#:include "common.fypp" 
module stdlib_blas
  use stdlib_linalg_constants
  use stdlib_linalg_blas_aux
  implicit none(type,external)

interface 
     module pure complex(sp) function stdlib_cdotc(n,cx,incx,cy,incy)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, incy, n
           complex(sp), intent(in) :: cx(*), cy(*)
     end function stdlib_cdotc

     module pure complex(dp) function stdlib_zdotc(n,zx,incx,zy,incy)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, incy, n
           complex(dp), intent(in) :: zx(*), zy(*)
     end function stdlib_zdotc

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure complex(${ck}$) function stdlib_${ci}$dotc(n,zx,incx,zy,incy)
     use stdlib_blas_constants_${ck}$
           integer(ilp), intent(in) :: incx, incy, n
           complex(${ck}$), intent(in) :: zx(*), zy(*)
     end function stdlib_${ci}$dotc

#:endif
#:endfor

end interface 


interface 
     module pure real(dp) function stdlib_dzasum(n,zx,incx)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, n
           complex(dp), intent(in) :: zx(*)
     end function stdlib_dzasum

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure real(${rk}$) function stdlib_${ri}$zasum(n,zx,incx)
     use stdlib_blas_constants_${rk}$
           integer(ilp), intent(in) :: incx, n
           complex(${rk}$), intent(in) :: zx(*)
     end function stdlib_${ri}$zasum

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_saxpy(n,sa,sx,incx,sy,incy)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: sa
           integer(ilp), intent(in) :: incx, incy, n
           real(sp), intent(in) :: sx(*)
           real(sp), intent(inout) :: sy(*)
     end subroutine stdlib_saxpy

     module pure subroutine stdlib_daxpy(n,da,dx,incx,dy,incy)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: da
           integer(ilp), intent(in) :: incx, incy, n
           real(dp), intent(in) :: dx(*)
           real(dp), intent(inout) :: dy(*)
     end subroutine stdlib_daxpy

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$axpy(n,da,dx,incx,dy,incy)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: da
           integer(ilp), intent(in) :: incx, incy, n
           real(${rk}$), intent(in) :: dx(*)
           real(${rk}$), intent(inout) :: dy(*)
     end subroutine stdlib_${ri}$axpy

#:endif
#:endfor

     module pure subroutine stdlib_caxpy(n,ca,cx,incx,cy,incy)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: ca
           integer(ilp), intent(in) :: incx, incy, n
           complex(sp), intent(in) :: cx(*)
           complex(sp), intent(inout) :: cy(*)
     end subroutine stdlib_caxpy

     module pure subroutine stdlib_zaxpy(n,za,zx,incx,zy,incy)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: za
           integer(ilp), intent(in) :: incx, incy, n
           complex(dp), intent(in) :: zx(*)
           complex(dp), intent(inout) :: zy(*)
     end subroutine stdlib_zaxpy

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$axpy(n,za,zx,incx,zy,incy)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: za
           integer(ilp), intent(in) :: incx, incy, n
           complex(${ck}$), intent(in) :: zx(*)
           complex(${ck}$), intent(inout) :: zy(*)
     end subroutine stdlib_${ci}$axpy

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_zdscal(n,da,zx,incx)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: da
           integer(ilp), intent(in) :: incx, n
           complex(dp), intent(inout) :: zx(*)
     end subroutine stdlib_zdscal

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$dscal(n,da,zx,incx)
     use stdlib_blas_constants_${ck}$
           real(${ck}$), intent(in) :: da
           integer(ilp), intent(in) :: incx, n
           complex(${ck}$), intent(inout) :: zx(*)
     end subroutine stdlib_${ci}$dscal

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_zdrot( n, zx, incx, zy, incy, c, s )
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, incy, n
           real(dp), intent(in) :: c, s
           complex(dp), intent(inout) :: zx(*), zy(*)
     end subroutine stdlib_zdrot

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$drot( n, zx, incx, zy, incy, c, s )
     use stdlib_blas_constants_${ck}$
           integer(ilp), intent(in) :: incx, incy, n
           real(${ck}$), intent(in) :: c, s
           complex(${ck}$), intent(inout) :: zx(*), zy(*)
     end subroutine stdlib_${ci}$drot

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_scopy(n,sx,incx,sy,incy)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, incy, n
           real(sp), intent(in) :: sx(*)
           real(sp), intent(out) :: sy(*)
     end subroutine stdlib_scopy

     module pure subroutine stdlib_dcopy(n,dx,incx,dy,incy)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, incy, n
           real(dp), intent(in) :: dx(*)
           real(dp), intent(out) :: dy(*)
     end subroutine stdlib_dcopy

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$copy(n,dx,incx,dy,incy)
     use stdlib_blas_constants_${rk}$
           integer(ilp), intent(in) :: incx, incy, n
           real(${rk}$), intent(in) :: dx(*)
           real(${rk}$), intent(out) :: dy(*)
     end subroutine stdlib_${ri}$copy

#:endif
#:endfor

     module pure subroutine stdlib_ccopy(n,cx,incx,cy,incy)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, incy, n
           complex(sp), intent(in) :: cx(*)
           complex(sp), intent(out) :: cy(*)
     end subroutine stdlib_ccopy

     module pure subroutine stdlib_zcopy(n,zx,incx,zy,incy)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, incy, n
           complex(dp), intent(in) :: zx(*)
           complex(dp), intent(out) :: zy(*)
     end subroutine stdlib_zcopy

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$copy(n,zx,incx,zy,incy)
     use stdlib_blas_constants_${ck}$
           integer(ilp), intent(in) :: incx, incy, n
           complex(${ck}$), intent(in) :: zx(*)
           complex(${ck}$), intent(out) :: zy(*)
     end subroutine stdlib_${ci}$copy

#:endif
#:endfor

end interface 


interface 
     module pure real(dp) function stdlib_dsdot(n,sx,incx,sy,incy)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, incy, n
           real(sp), intent(in) :: sx(*), sy(*)
     end function stdlib_dsdot

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure real(${rk}$) function stdlib_${ri}$sdot(n,sx,incx,sy,incy)
     use stdlib_blas_constants_${rk}$
           integer(ilp), intent(in) :: incx, incy, n
           real(dp), intent(in) :: sx(*), sy(*)
     end function stdlib_${ri}$sdot

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_srot(n,sx,incx,sy,incy,c,s)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: c, s
           integer(ilp), intent(in) :: incx, incy, n
           real(sp), intent(inout) :: sx(*), sy(*)
     end subroutine stdlib_srot

     module pure subroutine stdlib_drot(n,dx,incx,dy,incy,c,s)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: c, s
           integer(ilp), intent(in) :: incx, incy, n
           real(dp), intent(inout) :: dx(*), dy(*)
     end subroutine stdlib_drot

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$rot(n,dx,incx,dy,incy,c,s)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: c, s
           integer(ilp), intent(in) :: incx, incy, n
           real(${rk}$), intent(inout) :: dx(*), dy(*)
     end subroutine stdlib_${ri}$rot

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_srotmg(sd1,sd2,sx1,sy1,sparam)
     use stdlib_blas_constants_sp
           real(sp), intent(inout) :: sd1, sd2, sx1
           real(sp), intent(in) :: sy1
           real(sp), intent(out) :: sparam(5)
     end subroutine stdlib_srotmg

     module pure subroutine stdlib_drotmg(dd1,dd2,dx1,dy1,dparam)
     use stdlib_blas_constants_dp
           real(dp), intent(inout) :: dd1, dd2, dx1
           real(dp), intent(in) :: dy1
           real(dp), intent(out) :: dparam(5)
     end subroutine stdlib_drotmg

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$rotmg(dd1,dd2,dx1,dy1,dparam)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(inout) :: dd1, dd2, dx1
           real(${rk}$), intent(in) :: dy1
           real(${rk}$), intent(out) :: dparam(5)
     end subroutine stdlib_${ri}$rotmg

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_sswap(n,sx,incx,sy,incy)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, incy, n
           real(sp), intent(inout) :: sx(*), sy(*)
     end subroutine stdlib_sswap

     module pure subroutine stdlib_dswap(n,dx,incx,dy,incy)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, incy, n
           real(dp), intent(inout) :: dx(*), dy(*)
     end subroutine stdlib_dswap

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$swap(n,dx,incx,dy,incy)
     use stdlib_blas_constants_${rk}$
           integer(ilp), intent(in) :: incx, incy, n
           real(${rk}$), intent(inout) :: dx(*), dy(*)
     end subroutine stdlib_${ri}$swap

#:endif
#:endfor

     module pure subroutine stdlib_cswap(n,cx,incx,cy,incy)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, incy, n
           complex(sp), intent(inout) :: cx(*), cy(*)
     end subroutine stdlib_cswap

     module pure subroutine stdlib_zswap(n,zx,incx,zy,incy)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, incy, n
           complex(dp), intent(inout) :: zx(*), zy(*)
     end subroutine stdlib_zswap

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$swap(n,zx,incx,zy,incy)
     use stdlib_blas_constants_${ck}$
           integer(ilp), intent(in) :: incx, incy, n
           complex(${ck}$), intent(inout) :: zx(*), zy(*)
     end subroutine stdlib_${ci}$swap

#:endif
#:endfor

end interface 


interface 
     module pure real(sp) function stdlib_snrm2( n, x, incx )
     use stdlib_blas_constants_sp
        integer(ilp), intent(in) :: incx, n
        real(sp), intent(in) :: x(*)
     end function stdlib_snrm2

     module pure real(dp) function stdlib_dnrm2( n, x, incx )
     use stdlib_blas_constants_dp
        integer(ilp), intent(in) :: incx, n
        real(dp), intent(in) :: x(*)
     end function stdlib_dnrm2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure real(${rk}$) function stdlib_${ri}$nrm2( n, x, incx )
     use stdlib_blas_constants_${rk}$
        integer(ilp), intent(in) :: incx, n
        real(${rk}$), intent(in) :: x(*)
     end function stdlib_${ri}$nrm2

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_csrot( n, cx, incx, cy, incy, c, s )
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, incy, n
           real(sp), intent(in) :: c, s
           complex(sp), intent(inout) :: cx(*), cy(*)
     end subroutine stdlib_csrot

end interface 


interface 
     module pure subroutine stdlib_sscal(n,sa,sx,incx)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: sa
           integer(ilp), intent(in) :: incx, n
           real(sp), intent(inout) :: sx(*)
     end subroutine stdlib_sscal

     module pure subroutine stdlib_dscal(n,da,dx,incx)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: da
           integer(ilp), intent(in) :: incx, n
           real(dp), intent(inout) :: dx(*)
     end subroutine stdlib_dscal

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$scal(n,da,dx,incx)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: da
           integer(ilp), intent(in) :: incx, n
           real(${rk}$), intent(inout) :: dx(*)
     end subroutine stdlib_${ri}$scal

#:endif
#:endfor

     module pure subroutine stdlib_cscal(n,ca,cx,incx)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: ca
           integer(ilp), intent(in) :: incx, n
           complex(sp), intent(inout) :: cx(*)
     end subroutine stdlib_cscal

     module pure subroutine stdlib_zscal(n,za,zx,incx)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: za
           integer(ilp), intent(in) :: incx, n
           complex(dp), intent(inout) :: zx(*)
     end subroutine stdlib_zscal

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$scal(n,za,zx,incx)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: za
           integer(ilp), intent(in) :: incx, n
           complex(${ck}$), intent(inout) :: zx(*)
     end subroutine stdlib_${ci}$scal

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_srotg( a, b, c, s )
     use stdlib_blas_constants_sp
        real(sp), intent(inout) :: a, b
        real(sp), intent(out) :: c, s
     end subroutine stdlib_srotg

     module pure subroutine stdlib_drotg( a, b, c, s )
     use stdlib_blas_constants_dp
        real(dp), intent(inout) :: a, b
        real(dp), intent(out) :: c, s
     end subroutine stdlib_drotg

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$rotg( a, b, c, s )
     use stdlib_blas_constants_${rk}$
        real(${rk}$), intent(inout) :: a, b
        real(${rk}$), intent(out) :: c, s
     end subroutine stdlib_${ri}$rotg

#:endif
#:endfor

     module pure subroutine stdlib_crotg( a, b, c, s )
     use stdlib_blas_constants_sp
        real(sp), intent(out) :: c
        complex(sp), intent(inout) :: a
        complex(sp), intent(in) :: b
        complex(sp), intent(out) :: s
     end subroutine stdlib_crotg

     module pure subroutine stdlib_zrotg( a, b, c, s )
     use stdlib_blas_constants_dp
        real(dp), intent(out) :: c
        complex(dp), intent(inout) :: a
        complex(dp), intent(in) :: b
        complex(dp), intent(out) :: s
     end subroutine stdlib_zrotg

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$rotg( a, b, c, s )
     use stdlib_blas_constants_${ck}$
        real(${ck}$), intent(out) :: c
        complex(${ck}$), intent(inout) :: a
        complex(${ck}$), intent(in) :: b
        complex(${ck}$), intent(out) :: s
     end subroutine stdlib_${ci}$rotg

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_srotm(n,sx,incx,sy,incy,sparam)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, incy, n
           real(sp), intent(in) :: sparam(5)
           real(sp), intent(inout) :: sx(*), sy(*)
     end subroutine stdlib_srotm

     module pure subroutine stdlib_drotm(n,dx,incx,dy,incy,dparam)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, incy, n
           real(dp), intent(in) :: dparam(5)
           real(dp), intent(inout) :: dx(*), dy(*)
     end subroutine stdlib_drotm

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$rotm(n,dx,incx,dy,incy,dparam)
     use stdlib_blas_constants_${rk}$
           integer(ilp), intent(in) :: incx, incy, n
           real(${rk}$), intent(in) :: dparam(5)
           real(${rk}$), intent(inout) :: dx(*), dy(*)
     end subroutine stdlib_${ri}$rotm

#:endif
#:endfor

end interface 


interface 
     module pure real(sp) function stdlib_scasum(n,cx,incx)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, n
           complex(sp), intent(in) :: cx(*)
     end function stdlib_scasum

end interface 


interface 
     module pure complex(sp) function stdlib_cdotu(n,cx,incx,cy,incy)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, incy, n
           complex(sp), intent(in) :: cx(*), cy(*)
     end function stdlib_cdotu

     module pure complex(dp) function stdlib_zdotu(n,zx,incx,zy,incy)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, incy, n
           complex(dp), intent(in) :: zx(*), zy(*)
     end function stdlib_zdotu

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure complex(${ck}$) function stdlib_${ci}$dotu(n,zx,incx,zy,incy)
     use stdlib_blas_constants_${ck}$
           integer(ilp), intent(in) :: incx, incy, n
           complex(${ck}$), intent(in) :: zx(*), zy(*)
     end function stdlib_${ci}$dotu

#:endif
#:endfor

end interface 


interface 
     module pure real(sp) function stdlib_scnrm2( n, x, incx )
     use stdlib_blas_constants_sp
        integer(ilp), intent(in) :: incx, n
        complex(sp), intent(in) :: x(*)
     end function stdlib_scnrm2

end interface 


interface 
     module pure real(sp) function stdlib_sasum(n,sx,incx)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, n
           real(sp), intent(in) :: sx(*)
     end function stdlib_sasum

     module pure real(dp) function stdlib_dasum(n,dx,incx)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, n
           real(dp), intent(in) :: dx(*)
     end function stdlib_dasum

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure real(${rk}$) function stdlib_${ri}$asum(n,dx,incx)
     use stdlib_blas_constants_${rk}$
           integer(ilp), intent(in) :: incx, n
           real(${rk}$), intent(in) :: dx(*)
     end function stdlib_${ri}$asum

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_csscal(n,sa,cx,incx)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: sa
           integer(ilp), intent(in) :: incx, n
           complex(sp), intent(inout) :: cx(*)
     end subroutine stdlib_csscal

end interface 


interface 
     module pure real(dp) function stdlib_dznrm2( n, x, incx )
     use stdlib_blas_constants_dp
        integer(ilp), intent(in) :: incx, n
        complex(dp), intent(in) :: x(*)
     end function stdlib_dznrm2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure real(${rk}$) function stdlib_${ri}$znrm2( n, x, incx )
     use stdlib_blas_constants_${rk}$
        integer(ilp), intent(in) :: incx, n
        complex(${rk}$), intent(in) :: x(*)
     end function stdlib_${ri}$znrm2

#:endif
#:endfor

end interface 


interface 
     module pure real(sp) function stdlib_sdot(n,sx,incx,sy,incy)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, incy, n
           real(sp), intent(in) :: sx(*), sy(*)
     end function stdlib_sdot

     module pure real(dp) function stdlib_ddot(n,dx,incx,dy,incy)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, incy, n
           real(dp), intent(in) :: dx(*), dy(*)
     end function stdlib_ddot

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure real(${rk}$) function stdlib_${ri}$dot(n,dx,incx,dy,incy)
     use stdlib_blas_constants_${rk}$
           integer(ilp), intent(in) :: incx, incy, n
           real(${rk}$), intent(in) :: dx(*), dy(*)
     end function stdlib_${ri}$dot

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_sger(m,n,alpha,x,incx,y,incy,a,lda)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, lda, m, n
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(in) :: x(*), y(*)
     end subroutine stdlib_sger

     module pure subroutine stdlib_dger(m,n,alpha,x,incx,y,incy,a,lda)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, lda, m, n
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(in) :: x(*), y(*)
     end subroutine stdlib_dger

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$ger(m,n,alpha,x,incx,y,incy,a,lda)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, lda, m, n
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: x(*), y(*)
     end subroutine stdlib_${ri}$ger

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_cher(uplo,n,alpha,x,incx,a,lda)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, lda, n
           character, intent(in) :: uplo
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: x(*)
     end subroutine stdlib_cher

     module pure subroutine stdlib_zher(uplo,n,alpha,x,incx,a,lda)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, lda, n
           character, intent(in) :: uplo
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(in) :: x(*)
     end subroutine stdlib_zher

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$her(uplo,n,alpha,x,incx,a,lda)
     use stdlib_blas_constants_${ck}$
           real(${ck}$), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, lda, n
           character, intent(in) :: uplo
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(in) :: x(*)
     end subroutine stdlib_${ci}$her

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_sgemv(trans,m,n,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, m, n
           character, intent(in) :: trans
           real(sp), intent(in) :: a(lda,*), x(*)
           real(sp), intent(inout) :: y(*)
     end subroutine stdlib_sgemv

     module pure subroutine stdlib_dgemv(trans,m,n,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, m, n
           character, intent(in) :: trans
           real(dp), intent(in) :: a(lda,*), x(*)
           real(dp), intent(inout) :: y(*)
     end subroutine stdlib_dgemv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$gemv(trans,m,n,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, m, n
           character, intent(in) :: trans
           real(${rk}$), intent(in) :: a(lda,*), x(*)
           real(${rk}$), intent(inout) :: y(*)
     end subroutine stdlib_${ri}$gemv

#:endif
#:endfor

     module pure subroutine stdlib_cgemv(trans,m,n,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, m, n
           character, intent(in) :: trans
           complex(sp), intent(in) :: a(lda,*), x(*)
           complex(sp), intent(inout) :: y(*)
     end subroutine stdlib_cgemv

     module pure subroutine stdlib_zgemv(trans,m,n,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, m, n
           character, intent(in) :: trans
           complex(dp), intent(in) :: a(lda,*), x(*)
           complex(dp), intent(inout) :: y(*)
     end subroutine stdlib_zgemv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$gemv(trans,m,n,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, m, n
           character, intent(in) :: trans
           complex(${ck}$), intent(in) :: a(lda,*), x(*)
           complex(${ck}$), intent(inout) :: y(*)
     end subroutine stdlib_${ci}$gemv

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_cgerc(m,n,alpha,x,incx,y,incy,a,lda)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, lda, m, n
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: x(*), y(*)
     end subroutine stdlib_cgerc

     module pure subroutine stdlib_zgerc(m,n,alpha,x,incx,y,incy,a,lda)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, lda, m, n
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(in) :: x(*), y(*)
     end subroutine stdlib_zgerc

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$gerc(m,n,alpha,x,incx,y,incy,a,lda)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, lda, m, n
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(in) :: x(*), y(*)
     end subroutine stdlib_${ci}$gerc

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_cgeru(m,n,alpha,x,incx,y,incy,a,lda)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, lda, m, n
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: x(*), y(*)
     end subroutine stdlib_cgeru

     module pure subroutine stdlib_zgeru(m,n,alpha,x,incx,y,incy,a,lda)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, lda, m, n
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(in) :: x(*), y(*)
     end subroutine stdlib_zgeru

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$geru(m,n,alpha,x,incx,y,incy,a,lda)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, lda, m, n
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(in) :: x(*), y(*)
     end subroutine stdlib_${ci}$geru

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_chemv(uplo,n,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, n
           character, intent(in) :: uplo
           complex(sp), intent(in) :: a(lda,*), x(*)
           complex(sp), intent(inout) :: y(*)
     end subroutine stdlib_chemv

     module pure subroutine stdlib_zhemv(uplo,n,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, n
           character, intent(in) :: uplo
           complex(dp), intent(in) :: a(lda,*), x(*)
           complex(dp), intent(inout) :: y(*)
     end subroutine stdlib_zhemv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hemv(uplo,n,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, n
           character, intent(in) :: uplo
           complex(${ck}$), intent(in) :: a(lda,*), x(*)
           complex(${ck}$), intent(inout) :: y(*)
     end subroutine stdlib_${ci}$hemv

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_cher2(uplo,n,alpha,x,incx,y,incy,a,lda)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, lda, n
           character, intent(in) :: uplo
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: x(*), y(*)
     end subroutine stdlib_cher2

     module pure subroutine stdlib_zher2(uplo,n,alpha,x,incx,y,incy,a,lda)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, lda, n
           character, intent(in) :: uplo
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(in) :: x(*), y(*)
     end subroutine stdlib_zher2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$her2(uplo,n,alpha,x,incx,y,incy,a,lda)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, lda, n
           character, intent(in) :: uplo
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(in) :: x(*), y(*)
     end subroutine stdlib_${ci}$her2

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_sgbmv(trans,m,n,kl,ku,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, kl, ku, lda, m, n
           character, intent(in) :: trans
           real(sp), intent(in) :: a(lda,*), x(*)
           real(sp), intent(inout) :: y(*)
     end subroutine stdlib_sgbmv

     module pure subroutine stdlib_dgbmv(trans,m,n,kl,ku,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, kl, ku, lda, m, n
           character, intent(in) :: trans
           real(dp), intent(in) :: a(lda,*), x(*)
           real(dp), intent(inout) :: y(*)
     end subroutine stdlib_dgbmv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$gbmv(trans,m,n,kl,ku,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, kl, ku, lda, m, n
           character, intent(in) :: trans
           real(${rk}$), intent(in) :: a(lda,*), x(*)
           real(${rk}$), intent(inout) :: y(*)
     end subroutine stdlib_${ri}$gbmv

#:endif
#:endfor

     module pure subroutine stdlib_cgbmv(trans,m,n,kl,ku,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, kl, ku, lda, m, n
           character, intent(in) :: trans
           complex(sp), intent(in) :: a(lda,*), x(*)
           complex(sp), intent(inout) :: y(*)
     end subroutine stdlib_cgbmv

     module pure subroutine stdlib_zgbmv(trans,m,n,kl,ku,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, kl, ku, lda, m, n
           character, intent(in) :: trans
           complex(dp), intent(in) :: a(lda,*), x(*)
           complex(dp), intent(inout) :: y(*)
     end subroutine stdlib_zgbmv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$gbmv(trans,m,n,kl,ku,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, kl, ku, lda, m, n
           character, intent(in) :: trans
           complex(${ck}$), intent(in) :: a(lda,*), x(*)
           complex(${ck}$), intent(inout) :: y(*)
     end subroutine stdlib_${ci}$gbmv

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_chbmv(uplo,n,k,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, k, lda, n
           character, intent(in) :: uplo
           complex(sp), intent(in) :: a(lda,*), x(*)
           complex(sp), intent(inout) :: y(*)
     end subroutine stdlib_chbmv

     module pure subroutine stdlib_zhbmv(uplo,n,k,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, k, lda, n
           character, intent(in) :: uplo
           complex(dp), intent(in) :: a(lda,*), x(*)
           complex(dp), intent(inout) :: y(*)
     end subroutine stdlib_zhbmv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hbmv(uplo,n,k,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, k, lda, n
           character, intent(in) :: uplo
           complex(${ck}$), intent(in) :: a(lda,*), x(*)
           complex(${ck}$), intent(inout) :: y(*)
     end subroutine stdlib_${ci}$hbmv

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_ssyr2(uplo,n,alpha,x,incx,y,incy,a,lda)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, lda, n
           character, intent(in) :: uplo
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(in) :: x(*), y(*)
     end subroutine stdlib_ssyr2

     module pure subroutine stdlib_dsyr2(uplo,n,alpha,x,incx,y,incy,a,lda)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, lda, n
           character, intent(in) :: uplo
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(in) :: x(*), y(*)
     end subroutine stdlib_dsyr2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$syr2(uplo,n,alpha,x,incx,y,incy,a,lda)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, lda, n
           character, intent(in) :: uplo
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: x(*), y(*)
     end subroutine stdlib_${ri}$syr2

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_ssyr(uplo,n,alpha,x,incx,a,lda)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, lda, n
           character, intent(in) :: uplo
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(in) :: x(*)
     end subroutine stdlib_ssyr

     module pure subroutine stdlib_dsyr(uplo,n,alpha,x,incx,a,lda)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, lda, n
           character, intent(in) :: uplo
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(in) :: x(*)
     end subroutine stdlib_dsyr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$syr(uplo,n,alpha,x,incx,a,lda)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, lda, n
           character, intent(in) :: uplo
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: x(*)
     end subroutine stdlib_${ri}$syr

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_ssymv(uplo,n,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, n
           character, intent(in) :: uplo
           real(sp), intent(in) :: a(lda,*), x(*)
           real(sp), intent(inout) :: y(*)
     end subroutine stdlib_ssymv

     module pure subroutine stdlib_dsymv(uplo,n,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, n
           character, intent(in) :: uplo
           real(dp), intent(in) :: a(lda,*), x(*)
           real(dp), intent(inout) :: y(*)
     end subroutine stdlib_dsymv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$symv(uplo,n,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, n
           character, intent(in) :: uplo
           real(${rk}$), intent(in) :: a(lda,*), x(*)
           real(${rk}$), intent(inout) :: y(*)
     end subroutine stdlib_${ri}$symv

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_chpr2(uplo,n,alpha,x,incx,y,incy,ap)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, n
           character, intent(in) :: uplo
           complex(sp), intent(inout) :: ap(*)
           complex(sp), intent(in) :: x(*), y(*)
     end subroutine stdlib_chpr2

     module pure subroutine stdlib_zhpr2(uplo,n,alpha,x,incx,y,incy,ap)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, n
           character, intent(in) :: uplo
           complex(dp), intent(inout) :: ap(*)
           complex(dp), intent(in) :: x(*), y(*)
     end subroutine stdlib_zhpr2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hpr2(uplo,n,alpha,x,incx,y,incy,ap)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, n
           character, intent(in) :: uplo
           complex(${ck}$), intent(inout) :: ap(*)
           complex(${ck}$), intent(in) :: x(*), y(*)
     end subroutine stdlib_${ci}$hpr2

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_sspr(uplo,n,alpha,x,incx,ap)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, n
           character, intent(in) :: uplo
           real(sp), intent(inout) :: ap(*)
           real(sp), intent(in) :: x(*)
     end subroutine stdlib_sspr

     module pure subroutine stdlib_dspr(uplo,n,alpha,x,incx,ap)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, n
           character, intent(in) :: uplo
           real(dp), intent(inout) :: ap(*)
           real(dp), intent(in) :: x(*)
     end subroutine stdlib_dspr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$spr(uplo,n,alpha,x,incx,ap)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, n
           character, intent(in) :: uplo
           real(${rk}$), intent(inout) :: ap(*)
           real(${rk}$), intent(in) :: x(*)
     end subroutine stdlib_${ri}$spr

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_sspmv(uplo,n,alpha,ap,x,incx,beta,y,incy)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, n
           character, intent(in) :: uplo
           real(sp), intent(in) :: ap(*), x(*)
           real(sp), intent(inout) :: y(*)
     end subroutine stdlib_sspmv

     module pure subroutine stdlib_dspmv(uplo,n,alpha,ap,x,incx,beta,y,incy)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, n
           character, intent(in) :: uplo
           real(dp), intent(in) :: ap(*), x(*)
           real(dp), intent(inout) :: y(*)
     end subroutine stdlib_dspmv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$spmv(uplo,n,alpha,ap,x,incx,beta,y,incy)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, n
           character, intent(in) :: uplo
           real(${rk}$), intent(in) :: ap(*), x(*)
           real(${rk}$), intent(inout) :: y(*)
     end subroutine stdlib_${ri}$spmv

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_ssbmv(uplo,n,k,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, k, lda, n
           character, intent(in) :: uplo
           real(sp), intent(in) :: a(lda,*), x(*)
           real(sp), intent(inout) :: y(*)
     end subroutine stdlib_ssbmv

     module pure subroutine stdlib_dsbmv(uplo,n,k,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, k, lda, n
           character, intent(in) :: uplo
           real(dp), intent(in) :: a(lda,*), x(*)
           real(dp), intent(inout) :: y(*)
     end subroutine stdlib_dsbmv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sbmv(uplo,n,k,alpha,a,lda,x,incx,beta,y,incy)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, k, lda, n
           character, intent(in) :: uplo
           real(${rk}$), intent(in) :: a(lda,*), x(*)
           real(${rk}$), intent(inout) :: y(*)
     end subroutine stdlib_${ri}$sbmv

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_chpr(uplo,n,alpha,x,incx,ap)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, n
           character, intent(in) :: uplo
           complex(sp), intent(inout) :: ap(*)
           complex(sp), intent(in) :: x(*)
     end subroutine stdlib_chpr

     module pure subroutine stdlib_zhpr(uplo,n,alpha,x,incx,ap)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, n
           character, intent(in) :: uplo
           complex(dp), intent(inout) :: ap(*)
           complex(dp), intent(in) :: x(*)
     end subroutine stdlib_zhpr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hpr(uplo,n,alpha,x,incx,ap)
     use stdlib_blas_constants_${ck}$
           real(${ck}$), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, n
           character, intent(in) :: uplo
           complex(${ck}$), intent(inout) :: ap(*)
           complex(${ck}$), intent(in) :: x(*)
     end subroutine stdlib_${ci}$hpr

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_sspr2(uplo,n,alpha,x,incx,y,incy,ap)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, n
           character, intent(in) :: uplo
           real(sp), intent(inout) :: ap(*)
           real(sp), intent(in) :: x(*), y(*)
     end subroutine stdlib_sspr2

     module pure subroutine stdlib_dspr2(uplo,n,alpha,x,incx,y,incy,ap)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, n
           character, intent(in) :: uplo
           real(dp), intent(inout) :: ap(*)
           real(dp), intent(in) :: x(*), y(*)
     end subroutine stdlib_dspr2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$spr2(uplo,n,alpha,x,incx,y,incy,ap)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: alpha
           integer(ilp), intent(in) :: incx, incy, n
           character, intent(in) :: uplo
           real(${rk}$), intent(inout) :: ap(*)
           real(${rk}$), intent(in) :: x(*), y(*)
     end subroutine stdlib_${ri}$spr2

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_chpmv(uplo,n,alpha,ap,x,incx,beta,y,incy)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, n
           character, intent(in) :: uplo
           complex(sp), intent(in) :: ap(*), x(*)
           complex(sp), intent(inout) :: y(*)
     end subroutine stdlib_chpmv

     module pure subroutine stdlib_zhpmv(uplo,n,alpha,ap,x,incx,beta,y,incy)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, n
           character, intent(in) :: uplo
           complex(dp), intent(in) :: ap(*), x(*)
           complex(dp), intent(inout) :: y(*)
     end subroutine stdlib_zhpmv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hpmv(uplo,n,alpha,ap,x,incx,beta,y,incy)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, n
           character, intent(in) :: uplo
           complex(${ck}$), intent(in) :: ap(*), x(*)
           complex(${ck}$), intent(inout) :: y(*)
     end subroutine stdlib_${ci}$hpmv

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_stpmv(uplo,trans,diag,n,ap,x,incx)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, n
           character, intent(in) :: diag, trans, uplo
           real(sp), intent(in) :: ap(*)
           real(sp), intent(inout) :: x(*)
     end subroutine stdlib_stpmv

     module pure subroutine stdlib_dtpmv(uplo,trans,diag,n,ap,x,incx)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, n
           character, intent(in) :: diag, trans, uplo
           real(dp), intent(in) :: ap(*)
           real(dp), intent(inout) :: x(*)
     end subroutine stdlib_dtpmv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$tpmv(uplo,trans,diag,n,ap,x,incx)
     use stdlib_blas_constants_${rk}$
           integer(ilp), intent(in) :: incx, n
           character, intent(in) :: diag, trans, uplo
           real(${rk}$), intent(in) :: ap(*)
           real(${rk}$), intent(inout) :: x(*)
     end subroutine stdlib_${ri}$tpmv

#:endif
#:endfor

     module pure subroutine stdlib_ctpmv(uplo,trans,diag,n,ap,x,incx)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, n
           character, intent(in) :: diag, trans, uplo
           complex(sp), intent(in) :: ap(*)
           complex(sp), intent(inout) :: x(*)
     end subroutine stdlib_ctpmv

     module pure subroutine stdlib_ztpmv(uplo,trans,diag,n,ap,x,incx)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, n
           character, intent(in) :: diag, trans, uplo
           complex(dp), intent(in) :: ap(*)
           complex(dp), intent(inout) :: x(*)
     end subroutine stdlib_ztpmv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$tpmv(uplo,trans,diag,n,ap,x,incx)
     use stdlib_blas_constants_${ck}$
           integer(ilp), intent(in) :: incx, n
           character, intent(in) :: diag, trans, uplo
           complex(${ck}$), intent(in) :: ap(*)
           complex(${ck}$), intent(inout) :: x(*)
     end subroutine stdlib_${ci}$tpmv

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_strsv(uplo,trans,diag,n,a,lda,x,incx)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, lda, n
           character, intent(in) :: diag, trans, uplo
           real(sp), intent(in) :: a(lda,*)
           real(sp), intent(inout) :: x(*)
     end subroutine stdlib_strsv

     module pure subroutine stdlib_dtrsv(uplo,trans,diag,n,a,lda,x,incx)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, lda, n
           character, intent(in) :: diag, trans, uplo
           real(dp), intent(in) :: a(lda,*)
           real(dp), intent(inout) :: x(*)
     end subroutine stdlib_dtrsv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$trsv(uplo,trans,diag,n,a,lda,x,incx)
     use stdlib_blas_constants_${rk}$
           integer(ilp), intent(in) :: incx, lda, n
           character, intent(in) :: diag, trans, uplo
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: x(*)
     end subroutine stdlib_${ri}$trsv

#:endif
#:endfor

     module pure subroutine stdlib_ctrsv(uplo,trans,diag,n,a,lda,x,incx)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, lda, n
           character, intent(in) :: diag, trans, uplo
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: x(*)
     end subroutine stdlib_ctrsv

     module pure subroutine stdlib_ztrsv(uplo,trans,diag,n,a,lda,x,incx)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, lda, n
           character, intent(in) :: diag, trans, uplo
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(inout) :: x(*)
     end subroutine stdlib_ztrsv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$trsv(uplo,trans,diag,n,a,lda,x,incx)
     use stdlib_blas_constants_${ck}$
           integer(ilp), intent(in) :: incx, lda, n
           character, intent(in) :: diag, trans, uplo
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(inout) :: x(*)
     end subroutine stdlib_${ci}$trsv

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_stbmv(uplo,trans,diag,n,k,a,lda,x,incx)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, k, lda, n
           character, intent(in) :: diag, trans, uplo
           real(sp), intent(in) :: a(lda,*)
           real(sp), intent(inout) :: x(*)
     end subroutine stdlib_stbmv

     module pure subroutine stdlib_dtbmv(uplo,trans,diag,n,k,a,lda,x,incx)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, k, lda, n
           character, intent(in) :: diag, trans, uplo
           real(dp), intent(in) :: a(lda,*)
           real(dp), intent(inout) :: x(*)
     end subroutine stdlib_dtbmv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$tbmv(uplo,trans,diag,n,k,a,lda,x,incx)
     use stdlib_blas_constants_${rk}$
           integer(ilp), intent(in) :: incx, k, lda, n
           character, intent(in) :: diag, trans, uplo
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: x(*)
     end subroutine stdlib_${ri}$tbmv

#:endif
#:endfor

     module pure subroutine stdlib_ctbmv(uplo,trans,diag,n,k,a,lda,x,incx)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, k, lda, n
           character, intent(in) :: diag, trans, uplo
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: x(*)
     end subroutine stdlib_ctbmv

     module pure subroutine stdlib_ztbmv(uplo,trans,diag,n,k,a,lda,x,incx)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, k, lda, n
           character, intent(in) :: diag, trans, uplo
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(inout) :: x(*)
     end subroutine stdlib_ztbmv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$tbmv(uplo,trans,diag,n,k,a,lda,x,incx)
     use stdlib_blas_constants_${ck}$
           integer(ilp), intent(in) :: incx, k, lda, n
           character, intent(in) :: diag, trans, uplo
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(inout) :: x(*)
     end subroutine stdlib_${ci}$tbmv

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_stbsv(uplo,trans,diag,n,k,a,lda,x,incx)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, k, lda, n
           character, intent(in) :: diag, trans, uplo
           real(sp), intent(in) :: a(lda,*)
           real(sp), intent(inout) :: x(*)
     end subroutine stdlib_stbsv

     module pure subroutine stdlib_dtbsv(uplo,trans,diag,n,k,a,lda,x,incx)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, k, lda, n
           character, intent(in) :: diag, trans, uplo
           real(dp), intent(in) :: a(lda,*)
           real(dp), intent(inout) :: x(*)
     end subroutine stdlib_dtbsv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$tbsv(uplo,trans,diag,n,k,a,lda,x,incx)
     use stdlib_blas_constants_${rk}$
           integer(ilp), intent(in) :: incx, k, lda, n
           character, intent(in) :: diag, trans, uplo
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: x(*)
     end subroutine stdlib_${ri}$tbsv

#:endif
#:endfor

     module pure subroutine stdlib_ctbsv(uplo,trans,diag,n,k,a,lda,x,incx)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, k, lda, n
           character, intent(in) :: diag, trans, uplo
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: x(*)
     end subroutine stdlib_ctbsv

     module pure subroutine stdlib_ztbsv(uplo,trans,diag,n,k,a,lda,x,incx)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, k, lda, n
           character, intent(in) :: diag, trans, uplo
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(inout) :: x(*)
     end subroutine stdlib_ztbsv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$tbsv(uplo,trans,diag,n,k,a,lda,x,incx)
     use stdlib_blas_constants_${ck}$
           integer(ilp), intent(in) :: incx, k, lda, n
           character, intent(in) :: diag, trans, uplo
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(inout) :: x(*)
     end subroutine stdlib_${ci}$tbsv

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_strmv(uplo,trans,diag,n,a,lda,x,incx)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, lda, n
           character, intent(in) :: diag, trans, uplo
           real(sp), intent(in) :: a(lda,*)
           real(sp), intent(inout) :: x(*)
     end subroutine stdlib_strmv

     module pure subroutine stdlib_dtrmv(uplo,trans,diag,n,a,lda,x,incx)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, lda, n
           character, intent(in) :: diag, trans, uplo
           real(dp), intent(in) :: a(lda,*)
           real(dp), intent(inout) :: x(*)
     end subroutine stdlib_dtrmv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$trmv(uplo,trans,diag,n,a,lda,x,incx)
     use stdlib_blas_constants_${rk}$
           integer(ilp), intent(in) :: incx, lda, n
           character, intent(in) :: diag, trans, uplo
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: x(*)
     end subroutine stdlib_${ri}$trmv

#:endif
#:endfor

     module pure subroutine stdlib_ctrmv(uplo,trans,diag,n,a,lda,x,incx)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, lda, n
           character, intent(in) :: diag, trans, uplo
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: x(*)
     end subroutine stdlib_ctrmv

     module pure subroutine stdlib_ztrmv(uplo,trans,diag,n,a,lda,x,incx)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, lda, n
           character, intent(in) :: diag, trans, uplo
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(inout) :: x(*)
     end subroutine stdlib_ztrmv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$trmv(uplo,trans,diag,n,a,lda,x,incx)
     use stdlib_blas_constants_${ck}$
           integer(ilp), intent(in) :: incx, lda, n
           character, intent(in) :: diag, trans, uplo
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(inout) :: x(*)
     end subroutine stdlib_${ci}$trmv

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_stpsv(uplo,trans,diag,n,ap,x,incx)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, n
           character, intent(in) :: diag, trans, uplo
           real(sp), intent(in) :: ap(*)
           real(sp), intent(inout) :: x(*)
     end subroutine stdlib_stpsv

     module pure subroutine stdlib_dtpsv(uplo,trans,diag,n,ap,x,incx)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, n
           character, intent(in) :: diag, trans, uplo
           real(dp), intent(in) :: ap(*)
           real(dp), intent(inout) :: x(*)
     end subroutine stdlib_dtpsv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$tpsv(uplo,trans,diag,n,ap,x,incx)
     use stdlib_blas_constants_${rk}$
           integer(ilp), intent(in) :: incx, n
           character, intent(in) :: diag, trans, uplo
           real(${rk}$), intent(in) :: ap(*)
           real(${rk}$), intent(inout) :: x(*)
     end subroutine stdlib_${ri}$tpsv

#:endif
#:endfor

     module pure subroutine stdlib_ctpsv(uplo,trans,diag,n,ap,x,incx)
     use stdlib_blas_constants_sp
           integer(ilp), intent(in) :: incx, n
           character, intent(in) :: diag, trans, uplo
           complex(sp), intent(in) :: ap(*)
           complex(sp), intent(inout) :: x(*)
     end subroutine stdlib_ctpsv

     module pure subroutine stdlib_ztpsv(uplo,trans,diag,n,ap,x,incx)
     use stdlib_blas_constants_dp
           integer(ilp), intent(in) :: incx, n
           character, intent(in) :: diag, trans, uplo
           complex(dp), intent(in) :: ap(*)
           complex(dp), intent(inout) :: x(*)
     end subroutine stdlib_ztpsv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$tpsv(uplo,trans,diag,n,ap,x,incx)
     use stdlib_blas_constants_${ck}$
           integer(ilp), intent(in) :: incx, n
           character, intent(in) :: diag, trans, uplo
           complex(${ck}$), intent(in) :: ap(*)
           complex(${ck}$), intent(inout) :: x(*)
     end subroutine stdlib_${ci}$tpsv

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_chemm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: lda, ldb, ldc, m, n
           character, intent(in) :: side, uplo
           complex(sp), intent(in) :: a(lda,*), b(ldb,*)
           complex(sp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_chemm

     module pure subroutine stdlib_zhemm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: lda, ldb, ldc, m, n
           character, intent(in) :: side, uplo
           complex(dp), intent(in) :: a(lda,*), b(ldb,*)
           complex(dp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_zhemm

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hemm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: lda, ldb, ldc, m, n
           character, intent(in) :: side, uplo
           complex(${ck}$), intent(in) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(inout) :: c(ldc,*)
     end subroutine stdlib_${ci}$hemm

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_cher2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: alpha
           real(sp), intent(in) :: beta
           integer(ilp), intent(in) :: k, lda, ldb, ldc, n
           character, intent(in) :: trans, uplo
           complex(sp), intent(in) :: a(lda,*), b(ldb,*)
           complex(sp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_cher2k

     module pure subroutine stdlib_zher2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: alpha
           real(dp), intent(in) :: beta
           integer(ilp), intent(in) :: k, lda, ldb, ldc, n
           character, intent(in) :: trans, uplo
           complex(dp), intent(in) :: a(lda,*), b(ldb,*)
           complex(dp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_zher2k

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$her2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: alpha
           real(${ck}$), intent(in) :: beta
           integer(ilp), intent(in) :: k, lda, ldb, ldc, n
           character, intent(in) :: trans, uplo
           complex(${ck}$), intent(in) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(inout) :: c(ldc,*)
     end subroutine stdlib_${ci}$her2k

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_cherk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldc, n
           character, intent(in) :: trans, uplo
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_cherk

     module pure subroutine stdlib_zherk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldc, n
           character, intent(in) :: trans, uplo
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_zherk

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$herk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc)
     use stdlib_blas_constants_${ck}$
           real(${ck}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldc, n
           character, intent(in) :: trans, uplo
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(inout) :: c(ldc,*)
     end subroutine stdlib_${ci}$herk

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_sgemm(transa,transb,m,n,k,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldb, ldc, m, n
           character, intent(in) :: transa, transb
           real(sp), intent(in) :: a(lda,*), b(ldb,*)
           real(sp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_sgemm

     module pure subroutine stdlib_dgemm(transa,transb,m,n,k,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldb, ldc, m, n
           character, intent(in) :: transa, transb
           real(dp), intent(in) :: a(lda,*), b(ldb,*)
           real(dp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_dgemm

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$gemm(transa,transb,m,n,k,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldb, ldc, m, n
           character, intent(in) :: transa, transb
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(inout) :: c(ldc,*)
     end subroutine stdlib_${ri}$gemm

#:endif
#:endfor

     module pure subroutine stdlib_cgemm(transa,transb,m,n,k,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldb, ldc, m, n
           character, intent(in) :: transa, transb
           complex(sp), intent(in) :: a(lda,*), b(ldb,*)
           complex(sp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_cgemm

     module pure subroutine stdlib_zgemm(transa,transb,m,n,k,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldb, ldc, m, n
           character, intent(in) :: transa, transb
           complex(dp), intent(in) :: a(lda,*), b(ldb,*)
           complex(dp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_zgemm

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$gemm(transa,transb,m,n,k,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldb, ldc, m, n
           character, intent(in) :: transa, transb
           complex(${ck}$), intent(in) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(inout) :: c(ldc,*)
     end subroutine stdlib_${ci}$gemm

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_ssyr2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldb, ldc, n
           character, intent(in) :: trans, uplo
           real(sp), intent(in) :: a(lda,*), b(ldb,*)
           real(sp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_ssyr2k

     module pure subroutine stdlib_dsyr2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldb, ldc, n
           character, intent(in) :: trans, uplo
           real(dp), intent(in) :: a(lda,*), b(ldb,*)
           real(dp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_dsyr2k

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$syr2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldb, ldc, n
           character, intent(in) :: trans, uplo
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(inout) :: c(ldc,*)
     end subroutine stdlib_${ri}$syr2k

#:endif
#:endfor

     module pure subroutine stdlib_csyr2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldb, ldc, n
           character, intent(in) :: trans, uplo
           complex(sp), intent(in) :: a(lda,*), b(ldb,*)
           complex(sp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_csyr2k

     module pure subroutine stdlib_zsyr2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldb, ldc, n
           character, intent(in) :: trans, uplo
           complex(dp), intent(in) :: a(lda,*), b(ldb,*)
           complex(dp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_zsyr2k

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$syr2k(uplo,trans,n,k,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldb, ldc, n
           character, intent(in) :: trans, uplo
           complex(${ck}$), intent(in) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(inout) :: c(ldc,*)
     end subroutine stdlib_${ci}$syr2k

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_ssymm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: lda, ldb, ldc, m, n
           character, intent(in) :: side, uplo
           real(sp), intent(in) :: a(lda,*), b(ldb,*)
           real(sp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_ssymm

     module pure subroutine stdlib_dsymm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: lda, ldb, ldc, m, n
           character, intent(in) :: side, uplo
           real(dp), intent(in) :: a(lda,*), b(ldb,*)
           real(dp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_dsymm

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$symm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: lda, ldb, ldc, m, n
           character, intent(in) :: side, uplo
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(inout) :: c(ldc,*)
     end subroutine stdlib_${ri}$symm

#:endif
#:endfor

     module pure subroutine stdlib_csymm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: lda, ldb, ldc, m, n
           character, intent(in) :: side, uplo
           complex(sp), intent(in) :: a(lda,*), b(ldb,*)
           complex(sp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_csymm

     module pure subroutine stdlib_zsymm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: lda, ldb, ldc, m, n
           character, intent(in) :: side, uplo
           complex(dp), intent(in) :: a(lda,*), b(ldb,*)
           complex(dp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_zsymm

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$symm(side,uplo,m,n,alpha,a,lda,b,ldb,beta,c,ldc)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: lda, ldb, ldc, m, n
           character, intent(in) :: side, uplo
           complex(${ck}$), intent(in) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(inout) :: c(ldc,*)
     end subroutine stdlib_${ci}$symm

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_ssyrk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldc, n
           character, intent(in) :: trans, uplo
           real(sp), intent(in) :: a(lda,*)
           real(sp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_ssyrk

     module pure subroutine stdlib_dsyrk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldc, n
           character, intent(in) :: trans, uplo
           real(dp), intent(in) :: a(lda,*)
           real(dp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_dsyrk

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$syrk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldc, n
           character, intent(in) :: trans, uplo
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: c(ldc,*)
     end subroutine stdlib_${ri}$syrk

#:endif
#:endfor

     module pure subroutine stdlib_csyrk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldc, n
           character, intent(in) :: trans, uplo
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_csyrk

     module pure subroutine stdlib_zsyrk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldc, n
           character, intent(in) :: trans, uplo
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(inout) :: c(ldc,*)
     end subroutine stdlib_zsyrk

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$syrk(uplo,trans,n,k,alpha,a,lda,beta,c,ldc)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: k, lda, ldc, n
           character, intent(in) :: trans, uplo
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(inout) :: c(ldc,*)
     end subroutine stdlib_${ci}$syrk

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_strmm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha
           integer(ilp), intent(in) :: lda, ldb, m, n
           character, intent(in) :: diag, side, transa, uplo
           real(sp), intent(in) :: a(lda,*)
           real(sp), intent(inout) :: b(ldb,*)
     end subroutine stdlib_strmm

     module pure subroutine stdlib_dtrmm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha
           integer(ilp), intent(in) :: lda, ldb, m, n
           character, intent(in) :: diag, side, transa, uplo
           real(dp), intent(in) :: a(lda,*)
           real(dp), intent(inout) :: b(ldb,*)
     end subroutine stdlib_dtrmm

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$trmm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: alpha
           integer(ilp), intent(in) :: lda, ldb, m, n
           character, intent(in) :: diag, side, transa, uplo
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: b(ldb,*)
     end subroutine stdlib_${ri}$trmm

#:endif
#:endfor

     module pure subroutine stdlib_ctrmm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: alpha
           integer(ilp), intent(in) :: lda, ldb, m, n
           character, intent(in) :: diag, side, transa, uplo
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: b(ldb,*)
     end subroutine stdlib_ctrmm

     module pure subroutine stdlib_ztrmm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: alpha
           integer(ilp), intent(in) :: lda, ldb, m, n
           character, intent(in) :: diag, side, transa, uplo
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(inout) :: b(ldb,*)
     end subroutine stdlib_ztrmm

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$trmm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: alpha
           integer(ilp), intent(in) :: lda, ldb, m, n
           character, intent(in) :: diag, side, transa, uplo
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(inout) :: b(ldb,*)
     end subroutine stdlib_${ci}$trmm

#:endif
#:endfor

end interface 


interface 
     module pure subroutine stdlib_strsm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)
     use stdlib_blas_constants_sp
           real(sp), intent(in) :: alpha
           integer(ilp), intent(in) :: lda, ldb, m, n
           character, intent(in) :: diag, side, transa, uplo
           real(sp), intent(in) :: a(lda,*)
           real(sp), intent(inout) :: b(ldb,*)
     end subroutine stdlib_strsm

     module pure subroutine stdlib_dtrsm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)
     use stdlib_blas_constants_dp
           real(dp), intent(in) :: alpha
           integer(ilp), intent(in) :: lda, ldb, m, n
           character, intent(in) :: diag, side, transa, uplo
           real(dp), intent(in) :: a(lda,*)
           real(dp), intent(inout) :: b(ldb,*)
     end subroutine stdlib_dtrsm

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$trsm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)
     use stdlib_blas_constants_${rk}$
           real(${rk}$), intent(in) :: alpha
           integer(ilp), intent(in) :: lda, ldb, m, n
           character, intent(in) :: diag, side, transa, uplo
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: b(ldb,*)
     end subroutine stdlib_${ri}$trsm

#:endif
#:endfor

     module pure subroutine stdlib_ctrsm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)
     use stdlib_blas_constants_sp
           complex(sp), intent(in) :: alpha
           integer(ilp), intent(in) :: lda, ldb, m, n
           character, intent(in) :: diag, side, transa, uplo
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: b(ldb,*)
     end subroutine stdlib_ctrsm

     module pure subroutine stdlib_ztrsm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)
     use stdlib_blas_constants_dp
           complex(dp), intent(in) :: alpha
           integer(ilp), intent(in) :: lda, ldb, m, n
           character, intent(in) :: diag, side, transa, uplo
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(inout) :: b(ldb,*)
     end subroutine stdlib_ztrsm

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$trsm(side,uplo,transa,diag,m,n,alpha,a,lda,b,ldb)
     use stdlib_blas_constants_${ck}$
           complex(${ck}$), intent(in) :: alpha
           integer(ilp), intent(in) :: lda, ldb, m, n
           character, intent(in) :: diag, side, transa, uplo
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(inout) :: b(ldb,*)
     end subroutine stdlib_${ci}$trsm

#:endif
#:endfor

end interface 

end module stdlib_blas
