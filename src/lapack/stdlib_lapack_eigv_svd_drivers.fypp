#:include "common.fypp" 
submodule(stdlib_lapack) stdlib_lapack_eigv_svd_drivers
  implicit none(type,external)


  contains



     module subroutine stdlib_sgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
     numrank, iwork, liwork,work, lwork, rwork, lrwork, info )
     !! SGESVDQ computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N orthogonal matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
               
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: joba, jobp, jobr, jobu, jobv
           integer(ilp), intent(in) :: m, n, lda, ldu, ldv, liwork, lrwork
           integer(ilp), intent(out) :: numrank, info
           integer(ilp), intent(inout) :: lwork
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: u(ldu,*), v(ldv,*), work(*)
           real(sp), intent(out) :: s(*), rwork(*)
           integer(ilp), intent(out) :: iwork(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: ierr, iwoff, nr, n1, optratio, p, q
           integer(ilp) :: lwcon, lwqp3, lwrk_sgelqf, lwrk_sgesvd, lwrk_sgesvd2, lwrk_sgeqp3, &
           lwrk_sgeqrf, lwrk_sormlq, lwrk_sormqr, lwrk_sormqr2, lwlqf, lwqrf, lwsvd, lwsvd2, &
                     lworq, lworq2, lwunlq, minwrk, minwrk2, optwrk, optwrk2, iminwrk, rminwrk
           logical(lk) :: accla, acclm, acclh, ascaled, conda, dntwu, dntwv, lquery, lsvc0, lsvec,&
                      rowprm, rsvec, rtrans, wntua, wntuf, wntur, wntus, wntva, wntvr
           real(sp) :: big, epsln, rtmp, sconda, sfmin
           ! Local Arrays
           real(sp) :: rdummy(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           wntus  = stdlib_lsame( jobu, 'S' ) .or. stdlib_lsame( jobu, 'U' )
           wntur  = stdlib_lsame( jobu, 'R' )
           wntua  = stdlib_lsame( jobu, 'A' )
           wntuf  = stdlib_lsame( jobu, 'F' )
           lsvc0  = wntus .or. wntur .or. wntua
           lsvec  = lsvc0 .or. wntuf
           dntwu  = stdlib_lsame( jobu, 'N' )
           wntvr  = stdlib_lsame( jobv, 'R' )
           wntva  = stdlib_lsame( jobv, 'A' ) .or. stdlib_lsame( jobv, 'V' )
           rsvec  = wntvr .or. wntva
           dntwv  = stdlib_lsame( jobv, 'N' )
           accla  = stdlib_lsame( joba, 'A' )
           acclm  = stdlib_lsame( joba, 'M' )
           conda  = stdlib_lsame( joba, 'E' )
           acclh  = stdlib_lsame( joba, 'H' ) .or. conda
           rowprm = stdlib_lsame( jobp, 'P' )
           rtrans = stdlib_lsame( jobr, 'T' )
           if ( rowprm ) then
              if ( conda ) then
                 iminwrk = max( 1, n + m - 1 + n )
              else
                 iminwrk = max( 1, n + m - 1 )
              end if
              rminwrk = max( 2, m )
           else
              if ( conda ) then
                 iminwrk = max( 1, n + n )
              else
                 iminwrk = max( 1, n )
              end if
              rminwrk = 2
           end if
           lquery = (liwork == -1 .or. lwork == -1 .or. lrwork == -1)
           info  = 0
           if ( .not. ( accla .or. acclm .or. acclh ) ) then
              info = -1
           else if ( .not.( rowprm .or. stdlib_lsame( jobp, 'N' ) ) ) then
               info = -2
           else if ( .not.( rtrans .or. stdlib_lsame( jobr, 'N' ) ) ) then
               info = -3
           else if ( .not.( lsvec .or. dntwu ) ) then
              info = -4
           else if ( wntur .and. wntva ) then
              info = -5
           else if ( .not.( rsvec .or. dntwv )) then
              info = -5
           else if ( m<0 ) then
              info = -6
           else if ( ( n<0 ) .or. ( n>m ) ) then
              info = -7
           else if ( lda<max( 1, m ) ) then
              info = -9
           else if ( ldu<1 .or. ( lsvc0 .and. ldu<m ) .or.( wntuf .and. ldu<n ) ) then
              info = -12
           else if ( ldv<1 .or. ( rsvec .and. ldv<n ) .or.( conda .and. ldv<n ) ) then
              info = -14
           else if ( liwork < iminwrk .and. .not. lquery ) then
              info = -17
           end if
           if ( info == 0 ) then
              ! Compute The Minimal And The Optimal Workspace Lengths
              ! [[the expressions for computing the minimal and the optimal
              ! values of lwork are written with a lot of redundancy and
              ! can be simplified. however, this detailed form is easier for
              ! maintenance and modifications of the code.]]
              ! Minimal Workspace Length For Stdlib_Sgeqp3 Of An M X N Matrix
              lwqp3 = 3 * n + 1
              ! Minimal Workspace Length For Stdlib_Sormqr To Build Left Singular Vectors
              if ( wntus .or. wntur ) then
                  lworq  = max( n  , 1 )
              else if ( wntua ) then
                  lworq = max( m , 1 )
              end if
              ! Minimal Workspace Length For Stdlib_Spocon Of An N X N Matrix
              lwcon = 3 * n
              ! Stdlib_Sgesvd Of An N X N Matrix
              lwsvd = max( 5 * n, 1 )
              if ( lquery ) then
                  call stdlib_sgeqp3( m, n, a, lda, iwork, rdummy, rdummy, -1,ierr )
                  lwrk_sgeqp3 = int( rdummy(1),KIND=ilp)
                  if ( wntus .or. wntur ) then
                      call stdlib_sormqr( 'L', 'N', m, n, n, a, lda, rdummy, u,ldu, rdummy, -1, &
                                ierr )
                      lwrk_sormqr = int( rdummy(1),KIND=ilp)
                  else if ( wntua ) then
                      call stdlib_sormqr( 'L', 'N', m, m, n, a, lda, rdummy, u,ldu, rdummy, -1, &
                                ierr )
                      lwrk_sormqr = int( rdummy(1),KIND=ilp)
                  else
                      lwrk_sormqr = 0
                  end if
              end if
              minwrk = 2
              optwrk = 2
              if ( .not. (lsvec .or. rsvec )) then
                  ! Minimal And Optimal Sizes Of The Workspace If
                  ! only the singular values are requested
                  if ( conda ) then
                     minwrk = max( n+lwqp3, lwcon, lwsvd )
                  else
                     minwrk = max( n+lwqp3, lwsvd )
                  end if
                  if ( lquery ) then
                      call stdlib_sgesvd( 'N', 'N', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                ierr )
                      lwrk_sgesvd = int( rdummy(1),KIND=ilp)
                      if ( conda ) then
                         optwrk = max( n+lwrk_sgeqp3, n+lwcon, lwrk_sgesvd )
                      else
                         optwrk = max( n+lwrk_sgeqp3, lwrk_sgesvd )
                      end if
                  end if
              else if ( lsvec .and. (.not.rsvec) ) then
                  ! Minimal And Optimal Sizes Of The Workspace If The
                  ! singular values and the left singular vectors are requested
                  if ( conda ) then
                      minwrk = n + max( lwqp3, lwcon, lwsvd, lworq )
                  else
                      minwrk = n + max( lwqp3, lwsvd, lworq )
                  end if
                  if ( lquery ) then
                     if ( rtrans ) then
                        call stdlib_sgesvd( 'N', 'O', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                  ierr )
                     else
                        call stdlib_sgesvd( 'O', 'N', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                  ierr )
                     end if
                     lwrk_sgesvd = int( rdummy(1),KIND=ilp)
                     if ( conda ) then
                         optwrk = n + max( lwrk_sgeqp3, lwcon, lwrk_sgesvd,lwrk_sormqr )
                     else
                         optwrk = n + max( lwrk_sgeqp3, lwrk_sgesvd,lwrk_sormqr )
                     end if
                  end if
              else if ( rsvec .and. (.not.lsvec) ) then
                  ! Minimal And Optimal Sizes Of The Workspace If The
                  ! singular values and the right singular vectors are requested
                  if ( conda ) then
                      minwrk = n + max( lwqp3, lwcon, lwsvd )
                  else
                      minwrk = n + max( lwqp3, lwsvd )
                  end if
                  if ( lquery ) then
                      if ( rtrans ) then
                          call stdlib_sgesvd( 'O', 'N', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -&
                                    1, ierr )
                      else
                          call stdlib_sgesvd( 'N', 'O', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -&
                                    1, ierr )
                      end if
                      lwrk_sgesvd = int( rdummy(1),KIND=ilp)
                      if ( conda ) then
                          optwrk = n + max( lwrk_sgeqp3, lwcon, lwrk_sgesvd )
                      else
                          optwrk = n + max( lwrk_sgeqp3, lwrk_sgesvd )
                      end if
                  end if
              else
                  ! Minimal And Optimal Sizes Of The Workspace If The
                  ! full svd is requested
                  if ( rtrans ) then
                      minwrk = max( lwqp3, lwsvd, lworq )
                      if ( conda ) minwrk = max( minwrk, lwcon )
                      minwrk = minwrk + n
                      if ( wntva ) then
                         ! .. minimal workspace length for n x n/2 stdlib_sgeqrf
                         lwqrf  = max( n/2, 1 )
                         ! .. minimal workspace length for n/2 x n/2 stdlib_sgesvd
                         lwsvd2 = max( 5 * (n/2), 1 )
                         lworq2 = max( n, 1 )
                         minwrk2 = max( lwqp3, n/2+lwqrf, n/2+lwsvd2,n/2+lworq2, lworq )
                         if ( conda ) minwrk2 = max( minwrk2, lwcon )
                         minwrk2 = n + minwrk2
                         minwrk = max( minwrk, minwrk2 )
                      end if
                  else
                      minwrk = max( lwqp3, lwsvd, lworq )
                      if ( conda ) minwrk = max( minwrk, lwcon )
                      minwrk = minwrk + n
                      if ( wntva ) then
                         ! .. minimal workspace length for n/2 x n stdlib_sgelqf
                         lwlqf  = max( n/2, 1 )
                         lwsvd2 = max( 5 * (n/2), 1 )
                         lwunlq = max( n , 1 )
                         minwrk2 = max( lwqp3, n/2+lwlqf, n/2+lwsvd2,n/2+lwunlq, lworq )
                         if ( conda ) minwrk2 = max( minwrk2, lwcon )
                         minwrk2 = n + minwrk2
                         minwrk = max( minwrk, minwrk2 )
                      end if
                  end if
                  if ( lquery ) then
                     if ( rtrans ) then
                        call stdlib_sgesvd( 'O', 'A', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                  ierr )
                        lwrk_sgesvd = int( rdummy(1),KIND=ilp)
                        optwrk = max(lwrk_sgeqp3,lwrk_sgesvd,lwrk_sormqr)
                        if ( conda ) optwrk = max( optwrk, lwcon )
                        optwrk = n + optwrk
                        if ( wntva ) then
                            call stdlib_sgeqrf(n,n/2,u,ldu,rdummy,rdummy,-1,ierr)
                            lwrk_sgeqrf = int( rdummy(1),KIND=ilp)
                            call stdlib_sgesvd( 'S', 'O', n/2,n/2, v,ldv, s, u,ldu,v, ldv, rdummy,&
                                       -1, ierr )
                            lwrk_sgesvd2 = int( rdummy(1),KIND=ilp)
                            call stdlib_sormqr( 'R', 'C', n, n, n/2, u, ldu, rdummy,v, ldv, &
                                      rdummy, -1, ierr )
                            lwrk_sormqr2 = int( rdummy(1),KIND=ilp)
                            optwrk2 = max( lwrk_sgeqp3, n/2+lwrk_sgeqrf,n/2+lwrk_sgesvd2, n/2+&
                                      lwrk_sormqr2 )
                            if ( conda ) optwrk2 = max( optwrk2, lwcon )
                            optwrk2 = n + optwrk2
                            optwrk = max( optwrk, optwrk2 )
                        end if
                     else
                        call stdlib_sgesvd( 'S', 'O', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                  ierr )
                        lwrk_sgesvd = int( rdummy(1),KIND=ilp)
                        optwrk = max(lwrk_sgeqp3,lwrk_sgesvd,lwrk_sormqr)
                        if ( conda ) optwrk = max( optwrk, lwcon )
                        optwrk = n + optwrk
                        if ( wntva ) then
                           call stdlib_sgelqf(n/2,n,u,ldu,rdummy,rdummy,-1,ierr)
                           lwrk_sgelqf = int( rdummy(1),KIND=ilp)
                           call stdlib_sgesvd( 'S','O', n/2,n/2, v, ldv, s, u, ldu,v, ldv, rdummy,&
                                      -1, ierr )
                           lwrk_sgesvd2 = int( rdummy(1),KIND=ilp)
                           call stdlib_sormlq( 'R', 'N', n, n, n/2, u, ldu, rdummy,v, ldv, rdummy,&
                                     -1,ierr )
                           lwrk_sormlq = int( rdummy(1),KIND=ilp)
                           optwrk2 = max( lwrk_sgeqp3, n/2+lwrk_sgelqf,n/2+lwrk_sgesvd2, n/2+&
                                     lwrk_sormlq )
                            if ( conda ) optwrk2 = max( optwrk2, lwcon )
                            optwrk2 = n + optwrk2
                            optwrk = max( optwrk, optwrk2 )
                        end if
                     end if
                  end if
              end if
              minwrk = max( 2, minwrk )
              optwrk = max( 2, optwrk )
              if ( lwork < minwrk .and. (.not.lquery) ) info = -19
           end if
           if (info == 0 .and. lrwork < rminwrk .and. .not. lquery) then
              info = -21
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGESVDQ', -info )
              return
           else if ( lquery ) then
           ! return optimal workspace
               iwork(1) = iminwrk
               work(1) = optwrk
               work(2) = minwrk
               rwork(1) = rminwrk
               return
           end if
           ! quick return if the matrix is void.
           if( ( m==0 ) .or. ( n==0 ) ) then
           ! All Output Is Void
              return
           end if
           big = stdlib_slamch('O')
           ascaled = .false.
           iwoff = 1
           if ( rowprm ) then
                 iwoff = m
                 ! Reordering The Rows In Decreasing Sequence In The
                 ! ell-infinity norm - this enhances numerical robustness in
                 ! the case of differently scaled rows.
                 do p = 1, m
                     ! rwork(p) = abs( a(p,stdlib_icamax(n,a(p,1),lda)) )
                     ! [[stdlib_slange will return nan if an entry of the p-th row is nan]]
                     rwork(p) = stdlib_slange( 'M', 1, n, a(p,1), lda, rdummy )
                     ! .. check for nan's and inf's
                     if ( ( rwork(p) /= rwork(p) ) .or.( (rwork(p)*zero) /= zero ) ) then
                         info = -8
                         call stdlib_xerbla( 'SGESVDQ', -info )
                         return
                     end if
                 end do
                 do p = 1, m - 1
                 q = stdlib_isamax( m-p+1, rwork(p), 1 ) + p - 1
                 iwork(n+p) = q
                 if ( p /= q ) then
                    rtmp     = rwork(p)
                    rwork(p) = rwork(q)
                    rwork(q) = rtmp
                 end if
                 end do
                 if ( rwork(1) == zero ) then
                    ! quick return: a is the m x n zero matrix.
                    numrank = 0
                    call stdlib_slaset( 'G', n, 1, zero, zero, s, n )
                    if ( wntus ) call stdlib_slaset('G', m, n, zero, one, u, ldu)
                    if ( wntua ) call stdlib_slaset('G', m, m, zero, one, u, ldu)
                    if ( wntva ) call stdlib_slaset('G', n, n, zero, one, v, ldv)
                    if ( wntuf ) then
                        call stdlib_slaset( 'G', n, 1, zero, zero, work, n )
                        call stdlib_slaset( 'G', m, n, zero,  one, u, ldu )
                    end if
                    do p = 1, n
                        iwork(p) = p
                    end do
                    if ( rowprm ) then
                        do p = n + 1, n + m - 1
                            iwork(p) = p - n
                        end do
                    end if
                    if ( conda ) rwork(1) = -1
                    rwork(2) = -1
                    return
                 end if
                 if ( rwork(1) > big / sqrt(real(m,KIND=sp)) ) then
                     ! .. to prevent overflow in the qr factorization, scale the
                     ! matrix by 1/sqrt(m) if too large entry detected
                     call stdlib_slascl('G',0,0,sqrt(real(m,KIND=sp)),one, m,n, a,lda, ierr)
                               
                     ascaled = .true.
                 end if
                 call stdlib_slaswp( n, a, lda, 1, m-1, iwork(n+1), 1 )
           end if
          ! .. at this stage, preemptive scaling is done only to avoid column
          ! norms overflows during the qr factorization. the svd procedure should
          ! have its own scaling to save the singular values from overflows and
          ! underflows. that depends on the svd procedure.
           if ( .not.rowprm ) then
               rtmp = stdlib_slange( 'M', m, n, a, lda, rdummy )
               if ( ( rtmp /= rtmp ) .or.( (rtmp*zero) /= zero ) ) then
                    info = -8
                    call stdlib_xerbla( 'SGESVDQ', -info )
                    return
               end if
               if ( rtmp > big / sqrt(real(m,KIND=sp)) ) then
                   ! .. to prevent overflow in the qr factorization, scale the
                   ! matrix by 1/sqrt(m) if too large entry detected
                   call stdlib_slascl('G',0,0, sqrt(real(m,KIND=sp)),one, m,n, a,lda, ierr)
                             
                   ascaled = .true.
               end if
           end if
           ! Qr Factorization With Column Pivoting
           ! a * p = q * [ r ]
                       ! [ 0 ]
           do p = 1, n
              ! All Columns Are Free Columns
              iwork(p) = 0
           end do
           call stdlib_sgeqp3( m, n, a, lda, iwork, work, work(n+1), lwork-n,ierr )
          ! if the user requested accuracy level allows truncation in the
          ! computed upper triangular factor, the matrix r is examined and,
          ! if possible, replaced with its leading upper trapezoidal part.
           epsln = stdlib_slamch('E')
           sfmin = stdlib_slamch('S')
           ! small = sfmin / epsln
           nr = n
           if ( accla ) then
              ! standard absolute error bound suffices. all sigma_i with
              ! sigma_i < n*eps*||a||_f are flushed to zero. this is an
              ! aggressive enforcement of lower numerical rank by introducing a
              ! backward error of the order of n*eps*||a||_f.
              nr = 1
              rtmp = sqrt(real(n,KIND=sp))*epsln
              do p = 2, n
                 if ( abs(a(p,p)) < (rtmp*abs(a(1,1))) ) go to 3002
                    nr = nr + 1
              end do
              3002 continue
           elseif ( acclm ) then
              ! .. similarly as above, only slightly more gentle (less aggressive).
              ! sudden drop on the diagonal of r is used as the criterion for being
              ! close-to-rank-deficient. the threshold is set to epsln=stdlib_slamch('e').
              ! [[this can be made more flexible by replacing this hard-coded value
              ! with a user specified threshold.]] also, the values that underflow
              ! will be truncated.
              nr = 1
              do p = 2, n
                 if ( ( abs(a(p,p)) < (epsln*abs(a(p-1,p-1))) ) .or.( abs(a(p,p)) < sfmin ) ) go &
                           to 3402
                 nr = nr + 1
              end do
              3402 continue
           else
              ! Rrqr Not Authorized To Determine Numerical Rank Except In The
              ! obvious case of zero pivots.
              ! .. inspect r for exact zeros on the diagonal;
              ! r(i,i)=0 => r(i:n,i:n)=0.
              nr = 1
              do p = 2, n
                 if ( abs(a(p,p)) == zero ) go to 3502
                 nr = nr + 1
              end do
              3502 continue
              if ( conda ) then
                 ! estimate the scaled condition number of a. use the fact that it is
                 ! the same as the scaled condition number of r.
                    ! V Is Used As Workspace
                    call stdlib_slacpy( 'U', n, n, a, lda, v, ldv )
                    ! only the leading nr x nr submatrix of the triangular factor
                    ! is considered. only if nr=n will this give a reliable error
                    ! bound. however, even for nr < n, this can be used on an
                    ! expert level and obtain useful information in the sense of
                    ! perturbation theory.
                    do p = 1, nr
                       rtmp = stdlib_snrm2( p, v(1,p), 1 )
                       call stdlib_sscal( p, one/rtmp, v(1,p), 1 )
                    end do
                    if ( .not. ( lsvec .or. rsvec ) ) then
                        call stdlib_spocon( 'U', nr, v, ldv, one, rtmp,work, iwork(n+iwoff), ierr &
                                  )
                    else
                        call stdlib_spocon( 'U', nr, v, ldv, one, rtmp,work(n+1), iwork(n+iwoff), &
                                  ierr )
                    end if
                    sconda = one / sqrt(rtmp)
                 ! for nr=n, sconda is an estimate of sqrt(||(r^* * r)^(-1)||_1),
                 ! n^(-1/4) * sconda <= ||r^(-1)||_2 <= n^(1/4) * sconda
                 ! see the reference [1] for more details.
              end if
           endif
           if ( wntur ) then
               n1 = nr
           else if ( wntus .or. wntuf) then
               n1 = n
           else if ( wntua ) then
               n1 = m
           end if
           if ( .not. ( rsvec .or. lsvec ) ) then
      ! .......................................................................
              ! Only The Singular Values Are Requested
      ! .......................................................................
              if ( rtrans ) then
               ! .. compute the singular values of r**t = [a](1:nr,1:n)**t
                 ! .. set the lower triangle of [a] to [a](1:nr,1:n)**t and
                 ! the upper triangle of [a] to zero.
                 do p = 1, min( n, nr )
                    do q = p + 1, n
                       a(q,p) = a(p,q)
                       if ( q <= nr ) a(p,q) = zero
                    end do
                 end do
                 call stdlib_sgesvd( 'N', 'N', n, nr, a, lda, s, u, ldu,v, ldv, work, lwork, info &
                           )
              else
                 ! .. compute the singular values of r = [a](1:nr,1:n)
                 if ( nr > 1 )call stdlib_slaset( 'L', nr-1,nr-1, zero,zero, a(2,1), lda )
                 call stdlib_sgesvd( 'N', 'N', nr, n, a, lda, s, u, ldu,v, ldv, work, lwork, info &
                           )
              end if
           else if ( lsvec .and. ( .not. rsvec) ) then
      ! .......................................................................
             ! The Singular Values And The Left Singular Vectors Requested
      ! .......................................................................""""""""
              if ( rtrans ) then
                  ! .. apply stdlib_sgesvd to r**t
                  ! .. copy r**t into [u] and overwrite [u] with the right singular
                  ! vectors of r
                 do p = 1, nr
                    do q = p, n
                       u(q,p) = a(p,q)
                    end do
                 end do
                 if ( nr > 1 )call stdlib_slaset( 'U', nr-1,nr-1, zero,zero, u(1,2), ldu )
                 ! .. the left singular vectors not computed, the nr right singular
                 ! vectors overwrite [u](1:nr,1:nr) as transposed. these
                 ! will be pre-multiplied by q to build the left singular vectors of a.
                    call stdlib_sgesvd( 'N', 'O', n, nr, u, ldu, s, u, ldu,u, ldu, work(n+1), &
                              lwork-n, info )
                    do p = 1, nr
                        do q = p + 1, nr
                           rtmp   = u(q,p)
                           u(q,p) = u(p,q)
                           u(p,q) = rtmp
                        end do
                    end do
              else
                  ! Apply Stdlib_Sgesvd To R
                  ! .. copy r into [u] and overwrite [u] with the left singular vectors
                  call stdlib_slacpy( 'U', nr, n, a, lda, u, ldu )
                  if ( nr > 1 )call stdlib_slaset( 'L', nr-1, nr-1, zero, zero, u(2,1), ldu )
                            
                  ! .. the right singular vectors not computed, the nr left singular
                  ! vectors overwrite [u](1:nr,1:nr)
                     call stdlib_sgesvd( 'O', 'N', nr, n, u, ldu, s, u, ldu,v, ldv, work(n+1), &
                               lwork-n, info )
                     ! .. now [u](1:nr,1:nr) contains the nr left singular vectors of
                     ! r. these will be pre-multiplied by q to build the left singular
                     ! vectors of a.
              end if
                 ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
              if ( ( nr < m ) .and. ( .not.wntuf ) ) then
                  call stdlib_slaset('A', m-nr, nr, zero, zero, u(nr+1,1), ldu)
                  if ( nr < n1 ) then
                     call stdlib_slaset( 'A',nr,n1-nr,zero,zero,u(1,nr+1), ldu )
                     call stdlib_slaset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                  end if
              end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! vectors matrix u.
              if ( .not.wntuf )call stdlib_sormqr( 'L', 'N', m, n1, n, a, lda, work, u,ldu, work(&
                        n+1), lwork-n, ierr )
              if ( rowprm .and. .not.wntuf )call stdlib_slaswp( n1, u, ldu, 1, m-1, iwork(n+1), -&
                        1 )
           else if ( rsvec .and. ( .not. lsvec ) ) then
      ! .......................................................................
             ! The Singular Values And The Right Singular Vectors Requested
      ! .......................................................................
               if ( rtrans ) then
                  ! .. apply stdlib_sgesvd to r**t
                  ! .. copy r**t into v and overwrite v with the left singular vectors
                 do p = 1, nr
                    do q = p, n
                       v(q,p) = (a(p,q))
                    end do
                 end do
                 if ( nr > 1 )call stdlib_slaset( 'U', nr-1,nr-1, zero,zero, v(1,2), ldv )
                 ! .. the left singular vectors of r**t overwrite v, the right singular
                 ! vectors not computed
                 if ( wntvr .or. ( nr == n ) ) then
                    call stdlib_sgesvd( 'O', 'N', n, nr, v, ldv, s, u, ldu,u, ldu, work(n+1), &
                              lwork-n, info )
                    do p = 1, nr
                        do q = p + 1, nr
                           rtmp   = v(q,p)
                           v(q,p) = v(p,q)
                           v(p,q) = rtmp
                        end do
                    end do
                    if ( nr < n ) then
                        do p = 1, nr
                           do q = nr + 1, n
                               v(p,q) = v(q,p)
                           end do
                        end do
                    end if
                    call stdlib_slapmt( .false., nr, n, v, ldv, iwork )
                 else
                     ! .. need all n right singular vectors and nr < n
                     ! [!] this is simple implementation that augments [v](1:n,1:nr)
                     ! by padding a zero block. in the case nr << n, a more efficient
                     ! way is to first use the qr factorization. for more details
                     ! how to implement this, see the " full svd " branch.
                     call stdlib_slaset('G', n, n-nr, zero, zero, v(1,nr+1), ldv)
                     call stdlib_sgesvd( 'O', 'N', n, n, v, ldv, s, u, ldu,u, ldu, work(n+1), &
                               lwork-n, info )
                     do p = 1, n
                        do q = p + 1, n
                           rtmp   = v(q,p)
                           v(q,p) = v(p,q)
                           v(p,q) = rtmp
                        end do
                     end do
                     call stdlib_slapmt( .false., n, n, v, ldv, iwork )
                 end if
               else
                  ! Aply Stdlib_Sgesvd To R
                  ! Copy R Into V And Overwrite V With The Right Singular Vectors
                  call stdlib_slacpy( 'U', nr, n, a, lda, v, ldv )
                  if ( nr > 1 )call stdlib_slaset( 'L', nr-1, nr-1, zero, zero, v(2,1), ldv )
                            
                  ! .. the right singular vectors overwrite v, the nr left singular
                  ! vectors stored in u(1:nr,1:nr)
                  if ( wntvr .or. ( nr == n ) ) then
                     call stdlib_sgesvd( 'N', 'O', nr, n, v, ldv, s, u, ldu,v, ldv, work(n+1), &
                               lwork-n, info )
                     call stdlib_slapmt( .false., nr, n, v, ldv, iwork )
                     ! .. now [v](1:nr,1:n) contains v(1:n,1:nr)**t
                  else
                     ! .. need all n right singular vectors and nr < n
                     ! [!] this is simple implementation that augments [v](1:nr,1:n)
                     ! by padding a zero block. in the case nr << n, a more efficient
                     ! way is to first use the lq factorization. for more details
                     ! how to implement this, see the " full svd " branch.
                      call stdlib_slaset('G', n-nr, n, zero,zero, v(nr+1,1), ldv)
                      call stdlib_sgesvd( 'N', 'O', n, n, v, ldv, s, u, ldu,v, ldv, work(n+1), &
                                lwork-n, info )
                      call stdlib_slapmt( .false., n, n, v, ldv, iwork )
                  end if
                  ! .. now [v] contains the transposed matrix of the right singular
                  ! vectors of a.
               end if
           else
      ! .......................................................................
             ! Full Svd Requested
      ! .......................................................................
              if ( rtrans ) then
                  ! .. apply stdlib_sgesvd to r**t [[this option is left for r
                 if ( wntvr .or. ( nr == n ) ) then
                  ! .. copy r**t into [v] and overwrite [v] with the left singular
                  ! vectors of r**t
                 do p = 1, nr
                    do q = p, n
                       v(q,p) = a(p,q)
                    end do
                 end do
                 if ( nr > 1 )call stdlib_slaset( 'U', nr-1,nr-1, zero,zero, v(1,2), ldv )
                 ! .. the left singular vectors of r**t overwrite [v], the nr right
                 ! singular vectors of r**t stored in [u](1:nr,1:nr) as transposed
                    call stdlib_sgesvd( 'O', 'A', n, nr, v, ldv, s, v, ldv,u, ldu, work(n+1), &
                              lwork-n, info )
                    ! Assemble V
                    do p = 1, nr
                       do q = p + 1, nr
                          rtmp   = v(q,p)
                          v(q,p) = v(p,q)
                          v(p,q) = rtmp
                       end do
                    end do
                    if ( nr < n ) then
                        do p = 1, nr
                           do q = nr+1, n
                              v(p,q) = v(q,p)
                           end do
                        end do
                    end if
                    call stdlib_slapmt( .false., nr, n, v, ldv, iwork )
                     do p = 1, nr
                        do q = p + 1, nr
                           rtmp   = u(q,p)
                           u(q,p) = u(p,q)
                           u(p,q) = rtmp
                        end do
                     end do
                     if ( ( nr < m ) .and. .not.(wntuf)) then
                       call stdlib_slaset('A', m-nr,nr, zero,zero, u(nr+1,1), ldu)
                       if ( nr < n1 ) then
                          call stdlib_slaset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                          call stdlib_slaset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                       end if
                    end if
                 else
                     ! .. need all n right singular vectors and nr < n
                  ! .. copy r**t into [v] and overwrite [v] with the left singular
                  ! vectors of r**t
                     ! [[the optimal ratio n/nr for using qrf instead of padding
                       ! with zeros. here hard coded to 2; it must be at least
                       ! two due to work space constraints.]]
                     ! optratio = stdlib_ilaenv(6, 'sgesvd', 's' // 'o', nr,n,0,0)
                     ! optratio = max( optratio, 2 )
                     optratio = 2
                     if ( optratio*nr > n ) then
                        do p = 1, nr
                           do q = p, n
                              v(q,p) = a(p,q)
                           end do
                        end do
                        if ( nr > 1 )call stdlib_slaset('U',nr-1,nr-1, zero,zero, v(1,2),ldv)
                                  
                        call stdlib_slaset('A',n,n-nr,zero,zero,v(1,nr+1),ldv)
                        call stdlib_sgesvd( 'O', 'A', n, n, v, ldv, s, v, ldv,u, ldu, work(n+1), &
                                  lwork-n, info )
                        do p = 1, n
                           do q = p + 1, n
                              rtmp   = v(q,p)
                              v(q,p) = v(p,q)
                              v(p,q) = rtmp
                           end do
                        end do
                        call stdlib_slapmt( .false., n, n, v, ldv, iwork )
                    ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x n1), i.e. (m x n) or (m x m).
                        do p = 1, n
                           do q = p + 1, n
                              rtmp   = u(q,p)
                              u(q,p) = u(p,q)
                              u(p,q) = rtmp
                           end do
                        end do
                        if ( ( n < m ) .and. .not.(wntuf)) then
                           call stdlib_slaset('A',m-n,n,zero,zero,u(n+1,1),ldu)
                           if ( n < n1 ) then
                             call stdlib_slaset('A',n,n1-n,zero,zero,u(1,n+1),ldu)
                             call stdlib_slaset('A',m-n,n1-n,zero,one,u(n+1,n+1), ldu )
                           end if
                        end if
                     else
                        ! .. copy r**t into [u] and overwrite [u] with the right
                        ! singular vectors of r
                        do p = 1, nr
                           do q = p, n
                              u(q,nr+p) = a(p,q)
                           end do
                        end do
                        if ( nr > 1 )call stdlib_slaset('U',nr-1,nr-1,zero,zero,u(1,nr+2),ldu)
                                  
                        call stdlib_sgeqrf( n, nr, u(1,nr+1), ldu, work(n+1),work(n+nr+1), lwork-&
                                  n-nr, ierr )
                        do p = 1, nr
                            do q = 1, n
                                v(q,p) = u(p,nr+q)
                            end do
                        end do
                       call stdlib_slaset('U',nr-1,nr-1,zero,zero,v(1,2),ldv)
                       call stdlib_sgesvd( 'S', 'O', nr, nr, v, ldv, s, u, ldu,v,ldv, work(n+nr+1)&
                                 ,lwork-n-nr, info )
                       call stdlib_slaset('A',n-nr,nr,zero,zero,v(nr+1,1),ldv)
                       call stdlib_slaset('A',nr,n-nr,zero,zero,v(1,nr+1),ldv)
                       call stdlib_slaset('A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv)
                       call stdlib_sormqr('R','C', n, n, nr, u(1,nr+1), ldu,work(n+1),v,ldv,work(&
                                 n+nr+1),lwork-n-nr,ierr)
                       call stdlib_slapmt( .false., n, n, v, ldv, iwork )
                       ! Assemble The Left Singular Vector Matrix U Of Dimensions
                       ! (m x nr) or (m x n) or (m x m).
                       if ( ( nr < m ) .and. .not.(wntuf)) then
                          call stdlib_slaset('A',m-nr,nr,zero,zero,u(nr+1,1),ldu)
                          if ( nr < n1 ) then
                          call stdlib_slaset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                          call stdlib_slaset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1),ldu)
                          end if
                       end if
                     end if
                 end if
              else
                  ! .. apply stdlib_sgesvd to r [[this is the recommended option]]
                  if ( wntvr .or. ( nr == n ) ) then
                      ! .. copy r into [v] and overwrite v with the right singular vectors
                      call stdlib_slacpy( 'U', nr, n, a, lda, v, ldv )
                     if ( nr > 1 )call stdlib_slaset( 'L', nr-1,nr-1, zero,zero, v(2,1), ldv )
                               
                     ! .. the right singular vectors of r overwrite [v], the nr left
                     ! singular vectors of r stored in [u](1:nr,1:nr)
                     call stdlib_sgesvd( 'S', 'O', nr, n, v, ldv, s, u, ldu,v, ldv, work(n+1), &
                               lwork-n, info )
                     call stdlib_slapmt( .false., nr, n, v, ldv, iwork )
                     ! .. now [v](1:nr,1:n) contains v(1:n,1:nr)**t
                     ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
                    if ( ( nr < m ) .and. .not.(wntuf)) then
                       call stdlib_slaset('A', m-nr,nr, zero,zero, u(nr+1,1), ldu)
                       if ( nr < n1 ) then
                          call stdlib_slaset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                          call stdlib_slaset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                       end if
                    end if
                  else
                    ! .. need all n right singular vectors and nr < n
                    ! The Requested Number Of The Left Singular Vectors
                     ! is then n1 (n or m)
                     ! [[the optimal ratio n/nr for using lq instead of padding
                       ! with zeros. here hard coded to 2; it must be at least
                       ! two due to work space constraints.]]
                     ! optratio = stdlib_ilaenv(6, 'sgesvd', 's' // 'o', nr,n,0,0)
                     ! optratio = max( optratio, 2 )
                    optratio = 2
                    if ( optratio * nr > n ) then
                       call stdlib_slacpy( 'U', nr, n, a, lda, v, ldv )
                       if ( nr > 1 )call stdlib_slaset('L', nr-1,nr-1, zero,zero, v(2,1),ldv)
                                 
                    ! .. the right singular vectors of r overwrite [v], the nr left
                       ! singular vectors of r stored in [u](1:nr,1:nr)
                       call stdlib_slaset('A', n-nr,n, zero,zero, v(nr+1,1),ldv)
                       call stdlib_sgesvd( 'S', 'O', n, n, v, ldv, s, u, ldu,v, ldv, work(n+1), &
                                 lwork-n, info )
                       call stdlib_slapmt( .false., n, n, v, ldv, iwork )
                       ! .. now [v] contains the transposed matrix of the right
                       ! singular vectors of a. the leading n left singular vectors
                       ! are in [u](1:n,1:n)
                       ! Assemble The Left Singular Vector Matrix U Of Dimensions
                       ! (m x n1), i.e. (m x n) or (m x m).
                       if ( ( n < m ) .and. .not.(wntuf)) then
                           call stdlib_slaset('A',m-n,n,zero,zero,u(n+1,1),ldu)
                           if ( n < n1 ) then
                             call stdlib_slaset('A',n,n1-n,zero,zero,u(1,n+1),ldu)
                             call stdlib_slaset( 'A',m-n,n1-n,zero,one,u(n+1,n+1), ldu )
                           end if
                       end if
                    else
                       call stdlib_slacpy( 'U', nr, n, a, lda, u(nr+1,1), ldu )
                       if ( nr > 1 )call stdlib_slaset('L',nr-1,nr-1,zero,zero,u(nr+2,1),ldu)
                                 
                       call stdlib_sgelqf( nr, n, u(nr+1,1), ldu, work(n+1),work(n+nr+1), lwork-n-&
                                 nr, ierr )
                       call stdlib_slacpy('L',nr,nr,u(nr+1,1),ldu,v,ldv)
                       if ( nr > 1 )call stdlib_slaset('U',nr-1,nr-1,zero,zero,v(1,2),ldv)
                       call stdlib_sgesvd( 'S', 'O', nr, nr, v, ldv, s, u, ldu,v, ldv, work(n+nr+&
                                 1), lwork-n-nr, info )
                       call stdlib_slaset('A',n-nr,nr,zero,zero,v(nr+1,1),ldv)
                       call stdlib_slaset('A',nr,n-nr,zero,zero,v(1,nr+1),ldv)
                       call stdlib_slaset('A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv)
                       call stdlib_sormlq('R','N',n,n,nr,u(nr+1,1),ldu,work(n+1),v, ldv, work(n+&
                                 nr+1),lwork-n-nr,ierr)
                       call stdlib_slapmt( .false., n, n, v, ldv, iwork )
                     ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
                       if ( ( nr < m ) .and. .not.(wntuf)) then
                          call stdlib_slaset('A',m-nr,nr,zero,zero,u(nr+1,1),ldu)
                          if ( nr < n1 ) then
                          call stdlib_slaset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                          call stdlib_slaset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                          end if
                       end if
                    end if
                  end if
              ! .. end of the "r**t or r" branch
              end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! vectors matrix u.
              if ( .not. wntuf )call stdlib_sormqr( 'L', 'N', m, n1, n, a, lda, work, u,ldu, work(&
                        n+1), lwork-n, ierr )
              if ( rowprm .and. .not.wntuf )call stdlib_slaswp( n1, u, ldu, 1, m-1, iwork(n+1), -&
                        1 )
           ! ... end of the "full svd" branch
           end if
           ! check whether some singular values are returned as zeros, e.g.
           ! due to underflow, and update the numerical rank.
           p = nr
           do q = p, 1, -1
               if ( s(q) > zero ) go to 4002
               nr = nr - 1
           end do
           4002 continue
           ! .. if numerical rank deficiency is detected, the truncated
           ! singular values are set to zero.
           if ( nr < n ) call stdlib_slaset( 'G', n-nr,1, zero,zero, s(nr+1), n )
           ! .. undo scaling; this may cause overflow in the largest singular
           ! values.
           if ( ascaled )call stdlib_slascl( 'G',0,0, one,sqrt(real(m,KIND=sp)), nr,1, s, n, ierr &
                     )
           if ( conda ) rwork(1) = sconda
           rwork(2) = p - nr
           ! .. p-nr is the number of singular values that are computed as
           ! exact zeros in stdlib_sgesvd() applied to the (possibly truncated)
           ! full row rank triangular (trapezoidal) factor of a.
           numrank = nr
           return
     end subroutine stdlib_sgesvdq

     module subroutine stdlib_dgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
     numrank, iwork, liwork,work, lwork, rwork, lrwork, info )
     !! DGESVDQ computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N orthogonal matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
               
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: joba, jobp, jobr, jobu, jobv
           integer(ilp), intent(in) :: m, n, lda, ldu, ldv, liwork, lrwork
           integer(ilp), intent(out) :: numrank, info
           integer(ilp), intent(inout) :: lwork
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: u(ldu,*), v(ldv,*), work(*)
           real(dp), intent(out) :: s(*), rwork(*)
           integer(ilp), intent(out) :: iwork(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: ierr, iwoff, nr, n1, optratio, p, q
           integer(ilp) :: lwcon, lwqp3, lwrk_dgelqf, lwrk_dgesvd, lwrk_dgesvd2, lwrk_dgeqp3, &
           lwrk_dgeqrf, lwrk_dormlq, lwrk_dormqr, lwrk_dormqr2, lwlqf, lwqrf, lwsvd, lwsvd2, &
                     lworq, lworq2, lworlq, minwrk, minwrk2, optwrk, optwrk2, iminwrk, rminwrk
           logical(lk) :: accla, acclm, acclh, ascaled, conda, dntwu, dntwv, lquery, lsvc0, lsvec,&
                      rowprm, rsvec, rtrans, wntua, wntuf, wntur, wntus, wntva, wntvr
           real(dp) :: big, epsln, rtmp, sconda, sfmin
           ! Local Arrays
           real(dp) :: rdummy(1)
           ! Intrinsic Functions 
           ! test the input arguments
           wntus  = stdlib_lsame( jobu, 'S' ) .or. stdlib_lsame( jobu, 'U' )
           wntur  = stdlib_lsame( jobu, 'R' )
           wntua  = stdlib_lsame( jobu, 'A' )
           wntuf  = stdlib_lsame( jobu, 'F' )
           lsvc0  = wntus .or. wntur .or. wntua
           lsvec  = lsvc0 .or. wntuf
           dntwu  = stdlib_lsame( jobu, 'N' )
           wntvr  = stdlib_lsame( jobv, 'R' )
           wntva  = stdlib_lsame( jobv, 'A' ) .or. stdlib_lsame( jobv, 'V' )
           rsvec  = wntvr .or. wntva
           dntwv  = stdlib_lsame( jobv, 'N' )
           accla  = stdlib_lsame( joba, 'A' )
           acclm  = stdlib_lsame( joba, 'M' )
           conda  = stdlib_lsame( joba, 'E' )
           acclh  = stdlib_lsame( joba, 'H' ) .or. conda
           rowprm = stdlib_lsame( jobp, 'P' )
           rtrans = stdlib_lsame( jobr, 'T' )
           if ( rowprm ) then
              if ( conda ) then
                 iminwrk = max( 1, n + m - 1 + n )
              else
                 iminwrk = max( 1, n + m - 1 )
              end if
              rminwrk = max( 2, m )
           else
              if ( conda ) then
                 iminwrk = max( 1, n + n )
              else
                 iminwrk = max( 1, n )
              end if
              rminwrk = 2
           end if
           lquery = (liwork == -1 .or. lwork == -1 .or. lrwork == -1)
           info  = 0
           if ( .not. ( accla .or. acclm .or. acclh ) ) then
              info = -1
           else if ( .not.( rowprm .or. stdlib_lsame( jobp, 'N' ) ) ) then
               info = -2
           else if ( .not.( rtrans .or. stdlib_lsame( jobr, 'N' ) ) ) then
               info = -3
           else if ( .not.( lsvec .or. dntwu ) ) then
              info = -4
           else if ( wntur .and. wntva ) then
              info = -5
           else if ( .not.( rsvec .or. dntwv )) then
              info = -5
           else if ( m<0 ) then
              info = -6
           else if ( ( n<0 ) .or. ( n>m ) ) then
              info = -7
           else if ( lda<max( 1, m ) ) then
              info = -9
           else if ( ldu<1 .or. ( lsvc0 .and. ldu<m ) .or.( wntuf .and. ldu<n ) ) then
              info = -12
           else if ( ldv<1 .or. ( rsvec .and. ldv<n ) .or.( conda .and. ldv<n ) ) then
              info = -14
           else if ( liwork < iminwrk .and. .not. lquery ) then
              info = -17
           end if
           if ( info == 0 ) then
              ! Compute The Minimal And The Optimal Workspace Lengths
              ! [[the expressions for computing the minimal and the optimal
              ! values of lwork are written with a lot of redundancy and
              ! can be simplified. however, this detailed form is easier for
              ! maintenance and modifications of the code.]]
              ! Minimal Workspace Length For Stdlib_Dgeqp3 Of An M X N Matrix
              lwqp3 = 3 * n + 1
              ! Minimal Workspace Length For Stdlib_Dormqr To Build Left Singular Vectors
              if ( wntus .or. wntur ) then
                  lworq  = max( n  , 1 )
              else if ( wntua ) then
                  lworq = max( m , 1 )
              end if
              ! Minimal Workspace Length For Stdlib_Dpocon Of An N X N Matrix
              lwcon = 3 * n
              ! Stdlib_Dgesvd Of An N X N Matrix
              lwsvd = max( 5 * n, 1 )
              if ( lquery ) then
                  call stdlib_dgeqp3( m, n, a, lda, iwork, rdummy, rdummy, -1,ierr )
                  lwrk_dgeqp3 = int( rdummy(1),KIND=ilp)
                  if ( wntus .or. wntur ) then
                      call stdlib_dormqr( 'L', 'N', m, n, n, a, lda, rdummy, u,ldu, rdummy, -1, &
                                ierr )
                      lwrk_dormqr = int( rdummy(1),KIND=ilp)
                  else if ( wntua ) then
                      call stdlib_dormqr( 'L', 'N', m, m, n, a, lda, rdummy, u,ldu, rdummy, -1, &
                                ierr )
                      lwrk_dormqr = int( rdummy(1),KIND=ilp)
                  else
                      lwrk_dormqr = 0
                  end if
              end if
              minwrk = 2
              optwrk = 2
              if ( .not. (lsvec .or. rsvec )) then
                  ! Minimal And Optimal Sizes Of The Workspace If
                  ! only the singular values are requested
                  if ( conda ) then
                     minwrk = max( n+lwqp3, lwcon, lwsvd )
                  else
                     minwrk = max( n+lwqp3, lwsvd )
                  end if
                  if ( lquery ) then
                      call stdlib_dgesvd( 'N', 'N', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                ierr )
                      lwrk_dgesvd = int( rdummy(1),KIND=ilp)
                      if ( conda ) then
                         optwrk = max( n+lwrk_dgeqp3, n+lwcon, lwrk_dgesvd )
                      else
                         optwrk = max( n+lwrk_dgeqp3, lwrk_dgesvd )
                      end if
                  end if
              else if ( lsvec .and. (.not.rsvec) ) then
                  ! Minimal And Optimal Sizes Of The Workspace If The
                  ! singular values and the left singular vectors are requested
                  if ( conda ) then
                      minwrk = n + max( lwqp3, lwcon, lwsvd, lworq )
                  else
                      minwrk = n + max( lwqp3, lwsvd, lworq )
                  end if
                  if ( lquery ) then
                     if ( rtrans ) then
                        call stdlib_dgesvd( 'N', 'O', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                  ierr )
                     else
                        call stdlib_dgesvd( 'O', 'N', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                  ierr )
                     end if
                     lwrk_dgesvd = int( rdummy(1),KIND=ilp)
                     if ( conda ) then
                         optwrk = n + max( lwrk_dgeqp3, lwcon, lwrk_dgesvd,lwrk_dormqr )
                     else
                         optwrk = n + max( lwrk_dgeqp3, lwrk_dgesvd,lwrk_dormqr )
                     end if
                  end if
              else if ( rsvec .and. (.not.lsvec) ) then
                  ! Minimal And Optimal Sizes Of The Workspace If The
                  ! singular values and the right singular vectors are requested
                  if ( conda ) then
                      minwrk = n + max( lwqp3, lwcon, lwsvd )
                  else
                      minwrk = n + max( lwqp3, lwsvd )
                  end if
                  if ( lquery ) then
                      if ( rtrans ) then
                          call stdlib_dgesvd( 'O', 'N', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -&
                                    1, ierr )
                      else
                          call stdlib_dgesvd( 'N', 'O', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -&
                                    1, ierr )
                      end if
                      lwrk_dgesvd = int( rdummy(1),KIND=ilp)
                      if ( conda ) then
                          optwrk = n + max( lwrk_dgeqp3, lwcon, lwrk_dgesvd )
                      else
                          optwrk = n + max( lwrk_dgeqp3, lwrk_dgesvd )
                      end if
                  end if
              else
                  ! Minimal And Optimal Sizes Of The Workspace If The
                  ! full svd is requested
                  if ( rtrans ) then
                      minwrk = max( lwqp3, lwsvd, lworq )
                      if ( conda ) minwrk = max( minwrk, lwcon )
                      minwrk = minwrk + n
                      if ( wntva ) then
                         ! .. minimal workspace length for n x n/2 stdlib_dgeqrf
                         lwqrf  = max( n/2, 1 )
                         ! .. minimal workspace length for n/2 x n/2 stdlib_dgesvd
                         lwsvd2 = max( 5 * (n/2), 1 )
                         lworq2 = max( n, 1 )
                         minwrk2 = max( lwqp3, n/2+lwqrf, n/2+lwsvd2,n/2+lworq2, lworq )
                         if ( conda ) minwrk2 = max( minwrk2, lwcon )
                         minwrk2 = n + minwrk2
                         minwrk = max( minwrk, minwrk2 )
                      end if
                  else
                      minwrk = max( lwqp3, lwsvd, lworq )
                      if ( conda ) minwrk = max( minwrk, lwcon )
                      minwrk = minwrk + n
                      if ( wntva ) then
                         ! .. minimal workspace length for n/2 x n stdlib_dgelqf
                         lwlqf  = max( n/2, 1 )
                         lwsvd2 = max( 5 * (n/2), 1 )
                         lworlq = max( n , 1 )
                         minwrk2 = max( lwqp3, n/2+lwlqf, n/2+lwsvd2,n/2+lworlq, lworq )
                         if ( conda ) minwrk2 = max( minwrk2, lwcon )
                         minwrk2 = n + minwrk2
                         minwrk = max( minwrk, minwrk2 )
                      end if
                  end if
                  if ( lquery ) then
                     if ( rtrans ) then
                        call stdlib_dgesvd( 'O', 'A', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                  ierr )
                        lwrk_dgesvd = int( rdummy(1),KIND=ilp)
                        optwrk = max(lwrk_dgeqp3,lwrk_dgesvd,lwrk_dormqr)
                        if ( conda ) optwrk = max( optwrk, lwcon )
                        optwrk = n + optwrk
                        if ( wntva ) then
                            call stdlib_dgeqrf(n,n/2,u,ldu,rdummy,rdummy,-1,ierr)
                            lwrk_dgeqrf = int( rdummy(1),KIND=ilp)
                            call stdlib_dgesvd( 'S', 'O', n/2,n/2, v,ldv, s, u,ldu,v, ldv, rdummy,&
                                       -1, ierr )
                            lwrk_dgesvd2 = int( rdummy(1),KIND=ilp)
                            call stdlib_dormqr( 'R', 'C', n, n, n/2, u, ldu, rdummy,v, ldv, &
                                      rdummy, -1, ierr )
                            lwrk_dormqr2 = int( rdummy(1),KIND=ilp)
                            optwrk2 = max( lwrk_dgeqp3, n/2+lwrk_dgeqrf,n/2+lwrk_dgesvd2, n/2+&
                                      lwrk_dormqr2 )
                            if ( conda ) optwrk2 = max( optwrk2, lwcon )
                            optwrk2 = n + optwrk2
                            optwrk = max( optwrk, optwrk2 )
                        end if
                     else
                        call stdlib_dgesvd( 'S', 'O', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                  ierr )
                        lwrk_dgesvd = int( rdummy(1),KIND=ilp)
                        optwrk = max(lwrk_dgeqp3,lwrk_dgesvd,lwrk_dormqr)
                        if ( conda ) optwrk = max( optwrk, lwcon )
                        optwrk = n + optwrk
                        if ( wntva ) then
                           call stdlib_dgelqf(n/2,n,u,ldu,rdummy,rdummy,-1,ierr)
                           lwrk_dgelqf = int( rdummy(1),KIND=ilp)
                           call stdlib_dgesvd( 'S','O', n/2,n/2, v, ldv, s, u, ldu,v, ldv, rdummy,&
                                      -1, ierr )
                           lwrk_dgesvd2 = int( rdummy(1),KIND=ilp)
                           call stdlib_dormlq( 'R', 'N', n, n, n/2, u, ldu, rdummy,v, ldv, rdummy,&
                                     -1,ierr )
                           lwrk_dormlq = int( rdummy(1),KIND=ilp)
                           optwrk2 = max( lwrk_dgeqp3, n/2+lwrk_dgelqf,n/2+lwrk_dgesvd2, n/2+&
                                     lwrk_dormlq )
                            if ( conda ) optwrk2 = max( optwrk2, lwcon )
                            optwrk2 = n + optwrk2
                            optwrk = max( optwrk, optwrk2 )
                        end if
                     end if
                  end if
              end if
              minwrk = max( 2, minwrk )
              optwrk = max( 2, optwrk )
              if ( lwork < minwrk .and. (.not.lquery) ) info = -19
           end if
           if (info == 0 .and. lrwork < rminwrk .and. .not. lquery) then
              info = -21
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGESVDQ', -info )
              return
           else if ( lquery ) then
           ! return optimal workspace
               iwork(1) = iminwrk
               work(1) = optwrk
               work(2) = minwrk
               rwork(1) = rminwrk
               return
           end if
           ! quick return if the matrix is void.
           if( ( m==0 ) .or. ( n==0 ) ) then
           ! All Output Is Void
              return
           end if
           big = stdlib_dlamch('O')
           ascaled = .false.
           iwoff = 1
           if ( rowprm ) then
                 iwoff = m
                 ! Reordering The Rows In Decreasing Sequence In The
                 ! ell-infinity norm - this enhances numerical robustness in
                 ! the case of differently scaled rows.
                 do p = 1, m
                     ! rwork(p) = abs( a(p,stdlib_icamax(n,a(p,1),lda)) )
                     ! [[stdlib_dlange will return nan if an entry of the p-th row is nan]]
                     rwork(p) = stdlib_dlange( 'M', 1, n, a(p,1), lda, rdummy )
                     ! .. check for nan's and inf's
                     if ( ( rwork(p) /= rwork(p) ) .or.( (rwork(p)*zero) /= zero ) ) then
                         info = -8
                         call stdlib_xerbla( 'DGESVDQ', -info )
                         return
                     end if
                 end do
                 do p = 1, m - 1
                 q = stdlib_idamax( m-p+1, rwork(p), 1 ) + p - 1
                 iwork(n+p) = q
                 if ( p /= q ) then
                    rtmp     = rwork(p)
                    rwork(p) = rwork(q)
                    rwork(q) = rtmp
                 end if
                 end do
                 if ( rwork(1) == zero ) then
                    ! quick return: a is the m x n zero matrix.
                    numrank = 0
                    call stdlib_dlaset( 'G', n, 1, zero, zero, s, n )
                    if ( wntus ) call stdlib_dlaset('G', m, n, zero, one, u, ldu)
                    if ( wntua ) call stdlib_dlaset('G', m, m, zero, one, u, ldu)
                    if ( wntva ) call stdlib_dlaset('G', n, n, zero, one, v, ldv)
                    if ( wntuf ) then
                        call stdlib_dlaset( 'G', n, 1, zero, zero, work, n )
                        call stdlib_dlaset( 'G', m, n, zero,  one, u, ldu )
                    end if
                    do p = 1, n
                        iwork(p) = p
                    end do
                    if ( rowprm ) then
                        do p = n + 1, n + m - 1
                            iwork(p) = p - n
                        end do
                    end if
                    if ( conda ) rwork(1) = -1
                    rwork(2) = -1
                    return
                 end if
                 if ( rwork(1) > big / sqrt(real(m,KIND=dp)) ) then
                     ! .. to prevent overflow in the qr factorization, scale the
                     ! matrix by 1/sqrt(m) if too large entry detected
                     call stdlib_dlascl('G',0,0,sqrt(real(m,KIND=dp)),one, m,n, a,lda, ierr)
                               
                     ascaled = .true.
                 end if
                 call stdlib_dlaswp( n, a, lda, 1, m-1, iwork(n+1), 1 )
           end if
          ! .. at this stage, preemptive scaling is done only to avoid column
          ! norms overflows during the qr factorization. the svd procedure should
          ! have its own scaling to save the singular values from overflows and
          ! underflows. that depends on the svd procedure.
           if ( .not.rowprm ) then
               rtmp = stdlib_dlange( 'M', m, n, a, lda, rdummy )
               if ( ( rtmp /= rtmp ) .or.( (rtmp*zero) /= zero ) ) then
                    info = -8
                    call stdlib_xerbla( 'DGESVDQ', -info )
                    return
               end if
               if ( rtmp > big / sqrt(real(m,KIND=dp)) ) then
                   ! .. to prevent overflow in the qr factorization, scale the
                   ! matrix by 1/sqrt(m) if too large entry detected
                   call stdlib_dlascl('G',0,0, sqrt(real(m,KIND=dp)),one, m,n, a,lda, ierr)
                             
                   ascaled = .true.
               end if
           end if
           ! Qr Factorization With Column Pivoting
           ! a * p = q * [ r ]
                       ! [ 0 ]
           do p = 1, n
              ! All Columns Are Free Columns
              iwork(p) = 0
           end do
           call stdlib_dgeqp3( m, n, a, lda, iwork, work, work(n+1), lwork-n,ierr )
          ! if the user requested accuracy level allows truncation in the
          ! computed upper triangular factor, the matrix r is examined and,
          ! if possible, replaced with its leading upper trapezoidal part.
           epsln = stdlib_dlamch('E')
           sfmin = stdlib_dlamch('S')
           ! small = sfmin / epsln
           nr = n
           if ( accla ) then
              ! standard absolute error bound suffices. all sigma_i with
              ! sigma_i < n*eps*||a||_f are flushed to zero. this is an
              ! aggressive enforcement of lower numerical rank by introducing a
              ! backward error of the order of n*eps*||a||_f.
              nr = 1
              rtmp = sqrt(real(n,KIND=dp))*epsln
              do p = 2, n
                 if ( abs(a(p,p)) < (rtmp*abs(a(1,1))) ) go to 3002
                    nr = nr + 1
              end do
              3002 continue
           elseif ( acclm ) then
              ! .. similarly as above, only slightly more gentle (less aggressive).
              ! sudden drop on the diagonal of r is used as the criterion for being
              ! close-to-rank-deficient. the threshold is set to epsln=stdlib_dlamch('e').
              ! [[this can be made more flexible by replacing this hard-coded value
              ! with a user specified threshold.]] also, the values that underflow
              ! will be truncated.
              nr = 1
              do p = 2, n
                 if ( ( abs(a(p,p)) < (epsln*abs(a(p-1,p-1))) ) .or.( abs(a(p,p)) < sfmin ) ) go &
                           to 3402
                 nr = nr + 1
              end do
              3402 continue
           else
              ! Rrqr Not Authorized To Determine Numerical Rank Except In The
              ! obvious case of zero pivots.
              ! .. inspect r for exact zeros on the diagonal;
              ! r(i,i)=0 => r(i:n,i:n)=0.
              nr = 1
              do p = 2, n
                 if ( abs(a(p,p)) == zero ) go to 3502
                 nr = nr + 1
              end do
              3502 continue
              if ( conda ) then
                 ! estimate the scaled condition number of a. use the fact that it is
                 ! the same as the scaled condition number of r.
                    ! V Is Used As Workspace
                    call stdlib_dlacpy( 'U', n, n, a, lda, v, ldv )
                    ! only the leading nr x nr submatrix of the triangular factor
                    ! is considered. only if nr=n will this give a reliable error
                    ! bound. however, even for nr < n, this can be used on an
                    ! expert level and obtain useful information in the sense of
                    ! perturbation theory.
                    do p = 1, nr
                       rtmp = stdlib_dnrm2( p, v(1,p), 1 )
                       call stdlib_dscal( p, one/rtmp, v(1,p), 1 )
                    end do
                    if ( .not. ( lsvec .or. rsvec ) ) then
                        call stdlib_dpocon( 'U', nr, v, ldv, one, rtmp,work, iwork(n+iwoff), ierr &
                                  )
                    else
                        call stdlib_dpocon( 'U', nr, v, ldv, one, rtmp,work(n+1), iwork(n+iwoff), &
                                  ierr )
                    end if
                    sconda = one / sqrt(rtmp)
                 ! for nr=n, sconda is an estimate of sqrt(||(r^* * r)^(-1)||_1),
                 ! n^(-1/4) * sconda <= ||r^(-1)||_2 <= n^(1/4) * sconda
                 ! see the reference [1] for more details.
              end if
           endif
           if ( wntur ) then
               n1 = nr
           else if ( wntus .or. wntuf) then
               n1 = n
           else if ( wntua ) then
               n1 = m
           end if
           if ( .not. ( rsvec .or. lsvec ) ) then
      ! .......................................................................
              ! Only The Singular Values Are Requested
      ! .......................................................................
              if ( rtrans ) then
               ! .. compute the singular values of r**t = [a](1:nr,1:n)**t
                 ! .. set the lower triangle of [a] to [a](1:nr,1:n)**t and
                 ! the upper triangle of [a] to zero.
                 do p = 1, min( n, nr )
                    do q = p + 1, n
                       a(q,p) = a(p,q)
                       if ( q <= nr ) a(p,q) = zero
                    end do
                 end do
                 call stdlib_dgesvd( 'N', 'N', n, nr, a, lda, s, u, ldu,v, ldv, work, lwork, info &
                           )
              else
                 ! .. compute the singular values of r = [a](1:nr,1:n)
                 if ( nr > 1 )call stdlib_dlaset( 'L', nr-1,nr-1, zero,zero, a(2,1), lda )
                 call stdlib_dgesvd( 'N', 'N', nr, n, a, lda, s, u, ldu,v, ldv, work, lwork, info &
                           )
              end if
           else if ( lsvec .and. ( .not. rsvec) ) then
      ! .......................................................................
             ! The Singular Values And The Left Singular Vectors Requested
      ! .......................................................................""""""""
              if ( rtrans ) then
                  ! .. apply stdlib_dgesvd to r**t
                  ! .. copy r**t into [u] and overwrite [u] with the right singular
                  ! vectors of r
                 do p = 1, nr
                    do q = p, n
                       u(q,p) = a(p,q)
                    end do
                 end do
                 if ( nr > 1 )call stdlib_dlaset( 'U', nr-1,nr-1, zero,zero, u(1,2), ldu )
                 ! .. the left singular vectors not computed, the nr right singular
                 ! vectors overwrite [u](1:nr,1:nr) as transposed. these
                 ! will be pre-multiplied by q to build the left singular vectors of a.
                    call stdlib_dgesvd( 'N', 'O', n, nr, u, ldu, s, u, ldu,u, ldu, work(n+1), &
                              lwork-n, info )
                    do p = 1, nr
                        do q = p + 1, nr
                           rtmp   = u(q,p)
                           u(q,p) = u(p,q)
                           u(p,q) = rtmp
                        end do
                    end do
              else
                  ! Apply Stdlib_Dgesvd To R
                  ! .. copy r into [u] and overwrite [u] with the left singular vectors
                  call stdlib_dlacpy( 'U', nr, n, a, lda, u, ldu )
                  if ( nr > 1 )call stdlib_dlaset( 'L', nr-1, nr-1, zero, zero, u(2,1), ldu )
                            
                  ! .. the right singular vectors not computed, the nr left singular
                  ! vectors overwrite [u](1:nr,1:nr)
                     call stdlib_dgesvd( 'O', 'N', nr, n, u, ldu, s, u, ldu,v, ldv, work(n+1), &
                               lwork-n, info )
                     ! .. now [u](1:nr,1:nr) contains the nr left singular vectors of
                     ! r. these will be pre-multiplied by q to build the left singular
                     ! vectors of a.
              end if
                 ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
              if ( ( nr < m ) .and. ( .not.wntuf ) ) then
                  call stdlib_dlaset('A', m-nr, nr, zero, zero, u(nr+1,1), ldu)
                  if ( nr < n1 ) then
                     call stdlib_dlaset( 'A',nr,n1-nr,zero,zero,u(1,nr+1), ldu )
                     call stdlib_dlaset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                  end if
              end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! vectors matrix u.
              if ( .not.wntuf )call stdlib_dormqr( 'L', 'N', m, n1, n, a, lda, work, u,ldu, work(&
                        n+1), lwork-n, ierr )
              if ( rowprm .and. .not.wntuf )call stdlib_dlaswp( n1, u, ldu, 1, m-1, iwork(n+1), -&
                        1 )
           else if ( rsvec .and. ( .not. lsvec ) ) then
      ! .......................................................................
             ! The Singular Values And The Right Singular Vectors Requested
      ! .......................................................................
               if ( rtrans ) then
                  ! .. apply stdlib_dgesvd to r**t
                  ! .. copy r**t into v and overwrite v with the left singular vectors
                 do p = 1, nr
                    do q = p, n
                       v(q,p) = (a(p,q))
                    end do
                 end do
                 if ( nr > 1 )call stdlib_dlaset( 'U', nr-1,nr-1, zero,zero, v(1,2), ldv )
                 ! .. the left singular vectors of r**t overwrite v, the right singular
                 ! vectors not computed
                 if ( wntvr .or. ( nr == n ) ) then
                    call stdlib_dgesvd( 'O', 'N', n, nr, v, ldv, s, u, ldu,u, ldu, work(n+1), &
                              lwork-n, info )
                    do p = 1, nr
                        do q = p + 1, nr
                           rtmp   = v(q,p)
                           v(q,p) = v(p,q)
                           v(p,q) = rtmp
                        end do
                    end do
                    if ( nr < n ) then
                        do p = 1, nr
                           do q = nr + 1, n
                               v(p,q) = v(q,p)
                           end do
                        end do
                    end if
                    call stdlib_dlapmt( .false., nr, n, v, ldv, iwork )
                 else
                     ! .. need all n right singular vectors and nr < n
                     ! [!] this is simple implementation that augments [v](1:n,1:nr)
                     ! by padding a zero block. in the case nr << n, a more efficient
                     ! way is to first use the qr factorization. for more details
                     ! how to implement this, see the " full svd " branch.
                     call stdlib_dlaset('G', n, n-nr, zero, zero, v(1,nr+1), ldv)
                     call stdlib_dgesvd( 'O', 'N', n, n, v, ldv, s, u, ldu,u, ldu, work(n+1), &
                               lwork-n, info )
                     do p = 1, n
                        do q = p + 1, n
                           rtmp   = v(q,p)
                           v(q,p) = v(p,q)
                           v(p,q) = rtmp
                        end do
                     end do
                     call stdlib_dlapmt( .false., n, n, v, ldv, iwork )
                 end if
               else
                  ! Aply Stdlib_Dgesvd To R
                  ! Copy R Into V And Overwrite V With The Right Singular Vectors
                  call stdlib_dlacpy( 'U', nr, n, a, lda, v, ldv )
                  if ( nr > 1 )call stdlib_dlaset( 'L', nr-1, nr-1, zero, zero, v(2,1), ldv )
                            
                  ! .. the right singular vectors overwrite v, the nr left singular
                  ! vectors stored in u(1:nr,1:nr)
                  if ( wntvr .or. ( nr == n ) ) then
                     call stdlib_dgesvd( 'N', 'O', nr, n, v, ldv, s, u, ldu,v, ldv, work(n+1), &
                               lwork-n, info )
                     call stdlib_dlapmt( .false., nr, n, v, ldv, iwork )
                     ! .. now [v](1:nr,1:n) contains v(1:n,1:nr)**t
                  else
                     ! .. need all n right singular vectors and nr < n
                     ! [!] this is simple implementation that augments [v](1:nr,1:n)
                     ! by padding a zero block. in the case nr << n, a more efficient
                     ! way is to first use the lq factorization. for more details
                     ! how to implement this, see the " full svd " branch.
                      call stdlib_dlaset('G', n-nr, n, zero,zero, v(nr+1,1), ldv)
                      call stdlib_dgesvd( 'N', 'O', n, n, v, ldv, s, u, ldu,v, ldv, work(n+1), &
                                lwork-n, info )
                      call stdlib_dlapmt( .false., n, n, v, ldv, iwork )
                  end if
                  ! .. now [v] contains the transposed matrix of the right singular
                  ! vectors of a.
               end if
           else
      ! .......................................................................
             ! Full Svd Requested
      ! .......................................................................
              if ( rtrans ) then
                  ! .. apply stdlib_dgesvd to r**t [[this option is left for r
                 if ( wntvr .or. ( nr == n ) ) then
                  ! .. copy r**t into [v] and overwrite [v] with the left singular
                  ! vectors of r**t
                 do p = 1, nr
                    do q = p, n
                       v(q,p) = a(p,q)
                    end do
                 end do
                 if ( nr > 1 )call stdlib_dlaset( 'U', nr-1,nr-1, zero,zero, v(1,2), ldv )
                 ! .. the left singular vectors of r**t overwrite [v], the nr right
                 ! singular vectors of r**t stored in [u](1:nr,1:nr) as transposed
                    call stdlib_dgesvd( 'O', 'A', n, nr, v, ldv, s, v, ldv,u, ldu, work(n+1), &
                              lwork-n, info )
                    ! Assemble V
                    do p = 1, nr
                       do q = p + 1, nr
                          rtmp   = v(q,p)
                          v(q,p) = v(p,q)
                          v(p,q) = rtmp
                       end do
                    end do
                    if ( nr < n ) then
                        do p = 1, nr
                           do q = nr+1, n
                              v(p,q) = v(q,p)
                           end do
                        end do
                    end if
                    call stdlib_dlapmt( .false., nr, n, v, ldv, iwork )
                     do p = 1, nr
                        do q = p + 1, nr
                           rtmp   = u(q,p)
                           u(q,p) = u(p,q)
                           u(p,q) = rtmp
                        end do
                     end do
                     if ( ( nr < m ) .and. .not.(wntuf)) then
                       call stdlib_dlaset('A', m-nr,nr, zero,zero, u(nr+1,1), ldu)
                       if ( nr < n1 ) then
                          call stdlib_dlaset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                          call stdlib_dlaset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                       end if
                    end if
                 else
                     ! .. need all n right singular vectors and nr < n
                  ! .. copy r**t into [v] and overwrite [v] with the left singular
                  ! vectors of r**t
                     ! [[the optimal ratio n/nr for using qrf instead of padding
                       ! with zeros. here hard coded to 2; it must be at least
                       ! two due to work space constraints.]]
                     ! optratio = stdlib_ilaenv(6, 'dgesvd', 's' // 'o', nr,n,0,0)
                     ! optratio = max( optratio, 2 )
                     optratio = 2
                     if ( optratio*nr > n ) then
                        do p = 1, nr
                           do q = p, n
                              v(q,p) = a(p,q)
                           end do
                        end do
                        if ( nr > 1 )call stdlib_dlaset('U',nr-1,nr-1, zero,zero, v(1,2),ldv)
                                  
                        call stdlib_dlaset('A',n,n-nr,zero,zero,v(1,nr+1),ldv)
                        call stdlib_dgesvd( 'O', 'A', n, n, v, ldv, s, v, ldv,u, ldu, work(n+1), &
                                  lwork-n, info )
                        do p = 1, n
                           do q = p + 1, n
                              rtmp   = v(q,p)
                              v(q,p) = v(p,q)
                              v(p,q) = rtmp
                           end do
                        end do
                        call stdlib_dlapmt( .false., n, n, v, ldv, iwork )
                    ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x n1), i.e. (m x n) or (m x m).
                        do p = 1, n
                           do q = p + 1, n
                              rtmp   = u(q,p)
                              u(q,p) = u(p,q)
                              u(p,q) = rtmp
                           end do
                        end do
                        if ( ( n < m ) .and. .not.(wntuf)) then
                           call stdlib_dlaset('A',m-n,n,zero,zero,u(n+1,1),ldu)
                           if ( n < n1 ) then
                             call stdlib_dlaset('A',n,n1-n,zero,zero,u(1,n+1),ldu)
                             call stdlib_dlaset('A',m-n,n1-n,zero,one,u(n+1,n+1), ldu )
                           end if
                        end if
                     else
                        ! .. copy r**t into [u] and overwrite [u] with the right
                        ! singular vectors of r
                        do p = 1, nr
                           do q = p, n
                              u(q,nr+p) = a(p,q)
                           end do
                        end do
                        if ( nr > 1 )call stdlib_dlaset('U',nr-1,nr-1,zero,zero,u(1,nr+2),ldu)
                                  
                        call stdlib_dgeqrf( n, nr, u(1,nr+1), ldu, work(n+1),work(n+nr+1), lwork-&
                                  n-nr, ierr )
                        do p = 1, nr
                            do q = 1, n
                                v(q,p) = u(p,nr+q)
                            end do
                        end do
                       if (nr>1) call stdlib_dlaset('U',nr-1,nr-1,zero,zero,v(1,2),ldv)
                       call stdlib_dgesvd( 'S', 'O', nr, nr, v, ldv, s, u, ldu,v,ldv, work(n+nr+1)&
                                 ,lwork-n-nr, info )
                       call stdlib_dlaset('A',n-nr,nr,zero,zero,v(nr+1,1),ldv)
                       call stdlib_dlaset('A',nr,n-nr,zero,zero,v(1,nr+1),ldv)
                       call stdlib_dlaset('A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv)
                       call stdlib_dormqr('R','C', n, n, nr, u(1,nr+1), ldu,work(n+1),v,ldv,work(&
                                 n+nr+1),lwork-n-nr,ierr)
                       call stdlib_dlapmt( .false., n, n, v, ldv, iwork )
                       ! Assemble The Left Singular Vector Matrix U Of Dimensions
                       ! (m x nr) or (m x n) or (m x m).
                       if ( ( nr < m ) .and. .not.(wntuf)) then
                          call stdlib_dlaset('A',m-nr,nr,zero,zero,u(nr+1,1),ldu)
                          if ( nr < n1 ) then
                          call stdlib_dlaset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                          call stdlib_dlaset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1),ldu)
                          end if
                       end if
                     end if
                 end if
              else
                  ! .. apply stdlib_dgesvd to r [[this is the recommended option]]
                  if ( wntvr .or. ( nr == n ) ) then
                      ! .. copy r into [v] and overwrite v with the right singular vectors
                      call stdlib_dlacpy( 'U', nr, n, a, lda, v, ldv )
                     if ( nr > 1 )call stdlib_dlaset( 'L', nr-1,nr-1, zero,zero, v(2,1), ldv )
                               
                     ! .. the right singular vectors of r overwrite [v], the nr left
                     ! singular vectors of r stored in [u](1:nr,1:nr)
                     call stdlib_dgesvd( 'S', 'O', nr, n, v, ldv, s, u, ldu,v, ldv, work(n+1), &
                               lwork-n, info )
                     call stdlib_dlapmt( .false., nr, n, v, ldv, iwork )
                     ! .. now [v](1:nr,1:n) contains v(1:n,1:nr)**t
                     ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
                    if ( ( nr < m ) .and. .not.(wntuf)) then
                       call stdlib_dlaset('A', m-nr,nr, zero,zero, u(nr+1,1), ldu)
                       if ( nr < n1 ) then
                          call stdlib_dlaset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                          call stdlib_dlaset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                       end if
                    end if
                  else
                    ! .. need all n right singular vectors and nr < n
                    ! The Requested Number Of The Left Singular Vectors
                     ! is then n1 (n or m)
                     ! [[the optimal ratio n/nr for using lq instead of padding
                       ! with zeros. here hard coded to 2; it must be at least
                       ! two due to work space constraints.]]
                     ! optratio = stdlib_ilaenv(6, 'dgesvd', 's' // 'o', nr,n,0,0)
                     ! optratio = max( optratio, 2 )
                    optratio = 2
                    if ( optratio * nr > n ) then
                       call stdlib_dlacpy( 'U', nr, n, a, lda, v, ldv )
                       if ( nr > 1 )call stdlib_dlaset('L', nr-1,nr-1, zero,zero, v(2,1),ldv)
                                 
                    ! .. the right singular vectors of r overwrite [v], the nr left
                       ! singular vectors of r stored in [u](1:nr,1:nr)
                       call stdlib_dlaset('A', n-nr,n, zero,zero, v(nr+1,1),ldv)
                       call stdlib_dgesvd( 'S', 'O', n, n, v, ldv, s, u, ldu,v, ldv, work(n+1), &
                                 lwork-n, info )
                       call stdlib_dlapmt( .false., n, n, v, ldv, iwork )
                       ! .. now [v] contains the transposed matrix of the right
                       ! singular vectors of a. the leading n left singular vectors
                       ! are in [u](1:n,1:n)
                       ! Assemble The Left Singular Vector Matrix U Of Dimensions
                       ! (m x n1), i.e. (m x n) or (m x m).
                       if ( ( n < m ) .and. .not.(wntuf)) then
                           call stdlib_dlaset('A',m-n,n,zero,zero,u(n+1,1),ldu)
                           if ( n < n1 ) then
                             call stdlib_dlaset('A',n,n1-n,zero,zero,u(1,n+1),ldu)
                             call stdlib_dlaset( 'A',m-n,n1-n,zero,one,u(n+1,n+1), ldu )
                           end if
                       end if
                    else
                       call stdlib_dlacpy( 'U', nr, n, a, lda, u(nr+1,1), ldu )
                       if ( nr > 1 )call stdlib_dlaset('L',nr-1,nr-1,zero,zero,u(nr+2,1),ldu)
                                 
                       call stdlib_dgelqf( nr, n, u(nr+1,1), ldu, work(n+1),work(n+nr+1), lwork-n-&
                                 nr, ierr )
                       call stdlib_dlacpy('L',nr,nr,u(nr+1,1),ldu,v,ldv)
                       if ( nr > 1 )call stdlib_dlaset('U',nr-1,nr-1,zero,zero,v(1,2),ldv)
                       call stdlib_dgesvd( 'S', 'O', nr, nr, v, ldv, s, u, ldu,v, ldv, work(n+nr+&
                                 1), lwork-n-nr, info )
                       call stdlib_dlaset('A',n-nr,nr,zero,zero,v(nr+1,1),ldv)
                       call stdlib_dlaset('A',nr,n-nr,zero,zero,v(1,nr+1),ldv)
                       call stdlib_dlaset('A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv)
                       call stdlib_dormlq('R','N',n,n,nr,u(nr+1,1),ldu,work(n+1),v, ldv, work(n+&
                                 nr+1),lwork-n-nr,ierr)
                       call stdlib_dlapmt( .false., n, n, v, ldv, iwork )
                     ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
                       if ( ( nr < m ) .and. .not.(wntuf)) then
                          call stdlib_dlaset('A',m-nr,nr,zero,zero,u(nr+1,1),ldu)
                          if ( nr < n1 ) then
                          call stdlib_dlaset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                          call stdlib_dlaset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                          end if
                       end if
                    end if
                  end if
              ! .. end of the "r**t or r" branch
              end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! vectors matrix u.
              if ( .not. wntuf )call stdlib_dormqr( 'L', 'N', m, n1, n, a, lda, work, u,ldu, work(&
                        n+1), lwork-n, ierr )
              if ( rowprm .and. .not.wntuf )call stdlib_dlaswp( n1, u, ldu, 1, m-1, iwork(n+1), -&
                        1 )
           ! ... end of the "full svd" branch
           end if
           ! check whether some singular values are returned as zeros, e.g.
           ! due to underflow, and update the numerical rank.
           p = nr
           do q = p, 1, -1
               if ( s(q) > zero ) go to 4002
               nr = nr - 1
           end do
           4002 continue
           ! .. if numerical rank deficiency is detected, the truncated
           ! singular values are set to zero.
           if ( nr < n ) call stdlib_dlaset( 'G', n-nr,1, zero,zero, s(nr+1), n )
           ! .. undo scaling; this may cause overflow in the largest singular
           ! values.
           if ( ascaled )call stdlib_dlascl( 'G',0,0, one,sqrt(real(m,KIND=dp)), nr,1, s, n, ierr &
                     )
           if ( conda ) rwork(1) = sconda
           rwork(2) = p - nr
           ! .. p-nr is the number of singular values that are computed as
           ! exact zeros in stdlib_dgesvd() applied to the (possibly truncated)
           ! full row rank triangular (trapezoidal) factor of a.
           numrank = nr
           return
     end subroutine stdlib_dgesvdq

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$gesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
      numrank, iwork, liwork,work, lwork, rwork, lrwork, info )
     !! DGESVDQ: computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N orthogonal matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
               
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: joba, jobp, jobr, jobu, jobv
           integer(ilp), intent(in) :: m, n, lda, ldu, ldv, liwork, lrwork
           integer(ilp), intent(out) :: numrank, info
           integer(ilp), intent(inout) :: lwork
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: u(ldu,*), v(ldv,*), work(*)
           real(${rk}$), intent(out) :: s(*), rwork(*)
           integer(ilp), intent(out) :: iwork(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: ierr, iwoff, nr, n1, optratio, p, q
           integer(ilp) :: lwcon, lwqp3, lwrk_qgelqf, lwrk_qgesvd, lwrk_qgesvd2, lwrk_qgeqp3, &
           lwrk_qgeqrf, lwrk_qormlq, lwrk_qormqr, lwrk_qormqr2, lwlqf, lwqrf, lwsvd, lwsvd2, &
                     lworq, lworq2, lworlq, minwrk, minwrk2, optwrk, optwrk2, iminwrk, rminwrk
           logical(lk) :: accla, acclm, acclh, ascaled, conda, dntwu, dntwv, lquery, lsvc0, lsvec,&
                      rowprm, rsvec, rtrans, wntua, wntuf, wntur, wntus, wntva, wntvr
           real(${rk}$) :: big, epsln, rtmp, sconda, sfmin
           ! Local Arrays
           real(${rk}$) :: rdummy(1)
           ! Intrinsic Functions 
           ! test the input arguments
           wntus  = stdlib_lsame( jobu, 'S' ) .or. stdlib_lsame( jobu, 'U' )
           wntur  = stdlib_lsame( jobu, 'R' )
           wntua  = stdlib_lsame( jobu, 'A' )
           wntuf  = stdlib_lsame( jobu, 'F' )
           lsvc0  = wntus .or. wntur .or. wntua
           lsvec  = lsvc0 .or. wntuf
           dntwu  = stdlib_lsame( jobu, 'N' )
           wntvr  = stdlib_lsame( jobv, 'R' )
           wntva  = stdlib_lsame( jobv, 'A' ) .or. stdlib_lsame( jobv, 'V' )
           rsvec  = wntvr .or. wntva
           dntwv  = stdlib_lsame( jobv, 'N' )
           accla  = stdlib_lsame( joba, 'A' )
           acclm  = stdlib_lsame( joba, 'M' )
           conda  = stdlib_lsame( joba, 'E' )
           acclh  = stdlib_lsame( joba, 'H' ) .or. conda
           rowprm = stdlib_lsame( jobp, 'P' )
           rtrans = stdlib_lsame( jobr, 'T' )
           if ( rowprm ) then
              if ( conda ) then
                 iminwrk = max( 1, n + m - 1 + n )
              else
                 iminwrk = max( 1, n + m - 1 )
              end if
              rminwrk = max( 2, m )
           else
              if ( conda ) then
                 iminwrk = max( 1, n + n )
              else
                 iminwrk = max( 1, n )
              end if
              rminwrk = 2
           end if
           lquery = (liwork == -1 .or. lwork == -1 .or. lrwork == -1)
           info  = 0
           if ( .not. ( accla .or. acclm .or. acclh ) ) then
              info = -1
           else if ( .not.( rowprm .or. stdlib_lsame( jobp, 'N' ) ) ) then
               info = -2
           else if ( .not.( rtrans .or. stdlib_lsame( jobr, 'N' ) ) ) then
               info = -3
           else if ( .not.( lsvec .or. dntwu ) ) then
              info = -4
           else if ( wntur .and. wntva ) then
              info = -5
           else if ( .not.( rsvec .or. dntwv )) then
              info = -5
           else if ( m<0 ) then
              info = -6
           else if ( ( n<0 ) .or. ( n>m ) ) then
              info = -7
           else if ( lda<max( 1, m ) ) then
              info = -9
           else if ( ldu<1 .or. ( lsvc0 .and. ldu<m ) .or.( wntuf .and. ldu<n ) ) then
              info = -12
           else if ( ldv<1 .or. ( rsvec .and. ldv<n ) .or.( conda .and. ldv<n ) ) then
              info = -14
           else if ( liwork < iminwrk .and. .not. lquery ) then
              info = -17
           end if
           if ( info == 0 ) then
              ! Compute The Minimal And The Optimal Workspace Lengths
              ! [[the expressions for computing the minimal and the optimal
              ! values of lwork are written with a lot of redundancy and
              ! can be simplified. however, this detailed form is easier for
              ! maintenance and modifications of the code.]]
              ! Minimal Workspace Length For Stdlib_Dgeqp3 Of An M X N Matrix
              lwqp3 = 3 * n + 1
              ! Minimal Workspace Length For Stdlib_Dormqr To Build Left Singular Vectors
              if ( wntus .or. wntur ) then
                  lworq  = max( n  , 1 )
              else if ( wntua ) then
                  lworq = max( m , 1 )
              end if
              ! Minimal Workspace Length For Stdlib_Dpocon Of An N X N Matrix
              lwcon = 3 * n
              ! Stdlib_Dgesvd Of An N X N Matrix
              lwsvd = max( 5 * n, 1 )
              if ( lquery ) then
                  call stdlib_${ri}$geqp3( m, n, a, lda, iwork, rdummy, rdummy, -1,ierr )
                  lwrk_qgeqp3 = int( rdummy(1),KIND=ilp)
                  if ( wntus .or. wntur ) then
                      call stdlib_${ri}$ormqr( 'L', 'N', m, n, n, a, lda, rdummy, u,ldu, rdummy, -1, &
                                ierr )
                      lwrk_qormqr = int( rdummy(1),KIND=ilp)
                  else if ( wntua ) then
                      call stdlib_${ri}$ormqr( 'L', 'N', m, m, n, a, lda, rdummy, u,ldu, rdummy, -1, &
                                ierr )
                      lwrk_qormqr = int( rdummy(1),KIND=ilp)
                  else
                      lwrk_qormqr = 0
                  end if
              end if
              minwrk = 2
              optwrk = 2
              if ( .not. (lsvec .or. rsvec )) then
                  ! Minimal And Optimal Sizes Of The Workspace If
                  ! only the singular values are requested
                  if ( conda ) then
                     minwrk = max( n+lwqp3, lwcon, lwsvd )
                  else
                     minwrk = max( n+lwqp3, lwsvd )
                  end if
                  if ( lquery ) then
                      call stdlib_${ri}$gesvd( 'N', 'N', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                ierr )
                      lwrk_qgesvd = int( rdummy(1),KIND=ilp)
                      if ( conda ) then
                         optwrk = max( n+lwrk_qgeqp3, n+lwcon, lwrk_qgesvd )
                      else
                         optwrk = max( n+lwrk_qgeqp3, lwrk_qgesvd )
                      end if
                  end if
              else if ( lsvec .and. (.not.rsvec) ) then
                  ! Minimal And Optimal Sizes Of The Workspace If The
                  ! singular values and the left singular vectors are requested
                  if ( conda ) then
                      minwrk = n + max( lwqp3, lwcon, lwsvd, lworq )
                  else
                      minwrk = n + max( lwqp3, lwsvd, lworq )
                  end if
                  if ( lquery ) then
                     if ( rtrans ) then
                        call stdlib_${ri}$gesvd( 'N', 'O', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                  ierr )
                     else
                        call stdlib_${ri}$gesvd( 'O', 'N', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                  ierr )
                     end if
                     lwrk_qgesvd = int( rdummy(1),KIND=ilp)
                     if ( conda ) then
                         optwrk = n + max( lwrk_qgeqp3, lwcon, lwrk_qgesvd,lwrk_qormqr )
                     else
                         optwrk = n + max( lwrk_qgeqp3, lwrk_qgesvd,lwrk_qormqr )
                     end if
                  end if
              else if ( rsvec .and. (.not.lsvec) ) then
                  ! Minimal And Optimal Sizes Of The Workspace If The
                  ! singular values and the right singular vectors are requested
                  if ( conda ) then
                      minwrk = n + max( lwqp3, lwcon, lwsvd )
                  else
                      minwrk = n + max( lwqp3, lwsvd )
                  end if
                  if ( lquery ) then
                      if ( rtrans ) then
                          call stdlib_${ri}$gesvd( 'O', 'N', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -&
                                    1, ierr )
                      else
                          call stdlib_${ri}$gesvd( 'N', 'O', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -&
                                    1, ierr )
                      end if
                      lwrk_qgesvd = int( rdummy(1),KIND=ilp)
                      if ( conda ) then
                          optwrk = n + max( lwrk_qgeqp3, lwcon, lwrk_qgesvd )
                      else
                          optwrk = n + max( lwrk_qgeqp3, lwrk_qgesvd )
                      end if
                  end if
              else
                  ! Minimal And Optimal Sizes Of The Workspace If The
                  ! full svd is requested
                  if ( rtrans ) then
                      minwrk = max( lwqp3, lwsvd, lworq )
                      if ( conda ) minwrk = max( minwrk, lwcon )
                      minwrk = minwrk + n
                      if ( wntva ) then
                         ! .. minimal workspace length for n x n/2 stdlib_${ri}$geqrf
                         lwqrf  = max( n/2, 1 )
                         ! .. minimal workspace length for n/2 x n/2 stdlib_${ri}$gesvd
                         lwsvd2 = max( 5 * (n/2), 1 )
                         lworq2 = max( n, 1 )
                         minwrk2 = max( lwqp3, n/2+lwqrf, n/2+lwsvd2,n/2+lworq2, lworq )
                         if ( conda ) minwrk2 = max( minwrk2, lwcon )
                         minwrk2 = n + minwrk2
                         minwrk = max( minwrk, minwrk2 )
                      end if
                  else
                      minwrk = max( lwqp3, lwsvd, lworq )
                      if ( conda ) minwrk = max( minwrk, lwcon )
                      minwrk = minwrk + n
                      if ( wntva ) then
                         ! .. minimal workspace length for n/2 x n stdlib_${ri}$gelqf
                         lwlqf  = max( n/2, 1 )
                         lwsvd2 = max( 5 * (n/2), 1 )
                         lworlq = max( n , 1 )
                         minwrk2 = max( lwqp3, n/2+lwlqf, n/2+lwsvd2,n/2+lworlq, lworq )
                         if ( conda ) minwrk2 = max( minwrk2, lwcon )
                         minwrk2 = n + minwrk2
                         minwrk = max( minwrk, minwrk2 )
                      end if
                  end if
                  if ( lquery ) then
                     if ( rtrans ) then
                        call stdlib_${ri}$gesvd( 'O', 'A', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                  ierr )
                        lwrk_qgesvd = int( rdummy(1),KIND=ilp)
                        optwrk = max(lwrk_qgeqp3,lwrk_qgesvd,lwrk_qormqr)
                        if ( conda ) optwrk = max( optwrk, lwcon )
                        optwrk = n + optwrk
                        if ( wntva ) then
                            call stdlib_${ri}$geqrf(n,n/2,u,ldu,rdummy,rdummy,-1,ierr)
                            lwrk_qgeqrf = int( rdummy(1),KIND=ilp)
                            call stdlib_${ri}$gesvd( 'S', 'O', n/2,n/2, v,ldv, s, u,ldu,v, ldv, rdummy,&
                                       -1, ierr )
                            lwrk_qgesvd2 = int( rdummy(1),KIND=ilp)
                            call stdlib_${ri}$ormqr( 'R', 'C', n, n, n/2, u, ldu, rdummy,v, ldv, &
                                      rdummy, -1, ierr )
                            lwrk_qormqr2 = int( rdummy(1),KIND=ilp)
                            optwrk2 = max( lwrk_qgeqp3, n/2+lwrk_qgeqrf,n/2+lwrk_qgesvd2, n/2+&
                                      lwrk_qormqr2 )
                            if ( conda ) optwrk2 = max( optwrk2, lwcon )
                            optwrk2 = n + optwrk2
                            optwrk = max( optwrk, optwrk2 )
                        end if
                     else
                        call stdlib_${ri}$gesvd( 'S', 'O', n, n, a, lda, s, u, ldu,v, ldv, rdummy, -1, &
                                  ierr )
                        lwrk_qgesvd = int( rdummy(1),KIND=ilp)
                        optwrk = max(lwrk_qgeqp3,lwrk_qgesvd,lwrk_qormqr)
                        if ( conda ) optwrk = max( optwrk, lwcon )
                        optwrk = n + optwrk
                        if ( wntva ) then
                           call stdlib_${ri}$gelqf(n/2,n,u,ldu,rdummy,rdummy,-1,ierr)
                           lwrk_qgelqf = int( rdummy(1),KIND=ilp)
                           call stdlib_${ri}$gesvd( 'S','O', n/2,n/2, v, ldv, s, u, ldu,v, ldv, rdummy,&
                                      -1, ierr )
                           lwrk_qgesvd2 = int( rdummy(1),KIND=ilp)
                           call stdlib_${ri}$ormlq( 'R', 'N', n, n, n/2, u, ldu, rdummy,v, ldv, rdummy,&
                                     -1,ierr )
                           lwrk_qormlq = int( rdummy(1),KIND=ilp)
                           optwrk2 = max( lwrk_qgeqp3, n/2+lwrk_qgelqf,n/2+lwrk_qgesvd2, n/2+&
                                     lwrk_qormlq )
                            if ( conda ) optwrk2 = max( optwrk2, lwcon )
                            optwrk2 = n + optwrk2
                            optwrk = max( optwrk, optwrk2 )
                        end if
                     end if
                  end if
              end if
              minwrk = max( 2, minwrk )
              optwrk = max( 2, optwrk )
              if ( lwork < minwrk .and. (.not.lquery) ) info = -19
           end if
           if (info == 0 .and. lrwork < rminwrk .and. .not. lquery) then
              info = -21
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGESVDQ', -info )
              return
           else if ( lquery ) then
           ! return optimal workspace
               iwork(1) = iminwrk
               work(1) = optwrk
               work(2) = minwrk
               rwork(1) = rminwrk
               return
           end if
           ! quick return if the matrix is void.
           if( ( m==0 ) .or. ( n==0 ) ) then
           ! All Output Is Void
              return
           end if
           big = stdlib_${ri}$lamch('O')
           ascaled = .false.
           iwoff = 1
           if ( rowprm ) then
                 iwoff = m
                 ! Reordering The Rows In Decreasing Sequence In The
                 ! ell-infinity norm - this enhances numerical robustness in
                 ! the case of differently scaled rows.
                 do p = 1, m
                     ! rwork(p) = abs( a(p,stdlib_izamax(n,a(p,1),lda)) )
                     ! [[stdlib_${ri}$lange will return nan if an entry of the p-th row is nan]]
                     rwork(p) = stdlib_${ri}$lange( 'M', 1, n, a(p,1), lda, rdummy )
                     ! .. check for nan's and inf's
                     if ( ( rwork(p) /= rwork(p) ) .or.( (rwork(p)*zero) /= zero ) ) then
                         info = -8
                         call stdlib_xerbla( 'DGESVDQ', -info )
                         return
                     end if
                 end do
                 do p = 1, m - 1
                 q = stdlib_i${ri}$amax( m-p+1, rwork(p), 1 ) + p - 1
                 iwork(n+p) = q
                 if ( p /= q ) then
                    rtmp     = rwork(p)
                    rwork(p) = rwork(q)
                    rwork(q) = rtmp
                 end if
                 end do
                 if ( rwork(1) == zero ) then
                    ! quick return: a is the m x n zero matrix.
                    numrank = 0
                    call stdlib_${ri}$laset( 'G', n, 1, zero, zero, s, n )
                    if ( wntus ) call stdlib_${ri}$laset('G', m, n, zero, one, u, ldu)
                    if ( wntua ) call stdlib_${ri}$laset('G', m, m, zero, one, u, ldu)
                    if ( wntva ) call stdlib_${ri}$laset('G', n, n, zero, one, v, ldv)
                    if ( wntuf ) then
                        call stdlib_${ri}$laset( 'G', n, 1, zero, zero, work, n )
                        call stdlib_${ri}$laset( 'G', m, n, zero,  one, u, ldu )
                    end if
                    do p = 1, n
                        iwork(p) = p
                    end do
                    if ( rowprm ) then
                        do p = n + 1, n + m - 1
                            iwork(p) = p - n
                        end do
                    end if
                    if ( conda ) rwork(1) = -1
                    rwork(2) = -1
                    return
                 end if
                 if ( rwork(1) > big / sqrt(real(m,KIND=${rk}$)) ) then
                     ! .. to prevent overflow in the qr factorization, scale the
                     ! matrix by 1/sqrt(m) if too large entry detected
                     call stdlib_${ri}$lascl('G',0,0,sqrt(real(m,KIND=${rk}$)),one, m,n, a,lda, ierr)
                               
                     ascaled = .true.
                 end if
                 call stdlib_${ri}$laswp( n, a, lda, 1, m-1, iwork(n+1), 1 )
           end if
          ! .. at this stage, preemptive scaling is done only to avoid column
          ! norms overflows during the qr factorization. the svd procedure should
          ! have its own scaling to save the singular values from overflows and
          ! underflows. that depends on the svd procedure.
           if ( .not.rowprm ) then
               rtmp = stdlib_${ri}$lange( 'M', m, n, a, lda, rdummy )
               if ( ( rtmp /= rtmp ) .or.( (rtmp*zero) /= zero ) ) then
                    info = -8
                    call stdlib_xerbla( 'DGESVDQ', -info )
                    return
               end if
               if ( rtmp > big / sqrt(real(m,KIND=${rk}$)) ) then
                   ! .. to prevent overflow in the qr factorization, scale the
                   ! matrix by 1/sqrt(m) if too large entry detected
                   call stdlib_${ri}$lascl('G',0,0, sqrt(real(m,KIND=${rk}$)),one, m,n, a,lda, ierr)
                             
                   ascaled = .true.
               end if
           end if
           ! Qr Factorization With Column Pivoting
           ! a * p = q * [ r ]
                       ! [ 0 ]
           do p = 1, n
              ! All Columns Are Free Columns
              iwork(p) = 0
           end do
           call stdlib_${ri}$geqp3( m, n, a, lda, iwork, work, work(n+1), lwork-n,ierr )
          ! if the user requested accuracy level allows truncation in the
          ! computed upper triangular factor, the matrix r is examined and,
          ! if possible, replaced with its leading upper trapezoidal part.
           epsln = stdlib_${ri}$lamch('E')
           sfmin = stdlib_${ri}$lamch('S')
           ! small = sfmin / epsln
           nr = n
           if ( accla ) then
              ! standard absolute error bound suffices. all sigma_i with
              ! sigma_i < n*eps*||a||_f are flushed to zero. this is an
              ! aggressive enforcement of lower numerical rank by introducing a
              ! backward error of the order of n*eps*||a||_f.
              nr = 1
              rtmp = sqrt(real(n,KIND=${rk}$))*epsln
              do p = 2, n
                 if ( abs(a(p,p)) < (rtmp*abs(a(1,1))) ) go to 3002
                    nr = nr + 1
              end do
              3002 continue
           elseif ( acclm ) then
              ! .. similarly as above, only slightly more gentle (less aggressive).
              ! sudden drop on the diagonal of r is used as the criterion for being
              ! close-to-rank-deficient. the threshold is set to epsln=stdlib_${ri}$lamch('e').
              ! [[this can be made more flexible by replacing this hard-coded value
              ! with a user specified threshold.]] also, the values that underflow
              ! will be truncated.
              nr = 1
              do p = 2, n
                 if ( ( abs(a(p,p)) < (epsln*abs(a(p-1,p-1))) ) .or.( abs(a(p,p)) < sfmin ) ) go &
                           to 3402
                 nr = nr + 1
              end do
              3402 continue
           else
              ! Rrqr Not Authorized To Determine Numerical Rank Except In The
              ! obvious case of zero pivots.
              ! .. inspect r for exact zeros on the diagonal;
              ! r(i,i)=0 => r(i:n,i:n)=0.
              nr = 1
              do p = 2, n
                 if ( abs(a(p,p)) == zero ) go to 3502
                 nr = nr + 1
              end do
              3502 continue
              if ( conda ) then
                 ! estimate the scaled condition number of a. use the fact that it is
                 ! the same as the scaled condition number of r.
                    ! V Is Used As Workspace
                    call stdlib_${ri}$lacpy( 'U', n, n, a, lda, v, ldv )
                    ! only the leading nr x nr submatrix of the triangular factor
                    ! is considered. only if nr=n will this give a reliable error
                    ! bound. however, even for nr < n, this can be used on an
                    ! expert level and obtain useful information in the sense of
                    ! perturbation theory.
                    do p = 1, nr
                       rtmp = stdlib_${ri}$nrm2( p, v(1,p), 1 )
                       call stdlib_${ri}$scal( p, one/rtmp, v(1,p), 1 )
                    end do
                    if ( .not. ( lsvec .or. rsvec ) ) then
                        call stdlib_${ri}$pocon( 'U', nr, v, ldv, one, rtmp,work, iwork(n+iwoff), ierr &
                                  )
                    else
                        call stdlib_${ri}$pocon( 'U', nr, v, ldv, one, rtmp,work(n+1), iwork(n+iwoff), &
                                  ierr )
                    end if
                    sconda = one / sqrt(rtmp)
                 ! for nr=n, sconda is an estimate of sqrt(||(r^* * r)^(-1)||_1),
                 ! n^(-1/4) * sconda <= ||r^(-1)||_2 <= n^(1/4) * sconda
                 ! see the reference [1] for more details.
              end if
           endif
           if ( wntur ) then
               n1 = nr
           else if ( wntus .or. wntuf) then
               n1 = n
           else if ( wntua ) then
               n1 = m
           end if
           if ( .not. ( rsvec .or. lsvec ) ) then
      ! .......................................................................
              ! Only The Singular Values Are Requested
      ! .......................................................................
              if ( rtrans ) then
               ! .. compute the singular values of r**t = [a](1:nr,1:n)**t
                 ! .. set the lower triangle of [a] to [a](1:nr,1:n)**t and
                 ! the upper triangle of [a] to zero.
                 do p = 1, min( n, nr )
                    do q = p + 1, n
                       a(q,p) = a(p,q)
                       if ( q <= nr ) a(p,q) = zero
                    end do
                 end do
                 call stdlib_${ri}$gesvd( 'N', 'N', n, nr, a, lda, s, u, ldu,v, ldv, work, lwork, info &
                           )
              else
                 ! .. compute the singular values of r = [a](1:nr,1:n)
                 if ( nr > 1 )call stdlib_${ri}$laset( 'L', nr-1,nr-1, zero,zero, a(2,1), lda )
                 call stdlib_${ri}$gesvd( 'N', 'N', nr, n, a, lda, s, u, ldu,v, ldv, work, lwork, info &
                           )
              end if
           else if ( lsvec .and. ( .not. rsvec) ) then
      ! .......................................................................
             ! The Singular Values And The Left Singular Vectors Requested
      ! .......................................................................""""""""
              if ( rtrans ) then
                  ! .. apply stdlib_${ri}$gesvd to r**t
                  ! .. copy r**t into [u] and overwrite [u] with the right singular
                  ! vectors of r
                 do p = 1, nr
                    do q = p, n
                       u(q,p) = a(p,q)
                    end do
                 end do
                 if ( nr > 1 )call stdlib_${ri}$laset( 'U', nr-1,nr-1, zero,zero, u(1,2), ldu )
                 ! .. the left singular vectors not computed, the nr right singular
                 ! vectors overwrite [u](1:nr,1:nr) as transposed. these
                 ! will be pre-multiplied by q to build the left singular vectors of a.
                    call stdlib_${ri}$gesvd( 'N', 'O', n, nr, u, ldu, s, u, ldu,u, ldu, work(n+1), &
                              lwork-n, info )
                    do p = 1, nr
                        do q = p + 1, nr
                           rtmp   = u(q,p)
                           u(q,p) = u(p,q)
                           u(p,q) = rtmp
                        end do
                    end do
              else
                  ! Apply Stdlib_Dgesvd To R
                  ! .. copy r into [u] and overwrite [u] with the left singular vectors
                  call stdlib_${ri}$lacpy( 'U', nr, n, a, lda, u, ldu )
                  if ( nr > 1 )call stdlib_${ri}$laset( 'L', nr-1, nr-1, zero, zero, u(2,1), ldu )
                            
                  ! .. the right singular vectors not computed, the nr left singular
                  ! vectors overwrite [u](1:nr,1:nr)
                     call stdlib_${ri}$gesvd( 'O', 'N', nr, n, u, ldu, s, u, ldu,v, ldv, work(n+1), &
                               lwork-n, info )
                     ! .. now [u](1:nr,1:nr) contains the nr left singular vectors of
                     ! r. these will be pre-multiplied by q to build the left singular
                     ! vectors of a.
              end if
                 ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
              if ( ( nr < m ) .and. ( .not.wntuf ) ) then
                  call stdlib_${ri}$laset('A', m-nr, nr, zero, zero, u(nr+1,1), ldu)
                  if ( nr < n1 ) then
                     call stdlib_${ri}$laset( 'A',nr,n1-nr,zero,zero,u(1,nr+1), ldu )
                     call stdlib_${ri}$laset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                  end if
              end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! vectors matrix u.
              if ( .not.wntuf )call stdlib_${ri}$ormqr( 'L', 'N', m, n1, n, a, lda, work, u,ldu, work(&
                        n+1), lwork-n, ierr )
              if ( rowprm .and. .not.wntuf )call stdlib_${ri}$laswp( n1, u, ldu, 1, m-1, iwork(n+1), -&
                        1 )
           else if ( rsvec .and. ( .not. lsvec ) ) then
      ! .......................................................................
             ! The Singular Values And The Right Singular Vectors Requested
      ! .......................................................................
               if ( rtrans ) then
                  ! .. apply stdlib_${ri}$gesvd to r**t
                  ! .. copy r**t into v and overwrite v with the left singular vectors
                 do p = 1, nr
                    do q = p, n
                       v(q,p) = (a(p,q))
                    end do
                 end do
                 if ( nr > 1 )call stdlib_${ri}$laset( 'U', nr-1,nr-1, zero,zero, v(1,2), ldv )
                 ! .. the left singular vectors of r**t overwrite v, the right singular
                 ! vectors not computed
                 if ( wntvr .or. ( nr == n ) ) then
                    call stdlib_${ri}$gesvd( 'O', 'N', n, nr, v, ldv, s, u, ldu,u, ldu, work(n+1), &
                              lwork-n, info )
                    do p = 1, nr
                        do q = p + 1, nr
                           rtmp   = v(q,p)
                           v(q,p) = v(p,q)
                           v(p,q) = rtmp
                        end do
                    end do
                    if ( nr < n ) then
                        do p = 1, nr
                           do q = nr + 1, n
                               v(p,q) = v(q,p)
                           end do
                        end do
                    end if
                    call stdlib_${ri}$lapmt( .false., nr, n, v, ldv, iwork )
                 else
                     ! .. need all n right singular vectors and nr < n
                     ! [!] this is simple implementation that augments [v](1:n,1:nr)
                     ! by padding a zero block. in the case nr << n, a more efficient
                     ! way is to first use the qr factorization. for more details
                     ! how to implement this, see the " full svd " branch.
                     call stdlib_${ri}$laset('G', n, n-nr, zero, zero, v(1,nr+1), ldv)
                     call stdlib_${ri}$gesvd( 'O', 'N', n, n, v, ldv, s, u, ldu,u, ldu, work(n+1), &
                               lwork-n, info )
                     do p = 1, n
                        do q = p + 1, n
                           rtmp   = v(q,p)
                           v(q,p) = v(p,q)
                           v(p,q) = rtmp
                        end do
                     end do
                     call stdlib_${ri}$lapmt( .false., n, n, v, ldv, iwork )
                 end if
               else
                  ! Aply Stdlib_Dgesvd To R
                  ! Copy R Into V And Overwrite V With The Right Singular Vectors
                  call stdlib_${ri}$lacpy( 'U', nr, n, a, lda, v, ldv )
                  if ( nr > 1 )call stdlib_${ri}$laset( 'L', nr-1, nr-1, zero, zero, v(2,1), ldv )
                            
                  ! .. the right singular vectors overwrite v, the nr left singular
                  ! vectors stored in u(1:nr,1:nr)
                  if ( wntvr .or. ( nr == n ) ) then
                     call stdlib_${ri}$gesvd( 'N', 'O', nr, n, v, ldv, s, u, ldu,v, ldv, work(n+1), &
                               lwork-n, info )
                     call stdlib_${ri}$lapmt( .false., nr, n, v, ldv, iwork )
                     ! .. now [v](1:nr,1:n) contains v(1:n,1:nr)**t
                  else
                     ! .. need all n right singular vectors and nr < n
                     ! [!] this is simple implementation that augments [v](1:nr,1:n)
                     ! by padding a zero block. in the case nr << n, a more efficient
                     ! way is to first use the lq factorization. for more details
                     ! how to implement this, see the " full svd " branch.
                      call stdlib_${ri}$laset('G', n-nr, n, zero,zero, v(nr+1,1), ldv)
                      call stdlib_${ri}$gesvd( 'N', 'O', n, n, v, ldv, s, u, ldu,v, ldv, work(n+1), &
                                lwork-n, info )
                      call stdlib_${ri}$lapmt( .false., n, n, v, ldv, iwork )
                  end if
                  ! .. now [v] contains the transposed matrix of the right singular
                  ! vectors of a.
               end if
           else
      ! .......................................................................
             ! Full Svd Requested
      ! .......................................................................
              if ( rtrans ) then
                  ! .. apply stdlib_${ri}$gesvd to r**t [[this option is left for r
                 if ( wntvr .or. ( nr == n ) ) then
                  ! .. copy r**t into [v] and overwrite [v] with the left singular
                  ! vectors of r**t
                 do p = 1, nr
                    do q = p, n
                       v(q,p) = a(p,q)
                    end do
                 end do
                 if ( nr > 1 )call stdlib_${ri}$laset( 'U', nr-1,nr-1, zero,zero, v(1,2), ldv )
                 ! .. the left singular vectors of r**t overwrite [v], the nr right
                 ! singular vectors of r**t stored in [u](1:nr,1:nr) as transposed
                    call stdlib_${ri}$gesvd( 'O', 'A', n, nr, v, ldv, s, v, ldv,u, ldu, work(n+1), &
                              lwork-n, info )
                    ! Assemble V
                    do p = 1, nr
                       do q = p + 1, nr
                          rtmp   = v(q,p)
                          v(q,p) = v(p,q)
                          v(p,q) = rtmp
                       end do
                    end do
                    if ( nr < n ) then
                        do p = 1, nr
                           do q = nr+1, n
                              v(p,q) = v(q,p)
                           end do
                        end do
                    end if
                    call stdlib_${ri}$lapmt( .false., nr, n, v, ldv, iwork )
                     do p = 1, nr
                        do q = p + 1, nr
                           rtmp   = u(q,p)
                           u(q,p) = u(p,q)
                           u(p,q) = rtmp
                        end do
                     end do
                     if ( ( nr < m ) .and. .not.(wntuf)) then
                       call stdlib_${ri}$laset('A', m-nr,nr, zero,zero, u(nr+1,1), ldu)
                       if ( nr < n1 ) then
                          call stdlib_${ri}$laset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                          call stdlib_${ri}$laset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                       end if
                    end if
                 else
                     ! .. need all n right singular vectors and nr < n
                  ! .. copy r**t into [v] and overwrite [v] with the left singular
                  ! vectors of r**t
                     ! [[the optimal ratio n/nr for using qrf instead of padding
                       ! with zeros. here hard coded to 2; it must be at least
                       ! two due to work space constraints.]]
                     ! optratio = stdlib_ilaenv(6, 'dgesvd', 's' // 'o', nr,n,0,0)
                     ! optratio = max( optratio, 2 )
                     optratio = 2
                     if ( optratio*nr > n ) then
                        do p = 1, nr
                           do q = p, n
                              v(q,p) = a(p,q)
                           end do
                        end do
                        if ( nr > 1 )call stdlib_${ri}$laset('U',nr-1,nr-1, zero,zero, v(1,2),ldv)
                                  
                        call stdlib_${ri}$laset('A',n,n-nr,zero,zero,v(1,nr+1),ldv)
                        call stdlib_${ri}$gesvd( 'O', 'A', n, n, v, ldv, s, v, ldv,u, ldu, work(n+1), &
                                  lwork-n, info )
                        do p = 1, n
                           do q = p + 1, n
                              rtmp   = v(q,p)
                              v(q,p) = v(p,q)
                              v(p,q) = rtmp
                           end do
                        end do
                        call stdlib_${ri}$lapmt( .false., n, n, v, ldv, iwork )
                    ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x n1), i.e. (m x n) or (m x m).
                        do p = 1, n
                           do q = p + 1, n
                              rtmp   = u(q,p)
                              u(q,p) = u(p,q)
                              u(p,q) = rtmp
                           end do
                        end do
                        if ( ( n < m ) .and. .not.(wntuf)) then
                           call stdlib_${ri}$laset('A',m-n,n,zero,zero,u(n+1,1),ldu)
                           if ( n < n1 ) then
                             call stdlib_${ri}$laset('A',n,n1-n,zero,zero,u(1,n+1),ldu)
                             call stdlib_${ri}$laset('A',m-n,n1-n,zero,one,u(n+1,n+1), ldu )
                           end if
                        end if
                     else
                        ! .. copy r**t into [u] and overwrite [u] with the right
                        ! singular vectors of r
                        do p = 1, nr
                           do q = p, n
                              u(q,nr+p) = a(p,q)
                           end do
                        end do
                        if ( nr > 1 )call stdlib_${ri}$laset('U',nr-1,nr-1,zero,zero,u(1,nr+2),ldu)
                                  
                        call stdlib_${ri}$geqrf( n, nr, u(1,nr+1), ldu, work(n+1),work(n+nr+1), lwork-&
                                  n-nr, ierr )
                        do p = 1, nr
                            do q = 1, n
                                v(q,p) = u(p,nr+q)
                            end do
                        end do
                       if (nr>1) call stdlib_${ri}$laset('U',nr-1,nr-1,zero,zero,v(1,2),ldv)
                       call stdlib_${ri}$gesvd( 'S', 'O', nr, nr, v, ldv, s, u, ldu,v,ldv, work(n+nr+1)&
                                 ,lwork-n-nr, info )
                       call stdlib_${ri}$laset('A',n-nr,nr,zero,zero,v(nr+1,1),ldv)
                       call stdlib_${ri}$laset('A',nr,n-nr,zero,zero,v(1,nr+1),ldv)
                       call stdlib_${ri}$laset('A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv)
                       call stdlib_${ri}$ormqr('R','C', n, n, nr, u(1,nr+1), ldu,work(n+1),v,ldv,work(&
                                 n+nr+1),lwork-n-nr,ierr)
                       call stdlib_${ri}$lapmt( .false., n, n, v, ldv, iwork )
                       ! Assemble The Left Singular Vector Matrix U Of Dimensions
                       ! (m x nr) or (m x n) or (m x m).
                       if ( ( nr < m ) .and. .not.(wntuf)) then
                          call stdlib_${ri}$laset('A',m-nr,nr,zero,zero,u(nr+1,1),ldu)
                          if ( nr < n1 ) then
                          call stdlib_${ri}$laset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                          call stdlib_${ri}$laset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1),ldu)
                          end if
                       end if
                     end if
                 end if
              else
                  ! .. apply stdlib_${ri}$gesvd to r [[this is the recommended option]]
                  if ( wntvr .or. ( nr == n ) ) then
                      ! .. copy r into [v] and overwrite v with the right singular vectors
                      call stdlib_${ri}$lacpy( 'U', nr, n, a, lda, v, ldv )
                     if ( nr > 1 )call stdlib_${ri}$laset( 'L', nr-1,nr-1, zero,zero, v(2,1), ldv )
                               
                     ! .. the right singular vectors of r overwrite [v], the nr left
                     ! singular vectors of r stored in [u](1:nr,1:nr)
                     call stdlib_${ri}$gesvd( 'S', 'O', nr, n, v, ldv, s, u, ldu,v, ldv, work(n+1), &
                               lwork-n, info )
                     call stdlib_${ri}$lapmt( .false., nr, n, v, ldv, iwork )
                     ! .. now [v](1:nr,1:n) contains v(1:n,1:nr)**t
                     ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
                    if ( ( nr < m ) .and. .not.(wntuf)) then
                       call stdlib_${ri}$laset('A', m-nr,nr, zero,zero, u(nr+1,1), ldu)
                       if ( nr < n1 ) then
                          call stdlib_${ri}$laset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                          call stdlib_${ri}$laset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                       end if
                    end if
                  else
                    ! .. need all n right singular vectors and nr < n
                    ! The Requested Number Of The Left Singular Vectors
                     ! is then n1 (n or m)
                     ! [[the optimal ratio n/nr for using lq instead of padding
                       ! with zeros. here hard coded to 2; it must be at least
                       ! two due to work space constraints.]]
                     ! optratio = stdlib_ilaenv(6, 'dgesvd', 's' // 'o', nr,n,0,0)
                     ! optratio = max( optratio, 2 )
                    optratio = 2
                    if ( optratio * nr > n ) then
                       call stdlib_${ri}$lacpy( 'U', nr, n, a, lda, v, ldv )
                       if ( nr > 1 )call stdlib_${ri}$laset('L', nr-1,nr-1, zero,zero, v(2,1),ldv)
                                 
                    ! .. the right singular vectors of r overwrite [v], the nr left
                       ! singular vectors of r stored in [u](1:nr,1:nr)
                       call stdlib_${ri}$laset('A', n-nr,n, zero,zero, v(nr+1,1),ldv)
                       call stdlib_${ri}$gesvd( 'S', 'O', n, n, v, ldv, s, u, ldu,v, ldv, work(n+1), &
                                 lwork-n, info )
                       call stdlib_${ri}$lapmt( .false., n, n, v, ldv, iwork )
                       ! .. now [v] contains the transposed matrix of the right
                       ! singular vectors of a. the leading n left singular vectors
                       ! are in [u](1:n,1:n)
                       ! Assemble The Left Singular Vector Matrix U Of Dimensions
                       ! (m x n1), i.e. (m x n) or (m x m).
                       if ( ( n < m ) .and. .not.(wntuf)) then
                           call stdlib_${ri}$laset('A',m-n,n,zero,zero,u(n+1,1),ldu)
                           if ( n < n1 ) then
                             call stdlib_${ri}$laset('A',n,n1-n,zero,zero,u(1,n+1),ldu)
                             call stdlib_${ri}$laset( 'A',m-n,n1-n,zero,one,u(n+1,n+1), ldu )
                           end if
                       end if
                    else
                       call stdlib_${ri}$lacpy( 'U', nr, n, a, lda, u(nr+1,1), ldu )
                       if ( nr > 1 )call stdlib_${ri}$laset('L',nr-1,nr-1,zero,zero,u(nr+2,1),ldu)
                                 
                       call stdlib_${ri}$gelqf( nr, n, u(nr+1,1), ldu, work(n+1),work(n+nr+1), lwork-n-&
                                 nr, ierr )
                       call stdlib_${ri}$lacpy('L',nr,nr,u(nr+1,1),ldu,v,ldv)
                       if ( nr > 1 )call stdlib_${ri}$laset('U',nr-1,nr-1,zero,zero,v(1,2),ldv)
                       call stdlib_${ri}$gesvd( 'S', 'O', nr, nr, v, ldv, s, u, ldu,v, ldv, work(n+nr+&
                                 1), lwork-n-nr, info )
                       call stdlib_${ri}$laset('A',n-nr,nr,zero,zero,v(nr+1,1),ldv)
                       call stdlib_${ri}$laset('A',nr,n-nr,zero,zero,v(1,nr+1),ldv)
                       call stdlib_${ri}$laset('A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv)
                       call stdlib_${ri}$ormlq('R','N',n,n,nr,u(nr+1,1),ldu,work(n+1),v, ldv, work(n+&
                                 nr+1),lwork-n-nr,ierr)
                       call stdlib_${ri}$lapmt( .false., n, n, v, ldv, iwork )
                     ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
                       if ( ( nr < m ) .and. .not.(wntuf)) then
                          call stdlib_${ri}$laset('A',m-nr,nr,zero,zero,u(nr+1,1),ldu)
                          if ( nr < n1 ) then
                          call stdlib_${ri}$laset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                          call stdlib_${ri}$laset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                          end if
                       end if
                    end if
                  end if
              ! .. end of the "r**t or r" branch
              end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! vectors matrix u.
              if ( .not. wntuf )call stdlib_${ri}$ormqr( 'L', 'N', m, n1, n, a, lda, work, u,ldu, work(&
                        n+1), lwork-n, ierr )
              if ( rowprm .and. .not.wntuf )call stdlib_${ri}$laswp( n1, u, ldu, 1, m-1, iwork(n+1), -&
                        1 )
           ! ... end of the "full svd" branch
           end if
           ! check whether some singular values are returned as zeros, e.g.
           ! due to underflow, and update the numerical rank.
           p = nr
           do q = p, 1, -1
               if ( s(q) > zero ) go to 4002
               nr = nr - 1
           end do
           4002 continue
           ! .. if numerical rank deficiency is detected, the truncated
           ! singular values are set to zero.
           if ( nr < n ) call stdlib_${ri}$laset( 'G', n-nr,1, zero,zero, s(nr+1), n )
           ! .. undo scaling; this may cause overflow in the largest singular
           ! values.
           if ( ascaled )call stdlib_${ri}$lascl( 'G',0,0, one,sqrt(real(m,KIND=${rk}$)), nr,1, s, n, ierr &
                     )
           if ( conda ) rwork(1) = sconda
           rwork(2) = p - nr
           ! .. p-nr is the number of singular values that are computed as
           ! exact zeros in stdlib_${ri}$gesvd() applied to the (possibly truncated)
           ! full row rank triangular (trapezoidal) factor of a.
           numrank = nr
           return
     end subroutine stdlib_${ri}$gesvdq

#:endif
#:endfor

     module subroutine stdlib_cgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
      numrank, iwork, liwork,cwork, lcwork, rwork, lrwork, info )
     !! CGESVDQ computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N unitary matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
               
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: joba, jobp, jobr, jobu, jobv
           integer(ilp), intent(in) :: m, n, lda, ldu, ldv, liwork, lrwork
           integer(ilp), intent(out) :: numrank, info
           integer(ilp), intent(inout) :: lcwork
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: u(ldu,*), v(ldv,*), cwork(*)
           real(sp), intent(out) :: s(*), rwork(*)
           integer(ilp), intent(out) :: iwork(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           integer(ilp) :: ierr, nr, n1, optratio, p, q
           integer(ilp) :: lwcon, lwqp3, lwrk_cgelqf, lwrk_cgesvd, lwrk_cgesvd2, lwrk_cgeqp3, &
           lwrk_cgeqrf, lwrk_cunmlq, lwrk_cunmqr, lwrk_cunmqr2, lwlqf, lwqrf, lwsvd, lwsvd2, &
                     lwunq, lwunq2, lwunlq, minwrk, minwrk2, optwrk, optwrk2, iminwrk, rminwrk
           logical(lk) :: accla, acclm, acclh, ascaled, conda, dntwu, dntwv, lquery, lsvc0, lsvec,&
                      rowprm, rsvec, rtrans, wntua, wntuf, wntur, wntus, wntva, wntvr
           real(sp) :: big, epsln, rtmp, sconda, sfmin
           complex(sp) :: ctmp
           ! Local Arrays
           complex(sp) :: cdummy(1)
           real(sp) :: rdummy(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           wntus  = stdlib_lsame( jobu, 'S' ) .or. stdlib_lsame( jobu, 'U' )
           wntur  = stdlib_lsame( jobu, 'R' )
           wntua  = stdlib_lsame( jobu, 'A' )
           wntuf  = stdlib_lsame( jobu, 'F' )
           lsvc0  = wntus .or. wntur .or. wntua
           lsvec  = lsvc0 .or. wntuf
           dntwu  = stdlib_lsame( jobu, 'N' )
           wntvr  = stdlib_lsame( jobv, 'R' )
           wntva  = stdlib_lsame( jobv, 'A' ) .or. stdlib_lsame( jobv, 'V' )
           rsvec  = wntvr .or. wntva
           dntwv  = stdlib_lsame( jobv, 'N' )
           accla  = stdlib_lsame( joba, 'A' )
           acclm  = stdlib_lsame( joba, 'M' )
           conda  = stdlib_lsame( joba, 'E' )
           acclh  = stdlib_lsame( joba, 'H' ) .or. conda
           rowprm = stdlib_lsame( jobp, 'P' )
           rtrans = stdlib_lsame( jobr, 'T' )
           if ( rowprm ) then
              iminwrk = max( 1, n + m - 1 )
              rminwrk = max( 2, m, 5*n )
           else
              iminwrk = max( 1, n )
              rminwrk = max( 2, 5*n )
           end if
           lquery = (liwork == -1 .or. lcwork == -1 .or. lrwork == -1)
           info  = 0
           if ( .not. ( accla .or. acclm .or. acclh ) ) then
              info = -1
           else if ( .not.( rowprm .or. stdlib_lsame( jobp, 'N' ) ) ) then
               info = -2
           else if ( .not.( rtrans .or. stdlib_lsame( jobr, 'N' ) ) ) then
               info = -3
           else if ( .not.( lsvec .or. dntwu ) ) then
              info = -4
           else if ( wntur .and. wntva ) then
              info = -5
           else if ( .not.( rsvec .or. dntwv )) then
              info = -5
           else if ( m<0 ) then
              info = -6
           else if ( ( n<0 ) .or. ( n>m ) ) then
              info = -7
           else if ( lda<max( 1, m ) ) then
              info = -9
           else if ( ldu<1 .or. ( lsvc0 .and. ldu<m ) .or.( wntuf .and. ldu<n ) ) then
              info = -12
           else if ( ldv<1 .or. ( rsvec .and. ldv<n ) .or.( conda .and. ldv<n ) ) then
              info = -14
           else if ( liwork < iminwrk .and. .not. lquery ) then
              info = -17
           end if
           if ( info == 0 ) then
           ! compute workspace
              ! Compute The Minimal And The Optimal Workspace Lengths
              ! [[the expressions for computing the minimal and the optimal
              ! values of lcwork are written with a lot of redundancy and
              ! can be simplified. however, this detailed form is easier for
              ! maintenance and modifications of the code.]]
              ! Minimal Workspace Length For Stdlib_Cgeqp3 Of An M X N Matrix
              lwqp3 = n+1
              ! Minimal Workspace Length For Stdlib_Cunmqr To Build Left Singular Vectors
              if ( wntus .or. wntur ) then
                  lwunq  = max( n  , 1 )
              else if ( wntua ) then
                  lwunq = max( m , 1 )
              end if
              ! Minimal Workspace Length For Stdlib_Cpocon Of An N X N Matrix
              lwcon = 2 * n
              ! Stdlib_Cgesvd Of An N X N Matrix
              lwsvd = max( 3 * n, 1 )
              if ( lquery ) then
                  call stdlib_cgeqp3( m, n, a, lda, iwork, cdummy, cdummy, -1,rdummy, ierr )
                            
                  lwrk_cgeqp3 = int( cdummy(1),KIND=ilp)
                  if ( wntus .or. wntur ) then
                      call stdlib_cunmqr( 'L', 'N', m, n, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_cunmqr = int( cdummy(1),KIND=ilp)
                  else if ( wntua ) then
                      call stdlib_cunmqr( 'L', 'N', m, m, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_cunmqr = int( cdummy(1),KIND=ilp)
                  else
                      lwrk_cunmqr = 0
                  end if
              end if
              minwrk = 2
              optwrk = 2
              if ( .not. (lsvec .or. rsvec )) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If
                  ! only the singular values are requested
                  if ( conda ) then
                     minwrk = max( n+lwqp3, lwcon, lwsvd )
                  else
                     minwrk = max( n+lwqp3, lwsvd )
                  end if
                  if ( lquery ) then
                      call stdlib_cgesvd( 'N', 'N', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                rdummy, ierr )
                      lwrk_cgesvd = int( cdummy(1),KIND=ilp)
                      if ( conda ) then
                         optwrk = max( n+lwrk_cgeqp3, n+lwcon, lwrk_cgesvd )
                      else
                         optwrk = max( n+lwrk_cgeqp3, lwrk_cgesvd )
                      end if
                  end if
              else if ( lsvec .and. (.not.rsvec) ) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! singular values and the left singular vectors are requested
                  if ( conda ) then
                      minwrk = n + max( lwqp3, lwcon, lwsvd, lwunq )
                  else
                      minwrk = n + max( lwqp3, lwsvd, lwunq )
                  end if
                  if ( lquery ) then
                     if ( rtrans ) then
                        call stdlib_cgesvd( 'N', 'O', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                  rdummy, ierr )
                     else
                        call stdlib_cgesvd( 'O', 'N', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                  rdummy, ierr )
                     end if
                     lwrk_cgesvd = int( cdummy(1),KIND=ilp)
                     if ( conda ) then
                         optwrk = n + max( lwrk_cgeqp3, lwcon, lwrk_cgesvd,lwrk_cunmqr )
                     else
                         optwrk = n + max( lwrk_cgeqp3, lwrk_cgesvd,lwrk_cunmqr )
                     end if
                  end if
              else if ( rsvec .and. (.not.lsvec) ) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! singular values and the right singular vectors are requested
                  if ( conda ) then
                      minwrk = n + max( lwqp3, lwcon, lwsvd )
                  else
                      minwrk = n + max( lwqp3, lwsvd )
                  end if
                  if ( lquery ) then
                      if ( rtrans ) then
                          call stdlib_cgesvd( 'O', 'N', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -&
                                    1, rdummy, ierr )
                      else
                          call stdlib_cgesvd( 'N', 'O', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -&
                                    1, rdummy, ierr )
                      end if
                      lwrk_cgesvd = int( cdummy(1),KIND=ilp)
                      if ( conda ) then
                          optwrk = n + max( lwrk_cgeqp3, lwcon, lwrk_cgesvd )
                      else
                          optwrk = n + max( lwrk_cgeqp3, lwrk_cgesvd )
                      end if
                  end if
              else
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! full svd is requested
                  if ( rtrans ) then
                      minwrk = max( lwqp3, lwsvd, lwunq )
                      if ( conda ) minwrk = max( minwrk, lwcon )
                      minwrk = minwrk + n
                      if ( wntva ) then
                         ! .. minimal workspace length for n x n/2 stdlib_cgeqrf
                         lwqrf  = max( n/2, 1 )
                         ! .. minimal workspace length for n/2 x n/2 stdlib_cgesvd
                         lwsvd2 = max( 3 * (n/2), 1 )
                         lwunq2 = max( n, 1 )
                         minwrk2 = max( lwqp3, n/2+lwqrf, n/2+lwsvd2,n/2+lwunq2, lwunq )
                         if ( conda ) minwrk2 = max( minwrk2, lwcon )
                         minwrk2 = n + minwrk2
                         minwrk = max( minwrk, minwrk2 )
                      end if
                  else
                      minwrk = max( lwqp3, lwsvd, lwunq )
                      if ( conda ) minwrk = max( minwrk, lwcon )
                      minwrk = minwrk + n
                      if ( wntva ) then
                         ! .. minimal workspace length for n/2 x n stdlib_cgelqf
                         lwlqf  = max( n/2, 1 )
                         lwsvd2 = max( 3 * (n/2), 1 )
                         lwunlq = max( n , 1 )
                         minwrk2 = max( lwqp3, n/2+lwlqf, n/2+lwsvd2,n/2+lwunlq, lwunq )
                         if ( conda ) minwrk2 = max( minwrk2, lwcon )
                         minwrk2 = n + minwrk2
                         minwrk = max( minwrk, minwrk2 )
                      end if
                  end if
                  if ( lquery ) then
                     if ( rtrans ) then
                        call stdlib_cgesvd( 'O', 'A', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                  rdummy, ierr )
                        lwrk_cgesvd = int( cdummy(1),KIND=ilp)
                        optwrk = max(lwrk_cgeqp3,lwrk_cgesvd,lwrk_cunmqr)
                        if ( conda ) optwrk = max( optwrk, lwcon )
                        optwrk = n + optwrk
                        if ( wntva ) then
                            call stdlib_cgeqrf(n,n/2,u,ldu,cdummy,cdummy,-1,ierr)
                            lwrk_cgeqrf = int( cdummy(1),KIND=ilp)
                            call stdlib_cgesvd( 'S', 'O', n/2,n/2, v,ldv, s, u,ldu,v, ldv, cdummy,&
                                       -1, rdummy, ierr )
                            lwrk_cgesvd2 = int( cdummy(1),KIND=ilp)
                            call stdlib_cunmqr( 'R', 'C', n, n, n/2, u, ldu, cdummy,v, ldv, &
                                      cdummy, -1, ierr )
                            lwrk_cunmqr2 = int( cdummy(1),KIND=ilp)
                            optwrk2 = max( lwrk_cgeqp3, n/2+lwrk_cgeqrf,n/2+lwrk_cgesvd2, n/2+&
                                      lwrk_cunmqr2 )
                            if ( conda ) optwrk2 = max( optwrk2, lwcon )
                            optwrk2 = n + optwrk2
                            optwrk = max( optwrk, optwrk2 )
                        end if
                     else
                        call stdlib_cgesvd( 'S', 'O', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                  rdummy, ierr )
                        lwrk_cgesvd = int( cdummy(1),KIND=ilp)
                        optwrk = max(lwrk_cgeqp3,lwrk_cgesvd,lwrk_cunmqr)
                        if ( conda ) optwrk = max( optwrk, lwcon )
                        optwrk = n + optwrk
                        if ( wntva ) then
                           call stdlib_cgelqf(n/2,n,u,ldu,cdummy,cdummy,-1,ierr)
                           lwrk_cgelqf = int( cdummy(1),KIND=ilp)
                           call stdlib_cgesvd( 'S','O', n/2,n/2, v, ldv, s, u, ldu,v, ldv, cdummy,&
                                      -1, rdummy, ierr )
                           lwrk_cgesvd2 = int( cdummy(1),KIND=ilp)
                           call stdlib_cunmlq( 'R', 'N', n, n, n/2, u, ldu, cdummy,v, ldv, cdummy,&
                                     -1,ierr )
                           lwrk_cunmlq = int( cdummy(1),KIND=ilp)
                           optwrk2 = max( lwrk_cgeqp3, n/2+lwrk_cgelqf,n/2+lwrk_cgesvd2, n/2+&
                                     lwrk_cunmlq )
                            if ( conda ) optwrk2 = max( optwrk2, lwcon )
                            optwrk2 = n + optwrk2
                            optwrk = max( optwrk, optwrk2 )
                        end if
                     end if
                  end if
              end if
              minwrk = max( 2, minwrk )
              optwrk = max( 2, optwrk )
              if ( lcwork < minwrk .and. (.not.lquery) ) info = -19
           end if
           if (info == 0 .and. lrwork < rminwrk .and. .not. lquery) then
              info = -21
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGESVDQ', -info )
              return
           else if ( lquery ) then
           ! return optimal workspace
               iwork(1) = iminwrk
               cwork(1) = optwrk
               cwork(2) = minwrk
               rwork(1) = rminwrk
               return
           end if
           ! quick return if the matrix is void.
           if( ( m==0 ) .or. ( n==0 ) ) then
           ! All Output Is Void
              return
           end if
           big = stdlib_slamch('O')
           ascaled = .false.
           if ( rowprm ) then
                 ! Reordering The Rows In Decreasing Sequence In The
                 ! ell-infinity norm - this enhances numerical robustness in
                 ! the case of differently scaled rows.
                 do p = 1, m
                     ! rwork(p) = abs( a(p,stdlib_icamax(n,a(p,1),lda)) )
                     ! [[stdlib_clange will return nan if an entry of the p-th row is nan]]
                     rwork(p) = stdlib_clange( 'M', 1, n, a(p,1), lda, rdummy )
                     ! .. check for nan's and inf's
                     if ( ( rwork(p) /= rwork(p) ) .or.( (rwork(p)*zero) /= zero ) ) then
                         info = - 8
                         call stdlib_xerbla( 'CGESVDQ', -info )
                         return
                     end if
                 end do
                 do p = 1, m - 1
                 q = stdlib_isamax( m-p+1, rwork(p), 1 ) + p - 1
                 iwork(n+p) = q
                 if ( p /= q ) then
                    rtmp     = rwork(p)
                    rwork(p) = rwork(q)
                    rwork(q) = rtmp
                 end if
                 end do
                 if ( rwork(1) == zero ) then
                    ! quick return: a is the m x n zero matrix.
                    numrank = 0
                    call stdlib_slaset( 'G', n, 1, zero, zero, s, n )
                    if ( wntus ) call stdlib_claset('G', m, n, czero, cone, u, ldu)
                    if ( wntua ) call stdlib_claset('G', m, m, czero, cone, u, ldu)
                    if ( wntva ) call stdlib_claset('G', n, n, czero, cone, v, ldv)
                    if ( wntuf ) then
                        call stdlib_claset( 'G', n, 1, czero, czero, cwork, n )
                        call stdlib_claset( 'G', m, n, czero, cone, u, ldu )
                    end if
                    do p = 1, n
                        iwork(p) = p
                    end do
                    if ( rowprm ) then
                        do p = n + 1, n + m - 1
                            iwork(p) = p - n
                        end do
                    end if
                    if ( conda ) rwork(1) = -1
                    rwork(2) = -1
                    return
                 end if
                 if ( rwork(1) > big / sqrt(real(m,KIND=sp)) ) then
                     ! .. to prevent overflow in the qr factorization, scale the
                     ! matrix by 1/sqrt(m) if too large entry detected
                     call stdlib_clascl('G',0,0,sqrt(real(m,KIND=sp)),one, m,n, a,lda, ierr)
                               
                     ascaled = .true.
                 end if
                 call stdlib_claswp( n, a, lda, 1, m-1, iwork(n+1), 1 )
           end if
          ! .. at this stage, preemptive scaling is done only to avoid column
          ! norms overflows during the qr factorization. the svd procedure should
          ! have its own scaling to save the singular values from overflows and
          ! underflows. that depends on the svd procedure.
           if ( .not.rowprm ) then
               rtmp = stdlib_clange( 'M', m, n, a, lda, rwork )
               if ( ( rtmp /= rtmp ) .or.( (rtmp*zero) /= zero ) ) then
                    info = - 8
                    call stdlib_xerbla( 'CGESVDQ', -info )
                    return
               end if
               if ( rtmp > big / sqrt(real(m,KIND=sp)) ) then
                   ! .. to prevent overflow in the qr factorization, scale the
                   ! matrix by 1/sqrt(m) if too large entry detected
                   call stdlib_clascl('G',0,0, sqrt(real(m,KIND=sp)),one, m,n, a,lda, ierr)
                             
                   ascaled = .true.
               end if
           end if
           ! Qr Factorization With Column Pivoting
           ! a * p = q * [ r ]
                       ! [ 0 ]
           do p = 1, n
              ! All Columns Are Free Columns
              iwork(p) = 0
           end do
           call stdlib_cgeqp3( m, n, a, lda, iwork, cwork, cwork(n+1), lcwork-n,rwork, ierr )
                     
          ! if the user requested accuracy level allows truncation in the
          ! computed upper triangular factor, the matrix r is examined and,
          ! if possible, replaced with its leading upper trapezoidal part.
           epsln = stdlib_slamch('E')
           sfmin = stdlib_slamch('S')
           ! small = sfmin / epsln
           nr = n
           if ( accla ) then
              ! standard absolute error bound suffices. all sigma_i with
              ! sigma_i < n*eps*||a||_f are flushed to zero. this is an
              ! aggressive enforcement of lower numerical rank by introducing a
              ! backward error of the order of n*eps*||a||_f.
              nr = 1
              rtmp = sqrt(real(n,KIND=sp))*epsln
              do p = 2, n
                 if ( abs(a(p,p)) < (rtmp*abs(a(1,1))) ) go to 3002
                    nr = nr + 1
              end do
              3002 continue
           elseif ( acclm ) then
              ! .. similarly as above, only slightly more gentle (less aggressive).
              ! sudden drop on the diagonal of r is used as the criterion for being
              ! close-to-rank-deficient. the threshold is set to epsln=stdlib_slamch('e').
              ! [[this can be made more flexible by replacing this hard-coded value
              ! with a user specified threshold.]] also, the values that underflow
              ! will be truncated.
              nr = 1
              do p = 2, n
                 if ( ( abs(a(p,p)) < (epsln*abs(a(p-1,p-1))) ) .or.( abs(a(p,p)) < sfmin ) ) go &
                           to 3402
                 nr = nr + 1
              end do
              3402 continue
           else
              ! Rrqr Not Authorized To Determine Numerical Rank Except In The
              ! obvious case of zero pivots.
              ! .. inspect r for exact zeros on the diagonal;
              ! r(i,i)=0 => r(i:n,i:n)=0.
              nr = 1
              do p = 2, n
                 if ( abs(a(p,p)) == zero ) go to 3502
                 nr = nr + 1
              end do
              3502 continue
              if ( conda ) then
                 ! estimate the scaled condition number of a. use the fact that it is
                 ! the same as the scaled condition number of r.
                    ! V Is Used As Workspace
                    call stdlib_clacpy( 'U', n, n, a, lda, v, ldv )
                    ! only the leading nr x nr submatrix of the triangular factor
                    ! is considered. only if nr=n will this give a reliable error
                    ! bound. however, even for nr < n, this can be used on an
                    ! expert level and obtain useful information in the sense of
                    ! perturbation theory.
                    do p = 1, nr
                       rtmp = stdlib_scnrm2( p, v(1,p), 1 )
                       call stdlib_csscal( p, one/rtmp, v(1,p), 1 )
                    end do
                    if ( .not. ( lsvec .or. rsvec ) ) then
                        call stdlib_cpocon( 'U', nr, v, ldv, one, rtmp,cwork, rwork, ierr )
                                  
                    else
                        call stdlib_cpocon( 'U', nr, v, ldv, one, rtmp,cwork(n+1), rwork, ierr )
                                  
                    end if
                    sconda = one / sqrt(rtmp)
                 ! for nr=n, sconda is an estimate of sqrt(||(r^* * r)^(-1)||_1),
                 ! n^(-1/4) * sconda <= ||r^(-1)||_2 <= n^(1/4) * sconda
                 ! see the reference [1] for more details.
              end if
           endif
           if ( wntur ) then
               n1 = nr
           else if ( wntus .or. wntuf) then
               n1 = n
           else if ( wntua ) then
               n1 = m
           end if
           if ( .not. ( rsvec .or. lsvec ) ) then
      ! .......................................................................
              ! Only The Singular Values Are Requested
      ! .......................................................................
              if ( rtrans ) then
               ! .. compute the singular values of r**h = [a](1:nr,1:n)**h
                 ! .. set the lower triangle of [a] to [a](1:nr,1:n)**h and
                 ! the upper triangle of [a] to zero.
                 do p = 1, min( n, nr )
                    a(p,p) = conjg(a(p,p))
                    do q = p + 1, n
                       a(q,p) = conjg(a(p,q))
                       if ( q <= nr ) a(p,q) = czero
                    end do
                 end do
                 call stdlib_cgesvd( 'N', 'N', n, nr, a, lda, s, u, ldu,v, ldv, cwork, lcwork, &
                           rwork, info )
              else
                 ! .. compute the singular values of r = [a](1:nr,1:n)
                 if ( nr > 1 )call stdlib_claset( 'L', nr-1,nr-1, czero,czero, a(2,1), lda )
                           
                 call stdlib_cgesvd( 'N', 'N', nr, n, a, lda, s, u, ldu,v, ldv, cwork, lcwork, &
                           rwork, info )
              end if
           else if ( lsvec .and. ( .not. rsvec) ) then
      ! .......................................................................
             ! The Singular Values And The Left Singular Vectors Requested
      ! .......................................................................""""""""
              if ( rtrans ) then
                  ! .. apply stdlib_cgesvd to r**h
                  ! .. copy r**h into [u] and overwrite [u] with the right singular
                  ! vectors of r
                 do p = 1, nr
                    do q = p, n
                       u(q,p) = conjg(a(p,q))
                    end do
                 end do
                 if ( nr > 1 )call stdlib_claset( 'U', nr-1,nr-1, czero,czero, u(1,2), ldu )
                           
                 ! .. the left singular vectors not computed, the nr right singular
                 ! vectors overwrite [u](1:nr,1:nr) as conjugate transposed. these
                 ! will be pre-multiplied by q to build the left singular vectors of a.
                    call stdlib_cgesvd( 'N', 'O', n, nr, u, ldu, s, u, ldu,u, ldu, cwork(n+1), &
                              lcwork-n, rwork, info )
                    do p = 1, nr
                        u(p,p) = conjg(u(p,p))
                        do q = p + 1, nr
                           ctmp   = conjg(u(q,p))
                           u(q,p) = conjg(u(p,q))
                           u(p,q) = ctmp
                        end do
                    end do
              else
                  ! Apply Stdlib_Cgesvd To R
                  ! .. copy r into [u] and overwrite [u] with the left singular vectors
                  call stdlib_clacpy( 'U', nr, n, a, lda, u, ldu )
                  if ( nr > 1 )call stdlib_claset( 'L', nr-1, nr-1, czero, czero, u(2,1), ldu )
                            
                  ! .. the right singular vectors not computed, the nr left singular
                  ! vectors overwrite [u](1:nr,1:nr)
                     call stdlib_cgesvd( 'O', 'N', nr, n, u, ldu, s, u, ldu,v, ldv, cwork(n+1), &
                               lcwork-n, rwork, info )
                     ! .. now [u](1:nr,1:nr) contains the nr left singular vectors of
                     ! r. these will be pre-multiplied by q to build the left singular
                     ! vectors of a.
              end if
                 ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
              if ( ( nr < m ) .and. ( .not.wntuf ) ) then
                  call stdlib_claset('A', m-nr, nr, czero, czero, u(nr+1,1), ldu)
                  if ( nr < n1 ) then
                     call stdlib_claset( 'A',nr,n1-nr,czero,czero,u(1,nr+1), ldu )
                     call stdlib_claset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1), ldu )
                  end if
              end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! vectors matrix u.
              if ( .not.wntuf )call stdlib_cunmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, &
                        cwork(n+1), lcwork-n, ierr )
              if ( rowprm .and. .not.wntuf )call stdlib_claswp( n1, u, ldu, 1, m-1, iwork(n+1), -&
                        1 )
           else if ( rsvec .and. ( .not. lsvec ) ) then
      ! .......................................................................
             ! The Singular Values And The Right Singular Vectors Requested
      ! .......................................................................
               if ( rtrans ) then
                  ! .. apply stdlib_cgesvd to r**h
                  ! .. copy r**h into v and overwrite v with the left singular vectors
                 do p = 1, nr
                    do q = p, n
                       v(q,p) = conjg(a(p,q))
                    end do
                 end do
                 if ( nr > 1 )call stdlib_claset( 'U', nr-1,nr-1, czero,czero, v(1,2), ldv )
                           
                 ! .. the left singular vectors of r**h overwrite v, the right singular
                 ! vectors not computed
                 if ( wntvr .or. ( nr == n ) ) then
                    call stdlib_cgesvd( 'O', 'N', n, nr, v, ldv, s, u, ldu,u, ldu, cwork(n+1), &
                              lcwork-n, rwork, info )
                    do p = 1, nr
                        v(p,p) = conjg(v(p,p))
                        do q = p + 1, nr
                           ctmp   = conjg(v(q,p))
                           v(q,p) = conjg(v(p,q))
                           v(p,q) = ctmp
                        end do
                    end do
                    if ( nr < n ) then
                        do p = 1, nr
                           do q = nr + 1, n
                               v(p,q) = conjg(v(q,p))
                           end do
                        end do
                    end if
                    call stdlib_clapmt( .false., nr, n, v, ldv, iwork )
                 else
                     ! .. need all n right singular vectors and nr < n
                     ! [!] this is simple implementation that augments [v](1:n,1:nr)
                     ! by padding a zero block. in the case nr << n, a more efficient
                     ! way is to first use the qr factorization. for more details
                     ! how to implement this, see the " full svd " branch.
                     call stdlib_claset('G', n, n-nr, czero, czero, v(1,nr+1), ldv)
                     call stdlib_cgesvd( 'O', 'N', n, n, v, ldv, s, u, ldu,u, ldu, cwork(n+1), &
                               lcwork-n, rwork, info )
                     do p = 1, n
                        v(p,p) = conjg(v(p,p))
                        do q = p + 1, n
                           ctmp   = conjg(v(q,p))
                           v(q,p) = conjg(v(p,q))
                           v(p,q) = ctmp
                        end do
                     end do
                     call stdlib_clapmt( .false., n, n, v, ldv, iwork )
                 end if
               else
                  ! Aply Stdlib_Cgesvd To R
                  ! Copy R Into V And Overwrite V With The Right Singular Vectors
                  call stdlib_clacpy( 'U', nr, n, a, lda, v, ldv )
                  if ( nr > 1 )call stdlib_claset( 'L', nr-1, nr-1, czero, czero, v(2,1), ldv )
                            
                  ! .. the right singular vectors overwrite v, the nr left singular
                  ! vectors stored in u(1:nr,1:nr)
                  if ( wntvr .or. ( nr == n ) ) then
                     call stdlib_cgesvd( 'N', 'O', nr, n, v, ldv, s, u, ldu,v, ldv, cwork(n+1), &
                               lcwork-n, rwork, info )
                     call stdlib_clapmt( .false., nr, n, v, ldv, iwork )
                     ! .. now [v](1:nr,1:n) contains v(1:n,1:nr)**h
                  else
                     ! .. need all n right singular vectors and nr < n
                     ! [!] this is simple implementation that augments [v](1:nr,1:n)
                     ! by padding a zero block. in the case nr << n, a more efficient
                     ! way is to first use the lq factorization. for more details
                     ! how to implement this, see the " full svd " branch.
                      call stdlib_claset('G', n-nr, n, czero,czero, v(nr+1,1), ldv)
                      call stdlib_cgesvd( 'N', 'O', n, n, v, ldv, s, u, ldu,v, ldv, cwork(n+1), &
                                lcwork-n, rwork, info )
                      call stdlib_clapmt( .false., n, n, v, ldv, iwork )
                  end if
                  ! .. now [v] contains the adjoint of the matrix of the right singular
                  ! vectors of a.
               end if
           else
      ! .......................................................................
             ! Full Svd Requested
      ! .......................................................................
              if ( rtrans ) then
                  ! .. apply stdlib_cgesvd to r**h [[this option is left for r
                 if ( wntvr .or. ( nr == n ) ) then
                  ! .. copy r**h into [v] and overwrite [v] with the left singular
                  ! vectors of r**h
                 do p = 1, nr
                    do q = p, n
                       v(q,p) = conjg(a(p,q))
                    end do
                 end do
                 if ( nr > 1 )call stdlib_claset( 'U', nr-1,nr-1, czero,czero, v(1,2), ldv )
                           
                 ! .. the left singular vectors of r**h overwrite [v], the nr right
                 ! singular vectors of r**h stored in [u](1:nr,1:nr) as conjugate
                 ! transposed
                    call stdlib_cgesvd( 'O', 'A', n, nr, v, ldv, s, v, ldv,u, ldu, cwork(n+1), &
                              lcwork-n, rwork, info )
                    ! Assemble V
                    do p = 1, nr
                       v(p,p) = conjg(v(p,p))
                       do q = p + 1, nr
                          ctmp   = conjg(v(q,p))
                          v(q,p) = conjg(v(p,q))
                          v(p,q) = ctmp
                       end do
                    end do
                    if ( nr < n ) then
                        do p = 1, nr
                           do q = nr+1, n
                              v(p,q) = conjg(v(q,p))
                           end do
                        end do
                    end if
                    call stdlib_clapmt( .false., nr, n, v, ldv, iwork )
                     do p = 1, nr
                        u(p,p) = conjg(u(p,p))
                        do q = p + 1, nr
                           ctmp   = conjg(u(q,p))
                           u(q,p) = conjg(u(p,q))
                           u(p,q) = ctmp
                        end do
                     end do
                     if ( ( nr < m ) .and. .not.(wntuf)) then
                       call stdlib_claset('A', m-nr,nr, czero,czero, u(nr+1,1), ldu)
                       if ( nr < n1 ) then
                          call stdlib_claset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                          call stdlib_claset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1), ldu )
                                    
                       end if
                    end if
                 else
                     ! .. need all n right singular vectors and nr < n
                  ! .. copy r**h into [v] and overwrite [v] with the left singular
                  ! vectors of r**h
                     ! [[the optimal ratio n/nr for using qrf instead of padding
                       ! with zeros. here hard coded to 2; it must be at least
                       ! two due to work space constraints.]]
                     ! optratio = stdlib_ilaenv(6, 'cgesvd', 's' // 'o', nr,n,0,0)
                     ! optratio = max( optratio, 2 )
                     optratio = 2
                     if ( optratio*nr > n ) then
                        do p = 1, nr
                           do q = p, n
                              v(q,p) = conjg(a(p,q))
                           end do
                        end do
                        if ( nr > 1 )call stdlib_claset('U',nr-1,nr-1, czero,czero, v(1,2),ldv)
                                  
                        call stdlib_claset('A',n,n-nr,czero,czero,v(1,nr+1),ldv)
                        call stdlib_cgesvd( 'O', 'A', n, n, v, ldv, s, v, ldv,u, ldu, cwork(n+1), &
                                  lcwork-n, rwork, info )
                        do p = 1, n
                           v(p,p) = conjg(v(p,p))
                           do q = p + 1, n
                              ctmp   = conjg(v(q,p))
                              v(q,p) = conjg(v(p,q))
                              v(p,q) = ctmp
                           end do
                        end do
                        call stdlib_clapmt( .false., n, n, v, ldv, iwork )
                    ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x n1), i.e. (m x n) or (m x m).
                        do p = 1, n
                           u(p,p) = conjg(u(p,p))
                           do q = p + 1, n
                              ctmp   = conjg(u(q,p))
                              u(q,p) = conjg(u(p,q))
                              u(p,q) = ctmp
                           end do
                        end do
                        if ( ( n < m ) .and. .not.(wntuf)) then
                           call stdlib_claset('A',m-n,n,czero,czero,u(n+1,1),ldu)
                           if ( n < n1 ) then
                             call stdlib_claset('A',n,n1-n,czero,czero,u(1,n+1),ldu)
                             call stdlib_claset('A',m-n,n1-n,czero,cone,u(n+1,n+1), ldu )
                           end if
                        end if
                     else
                        ! .. copy r**h into [u] and overwrite [u] with the right
                        ! singular vectors of r
                        do p = 1, nr
                           do q = p, n
                              u(q,nr+p) = conjg(a(p,q))
                           end do
                        end do
                        if ( nr > 1 )call stdlib_claset('U',nr-1,nr-1,czero,czero,u(1,nr+2),ldu)
                                  
                        call stdlib_cgeqrf( n, nr, u(1,nr+1), ldu, cwork(n+1),cwork(n+nr+1), &
                                  lcwork-n-nr, ierr )
                        do p = 1, nr
                            do q = 1, n
                                v(q,p) = conjg(u(p,nr+q))
                            end do
                        end do
                       if (nr>1) call stdlib_claset('U',nr-1,nr-1,czero,czero,v(1,2),ldv)
                       call stdlib_cgesvd( 'S', 'O', nr, nr, v, ldv, s, u, ldu,v,ldv, cwork(n+nr+&
                                 1),lcwork-n-nr,rwork, info )
                       call stdlib_claset('A',n-nr,nr,czero,czero,v(nr+1,1),ldv)
                       call stdlib_claset('A',nr,n-nr,czero,czero,v(1,nr+1),ldv)
                       call stdlib_claset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                       call stdlib_cunmqr('R','C', n, n, nr, u(1,nr+1), ldu,cwork(n+1),v,ldv,&
                                 cwork(n+nr+1),lcwork-n-nr,ierr)
                       call stdlib_clapmt( .false., n, n, v, ldv, iwork )
                       ! Assemble The Left Singular Vector Matrix U Of Dimensions
                       ! (m x nr) or (m x n) or (m x m).
                       if ( ( nr < m ) .and. .not.(wntuf)) then
                          call stdlib_claset('A',m-nr,nr,czero,czero,u(nr+1,1),ldu)
                          if ( nr < n1 ) then
                          call stdlib_claset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                          call stdlib_claset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1),ldu)
                          end if
                       end if
                     end if
                 end if
              else
                  ! .. apply stdlib_cgesvd to r [[this is the recommended option]]
                  if ( wntvr .or. ( nr == n ) ) then
                      ! .. copy r into [v] and overwrite v with the right singular vectors
                      call stdlib_clacpy( 'U', nr, n, a, lda, v, ldv )
                     if ( nr > 1 )call stdlib_claset( 'L', nr-1,nr-1, czero,czero, v(2,1), ldv )
                               
                     ! .. the right singular vectors of r overwrite [v], the nr left
                     ! singular vectors of r stored in [u](1:nr,1:nr)
                     call stdlib_cgesvd( 'S', 'O', nr, n, v, ldv, s, u, ldu,v, ldv, cwork(n+1), &
                               lcwork-n, rwork, info )
                     call stdlib_clapmt( .false., nr, n, v, ldv, iwork )
                     ! .. now [v](1:nr,1:n) contains v(1:n,1:nr)**h
                     ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
                    if ( ( nr < m ) .and. .not.(wntuf)) then
                       call stdlib_claset('A', m-nr,nr, czero,czero, u(nr+1,1), ldu)
                       if ( nr < n1 ) then
                          call stdlib_claset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                          call stdlib_claset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1), ldu )
                                    
                       end if
                    end if
                  else
                    ! .. need all n right singular vectors and nr < n
                    ! The Requested Number Of The Left Singular Vectors
                     ! is then n1 (n or m)
                     ! [[the optimal ratio n/nr for using lq instead of padding
                       ! with zeros. here hard coded to 2; it must be at least
                       ! two due to work space constraints.]]
                     ! optratio = stdlib_ilaenv(6, 'cgesvd', 's' // 'o', nr,n,0,0)
                     ! optratio = max( optratio, 2 )
                    optratio = 2
                    if ( optratio * nr > n ) then
                       call stdlib_clacpy( 'U', nr, n, a, lda, v, ldv )
                       if ( nr > 1 )call stdlib_claset('L', nr-1,nr-1, czero,czero, v(2,1),ldv)
                                 
                    ! .. the right singular vectors of r overwrite [v], the nr left
                       ! singular vectors of r stored in [u](1:nr,1:nr)
                       call stdlib_claset('A', n-nr,n, czero,czero, v(nr+1,1),ldv)
                       call stdlib_cgesvd( 'S', 'O', n, n, v, ldv, s, u, ldu,v, ldv, cwork(n+1), &
                                 lcwork-n, rwork, info )
                       call stdlib_clapmt( .false., n, n, v, ldv, iwork )
                       ! .. now [v] contains the adjoint of the matrix of the right
                       ! singular vectors of a. the leading n left singular vectors
                       ! are in [u](1:n,1:n)
                       ! Assemble The Left Singular Vector Matrix U Of Dimensions
                       ! (m x n1), i.e. (m x n) or (m x m).
                       if ( ( n < m ) .and. .not.(wntuf)) then
                           call stdlib_claset('A',m-n,n,czero,czero,u(n+1,1),ldu)
                           if ( n < n1 ) then
                             call stdlib_claset('A',n,n1-n,czero,czero,u(1,n+1),ldu)
                             call stdlib_claset( 'A',m-n,n1-n,czero,cone,u(n+1,n+1), ldu )
                           end if
                       end if
                    else
                       call stdlib_clacpy( 'U', nr, n, a, lda, u(nr+1,1), ldu )
                       if ( nr > 1 )call stdlib_claset('L',nr-1,nr-1,czero,czero,u(nr+2,1),ldu)
                                 
                       call stdlib_cgelqf( nr, n, u(nr+1,1), ldu, cwork(n+1),cwork(n+nr+1), &
                                 lcwork-n-nr, ierr )
                       call stdlib_clacpy('L',nr,nr,u(nr+1,1),ldu,v,ldv)
                       if ( nr > 1 )call stdlib_claset('U',nr-1,nr-1,czero,czero,v(1,2),ldv)
                                 
                       call stdlib_cgesvd( 'S', 'O', nr, nr, v, ldv, s, u, ldu,v, ldv, cwork(n+nr+&
                                 1), lcwork-n-nr, rwork, info )
                       call stdlib_claset('A',n-nr,nr,czero,czero,v(nr+1,1),ldv)
                       call stdlib_claset('A',nr,n-nr,czero,czero,v(1,nr+1),ldv)
                       call stdlib_claset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                       call stdlib_cunmlq('R','N',n,n,nr,u(nr+1,1),ldu,cwork(n+1),v, ldv, cwork(n+&
                                 nr+1),lcwork-n-nr,ierr)
                       call stdlib_clapmt( .false., n, n, v, ldv, iwork )
                     ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
                       if ( ( nr < m ) .and. .not.(wntuf)) then
                          call stdlib_claset('A',m-nr,nr,czero,czero,u(nr+1,1),ldu)
                          if ( nr < n1 ) then
                          call stdlib_claset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                          call stdlib_claset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1), ldu )
                                    
                          end if
                       end if
                    end if
                  end if
              ! .. end of the "r**h or r" branch
              end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! vectors matrix u.
              if ( .not. wntuf )call stdlib_cunmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, &
                        cwork(n+1), lcwork-n, ierr )
              if ( rowprm .and. .not.wntuf )call stdlib_claswp( n1, u, ldu, 1, m-1, iwork(n+1), -&
                        1 )
           ! ... end of the "full svd" branch
           end if
           ! check whether some singular values are returned as zeros, e.g.
           ! due to underflow, and update the numerical rank.
           p = nr
           do q = p, 1, -1
               if ( s(q) > zero ) go to 4002
               nr = nr - 1
           end do
           4002 continue
           ! .. if numerical rank deficiency is detected, the truncated
           ! singular values are set to zero.
           if ( nr < n ) call stdlib_slaset( 'G', n-nr,1, zero,zero, s(nr+1), n )
           ! .. undo scaling; this may cause overflow in the largest singular
           ! values.
           if ( ascaled )call stdlib_slascl( 'G',0,0, one,sqrt(real(m,KIND=sp)), nr,1, s, n, ierr &
                     )
           if ( conda ) rwork(1) = sconda
           rwork(2) = p - nr
           ! .. p-nr is the number of singular values that are computed as
           ! exact zeros in stdlib_cgesvd() applied to the (possibly truncated)
           ! full row rank triangular (trapezoidal) factor of a.
           numrank = nr
           return
     end subroutine stdlib_cgesvdq

     module subroutine stdlib_zgesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
      numrank, iwork, liwork,cwork, lcwork, rwork, lrwork, info )
     !! ZCGESVDQ computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N unitary matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
               
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: joba, jobp, jobr, jobu, jobv
           integer(ilp), intent(in) :: m, n, lda, ldu, ldv, liwork, lrwork
           integer(ilp), intent(out) :: numrank, info
           integer(ilp), intent(inout) :: lcwork
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: u(ldu,*), v(ldv,*), cwork(*)
           real(dp), intent(out) :: s(*), rwork(*)
           integer(ilp), intent(out) :: iwork(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           integer(ilp) :: ierr, nr, n1, optratio, p, q
           integer(ilp) :: lwcon, lwqp3, lwrk_zgelqf, lwrk_zgesvd, lwrk_zgesvd2, lwrk_zgeqp3, &
           lwrk_zgeqrf, lwrk_zunmlq, lwrk_zunmqr, lwrk_zunmqr2, lwlqf, lwqrf, lwsvd, lwsvd2, &
                     lwunq, lwunq2, lwunlq, minwrk, minwrk2, optwrk, optwrk2, iminwrk, rminwrk
           logical(lk) :: accla, acclm, acclh, ascaled, conda, dntwu, dntwv, lquery, lsvc0, lsvec,&
                      rowprm, rsvec, rtrans, wntua, wntuf, wntur, wntus, wntva, wntvr
           real(dp) :: big, epsln, rtmp, sconda, sfmin
           complex(dp) :: ctmp
           ! Local Arrays
           complex(dp) :: cdummy(1)
           real(dp) :: rdummy(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           wntus  = stdlib_lsame( jobu, 'S' ) .or. stdlib_lsame( jobu, 'U' )
           wntur  = stdlib_lsame( jobu, 'R' )
           wntua  = stdlib_lsame( jobu, 'A' )
           wntuf  = stdlib_lsame( jobu, 'F' )
           lsvc0  = wntus .or. wntur .or. wntua
           lsvec  = lsvc0 .or. wntuf
           dntwu  = stdlib_lsame( jobu, 'N' )
           wntvr  = stdlib_lsame( jobv, 'R' )
           wntva  = stdlib_lsame( jobv, 'A' ) .or. stdlib_lsame( jobv, 'V' )
           rsvec  = wntvr .or. wntva
           dntwv  = stdlib_lsame( jobv, 'N' )
           accla  = stdlib_lsame( joba, 'A' )
           acclm  = stdlib_lsame( joba, 'M' )
           conda  = stdlib_lsame( joba, 'E' )
           acclh  = stdlib_lsame( joba, 'H' ) .or. conda
           rowprm = stdlib_lsame( jobp, 'P' )
           rtrans = stdlib_lsame( jobr, 'T' )
           if ( rowprm ) then
              iminwrk = max( 1, n + m - 1 )
              rminwrk = max( 2, m, 5*n )
           else
              iminwrk = max( 1, n )
              rminwrk = max( 2, 5*n )
           end if
           lquery = (liwork == -1 .or. lcwork == -1 .or. lrwork == -1)
           info  = 0
           if ( .not. ( accla .or. acclm .or. acclh ) ) then
              info = -1
           else if ( .not.( rowprm .or. stdlib_lsame( jobp, 'N' ) ) ) then
               info = -2
           else if ( .not.( rtrans .or. stdlib_lsame( jobr, 'N' ) ) ) then
               info = -3
           else if ( .not.( lsvec .or. dntwu ) ) then
              info = -4
           else if ( wntur .and. wntva ) then
              info = -5
           else if ( .not.( rsvec .or. dntwv )) then
              info = -5
           else if ( m<0 ) then
              info = -6
           else if ( ( n<0 ) .or. ( n>m ) ) then
              info = -7
           else if ( lda<max( 1, m ) ) then
              info = -9
           else if ( ldu<1 .or. ( lsvc0 .and. ldu<m ) .or.( wntuf .and. ldu<n ) ) then
              info = -12
           else if ( ldv<1 .or. ( rsvec .and. ldv<n ) .or.( conda .and. ldv<n ) ) then
              info = -14
           else if ( liwork < iminwrk .and. .not. lquery ) then
              info = -17
           end if
           if ( info == 0 ) then
              ! Compute The Minimal And The Optimal Workspace Lengths
              ! [[the expressions for computing the minimal and the optimal
              ! values of lcwork are written with a lot of redundancy and
              ! can be simplified. however, this detailed form is easier for
              ! maintenance and modifications of the code.]]
              ! Minimal Workspace Length For Stdlib_Zgeqp3 Of An M X N Matrix
              lwqp3 = n+1
              ! Minimal Workspace Length For Stdlib_Zunmqr To Build Left Singular Vectors
              if ( wntus .or. wntur ) then
                  lwunq  = max( n  , 1 )
              else if ( wntua ) then
                  lwunq = max( m , 1 )
              end if
              ! Minimal Workspace Length For Stdlib_Zpocon Of An N X N Matrix
              lwcon = 2 * n
              ! Stdlib_Zgesvd Of An N X N Matrix
              lwsvd = max( 3 * n, 1 )
              if ( lquery ) then
                  call stdlib_zgeqp3( m, n, a, lda, iwork, cdummy, cdummy, -1,rdummy, ierr )
                            
                  lwrk_zgeqp3 = int( cdummy(1),KIND=ilp)
                  if ( wntus .or. wntur ) then
                      call stdlib_zunmqr( 'L', 'N', m, n, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_zunmqr = int( cdummy(1),KIND=ilp)
                  else if ( wntua ) then
                      call stdlib_zunmqr( 'L', 'N', m, m, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_zunmqr = int( cdummy(1),KIND=ilp)
                  else
                      lwrk_zunmqr = 0
                  end if
              end if
              minwrk = 2
              optwrk = 2
              if ( .not. (lsvec .or. rsvec ) ) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If
                  ! only the singular values are requested
                  if ( conda ) then
                     minwrk = max( n+lwqp3, lwcon, lwsvd )
                  else
                     minwrk = max( n+lwqp3, lwsvd )
                  end if
                  if ( lquery ) then
                      call stdlib_zgesvd( 'N', 'N', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                rdummy, ierr )
                      lwrk_zgesvd = int( cdummy(1),KIND=ilp)
                      if ( conda ) then
                         optwrk = max( n+lwrk_zgeqp3, n+lwcon, lwrk_zgesvd )
                      else
                         optwrk = max( n+lwrk_zgeqp3, lwrk_zgesvd )
                      end if
                  end if
              else if ( lsvec .and. (.not.rsvec) ) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! singular values and the left singular vectors are requested
                  if ( conda ) then
                      minwrk = n + max( lwqp3, lwcon, lwsvd, lwunq )
                  else
                      minwrk = n + max( lwqp3, lwsvd, lwunq )
                  end if
                  if ( lquery ) then
                     if ( rtrans ) then
                        call stdlib_zgesvd( 'N', 'O', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                  rdummy, ierr )
                     else
                        call stdlib_zgesvd( 'O', 'N', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                  rdummy, ierr )
                     end if
                     lwrk_zgesvd = int( cdummy(1),KIND=ilp)
                     if ( conda ) then
                         optwrk = n + max( lwrk_zgeqp3, lwcon, lwrk_zgesvd,lwrk_zunmqr )
                     else
                         optwrk = n + max( lwrk_zgeqp3, lwrk_zgesvd,lwrk_zunmqr )
                     end if
                  end if
              else if ( rsvec .and. (.not.lsvec) ) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! singular values and the right singular vectors are requested
                  if ( conda ) then
                      minwrk = n + max( lwqp3, lwcon, lwsvd )
                  else
                      minwrk = n + max( lwqp3, lwsvd )
                  end if
                  if ( lquery ) then
                      if ( rtrans ) then
                          call stdlib_zgesvd( 'O', 'N', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -&
                                    1, rdummy, ierr )
                      else
                          call stdlib_zgesvd( 'N', 'O', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -&
                                    1, rdummy, ierr )
                      end if
                      lwrk_zgesvd = int( cdummy(1),KIND=ilp)
                      if ( conda ) then
                          optwrk = n + max( lwrk_zgeqp3, lwcon, lwrk_zgesvd )
                      else
                          optwrk = n + max( lwrk_zgeqp3, lwrk_zgesvd )
                      end if
                  end if
              else
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! full svd is requested
                  if ( rtrans ) then
                      minwrk = max( lwqp3, lwsvd, lwunq )
                      if ( conda ) minwrk = max( minwrk, lwcon )
                      minwrk = minwrk + n
                      if ( wntva ) then
                         ! .. minimal workspace length for n x n/2 stdlib_zgeqrf
                         lwqrf  = max( n/2, 1 )
                         ! .. minimal workspace length for n/2 x n/2 stdlib_zgesvd
                         lwsvd2 = max( 3 * (n/2), 1 )
                         lwunq2 = max( n, 1 )
                         minwrk2 = max( lwqp3, n/2+lwqrf, n/2+lwsvd2,n/2+lwunq2, lwunq )
                         if ( conda ) minwrk2 = max( minwrk2, lwcon )
                         minwrk2 = n + minwrk2
                         minwrk = max( minwrk, minwrk2 )
                      end if
                  else
                      minwrk = max( lwqp3, lwsvd, lwunq )
                      if ( conda ) minwrk = max( minwrk, lwcon )
                      minwrk = minwrk + n
                      if ( wntva ) then
                         ! .. minimal workspace length for n/2 x n stdlib_zgelqf
                         lwlqf  = max( n/2, 1 )
                         lwsvd2 = max( 3 * (n/2), 1 )
                         lwunlq = max( n , 1 )
                         minwrk2 = max( lwqp3, n/2+lwlqf, n/2+lwsvd2,n/2+lwunlq, lwunq )
                         if ( conda ) minwrk2 = max( minwrk2, lwcon )
                         minwrk2 = n + minwrk2
                         minwrk = max( minwrk, minwrk2 )
                      end if
                  end if
                  if ( lquery ) then
                     if ( rtrans ) then
                        call stdlib_zgesvd( 'O', 'A', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                  rdummy, ierr )
                        lwrk_zgesvd = int( cdummy(1),KIND=ilp)
                        optwrk = max(lwrk_zgeqp3,lwrk_zgesvd,lwrk_zunmqr)
                        if ( conda ) optwrk = max( optwrk, lwcon )
                        optwrk = n + optwrk
                        if ( wntva ) then
                            call stdlib_zgeqrf(n,n/2,u,ldu,cdummy,cdummy,-1,ierr)
                            lwrk_zgeqrf = int( cdummy(1),KIND=ilp)
                            call stdlib_zgesvd( 'S', 'O', n/2,n/2, v,ldv, s, u,ldu,v, ldv, cdummy,&
                                       -1, rdummy, ierr )
                            lwrk_zgesvd2 = int( cdummy(1),KIND=ilp)
                            call stdlib_zunmqr( 'R', 'C', n, n, n/2, u, ldu, cdummy,v, ldv, &
                                      cdummy, -1, ierr )
                            lwrk_zunmqr2 = int( cdummy(1),KIND=ilp)
                            optwrk2 = max( lwrk_zgeqp3, n/2+lwrk_zgeqrf,n/2+lwrk_zgesvd2, n/2+&
                                      lwrk_zunmqr2 )
                            if ( conda ) optwrk2 = max( optwrk2, lwcon )
                            optwrk2 = n + optwrk2
                            optwrk = max( optwrk, optwrk2 )
                        end if
                     else
                        call stdlib_zgesvd( 'S', 'O', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                  rdummy, ierr )
                        lwrk_zgesvd = int( cdummy(1),KIND=ilp)
                        optwrk = max(lwrk_zgeqp3,lwrk_zgesvd,lwrk_zunmqr)
                        if ( conda ) optwrk = max( optwrk, lwcon )
                        optwrk = n + optwrk
                        if ( wntva ) then
                           call stdlib_zgelqf(n/2,n,u,ldu,cdummy,cdummy,-1,ierr)
                           lwrk_zgelqf = int( cdummy(1),KIND=ilp)
                           call stdlib_zgesvd( 'S','O', n/2,n/2, v, ldv, s, u, ldu,v, ldv, cdummy,&
                                      -1, rdummy, ierr )
                           lwrk_zgesvd2 = int( cdummy(1),KIND=ilp)
                           call stdlib_zunmlq( 'R', 'N', n, n, n/2, u, ldu, cdummy,v, ldv, cdummy,&
                                     -1,ierr )
                           lwrk_zunmlq = int( cdummy(1),KIND=ilp)
                           optwrk2 = max( lwrk_zgeqp3, n/2+lwrk_zgelqf,n/2+lwrk_zgesvd2, n/2+&
                                     lwrk_zunmlq )
                            if ( conda ) optwrk2 = max( optwrk2, lwcon )
                            optwrk2 = n + optwrk2
                            optwrk = max( optwrk, optwrk2 )
                        end if
                     end if
                  end if
              end if
              minwrk = max( 2, minwrk )
              optwrk = max( 2, optwrk )
              if ( lcwork < minwrk .and. (.not.lquery) ) info = -19
           end if
           if (info == 0 .and. lrwork < rminwrk .and. .not. lquery) then
              info = -21
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGESVDQ', -info )
              return
           else if ( lquery ) then
           ! return optimal workspace
               iwork(1) = iminwrk
               cwork(1) = optwrk
               cwork(2) = minwrk
               rwork(1) = rminwrk
               return
           end if
           ! quick return if the matrix is void.
           if( ( m==0 ) .or. ( n==0 ) ) then
           ! All Output Is Void
              return
           end if
           big = stdlib_dlamch('O')
           ascaled = .false.
           if ( rowprm ) then
                 ! Reordering The Rows In Decreasing Sequence In The
                 ! ell-infinity norm - this enhances numerical robustness in
                 ! the case of differently scaled rows.
                 do p = 1, m
                     ! rwork(p) = abs( a(p,stdlib_izamax(n,a(p,1),lda)) )
                     ! [[stdlib_zlange will return nan if an entry of the p-th row is nan]]
                     rwork(p) = stdlib_zlange( 'M', 1, n, a(p,1), lda, rdummy )
                     ! .. check for nan's and inf's
                     if ( ( rwork(p) /= rwork(p) ) .or.( (rwork(p)*zero) /= zero ) ) then
                         info = -8
                         call stdlib_xerbla( 'ZGESVDQ', -info )
                         return
                     end if
                 end do
                 do p = 1, m - 1
                 q = stdlib_idamax( m-p+1, rwork(p), 1 ) + p - 1
                 iwork(n+p) = q
                 if ( p /= q ) then
                    rtmp     = rwork(p)
                    rwork(p) = rwork(q)
                    rwork(q) = rtmp
                 end if
                 end do
                 if ( rwork(1) == zero ) then
                    ! quick return: a is the m x n zero matrix.
                    numrank = 0
                    call stdlib_dlaset( 'G', n, 1, zero, zero, s, n )
                    if ( wntus ) call stdlib_zlaset('G', m, n, czero, cone, u, ldu)
                    if ( wntua ) call stdlib_zlaset('G', m, m, czero, cone, u, ldu)
                    if ( wntva ) call stdlib_zlaset('G', n, n, czero, cone, v, ldv)
                    if ( wntuf ) then
                        call stdlib_zlaset( 'G', n, 1, czero, czero, cwork, n )
                        call stdlib_zlaset( 'G', m, n, czero, cone, u, ldu )
                    end if
                    do p = 1, n
                        iwork(p) = p
                    end do
                    if ( rowprm ) then
                        do p = n + 1, n + m - 1
                            iwork(p) = p - n
                        end do
                    end if
                    if ( conda ) rwork(1) = -1
                    rwork(2) = -1
                    return
                 end if
                 if ( rwork(1) > big / sqrt(real(m,KIND=dp)) ) then
                     ! .. to prevent overflow in the qr factorization, scale the
                     ! matrix by 1/sqrt(m) if too large entry detected
                     call stdlib_zlascl('G',0,0,sqrt(real(m,KIND=dp)),one, m,n, a,lda, ierr)
                               
                     ascaled = .true.
                 end if
                 call stdlib_zlaswp( n, a, lda, 1, m-1, iwork(n+1), 1 )
           end if
          ! .. at this stage, preemptive scaling is done only to avoid column
          ! norms overflows during the qr factorization. the svd procedure should
          ! have its own scaling to save the singular values from overflows and
          ! underflows. that depends on the svd procedure.
           if ( .not.rowprm ) then
               rtmp = stdlib_zlange( 'M', m, n, a, lda, rwork )
               if ( ( rtmp /= rtmp ) .or.( (rtmp*zero) /= zero ) ) then
                    info = -8
                    call stdlib_xerbla( 'ZGESVDQ', -info )
                    return
               end if
               if ( rtmp > big / sqrt(real(m,KIND=dp)) ) then
                   ! .. to prevent overflow in the qr factorization, scale the
                   ! matrix by 1/sqrt(m) if too large entry detected
                   call stdlib_zlascl('G',0,0, sqrt(real(m,KIND=dp)),one, m,n, a,lda, ierr)
                             
                   ascaled = .true.
               end if
           end if
           ! Qr Factorization With Column Pivoting
           ! a * p = q * [ r ]
                       ! [ 0 ]
           do p = 1, n
              ! All Columns Are Free Columns
              iwork(p) = 0
           end do
           call stdlib_zgeqp3( m, n, a, lda, iwork, cwork, cwork(n+1), lcwork-n,rwork, ierr )
                     
          ! if the user requested accuracy level allows truncation in the
          ! computed upper triangular factor, the matrix r is examined and,
          ! if possible, replaced with its leading upper trapezoidal part.
           epsln = stdlib_dlamch('E')
           sfmin = stdlib_dlamch('S')
           ! small = sfmin / epsln
           nr = n
           if ( accla ) then
              ! standard absolute error bound suffices. all sigma_i with
              ! sigma_i < n*eps*||a||_f are flushed to zero. this is an
              ! aggressive enforcement of lower numerical rank by introducing a
              ! backward error of the order of n*eps*||a||_f.
              nr = 1
              rtmp = sqrt(real(n,KIND=dp))*epsln
              do p = 2, n
                 if ( abs(a(p,p)) < (rtmp*abs(a(1,1))) ) go to 3002
                    nr = nr + 1
              end do
              3002 continue
           elseif ( acclm ) then
              ! .. similarly as above, only slightly more gentle (less aggressive).
              ! sudden drop on the diagonal of r is used as the criterion for being
              ! close-to-rank-deficient. the threshold is set to epsln=stdlib_dlamch('e').
              ! [[this can be made more flexible by replacing this hard-coded value
              ! with a user specified threshold.]] also, the values that underflow
              ! will be truncated.
              nr = 1
              do p = 2, n
                 if ( ( abs(a(p,p)) < (epsln*abs(a(p-1,p-1))) ) .or.( abs(a(p,p)) < sfmin ) ) go &
                           to 3402
                 nr = nr + 1
              end do
              3402 continue
           else
              ! Rrqr Not Authorized To Determine Numerical Rank Except In The
              ! obvious case of zero pivots.
              ! .. inspect r for exact zeros on the diagonal;
              ! r(i,i)=0 => r(i:n,i:n)=0.
              nr = 1
              do p = 2, n
                 if ( abs(a(p,p)) == zero ) go to 3502
                 nr = nr + 1
              end do
              3502 continue
              if ( conda ) then
                 ! estimate the scaled condition number of a. use the fact that it is
                 ! the same as the scaled condition number of r.
                    ! V Is Used As Workspace
                    call stdlib_zlacpy( 'U', n, n, a, lda, v, ldv )
                    ! only the leading nr x nr submatrix of the triangular factor
                    ! is considered. only if nr=n will this give a reliable error
                    ! bound. however, even for nr < n, this can be used on an
                    ! expert level and obtain useful information in the sense of
                    ! perturbation theory.
                    do p = 1, nr
                       rtmp = stdlib_dznrm2( p, v(1,p), 1 )
                       call stdlib_zdscal( p, one/rtmp, v(1,p), 1 )
                    end do
                    if ( .not. ( lsvec .or. rsvec ) ) then
                        call stdlib_zpocon( 'U', nr, v, ldv, one, rtmp,cwork, rwork, ierr )
                                  
                    else
                        call stdlib_zpocon( 'U', nr, v, ldv, one, rtmp,cwork(n+1), rwork, ierr )
                                  
                    end if
                    sconda = one / sqrt(rtmp)
                 ! for nr=n, sconda is an estimate of sqrt(||(r^* * r)^(-1)||_1),
                 ! n^(-1/4) * sconda <= ||r^(-1)||_2 <= n^(1/4) * sconda
                 ! see the reference [1] for more details.
              end if
           endif
           if ( wntur ) then
               n1 = nr
           else if ( wntus .or. wntuf) then
               n1 = n
           else if ( wntua ) then
               n1 = m
           end if
           if ( .not. ( rsvec .or. lsvec ) ) then
      ! .......................................................................
              ! Only The Singular Values Are Requested
      ! .......................................................................
              if ( rtrans ) then
               ! .. compute the singular values of r**h = [a](1:nr,1:n)**h
                 ! .. set the lower triangle of [a] to [a](1:nr,1:n)**h and
                 ! the upper triangle of [a] to zero.
                 do p = 1, min( n, nr )
                    a(p,p) = conjg(a(p,p))
                    do q = p + 1, n
                       a(q,p) = conjg(a(p,q))
                       if ( q <= nr ) a(p,q) = czero
                    end do
                 end do
                 call stdlib_zgesvd( 'N', 'N', n, nr, a, lda, s, u, ldu,v, ldv, cwork, lcwork, &
                           rwork, info )
              else
                 ! .. compute the singular values of r = [a](1:nr,1:n)
                 if ( nr > 1 )call stdlib_zlaset( 'L', nr-1,nr-1, czero,czero, a(2,1), lda )
                           
                 call stdlib_zgesvd( 'N', 'N', nr, n, a, lda, s, u, ldu,v, ldv, cwork, lcwork, &
                           rwork, info )
              end if
           else if ( lsvec .and. ( .not. rsvec) ) then
      ! .......................................................................
             ! The Singular Values And The Left Singular Vectors Requested
      ! .......................................................................""""""""
              if ( rtrans ) then
                  ! .. apply stdlib_zgesvd to r**h
                  ! .. copy r**h into [u] and overwrite [u] with the right singular
                  ! vectors of r
                 do p = 1, nr
                    do q = p, n
                       u(q,p) = conjg(a(p,q))
                    end do
                 end do
                 if ( nr > 1 )call stdlib_zlaset( 'U', nr-1,nr-1, czero,czero, u(1,2), ldu )
                           
                 ! .. the left singular vectors not computed, the nr right singular
                 ! vectors overwrite [u](1:nr,1:nr) as conjugate transposed. these
                 ! will be pre-multiplied by q to build the left singular vectors of a.
                    call stdlib_zgesvd( 'N', 'O', n, nr, u, ldu, s, u, ldu,u, ldu, cwork(n+1), &
                              lcwork-n, rwork, info )
                    do p = 1, nr
                        u(p,p) = conjg(u(p,p))
                        do q = p + 1, nr
                           ctmp   = conjg(u(q,p))
                           u(q,p) = conjg(u(p,q))
                           u(p,q) = ctmp
                        end do
                    end do
              else
                  ! Apply Stdlib_Zgesvd To R
                  ! .. copy r into [u] and overwrite [u] with the left singular vectors
                  call stdlib_zlacpy( 'U', nr, n, a, lda, u, ldu )
                  if ( nr > 1 )call stdlib_zlaset( 'L', nr-1, nr-1, czero, czero, u(2,1), ldu )
                            
                  ! .. the right singular vectors not computed, the nr left singular
                  ! vectors overwrite [u](1:nr,1:nr)
                     call stdlib_zgesvd( 'O', 'N', nr, n, u, ldu, s, u, ldu,v, ldv, cwork(n+1), &
                               lcwork-n, rwork, info )
                     ! .. now [u](1:nr,1:nr) contains the nr left singular vectors of
                     ! r. these will be pre-multiplied by q to build the left singular
                     ! vectors of a.
              end if
                 ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
              if ( ( nr < m ) .and. ( .not.wntuf ) ) then
                  call stdlib_zlaset('A', m-nr, nr, czero, czero, u(nr+1,1), ldu)
                  if ( nr < n1 ) then
                     call stdlib_zlaset( 'A',nr,n1-nr,czero,czero,u(1,nr+1), ldu )
                     call stdlib_zlaset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1), ldu )
                  end if
              end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! vectors matrix u.
              if ( .not.wntuf )call stdlib_zunmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, &
                        cwork(n+1), lcwork-n, ierr )
              if ( rowprm .and. .not.wntuf )call stdlib_zlaswp( n1, u, ldu, 1, m-1, iwork(n+1), -&
                        1 )
           else if ( rsvec .and. ( .not. lsvec ) ) then
      ! .......................................................................
             ! The Singular Values And The Right Singular Vectors Requested
      ! .......................................................................
               if ( rtrans ) then
                  ! .. apply stdlib_zgesvd to r**h
                  ! .. copy r**h into v and overwrite v with the left singular vectors
                 do p = 1, nr
                    do q = p, n
                       v(q,p) = conjg(a(p,q))
                    end do
                 end do
                 if ( nr > 1 )call stdlib_zlaset( 'U', nr-1,nr-1, czero,czero, v(1,2), ldv )
                           
                 ! .. the left singular vectors of r**h overwrite v, the right singular
                 ! vectors not computed
                 if ( wntvr .or. ( nr == n ) ) then
                    call stdlib_zgesvd( 'O', 'N', n, nr, v, ldv, s, u, ldu,u, ldu, cwork(n+1), &
                              lcwork-n, rwork, info )
                    do p = 1, nr
                        v(p,p) = conjg(v(p,p))
                        do q = p + 1, nr
                           ctmp   = conjg(v(q,p))
                           v(q,p) = conjg(v(p,q))
                           v(p,q) = ctmp
                        end do
                    end do
                    if ( nr < n ) then
                        do p = 1, nr
                           do q = nr + 1, n
                               v(p,q) = conjg(v(q,p))
                           end do
                        end do
                    end if
                    call stdlib_zlapmt( .false., nr, n, v, ldv, iwork )
                 else
                     ! .. need all n right singular vectors and nr < n
                     ! [!] this is simple implementation that augments [v](1:n,1:nr)
                     ! by padding a zero block. in the case nr << n, a more efficient
                     ! way is to first use the qr factorization. for more details
                     ! how to implement this, see the " full svd " branch.
                     call stdlib_zlaset('G', n, n-nr, czero, czero, v(1,nr+1), ldv)
                     call stdlib_zgesvd( 'O', 'N', n, n, v, ldv, s, u, ldu,u, ldu, cwork(n+1), &
                               lcwork-n, rwork, info )
                     do p = 1, n
                        v(p,p) = conjg(v(p,p))
                        do q = p + 1, n
                           ctmp   = conjg(v(q,p))
                           v(q,p) = conjg(v(p,q))
                           v(p,q) = ctmp
                        end do
                     end do
                     call stdlib_zlapmt( .false., n, n, v, ldv, iwork )
                 end if
               else
                  ! Aply Stdlib_Zgesvd To R
                  ! Copy R Into V And Overwrite V With The Right Singular Vectors
                  call stdlib_zlacpy( 'U', nr, n, a, lda, v, ldv )
                  if ( nr > 1 )call stdlib_zlaset( 'L', nr-1, nr-1, czero, czero, v(2,1), ldv )
                            
                  ! .. the right singular vectors overwrite v, the nr left singular
                  ! vectors stored in u(1:nr,1:nr)
                  if ( wntvr .or. ( nr == n ) ) then
                     call stdlib_zgesvd( 'N', 'O', nr, n, v, ldv, s, u, ldu,v, ldv, cwork(n+1), &
                               lcwork-n, rwork, info )
                     call stdlib_zlapmt( .false., nr, n, v, ldv, iwork )
                     ! .. now [v](1:nr,1:n) contains v(1:n,1:nr)**h
                  else
                     ! .. need all n right singular vectors and nr < n
                     ! [!] this is simple implementation that augments [v](1:nr,1:n)
                     ! by padding a zero block. in the case nr << n, a more efficient
                     ! way is to first use the lq factorization. for more details
                     ! how to implement this, see the " full svd " branch.
                      call stdlib_zlaset('G', n-nr, n, czero,czero, v(nr+1,1), ldv)
                      call stdlib_zgesvd( 'N', 'O', n, n, v, ldv, s, u, ldu,v, ldv, cwork(n+1), &
                                lcwork-n, rwork, info )
                      call stdlib_zlapmt( .false., n, n, v, ldv, iwork )
                  end if
                  ! .. now [v] contains the adjoint of the matrix of the right singular
                  ! vectors of a.
               end if
           else
      ! .......................................................................
             ! Full Svd Requested
      ! .......................................................................
              if ( rtrans ) then
                  ! .. apply stdlib_zgesvd to r**h [[this option is left for r
                 if ( wntvr .or. ( nr == n ) ) then
                  ! .. copy r**h into [v] and overwrite [v] with the left singular
                  ! vectors of r**h
                 do p = 1, nr
                    do q = p, n
                       v(q,p) = conjg(a(p,q))
                    end do
                 end do
                 if ( nr > 1 )call stdlib_zlaset( 'U', nr-1,nr-1, czero,czero, v(1,2), ldv )
                           
                 ! .. the left singular vectors of r**h overwrite [v], the nr right
                 ! singular vectors of r**h stored in [u](1:nr,1:nr) as conjugate
                 ! transposed
                    call stdlib_zgesvd( 'O', 'A', n, nr, v, ldv, s, v, ldv,u, ldu, cwork(n+1), &
                              lcwork-n, rwork, info )
                    ! Assemble V
                    do p = 1, nr
                       v(p,p) = conjg(v(p,p))
                       do q = p + 1, nr
                          ctmp   = conjg(v(q,p))
                          v(q,p) = conjg(v(p,q))
                          v(p,q) = ctmp
                       end do
                    end do
                    if ( nr < n ) then
                        do p = 1, nr
                           do q = nr+1, n
                              v(p,q) = conjg(v(q,p))
                           end do
                        end do
                    end if
                    call stdlib_zlapmt( .false., nr, n, v, ldv, iwork )
                     do p = 1, nr
                        u(p,p) = conjg(u(p,p))
                        do q = p + 1, nr
                           ctmp   = conjg(u(q,p))
                           u(q,p) = conjg(u(p,q))
                           u(p,q) = ctmp
                        end do
                     end do
                     if ( ( nr < m ) .and. .not.(wntuf)) then
                       call stdlib_zlaset('A', m-nr,nr, czero,czero, u(nr+1,1), ldu)
                       if ( nr < n1 ) then
                          call stdlib_zlaset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                          call stdlib_zlaset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1), ldu )
                                    
                       end if
                    end if
                 else
                     ! .. need all n right singular vectors and nr < n
                  ! .. copy r**h into [v] and overwrite [v] with the left singular
                  ! vectors of r**h
                     ! [[the optimal ratio n/nr for using qrf instead of padding
                       ! with zeros. here hard coded to 2; it must be at least
                       ! two due to work space constraints.]]
                     ! optratio = stdlib_ilaenv(6, 'zgesvd', 's' // 'o', nr,n,0,0)
                     ! optratio = max( optratio, 2 )
                     optratio = 2
                     if ( optratio*nr > n ) then
                        do p = 1, nr
                           do q = p, n
                              v(q,p) = conjg(a(p,q))
                           end do
                        end do
                        if ( nr > 1 )call stdlib_zlaset('U',nr-1,nr-1, czero,czero, v(1,2),ldv)
                                  
                        call stdlib_zlaset('A',n,n-nr,czero,czero,v(1,nr+1),ldv)
                        call stdlib_zgesvd( 'O', 'A', n, n, v, ldv, s, v, ldv,u, ldu, cwork(n+1), &
                                  lcwork-n, rwork, info )
                        do p = 1, n
                           v(p,p) = conjg(v(p,p))
                           do q = p + 1, n
                              ctmp   = conjg(v(q,p))
                              v(q,p) = conjg(v(p,q))
                              v(p,q) = ctmp
                           end do
                        end do
                        call stdlib_zlapmt( .false., n, n, v, ldv, iwork )
                    ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x n1), i.e. (m x n) or (m x m).
                        do p = 1, n
                           u(p,p) = conjg(u(p,p))
                           do q = p + 1, n
                              ctmp   = conjg(u(q,p))
                              u(q,p) = conjg(u(p,q))
                              u(p,q) = ctmp
                           end do
                        end do
                        if ( ( n < m ) .and. .not.(wntuf)) then
                           call stdlib_zlaset('A',m-n,n,czero,czero,u(n+1,1),ldu)
                           if ( n < n1 ) then
                             call stdlib_zlaset('A',n,n1-n,czero,czero,u(1,n+1),ldu)
                             call stdlib_zlaset('A',m-n,n1-n,czero,cone,u(n+1,n+1), ldu )
                           end if
                        end if
                     else
                        ! .. copy r**h into [u] and overwrite [u] with the right
                        ! singular vectors of r
                        do p = 1, nr
                           do q = p, n
                              u(q,nr+p) = conjg(a(p,q))
                           end do
                        end do
                        if ( nr > 1 )call stdlib_zlaset('U',nr-1,nr-1,czero,czero,u(1,nr+2),ldu)
                                  
                        call stdlib_zgeqrf( n, nr, u(1,nr+1), ldu, cwork(n+1),cwork(n+nr+1), &
                                  lcwork-n-nr, ierr )
                        do p = 1, nr
                            do q = 1, n
                                v(q,p) = conjg(u(p,nr+q))
                            end do
                        end do
                       if (nr>1) call stdlib_zlaset('U',nr-1,nr-1,czero,czero,v(1,2),ldv)
                       call stdlib_zgesvd( 'S', 'O', nr, nr, v, ldv, s, u, ldu,v,ldv, cwork(n+nr+&
                                 1),lcwork-n-nr,rwork, info )
                       call stdlib_zlaset('A',n-nr,nr,czero,czero,v(nr+1,1),ldv)
                       call stdlib_zlaset('A',nr,n-nr,czero,czero,v(1,nr+1),ldv)
                       call stdlib_zlaset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                       call stdlib_zunmqr('R','C', n, n, nr, u(1,nr+1), ldu,cwork(n+1),v,ldv,&
                                 cwork(n+nr+1),lcwork-n-nr,ierr)
                       call stdlib_zlapmt( .false., n, n, v, ldv, iwork )
                       ! Assemble The Left Singular Vector Matrix U Of Dimensions
                       ! (m x nr) or (m x n) or (m x m).
                       if ( ( nr < m ) .and. .not.(wntuf)) then
                          call stdlib_zlaset('A',m-nr,nr,czero,czero,u(nr+1,1),ldu)
                          if ( nr < n1 ) then
                          call stdlib_zlaset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                          call stdlib_zlaset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1),ldu)
                          end if
                       end if
                     end if
                 end if
              else
                  ! .. apply stdlib_zgesvd to r [[this is the recommended option]]
                  if ( wntvr .or. ( nr == n ) ) then
                      ! .. copy r into [v] and overwrite v with the right singular vectors
                      call stdlib_zlacpy( 'U', nr, n, a, lda, v, ldv )
                     if ( nr > 1 )call stdlib_zlaset( 'L', nr-1,nr-1, czero,czero, v(2,1), ldv )
                               
                     ! .. the right singular vectors of r overwrite [v], the nr left
                     ! singular vectors of r stored in [u](1:nr,1:nr)
                     call stdlib_zgesvd( 'S', 'O', nr, n, v, ldv, s, u, ldu,v, ldv, cwork(n+1), &
                               lcwork-n, rwork, info )
                     call stdlib_zlapmt( .false., nr, n, v, ldv, iwork )
                     ! .. now [v](1:nr,1:n) contains v(1:n,1:nr)**h
                     ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
                    if ( ( nr < m ) .and. .not.(wntuf)) then
                       call stdlib_zlaset('A', m-nr,nr, czero,czero, u(nr+1,1), ldu)
                       if ( nr < n1 ) then
                          call stdlib_zlaset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                          call stdlib_zlaset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1), ldu )
                                    
                       end if
                    end if
                  else
                    ! .. need all n right singular vectors and nr < n
                    ! The Requested Number Of The Left Singular Vectors
                     ! is then n1 (n or m)
                     ! [[the optimal ratio n/nr for using lq instead of padding
                       ! with zeros. here hard coded to 2; it must be at least
                       ! two due to work space constraints.]]
                     ! optratio = stdlib_ilaenv(6, 'zgesvd', 's' // 'o', nr,n,0,0)
                     ! optratio = max( optratio, 2 )
                    optratio = 2
                    if ( optratio * nr > n ) then
                       call stdlib_zlacpy( 'U', nr, n, a, lda, v, ldv )
                       if ( nr > 1 )call stdlib_zlaset('L', nr-1,nr-1, czero,czero, v(2,1),ldv)
                                 
                    ! .. the right singular vectors of r overwrite [v], the nr left
                       ! singular vectors of r stored in [u](1:nr,1:nr)
                       call stdlib_zlaset('A', n-nr,n, czero,czero, v(nr+1,1),ldv)
                       call stdlib_zgesvd( 'S', 'O', n, n, v, ldv, s, u, ldu,v, ldv, cwork(n+1), &
                                 lcwork-n, rwork, info )
                       call stdlib_zlapmt( .false., n, n, v, ldv, iwork )
                       ! .. now [v] contains the adjoint of the matrix of the right
                       ! singular vectors of a. the leading n left singular vectors
                       ! are in [u](1:n,1:n)
                       ! Assemble The Left Singular Vector Matrix U Of Dimensions
                       ! (m x n1), i.e. (m x n) or (m x m).
                       if ( ( n < m ) .and. .not.(wntuf)) then
                           call stdlib_zlaset('A',m-n,n,czero,czero,u(n+1,1),ldu)
                           if ( n < n1 ) then
                             call stdlib_zlaset('A',n,n1-n,czero,czero,u(1,n+1),ldu)
                             call stdlib_zlaset( 'A',m-n,n1-n,czero,cone,u(n+1,n+1), ldu )
                           end if
                       end if
                    else
                       call stdlib_zlacpy( 'U', nr, n, a, lda, u(nr+1,1), ldu )
                       if ( nr > 1 )call stdlib_zlaset('L',nr-1,nr-1,czero,czero,u(nr+2,1),ldu)
                                 
                       call stdlib_zgelqf( nr, n, u(nr+1,1), ldu, cwork(n+1),cwork(n+nr+1), &
                                 lcwork-n-nr, ierr )
                       call stdlib_zlacpy('L',nr,nr,u(nr+1,1),ldu,v,ldv)
                       if ( nr > 1 )call stdlib_zlaset('U',nr-1,nr-1,czero,czero,v(1,2),ldv)
                                 
                       call stdlib_zgesvd( 'S', 'O', nr, nr, v, ldv, s, u, ldu,v, ldv, cwork(n+nr+&
                                 1), lcwork-n-nr, rwork, info )
                       call stdlib_zlaset('A',n-nr,nr,czero,czero,v(nr+1,1),ldv)
                       call stdlib_zlaset('A',nr,n-nr,czero,czero,v(1,nr+1),ldv)
                       call stdlib_zlaset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                       call stdlib_zunmlq('R','N',n,n,nr,u(nr+1,1),ldu,cwork(n+1),v, ldv, cwork(n+&
                                 nr+1),lcwork-n-nr,ierr)
                       call stdlib_zlapmt( .false., n, n, v, ldv, iwork )
                     ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
                       if ( ( nr < m ) .and. .not.(wntuf)) then
                          call stdlib_zlaset('A',m-nr,nr,czero,czero,u(nr+1,1),ldu)
                          if ( nr < n1 ) then
                          call stdlib_zlaset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                          call stdlib_zlaset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1), ldu )
                                    
                          end if
                       end if
                    end if
                  end if
              ! .. end of the "r**h or r" branch
              end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! vectors matrix u.
              if ( .not. wntuf )call stdlib_zunmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, &
                        cwork(n+1), lcwork-n, ierr )
              if ( rowprm .and. .not.wntuf )call stdlib_zlaswp( n1, u, ldu, 1, m-1, iwork(n+1), -&
                        1 )
           ! ... end of the "full svd" branch
           end if
           ! check whether some singular values are returned as zeros, e.g.
           ! due to underflow, and update the numerical rank.
           p = nr
           do q = p, 1, -1
               if ( s(q) > zero ) go to 4002
               nr = nr - 1
           end do
           4002 continue
           ! .. if numerical rank deficiency is detected, the truncated
           ! singular values are set to zero.
           if ( nr < n ) call stdlib_dlaset( 'G', n-nr,1, zero,zero, s(nr+1), n )
           ! .. undo scaling; this may cause overflow in the largest singular
           ! values.
           if ( ascaled )call stdlib_dlascl( 'G',0,0, one,sqrt(real(m,KIND=dp)), nr,1, s, n, ierr &
                     )
           if ( conda ) rwork(1) = sconda
           rwork(2) = p - nr
           ! .. p-nr is the number of singular values that are computed as
           ! exact zeros in stdlib_zgesvd() applied to the (possibly truncated)
           ! full row rank triangular (trapezoidal) factor of a.
           numrank = nr
           return
     end subroutine stdlib_zgesvdq

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$gesvdq( joba, jobp, jobr, jobu, jobv, m, n, a, lda,s, u, ldu, v, ldv, &
      numrank, iwork, liwork,cwork, lcwork, rwork, lrwork, info )
     !! ZCGESVDQ computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N unitary matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
               
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: joba, jobp, jobr, jobu, jobv
           integer(ilp), intent(in) :: m, n, lda, ldu, ldv, liwork, lrwork
           integer(ilp), intent(out) :: numrank, info
           integer(ilp), intent(inout) :: lcwork
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: u(ldu,*), v(ldv,*), cwork(*)
           real(${ck}$), intent(out) :: s(*), rwork(*)
           integer(ilp), intent(out) :: iwork(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           integer(ilp) :: ierr, nr, n1, optratio, p, q
           integer(ilp) :: lwcon, lwqp3, lwrk_wgelqf, lwrk_wgesvd, lwrk_wgesvd2, lwrk_wgeqp3, &
           lwrk_wgeqrf, lwrk_wunmlq, lwrk_wunmqr, lwrk_wunmqr2, lwlqf, lwqrf, lwsvd, lwsvd2, &
                     lwunq, lwunq2, lwunlq, minwrk, minwrk2, optwrk, optwrk2, iminwrk, rminwrk
           logical(lk) :: accla, acclm, acclh, ascaled, conda, dntwu, dntwv, lquery, lsvc0, lsvec,&
                      rowprm, rsvec, rtrans, wntua, wntuf, wntur, wntus, wntva, wntvr
           real(${ck}$) :: big, epsln, rtmp, sconda, sfmin
           complex(${ck}$) :: ctmp
           ! Local Arrays
           complex(${ck}$) :: cdummy(1)
           real(${ck}$) :: rdummy(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           wntus  = stdlib_lsame( jobu, 'S' ) .or. stdlib_lsame( jobu, 'U' )
           wntur  = stdlib_lsame( jobu, 'R' )
           wntua  = stdlib_lsame( jobu, 'A' )
           wntuf  = stdlib_lsame( jobu, 'F' )
           lsvc0  = wntus .or. wntur .or. wntua
           lsvec  = lsvc0 .or. wntuf
           dntwu  = stdlib_lsame( jobu, 'N' )
           wntvr  = stdlib_lsame( jobv, 'R' )
           wntva  = stdlib_lsame( jobv, 'A' ) .or. stdlib_lsame( jobv, 'V' )
           rsvec  = wntvr .or. wntva
           dntwv  = stdlib_lsame( jobv, 'N' )
           accla  = stdlib_lsame( joba, 'A' )
           acclm  = stdlib_lsame( joba, 'M' )
           conda  = stdlib_lsame( joba, 'E' )
           acclh  = stdlib_lsame( joba, 'H' ) .or. conda
           rowprm = stdlib_lsame( jobp, 'P' )
           rtrans = stdlib_lsame( jobr, 'T' )
           if ( rowprm ) then
              iminwrk = max( 1, n + m - 1 )
              rminwrk = max( 2, m, 5*n )
           else
              iminwrk = max( 1, n )
              rminwrk = max( 2, 5*n )
           end if
           lquery = (liwork == -1 .or. lcwork == -1 .or. lrwork == -1)
           info  = 0
           if ( .not. ( accla .or. acclm .or. acclh ) ) then
              info = -1
           else if ( .not.( rowprm .or. stdlib_lsame( jobp, 'N' ) ) ) then
               info = -2
           else if ( .not.( rtrans .or. stdlib_lsame( jobr, 'N' ) ) ) then
               info = -3
           else if ( .not.( lsvec .or. dntwu ) ) then
              info = -4
           else if ( wntur .and. wntva ) then
              info = -5
           else if ( .not.( rsvec .or. dntwv )) then
              info = -5
           else if ( m<0 ) then
              info = -6
           else if ( ( n<0 ) .or. ( n>m ) ) then
              info = -7
           else if ( lda<max( 1, m ) ) then
              info = -9
           else if ( ldu<1 .or. ( lsvc0 .and. ldu<m ) .or.( wntuf .and. ldu<n ) ) then
              info = -12
           else if ( ldv<1 .or. ( rsvec .and. ldv<n ) .or.( conda .and. ldv<n ) ) then
              info = -14
           else if ( liwork < iminwrk .and. .not. lquery ) then
              info = -17
           end if
           if ( info == 0 ) then
              ! Compute The Minimal And The Optimal Workspace Lengths
              ! [[the expressions for computing the minimal and the optimal
              ! values of lcwork are written with a lot of redundancy and
              ! can be simplified. however, this detailed form is easier for
              ! maintenance and modifications of the code.]]
              ! Minimal Workspace Length For Stdlib_Zgeqp3 Of An M X N Matrix
              lwqp3 = n+1
              ! Minimal Workspace Length For Stdlib_Zunmqr To Build Left Singular Vectors
              if ( wntus .or. wntur ) then
                  lwunq  = max( n  , 1 )
              else if ( wntua ) then
                  lwunq = max( m , 1 )
              end if
              ! Minimal Workspace Length For Stdlib_Zpocon Of An N X N Matrix
              lwcon = 2 * n
              ! Stdlib_Zgesvd Of An N X N Matrix
              lwsvd = max( 3 * n, 1 )
              if ( lquery ) then
                  call stdlib_${ci}$geqp3( m, n, a, lda, iwork, cdummy, cdummy, -1,rdummy, ierr )
                            
                  lwrk_wgeqp3 = int( cdummy(1),KIND=ilp)
                  if ( wntus .or. wntur ) then
                      call stdlib_${ci}$unmqr( 'L', 'N', m, n, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_wunmqr = int( cdummy(1),KIND=ilp)
                  else if ( wntua ) then
                      call stdlib_${ci}$unmqr( 'L', 'N', m, m, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_wunmqr = int( cdummy(1),KIND=ilp)
                  else
                      lwrk_wunmqr = 0
                  end if
              end if
              minwrk = 2
              optwrk = 2
              if ( .not. (lsvec .or. rsvec ) ) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If
                  ! only the singular values are requested
                  if ( conda ) then
                     minwrk = max( n+lwqp3, lwcon, lwsvd )
                  else
                     minwrk = max( n+lwqp3, lwsvd )
                  end if
                  if ( lquery ) then
                      call stdlib_${ci}$gesvd( 'N', 'N', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                rdummy, ierr )
                      lwrk_wgesvd = int( cdummy(1),KIND=ilp)
                      if ( conda ) then
                         optwrk = max( n+lwrk_wgeqp3, n+lwcon, lwrk_wgesvd )
                      else
                         optwrk = max( n+lwrk_wgeqp3, lwrk_wgesvd )
                      end if
                  end if
              else if ( lsvec .and. (.not.rsvec) ) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! singular values and the left singular vectors are requested
                  if ( conda ) then
                      minwrk = n + max( lwqp3, lwcon, lwsvd, lwunq )
                  else
                      minwrk = n + max( lwqp3, lwsvd, lwunq )
                  end if
                  if ( lquery ) then
                     if ( rtrans ) then
                        call stdlib_${ci}$gesvd( 'N', 'O', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                  rdummy, ierr )
                     else
                        call stdlib_${ci}$gesvd( 'O', 'N', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                  rdummy, ierr )
                     end if
                     lwrk_wgesvd = int( cdummy(1),KIND=ilp)
                     if ( conda ) then
                         optwrk = n + max( lwrk_wgeqp3, lwcon, lwrk_wgesvd,lwrk_wunmqr )
                     else
                         optwrk = n + max( lwrk_wgeqp3, lwrk_wgesvd,lwrk_wunmqr )
                     end if
                  end if
              else if ( rsvec .and. (.not.lsvec) ) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! singular values and the right singular vectors are requested
                  if ( conda ) then
                      minwrk = n + max( lwqp3, lwcon, lwsvd )
                  else
                      minwrk = n + max( lwqp3, lwsvd )
                  end if
                  if ( lquery ) then
                      if ( rtrans ) then
                          call stdlib_${ci}$gesvd( 'O', 'N', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -&
                                    1, rdummy, ierr )
                      else
                          call stdlib_${ci}$gesvd( 'N', 'O', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -&
                                    1, rdummy, ierr )
                      end if
                      lwrk_wgesvd = int( cdummy(1),KIND=ilp)
                      if ( conda ) then
                          optwrk = n + max( lwrk_wgeqp3, lwcon, lwrk_wgesvd )
                      else
                          optwrk = n + max( lwrk_wgeqp3, lwrk_wgesvd )
                      end if
                  end if
              else
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! full svd is requested
                  if ( rtrans ) then
                      minwrk = max( lwqp3, lwsvd, lwunq )
                      if ( conda ) minwrk = max( minwrk, lwcon )
                      minwrk = minwrk + n
                      if ( wntva ) then
                         ! .. minimal workspace length for n x n/2 stdlib_${ci}$geqrf
                         lwqrf  = max( n/2, 1 )
                         ! .. minimal workspace length for n/2 x n/2 stdlib_${ci}$gesvd
                         lwsvd2 = max( 3 * (n/2), 1 )
                         lwunq2 = max( n, 1 )
                         minwrk2 = max( lwqp3, n/2+lwqrf, n/2+lwsvd2,n/2+lwunq2, lwunq )
                         if ( conda ) minwrk2 = max( minwrk2, lwcon )
                         minwrk2 = n + minwrk2
                         minwrk = max( minwrk, minwrk2 )
                      end if
                  else
                      minwrk = max( lwqp3, lwsvd, lwunq )
                      if ( conda ) minwrk = max( minwrk, lwcon )
                      minwrk = minwrk + n
                      if ( wntva ) then
                         ! .. minimal workspace length for n/2 x n stdlib_${ci}$gelqf
                         lwlqf  = max( n/2, 1 )
                         lwsvd2 = max( 3 * (n/2), 1 )
                         lwunlq = max( n , 1 )
                         minwrk2 = max( lwqp3, n/2+lwlqf, n/2+lwsvd2,n/2+lwunlq, lwunq )
                         if ( conda ) minwrk2 = max( minwrk2, lwcon )
                         minwrk2 = n + minwrk2
                         minwrk = max( minwrk, minwrk2 )
                      end if
                  end if
                  if ( lquery ) then
                     if ( rtrans ) then
                        call stdlib_${ci}$gesvd( 'O', 'A', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                  rdummy, ierr )
                        lwrk_wgesvd = int( cdummy(1),KIND=ilp)
                        optwrk = max(lwrk_wgeqp3,lwrk_wgesvd,lwrk_wunmqr)
                        if ( conda ) optwrk = max( optwrk, lwcon )
                        optwrk = n + optwrk
                        if ( wntva ) then
                            call stdlib_${ci}$geqrf(n,n/2,u,ldu,cdummy,cdummy,-1,ierr)
                            lwrk_wgeqrf = int( cdummy(1),KIND=ilp)
                            call stdlib_${ci}$gesvd( 'S', 'O', n/2,n/2, v,ldv, s, u,ldu,v, ldv, cdummy,&
                                       -1, rdummy, ierr )
                            lwrk_wgesvd2 = int( cdummy(1),KIND=ilp)
                            call stdlib_${ci}$unmqr( 'R', 'C', n, n, n/2, u, ldu, cdummy,v, ldv, &
                                      cdummy, -1, ierr )
                            lwrk_wunmqr2 = int( cdummy(1),KIND=ilp)
                            optwrk2 = max( lwrk_wgeqp3, n/2+lwrk_wgeqrf,n/2+lwrk_wgesvd2, n/2+&
                                      lwrk_wunmqr2 )
                            if ( conda ) optwrk2 = max( optwrk2, lwcon )
                            optwrk2 = n + optwrk2
                            optwrk = max( optwrk, optwrk2 )
                        end if
                     else
                        call stdlib_${ci}$gesvd( 'S', 'O', n, n, a, lda, s, u, ldu,v, ldv, cdummy, -1, &
                                  rdummy, ierr )
                        lwrk_wgesvd = int( cdummy(1),KIND=ilp)
                        optwrk = max(lwrk_wgeqp3,lwrk_wgesvd,lwrk_wunmqr)
                        if ( conda ) optwrk = max( optwrk, lwcon )
                        optwrk = n + optwrk
                        if ( wntva ) then
                           call stdlib_${ci}$gelqf(n/2,n,u,ldu,cdummy,cdummy,-1,ierr)
                           lwrk_wgelqf = int( cdummy(1),KIND=ilp)
                           call stdlib_${ci}$gesvd( 'S','O', n/2,n/2, v, ldv, s, u, ldu,v, ldv, cdummy,&
                                      -1, rdummy, ierr )
                           lwrk_wgesvd2 = int( cdummy(1),KIND=ilp)
                           call stdlib_${ci}$unmlq( 'R', 'N', n, n, n/2, u, ldu, cdummy,v, ldv, cdummy,&
                                     -1,ierr )
                           lwrk_wunmlq = int( cdummy(1),KIND=ilp)
                           optwrk2 = max( lwrk_wgeqp3, n/2+lwrk_wgelqf,n/2+lwrk_wgesvd2, n/2+&
                                     lwrk_wunmlq )
                            if ( conda ) optwrk2 = max( optwrk2, lwcon )
                            optwrk2 = n + optwrk2
                            optwrk = max( optwrk, optwrk2 )
                        end if
                     end if
                  end if
              end if
              minwrk = max( 2, minwrk )
              optwrk = max( 2, optwrk )
              if ( lcwork < minwrk .and. (.not.lquery) ) info = -19
           end if
           if (info == 0 .and. lrwork < rminwrk .and. .not. lquery) then
              info = -21
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGESVDQ', -info )
              return
           else if ( lquery ) then
           ! return optimal workspace
               iwork(1) = iminwrk
               cwork(1) = optwrk
               cwork(2) = minwrk
               rwork(1) = rminwrk
               return
           end if
           ! quick return if the matrix is void.
           if( ( m==0 ) .or. ( n==0 ) ) then
           ! All Output Is Void
              return
           end if
           big = stdlib_${c2ri(ci)}$lamch('O')
           ascaled = .false.
           if ( rowprm ) then
                 ! Reordering The Rows In Decreasing Sequence In The
                 ! ell-infinity norm - this enhances numerical robustness in
                 ! the case of differently scaled rows.
                 do p = 1, m
                     ! rwork(p) = abs( a(p,stdlib_i${ci}$amax(n,a(p,1),lda)) )
                     ! [[stdlib_${ci}$lange will return nan if an entry of the p-th row is nan]]
                     rwork(p) = stdlib_${ci}$lange( 'M', 1, n, a(p,1), lda, rdummy )
                     ! .. check for nan's and inf's
                     if ( ( rwork(p) /= rwork(p) ) .or.( (rwork(p)*zero) /= zero ) ) then
                         info = -8
                         call stdlib_xerbla( 'ZGESVDQ', -info )
                         return
                     end if
                 end do
                 do p = 1, m - 1
                 q = stdlib_i${c2ri(ci)}$amax( m-p+1, rwork(p), 1 ) + p - 1
                 iwork(n+p) = q
                 if ( p /= q ) then
                    rtmp     = rwork(p)
                    rwork(p) = rwork(q)
                    rwork(q) = rtmp
                 end if
                 end do
                 if ( rwork(1) == zero ) then
                    ! quick return: a is the m x n zero matrix.
                    numrank = 0
                    call stdlib_${c2ri(ci)}$laset( 'G', n, 1, zero, zero, s, n )
                    if ( wntus ) call stdlib_${ci}$laset('G', m, n, czero, cone, u, ldu)
                    if ( wntua ) call stdlib_${ci}$laset('G', m, m, czero, cone, u, ldu)
                    if ( wntva ) call stdlib_${ci}$laset('G', n, n, czero, cone, v, ldv)
                    if ( wntuf ) then
                        call stdlib_${ci}$laset( 'G', n, 1, czero, czero, cwork, n )
                        call stdlib_${ci}$laset( 'G', m, n, czero, cone, u, ldu )
                    end if
                    do p = 1, n
                        iwork(p) = p
                    end do
                    if ( rowprm ) then
                        do p = n + 1, n + m - 1
                            iwork(p) = p - n
                        end do
                    end if
                    if ( conda ) rwork(1) = -1
                    rwork(2) = -1
                    return
                 end if
                 if ( rwork(1) > big / sqrt(real(m,KIND=${ck}$)) ) then
                     ! .. to prevent overflow in the qr factorization, scale the
                     ! matrix by 1/sqrt(m) if too large entry detected
                     call stdlib_${ci}$lascl('G',0,0,sqrt(real(m,KIND=${ck}$)),one, m,n, a,lda, ierr)
                               
                     ascaled = .true.
                 end if
                 call stdlib_${ci}$laswp( n, a, lda, 1, m-1, iwork(n+1), 1 )
           end if
          ! .. at this stage, preemptive scaling is done only to avoid column
          ! norms overflows during the qr factorization. the svd procedure should
          ! have its own scaling to save the singular values from overflows and
          ! underflows. that depends on the svd procedure.
           if ( .not.rowprm ) then
               rtmp = stdlib_${ci}$lange( 'M', m, n, a, lda, rwork )
               if ( ( rtmp /= rtmp ) .or.( (rtmp*zero) /= zero ) ) then
                    info = -8
                    call stdlib_xerbla( 'ZGESVDQ', -info )
                    return
               end if
               if ( rtmp > big / sqrt(real(m,KIND=${ck}$)) ) then
                   ! .. to prevent overflow in the qr factorization, scale the
                   ! matrix by 1/sqrt(m) if too large entry detected
                   call stdlib_${ci}$lascl('G',0,0, sqrt(real(m,KIND=${ck}$)),one, m,n, a,lda, ierr)
                             
                   ascaled = .true.
               end if
           end if
           ! Qr Factorization With Column Pivoting
           ! a * p = q * [ r ]
                       ! [ 0 ]
           do p = 1, n
              ! All Columns Are Free Columns
              iwork(p) = 0
           end do
           call stdlib_${ci}$geqp3( m, n, a, lda, iwork, cwork, cwork(n+1), lcwork-n,rwork, ierr )
                     
          ! if the user requested accuracy level allows truncation in the
          ! computed upper triangular factor, the matrix r is examined and,
          ! if possible, replaced with its leading upper trapezoidal part.
           epsln = stdlib_${c2ri(ci)}$lamch('E')
           sfmin = stdlib_${c2ri(ci)}$lamch('S')
           ! small = sfmin / epsln
           nr = n
           if ( accla ) then
              ! standard absolute error bound suffices. all sigma_i with
              ! sigma_i < n*eps*||a||_f are flushed to zero. this is an
              ! aggressive enforcement of lower numerical rank by introducing a
              ! backward error of the order of n*eps*||a||_f.
              nr = 1
              rtmp = sqrt(real(n,KIND=${ck}$))*epsln
              do p = 2, n
                 if ( abs(a(p,p)) < (rtmp*abs(a(1,1))) ) go to 3002
                    nr = nr + 1
              end do
              3002 continue
           elseif ( acclm ) then
              ! .. similarly as above, only slightly more gentle (less aggressive).
              ! sudden drop on the diagonal of r is used as the criterion for being
              ! close-to-rank-deficient. the threshold is set to epsln=stdlib_${c2ri(ci)}$lamch('e').
              ! [[this can be made more flexible by replacing this hard-coded value
              ! with a user specified threshold.]] also, the values that underflow
              ! will be truncated.
              nr = 1
              do p = 2, n
                 if ( ( abs(a(p,p)) < (epsln*abs(a(p-1,p-1))) ) .or.( abs(a(p,p)) < sfmin ) ) go &
                           to 3402
                 nr = nr + 1
              end do
              3402 continue
           else
              ! Rrqr Not Authorized To Determine Numerical Rank Except In The
              ! obvious case of zero pivots.
              ! .. inspect r for exact zeros on the diagonal;
              ! r(i,i)=0 => r(i:n,i:n)=0.
              nr = 1
              do p = 2, n
                 if ( abs(a(p,p)) == zero ) go to 3502
                 nr = nr + 1
              end do
              3502 continue
              if ( conda ) then
                 ! estimate the scaled condition number of a. use the fact that it is
                 ! the same as the scaled condition number of r.
                    ! V Is Used As Workspace
                    call stdlib_${ci}$lacpy( 'U', n, n, a, lda, v, ldv )
                    ! only the leading nr x nr submatrix of the triangular factor
                    ! is considered. only if nr=n will this give a reliable error
                    ! bound. however, even for nr < n, this can be used on an
                    ! expert level and obtain useful information in the sense of
                    ! perturbation theory.
                    do p = 1, nr
                       rtmp = stdlib_${c2ri(ci)}$znrm2( p, v(1,p), 1 )
                       call stdlib_${ci}$dscal( p, one/rtmp, v(1,p), 1 )
                    end do
                    if ( .not. ( lsvec .or. rsvec ) ) then
                        call stdlib_${ci}$pocon( 'U', nr, v, ldv, one, rtmp,cwork, rwork, ierr )
                                  
                    else
                        call stdlib_${ci}$pocon( 'U', nr, v, ldv, one, rtmp,cwork(n+1), rwork, ierr )
                                  
                    end if
                    sconda = one / sqrt(rtmp)
                 ! for nr=n, sconda is an estimate of sqrt(||(r^* * r)^(-1)||_1),
                 ! n^(-1/4) * sconda <= ||r^(-1)||_2 <= n^(1/4) * sconda
                 ! see the reference [1] for more details.
              end if
           endif
           if ( wntur ) then
               n1 = nr
           else if ( wntus .or. wntuf) then
               n1 = n
           else if ( wntua ) then
               n1 = m
           end if
           if ( .not. ( rsvec .or. lsvec ) ) then
      ! .......................................................................
              ! Only The Singular Values Are Requested
      ! .......................................................................
              if ( rtrans ) then
               ! .. compute the singular values of r**h = [a](1:nr,1:n)**h
                 ! .. set the lower triangle of [a] to [a](1:nr,1:n)**h and
                 ! the upper triangle of [a] to zero.
                 do p = 1, min( n, nr )
                    a(p,p) = conjg(a(p,p))
                    do q = p + 1, n
                       a(q,p) = conjg(a(p,q))
                       if ( q <= nr ) a(p,q) = czero
                    end do
                 end do
                 call stdlib_${ci}$gesvd( 'N', 'N', n, nr, a, lda, s, u, ldu,v, ldv, cwork, lcwork, &
                           rwork, info )
              else
                 ! .. compute the singular values of r = [a](1:nr,1:n)
                 if ( nr > 1 )call stdlib_${ci}$laset( 'L', nr-1,nr-1, czero,czero, a(2,1), lda )
                           
                 call stdlib_${ci}$gesvd( 'N', 'N', nr, n, a, lda, s, u, ldu,v, ldv, cwork, lcwork, &
                           rwork, info )
              end if
           else if ( lsvec .and. ( .not. rsvec) ) then
      ! .......................................................................
             ! The Singular Values And The Left Singular Vectors Requested
      ! .......................................................................""""""""
              if ( rtrans ) then
                  ! .. apply stdlib_${ci}$gesvd to r**h
                  ! .. copy r**h into [u] and overwrite [u] with the right singular
                  ! vectors of r
                 do p = 1, nr
                    do q = p, n
                       u(q,p) = conjg(a(p,q))
                    end do
                 end do
                 if ( nr > 1 )call stdlib_${ci}$laset( 'U', nr-1,nr-1, czero,czero, u(1,2), ldu )
                           
                 ! .. the left singular vectors not computed, the nr right singular
                 ! vectors overwrite [u](1:nr,1:nr) as conjugate transposed. these
                 ! will be pre-multiplied by q to build the left singular vectors of a.
                    call stdlib_${ci}$gesvd( 'N', 'O', n, nr, u, ldu, s, u, ldu,u, ldu, cwork(n+1), &
                              lcwork-n, rwork, info )
                    do p = 1, nr
                        u(p,p) = conjg(u(p,p))
                        do q = p + 1, nr
                           ctmp   = conjg(u(q,p))
                           u(q,p) = conjg(u(p,q))
                           u(p,q) = ctmp
                        end do
                    end do
              else
                  ! Apply Stdlib_Zgesvd To R
                  ! .. copy r into [u] and overwrite [u] with the left singular vectors
                  call stdlib_${ci}$lacpy( 'U', nr, n, a, lda, u, ldu )
                  if ( nr > 1 )call stdlib_${ci}$laset( 'L', nr-1, nr-1, czero, czero, u(2,1), ldu )
                            
                  ! .. the right singular vectors not computed, the nr left singular
                  ! vectors overwrite [u](1:nr,1:nr)
                     call stdlib_${ci}$gesvd( 'O', 'N', nr, n, u, ldu, s, u, ldu,v, ldv, cwork(n+1), &
                               lcwork-n, rwork, info )
                     ! .. now [u](1:nr,1:nr) contains the nr left singular vectors of
                     ! r. these will be pre-multiplied by q to build the left singular
                     ! vectors of a.
              end if
                 ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
              if ( ( nr < m ) .and. ( .not.wntuf ) ) then
                  call stdlib_${ci}$laset('A', m-nr, nr, czero, czero, u(nr+1,1), ldu)
                  if ( nr < n1 ) then
                     call stdlib_${ci}$laset( 'A',nr,n1-nr,czero,czero,u(1,nr+1), ldu )
                     call stdlib_${ci}$laset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1), ldu )
                  end if
              end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! vectors matrix u.
              if ( .not.wntuf )call stdlib_${ci}$unmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, &
                        cwork(n+1), lcwork-n, ierr )
              if ( rowprm .and. .not.wntuf )call stdlib_${ci}$laswp( n1, u, ldu, 1, m-1, iwork(n+1), -&
                        1 )
           else if ( rsvec .and. ( .not. lsvec ) ) then
      ! .......................................................................
             ! The Singular Values And The Right Singular Vectors Requested
      ! .......................................................................
               if ( rtrans ) then
                  ! .. apply stdlib_${ci}$gesvd to r**h
                  ! .. copy r**h into v and overwrite v with the left singular vectors
                 do p = 1, nr
                    do q = p, n
                       v(q,p) = conjg(a(p,q))
                    end do
                 end do
                 if ( nr > 1 )call stdlib_${ci}$laset( 'U', nr-1,nr-1, czero,czero, v(1,2), ldv )
                           
                 ! .. the left singular vectors of r**h overwrite v, the right singular
                 ! vectors not computed
                 if ( wntvr .or. ( nr == n ) ) then
                    call stdlib_${ci}$gesvd( 'O', 'N', n, nr, v, ldv, s, u, ldu,u, ldu, cwork(n+1), &
                              lcwork-n, rwork, info )
                    do p = 1, nr
                        v(p,p) = conjg(v(p,p))
                        do q = p + 1, nr
                           ctmp   = conjg(v(q,p))
                           v(q,p) = conjg(v(p,q))
                           v(p,q) = ctmp
                        end do
                    end do
                    if ( nr < n ) then
                        do p = 1, nr
                           do q = nr + 1, n
                               v(p,q) = conjg(v(q,p))
                           end do
                        end do
                    end if
                    call stdlib_${ci}$lapmt( .false., nr, n, v, ldv, iwork )
                 else
                     ! .. need all n right singular vectors and nr < n
                     ! [!] this is simple implementation that augments [v](1:n,1:nr)
                     ! by padding a zero block. in the case nr << n, a more efficient
                     ! way is to first use the qr factorization. for more details
                     ! how to implement this, see the " full svd " branch.
                     call stdlib_${ci}$laset('G', n, n-nr, czero, czero, v(1,nr+1), ldv)
                     call stdlib_${ci}$gesvd( 'O', 'N', n, n, v, ldv, s, u, ldu,u, ldu, cwork(n+1), &
                               lcwork-n, rwork, info )
                     do p = 1, n
                        v(p,p) = conjg(v(p,p))
                        do q = p + 1, n
                           ctmp   = conjg(v(q,p))
                           v(q,p) = conjg(v(p,q))
                           v(p,q) = ctmp
                        end do
                     end do
                     call stdlib_${ci}$lapmt( .false., n, n, v, ldv, iwork )
                 end if
               else
                  ! Aply Stdlib_Zgesvd To R
                  ! Copy R Into V And Overwrite V With The Right Singular Vectors
                  call stdlib_${ci}$lacpy( 'U', nr, n, a, lda, v, ldv )
                  if ( nr > 1 )call stdlib_${ci}$laset( 'L', nr-1, nr-1, czero, czero, v(2,1), ldv )
                            
                  ! .. the right singular vectors overwrite v, the nr left singular
                  ! vectors stored in u(1:nr,1:nr)
                  if ( wntvr .or. ( nr == n ) ) then
                     call stdlib_${ci}$gesvd( 'N', 'O', nr, n, v, ldv, s, u, ldu,v, ldv, cwork(n+1), &
                               lcwork-n, rwork, info )
                     call stdlib_${ci}$lapmt( .false., nr, n, v, ldv, iwork )
                     ! .. now [v](1:nr,1:n) contains v(1:n,1:nr)**h
                  else
                     ! .. need all n right singular vectors and nr < n
                     ! [!] this is simple implementation that augments [v](1:nr,1:n)
                     ! by padding a zero block. in the case nr << n, a more efficient
                     ! way is to first use the lq factorization. for more details
                     ! how to implement this, see the " full svd " branch.
                      call stdlib_${ci}$laset('G', n-nr, n, czero,czero, v(nr+1,1), ldv)
                      call stdlib_${ci}$gesvd( 'N', 'O', n, n, v, ldv, s, u, ldu,v, ldv, cwork(n+1), &
                                lcwork-n, rwork, info )
                      call stdlib_${ci}$lapmt( .false., n, n, v, ldv, iwork )
                  end if
                  ! .. now [v] contains the adjoint of the matrix of the right singular
                  ! vectors of a.
               end if
           else
      ! .......................................................................
             ! Full Svd Requested
      ! .......................................................................
              if ( rtrans ) then
                  ! .. apply stdlib_${ci}$gesvd to r**h [[this option is left for r
                 if ( wntvr .or. ( nr == n ) ) then
                  ! .. copy r**h into [v] and overwrite [v] with the left singular
                  ! vectors of r**h
                 do p = 1, nr
                    do q = p, n
                       v(q,p) = conjg(a(p,q))
                    end do
                 end do
                 if ( nr > 1 )call stdlib_${ci}$laset( 'U', nr-1,nr-1, czero,czero, v(1,2), ldv )
                           
                 ! .. the left singular vectors of r**h overwrite [v], the nr right
                 ! singular vectors of r**h stored in [u](1:nr,1:nr) as conjugate
                 ! transposed
                    call stdlib_${ci}$gesvd( 'O', 'A', n, nr, v, ldv, s, v, ldv,u, ldu, cwork(n+1), &
                              lcwork-n, rwork, info )
                    ! Assemble V
                    do p = 1, nr
                       v(p,p) = conjg(v(p,p))
                       do q = p + 1, nr
                          ctmp   = conjg(v(q,p))
                          v(q,p) = conjg(v(p,q))
                          v(p,q) = ctmp
                       end do
                    end do
                    if ( nr < n ) then
                        do p = 1, nr
                           do q = nr+1, n
                              v(p,q) = conjg(v(q,p))
                           end do
                        end do
                    end if
                    call stdlib_${ci}$lapmt( .false., nr, n, v, ldv, iwork )
                     do p = 1, nr
                        u(p,p) = conjg(u(p,p))
                        do q = p + 1, nr
                           ctmp   = conjg(u(q,p))
                           u(q,p) = conjg(u(p,q))
                           u(p,q) = ctmp
                        end do
                     end do
                     if ( ( nr < m ) .and. .not.(wntuf)) then
                       call stdlib_${ci}$laset('A', m-nr,nr, czero,czero, u(nr+1,1), ldu)
                       if ( nr < n1 ) then
                          call stdlib_${ci}$laset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                          call stdlib_${ci}$laset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1), ldu )
                                    
                       end if
                    end if
                 else
                     ! .. need all n right singular vectors and nr < n
                  ! .. copy r**h into [v] and overwrite [v] with the left singular
                  ! vectors of r**h
                     ! [[the optimal ratio n/nr for using qrf instead of padding
                       ! with zeros. here hard coded to 2; it must be at least
                       ! two due to work space constraints.]]
                     ! optratio = stdlib_ilaenv(6, 'zgesvd', 's' // 'o', nr,n,0,0)
                     ! optratio = max( optratio, 2 )
                     optratio = 2
                     if ( optratio*nr > n ) then
                        do p = 1, nr
                           do q = p, n
                              v(q,p) = conjg(a(p,q))
                           end do
                        end do
                        if ( nr > 1 )call stdlib_${ci}$laset('U',nr-1,nr-1, czero,czero, v(1,2),ldv)
                                  
                        call stdlib_${ci}$laset('A',n,n-nr,czero,czero,v(1,nr+1),ldv)
                        call stdlib_${ci}$gesvd( 'O', 'A', n, n, v, ldv, s, v, ldv,u, ldu, cwork(n+1), &
                                  lcwork-n, rwork, info )
                        do p = 1, n
                           v(p,p) = conjg(v(p,p))
                           do q = p + 1, n
                              ctmp   = conjg(v(q,p))
                              v(q,p) = conjg(v(p,q))
                              v(p,q) = ctmp
                           end do
                        end do
                        call stdlib_${ci}$lapmt( .false., n, n, v, ldv, iwork )
                    ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x n1), i.e. (m x n) or (m x m).
                        do p = 1, n
                           u(p,p) = conjg(u(p,p))
                           do q = p + 1, n
                              ctmp   = conjg(u(q,p))
                              u(q,p) = conjg(u(p,q))
                              u(p,q) = ctmp
                           end do
                        end do
                        if ( ( n < m ) .and. .not.(wntuf)) then
                           call stdlib_${ci}$laset('A',m-n,n,czero,czero,u(n+1,1),ldu)
                           if ( n < n1 ) then
                             call stdlib_${ci}$laset('A',n,n1-n,czero,czero,u(1,n+1),ldu)
                             call stdlib_${ci}$laset('A',m-n,n1-n,czero,cone,u(n+1,n+1), ldu )
                           end if
                        end if
                     else
                        ! .. copy r**h into [u] and overwrite [u] with the right
                        ! singular vectors of r
                        do p = 1, nr
                           do q = p, n
                              u(q,nr+p) = conjg(a(p,q))
                           end do
                        end do
                        if ( nr > 1 )call stdlib_${ci}$laset('U',nr-1,nr-1,czero,czero,u(1,nr+2),ldu)
                                  
                        call stdlib_${ci}$geqrf( n, nr, u(1,nr+1), ldu, cwork(n+1),cwork(n+nr+1), &
                                  lcwork-n-nr, ierr )
                        do p = 1, nr
                            do q = 1, n
                                v(q,p) = conjg(u(p,nr+q))
                            end do
                        end do
                       if (nr>1) call stdlib_${ci}$laset('U',nr-1,nr-1,czero,czero,v(1,2),ldv)
                       call stdlib_${ci}$gesvd( 'S', 'O', nr, nr, v, ldv, s, u, ldu,v,ldv, cwork(n+nr+&
                                 1),lcwork-n-nr,rwork, info )
                       call stdlib_${ci}$laset('A',n-nr,nr,czero,czero,v(nr+1,1),ldv)
                       call stdlib_${ci}$laset('A',nr,n-nr,czero,czero,v(1,nr+1),ldv)
                       call stdlib_${ci}$laset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                       call stdlib_${ci}$unmqr('R','C', n, n, nr, u(1,nr+1), ldu,cwork(n+1),v,ldv,&
                                 cwork(n+nr+1),lcwork-n-nr,ierr)
                       call stdlib_${ci}$lapmt( .false., n, n, v, ldv, iwork )
                       ! Assemble The Left Singular Vector Matrix U Of Dimensions
                       ! (m x nr) or (m x n) or (m x m).
                       if ( ( nr < m ) .and. .not.(wntuf)) then
                          call stdlib_${ci}$laset('A',m-nr,nr,czero,czero,u(nr+1,1),ldu)
                          if ( nr < n1 ) then
                          call stdlib_${ci}$laset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                          call stdlib_${ci}$laset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1),ldu)
                          end if
                       end if
                     end if
                 end if
              else
                  ! .. apply stdlib_${ci}$gesvd to r [[this is the recommended option]]
                  if ( wntvr .or. ( nr == n ) ) then
                      ! .. copy r into [v] and overwrite v with the right singular vectors
                      call stdlib_${ci}$lacpy( 'U', nr, n, a, lda, v, ldv )
                     if ( nr > 1 )call stdlib_${ci}$laset( 'L', nr-1,nr-1, czero,czero, v(2,1), ldv )
                               
                     ! .. the right singular vectors of r overwrite [v], the nr left
                     ! singular vectors of r stored in [u](1:nr,1:nr)
                     call stdlib_${ci}$gesvd( 'S', 'O', nr, n, v, ldv, s, u, ldu,v, ldv, cwork(n+1), &
                               lcwork-n, rwork, info )
                     call stdlib_${ci}$lapmt( .false., nr, n, v, ldv, iwork )
                     ! .. now [v](1:nr,1:n) contains v(1:n,1:nr)**h
                     ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
                    if ( ( nr < m ) .and. .not.(wntuf)) then
                       call stdlib_${ci}$laset('A', m-nr,nr, czero,czero, u(nr+1,1), ldu)
                       if ( nr < n1 ) then
                          call stdlib_${ci}$laset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                          call stdlib_${ci}$laset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1), ldu )
                                    
                       end if
                    end if
                  else
                    ! .. need all n right singular vectors and nr < n
                    ! The Requested Number Of The Left Singular Vectors
                     ! is then n1 (n or m)
                     ! [[the optimal ratio n/nr for using lq instead of padding
                       ! with zeros. here hard coded to 2; it must be at least
                       ! two due to work space constraints.]]
                     ! optratio = stdlib_ilaenv(6, 'zgesvd', 's' // 'o', nr,n,0,0)
                     ! optratio = max( optratio, 2 )
                    optratio = 2
                    if ( optratio * nr > n ) then
                       call stdlib_${ci}$lacpy( 'U', nr, n, a, lda, v, ldv )
                       if ( nr > 1 )call stdlib_${ci}$laset('L', nr-1,nr-1, czero,czero, v(2,1),ldv)
                                 
                    ! .. the right singular vectors of r overwrite [v], the nr left
                       ! singular vectors of r stored in [u](1:nr,1:nr)
                       call stdlib_${ci}$laset('A', n-nr,n, czero,czero, v(nr+1,1),ldv)
                       call stdlib_${ci}$gesvd( 'S', 'O', n, n, v, ldv, s, u, ldu,v, ldv, cwork(n+1), &
                                 lcwork-n, rwork, info )
                       call stdlib_${ci}$lapmt( .false., n, n, v, ldv, iwork )
                       ! .. now [v] contains the adjoint of the matrix of the right
                       ! singular vectors of a. the leading n left singular vectors
                       ! are in [u](1:n,1:n)
                       ! Assemble The Left Singular Vector Matrix U Of Dimensions
                       ! (m x n1), i.e. (m x n) or (m x m).
                       if ( ( n < m ) .and. .not.(wntuf)) then
                           call stdlib_${ci}$laset('A',m-n,n,czero,czero,u(n+1,1),ldu)
                           if ( n < n1 ) then
                             call stdlib_${ci}$laset('A',n,n1-n,czero,czero,u(1,n+1),ldu)
                             call stdlib_${ci}$laset( 'A',m-n,n1-n,czero,cone,u(n+1,n+1), ldu )
                           end if
                       end if
                    else
                       call stdlib_${ci}$lacpy( 'U', nr, n, a, lda, u(nr+1,1), ldu )
                       if ( nr > 1 )call stdlib_${ci}$laset('L',nr-1,nr-1,czero,czero,u(nr+2,1),ldu)
                                 
                       call stdlib_${ci}$gelqf( nr, n, u(nr+1,1), ldu, cwork(n+1),cwork(n+nr+1), &
                                 lcwork-n-nr, ierr )
                       call stdlib_${ci}$lacpy('L',nr,nr,u(nr+1,1),ldu,v,ldv)
                       if ( nr > 1 )call stdlib_${ci}$laset('U',nr-1,nr-1,czero,czero,v(1,2),ldv)
                                 
                       call stdlib_${ci}$gesvd( 'S', 'O', nr, nr, v, ldv, s, u, ldu,v, ldv, cwork(n+nr+&
                                 1), lcwork-n-nr, rwork, info )
                       call stdlib_${ci}$laset('A',n-nr,nr,czero,czero,v(nr+1,1),ldv)
                       call stdlib_${ci}$laset('A',nr,n-nr,czero,czero,v(1,nr+1),ldv)
                       call stdlib_${ci}$laset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                       call stdlib_${ci}$unmlq('R','N',n,n,nr,u(nr+1,1),ldu,cwork(n+1),v, ldv, cwork(n+&
                                 nr+1),lcwork-n-nr,ierr)
                       call stdlib_${ci}$lapmt( .false., n, n, v, ldv, iwork )
                     ! Assemble The Left Singular Vector Matrix U Of Dimensions
                    ! (m x nr) or (m x n) or (m x m).
                       if ( ( nr < m ) .and. .not.(wntuf)) then
                          call stdlib_${ci}$laset('A',m-nr,nr,czero,czero,u(nr+1,1),ldu)
                          if ( nr < n1 ) then
                          call stdlib_${ci}$laset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                          call stdlib_${ci}$laset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1), ldu )
                                    
                          end if
                       end if
                    end if
                  end if
              ! .. end of the "r**h or r" branch
              end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! vectors matrix u.
              if ( .not. wntuf )call stdlib_${ci}$unmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, &
                        cwork(n+1), lcwork-n, ierr )
              if ( rowprm .and. .not.wntuf )call stdlib_${ci}$laswp( n1, u, ldu, 1, m-1, iwork(n+1), -&
                        1 )
           ! ... end of the "full svd" branch
           end if
           ! check whether some singular values are returned as zeros, e.g.
           ! due to underflow, and update the numerical rank.
           p = nr
           do q = p, 1, -1
               if ( s(q) > zero ) go to 4002
               nr = nr - 1
           end do
           4002 continue
           ! .. if numerical rank deficiency is detected, the truncated
           ! singular values are set to zero.
           if ( nr < n ) call stdlib_${c2ri(ci)}$laset( 'G', n-nr,1, zero,zero, s(nr+1), n )
           ! .. undo scaling; this may cause overflow in the largest singular
           ! values.
           if ( ascaled )call stdlib_${c2ri(ci)}$lascl( 'G',0,0, one,sqrt(real(m,KIND=${ck}$)), nr,1, s, n, ierr &
                     )
           if ( conda ) rwork(1) = sconda
           rwork(2) = p - nr
           ! .. p-nr is the number of singular values that are computed as
           ! exact zeros in stdlib_${ci}$gesvd() applied to the (possibly truncated)
           ! full row rank triangular (trapezoidal) factor of a.
           numrank = nr
           return
     end subroutine stdlib_${ci}$gesvdq

#:endif
#:endfor



     module subroutine stdlib_sgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, info )
     !! SGESVD computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, optionally computing the left and/or right singular
     !! vectors. The SVD is written
     !! A = U * SIGMA * transpose(V)
     !! where SIGMA is an M-by-N matrix which is zero except for its
     !! min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
     !! V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
     !! are the singular values of A; they are real and non-negative, and
     !! are returned in descending order.  The first min(m,n) columns of
     !! U and V are the left and right singular vectors of A.
     !! Note that the routine returns V**T, not V.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobu, jobvt
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldvt, lwork, m, n
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: s(*), u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wntua, wntuas, wntun, wntuo, wntus, wntva, wntvas, wntvn, wntvo,&
                      wntvs
           integer(ilp) :: bdspac, blk, chunk, i, ie, ierr, ir, iscl, itau, itaup, itauq, iu, &
           iwork, ldwrkr, ldwrku, maxwrk, minmn, minwrk, mnthr, ncu, ncvt, nru, nrvt, &
                     wrkbl
           integer(ilp) :: lwork_sgeqrf, lwork_sorgqr_n, lwork_sorgqr_m, lwork_sgebrd, &
                     lwork_sorgbr_p, lwork_sorgbr_q, lwork_sgelqf, lwork_sorglq_n, lwork_sorglq_m
           real(sp) :: anrm, bignum, eps, smlnum
           ! Local Arrays 
           real(sp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           minmn = min( m, n )
           wntua = stdlib_lsame( jobu, 'A' )
           wntus = stdlib_lsame( jobu, 'S' )
           wntuas = wntua .or. wntus
           wntuo = stdlib_lsame( jobu, 'O' )
           wntun = stdlib_lsame( jobu, 'N' )
           wntva = stdlib_lsame( jobvt, 'A' )
           wntvs = stdlib_lsame( jobvt, 'S' )
           wntvas = wntva .or. wntvs
           wntvo = stdlib_lsame( jobvt, 'O' )
           wntvn = stdlib_lsame( jobvt, 'N' )
           lquery = ( lwork==-1 )
           if( .not.( wntua .or. wntus .or. wntuo .or. wntun ) ) then
              info = -1
           else if( .not.( wntva .or. wntvs .or. wntvo .or. wntvn ) .or.( wntvo .and. wntuo ) ) &
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( ldu<1 .or. ( wntuas .and. ldu<m ) ) then
              info = -9
           else if( ldvt<1 .or. ( wntva .and. ldvt<n ) .or.( wntvs .and. ldvt<minmn ) ) &
                     then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              if( m>=n .and. minmn>0 ) then
                 ! compute space needed for stdlib_sbdsqr
                 mnthr = stdlib_ilaenv( 6, 'SGESVD', jobu // jobvt, m, n, 0, 0 )
                 bdspac = 5*n
                 ! compute space needed for stdlib_sgeqrf
                 call stdlib_sgeqrf( m, n, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_sgeqrf = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_sorgqr
                 call stdlib_sorgqr( m, n, n, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_sorgqr_n = int( dum(1),KIND=ilp)
                 call stdlib_sorgqr( m, m, n, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_sorgqr_m = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_sgebrd
                 call stdlib_sgebrd( n, n, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                           
                 lwork_sgebrd = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_sorgbr p
                 call stdlib_sorgbr( 'P', n, n, n, a, lda, dum(1),dum(1), -1, ierr )
                 lwork_sorgbr_p = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_sorgbr q
                 call stdlib_sorgbr( 'Q', n, n, n, a, lda, dum(1),dum(1), -1, ierr )
                 lwork_sorgbr_q = int( dum(1),KIND=ilp)
                 if( m>=mnthr ) then
                    if( wntun ) then
                       ! path 1 (m much larger than n, jobu='n')
                       maxwrk = n + lwork_sgeqrf
                       maxwrk = max( maxwrk, 3*n+lwork_sgebrd )
                       if( wntvo .or. wntvas )maxwrk = max( maxwrk, 3*n+lwork_sorgbr_p )
                       maxwrk = max( maxwrk, bdspac )
                       minwrk = max( 4*n, bdspac )
                    else if( wntuo .and. wntvn ) then
                       ! path 2 (m much larger than n, jobu='o', jobvt='n')
                       wrkbl = n + lwork_sgeqrf
                       wrkbl = max( wrkbl, n+lwork_sorgqr_n )
                       wrkbl = max( wrkbl, 3*n+lwork_sgebrd )
                       wrkbl = max( wrkbl, 3*n+lwork_sorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = max( n*n+wrkbl, n*n+m*n+n )
                       minwrk = max( 3*n+m, bdspac )
                    else if( wntuo .and. wntvas ) then
                       ! path 3 (m much larger than n, jobu='o', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_sgeqrf
                       wrkbl = max( wrkbl, n+lwork_sorgqr_n )
                       wrkbl = max( wrkbl, 3*n+lwork_sgebrd )
                       wrkbl = max( wrkbl, 3*n+lwork_sorgbr_q )
                       wrkbl = max( wrkbl, 3*n+lwork_sorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = max( n*n+wrkbl, n*n+m*n+n )
                       minwrk = max( 3*n+m, bdspac )
                    else if( wntus .and. wntvn ) then
                       ! path 4 (m much larger than n, jobu='s', jobvt='n')
                       wrkbl = n + lwork_sgeqrf
                       wrkbl = max( wrkbl, n+lwork_sorgqr_n )
                       wrkbl = max( wrkbl, 3*n+lwork_sgebrd )
                       wrkbl = max( wrkbl, 3*n+lwork_sorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = n*n + wrkbl
                       minwrk = max( 3*n+m, bdspac )
                    else if( wntus .and. wntvo ) then
                       ! path 5 (m much larger than n, jobu='s', jobvt='o')
                       wrkbl = n + lwork_sgeqrf
                       wrkbl = max( wrkbl, n+lwork_sorgqr_n )
                       wrkbl = max( wrkbl, 3*n+lwork_sgebrd )
                       wrkbl = max( wrkbl, 3*n+lwork_sorgbr_q )
                       wrkbl = max( wrkbl, 3*n+lwork_sorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = 2*n*n + wrkbl
                       minwrk = max( 3*n+m, bdspac )
                    else if( wntus .and. wntvas ) then
                       ! path 6 (m much larger than n, jobu='s', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_sgeqrf
                       wrkbl = max( wrkbl, n+lwork_sorgqr_n )
                       wrkbl = max( wrkbl, 3*n+lwork_sgebrd )
                       wrkbl = max( wrkbl, 3*n+lwork_sorgbr_q )
                       wrkbl = max( wrkbl, 3*n+lwork_sorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = n*n + wrkbl
                       minwrk = max( 3*n+m, bdspac )
                    else if( wntua .and. wntvn ) then
                       ! path 7 (m much larger than n, jobu='a', jobvt='n')
                       wrkbl = n + lwork_sgeqrf
                       wrkbl = max( wrkbl, n+lwork_sorgqr_m )
                       wrkbl = max( wrkbl, 3*n+lwork_sgebrd )
                       wrkbl = max( wrkbl, 3*n+lwork_sorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = n*n + wrkbl
                       minwrk = max( 3*n+m, bdspac )
                    else if( wntua .and. wntvo ) then
                       ! path 8 (m much larger than n, jobu='a', jobvt='o')
                       wrkbl = n + lwork_sgeqrf
                       wrkbl = max( wrkbl, n+lwork_sorgqr_m )
                       wrkbl = max( wrkbl, 3*n+lwork_sgebrd )
                       wrkbl = max( wrkbl, 3*n+lwork_sorgbr_q )
                       wrkbl = max( wrkbl, 3*n+lwork_sorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = 2*n*n + wrkbl
                       minwrk = max( 3*n+m, bdspac )
                    else if( wntua .and. wntvas ) then
                       ! path 9 (m much larger than n, jobu='a', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_sgeqrf
                       wrkbl = max( wrkbl, n+lwork_sorgqr_m )
                       wrkbl = max( wrkbl, 3*n+lwork_sgebrd )
                       wrkbl = max( wrkbl, 3*n+lwork_sorgbr_q )
                       wrkbl = max( wrkbl, 3*n+lwork_sorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = n*n + wrkbl
                       minwrk = max( 3*n+m, bdspac )
                    end if
                 else
                    ! path 10 (m at least n, but not much larger)
                    call stdlib_sgebrd( m, n, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                              
                    lwork_sgebrd = int( dum(1),KIND=ilp)
                    maxwrk = 3*n + lwork_sgebrd
                    if( wntus .or. wntuo ) then
                       call stdlib_sorgbr( 'Q', m, n, n, a, lda, dum(1),dum(1), -1, ierr )
                       lwork_sorgbr_q = int( dum(1),KIND=ilp)
                       maxwrk = max( maxwrk, 3*n+lwork_sorgbr_q )
                    end if
                    if( wntua ) then
                       call stdlib_sorgbr( 'Q', m, m, n, a, lda, dum(1),dum(1), -1, ierr )
                       lwork_sorgbr_q = int( dum(1),KIND=ilp)
                       maxwrk = max( maxwrk, 3*n+lwork_sorgbr_q )
                    end if
                    if( .not.wntvn ) then
                      maxwrk = max( maxwrk, 3*n+lwork_sorgbr_p )
                    end if
                    maxwrk = max( maxwrk, bdspac )
                    minwrk = max( 3*n+m, bdspac )
                 end if
              else if( minmn>0 ) then
                 ! compute space needed for stdlib_sbdsqr
                 mnthr = stdlib_ilaenv( 6, 'SGESVD', jobu // jobvt, m, n, 0, 0 )
                 bdspac = 5*m
                 ! compute space needed for stdlib_sgelqf
                 call stdlib_sgelqf( m, n, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_sgelqf = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_sorglq
                 call stdlib_sorglq( n, n, m, dum(1), n, dum(1), dum(1), -1, ierr )
                 lwork_sorglq_n = int( dum(1),KIND=ilp)
                 call stdlib_sorglq( m, n, m, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_sorglq_m = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_sgebrd
                 call stdlib_sgebrd( m, m, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                           
                 lwork_sgebrd = int( dum(1),KIND=ilp)
                  ! compute space needed for stdlib_sorgbr p
                 call stdlib_sorgbr( 'P', m, m, m, a, n, dum(1),dum(1), -1, ierr )
                 lwork_sorgbr_p = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_sorgbr q
                 call stdlib_sorgbr( 'Q', m, m, m, a, n, dum(1),dum(1), -1, ierr )
                 lwork_sorgbr_q = int( dum(1),KIND=ilp)
                 if( n>=mnthr ) then
                    if( wntvn ) then
                       ! path 1t(n much larger than m, jobvt='n')
                       maxwrk = m + lwork_sgelqf
                       maxwrk = max( maxwrk, 3*m+lwork_sgebrd )
                       if( wntuo .or. wntuas )maxwrk = max( maxwrk, 3*m+lwork_sorgbr_q )
                       maxwrk = max( maxwrk, bdspac )
                       minwrk = max( 4*m, bdspac )
                    else if( wntvo .and. wntun ) then
                       ! path 2t(n much larger than m, jobu='n', jobvt='o')
                       wrkbl = m + lwork_sgelqf
                       wrkbl = max( wrkbl, m+lwork_sorglq_m )
                       wrkbl = max( wrkbl, 3*m+lwork_sgebrd )
                       wrkbl = max( wrkbl, 3*m+lwork_sorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = max( m*m+wrkbl, m*m+m*n+m )
                       minwrk = max( 3*m+n, bdspac )
                    else if( wntvo .and. wntuas ) then
                       ! path 3t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='o')
                       wrkbl = m + lwork_sgelqf
                       wrkbl = max( wrkbl, m+lwork_sorglq_m )
                       wrkbl = max( wrkbl, 3*m+lwork_sgebrd )
                       wrkbl = max( wrkbl, 3*m+lwork_sorgbr_p )
                       wrkbl = max( wrkbl, 3*m+lwork_sorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = max( m*m+wrkbl, m*m+m*n+m )
                       minwrk = max( 3*m+n, bdspac )
                    else if( wntvs .and. wntun ) then
                       ! path 4t(n much larger than m, jobu='n', jobvt='s')
                       wrkbl = m + lwork_sgelqf
                       wrkbl = max( wrkbl, m+lwork_sorglq_m )
                       wrkbl = max( wrkbl, 3*m+lwork_sgebrd )
                       wrkbl = max( wrkbl, 3*m+lwork_sorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = m*m + wrkbl
                       minwrk = max( 3*m+n, bdspac )
                    else if( wntvs .and. wntuo ) then
                       ! path 5t(n much larger than m, jobu='o', jobvt='s')
                       wrkbl = m + lwork_sgelqf
                       wrkbl = max( wrkbl, m+lwork_sorglq_m )
                       wrkbl = max( wrkbl, 3*m+lwork_sgebrd )
                       wrkbl = max( wrkbl, 3*m+lwork_sorgbr_p )
                       wrkbl = max( wrkbl, 3*m+lwork_sorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = 2*m*m + wrkbl
                       minwrk = max( 3*m+n, bdspac )
                       maxwrk = max( maxwrk, minwrk )
                    else if( wntvs .and. wntuas ) then
                       ! path 6t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='s')
                       wrkbl = m + lwork_sgelqf
                       wrkbl = max( wrkbl, m+lwork_sorglq_m )
                       wrkbl = max( wrkbl, 3*m+lwork_sgebrd )
                       wrkbl = max( wrkbl, 3*m+lwork_sorgbr_p )
                       wrkbl = max( wrkbl, 3*m+lwork_sorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = m*m + wrkbl
                       minwrk = max( 3*m+n, bdspac )
                    else if( wntva .and. wntun ) then
                       ! path 7t(n much larger than m, jobu='n', jobvt='a')
                       wrkbl = m + lwork_sgelqf
                       wrkbl = max( wrkbl, m+lwork_sorglq_n )
                       wrkbl = max( wrkbl, 3*m+lwork_sgebrd )
                       wrkbl = max( wrkbl, 3*m+lwork_sorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = m*m + wrkbl
                       minwrk = max( 3*m+n, bdspac )
                    else if( wntva .and. wntuo ) then
                       ! path 8t(n much larger than m, jobu='o', jobvt='a')
                       wrkbl = m + lwork_sgelqf
                       wrkbl = max( wrkbl, m+lwork_sorglq_n )
                       wrkbl = max( wrkbl, 3*m+lwork_sgebrd )
                       wrkbl = max( wrkbl, 3*m+lwork_sorgbr_p )
                       wrkbl = max( wrkbl, 3*m+lwork_sorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = 2*m*m + wrkbl
                       minwrk = max( 3*m+n, bdspac )
                    else if( wntva .and. wntuas ) then
                       ! path 9t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='a')
                       wrkbl = m + lwork_sgelqf
                       wrkbl = max( wrkbl, m+lwork_sorglq_n )
                       wrkbl = max( wrkbl, 3*m+lwork_sgebrd )
                       wrkbl = max( wrkbl, 3*m+lwork_sorgbr_p )
                       wrkbl = max( wrkbl, 3*m+lwork_sorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = m*m + wrkbl
                       minwrk = max( 3*m+n, bdspac )
                    end if
                 else
                    ! path 10t(n greater than m, but not much larger)
                    call stdlib_sgebrd( m, n, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                              
                    lwork_sgebrd = int( dum(1),KIND=ilp)
                    maxwrk = 3*m + lwork_sgebrd
                    if( wntvs .or. wntvo ) then
                      ! compute space needed for stdlib_sorgbr p
                      call stdlib_sorgbr( 'P', m, n, m, a, n, dum(1),dum(1), -1, ierr )
                      lwork_sorgbr_p = int( dum(1),KIND=ilp)
                      maxwrk = max( maxwrk, 3*m+lwork_sorgbr_p )
                    end if
                    if( wntva ) then
                      call stdlib_sorgbr( 'P', n, n, m, a, n, dum(1),dum(1), -1, ierr )
                      lwork_sorgbr_p = int( dum(1),KIND=ilp)
                      maxwrk = max( maxwrk, 3*m+lwork_sorgbr_p )
                    end if
                    if( .not.wntun ) then
                       maxwrk = max( maxwrk, 3*m+lwork_sorgbr_q )
                    end if
                    maxwrk = max( maxwrk, bdspac )
                    minwrk = max( 3*m+n, bdspac )
                 end if
              end if
              maxwrk = max( maxwrk, minwrk )
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGESVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = sqrt( stdlib_slamch( 'S' ) ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_slange( 'M', m, n, a, lda, dum )
           iscl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              iscl = 1
              call stdlib_slascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, ierr )
           else if( anrm>bignum ) then
              iscl = 1
              call stdlib_slascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, ierr )
           end if
           if( m>=n ) then
              ! a has at least as many rows as columns. if a has sufficiently
              ! more rows than columns, first reduce using the qr
              ! decomposition (if sufficient workspace available)
              if( m>=mnthr ) then
                 if( wntun ) then
                    ! path 1 (m much larger than n, jobu='n')
                    ! no left singular vectors to be computed
                    itau = 1
                    iwork = itau + n
                    ! compute a=q*r
                    ! (workspace: need 2*n, prefer n+n*nb)
                    call stdlib_sgeqrf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, &
                              ierr )
                    ! zero out below r
                    if( n > 1 ) then
                       call stdlib_slaset( 'L', n-1, n-1, zero, zero, a( 2, 1 ),lda )
                    end if
                    ie = 1
                    itauq = ie + n
                    itaup = itauq + n
                    iwork = itaup + n
                    ! bidiagonalize r in a
                    ! (workspace: need 4*n, prefer 3*n+2*n*nb)
                    call stdlib_sgebrd( n, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( iwork ), lwork-iwork+1,ierr )
                    ncvt = 0
                    if( wntvo .or. wntvas ) then
                       ! if right singular vectors desired, generate p'.
                       ! (workspace: need 4*n-1, prefer 3*n+(n-1)*nb)
                       call stdlib_sorgbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       ncvt = n
                    end if
                    iwork = ie + n
                    ! perform bidiagonal qr iteration, computing right
                    ! singular vectors of a in a if desired
                    ! (workspace: need bdspac)
                    call stdlib_sbdsqr( 'U', n, ncvt, 0, 0, s, work( ie ), a, lda,dum, 1, dum, 1, &
                              work( iwork ), info )
                    ! if right singular vectors desired in vt, copy them there
                    if( wntvas )call stdlib_slacpy( 'F', n, n, a, lda, vt, ldvt )
                 else if( wntuo .and. wntvn ) then
                    ! path 2 (m much larger than n, jobu='o', jobvt='n')
                    ! n left singular vectors to be overwritten on a and
                    ! no right singular vectors to be computed
                    if( lwork>=n*n+max( 4*n, bdspac ) ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n+n )+lda*n ) then
                          ! work(iu) is lda by n, work(ir) is lda by n
                          ldwrku = lda
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n+n )+n*n ) then
                          ! work(iu) is lda by n, work(ir) is n by n
                          ldwrku = lda
                          ldwrkr = n
                       else
                          ! work(iu) is ldwrku by n, work(ir) is n by n
                          ldwrku = ( lwork-n*n-n ) / n
                          ldwrkr = n
                       end if
                       itau = ir + ldwrkr*n
                       iwork = itau + n
                       ! compute a=q*r
                       ! (workspace: need n*n+2*n, prefer n*n+n+n*nb)
                       call stdlib_sgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to work(ir) and zero out below it
                       call stdlib_slacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                       call stdlib_slaset( 'L', n-1, n-1, zero, zero, work( ir+1 ),ldwrkr )
                                 
                       ! generate q in a
                       ! (workspace: need n*n+2*n, prefer n*n+n+n*nb)
                       call stdlib_sorgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + n
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in work(ir)
                       ! (workspace: need n*n+4*n, prefer n*n+3*n+2*n*nb)
                       call stdlib_sgebrd( n, n, work( ir ), ldwrkr, s, work( ie ),work( itauq ), &
                                 work( itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing r
                       ! (workspace: need n*n+4*n, prefer n*n+3*n+n*nb)
                       call stdlib_sorgbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       iwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of r in work(ir)
                       ! (workspace: need n*n+bdspac)
                       call stdlib_sbdsqr( 'U', n, 0, n, 0, s, work( ie ), dum, 1,work( ir ), &
                                 ldwrkr, dum, 1,work( iwork ), info )
                       iu = ie + n
                       ! multiply q in a by left singular vectors of r in
                       ! work(ir), storing result in work(iu) and copying to a
                       ! (workspace: need n*n+2*n, prefer n*n+m*n+n)
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_sgemm( 'N', 'N', chunk, n, n, one, a( i, 1 ),lda, work( ir )&
                                    , ldwrkr, zero,work( iu ), ldwrku )
                          call stdlib_slacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       ie = 1
                       itauq = ie + n
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize a
                       ! (workspace: need 3*n+m, prefer 3*n+(m+n)*nb)
                       call stdlib_sgebrd( m, n, a, lda, s, work( ie ),work( itauq ), work( itaup &
                                 ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing a
                       ! (workspace: need 4*n, prefer 3*n+n*nb)
                       call stdlib_sorgbr( 'Q', m, n, n, a, lda, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in a
                       ! (workspace: need bdspac)
                       call stdlib_sbdsqr( 'U', n, 0, m, 0, s, work( ie ), dum, 1,a, lda, dum, 1, &
                                 work( iwork ), info )
                    end if
                 else if( wntuo .and. wntvas ) then
                    ! path 3 (m much larger than n, jobu='o', jobvt='s' or 'a')
                    ! n left singular vectors to be overwritten on a and
                    ! n right singular vectors to be computed in vt
                    if( lwork>=n*n+max( 4*n, bdspac ) ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n+n )+lda*n ) then
                          ! work(iu) is lda by n and work(ir) is lda by n
                          ldwrku = lda
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n+n )+n*n ) then
                          ! work(iu) is lda by n and work(ir) is n by n
                          ldwrku = lda
                          ldwrkr = n
                       else
                          ! work(iu) is ldwrku by n and work(ir) is n by n
                          ldwrku = ( lwork-n*n-n ) / n
                          ldwrkr = n
                       end if
                       itau = ir + ldwrkr*n
                       iwork = itau + n
                       ! compute a=q*r
                       ! (workspace: need n*n+2*n, prefer n*n+n+n*nb)
                       call stdlib_sgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to vt, zeroing out below it
                       call stdlib_slacpy( 'U', n, n, a, lda, vt, ldvt )
                       if( n>1 )call stdlib_slaset( 'L', n-1, n-1, zero, zero,vt( 2, 1 ), ldvt )
                                 
                       ! generate q in a
                       ! (workspace: need n*n+2*n, prefer n*n+n+n*nb)
                       call stdlib_sorgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + n
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in vt, copying result to work(ir)
                       ! (workspace: need n*n+4*n, prefer n*n+3*n+2*n*nb)
                       call stdlib_sgebrd( n, n, vt, ldvt, s, work( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       call stdlib_slacpy( 'L', n, n, vt, ldvt, work( ir ), ldwrkr )
                       ! generate left vectors bidiagonalizing r in work(ir)
                       ! (workspace: need n*n+4*n, prefer n*n+3*n+n*nb)
                       call stdlib_sorgbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing r in vt
                       ! (workspace: need n*n+4*n-1, prefer n*n+3*n+(n-1)*nb)
                       call stdlib_sorgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of r in work(ir) and computing right
                       ! singular vectors of r in vt
                       ! (workspace: need n*n+bdspac)
                       call stdlib_sbdsqr( 'U', n, n, n, 0, s, work( ie ), vt, ldvt,work( ir ), &
                                 ldwrkr, dum, 1,work( iwork ), info )
                       iu = ie + n
                       ! multiply q in a by left singular vectors of r in
                       ! work(ir), storing result in work(iu) and copying to a
                       ! (workspace: need n*n+2*n, prefer n*n+m*n+n)
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_sgemm( 'N', 'N', chunk, n, n, one, a( i, 1 ),lda, work( ir )&
                                    , ldwrkr, zero,work( iu ), ldwrku )
                          call stdlib_slacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       itau = 1
                       iwork = itau + n
                       ! compute a=q*r
                       ! (workspace: need 2*n, prefer n+n*nb)
                       call stdlib_sgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to vt, zeroing out below it
                       call stdlib_slacpy( 'U', n, n, a, lda, vt, ldvt )
                       if( n>1 )call stdlib_slaset( 'L', n-1, n-1, zero, zero,vt( 2, 1 ), ldvt )
                                 
                       ! generate q in a
                       ! (workspace: need 2*n, prefer n+n*nb)
                       call stdlib_sorgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + n
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in vt
                       ! (workspace: need 4*n, prefer 3*n+2*n*nb)
                       call stdlib_sgebrd( n, n, vt, ldvt, s, work( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! multiply q in a by left vectors bidiagonalizing r
                       ! (workspace: need 3*n+m, prefer 3*n+m*nb)
                       call stdlib_sormbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), a, lda,&
                                  work( iwork ),lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing r in vt
                       ! (workspace: need 4*n-1, prefer 3*n+(n-1)*nb)
                       call stdlib_sorgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in a and computing right
                       ! singular vectors of a in vt
                       ! (workspace: need bdspac)
                       call stdlib_sbdsqr( 'U', n, n, m, 0, s, work( ie ), vt, ldvt,a, lda, dum, &
                                 1, work( iwork ), info )
                    end if
                 else if( wntus ) then
                    if( wntvn ) then
                       ! path 4 (m much larger than n, jobu='s', jobvt='n')
                       ! n left singular vectors to be computed in u and
                       ! no right singular vectors to be computed
                       if( lwork>=n*n+max( 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(ir) is lda by n
                             ldwrkr = lda
                          else
                             ! work(ir) is n by n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (workspace: need n*n+2*n, prefer n*n+n+n*nb)
                          call stdlib_sgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(ir), zeroing out below it
                          call stdlib_slacpy( 'U', n, n, a, lda, work( ir ),ldwrkr )
                          call stdlib_slaset( 'L', n-1, n-1, zero, zero,work( ir+1 ), ldwrkr )
                                    
                          ! generate q in a
                          ! (workspace: need n*n+2*n, prefer n*n+n+n*nb)
                          call stdlib_sorgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(ir)
                          ! (workspace: need n*n+4*n, prefer n*n+3*n+2*n*nb)
                          call stdlib_sgebrd( n, n, work( ir ), ldwrkr, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate left vectors bidiagonalizing r in work(ir)
                          ! (workspace: need n*n+4*n, prefer n*n+3*n+n*nb)
                          call stdlib_sorgbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(ir)
                          ! (workspace: need n*n+bdspac)
                          call stdlib_sbdsqr( 'U', n, 0, n, 0, s, work( ie ), dum,1, work( ir ), &
                                    ldwrkr, dum, 1,work( iwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(ir), storing result in u
                          ! (workspace: need n*n)
                          call stdlib_sgemm( 'N', 'N', m, n, n, one, a, lda,work( ir ), ldwrkr, &
                                    zero, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n+n*nb)
                          call stdlib_sgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_slacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need 2*n, prefer n+n*nb)
                          call stdlib_sorgqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_slaset( 'L', n-1, n-1, zero, zero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (workspace: need 4*n, prefer 3*n+2*n*nb)
                          call stdlib_sgebrd( n, n, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left vectors bidiagonalizing r
                          ! (workspace: need 3*n+m, prefer 3*n+m*nb)
                          call stdlib_sormbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u
                          ! (workspace: need bdspac)
                          call stdlib_sbdsqr( 'U', n, 0, m, 0, s, work( ie ), dum,1, u, ldu, dum, &
                                    1, work( iwork ),info )
                       end if
                    else if( wntvo ) then
                       ! path 5 (m much larger than n, jobu='s', jobvt='o')
                       ! n left singular vectors to be computed in u and
                       ! n right singular vectors to be overwritten on a
                       if( lwork>=2*n*n+max( 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*n ) then
                             ! work(iu) is lda by n and work(ir) is lda by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+n )*n ) then
                             ! work(iu) is lda by n and work(ir) is n by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          else
                             ! work(iu) is n by n and work(ir) is n by n
                             ldwrku = n
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (workspace: need 2*n*n+2*n, prefer 2*n*n+n+n*nb)
                          call stdlib_sgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_slacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_slaset( 'L', n-1, n-1, zero, zero,work( iu+1 ), ldwrku )
                                    
                          ! generate q in a
                          ! (workspace: need 2*n*n+2*n, prefer 2*n*n+n+n*nb)
                          call stdlib_sorgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to
                          ! work(ir)
                          ! (workspace: need 2*n*n+4*n,
                                      ! prefer 2*n*n+3*n+2*n*nb)
                          call stdlib_sgebrd( n, n, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_slacpy( 'U', n, n, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (workspace: need 2*n*n+4*n, prefer 2*n*n+3*n+n*nb)
                          call stdlib_sorgbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (workspace: need 2*n*n+4*n-1,
                                      ! prefer 2*n*n+3*n+(n-1)*nb)
                          call stdlib_sorgbr( 'P', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in work(ir)
                          ! (workspace: need 2*n*n+bdspac)
                          call stdlib_sbdsqr( 'U', n, n, n, 0, s, work( ie ),work( ir ), ldwrkr, &
                                    work( iu ),ldwrku, dum, 1, work( iwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(iu), storing result in u
                          ! (workspace: need n*n)
                          call stdlib_sgemm( 'N', 'N', m, n, n, one, a, lda,work( iu ), ldwrku, &
                                    zero, u, ldu )
                          ! copy right singular vectors of r to a
                          ! (workspace: need n*n)
                          call stdlib_slacpy( 'F', n, n, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n+n*nb)
                          call stdlib_sgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_slacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need 2*n, prefer n+n*nb)
                          call stdlib_sorgqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_slaset( 'L', n-1, n-1, zero, zero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (workspace: need 4*n, prefer 3*n+2*n*nb)
                          call stdlib_sgebrd( n, n, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left vectors bidiagonalizing r
                          ! (workspace: need 3*n+m, prefer 3*n+m*nb)
                          call stdlib_sormbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right vectors bidiagonalizing r in a
                          ! (workspace: need 4*n-1, prefer 3*n+(n-1)*nb)
                          call stdlib_sorgbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in a
                          ! (workspace: need bdspac)
                          call stdlib_sbdsqr( 'U', n, n, m, 0, s, work( ie ), a,lda, u, ldu, dum, &
                                    1, work( iwork ),info )
                       end if
                    else if( wntvas ) then
                       ! path 6 (m much larger than n, jobu='s', jobvt='s'
                               ! or 'a')
                       ! n left singular vectors to be computed in u and
                       ! n right singular vectors to be computed in vt
                       if( lwork>=n*n+max( 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is n by n
                             ldwrku = n
                          end if
                          itau = iu + ldwrku*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (workspace: need n*n+2*n, prefer n*n+n+n*nb)
                          call stdlib_sgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_slacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_slaset( 'L', n-1, n-1, zero, zero,work( iu+1 ), ldwrku )
                                    
                          ! generate q in a
                          ! (workspace: need n*n+2*n, prefer n*n+n+n*nb)
                          call stdlib_sorgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to vt
                          ! (workspace: need n*n+4*n, prefer n*n+3*n+2*n*nb)
                          call stdlib_sgebrd( n, n, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_slacpy( 'U', n, n, work( iu ), ldwrku, vt,ldvt )
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (workspace: need n*n+4*n, prefer n*n+3*n+n*nb)
                          call stdlib_sorgbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (workspace: need n*n+4*n-1,
                                      ! prefer n*n+3*n+(n-1)*nb)
                          call stdlib_sorgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in vt
                          ! (workspace: need n*n+bdspac)
                          call stdlib_sbdsqr( 'U', n, n, n, 0, s, work( ie ), vt,ldvt, work( iu ),&
                                     ldwrku, dum, 1,work( iwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(iu), storing result in u
                          ! (workspace: need n*n)
                          call stdlib_sgemm( 'N', 'N', m, n, n, one, a, lda,work( iu ), ldwrku, &
                                    zero, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n+n*nb)
                          call stdlib_sgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_slacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need 2*n, prefer n+n*nb)
                          call stdlib_sorgqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to vt, zeroing out below it
                          call stdlib_slacpy( 'U', n, n, a, lda, vt, ldvt )
                          if( n>1 )call stdlib_slaset( 'L', n-1, n-1, zero, zero,vt( 2, 1 ), ldvt &
                                    )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in vt
                          ! (workspace: need 4*n, prefer 3*n+2*n*nb)
                          call stdlib_sgebrd( n, n, vt, ldvt, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in vt
                          ! (workspace: need 3*n+m, prefer 3*n+m*nb)
                          call stdlib_sormbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (workspace: need 4*n-1, prefer 3*n+(n-1)*nb)
                          call stdlib_sorgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_sbdsqr( 'U', n, n, m, 0, s, work( ie ), vt,ldvt, u, ldu, &
                                    dum, 1, work( iwork ),info )
                       end if
                    end if
                 else if( wntua ) then
                    if( wntvn ) then
                       ! path 7 (m much larger than n, jobu='a', jobvt='n')
                       ! m left singular vectors to be computed in u and
                       ! no right singular vectors to be computed
                       if( lwork>=n*n+max( n+m, 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(ir) is lda by n
                             ldwrkr = lda
                          else
                             ! work(ir) is n by n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need n*n+2*n, prefer n*n+n+n*nb)
                          call stdlib_sgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_slacpy( 'L', m, n, a, lda, u, ldu )
                          ! copy r to work(ir), zeroing out below it
                          call stdlib_slacpy( 'U', n, n, a, lda, work( ir ),ldwrkr )
                          call stdlib_slaset( 'L', n-1, n-1, zero, zero,work( ir+1 ), ldwrkr )
                                    
                          ! generate q in u
                          ! (workspace: need n*n+n+m, prefer n*n+n+m*nb)
                          call stdlib_sorgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(ir)
                          ! (workspace: need n*n+4*n, prefer n*n+3*n+2*n*nb)
                          call stdlib_sgebrd( n, n, work( ir ), ldwrkr, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (workspace: need n*n+4*n, prefer n*n+3*n+n*nb)
                          call stdlib_sorgbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(ir)
                          ! (workspace: need n*n+bdspac)
                          call stdlib_sbdsqr( 'U', n, 0, n, 0, s, work( ie ), dum,1, work( ir ), &
                                    ldwrkr, dum, 1,work( iwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(ir), storing result in a
                          ! (workspace: need n*n)
                          call stdlib_sgemm( 'N', 'N', m, n, n, one, u, ldu,work( ir ), ldwrkr, &
                                    zero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_slacpy( 'F', m, n, a, lda, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n+n*nb)
                          call stdlib_sgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_slacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need n+m, prefer n+m*nb)
                          call stdlib_sorgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_slaset( 'L', n-1, n-1, zero, zero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (workspace: need 4*n, prefer 3*n+2*n*nb)
                          call stdlib_sgebrd( n, n, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in a
                          ! (workspace: need 3*n+m, prefer 3*n+m*nb)
                          call stdlib_sormbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u
                          ! (workspace: need bdspac)
                          call stdlib_sbdsqr( 'U', n, 0, m, 0, s, work( ie ), dum,1, u, ldu, dum, &
                                    1, work( iwork ),info )
                       end if
                    else if( wntvo ) then
                       ! path 8 (m much larger than n, jobu='a', jobvt='o')
                       ! m left singular vectors to be computed in u and
                       ! n right singular vectors to be overwritten on a
                       if( lwork>=2*n*n+max( n+m, 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*n ) then
                             ! work(iu) is lda by n and work(ir) is lda by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+n )*n ) then
                             ! work(iu) is lda by n and work(ir) is n by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          else
                             ! work(iu) is n by n and work(ir) is n by n
                             ldwrku = n
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n*n+2*n, prefer 2*n*n+n+n*nb)
                          call stdlib_sgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_slacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need 2*n*n+n+m, prefer 2*n*n+n+m*nb)
                          call stdlib_sorgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_slacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_slaset( 'L', n-1, n-1, zero, zero,work( iu+1 ), ldwrku )
                                    
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to
                          ! work(ir)
                          ! (workspace: need 2*n*n+4*n,
                                      ! prefer 2*n*n+3*n+2*n*nb)
                          call stdlib_sgebrd( n, n, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_slacpy( 'U', n, n, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (workspace: need 2*n*n+4*n, prefer 2*n*n+3*n+n*nb)
                          call stdlib_sorgbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (workspace: need 2*n*n+4*n-1,
                                      ! prefer 2*n*n+3*n+(n-1)*nb)
                          call stdlib_sorgbr( 'P', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in work(ir)
                          ! (workspace: need 2*n*n+bdspac)
                          call stdlib_sbdsqr( 'U', n, n, n, 0, s, work( ie ),work( ir ), ldwrkr, &
                                    work( iu ),ldwrku, dum, 1, work( iwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(iu), storing result in a
                          ! (workspace: need n*n)
                          call stdlib_sgemm( 'N', 'N', m, n, n, one, u, ldu,work( iu ), ldwrku, &
                                    zero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_slacpy( 'F', m, n, a, lda, u, ldu )
                          ! copy right singular vectors of r from work(ir) to a
                          call stdlib_slacpy( 'F', n, n, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n+n*nb)
                          call stdlib_sgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_slacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need n+m, prefer n+m*nb)
                          call stdlib_sorgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_slaset( 'L', n-1, n-1, zero, zero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (workspace: need 4*n, prefer 3*n+2*n*nb)
                          call stdlib_sgebrd( n, n, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in a
                          ! (workspace: need 3*n+m, prefer 3*n+m*nb)
                          call stdlib_sormbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in a
                          ! (workspace: need 4*n-1, prefer 3*n+(n-1)*nb)
                          call stdlib_sorgbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in a
                          ! (workspace: need bdspac)
                          call stdlib_sbdsqr( 'U', n, n, m, 0, s, work( ie ), a,lda, u, ldu, dum, &
                                    1, work( iwork ),info )
                       end if
                    else if( wntvas ) then
                       ! path 9 (m much larger than n, jobu='a', jobvt='s'
                               ! or 'a')
                       ! m left singular vectors to be computed in u and
                       ! n right singular vectors to be computed in vt
                       if( lwork>=n*n+max( n+m, 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is n by n
                             ldwrku = n
                          end if
                          itau = iu + ldwrku*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need n*n+2*n, prefer n*n+n+n*nb)
                          call stdlib_sgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_slacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need n*n+n+m, prefer n*n+n+m*nb)
                          call stdlib_sorgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_slacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_slaset( 'L', n-1, n-1, zero, zero,work( iu+1 ), ldwrku )
                                    
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to vt
                          ! (workspace: need n*n+4*n, prefer n*n+3*n+2*n*nb)
                          call stdlib_sgebrd( n, n, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_slacpy( 'U', n, n, work( iu ), ldwrku, vt,ldvt )
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (workspace: need n*n+4*n, prefer n*n+3*n+n*nb)
                          call stdlib_sorgbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (workspace: need n*n+4*n-1,
                                      ! prefer n*n+3*n+(n-1)*nb)
                          call stdlib_sorgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in vt
                          ! (workspace: need n*n+bdspac)
                          call stdlib_sbdsqr( 'U', n, n, n, 0, s, work( ie ), vt,ldvt, work( iu ),&
                                     ldwrku, dum, 1,work( iwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(iu), storing result in a
                          ! (workspace: need n*n)
                          call stdlib_sgemm( 'N', 'N', m, n, n, one, u, ldu,work( iu ), ldwrku, &
                                    zero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_slacpy( 'F', m, n, a, lda, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n+n*nb)
                          call stdlib_sgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_slacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need n+m, prefer n+m*nb)
                          call stdlib_sorgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r from a to vt, zeroing out below it
                          call stdlib_slacpy( 'U', n, n, a, lda, vt, ldvt )
                          if( n>1 )call stdlib_slaset( 'L', n-1, n-1, zero, zero,vt( 2, 1 ), ldvt &
                                    )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in vt
                          ! (workspace: need 4*n, prefer 3*n+2*n*nb)
                          call stdlib_sgebrd( n, n, vt, ldvt, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in vt
                          ! (workspace: need 3*n+m, prefer 3*n+m*nb)
                          call stdlib_sormbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (workspace: need 4*n-1, prefer 3*n+(n-1)*nb)
                          call stdlib_sorgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_sbdsqr( 'U', n, n, m, 0, s, work( ie ), vt,ldvt, u, ldu, &
                                    dum, 1, work( iwork ),info )
                       end if
                    end if
                 end if
              else
                 ! m < mnthr
                 ! path 10 (m at least n, but not much larger)
                 ! reduce to bidiagonal form without qr decomposition
                 ie = 1
                 itauq = ie + n
                 itaup = itauq + n
                 iwork = itaup + n
                 ! bidiagonalize a
                 ! (workspace: need 3*n+m, prefer 3*n+(m+n)*nb)
                 call stdlib_sgebrd( m, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                           work( iwork ), lwork-iwork+1,ierr )
                 if( wntuas ) then
                    ! if left singular vectors desired in u, copy result to u
                    ! and generate left bidiagonalizing vectors in u
                    ! (workspace: need 3*n+ncu, prefer 3*n+ncu*nb)
                    call stdlib_slacpy( 'L', m, n, a, lda, u, ldu )
                    if( wntus )ncu = n
                    if( wntua )ncu = m
                    call stdlib_sorgbr( 'Q', m, ncu, n, u, ldu, work( itauq ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntvas ) then
                    ! if right singular vectors desired in vt, copy result to
                    ! vt and generate right bidiagonalizing vectors in vt
                    ! (workspace: need 4*n-1, prefer 3*n+(n-1)*nb)
                    call stdlib_slacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_sorgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntuo ) then
                    ! if left singular vectors desired in a, generate left
                    ! bidiagonalizing vectors in a
                    ! (workspace: need 4*n, prefer 3*n+n*nb)
                    call stdlib_sorgbr( 'Q', m, n, n, a, lda, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvo ) then
                    ! if right singular vectors desired in a, generate right
                    ! bidiagonalizing vectors in a
                    ! (workspace: need 4*n-1, prefer 3*n+(n-1)*nb)
                    call stdlib_sorgbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 iwork = ie + n
                 if( wntuas .or. wntuo )nru = m
                 if( wntun )nru = 0
                 if( wntvas .or. wntvo )ncvt = n
                 if( wntvn )ncvt = 0
                 if( ( .not.wntuo ) .and. ( .not.wntvo ) ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in vt
                    ! (workspace: need bdspac)
                    call stdlib_sbdsqr( 'U', n, ncvt, nru, 0, s, work( ie ), vt,ldvt, u, ldu, dum,&
                               1, work( iwork ), info )
                 else if( ( .not.wntuo ) .and. wntvo ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in a
                    ! (workspace: need bdspac)
                    call stdlib_sbdsqr( 'U', n, ncvt, nru, 0, s, work( ie ), a, lda,u, ldu, dum, &
                              1, work( iwork ), info )
                 else
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in a and computing right singular
                    ! vectors in vt
                    ! (workspace: need bdspac)
                    call stdlib_sbdsqr( 'U', n, ncvt, nru, 0, s, work( ie ), vt,ldvt, a, lda, dum,&
                               1, work( iwork ), info )
                 end if
              end if
           else
              ! a has more columns than rows. if a has sufficiently more
              ! columns than rows, first reduce using the lq decomposition (if
              ! sufficient workspace available)
              if( n>=mnthr ) then
                 if( wntvn ) then
                    ! path 1t(n much larger than m, jobvt='n')
                    ! no right singular vectors to be computed
                    itau = 1
                    iwork = itau + m
                    ! compute a=l*q
                    ! (workspace: need 2*m, prefer m+m*nb)
                    call stdlib_sgelqf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, &
                              ierr )
                    ! zero out above l
                    if (m>1) call stdlib_slaset( 'U', m-1, m-1, zero, zero, a( 1, 2 ), lda )
                    ie = 1
                    itauq = ie + m
                    itaup = itauq + m
                    iwork = itaup + m
                    ! bidiagonalize l in a
                    ! (workspace: need 4*m, prefer 3*m+2*m*nb)
                    call stdlib_sgebrd( m, m, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( iwork ), lwork-iwork+1,ierr )
                    if( wntuo .or. wntuas ) then
                       ! if left singular vectors desired, generate q
                       ! (workspace: need 4*m, prefer 3*m+m*nb)
                       call stdlib_sorgbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                    end if
                    iwork = ie + m
                    nru = 0
                    if( wntuo .or. wntuas )nru = m
                    ! perform bidiagonal qr iteration, computing left singular
                    ! vectors of a in a if desired
                    ! (workspace: need bdspac)
                    call stdlib_sbdsqr( 'U', m, 0, nru, 0, s, work( ie ), dum, 1, a,lda, dum, 1, &
                              work( iwork ), info )
                    ! if left singular vectors desired in u, copy them there
                    if( wntuas )call stdlib_slacpy( 'F', m, m, a, lda, u, ldu )
                 else if( wntvo .and. wntun ) then
                    ! path 2t(n much larger than m, jobu='n', jobvt='o')
                    ! m right singular vectors to be overwritten on a and
                    ! no left singular vectors to be computed
                    if( lwork>=m*m+max( 4*m, bdspac ) ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n+m )+lda*m ) then
                          ! work(iu) is lda by n and work(ir) is lda by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n+m )+m*m ) then
                          ! work(iu) is lda by n and work(ir) is m by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = m
                       else
                          ! work(iu) is m by chunk and work(ir) is m by m
                          ldwrku = m
                          chunk = ( lwork-m*m-m ) / m
                          ldwrkr = m
                       end if
                       itau = ir + ldwrkr*m
                       iwork = itau + m
                       ! compute a=l*q
                       ! (workspace: need m*m+2*m, prefer m*m+m+m*nb)
                       call stdlib_sgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to work(ir) and zero out above it
                       call stdlib_slacpy( 'L', m, m, a, lda, work( ir ), ldwrkr )
                       call stdlib_slaset( 'U', m-1, m-1, zero, zero,work( ir+ldwrkr ), ldwrkr )
                                 
                       ! generate q in a
                       ! (workspace: need m*m+2*m, prefer m*m+m+m*nb)
                       call stdlib_sorglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + m
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in work(ir)
                       ! (workspace: need m*m+4*m, prefer m*m+3*m+2*m*nb)
                       call stdlib_sgebrd( m, m, work( ir ), ldwrkr, s, work( ie ),work( itauq ), &
                                 work( itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing l
                       ! (workspace: need m*m+4*m-1, prefer m*m+3*m+(m-1)*nb)
                       call stdlib_sorgbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       iwork = ie + m
                       ! perform bidiagonal qr iteration, computing right
                       ! singular vectors of l in work(ir)
                       ! (workspace: need m*m+bdspac)
                       call stdlib_sbdsqr( 'U', m, m, 0, 0, s, work( ie ),work( ir ), ldwrkr, dum,&
                                  1, dum, 1,work( iwork ), info )
                       iu = ie + m
                       ! multiply right singular vectors of l in work(ir) by q
                       ! in a, storing result in work(iu) and copying to a
                       ! (workspace: need m*m+2*m, prefer m*m+m*n+m)
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_sgemm( 'N', 'N', m, blk, m, one, work( ir ),ldwrkr, a( 1, i &
                                    ), lda, zero,work( iu ), ldwrku )
                          call stdlib_slacpy( 'F', m, blk, work( iu ), ldwrku,a( 1, i ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       ie = 1
                       itauq = ie + m
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize a
                       ! (workspace: need 3*m+n, prefer 3*m+(m+n)*nb)
                       call stdlib_sgebrd( m, n, a, lda, s, work( ie ),work( itauq ), work( itaup &
                                 ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing a
                       ! (workspace: need 4*m, prefer 3*m+m*nb)
                       call stdlib_sorgbr( 'P', m, n, m, a, lda, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + m
                       ! perform bidiagonal qr iteration, computing right
                       ! singular vectors of a in a
                       ! (workspace: need bdspac)
                       call stdlib_sbdsqr( 'L', m, n, 0, 0, s, work( ie ), a, lda,dum, 1, dum, 1, &
                                 work( iwork ), info )
                    end if
                 else if( wntvo .and. wntuas ) then
                    ! path 3t(n much larger than m, jobu='s' or 'a', jobvt='o')
                    ! m right singular vectors to be overwritten on a and
                    ! m left singular vectors to be computed in u
                    if( lwork>=m*m+max( 4*m, bdspac ) ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n+m )+lda*m ) then
                          ! work(iu) is lda by n and work(ir) is lda by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n+m )+m*m ) then
                          ! work(iu) is lda by n and work(ir) is m by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = m
                       else
                          ! work(iu) is m by chunk and work(ir) is m by m
                          ldwrku = m
                          chunk = ( lwork-m*m-m ) / m
                          ldwrkr = m
                       end if
                       itau = ir + ldwrkr*m
                       iwork = itau + m
                       ! compute a=l*q
                       ! (workspace: need m*m+2*m, prefer m*m+m+m*nb)
                       call stdlib_sgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to u, zeroing about above it
                       call stdlib_slacpy( 'L', m, m, a, lda, u, ldu )
                       if (m>1) call stdlib_slaset( 'U', m-1, m-1, zero, zero, u( 1, 2 ),ldu )
                       ! generate q in a
                       ! (workspace: need m*m+2*m, prefer m*m+m+m*nb)
                       call stdlib_sorglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + m
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in u, copying result to work(ir)
                       ! (workspace: need m*m+4*m, prefer m*m+3*m+2*m*nb)
                       call stdlib_sgebrd( m, m, u, ldu, s, work( ie ),work( itauq ), work( itaup &
                                 ),work( iwork ), lwork-iwork+1, ierr )
                       call stdlib_slacpy( 'U', m, m, u, ldu, work( ir ), ldwrkr )
                       ! generate right vectors bidiagonalizing l in work(ir)
                       ! (workspace: need m*m+4*m-1, prefer m*m+3*m+(m-1)*nb)
                       call stdlib_sorgbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing l in u
                       ! (workspace: need m*m+4*m, prefer m*m+3*m+m*nb)
                       call stdlib_sorgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + m
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of l in u, and computing right
                       ! singular vectors of l in work(ir)
                       ! (workspace: need m*m+bdspac)
                       call stdlib_sbdsqr( 'U', m, m, m, 0, s, work( ie ),work( ir ), ldwrkr, u, &
                                 ldu, dum, 1,work( iwork ), info )
                       iu = ie + m
                       ! multiply right singular vectors of l in work(ir) by q
                       ! in a, storing result in work(iu) and copying to a
                       ! (workspace: need m*m+2*m, prefer m*m+m*n+m))
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_sgemm( 'N', 'N', m, blk, m, one, work( ir ),ldwrkr, a( 1, i &
                                    ), lda, zero,work( iu ), ldwrku )
                          call stdlib_slacpy( 'F', m, blk, work( iu ), ldwrku,a( 1, i ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       itau = 1
                       iwork = itau + m
                       ! compute a=l*q
                       ! (workspace: need 2*m, prefer m+m*nb)
                       call stdlib_sgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to u, zeroing out above it
                       call stdlib_slacpy( 'L', m, m, a, lda, u, ldu )
                       if (m>1) call stdlib_slaset( 'U', m-1, m-1, zero, zero, u( 1, 2 ),ldu )
                       ! generate q in a
                       ! (workspace: need 2*m, prefer m+m*nb)
                       call stdlib_sorglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + m
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in u
                       ! (workspace: need 4*m, prefer 3*m+2*m*nb)
                       call stdlib_sgebrd( m, m, u, ldu, s, work( ie ),work( itauq ), work( itaup &
                                 ),work( iwork ), lwork-iwork+1, ierr )
                       ! multiply right vectors bidiagonalizing l by q in a
                       ! (workspace: need 3*m+n, prefer 3*m+n*nb)
                       call stdlib_sormbr( 'P', 'L', 'T', m, n, m, u, ldu,work( itaup ), a, lda, &
                                 work( iwork ),lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing l in u
                       ! (workspace: need 4*m, prefer 3*m+m*nb)
                       call stdlib_sorgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + m
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in u and computing right
                       ! singular vectors of a in a
                       ! (workspace: need bdspac)
                       call stdlib_sbdsqr( 'U', m, n, m, 0, s, work( ie ), a, lda,u, ldu, dum, 1, &
                                 work( iwork ), info )
                    end if
                 else if( wntvs ) then
                    if( wntun ) then
                       ! path 4t(n much larger than m, jobu='n', jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! no left singular vectors to be computed
                       if( lwork>=m*m+max( 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(ir) is lda by m
                             ldwrkr = lda
                          else
                             ! work(ir) is m by m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (workspace: need m*m+2*m, prefer m*m+m+m*nb)
                          call stdlib_sgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(ir), zeroing out above it
                          call stdlib_slacpy( 'L', m, m, a, lda, work( ir ),ldwrkr )
                          call stdlib_slaset( 'U', m-1, m-1, zero, zero,work( ir+ldwrkr ), ldwrkr &
                                    )
                          ! generate q in a
                          ! (workspace: need m*m+2*m, prefer m*m+m+m*nb)
                          call stdlib_sorglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(ir)
                          ! (workspace: need m*m+4*m, prefer m*m+3*m+2*m*nb)
                          call stdlib_sgebrd( m, m, work( ir ), ldwrkr, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate right vectors bidiagonalizing l in
                          ! work(ir)
                          ! (workspace: need m*m+4*m, prefer m*m+3*m+(m-1)*nb)
                          call stdlib_sorgbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of l in work(ir)
                          ! (workspace: need m*m+bdspac)
                          call stdlib_sbdsqr( 'U', m, m, 0, 0, s, work( ie ),work( ir ), ldwrkr, &
                                    dum, 1, dum, 1,work( iwork ), info )
                          ! multiply right singular vectors of l in work(ir) by
                          ! q in a, storing result in vt
                          ! (workspace: need m*m)
                          call stdlib_sgemm( 'N', 'N', m, n, m, one, work( ir ),ldwrkr, a, lda, &
                                    zero, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q
                          ! (workspace: need 2*m, prefer m+m*nb)
                          call stdlib_sgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy result to vt
                          call stdlib_slacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need 2*m, prefer m+m*nb)
                          call stdlib_sorglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_slaset( 'U', m-1, m-1, zero, zero, a( 1, 2 ),lda )
                          ! bidiagonalize l in a
                          ! (workspace: need 4*m, prefer 3*m+2*m*nb)
                          call stdlib_sgebrd( m, m, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right vectors bidiagonalizing l by q in vt
                          ! (workspace: need 3*m+n, prefer 3*m+n*nb)
                          call stdlib_sormbr( 'P', 'L', 'T', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_sbdsqr( 'U', m, n, 0, 0, s, work( ie ), vt,ldvt, dum, 1, &
                                    dum, 1, work( iwork ),info )
                       end if
                    else if( wntuo ) then
                       ! path 5t(n much larger than m, jobu='o', jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! m left singular vectors to be overwritten on a
                       if( lwork>=2*m*m+max( 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*m ) then
                             ! work(iu) is lda by m and work(ir) is lda by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+m )*m ) then
                             ! work(iu) is lda by m and work(ir) is m by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          else
                             ! work(iu) is m by m and work(ir) is m by m
                             ldwrku = m
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (workspace: need 2*m*m+2*m, prefer 2*m*m+m+m*nb)
                          call stdlib_sgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(iu), zeroing out below it
                          call stdlib_slacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_slaset( 'U', m-1, m-1, zero, zero,work( iu+ldwrku ), ldwrku &
                                    )
                          ! generate q in a
                          ! (workspace: need 2*m*m+2*m, prefer 2*m*m+m+m*nb)
                          call stdlib_sorglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to
                          ! work(ir)
                          ! (workspace: need 2*m*m+4*m,
                                      ! prefer 2*m*m+3*m+2*m*nb)
                          call stdlib_sgebrd( m, m, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_slacpy( 'L', m, m, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (workspace: need 2*m*m+4*m-1,
                                      ! prefer 2*m*m+3*m+(m-1)*nb)
                          call stdlib_sorgbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (workspace: need 2*m*m+4*m, prefer 2*m*m+3*m+m*nb)
                          call stdlib_sorgbr( 'Q', m, m, m, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in work(ir) and computing
                          ! right singular vectors of l in work(iu)
                          ! (workspace: need 2*m*m+bdspac)
                          call stdlib_sbdsqr( 'U', m, m, m, 0, s, work( ie ),work( iu ), ldwrku, &
                                    work( ir ),ldwrkr, dum, 1, work( iwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in a, storing result in vt
                          ! (workspace: need m*m)
                          call stdlib_sgemm( 'N', 'N', m, n, m, one, work( iu ),ldwrku, a, lda, &
                                    zero, vt, ldvt )
                          ! copy left singular vectors of l to a
                          ! (workspace: need m*m)
                          call stdlib_slacpy( 'F', m, m, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m+m*nb)
                          call stdlib_sgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_slacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need 2*m, prefer m+m*nb)
                          call stdlib_sorglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_slaset( 'U', m-1, m-1, zero, zero, a( 1, 2 ),lda )
                          ! bidiagonalize l in a
                          ! (workspace: need 4*m, prefer 3*m+2*m*nb)
                          call stdlib_sgebrd( m, m, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right vectors bidiagonalizing l by q in vt
                          ! (workspace: need 3*m+n, prefer 3*m+n*nb)
                          call stdlib_sormbr( 'P', 'L', 'T', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors of l in a
                          ! (workspace: need 4*m, prefer 3*m+m*nb)
                          call stdlib_sorgbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, compute left
                          ! singular vectors of a in a and compute right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_sbdsqr( 'U', m, n, m, 0, s, work( ie ), vt,ldvt, a, lda, &
                                    dum, 1, work( iwork ),info )
                       end if
                    else if( wntuas ) then
                       ! path 6t(n much larger than m, jobu='s' or 'a',
                               ! jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! m left singular vectors to be computed in u
                       if( lwork>=m*m+max( 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is lda by m
                             ldwrku = m
                          end if
                          itau = iu + ldwrku*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (workspace: need m*m+2*m, prefer m*m+m+m*nb)
                          call stdlib_sgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_slacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_slaset( 'U', m-1, m-1, zero, zero,work( iu+ldwrku ), ldwrku &
                                    )
                          ! generate q in a
                          ! (workspace: need m*m+2*m, prefer m*m+m+m*nb)
                          call stdlib_sorglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to u
                          ! (workspace: need m*m+4*m, prefer m*m+3*m+2*m*nb)
                          call stdlib_sgebrd( m, m, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_slacpy( 'L', m, m, work( iu ), ldwrku, u,ldu )
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (workspace: need m*m+4*m-1,
                                      ! prefer m*m+3*m+(m-1)*nb)
                          call stdlib_sorgbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (workspace: need m*m+4*m, prefer m*m+3*m+m*nb)
                          call stdlib_sorgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in u and computing right
                          ! singular vectors of l in work(iu)
                          ! (workspace: need m*m+bdspac)
                          call stdlib_sbdsqr( 'U', m, m, m, 0, s, work( ie ),work( iu ), ldwrku, &
                                    u, ldu, dum, 1,work( iwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in a, storing result in vt
                          ! (workspace: need m*m)
                          call stdlib_sgemm( 'N', 'N', m, n, m, one, work( iu ),ldwrku, a, lda, &
                                    zero, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m+m*nb)
                          call stdlib_sgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_slacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need 2*m, prefer m+m*nb)
                          call stdlib_sorglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to u, zeroing out above it
                          call stdlib_slacpy( 'L', m, m, a, lda, u, ldu )
                          if (m>1) call stdlib_slaset( 'U', m-1, m-1, zero, zero, u( 1, 2 ),ldu )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in u
                          ! (workspace: need 4*m, prefer 3*m+2*m*nb)
                          call stdlib_sgebrd( m, m, u, ldu, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in u by q
                          ! in vt
                          ! (workspace: need 3*m+n, prefer 3*m+n*nb)
                          call stdlib_sormbr( 'P', 'L', 'T', m, n, m, u, ldu,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (workspace: need 4*m, prefer 3*m+m*nb)
                          call stdlib_sorgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_sbdsqr( 'U', m, n, m, 0, s, work( ie ), vt,ldvt, u, ldu, &
                                    dum, 1, work( iwork ),info )
                       end if
                    end if
                 else if( wntva ) then
                    if( wntun ) then
                       ! path 7t(n much larger than m, jobu='n', jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! no left singular vectors to be computed
                       if( lwork>=m*m+max( n+m, 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(ir) is lda by m
                             ldwrkr = lda
                          else
                             ! work(ir) is m by m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need m*m+2*m, prefer m*m+m+m*nb)
                          call stdlib_sgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_slacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! copy l to work(ir), zeroing out above it
                          call stdlib_slacpy( 'L', m, m, a, lda, work( ir ),ldwrkr )
                          call stdlib_slaset( 'U', m-1, m-1, zero, zero,work( ir+ldwrkr ), ldwrkr &
                                    )
                          ! generate q in vt
                          ! (workspace: need m*m+m+n, prefer m*m+m+n*nb)
                          call stdlib_sorglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(ir)
                          ! (workspace: need m*m+4*m, prefer m*m+3*m+2*m*nb)
                          call stdlib_sgebrd( m, m, work( ir ), ldwrkr, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (workspace: need m*m+4*m-1,
                                      ! prefer m*m+3*m+(m-1)*nb)
                          call stdlib_sorgbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of l in work(ir)
                          ! (workspace: need m*m+bdspac)
                          call stdlib_sbdsqr( 'U', m, m, 0, 0, s, work( ie ),work( ir ), ldwrkr, &
                                    dum, 1, dum, 1,work( iwork ), info )
                          ! multiply right singular vectors of l in work(ir) by
                          ! q in vt, storing result in a
                          ! (workspace: need m*m)
                          call stdlib_sgemm( 'N', 'N', m, n, m, one, work( ir ),ldwrkr, vt, ldvt, &
                                    zero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_slacpy( 'F', m, n, a, lda, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m+m*nb)
                          call stdlib_sgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_slacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need m+n, prefer m+n*nb)
                          call stdlib_sorglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_slaset( 'U', m-1, m-1, zero, zero, a( 1, 2 ),lda )
                          ! bidiagonalize l in a
                          ! (workspace: need 4*m, prefer 3*m+2*m*nb)
                          call stdlib_sgebrd( m, m, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in a by q
                          ! in vt
                          ! (workspace: need 3*m+n, prefer 3*m+n*nb)
                          call stdlib_sormbr( 'P', 'L', 'T', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_sbdsqr( 'U', m, n, 0, 0, s, work( ie ), vt,ldvt, dum, 1, &
                                    dum, 1, work( iwork ),info )
                       end if
                    else if( wntuo ) then
                       ! path 8t(n much larger than m, jobu='o', jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! m left singular vectors to be overwritten on a
                       if( lwork>=2*m*m+max( n+m, 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*m ) then
                             ! work(iu) is lda by m and work(ir) is lda by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+m )*m ) then
                             ! work(iu) is lda by m and work(ir) is m by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          else
                             ! work(iu) is m by m and work(ir) is m by m
                             ldwrku = m
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m*m+2*m, prefer 2*m*m+m+m*nb)
                          call stdlib_sgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_slacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need 2*m*m+m+n, prefer 2*m*m+m+n*nb)
                          call stdlib_sorglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_slacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_slaset( 'U', m-1, m-1, zero, zero,work( iu+ldwrku ), ldwrku &
                                    )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to
                          ! work(ir)
                          ! (workspace: need 2*m*m+4*m,
                                      ! prefer 2*m*m+3*m+2*m*nb)
                          call stdlib_sgebrd( m, m, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_slacpy( 'L', m, m, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (workspace: need 2*m*m+4*m-1,
                                      ! prefer 2*m*m+3*m+(m-1)*nb)
                          call stdlib_sorgbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (workspace: need 2*m*m+4*m, prefer 2*m*m+3*m+m*nb)
                          call stdlib_sorgbr( 'Q', m, m, m, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in work(ir) and computing
                          ! right singular vectors of l in work(iu)
                          ! (workspace: need 2*m*m+bdspac)
                          call stdlib_sbdsqr( 'U', m, m, m, 0, s, work( ie ),work( iu ), ldwrku, &
                                    work( ir ),ldwrkr, dum, 1, work( iwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in vt, storing result in a
                          ! (workspace: need m*m)
                          call stdlib_sgemm( 'N', 'N', m, n, m, one, work( iu ),ldwrku, vt, ldvt, &
                                    zero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_slacpy( 'F', m, n, a, lda, vt, ldvt )
                          ! copy left singular vectors of a from work(ir) to a
                          call stdlib_slacpy( 'F', m, m, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m+m*nb)
                          call stdlib_sgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_slacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need m+n, prefer m+n*nb)
                          call stdlib_sorglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_slaset( 'U', m-1, m-1, zero, zero, a( 1, 2 ),lda )
                          ! bidiagonalize l in a
                          ! (workspace: need 4*m, prefer 3*m+2*m*nb)
                          call stdlib_sgebrd( m, m, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in a by q
                          ! in vt
                          ! (workspace: need 3*m+n, prefer 3*m+n*nb)
                          call stdlib_sormbr( 'P', 'L', 'T', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in a
                          ! (workspace: need 4*m, prefer 3*m+m*nb)
                          call stdlib_sorgbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in a and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_sbdsqr( 'U', m, n, m, 0, s, work( ie ), vt,ldvt, a, lda, &
                                    dum, 1, work( iwork ),info )
                       end if
                    else if( wntuas ) then
                       ! path 9t(n much larger than m, jobu='s' or 'a',
                               ! jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! m left singular vectors to be computed in u
                       if( lwork>=m*m+max( n+m, 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(iu) is lda by m
                             ldwrku = lda
                          else
                             ! work(iu) is m by m
                             ldwrku = m
                          end if
                          itau = iu + ldwrku*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need m*m+2*m, prefer m*m+m+m*nb)
                          call stdlib_sgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_slacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need m*m+m+n, prefer m*m+m+n*nb)
                          call stdlib_sorglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_slacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_slaset( 'U', m-1, m-1, zero, zero,work( iu+ldwrku ), ldwrku &
                                    )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to u
                          ! (workspace: need m*m+4*m, prefer m*m+3*m+2*m*nb)
                          call stdlib_sgebrd( m, m, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_slacpy( 'L', m, m, work( iu ), ldwrku, u,ldu )
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (workspace: need m*m+4*m, prefer m*m+3*m+(m-1)*nb)
                          call stdlib_sorgbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (workspace: need m*m+4*m, prefer m*m+3*m+m*nb)
                          call stdlib_sorgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in u and computing right
                          ! singular vectors of l in work(iu)
                          ! (workspace: need m*m+bdspac)
                          call stdlib_sbdsqr( 'U', m, m, m, 0, s, work( ie ),work( iu ), ldwrku, &
                                    u, ldu, dum, 1,work( iwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in vt, storing result in a
                          ! (workspace: need m*m)
                          call stdlib_sgemm( 'N', 'N', m, n, m, one, work( iu ),ldwrku, vt, ldvt, &
                                    zero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_slacpy( 'F', m, n, a, lda, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m+m*nb)
                          call stdlib_sgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_slacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need m+n, prefer m+n*nb)
                          call stdlib_sorglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to u, zeroing out above it
                          call stdlib_slacpy( 'L', m, m, a, lda, u, ldu )
                          if (m>1) call stdlib_slaset( 'U', m-1, m-1, zero, zero, u( 1, 2 ),ldu )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in u
                          ! (workspace: need 4*m, prefer 3*m+2*m*nb)
                          call stdlib_sgebrd( m, m, u, ldu, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in u by q
                          ! in vt
                          ! (workspace: need 3*m+n, prefer 3*m+n*nb)
                          call stdlib_sormbr( 'P', 'L', 'T', m, n, m, u, ldu,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (workspace: need 4*m, prefer 3*m+m*nb)
                          call stdlib_sorgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_sbdsqr( 'U', m, n, m, 0, s, work( ie ), vt,ldvt, u, ldu, &
                                    dum, 1, work( iwork ),info )
                       end if
                    end if
                 end if
              else
                 ! n < mnthr
                 ! path 10t(n greater than m, but not much larger)
                 ! reduce to bidiagonal form without lq decomposition
                 ie = 1
                 itauq = ie + m
                 itaup = itauq + m
                 iwork = itaup + m
                 ! bidiagonalize a
                 ! (workspace: need 3*m+n, prefer 3*m+(m+n)*nb)
                 call stdlib_sgebrd( m, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                           work( iwork ), lwork-iwork+1,ierr )
                 if( wntuas ) then
                    ! if left singular vectors desired in u, copy result to u
                    ! and generate left bidiagonalizing vectors in u
                    ! (workspace: need 4*m-1, prefer 3*m+(m-1)*nb)
                    call stdlib_slacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_sorgbr( 'Q', m, m, n, u, ldu, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvas ) then
                    ! if right singular vectors desired in vt, copy result to
                    ! vt and generate right bidiagonalizing vectors in vt
                    ! (workspace: need 3*m+nrvt, prefer 3*m+nrvt*nb)
                    call stdlib_slacpy( 'U', m, n, a, lda, vt, ldvt )
                    if( wntva )nrvt = n
                    if( wntvs )nrvt = m
                    call stdlib_sorgbr( 'P', nrvt, n, m, vt, ldvt, work( itaup ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntuo ) then
                    ! if left singular vectors desired in a, generate left
                    ! bidiagonalizing vectors in a
                    ! (workspace: need 4*m-1, prefer 3*m+(m-1)*nb)
                    call stdlib_sorgbr( 'Q', m, m, n, a, lda, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvo ) then
                    ! if right singular vectors desired in a, generate right
                    ! bidiagonalizing vectors in a
                    ! (workspace: need 4*m, prefer 3*m+m*nb)
                    call stdlib_sorgbr( 'P', m, n, m, a, lda, work( itaup ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 iwork = ie + m
                 if( wntuas .or. wntuo )nru = m
                 if( wntun )nru = 0
                 if( wntvas .or. wntvo )ncvt = n
                 if( wntvn )ncvt = 0
                 if( ( .not.wntuo ) .and. ( .not.wntvo ) ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in vt
                    ! (workspace: need bdspac)
                    call stdlib_sbdsqr( 'L', m, ncvt, nru, 0, s, work( ie ), vt,ldvt, u, ldu, dum,&
                               1, work( iwork ), info )
                 else if( ( .not.wntuo ) .and. wntvo ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in a
                    ! (workspace: need bdspac)
                    call stdlib_sbdsqr( 'L', m, ncvt, nru, 0, s, work( ie ), a, lda,u, ldu, dum, &
                              1, work( iwork ), info )
                 else
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in a and computing right singular
                    ! vectors in vt
                    ! (workspace: need bdspac)
                    call stdlib_sbdsqr( 'L', m, ncvt, nru, 0, s, work( ie ), vt,ldvt, a, lda, dum,&
                               1, work( iwork ), info )
                 end if
              end if
           end if
           ! if stdlib_sbdsqr failed to converge, copy unconverged superdiagonals
           ! to work( 2:minmn )
           if( info/=0 ) then
              if( ie>2 ) then
                 do i = 1, minmn - 1
                    work( i+1 ) = work( i+ie-1 )
                 end do
              end if
              if( ie<2 ) then
                 do i = minmn - 1, 1, -1
                    work( i+1 ) = work( i+ie-1 )
                 end do
              end if
           end if
           ! undo scaling if necessary
           if( iscl==1 ) then
              if( anrm>bignum )call stdlib_slascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm>bignum )call stdlib_slascl( 'G', 0, 0, bignum, anrm, minmn-1,&
                         1, work( 2 ),minmn, ierr )
              if( anrm<smlnum )call stdlib_slascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm<smlnum )call stdlib_slascl( 'G', 0, 0, smlnum, anrm, minmn-1,&
                         1, work( 2 ),minmn, ierr )
           end if
           ! return optimal workspace in work(1)
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_sgesvd

     module subroutine stdlib_dgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu,vt, ldvt, work, lwork, info )
     !! DGESVD computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, optionally computing the left and/or right singular
     !! vectors. The SVD is written
     !! A = U * SIGMA * transpose(V)
     !! where SIGMA is an M-by-N matrix which is zero except for its
     !! min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
     !! V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
     !! are the singular values of A; they are real and non-negative, and
     !! are returned in descending order.  The first min(m,n) columns of
     !! U and V are the left and right singular vectors of A.
     !! Note that the routine returns V**T, not V.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobu, jobvt
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldvt, lwork, m, n
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: s(*), u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wntua, wntuas, wntun, wntuo, wntus, wntva, wntvas, wntvn, wntvo,&
                      wntvs
           integer(ilp) :: bdspac, blk, chunk, i, ie, ierr, ir, iscl, itau, itaup, itauq, iu, &
           iwork, ldwrkr, ldwrku, maxwrk, minmn, minwrk, mnthr, ncu, ncvt, nru, nrvt, &
                     wrkbl
           integer(ilp) :: lwork_dgeqrf, lwork_dorgqr_n, lwork_dorgqr_m, lwork_dgebrd, &
                     lwork_dorgbr_p, lwork_dorgbr_q, lwork_dgelqf, lwork_dorglq_n, lwork_dorglq_m
           real(dp) :: anrm, bignum, eps, smlnum
           ! Local Arrays 
           real(dp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           minmn = min( m, n )
           wntua = stdlib_lsame( jobu, 'A' )
           wntus = stdlib_lsame( jobu, 'S' )
           wntuas = wntua .or. wntus
           wntuo = stdlib_lsame( jobu, 'O' )
           wntun = stdlib_lsame( jobu, 'N' )
           wntva = stdlib_lsame( jobvt, 'A' )
           wntvs = stdlib_lsame( jobvt, 'S' )
           wntvas = wntva .or. wntvs
           wntvo = stdlib_lsame( jobvt, 'O' )
           wntvn = stdlib_lsame( jobvt, 'N' )
           lquery = ( lwork==-1 )
           if( .not.( wntua .or. wntus .or. wntuo .or. wntun ) ) then
              info = -1
           else if( .not.( wntva .or. wntvs .or. wntvo .or. wntvn ) .or.( wntvo .and. wntuo ) ) &
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( ldu<1 .or. ( wntuas .and. ldu<m ) ) then
              info = -9
           else if( ldvt<1 .or. ( wntva .and. ldvt<n ) .or.( wntvs .and. ldvt<minmn ) ) &
                     then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              if( m>=n .and. minmn>0 ) then
                 ! compute space needed for stdlib_dbdsqr
                 mnthr = stdlib_ilaenv( 6, 'DGESVD', jobu // jobvt, m, n, 0, 0 )
                 bdspac = 5*n
                 ! compute space needed for stdlib_dgeqrf
                 call stdlib_dgeqrf( m, n, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_dgeqrf = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_dorgqr
                 call stdlib_dorgqr( m, n, n, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_dorgqr_n = int( dum(1),KIND=ilp)
                 call stdlib_dorgqr( m, m, n, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_dorgqr_m = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_dgebrd
                 call stdlib_dgebrd( n, n, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                           
                 lwork_dgebrd = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_dorgbr p
                 call stdlib_dorgbr( 'P', n, n, n, a, lda, dum(1),dum(1), -1, ierr )
                 lwork_dorgbr_p = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_dorgbr q
                 call stdlib_dorgbr( 'Q', n, n, n, a, lda, dum(1),dum(1), -1, ierr )
                 lwork_dorgbr_q = int( dum(1),KIND=ilp)
                 if( m>=mnthr ) then
                    if( wntun ) then
                       ! path 1 (m much larger than n, jobu='n')
                       maxwrk = n + lwork_dgeqrf
                       maxwrk = max( maxwrk, 3*n + lwork_dgebrd )
                       if( wntvo .or. wntvas )maxwrk = max( maxwrk, 3*n + lwork_dorgbr_p )
                       maxwrk = max( maxwrk, bdspac )
                       minwrk = max( 4*n, bdspac )
                    else if( wntuo .and. wntvn ) then
                       ! path 2 (m much larger than n, jobu='o', jobvt='n')
                       wrkbl = n + lwork_dgeqrf
                       wrkbl = max( wrkbl, n + lwork_dorgqr_n )
                       wrkbl = max( wrkbl, 3*n + lwork_dgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_dorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = max( n*n + wrkbl, n*n + m*n + n )
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntuo .and. wntvas ) then
                       ! path 3 (m much larger than n, jobu='o', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_dgeqrf
                       wrkbl = max( wrkbl, n + lwork_dorgqr_n )
                       wrkbl = max( wrkbl, 3*n + lwork_dgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_dorgbr_q )
                       wrkbl = max( wrkbl, 3*n + lwork_dorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = max( n*n + wrkbl, n*n + m*n + n )
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntus .and. wntvn ) then
                       ! path 4 (m much larger than n, jobu='s', jobvt='n')
                       wrkbl = n + lwork_dgeqrf
                       wrkbl = max( wrkbl, n + lwork_dorgqr_n )
                       wrkbl = max( wrkbl, 3*n + lwork_dgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_dorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = n*n + wrkbl
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntus .and. wntvo ) then
                       ! path 5 (m much larger than n, jobu='s', jobvt='o')
                       wrkbl = n + lwork_dgeqrf
                       wrkbl = max( wrkbl, n + lwork_dorgqr_n )
                       wrkbl = max( wrkbl, 3*n + lwork_dgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_dorgbr_q )
                       wrkbl = max( wrkbl, 3*n + lwork_dorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = 2*n*n + wrkbl
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntus .and. wntvas ) then
                       ! path 6 (m much larger than n, jobu='s', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_dgeqrf
                       wrkbl = max( wrkbl, n + lwork_dorgqr_n )
                       wrkbl = max( wrkbl, 3*n + lwork_dgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_dorgbr_q )
                       wrkbl = max( wrkbl, 3*n + lwork_dorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = n*n + wrkbl
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntua .and. wntvn ) then
                       ! path 7 (m much larger than n, jobu='a', jobvt='n')
                       wrkbl = n + lwork_dgeqrf
                       wrkbl = max( wrkbl, n + lwork_dorgqr_m )
                       wrkbl = max( wrkbl, 3*n + lwork_dgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_dorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = n*n + wrkbl
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntua .and. wntvo ) then
                       ! path 8 (m much larger than n, jobu='a', jobvt='o')
                       wrkbl = n + lwork_dgeqrf
                       wrkbl = max( wrkbl, n + lwork_dorgqr_m )
                       wrkbl = max( wrkbl, 3*n + lwork_dgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_dorgbr_q )
                       wrkbl = max( wrkbl, 3*n + lwork_dorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = 2*n*n + wrkbl
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntua .and. wntvas ) then
                       ! path 9 (m much larger than n, jobu='a', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_dgeqrf
                       wrkbl = max( wrkbl, n + lwork_dorgqr_m )
                       wrkbl = max( wrkbl, 3*n + lwork_dgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_dorgbr_q )
                       wrkbl = max( wrkbl, 3*n + lwork_dorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = n*n + wrkbl
                       minwrk = max( 3*n + m, bdspac )
                    end if
                 else
                    ! path 10 (m at least n, but not much larger)
                    call stdlib_dgebrd( m, n, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                              
                    lwork_dgebrd = int( dum(1),KIND=ilp)
                    maxwrk = 3*n + lwork_dgebrd
                    if( wntus .or. wntuo ) then
                       call stdlib_dorgbr( 'Q', m, n, n, a, lda, dum(1),dum(1), -1, ierr )
                       lwork_dorgbr_q = int( dum(1),KIND=ilp)
                       maxwrk = max( maxwrk, 3*n + lwork_dorgbr_q )
                    end if
                    if( wntua ) then
                       call stdlib_dorgbr( 'Q', m, m, n, a, lda, dum(1),dum(1), -1, ierr )
                       lwork_dorgbr_q = int( dum(1),KIND=ilp)
                       maxwrk = max( maxwrk, 3*n + lwork_dorgbr_q )
                    end if
                    if( .not.wntvn ) then
                      maxwrk = max( maxwrk, 3*n + lwork_dorgbr_p )
                    end if
                    maxwrk = max( maxwrk, bdspac )
                    minwrk = max( 3*n + m, bdspac )
                 end if
              else if( minmn>0 ) then
                 ! compute space needed for stdlib_dbdsqr
                 mnthr = stdlib_ilaenv( 6, 'DGESVD', jobu // jobvt, m, n, 0, 0 )
                 bdspac = 5*m
                 ! compute space needed for stdlib_dgelqf
                 call stdlib_dgelqf( m, n, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_dgelqf = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_dorglq
                 call stdlib_dorglq( n, n, m, dum(1), n, dum(1), dum(1), -1, ierr )
                 lwork_dorglq_n = int( dum(1),KIND=ilp)
                 call stdlib_dorglq( m, n, m, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_dorglq_m = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_dgebrd
                 call stdlib_dgebrd( m, m, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                           
                 lwork_dgebrd = int( dum(1),KIND=ilp)
                  ! compute space needed for stdlib_dorgbr p
                 call stdlib_dorgbr( 'P', m, m, m, a, n, dum(1),dum(1), -1, ierr )
                 lwork_dorgbr_p = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_dorgbr q
                 call stdlib_dorgbr( 'Q', m, m, m, a, n, dum(1),dum(1), -1, ierr )
                 lwork_dorgbr_q = int( dum(1),KIND=ilp)
                 if( n>=mnthr ) then
                    if( wntvn ) then
                       ! path 1t(n much larger than m, jobvt='n')
                       maxwrk = m + lwork_dgelqf
                       maxwrk = max( maxwrk, 3*m + lwork_dgebrd )
                       if( wntuo .or. wntuas )maxwrk = max( maxwrk, 3*m + lwork_dorgbr_q )
                       maxwrk = max( maxwrk, bdspac )
                       minwrk = max( 4*m, bdspac )
                    else if( wntvo .and. wntun ) then
                       ! path 2t(n much larger than m, jobu='n', jobvt='o')
                       wrkbl = m + lwork_dgelqf
                       wrkbl = max( wrkbl, m + lwork_dorglq_m )
                       wrkbl = max( wrkbl, 3*m + lwork_dgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_dorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = max( m*m + wrkbl, m*m + m*n + m )
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntvo .and. wntuas ) then
                       ! path 3t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='o')
                       wrkbl = m + lwork_dgelqf
                       wrkbl = max( wrkbl, m + lwork_dorglq_m )
                       wrkbl = max( wrkbl, 3*m + lwork_dgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_dorgbr_p )
                       wrkbl = max( wrkbl, 3*m + lwork_dorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = max( m*m + wrkbl, m*m + m*n + m )
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntvs .and. wntun ) then
                       ! path 4t(n much larger than m, jobu='n', jobvt='s')
                       wrkbl = m + lwork_dgelqf
                       wrkbl = max( wrkbl, m + lwork_dorglq_m )
                       wrkbl = max( wrkbl, 3*m + lwork_dgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_dorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = m*m + wrkbl
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntvs .and. wntuo ) then
                       ! path 5t(n much larger than m, jobu='o', jobvt='s')
                       wrkbl = m + lwork_dgelqf
                       wrkbl = max( wrkbl, m + lwork_dorglq_m )
                       wrkbl = max( wrkbl, 3*m + lwork_dgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_dorgbr_p )
                       wrkbl = max( wrkbl, 3*m + lwork_dorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = 2*m*m + wrkbl
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntvs .and. wntuas ) then
                       ! path 6t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='s')
                       wrkbl = m + lwork_dgelqf
                       wrkbl = max( wrkbl, m + lwork_dorglq_m )
                       wrkbl = max( wrkbl, 3*m + lwork_dgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_dorgbr_p )
                       wrkbl = max( wrkbl, 3*m + lwork_dorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = m*m + wrkbl
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntva .and. wntun ) then
                       ! path 7t(n much larger than m, jobu='n', jobvt='a')
                       wrkbl = m + lwork_dgelqf
                       wrkbl = max( wrkbl, m + lwork_dorglq_n )
                       wrkbl = max( wrkbl, 3*m + lwork_dgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_dorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = m*m + wrkbl
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntva .and. wntuo ) then
                       ! path 8t(n much larger than m, jobu='o', jobvt='a')
                       wrkbl = m + lwork_dgelqf
                       wrkbl = max( wrkbl, m + lwork_dorglq_n )
                       wrkbl = max( wrkbl, 3*m + lwork_dgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_dorgbr_p )
                       wrkbl = max( wrkbl, 3*m + lwork_dorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = 2*m*m + wrkbl
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntva .and. wntuas ) then
                       ! path 9t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='a')
                       wrkbl = m + lwork_dgelqf
                       wrkbl = max( wrkbl, m + lwork_dorglq_n )
                       wrkbl = max( wrkbl, 3*m + lwork_dgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_dorgbr_p )
                       wrkbl = max( wrkbl, 3*m + lwork_dorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = m*m + wrkbl
                       minwrk = max( 3*m + n, bdspac )
                    end if
                 else
                    ! path 10t(n greater than m, but not much larger)
                    call stdlib_dgebrd( m, n, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                              
                    lwork_dgebrd = int( dum(1),KIND=ilp)
                    maxwrk = 3*m + lwork_dgebrd
                    if( wntvs .or. wntvo ) then
                      ! compute space needed for stdlib_dorgbr p
                      call stdlib_dorgbr( 'P', m, n, m, a, n, dum(1),dum(1), -1, ierr )
                      lwork_dorgbr_p = int( dum(1),KIND=ilp)
                      maxwrk = max( maxwrk, 3*m + lwork_dorgbr_p )
                    end if
                    if( wntva ) then
                      call stdlib_dorgbr( 'P', n, n, m, a, n, dum(1),dum(1), -1, ierr )
                      lwork_dorgbr_p = int( dum(1),KIND=ilp)
                      maxwrk = max( maxwrk, 3*m + lwork_dorgbr_p )
                    end if
                    if( .not.wntun ) then
                       maxwrk = max( maxwrk, 3*m + lwork_dorgbr_q )
                    end if
                    maxwrk = max( maxwrk, bdspac )
                    minwrk = max( 3*m + n, bdspac )
                 end if
              end if
              maxwrk = max( maxwrk, minwrk )
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGESVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = sqrt( stdlib_dlamch( 'S' ) ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_dlange( 'M', m, n, a, lda, dum )
           iscl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              iscl = 1
              call stdlib_dlascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, ierr )
           else if( anrm>bignum ) then
              iscl = 1
              call stdlib_dlascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, ierr )
           end if
           if( m>=n ) then
              ! a has at least as many rows as columns. if a has sufficiently
              ! more rows than columns, first reduce using the qr
              ! decomposition (if sufficient workspace available)
              if( m>=mnthr ) then
                 if( wntun ) then
                    ! path 1 (m much larger than n, jobu='n')
                    ! no left singular vectors to be computed
                    itau = 1
                    iwork = itau + n
                    ! compute a=q*r
                    ! (workspace: need 2*n, prefer n + n*nb)
                    call stdlib_dgeqrf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, &
                              ierr )
                    ! zero out below r
                    if( n > 1 ) then
                       call stdlib_dlaset( 'L', n-1, n-1, zero, zero, a( 2, 1 ),lda )
                    end if
                    ie = 1
                    itauq = ie + n
                    itaup = itauq + n
                    iwork = itaup + n
                    ! bidiagonalize r in a
                    ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                    call stdlib_dgebrd( n, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( iwork ), lwork-iwork+1,ierr )
                    ncvt = 0
                    if( wntvo .or. wntvas ) then
                       ! if right singular vectors desired, generate p'.
                       ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                       call stdlib_dorgbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       ncvt = n
                    end if
                    iwork = ie + n
                    ! perform bidiagonal qr iteration, computing right
                    ! singular vectors of a in a if desired
                    ! (workspace: need bdspac)
                    call stdlib_dbdsqr( 'U', n, ncvt, 0, 0, s, work( ie ), a, lda,dum, 1, dum, 1, &
                              work( iwork ), info )
                    ! if right singular vectors desired in vt, copy them there
                    if( wntvas )call stdlib_dlacpy( 'F', n, n, a, lda, vt, ldvt )
                 else if( wntuo .and. wntvn ) then
                    ! path 2 (m much larger than n, jobu='o', jobvt='n')
                    ! n left singular vectors to be overwritten on a and
                    ! no right singular vectors to be computed
                    if( lwork>=n*n+max( 4*n, bdspac ) ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n + n ) + lda*n ) then
                          ! work(iu) is lda by n, work(ir) is lda by n
                          ldwrku = lda
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n + n ) + n*n ) then
                          ! work(iu) is lda by n, work(ir) is n by n
                          ldwrku = lda
                          ldwrkr = n
                       else
                          ! work(iu) is ldwrku by n, work(ir) is n by n
                          ldwrku = ( lwork-n*n-n ) / n
                          ldwrkr = n
                       end if
                       itau = ir + ldwrkr*n
                       iwork = itau + n
                       ! compute a=q*r
                       ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                       call stdlib_dgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to work(ir) and zero out below it
                       call stdlib_dlacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                       call stdlib_dlaset( 'L', n-1, n-1, zero, zero, work( ir+1 ),ldwrkr )
                                 
                       ! generate q in a
                       ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                       call stdlib_dorgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + n
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in work(ir)
                       ! (workspace: need n*n + 4*n, prefer n*n + 3*n + 2*n*nb)
                       call stdlib_dgebrd( n, n, work( ir ), ldwrkr, s, work( ie ),work( itauq ), &
                                 work( itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing r
                       ! (workspace: need n*n + 4*n, prefer n*n + 3*n + n*nb)
                       call stdlib_dorgbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       iwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of r in work(ir)
                       ! (workspace: need n*n + bdspac)
                       call stdlib_dbdsqr( 'U', n, 0, n, 0, s, work( ie ), dum, 1,work( ir ), &
                                 ldwrkr, dum, 1,work( iwork ), info )
                       iu = ie + n
                       ! multiply q in a by left singular vectors of r in
                       ! work(ir), storing result in work(iu) and copying to a
                       ! (workspace: need n*n + 2*n, prefer n*n + m*n + n)
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_dgemm( 'N', 'N', chunk, n, n, one, a( i, 1 ),lda, work( ir )&
                                    , ldwrkr, zero,work( iu ), ldwrku )
                          call stdlib_dlacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       ie = 1
                       itauq = ie + n
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize a
                       ! (workspace: need 3*n + m, prefer 3*n + (m + n)*nb)
                       call stdlib_dgebrd( m, n, a, lda, s, work( ie ),work( itauq ), work( itaup &
                                 ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing a
                       ! (workspace: need 4*n, prefer 3*n + n*nb)
                       call stdlib_dorgbr( 'Q', m, n, n, a, lda, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in a
                       ! (workspace: need bdspac)
                       call stdlib_dbdsqr( 'U', n, 0, m, 0, s, work( ie ), dum, 1,a, lda, dum, 1, &
                                 work( iwork ), info )
                    end if
                 else if( wntuo .and. wntvas ) then
                    ! path 3 (m much larger than n, jobu='o', jobvt='s' or 'a')
                    ! n left singular vectors to be overwritten on a and
                    ! n right singular vectors to be computed in vt
                    if( lwork>=n*n+max( 4*n, bdspac ) ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n + n ) + lda*n ) then
                          ! work(iu) is lda by n and work(ir) is lda by n
                          ldwrku = lda
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n + n ) + n*n ) then
                          ! work(iu) is lda by n and work(ir) is n by n
                          ldwrku = lda
                          ldwrkr = n
                       else
                          ! work(iu) is ldwrku by n and work(ir) is n by n
                          ldwrku = ( lwork-n*n-n ) / n
                          ldwrkr = n
                       end if
                       itau = ir + ldwrkr*n
                       iwork = itau + n
                       ! compute a=q*r
                       ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                       call stdlib_dgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to vt, zeroing out below it
                       call stdlib_dlacpy( 'U', n, n, a, lda, vt, ldvt )
                       if( n>1 )call stdlib_dlaset( 'L', n-1, n-1, zero, zero,vt( 2, 1 ), ldvt )
                                 
                       ! generate q in a
                       ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                       call stdlib_dorgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + n
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in vt, copying result to work(ir)
                       ! (workspace: need n*n + 4*n, prefer n*n + 3*n + 2*n*nb)
                       call stdlib_dgebrd( n, n, vt, ldvt, s, work( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       call stdlib_dlacpy( 'L', n, n, vt, ldvt, work( ir ), ldwrkr )
                       ! generate left vectors bidiagonalizing r in work(ir)
                       ! (workspace: need n*n + 4*n, prefer n*n + 3*n + n*nb)
                       call stdlib_dorgbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing r in vt
                       ! (workspace: need n*n + 4*n-1, prefer n*n + 3*n + (n-1)*nb)
                       call stdlib_dorgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of r in work(ir) and computing right
                       ! singular vectors of r in vt
                       ! (workspace: need n*n + bdspac)
                       call stdlib_dbdsqr( 'U', n, n, n, 0, s, work( ie ), vt, ldvt,work( ir ), &
                                 ldwrkr, dum, 1,work( iwork ), info )
                       iu = ie + n
                       ! multiply q in a by left singular vectors of r in
                       ! work(ir), storing result in work(iu) and copying to a
                       ! (workspace: need n*n + 2*n, prefer n*n + m*n + n)
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_dgemm( 'N', 'N', chunk, n, n, one, a( i, 1 ),lda, work( ir )&
                                    , ldwrkr, zero,work( iu ), ldwrku )
                          call stdlib_dlacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       itau = 1
                       iwork = itau + n
                       ! compute a=q*r
                       ! (workspace: need 2*n, prefer n + n*nb)
                       call stdlib_dgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to vt, zeroing out below it
                       call stdlib_dlacpy( 'U', n, n, a, lda, vt, ldvt )
                       if( n>1 )call stdlib_dlaset( 'L', n-1, n-1, zero, zero,vt( 2, 1 ), ldvt )
                                 
                       ! generate q in a
                       ! (workspace: need 2*n, prefer n + n*nb)
                       call stdlib_dorgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + n
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in vt
                       ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                       call stdlib_dgebrd( n, n, vt, ldvt, s, work( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! multiply q in a by left vectors bidiagonalizing r
                       ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                       call stdlib_dormbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), a, lda,&
                                  work( iwork ),lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing r in vt
                       ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                       call stdlib_dorgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in a and computing right
                       ! singular vectors of a in vt
                       ! (workspace: need bdspac)
                       call stdlib_dbdsqr( 'U', n, n, m, 0, s, work( ie ), vt, ldvt,a, lda, dum, &
                                 1, work( iwork ), info )
                    end if
                 else if( wntus ) then
                    if( wntvn ) then
                       ! path 4 (m much larger than n, jobu='s', jobvt='n')
                       ! n left singular vectors to be computed in u and
                       ! no right singular vectors to be computed
                       if( lwork>=n*n+max( 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(ir) is lda by n
                             ldwrkr = lda
                          else
                             ! work(ir) is n by n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                          call stdlib_dgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(ir), zeroing out below it
                          call stdlib_dlacpy( 'U', n, n, a, lda, work( ir ),ldwrkr )
                          call stdlib_dlaset( 'L', n-1, n-1, zero, zero,work( ir+1 ), ldwrkr )
                                    
                          ! generate q in a
                          ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                          call stdlib_dorgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(ir)
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + 2*n*nb)
                          call stdlib_dgebrd( n, n, work( ir ), ldwrkr, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate left vectors bidiagonalizing r in work(ir)
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + n*nb)
                          call stdlib_dorgbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(ir)
                          ! (workspace: need n*n + bdspac)
                          call stdlib_dbdsqr( 'U', n, 0, n, 0, s, work( ie ), dum,1, work( ir ), &
                                    ldwrkr, dum, 1,work( iwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(ir), storing result in u
                          ! (workspace: need n*n)
                          call stdlib_dgemm( 'N', 'N', m, n, n, one, a, lda,work( ir ), ldwrkr, &
                                    zero, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_dgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_dlacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_dorgqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_dlaset( 'L', n-1, n-1, zero, zero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                          call stdlib_dgebrd( n, n, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left vectors bidiagonalizing r
                          ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                          call stdlib_dormbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u
                          ! (workspace: need bdspac)
                          call stdlib_dbdsqr( 'U', n, 0, m, 0, s, work( ie ), dum,1, u, ldu, dum, &
                                    1, work( iwork ),info )
                       end if
                    else if( wntvo ) then
                       ! path 5 (m much larger than n, jobu='s', jobvt='o')
                       ! n left singular vectors to be computed in u and
                       ! n right singular vectors to be overwritten on a
                       if( lwork>=2*n*n+max( 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*n ) then
                             ! work(iu) is lda by n and work(ir) is lda by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda + n )*n ) then
                             ! work(iu) is lda by n and work(ir) is n by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          else
                             ! work(iu) is n by n and work(ir) is n by n
                             ldwrku = n
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (workspace: need 2*n*n + 2*n, prefer 2*n*n + n + n*nb)
                          call stdlib_dgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_dlacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_dlaset( 'L', n-1, n-1, zero, zero,work( iu+1 ), ldwrku )
                                    
                          ! generate q in a
                          ! (workspace: need 2*n*n + 2*n, prefer 2*n*n + n + n*nb)
                          call stdlib_dorgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to
                          ! work(ir)
                          ! (workspace: need 2*n*n + 4*n,
                                      ! prefer 2*n*n+3*n+2*n*nb)
                          call stdlib_dgebrd( n, n, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_dlacpy( 'U', n, n, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (workspace: need 2*n*n + 4*n, prefer 2*n*n + 3*n + n*nb)
                          call stdlib_dorgbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (workspace: need 2*n*n + 4*n-1,
                                      ! prefer 2*n*n+3*n+(n-1)*nb)
                          call stdlib_dorgbr( 'P', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in work(ir)
                          ! (workspace: need 2*n*n + bdspac)
                          call stdlib_dbdsqr( 'U', n, n, n, 0, s, work( ie ),work( ir ), ldwrkr, &
                                    work( iu ),ldwrku, dum, 1, work( iwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(iu), storing result in u
                          ! (workspace: need n*n)
                          call stdlib_dgemm( 'N', 'N', m, n, n, one, a, lda,work( iu ), ldwrku, &
                                    zero, u, ldu )
                          ! copy right singular vectors of r to a
                          ! (workspace: need n*n)
                          call stdlib_dlacpy( 'F', n, n, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_dgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_dlacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_dorgqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_dlaset( 'L', n-1, n-1, zero, zero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                          call stdlib_dgebrd( n, n, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left vectors bidiagonalizing r
                          ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                          call stdlib_dormbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right vectors bidiagonalizing r in a
                          ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                          call stdlib_dorgbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in a
                          ! (workspace: need bdspac)
                          call stdlib_dbdsqr( 'U', n, n, m, 0, s, work( ie ), a,lda, u, ldu, dum, &
                                    1, work( iwork ),info )
                       end if
                    else if( wntvas ) then
                       ! path 6 (m much larger than n, jobu='s', jobvt='s'
                               ! or 'a')
                       ! n left singular vectors to be computed in u and
                       ! n right singular vectors to be computed in vt
                       if( lwork>=n*n+max( 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is n by n
                             ldwrku = n
                          end if
                          itau = iu + ldwrku*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                          call stdlib_dgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_dlacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_dlaset( 'L', n-1, n-1, zero, zero,work( iu+1 ), ldwrku )
                                    
                          ! generate q in a
                          ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                          call stdlib_dorgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to vt
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + 2*n*nb)
                          call stdlib_dgebrd( n, n, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_dlacpy( 'U', n, n, work( iu ), ldwrku, vt,ldvt )
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + n*nb)
                          call stdlib_dorgbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (workspace: need n*n + 4*n-1,
                                      ! prefer n*n+3*n+(n-1)*nb)
                          call stdlib_dorgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in vt
                          ! (workspace: need n*n + bdspac)
                          call stdlib_dbdsqr( 'U', n, n, n, 0, s, work( ie ), vt,ldvt, work( iu ),&
                                     ldwrku, dum, 1,work( iwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(iu), storing result in u
                          ! (workspace: need n*n)
                          call stdlib_dgemm( 'N', 'N', m, n, n, one, a, lda,work( iu ), ldwrku, &
                                    zero, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_dgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_dlacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_dorgqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to vt, zeroing out below it
                          call stdlib_dlacpy( 'U', n, n, a, lda, vt, ldvt )
                          if( n>1 )call stdlib_dlaset( 'L', n-1, n-1, zero, zero,vt( 2, 1 ), ldvt &
                                    )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in vt
                          ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                          call stdlib_dgebrd( n, n, vt, ldvt, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in vt
                          ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                          call stdlib_dormbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                          call stdlib_dorgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_dbdsqr( 'U', n, n, m, 0, s, work( ie ), vt,ldvt, u, ldu, &
                                    dum, 1, work( iwork ),info )
                       end if
                    end if
                 else if( wntua ) then
                    if( wntvn ) then
                       ! path 7 (m much larger than n, jobu='a', jobvt='n')
                       ! m left singular vectors to be computed in u and
                       ! no right singular vectors to be computed
                       if( lwork>=n*n+max( n+m, 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(ir) is lda by n
                             ldwrkr = lda
                          else
                             ! work(ir) is n by n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                          call stdlib_dgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_dlacpy( 'L', m, n, a, lda, u, ldu )
                          ! copy r to work(ir), zeroing out below it
                          call stdlib_dlacpy( 'U', n, n, a, lda, work( ir ),ldwrkr )
                          call stdlib_dlaset( 'L', n-1, n-1, zero, zero,work( ir+1 ), ldwrkr )
                                    
                          ! generate q in u
                          ! (workspace: need n*n + n + m, prefer n*n + n + m*nb)
                          call stdlib_dorgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(ir)
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + 2*n*nb)
                          call stdlib_dgebrd( n, n, work( ir ), ldwrkr, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + n*nb)
                          call stdlib_dorgbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(ir)
                          ! (workspace: need n*n + bdspac)
                          call stdlib_dbdsqr( 'U', n, 0, n, 0, s, work( ie ), dum,1, work( ir ), &
                                    ldwrkr, dum, 1,work( iwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(ir), storing result in a
                          ! (workspace: need n*n)
                          call stdlib_dgemm( 'N', 'N', m, n, n, one, u, ldu,work( ir ), ldwrkr, &
                                    zero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_dlacpy( 'F', m, n, a, lda, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_dgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_dlacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need n + m, prefer n + m*nb)
                          call stdlib_dorgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_dlaset( 'L', n-1, n-1, zero, zero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                          call stdlib_dgebrd( n, n, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in a
                          ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                          call stdlib_dormbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u
                          ! (workspace: need bdspac)
                          call stdlib_dbdsqr( 'U', n, 0, m, 0, s, work( ie ), dum,1, u, ldu, dum, &
                                    1, work( iwork ),info )
                       end if
                    else if( wntvo ) then
                       ! path 8 (m much larger than n, jobu='a', jobvt='o')
                       ! m left singular vectors to be computed in u and
                       ! n right singular vectors to be overwritten on a
                       if( lwork>=2*n*n+max( n+m, 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*n ) then
                             ! work(iu) is lda by n and work(ir) is lda by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda + n )*n ) then
                             ! work(iu) is lda by n and work(ir) is n by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          else
                             ! work(iu) is n by n and work(ir) is n by n
                             ldwrku = n
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n*n + 2*n, prefer 2*n*n + n + n*nb)
                          call stdlib_dgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_dlacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need 2*n*n + n + m, prefer 2*n*n + n + m*nb)
                          call stdlib_dorgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_dlacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_dlaset( 'L', n-1, n-1, zero, zero,work( iu+1 ), ldwrku )
                                    
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to
                          ! work(ir)
                          ! (workspace: need 2*n*n + 4*n,
                                      ! prefer 2*n*n+3*n+2*n*nb)
                          call stdlib_dgebrd( n, n, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_dlacpy( 'U', n, n, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (workspace: need 2*n*n + 4*n, prefer 2*n*n + 3*n + n*nb)
                          call stdlib_dorgbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (workspace: need 2*n*n + 4*n-1,
                                      ! prefer 2*n*n+3*n+(n-1)*nb)
                          call stdlib_dorgbr( 'P', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in work(ir)
                          ! (workspace: need 2*n*n + bdspac)
                          call stdlib_dbdsqr( 'U', n, n, n, 0, s, work( ie ),work( ir ), ldwrkr, &
                                    work( iu ),ldwrku, dum, 1, work( iwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(iu), storing result in a
                          ! (workspace: need n*n)
                          call stdlib_dgemm( 'N', 'N', m, n, n, one, u, ldu,work( iu ), ldwrku, &
                                    zero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_dlacpy( 'F', m, n, a, lda, u, ldu )
                          ! copy right singular vectors of r from work(ir) to a
                          call stdlib_dlacpy( 'F', n, n, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_dgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_dlacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need n + m, prefer n + m*nb)
                          call stdlib_dorgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_dlaset( 'L', n-1, n-1, zero, zero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                          call stdlib_dgebrd( n, n, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in a
                          ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                          call stdlib_dormbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in a
                          ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                          call stdlib_dorgbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in a
                          ! (workspace: need bdspac)
                          call stdlib_dbdsqr( 'U', n, n, m, 0, s, work( ie ), a,lda, u, ldu, dum, &
                                    1, work( iwork ),info )
                       end if
                    else if( wntvas ) then
                       ! path 9 (m much larger than n, jobu='a', jobvt='s'
                               ! or 'a')
                       ! m left singular vectors to be computed in u and
                       ! n right singular vectors to be computed in vt
                       if( lwork>=n*n+max( n+m, 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is n by n
                             ldwrku = n
                          end if
                          itau = iu + ldwrku*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                          call stdlib_dgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_dlacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need n*n + n + m, prefer n*n + n + m*nb)
                          call stdlib_dorgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_dlacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_dlaset( 'L', n-1, n-1, zero, zero,work( iu+1 ), ldwrku )
                                    
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to vt
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + 2*n*nb)
                          call stdlib_dgebrd( n, n, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_dlacpy( 'U', n, n, work( iu ), ldwrku, vt,ldvt )
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + n*nb)
                          call stdlib_dorgbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (workspace: need n*n + 4*n-1,
                                      ! prefer n*n+3*n+(n-1)*nb)
                          call stdlib_dorgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in vt
                          ! (workspace: need n*n + bdspac)
                          call stdlib_dbdsqr( 'U', n, n, n, 0, s, work( ie ), vt,ldvt, work( iu ),&
                                     ldwrku, dum, 1,work( iwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(iu), storing result in a
                          ! (workspace: need n*n)
                          call stdlib_dgemm( 'N', 'N', m, n, n, one, u, ldu,work( iu ), ldwrku, &
                                    zero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_dlacpy( 'F', m, n, a, lda, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_dgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_dlacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need n + m, prefer n + m*nb)
                          call stdlib_dorgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r from a to vt, zeroing out below it
                          call stdlib_dlacpy( 'U', n, n, a, lda, vt, ldvt )
                          if( n>1 )call stdlib_dlaset( 'L', n-1, n-1, zero, zero,vt( 2, 1 ), ldvt &
                                    )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in vt
                          ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                          call stdlib_dgebrd( n, n, vt, ldvt, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in vt
                          ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                          call stdlib_dormbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                          call stdlib_dorgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_dbdsqr( 'U', n, n, m, 0, s, work( ie ), vt,ldvt, u, ldu, &
                                    dum, 1, work( iwork ),info )
                       end if
                    end if
                 end if
              else
                 ! m < mnthr
                 ! path 10 (m at least n, but not much larger)
                 ! reduce to bidiagonal form without qr decomposition
                 ie = 1
                 itauq = ie + n
                 itaup = itauq + n
                 iwork = itaup + n
                 ! bidiagonalize a
                 ! (workspace: need 3*n + m, prefer 3*n + (m + n)*nb)
                 call stdlib_dgebrd( m, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                           work( iwork ), lwork-iwork+1,ierr )
                 if( wntuas ) then
                    ! if left singular vectors desired in u, copy result to u
                    ! and generate left bidiagonalizing vectors in u
                    ! (workspace: need 3*n + ncu, prefer 3*n + ncu*nb)
                    call stdlib_dlacpy( 'L', m, n, a, lda, u, ldu )
                    if( wntus )ncu = n
                    if( wntua )ncu = m
                    call stdlib_dorgbr( 'Q', m, ncu, n, u, ldu, work( itauq ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntvas ) then
                    ! if right singular vectors desired in vt, copy result to
                    ! vt and generate right bidiagonalizing vectors in vt
                    ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                    call stdlib_dlacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_dorgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntuo ) then
                    ! if left singular vectors desired in a, generate left
                    ! bidiagonalizing vectors in a
                    ! (workspace: need 4*n, prefer 3*n + n*nb)
                    call stdlib_dorgbr( 'Q', m, n, n, a, lda, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvo ) then
                    ! if right singular vectors desired in a, generate right
                    ! bidiagonalizing vectors in a
                    ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                    call stdlib_dorgbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 iwork = ie + n
                 if( wntuas .or. wntuo )nru = m
                 if( wntun )nru = 0
                 if( wntvas .or. wntvo )ncvt = n
                 if( wntvn )ncvt = 0
                 if( ( .not.wntuo ) .and. ( .not.wntvo ) ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in vt
                    ! (workspace: need bdspac)
                    call stdlib_dbdsqr( 'U', n, ncvt, nru, 0, s, work( ie ), vt,ldvt, u, ldu, dum,&
                               1, work( iwork ), info )
                 else if( ( .not.wntuo ) .and. wntvo ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in a
                    ! (workspace: need bdspac)
                    call stdlib_dbdsqr( 'U', n, ncvt, nru, 0, s, work( ie ), a, lda,u, ldu, dum, &
                              1, work( iwork ), info )
                 else
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in a and computing right singular
                    ! vectors in vt
                    ! (workspace: need bdspac)
                    call stdlib_dbdsqr( 'U', n, ncvt, nru, 0, s, work( ie ), vt,ldvt, a, lda, dum,&
                               1, work( iwork ), info )
                 end if
              end if
           else
              ! a has more columns than rows. if a has sufficiently more
              ! columns than rows, first reduce using the lq decomposition (if
              ! sufficient workspace available)
              if( n>=mnthr ) then
                 if( wntvn ) then
                    ! path 1t(n much larger than m, jobvt='n')
                    ! no right singular vectors to be computed
                    itau = 1
                    iwork = itau + m
                    ! compute a=l*q
                    ! (workspace: need 2*m, prefer m + m*nb)
                    call stdlib_dgelqf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, &
                              ierr )
                    ! zero out above l
                    if (m>1) call stdlib_dlaset( 'U', m-1, m-1, zero, zero, a( 1, 2 ), lda )
                    ie = 1
                    itauq = ie + m
                    itaup = itauq + m
                    iwork = itaup + m
                    ! bidiagonalize l in a
                    ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                    call stdlib_dgebrd( m, m, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( iwork ), lwork-iwork+1,ierr )
                    if( wntuo .or. wntuas ) then
                       ! if left singular vectors desired, generate q
                       ! (workspace: need 4*m, prefer 3*m + m*nb)
                       call stdlib_dorgbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                    end if
                    iwork = ie + m
                    nru = 0
                    if( wntuo .or. wntuas )nru = m
                    ! perform bidiagonal qr iteration, computing left singular
                    ! vectors of a in a if desired
                    ! (workspace: need bdspac)
                    call stdlib_dbdsqr( 'U', m, 0, nru, 0, s, work( ie ), dum, 1, a,lda, dum, 1, &
                              work( iwork ), info )
                    ! if left singular vectors desired in u, copy them there
                    if( wntuas )call stdlib_dlacpy( 'F', m, m, a, lda, u, ldu )
                 else if( wntvo .and. wntun ) then
                    ! path 2t(n much larger than m, jobu='n', jobvt='o')
                    ! m right singular vectors to be overwritten on a and
                    ! no left singular vectors to be computed
                    if( lwork>=m*m+max( 4*m, bdspac ) ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n + m ) + lda*m ) then
                          ! work(iu) is lda by n and work(ir) is lda by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n + m ) + m*m ) then
                          ! work(iu) is lda by n and work(ir) is m by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = m
                       else
                          ! work(iu) is m by chunk and work(ir) is m by m
                          ldwrku = m
                          chunk = ( lwork-m*m-m ) / m
                          ldwrkr = m
                       end if
                       itau = ir + ldwrkr*m
                       iwork = itau + m
                       ! compute a=l*q
                       ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                       call stdlib_dgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to work(ir) and zero out above it
                       call stdlib_dlacpy( 'L', m, m, a, lda, work( ir ), ldwrkr )
                       call stdlib_dlaset( 'U', m-1, m-1, zero, zero,work( ir+ldwrkr ), ldwrkr )
                                 
                       ! generate q in a
                       ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                       call stdlib_dorglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + m
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in work(ir)
                       ! (workspace: need m*m + 4*m, prefer m*m + 3*m + 2*m*nb)
                       call stdlib_dgebrd( m, m, work( ir ), ldwrkr, s, work( ie ),work( itauq ), &
                                 work( itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing l
                       ! (workspace: need m*m + 4*m-1, prefer m*m + 3*m + (m-1)*nb)
                       call stdlib_dorgbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       iwork = ie + m
                       ! perform bidiagonal qr iteration, computing right
                       ! singular vectors of l in work(ir)
                       ! (workspace: need m*m + bdspac)
                       call stdlib_dbdsqr( 'U', m, m, 0, 0, s, work( ie ),work( ir ), ldwrkr, dum,&
                                  1, dum, 1,work( iwork ), info )
                       iu = ie + m
                       ! multiply right singular vectors of l in work(ir) by q
                       ! in a, storing result in work(iu) and copying to a
                       ! (workspace: need m*m + 2*m, prefer m*m + m*n + m)
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_dgemm( 'N', 'N', m, blk, m, one, work( ir ),ldwrkr, a( 1, i &
                                    ), lda, zero,work( iu ), ldwrku )
                          call stdlib_dlacpy( 'F', m, blk, work( iu ), ldwrku,a( 1, i ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       ie = 1
                       itauq = ie + m
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize a
                       ! (workspace: need 3*m + n, prefer 3*m + (m + n)*nb)
                       call stdlib_dgebrd( m, n, a, lda, s, work( ie ),work( itauq ), work( itaup &
                                 ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing a
                       ! (workspace: need 4*m, prefer 3*m + m*nb)
                       call stdlib_dorgbr( 'P', m, n, m, a, lda, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + m
                       ! perform bidiagonal qr iteration, computing right
                       ! singular vectors of a in a
                       ! (workspace: need bdspac)
                       call stdlib_dbdsqr( 'L', m, n, 0, 0, s, work( ie ), a, lda,dum, 1, dum, 1, &
                                 work( iwork ), info )
                    end if
                 else if( wntvo .and. wntuas ) then
                    ! path 3t(n much larger than m, jobu='s' or 'a', jobvt='o')
                    ! m right singular vectors to be overwritten on a and
                    ! m left singular vectors to be computed in u
                    if( lwork>=m*m+max( 4*m, bdspac ) ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n + m ) + lda*m ) then
                          ! work(iu) is lda by n and work(ir) is lda by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n + m ) + m*m ) then
                          ! work(iu) is lda by n and work(ir) is m by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = m
                       else
                          ! work(iu) is m by chunk and work(ir) is m by m
                          ldwrku = m
                          chunk = ( lwork-m*m-m ) / m
                          ldwrkr = m
                       end if
                       itau = ir + ldwrkr*m
                       iwork = itau + m
                       ! compute a=l*q
                       ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                       call stdlib_dgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to u, zeroing about above it
                       call stdlib_dlacpy( 'L', m, m, a, lda, u, ldu )
                       if (m>1) call stdlib_dlaset( 'U', m-1, m-1, zero, zero, u( 1, 2 ),ldu )
                       ! generate q in a
                       ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                       call stdlib_dorglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + m
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in u, copying result to work(ir)
                       ! (workspace: need m*m + 4*m, prefer m*m + 3*m + 2*m*nb)
                       call stdlib_dgebrd( m, m, u, ldu, s, work( ie ),work( itauq ), work( itaup &
                                 ),work( iwork ), lwork-iwork+1, ierr )
                       call stdlib_dlacpy( 'U', m, m, u, ldu, work( ir ), ldwrkr )
                       ! generate right vectors bidiagonalizing l in work(ir)
                       ! (workspace: need m*m + 4*m-1, prefer m*m + 3*m + (m-1)*nb)
                       call stdlib_dorgbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing l in u
                       ! (workspace: need m*m + 4*m, prefer m*m + 3*m + m*nb)
                       call stdlib_dorgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + m
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of l in u, and computing right
                       ! singular vectors of l in work(ir)
                       ! (workspace: need m*m + bdspac)
                       call stdlib_dbdsqr( 'U', m, m, m, 0, s, work( ie ),work( ir ), ldwrkr, u, &
                                 ldu, dum, 1,work( iwork ), info )
                       iu = ie + m
                       ! multiply right singular vectors of l in work(ir) by q
                       ! in a, storing result in work(iu) and copying to a
                       ! (workspace: need m*m + 2*m, prefer m*m + m*n + m))
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_dgemm( 'N', 'N', m, blk, m, one, work( ir ),ldwrkr, a( 1, i &
                                    ), lda, zero,work( iu ), ldwrku )
                          call stdlib_dlacpy( 'F', m, blk, work( iu ), ldwrku,a( 1, i ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       itau = 1
                       iwork = itau + m
                       ! compute a=l*q
                       ! (workspace: need 2*m, prefer m + m*nb)
                       call stdlib_dgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to u, zeroing out above it
                       call stdlib_dlacpy( 'L', m, m, a, lda, u, ldu )
                       if (m>1) call stdlib_dlaset( 'U', m-1, m-1, zero, zero, u( 1, 2 ),ldu )
                       ! generate q in a
                       ! (workspace: need 2*m, prefer m + m*nb)
                       call stdlib_dorglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + m
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in u
                       ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                       call stdlib_dgebrd( m, m, u, ldu, s, work( ie ),work( itauq ), work( itaup &
                                 ),work( iwork ), lwork-iwork+1, ierr )
                       ! multiply right vectors bidiagonalizing l by q in a
                       ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                       call stdlib_dormbr( 'P', 'L', 'T', m, n, m, u, ldu,work( itaup ), a, lda, &
                                 work( iwork ),lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing l in u
                       ! (workspace: need 4*m, prefer 3*m + m*nb)
                       call stdlib_dorgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + m
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in u and computing right
                       ! singular vectors of a in a
                       ! (workspace: need bdspac)
                       call stdlib_dbdsqr( 'U', m, n, m, 0, s, work( ie ), a, lda,u, ldu, dum, 1, &
                                 work( iwork ), info )
                    end if
                 else if( wntvs ) then
                    if( wntun ) then
                       ! path 4t(n much larger than m, jobu='n', jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! no left singular vectors to be computed
                       if( lwork>=m*m+max( 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(ir) is lda by m
                             ldwrkr = lda
                          else
                             ! work(ir) is m by m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                          call stdlib_dgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(ir), zeroing out above it
                          call stdlib_dlacpy( 'L', m, m, a, lda, work( ir ),ldwrkr )
                          call stdlib_dlaset( 'U', m-1, m-1, zero, zero,work( ir+ldwrkr ), ldwrkr &
                                    )
                          ! generate q in a
                          ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                          call stdlib_dorglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(ir)
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + 2*m*nb)
                          call stdlib_dgebrd( m, m, work( ir ), ldwrkr, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate right vectors bidiagonalizing l in
                          ! work(ir)
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + (m-1)*nb)
                          call stdlib_dorgbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of l in work(ir)
                          ! (workspace: need m*m + bdspac)
                          call stdlib_dbdsqr( 'U', m, m, 0, 0, s, work( ie ),work( ir ), ldwrkr, &
                                    dum, 1, dum, 1,work( iwork ), info )
                          ! multiply right singular vectors of l in work(ir) by
                          ! q in a, storing result in vt
                          ! (workspace: need m*m)
                          call stdlib_dgemm( 'N', 'N', m, n, m, one, work( ir ),ldwrkr, a, lda, &
                                    zero, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_dgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy result to vt
                          call stdlib_dlacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_dorglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_dlaset( 'U', m-1, m-1, zero, zero, a( 1, 2 ),lda )
                          ! bidiagonalize l in a
                          ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                          call stdlib_dgebrd( m, m, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right vectors bidiagonalizing l by q in vt
                          ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                          call stdlib_dormbr( 'P', 'L', 'T', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_dbdsqr( 'U', m, n, 0, 0, s, work( ie ), vt,ldvt, dum, 1, &
                                    dum, 1, work( iwork ),info )
                       end if
                    else if( wntuo ) then
                       ! path 5t(n much larger than m, jobu='o', jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! m left singular vectors to be overwritten on a
                       if( lwork>=2*m*m+max( 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*m ) then
                             ! work(iu) is lda by m and work(ir) is lda by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda + m )*m ) then
                             ! work(iu) is lda by m and work(ir) is m by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          else
                             ! work(iu) is m by m and work(ir) is m by m
                             ldwrku = m
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (workspace: need 2*m*m + 2*m, prefer 2*m*m + m + m*nb)
                          call stdlib_dgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(iu), zeroing out below it
                          call stdlib_dlacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_dlaset( 'U', m-1, m-1, zero, zero,work( iu+ldwrku ), ldwrku &
                                    )
                          ! generate q in a
                          ! (workspace: need 2*m*m + 2*m, prefer 2*m*m + m + m*nb)
                          call stdlib_dorglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to
                          ! work(ir)
                          ! (workspace: need 2*m*m + 4*m,
                                      ! prefer 2*m*m+3*m+2*m*nb)
                          call stdlib_dgebrd( m, m, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_dlacpy( 'L', m, m, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (workspace: need 2*m*m + 4*m-1,
                                      ! prefer 2*m*m+3*m+(m-1)*nb)
                          call stdlib_dorgbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (workspace: need 2*m*m + 4*m, prefer 2*m*m + 3*m + m*nb)
                          call stdlib_dorgbr( 'Q', m, m, m, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in work(ir) and computing
                          ! right singular vectors of l in work(iu)
                          ! (workspace: need 2*m*m + bdspac)
                          call stdlib_dbdsqr( 'U', m, m, m, 0, s, work( ie ),work( iu ), ldwrku, &
                                    work( ir ),ldwrkr, dum, 1, work( iwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in a, storing result in vt
                          ! (workspace: need m*m)
                          call stdlib_dgemm( 'N', 'N', m, n, m, one, work( iu ),ldwrku, a, lda, &
                                    zero, vt, ldvt )
                          ! copy left singular vectors of l to a
                          ! (workspace: need m*m)
                          call stdlib_dlacpy( 'F', m, m, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_dgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_dlacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_dorglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_dlaset( 'U', m-1, m-1, zero, zero, a( 1, 2 ),lda )
                          ! bidiagonalize l in a
                          ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                          call stdlib_dgebrd( m, m, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right vectors bidiagonalizing l by q in vt
                          ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                          call stdlib_dormbr( 'P', 'L', 'T', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors of l in a
                          ! (workspace: need 4*m, prefer 3*m + m*nb)
                          call stdlib_dorgbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, compute left
                          ! singular vectors of a in a and compute right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_dbdsqr( 'U', m, n, m, 0, s, work( ie ), vt,ldvt, a, lda, &
                                    dum, 1, work( iwork ),info )
                       end if
                    else if( wntuas ) then
                       ! path 6t(n much larger than m, jobu='s' or 'a',
                               ! jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! m left singular vectors to be computed in u
                       if( lwork>=m*m+max( 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is lda by m
                             ldwrku = m
                          end if
                          itau = iu + ldwrku*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                          call stdlib_dgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_dlacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_dlaset( 'U', m-1, m-1, zero, zero,work( iu+ldwrku ), ldwrku &
                                    )
                          ! generate q in a
                          ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                          call stdlib_dorglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to u
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + 2*m*nb)
                          call stdlib_dgebrd( m, m, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_dlacpy( 'L', m, m, work( iu ), ldwrku, u,ldu )
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (workspace: need m*m + 4*m-1,
                                      ! prefer m*m+3*m+(m-1)*nb)
                          call stdlib_dorgbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + m*nb)
                          call stdlib_dorgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in u and computing right
                          ! singular vectors of l in work(iu)
                          ! (workspace: need m*m + bdspac)
                          call stdlib_dbdsqr( 'U', m, m, m, 0, s, work( ie ),work( iu ), ldwrku, &
                                    u, ldu, dum, 1,work( iwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in a, storing result in vt
                          ! (workspace: need m*m)
                          call stdlib_dgemm( 'N', 'N', m, n, m, one, work( iu ),ldwrku, a, lda, &
                                    zero, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_dgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_dlacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_dorglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to u, zeroing out above it
                          call stdlib_dlacpy( 'L', m, m, a, lda, u, ldu )
                          if (m>1) call stdlib_dlaset( 'U', m-1, m-1, zero, zero, u( 1, 2 ),ldu )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in u
                          ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                          call stdlib_dgebrd( m, m, u, ldu, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in u by q
                          ! in vt
                          ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                          call stdlib_dormbr( 'P', 'L', 'T', m, n, m, u, ldu,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (workspace: need 4*m, prefer 3*m + m*nb)
                          call stdlib_dorgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_dbdsqr( 'U', m, n, m, 0, s, work( ie ), vt,ldvt, u, ldu, &
                                    dum, 1, work( iwork ),info )
                       end if
                    end if
                 else if( wntva ) then
                    if( wntun ) then
                       ! path 7t(n much larger than m, jobu='n', jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! no left singular vectors to be computed
                       if( lwork>=m*m+max( n + m, 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(ir) is lda by m
                             ldwrkr = lda
                          else
                             ! work(ir) is m by m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                          call stdlib_dgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_dlacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! copy l to work(ir), zeroing out above it
                          call stdlib_dlacpy( 'L', m, m, a, lda, work( ir ),ldwrkr )
                          call stdlib_dlaset( 'U', m-1, m-1, zero, zero,work( ir+ldwrkr ), ldwrkr &
                                    )
                          ! generate q in vt
                          ! (workspace: need m*m + m + n, prefer m*m + m + n*nb)
                          call stdlib_dorglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(ir)
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + 2*m*nb)
                          call stdlib_dgebrd( m, m, work( ir ), ldwrkr, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (workspace: need m*m + 4*m-1,
                                      ! prefer m*m+3*m+(m-1)*nb)
                          call stdlib_dorgbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of l in work(ir)
                          ! (workspace: need m*m + bdspac)
                          call stdlib_dbdsqr( 'U', m, m, 0, 0, s, work( ie ),work( ir ), ldwrkr, &
                                    dum, 1, dum, 1,work( iwork ), info )
                          ! multiply right singular vectors of l in work(ir) by
                          ! q in vt, storing result in a
                          ! (workspace: need m*m)
                          call stdlib_dgemm( 'N', 'N', m, n, m, one, work( ir ),ldwrkr, vt, ldvt, &
                                    zero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_dlacpy( 'F', m, n, a, lda, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_dgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_dlacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need m + n, prefer m + n*nb)
                          call stdlib_dorglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_dlaset( 'U', m-1, m-1, zero, zero, a( 1, 2 ),lda )
                          ! bidiagonalize l in a
                          ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                          call stdlib_dgebrd( m, m, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in a by q
                          ! in vt
                          ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                          call stdlib_dormbr( 'P', 'L', 'T', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_dbdsqr( 'U', m, n, 0, 0, s, work( ie ), vt,ldvt, dum, 1, &
                                    dum, 1, work( iwork ),info )
                       end if
                    else if( wntuo ) then
                       ! path 8t(n much larger than m, jobu='o', jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! m left singular vectors to be overwritten on a
                       if( lwork>=2*m*m+max( n + m, 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*m ) then
                             ! work(iu) is lda by m and work(ir) is lda by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda + m )*m ) then
                             ! work(iu) is lda by m and work(ir) is m by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          else
                             ! work(iu) is m by m and work(ir) is m by m
                             ldwrku = m
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m*m + 2*m, prefer 2*m*m + m + m*nb)
                          call stdlib_dgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_dlacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need 2*m*m + m + n, prefer 2*m*m + m + n*nb)
                          call stdlib_dorglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_dlacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_dlaset( 'U', m-1, m-1, zero, zero,work( iu+ldwrku ), ldwrku &
                                    )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to
                          ! work(ir)
                          ! (workspace: need 2*m*m + 4*m,
                                      ! prefer 2*m*m+3*m+2*m*nb)
                          call stdlib_dgebrd( m, m, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_dlacpy( 'L', m, m, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (workspace: need 2*m*m + 4*m-1,
                                      ! prefer 2*m*m+3*m+(m-1)*nb)
                          call stdlib_dorgbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (workspace: need 2*m*m + 4*m, prefer 2*m*m + 3*m + m*nb)
                          call stdlib_dorgbr( 'Q', m, m, m, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in work(ir) and computing
                          ! right singular vectors of l in work(iu)
                          ! (workspace: need 2*m*m + bdspac)
                          call stdlib_dbdsqr( 'U', m, m, m, 0, s, work( ie ),work( iu ), ldwrku, &
                                    work( ir ),ldwrkr, dum, 1, work( iwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in vt, storing result in a
                          ! (workspace: need m*m)
                          call stdlib_dgemm( 'N', 'N', m, n, m, one, work( iu ),ldwrku, vt, ldvt, &
                                    zero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_dlacpy( 'F', m, n, a, lda, vt, ldvt )
                          ! copy left singular vectors of a from work(ir) to a
                          call stdlib_dlacpy( 'F', m, m, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_dgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_dlacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need m + n, prefer m + n*nb)
                          call stdlib_dorglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_dlaset( 'U', m-1, m-1, zero, zero, a( 1, 2 ),lda )
                          ! bidiagonalize l in a
                          ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                          call stdlib_dgebrd( m, m, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in a by q
                          ! in vt
                          ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                          call stdlib_dormbr( 'P', 'L', 'T', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in a
                          ! (workspace: need 4*m, prefer 3*m + m*nb)
                          call stdlib_dorgbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in a and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_dbdsqr( 'U', m, n, m, 0, s, work( ie ), vt,ldvt, a, lda, &
                                    dum, 1, work( iwork ),info )
                       end if
                    else if( wntuas ) then
                       ! path 9t(n much larger than m, jobu='s' or 'a',
                               ! jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! m left singular vectors to be computed in u
                       if( lwork>=m*m+max( n + m, 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(iu) is lda by m
                             ldwrku = lda
                          else
                             ! work(iu) is m by m
                             ldwrku = m
                          end if
                          itau = iu + ldwrku*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                          call stdlib_dgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_dlacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need m*m + m + n, prefer m*m + m + n*nb)
                          call stdlib_dorglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_dlacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_dlaset( 'U', m-1, m-1, zero, zero,work( iu+ldwrku ), ldwrku &
                                    )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to u
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + 2*m*nb)
                          call stdlib_dgebrd( m, m, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_dlacpy( 'L', m, m, work( iu ), ldwrku, u,ldu )
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + (m-1)*nb)
                          call stdlib_dorgbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + m*nb)
                          call stdlib_dorgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in u and computing right
                          ! singular vectors of l in work(iu)
                          ! (workspace: need m*m + bdspac)
                          call stdlib_dbdsqr( 'U', m, m, m, 0, s, work( ie ),work( iu ), ldwrku, &
                                    u, ldu, dum, 1,work( iwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in vt, storing result in a
                          ! (workspace: need m*m)
                          call stdlib_dgemm( 'N', 'N', m, n, m, one, work( iu ),ldwrku, vt, ldvt, &
                                    zero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_dlacpy( 'F', m, n, a, lda, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_dgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_dlacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need m + n, prefer m + n*nb)
                          call stdlib_dorglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to u, zeroing out above it
                          call stdlib_dlacpy( 'L', m, m, a, lda, u, ldu )
                          if (m>1) call stdlib_dlaset( 'U', m-1, m-1, zero, zero, u( 1, 2 ),ldu )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in u
                          ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                          call stdlib_dgebrd( m, m, u, ldu, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in u by q
                          ! in vt
                          ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                          call stdlib_dormbr( 'P', 'L', 'T', m, n, m, u, ldu,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (workspace: need 4*m, prefer 3*m + m*nb)
                          call stdlib_dorgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_dbdsqr( 'U', m, n, m, 0, s, work( ie ), vt,ldvt, u, ldu, &
                                    dum, 1, work( iwork ),info )
                       end if
                    end if
                 end if
              else
                 ! n < mnthr
                 ! path 10t(n greater than m, but not much larger)
                 ! reduce to bidiagonal form without lq decomposition
                 ie = 1
                 itauq = ie + m
                 itaup = itauq + m
                 iwork = itaup + m
                 ! bidiagonalize a
                 ! (workspace: need 3*m + n, prefer 3*m + (m + n)*nb)
                 call stdlib_dgebrd( m, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                           work( iwork ), lwork-iwork+1,ierr )
                 if( wntuas ) then
                    ! if left singular vectors desired in u, copy result to u
                    ! and generate left bidiagonalizing vectors in u
                    ! (workspace: need 4*m-1, prefer 3*m + (m-1)*nb)
                    call stdlib_dlacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_dorgbr( 'Q', m, m, n, u, ldu, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvas ) then
                    ! if right singular vectors desired in vt, copy result to
                    ! vt and generate right bidiagonalizing vectors in vt
                    ! (workspace: need 3*m + nrvt, prefer 3*m + nrvt*nb)
                    call stdlib_dlacpy( 'U', m, n, a, lda, vt, ldvt )
                    if( wntva )nrvt = n
                    if( wntvs )nrvt = m
                    call stdlib_dorgbr( 'P', nrvt, n, m, vt, ldvt, work( itaup ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntuo ) then
                    ! if left singular vectors desired in a, generate left
                    ! bidiagonalizing vectors in a
                    ! (workspace: need 4*m-1, prefer 3*m + (m-1)*nb)
                    call stdlib_dorgbr( 'Q', m, m, n, a, lda, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvo ) then
                    ! if right singular vectors desired in a, generate right
                    ! bidiagonalizing vectors in a
                    ! (workspace: need 4*m, prefer 3*m + m*nb)
                    call stdlib_dorgbr( 'P', m, n, m, a, lda, work( itaup ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 iwork = ie + m
                 if( wntuas .or. wntuo )nru = m
                 if( wntun )nru = 0
                 if( wntvas .or. wntvo )ncvt = n
                 if( wntvn )ncvt = 0
                 if( ( .not.wntuo ) .and. ( .not.wntvo ) ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in vt
                    ! (workspace: need bdspac)
                    call stdlib_dbdsqr( 'L', m, ncvt, nru, 0, s, work( ie ), vt,ldvt, u, ldu, dum,&
                               1, work( iwork ), info )
                 else if( ( .not.wntuo ) .and. wntvo ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in a
                    ! (workspace: need bdspac)
                    call stdlib_dbdsqr( 'L', m, ncvt, nru, 0, s, work( ie ), a, lda,u, ldu, dum, &
                              1, work( iwork ), info )
                 else
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in a and computing right singular
                    ! vectors in vt
                    ! (workspace: need bdspac)
                    call stdlib_dbdsqr( 'L', m, ncvt, nru, 0, s, work( ie ), vt,ldvt, a, lda, dum,&
                               1, work( iwork ), info )
                 end if
              end if
           end if
           ! if stdlib_dbdsqr failed to converge, copy unconverged superdiagonals
           ! to work( 2:minmn )
           if( info/=0 ) then
              if( ie>2 ) then
                 do i = 1, minmn - 1
                    work( i+1 ) = work( i+ie-1 )
                 end do
              end if
              if( ie<2 ) then
                 do i = minmn - 1, 1, -1
                    work( i+1 ) = work( i+ie-1 )
                 end do
              end if
           end if
           ! undo scaling if necessary
           if( iscl==1 ) then
              if( anrm>bignum )call stdlib_dlascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm>bignum )call stdlib_dlascl( 'G', 0, 0, bignum, anrm, minmn-1,&
                         1, work( 2 ),minmn, ierr )
              if( anrm<smlnum )call stdlib_dlascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm<smlnum )call stdlib_dlascl( 'G', 0, 0, smlnum, anrm, minmn-1,&
                         1, work( 2 ),minmn, ierr )
           end if
           ! return optimal workspace in work(1)
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_dgesvd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$gesvd( jobu, jobvt, m, n, a, lda, s, u, ldu,vt, ldvt, work, lwork, info )
     !! DGESVD: computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, optionally computing the left and/or right singular
     !! vectors. The SVD is written
     !! A = U * SIGMA * transpose(V)
     !! where SIGMA is an M-by-N matrix which is zero except for its
     !! min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
     !! V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
     !! are the singular values of A; they are real and non-negative, and
     !! are returned in descending order.  The first min(m,n) columns of
     !! U and V are the left and right singular vectors of A.
     !! Note that the routine returns V**T, not V.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobu, jobvt
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldvt, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: s(*), u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wntua, wntuas, wntun, wntuo, wntus, wntva, wntvas, wntvn, wntvo,&
                      wntvs
           integer(ilp) :: bdspac, blk, chunk, i, ie, ierr, ir, iscl, itau, itaup, itauq, iu, &
           iwork, ldwrkr, ldwrku, maxwrk, minmn, minwrk, mnthr, ncu, ncvt, nru, nrvt, &
                     wrkbl
           integer(ilp) :: lwork_qgeqrf, lwork_qorgqr_n, lwork_qorgqr_m, lwork_qgebrd, &
                     lwork_qorgbr_p, lwork_qorgbr_q, lwork_qgelqf, lwork_qorglq_n, lwork_qorglq_m
           real(${rk}$) :: anrm, bignum, eps, smlnum
           ! Local Arrays 
           real(${rk}$) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           minmn = min( m, n )
           wntua = stdlib_lsame( jobu, 'A' )
           wntus = stdlib_lsame( jobu, 'S' )
           wntuas = wntua .or. wntus
           wntuo = stdlib_lsame( jobu, 'O' )
           wntun = stdlib_lsame( jobu, 'N' )
           wntva = stdlib_lsame( jobvt, 'A' )
           wntvs = stdlib_lsame( jobvt, 'S' )
           wntvas = wntva .or. wntvs
           wntvo = stdlib_lsame( jobvt, 'O' )
           wntvn = stdlib_lsame( jobvt, 'N' )
           lquery = ( lwork==-1 )
           if( .not.( wntua .or. wntus .or. wntuo .or. wntun ) ) then
              info = -1
           else if( .not.( wntva .or. wntvs .or. wntvo .or. wntvn ) .or.( wntvo .and. wntuo ) ) &
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( ldu<1 .or. ( wntuas .and. ldu<m ) ) then
              info = -9
           else if( ldvt<1 .or. ( wntva .and. ldvt<n ) .or.( wntvs .and. ldvt<minmn ) ) &
                     then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              if( m>=n .and. minmn>0 ) then
                 ! compute space needed for stdlib_${ri}$bdsqr
                 mnthr = stdlib_ilaenv( 6, 'DGESVD', jobu // jobvt, m, n, 0, 0 )
                 bdspac = 5*n
                 ! compute space needed for stdlib_${ri}$geqrf
                 call stdlib_${ri}$geqrf( m, n, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_qgeqrf = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ri}$orgqr
                 call stdlib_${ri}$orgqr( m, n, n, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_qorgqr_n = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$orgqr( m, m, n, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_qorgqr_m = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ri}$gebrd
                 call stdlib_${ri}$gebrd( n, n, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                           
                 lwork_qgebrd = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ri}$orgbr p
                 call stdlib_${ri}$orgbr( 'P', n, n, n, a, lda, dum(1),dum(1), -1, ierr )
                 lwork_qorgbr_p = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ri}$orgbr q
                 call stdlib_${ri}$orgbr( 'Q', n, n, n, a, lda, dum(1),dum(1), -1, ierr )
                 lwork_qorgbr_q = int( dum(1),KIND=ilp)
                 if( m>=mnthr ) then
                    if( wntun ) then
                       ! path 1 (m much larger than n, jobu='n')
                       maxwrk = n + lwork_qgeqrf
                       maxwrk = max( maxwrk, 3*n + lwork_qgebrd )
                       if( wntvo .or. wntvas )maxwrk = max( maxwrk, 3*n + lwork_qorgbr_p )
                       maxwrk = max( maxwrk, bdspac )
                       minwrk = max( 4*n, bdspac )
                    else if( wntuo .and. wntvn ) then
                       ! path 2 (m much larger than n, jobu='o', jobvt='n')
                       wrkbl = n + lwork_qgeqrf
                       wrkbl = max( wrkbl, n + lwork_qorgqr_n )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = max( n*n + wrkbl, n*n + m*n + n )
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntuo .and. wntvas ) then
                       ! path 3 (m much larger than n, jobu='o', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_qgeqrf
                       wrkbl = max( wrkbl, n + lwork_qorgqr_n )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = max( n*n + wrkbl, n*n + m*n + n )
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntus .and. wntvn ) then
                       ! path 4 (m much larger than n, jobu='s', jobvt='n')
                       wrkbl = n + lwork_qgeqrf
                       wrkbl = max( wrkbl, n + lwork_qorgqr_n )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = n*n + wrkbl
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntus .and. wntvo ) then
                       ! path 5 (m much larger than n, jobu='s', jobvt='o')
                       wrkbl = n + lwork_qgeqrf
                       wrkbl = max( wrkbl, n + lwork_qorgqr_n )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = 2*n*n + wrkbl
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntus .and. wntvas ) then
                       ! path 6 (m much larger than n, jobu='s', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_qgeqrf
                       wrkbl = max( wrkbl, n + lwork_qorgqr_n )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = n*n + wrkbl
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntua .and. wntvn ) then
                       ! path 7 (m much larger than n, jobu='a', jobvt='n')
                       wrkbl = n + lwork_qgeqrf
                       wrkbl = max( wrkbl, n + lwork_qorgqr_m )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = n*n + wrkbl
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntua .and. wntvo ) then
                       ! path 8 (m much larger than n, jobu='a', jobvt='o')
                       wrkbl = n + lwork_qgeqrf
                       wrkbl = max( wrkbl, n + lwork_qorgqr_m )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = 2*n*n + wrkbl
                       minwrk = max( 3*n + m, bdspac )
                    else if( wntua .and. wntvas ) then
                       ! path 9 (m much larger than n, jobu='a', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_qgeqrf
                       wrkbl = max( wrkbl, n + lwork_qorgqr_m )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, 3*n + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = n*n + wrkbl
                       minwrk = max( 3*n + m, bdspac )
                    end if
                 else
                    ! path 10 (m at least n, but not much larger)
                    call stdlib_${ri}$gebrd( m, n, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                              
                    lwork_qgebrd = int( dum(1),KIND=ilp)
                    maxwrk = 3*n + lwork_qgebrd
                    if( wntus .or. wntuo ) then
                       call stdlib_${ri}$orgbr( 'Q', m, n, n, a, lda, dum(1),dum(1), -1, ierr )
                       lwork_qorgbr_q = int( dum(1),KIND=ilp)
                       maxwrk = max( maxwrk, 3*n + lwork_qorgbr_q )
                    end if
                    if( wntua ) then
                       call stdlib_${ri}$orgbr( 'Q', m, m, n, a, lda, dum(1),dum(1), -1, ierr )
                       lwork_qorgbr_q = int( dum(1),KIND=ilp)
                       maxwrk = max( maxwrk, 3*n + lwork_qorgbr_q )
                    end if
                    if( .not.wntvn ) then
                      maxwrk = max( maxwrk, 3*n + lwork_qorgbr_p )
                    end if
                    maxwrk = max( maxwrk, bdspac )
                    minwrk = max( 3*n + m, bdspac )
                 end if
              else if( minmn>0 ) then
                 ! compute space needed for stdlib_${ri}$bdsqr
                 mnthr = stdlib_ilaenv( 6, 'DGESVD', jobu // jobvt, m, n, 0, 0 )
                 bdspac = 5*m
                 ! compute space needed for stdlib_${ri}$gelqf
                 call stdlib_${ri}$gelqf( m, n, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_qgelqf = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ri}$orglq
                 call stdlib_${ri}$orglq( n, n, m, dum(1), n, dum(1), dum(1), -1, ierr )
                 lwork_qorglq_n = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$orglq( m, n, m, a, lda, dum(1), dum(1), -1, ierr )
                 lwork_qorglq_m = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ri}$gebrd
                 call stdlib_${ri}$gebrd( m, m, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                           
                 lwork_qgebrd = int( dum(1),KIND=ilp)
                  ! compute space needed for stdlib_${ri}$orgbr p
                 call stdlib_${ri}$orgbr( 'P', m, m, m, a, n, dum(1),dum(1), -1, ierr )
                 lwork_qorgbr_p = int( dum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ri}$orgbr q
                 call stdlib_${ri}$orgbr( 'Q', m, m, m, a, n, dum(1),dum(1), -1, ierr )
                 lwork_qorgbr_q = int( dum(1),KIND=ilp)
                 if( n>=mnthr ) then
                    if( wntvn ) then
                       ! path 1t(n much larger than m, jobvt='n')
                       maxwrk = m + lwork_qgelqf
                       maxwrk = max( maxwrk, 3*m + lwork_qgebrd )
                       if( wntuo .or. wntuas )maxwrk = max( maxwrk, 3*m + lwork_qorgbr_q )
                       maxwrk = max( maxwrk, bdspac )
                       minwrk = max( 4*m, bdspac )
                    else if( wntvo .and. wntun ) then
                       ! path 2t(n much larger than m, jobu='n', jobvt='o')
                       wrkbl = m + lwork_qgelqf
                       wrkbl = max( wrkbl, m + lwork_qorglq_m )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = max( m*m + wrkbl, m*m + m*n + m )
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntvo .and. wntuas ) then
                       ! path 3t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='o')
                       wrkbl = m + lwork_qgelqf
                       wrkbl = max( wrkbl, m + lwork_qorglq_m )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = max( m*m + wrkbl, m*m + m*n + m )
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntvs .and. wntun ) then
                       ! path 4t(n much larger than m, jobu='n', jobvt='s')
                       wrkbl = m + lwork_qgelqf
                       wrkbl = max( wrkbl, m + lwork_qorglq_m )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = m*m + wrkbl
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntvs .and. wntuo ) then
                       ! path 5t(n much larger than m, jobu='o', jobvt='s')
                       wrkbl = m + lwork_qgelqf
                       wrkbl = max( wrkbl, m + lwork_qorglq_m )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = 2*m*m + wrkbl
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntvs .and. wntuas ) then
                       ! path 6t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='s')
                       wrkbl = m + lwork_qgelqf
                       wrkbl = max( wrkbl, m + lwork_qorglq_m )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = m*m + wrkbl
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntva .and. wntun ) then
                       ! path 7t(n much larger than m, jobu='n', jobvt='a')
                       wrkbl = m + lwork_qgelqf
                       wrkbl = max( wrkbl, m + lwork_qorglq_n )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = m*m + wrkbl
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntva .and. wntuo ) then
                       ! path 8t(n much larger than m, jobu='o', jobvt='a')
                       wrkbl = m + lwork_qgelqf
                       wrkbl = max( wrkbl, m + lwork_qorglq_n )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = 2*m*m + wrkbl
                       minwrk = max( 3*m + n, bdspac )
                    else if( wntva .and. wntuas ) then
                       ! path 9t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='a')
                       wrkbl = m + lwork_qgelqf
                       wrkbl = max( wrkbl, m + lwork_qorglq_n )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_p )
                       wrkbl = max( wrkbl, 3*m + lwork_qorgbr_q )
                       wrkbl = max( wrkbl, bdspac )
                       maxwrk = m*m + wrkbl
                       minwrk = max( 3*m + n, bdspac )
                    end if
                 else
                    ! path 10t(n greater than m, but not much larger)
                    call stdlib_${ri}$gebrd( m, n, a, lda, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                              
                    lwork_qgebrd = int( dum(1),KIND=ilp)
                    maxwrk = 3*m + lwork_qgebrd
                    if( wntvs .or. wntvo ) then
                      ! compute space needed for stdlib_${ri}$orgbr p
                      call stdlib_${ri}$orgbr( 'P', m, n, m, a, n, dum(1),dum(1), -1, ierr )
                      lwork_qorgbr_p = int( dum(1),KIND=ilp)
                      maxwrk = max( maxwrk, 3*m + lwork_qorgbr_p )
                    end if
                    if( wntva ) then
                      call stdlib_${ri}$orgbr( 'P', n, n, m, a, n, dum(1),dum(1), -1, ierr )
                      lwork_qorgbr_p = int( dum(1),KIND=ilp)
                      maxwrk = max( maxwrk, 3*m + lwork_qorgbr_p )
                    end if
                    if( .not.wntun ) then
                       maxwrk = max( maxwrk, 3*m + lwork_qorgbr_q )
                    end if
                    maxwrk = max( maxwrk, bdspac )
                    minwrk = max( 3*m + n, bdspac )
                 end if
              end if
              maxwrk = max( maxwrk, minwrk )
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGESVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = sqrt( stdlib_${ri}$lamch( 'S' ) ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', m, n, a, lda, dum )
           iscl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              iscl = 1
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, ierr )
           else if( anrm>bignum ) then
              iscl = 1
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, ierr )
           end if
           if( m>=n ) then
              ! a has at least as many rows as columns. if a has sufficiently
              ! more rows than columns, first reduce using the qr
              ! decomposition (if sufficient workspace available)
              if( m>=mnthr ) then
                 if( wntun ) then
                    ! path 1 (m much larger than n, jobu='n')
                    ! no left singular vectors to be computed
                    itau = 1
                    iwork = itau + n
                    ! compute a=q*r
                    ! (workspace: need 2*n, prefer n + n*nb)
                    call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, &
                              ierr )
                    ! zero out below r
                    if( n > 1 ) then
                       call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero, a( 2, 1 ),lda )
                    end if
                    ie = 1
                    itauq = ie + n
                    itaup = itauq + n
                    iwork = itaup + n
                    ! bidiagonalize r in a
                    ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                    call stdlib_${ri}$gebrd( n, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( iwork ), lwork-iwork+1,ierr )
                    ncvt = 0
                    if( wntvo .or. wntvas ) then
                       ! if right singular vectors desired, generate p'.
                       ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                       call stdlib_${ri}$orgbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       ncvt = n
                    end if
                    iwork = ie + n
                    ! perform bidiagonal qr iteration, computing right
                    ! singular vectors of a in a if desired
                    ! (workspace: need bdspac)
                    call stdlib_${ri}$bdsqr( 'U', n, ncvt, 0, 0, s, work( ie ), a, lda,dum, 1, dum, 1, &
                              work( iwork ), info )
                    ! if right singular vectors desired in vt, copy them there
                    if( wntvas )call stdlib_${ri}$lacpy( 'F', n, n, a, lda, vt, ldvt )
                 else if( wntuo .and. wntvn ) then
                    ! path 2 (m much larger than n, jobu='o', jobvt='n')
                    ! n left singular vectors to be overwritten on a and
                    ! no right singular vectors to be computed
                    if( lwork>=n*n+max( 4*n, bdspac ) ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n + n ) + lda*n ) then
                          ! work(iu) is lda by n, work(ir) is lda by n
                          ldwrku = lda
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n + n ) + n*n ) then
                          ! work(iu) is lda by n, work(ir) is n by n
                          ldwrku = lda
                          ldwrkr = n
                       else
                          ! work(iu) is ldwrku by n, work(ir) is n by n
                          ldwrku = ( lwork-n*n-n ) / n
                          ldwrkr = n
                       end if
                       itau = ir + ldwrkr*n
                       iwork = itau + n
                       ! compute a=q*r
                       ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                       call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to work(ir) and zero out below it
                       call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                       call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero, work( ir+1 ),ldwrkr )
                                 
                       ! generate q in a
                       ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                       call stdlib_${ri}$orgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + n
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in work(ir)
                       ! (workspace: need n*n + 4*n, prefer n*n + 3*n + 2*n*nb)
                       call stdlib_${ri}$gebrd( n, n, work( ir ), ldwrkr, s, work( ie ),work( itauq ), &
                                 work( itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing r
                       ! (workspace: need n*n + 4*n, prefer n*n + 3*n + n*nb)
                       call stdlib_${ri}$orgbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       iwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of r in work(ir)
                       ! (workspace: need n*n + bdspac)
                       call stdlib_${ri}$bdsqr( 'U', n, 0, n, 0, s, work( ie ), dum, 1,work( ir ), &
                                 ldwrkr, dum, 1,work( iwork ), info )
                       iu = ie + n
                       ! multiply q in a by left singular vectors of r in
                       ! work(ir), storing result in work(iu) and copying to a
                       ! (workspace: need n*n + 2*n, prefer n*n + m*n + n)
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_${ri}$gemm( 'N', 'N', chunk, n, n, one, a( i, 1 ),lda, work( ir )&
                                    , ldwrkr, zero,work( iu ), ldwrku )
                          call stdlib_${ri}$lacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       ie = 1
                       itauq = ie + n
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize a
                       ! (workspace: need 3*n + m, prefer 3*n + (m + n)*nb)
                       call stdlib_${ri}$gebrd( m, n, a, lda, s, work( ie ),work( itauq ), work( itaup &
                                 ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing a
                       ! (workspace: need 4*n, prefer 3*n + n*nb)
                       call stdlib_${ri}$orgbr( 'Q', m, n, n, a, lda, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in a
                       ! (workspace: need bdspac)
                       call stdlib_${ri}$bdsqr( 'U', n, 0, m, 0, s, work( ie ), dum, 1,a, lda, dum, 1, &
                                 work( iwork ), info )
                    end if
                 else if( wntuo .and. wntvas ) then
                    ! path 3 (m much larger than n, jobu='o', jobvt='s' or 'a')
                    ! n left singular vectors to be overwritten on a and
                    ! n right singular vectors to be computed in vt
                    if( lwork>=n*n+max( 4*n, bdspac ) ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n + n ) + lda*n ) then
                          ! work(iu) is lda by n and work(ir) is lda by n
                          ldwrku = lda
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n + n ) + n*n ) then
                          ! work(iu) is lda by n and work(ir) is n by n
                          ldwrku = lda
                          ldwrkr = n
                       else
                          ! work(iu) is ldwrku by n and work(ir) is n by n
                          ldwrku = ( lwork-n*n-n ) / n
                          ldwrkr = n
                       end if
                       itau = ir + ldwrkr*n
                       iwork = itau + n
                       ! compute a=q*r
                       ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                       call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to vt, zeroing out below it
                       call stdlib_${ri}$lacpy( 'U', n, n, a, lda, vt, ldvt )
                       if( n>1 )call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,vt( 2, 1 ), ldvt )
                                 
                       ! generate q in a
                       ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                       call stdlib_${ri}$orgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + n
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in vt, copying result to work(ir)
                       ! (workspace: need n*n + 4*n, prefer n*n + 3*n + 2*n*nb)
                       call stdlib_${ri}$gebrd( n, n, vt, ldvt, s, work( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       call stdlib_${ri}$lacpy( 'L', n, n, vt, ldvt, work( ir ), ldwrkr )
                       ! generate left vectors bidiagonalizing r in work(ir)
                       ! (workspace: need n*n + 4*n, prefer n*n + 3*n + n*nb)
                       call stdlib_${ri}$orgbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing r in vt
                       ! (workspace: need n*n + 4*n-1, prefer n*n + 3*n + (n-1)*nb)
                       call stdlib_${ri}$orgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of r in work(ir) and computing right
                       ! singular vectors of r in vt
                       ! (workspace: need n*n + bdspac)
                       call stdlib_${ri}$bdsqr( 'U', n, n, n, 0, s, work( ie ), vt, ldvt,work( ir ), &
                                 ldwrkr, dum, 1,work( iwork ), info )
                       iu = ie + n
                       ! multiply q in a by left singular vectors of r in
                       ! work(ir), storing result in work(iu) and copying to a
                       ! (workspace: need n*n + 2*n, prefer n*n + m*n + n)
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_${ri}$gemm( 'N', 'N', chunk, n, n, one, a( i, 1 ),lda, work( ir )&
                                    , ldwrkr, zero,work( iu ), ldwrku )
                          call stdlib_${ri}$lacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       itau = 1
                       iwork = itau + n
                       ! compute a=q*r
                       ! (workspace: need 2*n, prefer n + n*nb)
                       call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to vt, zeroing out below it
                       call stdlib_${ri}$lacpy( 'U', n, n, a, lda, vt, ldvt )
                       if( n>1 )call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,vt( 2, 1 ), ldvt )
                                 
                       ! generate q in a
                       ! (workspace: need 2*n, prefer n + n*nb)
                       call stdlib_${ri}$orgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + n
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in vt
                       ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                       call stdlib_${ri}$gebrd( n, n, vt, ldvt, s, work( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! multiply q in a by left vectors bidiagonalizing r
                       ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                       call stdlib_${ri}$ormbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), a, lda,&
                                  work( iwork ),lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing r in vt
                       ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                       call stdlib_${ri}$orgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in a and computing right
                       ! singular vectors of a in vt
                       ! (workspace: need bdspac)
                       call stdlib_${ri}$bdsqr( 'U', n, n, m, 0, s, work( ie ), vt, ldvt,a, lda, dum, &
                                 1, work( iwork ), info )
                    end if
                 else if( wntus ) then
                    if( wntvn ) then
                       ! path 4 (m much larger than n, jobu='s', jobvt='n')
                       ! n left singular vectors to be computed in u and
                       ! no right singular vectors to be computed
                       if( lwork>=n*n+max( 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(ir) is lda by n
                             ldwrkr = lda
                          else
                             ! work(ir) is n by n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(ir), zeroing out below it
                          call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work( ir ),ldwrkr )
                          call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,work( ir+1 ), ldwrkr )
                                    
                          ! generate q in a
                          ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                          call stdlib_${ri}$orgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(ir)
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, work( ir ), ldwrkr, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate left vectors bidiagonalizing r in work(ir)
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + n*nb)
                          call stdlib_${ri}$orgbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(ir)
                          ! (workspace: need n*n + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, 0, n, 0, s, work( ie ), dum,1, work( ir ), &
                                    ldwrkr, dum, 1,work( iwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(ir), storing result in u
                          ! (workspace: need n*n)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, n, one, a, lda,work( ir ), ldwrkr, &
                                    zero, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_${ri}$orgqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left vectors bidiagonalizing r
                          ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                          call stdlib_${ri}$ormbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, 0, m, 0, s, work( ie ), dum,1, u, ldu, dum, &
                                    1, work( iwork ),info )
                       end if
                    else if( wntvo ) then
                       ! path 5 (m much larger than n, jobu='s', jobvt='o')
                       ! n left singular vectors to be computed in u and
                       ! n right singular vectors to be overwritten on a
                       if( lwork>=2*n*n+max( 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*n ) then
                             ! work(iu) is lda by n and work(ir) is lda by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda + n )*n ) then
                             ! work(iu) is lda by n and work(ir) is n by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          else
                             ! work(iu) is n by n and work(ir) is n by n
                             ldwrku = n
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (workspace: need 2*n*n + 2*n, prefer 2*n*n + n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,work( iu+1 ), ldwrku )
                                    
                          ! generate q in a
                          ! (workspace: need 2*n*n + 2*n, prefer 2*n*n + n + n*nb)
                          call stdlib_${ri}$orgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to
                          ! work(ir)
                          ! (workspace: need 2*n*n + 4*n,
                                      ! prefer 2*n*n+3*n+2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', n, n, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (workspace: need 2*n*n + 4*n, prefer 2*n*n + 3*n + n*nb)
                          call stdlib_${ri}$orgbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (workspace: need 2*n*n + 4*n-1,
                                      ! prefer 2*n*n+3*n+(n-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in work(ir)
                          ! (workspace: need 2*n*n + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, n, n, 0, s, work( ie ),work( ir ), ldwrkr, &
                                    work( iu ),ldwrku, dum, 1, work( iwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(iu), storing result in u
                          ! (workspace: need n*n)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, n, one, a, lda,work( iu ), ldwrku, &
                                    zero, u, ldu )
                          ! copy right singular vectors of r to a
                          ! (workspace: need n*n)
                          call stdlib_${ri}$lacpy( 'F', n, n, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_${ri}$orgqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left vectors bidiagonalizing r
                          ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                          call stdlib_${ri}$ormbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right vectors bidiagonalizing r in a
                          ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in a
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, n, m, 0, s, work( ie ), a,lda, u, ldu, dum, &
                                    1, work( iwork ),info )
                       end if
                    else if( wntvas ) then
                       ! path 6 (m much larger than n, jobu='s', jobvt='s'
                               ! or 'a')
                       ! n left singular vectors to be computed in u and
                       ! n right singular vectors to be computed in vt
                       if( lwork>=n*n+max( 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is n by n
                             ldwrku = n
                          end if
                          itau = iu + ldwrku*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,work( iu+1 ), ldwrku )
                                    
                          ! generate q in a
                          ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                          call stdlib_${ri}$orgqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to vt
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', n, n, work( iu ), ldwrku, vt,ldvt )
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + n*nb)
                          call stdlib_${ri}$orgbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (workspace: need n*n + 4*n-1,
                                      ! prefer n*n+3*n+(n-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in vt
                          ! (workspace: need n*n + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, n, n, 0, s, work( ie ), vt,ldvt, work( iu ),&
                                     ldwrku, dum, 1,work( iwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(iu), storing result in u
                          ! (workspace: need n*n)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, n, one, a, lda,work( iu ), ldwrku, &
                                    zero, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_${ri}$orgqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to vt, zeroing out below it
                          call stdlib_${ri}$lacpy( 'U', n, n, a, lda, vt, ldvt )
                          if( n>1 )call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,vt( 2, 1 ), ldvt &
                                    )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in vt
                          ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, vt, ldvt, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in vt
                          ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                          call stdlib_${ri}$ormbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, n, m, 0, s, work( ie ), vt,ldvt, u, ldu, &
                                    dum, 1, work( iwork ),info )
                       end if
                    end if
                 else if( wntua ) then
                    if( wntvn ) then
                       ! path 7 (m much larger than n, jobu='a', jobvt='n')
                       ! m left singular vectors to be computed in u and
                       ! no right singular vectors to be computed
                       if( lwork>=n*n+max( n+m, 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(ir) is lda by n
                             ldwrkr = lda
                          else
                             ! work(ir) is n by n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! copy r to work(ir), zeroing out below it
                          call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work( ir ),ldwrkr )
                          call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,work( ir+1 ), ldwrkr )
                                    
                          ! generate q in u
                          ! (workspace: need n*n + n + m, prefer n*n + n + m*nb)
                          call stdlib_${ri}$orgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(ir)
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, work( ir ), ldwrkr, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + n*nb)
                          call stdlib_${ri}$orgbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(ir)
                          ! (workspace: need n*n + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, 0, n, 0, s, work( ie ), dum,1, work( ir ), &
                                    ldwrkr, dum, 1,work( iwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(ir), storing result in a
                          ! (workspace: need n*n)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, n, one, u, ldu,work( ir ), ldwrkr, &
                                    zero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_${ri}$lacpy( 'F', m, n, a, lda, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need n + m, prefer n + m*nb)
                          call stdlib_${ri}$orgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in a
                          ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                          call stdlib_${ri}$ormbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, 0, m, 0, s, work( ie ), dum,1, u, ldu, dum, &
                                    1, work( iwork ),info )
                       end if
                    else if( wntvo ) then
                       ! path 8 (m much larger than n, jobu='a', jobvt='o')
                       ! m left singular vectors to be computed in u and
                       ! n right singular vectors to be overwritten on a
                       if( lwork>=2*n*n+max( n+m, 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*n ) then
                             ! work(iu) is lda by n and work(ir) is lda by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda + n )*n ) then
                             ! work(iu) is lda by n and work(ir) is n by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          else
                             ! work(iu) is n by n and work(ir) is n by n
                             ldwrku = n
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n*n + 2*n, prefer 2*n*n + n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need 2*n*n + n + m, prefer 2*n*n + n + m*nb)
                          call stdlib_${ri}$orgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,work( iu+1 ), ldwrku )
                                    
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to
                          ! work(ir)
                          ! (workspace: need 2*n*n + 4*n,
                                      ! prefer 2*n*n+3*n+2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', n, n, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (workspace: need 2*n*n + 4*n, prefer 2*n*n + 3*n + n*nb)
                          call stdlib_${ri}$orgbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (workspace: need 2*n*n + 4*n-1,
                                      ! prefer 2*n*n+3*n+(n-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in work(ir)
                          ! (workspace: need 2*n*n + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, n, n, 0, s, work( ie ),work( ir ), ldwrkr, &
                                    work( iu ),ldwrku, dum, 1, work( iwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(iu), storing result in a
                          ! (workspace: need n*n)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, n, one, u, ldu,work( iu ), ldwrku, &
                                    zero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_${ri}$lacpy( 'F', m, n, a, lda, u, ldu )
                          ! copy right singular vectors of r from work(ir) to a
                          call stdlib_${ri}$lacpy( 'F', n, n, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need n + m, prefer n + m*nb)
                          call stdlib_${ri}$orgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in a
                          ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                          call stdlib_${ri}$ormbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in a
                          ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in a
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, n, m, 0, s, work( ie ), a,lda, u, ldu, dum, &
                                    1, work( iwork ),info )
                       end if
                    else if( wntvas ) then
                       ! path 9 (m much larger than n, jobu='a', jobvt='s'
                               ! or 'a')
                       ! m left singular vectors to be computed in u and
                       ! n right singular vectors to be computed in vt
                       if( lwork>=n*n+max( n+m, 4*n, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is n by n
                             ldwrku = n
                          end if
                          itau = iu + ldwrku*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need n*n + 2*n, prefer n*n + n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need n*n + n + m, prefer n*n + n + m*nb)
                          call stdlib_${ri}$orgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,work( iu+1 ), ldwrku )
                                    
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to vt
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', n, n, work( iu ), ldwrku, vt,ldvt )
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (workspace: need n*n + 4*n, prefer n*n + 3*n + n*nb)
                          call stdlib_${ri}$orgbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (workspace: need n*n + 4*n-1,
                                      ! prefer n*n+3*n+(n-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in vt
                          ! (workspace: need n*n + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, n, n, 0, s, work( ie ), vt,ldvt, work( iu ),&
                                     ldwrku, dum, 1,work( iwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(iu), storing result in a
                          ! (workspace: need n*n)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, n, one, u, ldu,work( iu ), ldwrku, &
                                    zero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_${ri}$lacpy( 'F', m, n, a, lda, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (workspace: need 2*n, prefer n + n*nb)
                          call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (workspace: need n + m, prefer n + m*nb)
                          call stdlib_${ri}$orgqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r from a to vt, zeroing out below it
                          call stdlib_${ri}$lacpy( 'U', n, n, a, lda, vt, ldvt )
                          if( n>1 )call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero,vt( 2, 1 ), ldvt &
                                    )
                          ie = itau
                          itauq = ie + n
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in vt
                          ! (workspace: need 4*n, prefer 3*n + 2*n*nb)
                          call stdlib_${ri}$gebrd( n, n, vt, ldvt, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in vt
                          ! (workspace: need 3*n + m, prefer 3*n + m*nb)
                          call stdlib_${ri}$ormbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          iwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', n, n, m, 0, s, work( ie ), vt,ldvt, u, ldu, &
                                    dum, 1, work( iwork ),info )
                       end if
                    end if
                 end if
              else
                 ! m < mnthr
                 ! path 10 (m at least n, but not much larger)
                 ! reduce to bidiagonal form without qr decomposition
                 ie = 1
                 itauq = ie + n
                 itaup = itauq + n
                 iwork = itaup + n
                 ! bidiagonalize a
                 ! (workspace: need 3*n + m, prefer 3*n + (m + n)*nb)
                 call stdlib_${ri}$gebrd( m, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                           work( iwork ), lwork-iwork+1,ierr )
                 if( wntuas ) then
                    ! if left singular vectors desired in u, copy result to u
                    ! and generate left bidiagonalizing vectors in u
                    ! (workspace: need 3*n + ncu, prefer 3*n + ncu*nb)
                    call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                    if( wntus )ncu = n
                    if( wntua )ncu = m
                    call stdlib_${ri}$orgbr( 'Q', m, ncu, n, u, ldu, work( itauq ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntvas ) then
                    ! if right singular vectors desired in vt, copy result to
                    ! vt and generate right bidiagonalizing vectors in vt
                    ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                    call stdlib_${ri}$lacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_${ri}$orgbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntuo ) then
                    ! if left singular vectors desired in a, generate left
                    ! bidiagonalizing vectors in a
                    ! (workspace: need 4*n, prefer 3*n + n*nb)
                    call stdlib_${ri}$orgbr( 'Q', m, n, n, a, lda, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvo ) then
                    ! if right singular vectors desired in a, generate right
                    ! bidiagonalizing vectors in a
                    ! (workspace: need 4*n-1, prefer 3*n + (n-1)*nb)
                    call stdlib_${ri}$orgbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 iwork = ie + n
                 if( wntuas .or. wntuo )nru = m
                 if( wntun )nru = 0
                 if( wntvas .or. wntvo )ncvt = n
                 if( wntvn )ncvt = 0
                 if( ( .not.wntuo ) .and. ( .not.wntvo ) ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in vt
                    ! (workspace: need bdspac)
                    call stdlib_${ri}$bdsqr( 'U', n, ncvt, nru, 0, s, work( ie ), vt,ldvt, u, ldu, dum,&
                               1, work( iwork ), info )
                 else if( ( .not.wntuo ) .and. wntvo ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in a
                    ! (workspace: need bdspac)
                    call stdlib_${ri}$bdsqr( 'U', n, ncvt, nru, 0, s, work( ie ), a, lda,u, ldu, dum, &
                              1, work( iwork ), info )
                 else
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in a and computing right singular
                    ! vectors in vt
                    ! (workspace: need bdspac)
                    call stdlib_${ri}$bdsqr( 'U', n, ncvt, nru, 0, s, work( ie ), vt,ldvt, a, lda, dum,&
                               1, work( iwork ), info )
                 end if
              end if
           else
              ! a has more columns than rows. if a has sufficiently more
              ! columns than rows, first reduce using the lq decomposition (if
              ! sufficient workspace available)
              if( n>=mnthr ) then
                 if( wntvn ) then
                    ! path 1t(n much larger than m, jobvt='n')
                    ! no right singular vectors to be computed
                    itau = 1
                    iwork = itau + m
                    ! compute a=l*q
                    ! (workspace: need 2*m, prefer m + m*nb)
                    call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, &
                              ierr )
                    ! zero out above l
                    if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, a( 1, 2 ), lda )
                    ie = 1
                    itauq = ie + m
                    itaup = itauq + m
                    iwork = itaup + m
                    ! bidiagonalize l in a
                    ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                    call stdlib_${ri}$gebrd( m, m, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( iwork ), lwork-iwork+1,ierr )
                    if( wntuo .or. wntuas ) then
                       ! if left singular vectors desired, generate q
                       ! (workspace: need 4*m, prefer 3*m + m*nb)
                       call stdlib_${ri}$orgbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                    end if
                    iwork = ie + m
                    nru = 0
                    if( wntuo .or. wntuas )nru = m
                    ! perform bidiagonal qr iteration, computing left singular
                    ! vectors of a in a if desired
                    ! (workspace: need bdspac)
                    call stdlib_${ri}$bdsqr( 'U', m, 0, nru, 0, s, work( ie ), dum, 1, a,lda, dum, 1, &
                              work( iwork ), info )
                    ! if left singular vectors desired in u, copy them there
                    if( wntuas )call stdlib_${ri}$lacpy( 'F', m, m, a, lda, u, ldu )
                 else if( wntvo .and. wntun ) then
                    ! path 2t(n much larger than m, jobu='n', jobvt='o')
                    ! m right singular vectors to be overwritten on a and
                    ! no left singular vectors to be computed
                    if( lwork>=m*m+max( 4*m, bdspac ) ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n + m ) + lda*m ) then
                          ! work(iu) is lda by n and work(ir) is lda by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n + m ) + m*m ) then
                          ! work(iu) is lda by n and work(ir) is m by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = m
                       else
                          ! work(iu) is m by chunk and work(ir) is m by m
                          ldwrku = m
                          chunk = ( lwork-m*m-m ) / m
                          ldwrkr = m
                       end if
                       itau = ir + ldwrkr*m
                       iwork = itau + m
                       ! compute a=l*q
                       ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                       call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to work(ir) and zero out above it
                       call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( ir ), ldwrkr )
                       call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero,work( ir+ldwrkr ), ldwrkr )
                                 
                       ! generate q in a
                       ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                       call stdlib_${ri}$orglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + m
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in work(ir)
                       ! (workspace: need m*m + 4*m, prefer m*m + 3*m + 2*m*nb)
                       call stdlib_${ri}$gebrd( m, m, work( ir ), ldwrkr, s, work( ie ),work( itauq ), &
                                 work( itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing l
                       ! (workspace: need m*m + 4*m-1, prefer m*m + 3*m + (m-1)*nb)
                       call stdlib_${ri}$orgbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       iwork = ie + m
                       ! perform bidiagonal qr iteration, computing right
                       ! singular vectors of l in work(ir)
                       ! (workspace: need m*m + bdspac)
                       call stdlib_${ri}$bdsqr( 'U', m, m, 0, 0, s, work( ie ),work( ir ), ldwrkr, dum,&
                                  1, dum, 1,work( iwork ), info )
                       iu = ie + m
                       ! multiply right singular vectors of l in work(ir) by q
                       ! in a, storing result in work(iu) and copying to a
                       ! (workspace: need m*m + 2*m, prefer m*m + m*n + m)
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_${ri}$gemm( 'N', 'N', m, blk, m, one, work( ir ),ldwrkr, a( 1, i &
                                    ), lda, zero,work( iu ), ldwrku )
                          call stdlib_${ri}$lacpy( 'F', m, blk, work( iu ), ldwrku,a( 1, i ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       ie = 1
                       itauq = ie + m
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize a
                       ! (workspace: need 3*m + n, prefer 3*m + (m + n)*nb)
                       call stdlib_${ri}$gebrd( m, n, a, lda, s, work( ie ),work( itauq ), work( itaup &
                                 ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing a
                       ! (workspace: need 4*m, prefer 3*m + m*nb)
                       call stdlib_${ri}$orgbr( 'P', m, n, m, a, lda, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + m
                       ! perform bidiagonal qr iteration, computing right
                       ! singular vectors of a in a
                       ! (workspace: need bdspac)
                       call stdlib_${ri}$bdsqr( 'L', m, n, 0, 0, s, work( ie ), a, lda,dum, 1, dum, 1, &
                                 work( iwork ), info )
                    end if
                 else if( wntvo .and. wntuas ) then
                    ! path 3t(n much larger than m, jobu='s' or 'a', jobvt='o')
                    ! m right singular vectors to be overwritten on a and
                    ! m left singular vectors to be computed in u
                    if( lwork>=m*m+max( 4*m, bdspac ) ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n + m ) + lda*m ) then
                          ! work(iu) is lda by n and work(ir) is lda by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n + m ) + m*m ) then
                          ! work(iu) is lda by n and work(ir) is m by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = m
                       else
                          ! work(iu) is m by chunk and work(ir) is m by m
                          ldwrku = m
                          chunk = ( lwork-m*m-m ) / m
                          ldwrkr = m
                       end if
                       itau = ir + ldwrkr*m
                       iwork = itau + m
                       ! compute a=l*q
                       ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                       call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to u, zeroing about above it
                       call stdlib_${ri}$lacpy( 'L', m, m, a, lda, u, ldu )
                       if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, u( 1, 2 ),ldu )
                       ! generate q in a
                       ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                       call stdlib_${ri}$orglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + m
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in u, copying result to work(ir)
                       ! (workspace: need m*m + 4*m, prefer m*m + 3*m + 2*m*nb)
                       call stdlib_${ri}$gebrd( m, m, u, ldu, s, work( ie ),work( itauq ), work( itaup &
                                 ),work( iwork ), lwork-iwork+1, ierr )
                       call stdlib_${ri}$lacpy( 'U', m, m, u, ldu, work( ir ), ldwrkr )
                       ! generate right vectors bidiagonalizing l in work(ir)
                       ! (workspace: need m*m + 4*m-1, prefer m*m + 3*m + (m-1)*nb)
                       call stdlib_${ri}$orgbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing l in u
                       ! (workspace: need m*m + 4*m, prefer m*m + 3*m + m*nb)
                       call stdlib_${ri}$orgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + m
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of l in u, and computing right
                       ! singular vectors of l in work(ir)
                       ! (workspace: need m*m + bdspac)
                       call stdlib_${ri}$bdsqr( 'U', m, m, m, 0, s, work( ie ),work( ir ), ldwrkr, u, &
                                 ldu, dum, 1,work( iwork ), info )
                       iu = ie + m
                       ! multiply right singular vectors of l in work(ir) by q
                       ! in a, storing result in work(iu) and copying to a
                       ! (workspace: need m*m + 2*m, prefer m*m + m*n + m))
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_${ri}$gemm( 'N', 'N', m, blk, m, one, work( ir ),ldwrkr, a( 1, i &
                                    ), lda, zero,work( iu ), ldwrku )
                          call stdlib_${ri}$lacpy( 'F', m, blk, work( iu ), ldwrku,a( 1, i ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       itau = 1
                       iwork = itau + m
                       ! compute a=l*q
                       ! (workspace: need 2*m, prefer m + m*nb)
                       call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to u, zeroing out above it
                       call stdlib_${ri}$lacpy( 'L', m, m, a, lda, u, ldu )
                       if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, u( 1, 2 ),ldu )
                       ! generate q in a
                       ! (workspace: need 2*m, prefer m + m*nb)
                       call stdlib_${ri}$orglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = itau
                       itauq = ie + m
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in u
                       ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                       call stdlib_${ri}$gebrd( m, m, u, ldu, s, work( ie ),work( itauq ), work( itaup &
                                 ),work( iwork ), lwork-iwork+1, ierr )
                       ! multiply right vectors bidiagonalizing l by q in a
                       ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                       call stdlib_${ri}$ormbr( 'P', 'L', 'T', m, n, m, u, ldu,work( itaup ), a, lda, &
                                 work( iwork ),lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing l in u
                       ! (workspace: need 4*m, prefer 3*m + m*nb)
                       call stdlib_${ri}$orgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       iwork = ie + m
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in u and computing right
                       ! singular vectors of a in a
                       ! (workspace: need bdspac)
                       call stdlib_${ri}$bdsqr( 'U', m, n, m, 0, s, work( ie ), a, lda,u, ldu, dum, 1, &
                                 work( iwork ), info )
                    end if
                 else if( wntvs ) then
                    if( wntun ) then
                       ! path 4t(n much larger than m, jobu='n', jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! no left singular vectors to be computed
                       if( lwork>=m*m+max( 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(ir) is lda by m
                             ldwrkr = lda
                          else
                             ! work(ir) is m by m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(ir), zeroing out above it
                          call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( ir ),ldwrkr )
                          call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero,work( ir+ldwrkr ), ldwrkr &
                                    )
                          ! generate q in a
                          ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                          call stdlib_${ri}$orglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(ir)
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, work( ir ), ldwrkr, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate right vectors bidiagonalizing l in
                          ! work(ir)
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + (m-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of l in work(ir)
                          ! (workspace: need m*m + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, m, 0, 0, s, work( ie ),work( ir ), ldwrkr, &
                                    dum, 1, dum, 1,work( iwork ), info )
                          ! multiply right singular vectors of l in work(ir) by
                          ! q in a, storing result in vt
                          ! (workspace: need m*m)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, m, one, work( ir ),ldwrkr, a, lda, &
                                    zero, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy result to vt
                          call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_${ri}$orglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, a( 1, 2 ),lda )
                          ! bidiagonalize l in a
                          ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right vectors bidiagonalizing l by q in vt
                          ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                          call stdlib_${ri}$ormbr( 'P', 'L', 'T', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, n, 0, 0, s, work( ie ), vt,ldvt, dum, 1, &
                                    dum, 1, work( iwork ),info )
                       end if
                    else if( wntuo ) then
                       ! path 5t(n much larger than m, jobu='o', jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! m left singular vectors to be overwritten on a
                       if( lwork>=2*m*m+max( 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*m ) then
                             ! work(iu) is lda by m and work(ir) is lda by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda + m )*m ) then
                             ! work(iu) is lda by m and work(ir) is m by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          else
                             ! work(iu) is m by m and work(ir) is m by m
                             ldwrku = m
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (workspace: need 2*m*m + 2*m, prefer 2*m*m + m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(iu), zeroing out below it
                          call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero,work( iu+ldwrku ), ldwrku &
                                    )
                          ! generate q in a
                          ! (workspace: need 2*m*m + 2*m, prefer 2*m*m + m + m*nb)
                          call stdlib_${ri}$orglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to
                          ! work(ir)
                          ! (workspace: need 2*m*m + 4*m,
                                      ! prefer 2*m*m+3*m+2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, m, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (workspace: need 2*m*m + 4*m-1,
                                      ! prefer 2*m*m+3*m+(m-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (workspace: need 2*m*m + 4*m, prefer 2*m*m + 3*m + m*nb)
                          call stdlib_${ri}$orgbr( 'Q', m, m, m, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in work(ir) and computing
                          ! right singular vectors of l in work(iu)
                          ! (workspace: need 2*m*m + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, m, m, 0, s, work( ie ),work( iu ), ldwrku, &
                                    work( ir ),ldwrkr, dum, 1, work( iwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in a, storing result in vt
                          ! (workspace: need m*m)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, m, one, work( iu ),ldwrku, a, lda, &
                                    zero, vt, ldvt )
                          ! copy left singular vectors of l to a
                          ! (workspace: need m*m)
                          call stdlib_${ri}$lacpy( 'F', m, m, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_${ri}$orglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, a( 1, 2 ),lda )
                          ! bidiagonalize l in a
                          ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right vectors bidiagonalizing l by q in vt
                          ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                          call stdlib_${ri}$ormbr( 'P', 'L', 'T', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors of l in a
                          ! (workspace: need 4*m, prefer 3*m + m*nb)
                          call stdlib_${ri}$orgbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, compute left
                          ! singular vectors of a in a and compute right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, n, m, 0, s, work( ie ), vt,ldvt, a, lda, &
                                    dum, 1, work( iwork ),info )
                       end if
                    else if( wntuas ) then
                       ! path 6t(n much larger than m, jobu='s' or 'a',
                               ! jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! m left singular vectors to be computed in u
                       if( lwork>=m*m+max( 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is lda by m
                             ldwrku = m
                          end if
                          itau = iu + ldwrku*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero,work( iu+ldwrku ), ldwrku &
                                    )
                          ! generate q in a
                          ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                          call stdlib_${ri}$orglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to u
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, m, work( iu ), ldwrku, u,ldu )
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (workspace: need m*m + 4*m-1,
                                      ! prefer m*m+3*m+(m-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + m*nb)
                          call stdlib_${ri}$orgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in u and computing right
                          ! singular vectors of l in work(iu)
                          ! (workspace: need m*m + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, m, m, 0, s, work( ie ),work( iu ), ldwrku, &
                                    u, ldu, dum, 1,work( iwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in a, storing result in vt
                          ! (workspace: need m*m)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, m, one, work( iu ),ldwrku, a, lda, &
                                    zero, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_${ri}$orglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to u, zeroing out above it
                          call stdlib_${ri}$lacpy( 'L', m, m, a, lda, u, ldu )
                          if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, u( 1, 2 ),ldu )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in u
                          ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, u, ldu, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in u by q
                          ! in vt
                          ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                          call stdlib_${ri}$ormbr( 'P', 'L', 'T', m, n, m, u, ldu,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (workspace: need 4*m, prefer 3*m + m*nb)
                          call stdlib_${ri}$orgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, n, m, 0, s, work( ie ), vt,ldvt, u, ldu, &
                                    dum, 1, work( iwork ),info )
                       end if
                    end if
                 else if( wntva ) then
                    if( wntun ) then
                       ! path 7t(n much larger than m, jobu='n', jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! no left singular vectors to be computed
                       if( lwork>=m*m+max( n + m, 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(ir) is lda by m
                             ldwrkr = lda
                          else
                             ! work(ir) is m by m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! copy l to work(ir), zeroing out above it
                          call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( ir ),ldwrkr )
                          call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero,work( ir+ldwrkr ), ldwrkr &
                                    )
                          ! generate q in vt
                          ! (workspace: need m*m + m + n, prefer m*m + m + n*nb)
                          call stdlib_${ri}$orglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(ir)
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, work( ir ), ldwrkr, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (workspace: need m*m + 4*m-1,
                                      ! prefer m*m+3*m+(m-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of l in work(ir)
                          ! (workspace: need m*m + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, m, 0, 0, s, work( ie ),work( ir ), ldwrkr, &
                                    dum, 1, dum, 1,work( iwork ), info )
                          ! multiply right singular vectors of l in work(ir) by
                          ! q in vt, storing result in a
                          ! (workspace: need m*m)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, m, one, work( ir ),ldwrkr, vt, ldvt, &
                                    zero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_${ri}$lacpy( 'F', m, n, a, lda, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need m + n, prefer m + n*nb)
                          call stdlib_${ri}$orglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, a( 1, 2 ),lda )
                          ! bidiagonalize l in a
                          ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in a by q
                          ! in vt
                          ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                          call stdlib_${ri}$ormbr( 'P', 'L', 'T', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, n, 0, 0, s, work( ie ), vt,ldvt, dum, 1, &
                                    dum, 1, work( iwork ),info )
                       end if
                    else if( wntuo ) then
                       ! path 8t(n much larger than m, jobu='o', jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! m left singular vectors to be overwritten on a
                       if( lwork>=2*m*m+max( n + m, 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*m ) then
                             ! work(iu) is lda by m and work(ir) is lda by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda + m )*m ) then
                             ! work(iu) is lda by m and work(ir) is m by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          else
                             ! work(iu) is m by m and work(ir) is m by m
                             ldwrku = m
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m*m + 2*m, prefer 2*m*m + m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need 2*m*m + m + n, prefer 2*m*m + m + n*nb)
                          call stdlib_${ri}$orglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero,work( iu+ldwrku ), ldwrku &
                                    )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to
                          ! work(ir)
                          ! (workspace: need 2*m*m + 4*m,
                                      ! prefer 2*m*m+3*m+2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, m, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (workspace: need 2*m*m + 4*m-1,
                                      ! prefer 2*m*m+3*m+(m-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (workspace: need 2*m*m + 4*m, prefer 2*m*m + 3*m + m*nb)
                          call stdlib_${ri}$orgbr( 'Q', m, m, m, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in work(ir) and computing
                          ! right singular vectors of l in work(iu)
                          ! (workspace: need 2*m*m + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, m, m, 0, s, work( ie ),work( iu ), ldwrku, &
                                    work( ir ),ldwrkr, dum, 1, work( iwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in vt, storing result in a
                          ! (workspace: need m*m)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, m, one, work( iu ),ldwrku, vt, ldvt, &
                                    zero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_${ri}$lacpy( 'F', m, n, a, lda, vt, ldvt )
                          ! copy left singular vectors of a from work(ir) to a
                          call stdlib_${ri}$lacpy( 'F', m, m, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need m + n, prefer m + n*nb)
                          call stdlib_${ri}$orglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, a( 1, 2 ),lda )
                          ! bidiagonalize l in a
                          ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, a, lda, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in a by q
                          ! in vt
                          ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                          call stdlib_${ri}$ormbr( 'P', 'L', 'T', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in a
                          ! (workspace: need 4*m, prefer 3*m + m*nb)
                          call stdlib_${ri}$orgbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in a and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, n, m, 0, s, work( ie ), vt,ldvt, a, lda, &
                                    dum, 1, work( iwork ),info )
                       end if
                    else if( wntuas ) then
                       ! path 9t(n much larger than m, jobu='s' or 'a',
                               ! jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! m left singular vectors to be computed in u
                       if( lwork>=m*m+max( n + m, 4*m, bdspac ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(iu) is lda by m
                             ldwrku = lda
                          else
                             ! work(iu) is m by m
                             ldwrku = m
                          end if
                          itau = iu + ldwrku*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need m*m + 2*m, prefer m*m + m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need m*m + m + n, prefer m*m + m + n*nb)
                          call stdlib_${ri}$orglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero,work( iu+ldwrku ), ldwrku &
                                    )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to u
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, work( iu ), ldwrku, s,work( ie ), work( itauq &
                                    ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'L', m, m, work( iu ), ldwrku, u,ldu )
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + (m-1)*nb)
                          call stdlib_${ri}$orgbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (workspace: need m*m + 4*m, prefer m*m + 3*m + m*nb)
                          call stdlib_${ri}$orgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in u and computing right
                          ! singular vectors of l in work(iu)
                          ! (workspace: need m*m + bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, m, m, 0, s, work( ie ),work( iu ), ldwrku, &
                                    u, ldu, dum, 1,work( iwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in vt, storing result in a
                          ! (workspace: need m*m)
                          call stdlib_${ri}$gemm( 'N', 'N', m, n, m, one, work( iu ),ldwrku, vt, ldvt, &
                                    zero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_${ri}$lacpy( 'F', m, n, a, lda, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (workspace: need 2*m, prefer m + m*nb)
                          call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (workspace: need m + n, prefer m + n*nb)
                          call stdlib_${ri}$orglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to u, zeroing out above it
                          call stdlib_${ri}$lacpy( 'L', m, m, a, lda, u, ldu )
                          if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, u( 1, 2 ),ldu )
                          ie = itau
                          itauq = ie + m
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in u
                          ! (workspace: need 4*m, prefer 3*m + 2*m*nb)
                          call stdlib_${ri}$gebrd( m, m, u, ldu, s, work( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in u by q
                          ! in vt
                          ! (workspace: need 3*m + n, prefer 3*m + n*nb)
                          call stdlib_${ri}$ormbr( 'P', 'L', 'T', m, n, m, u, ldu,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (workspace: need 4*m, prefer 3*m + m*nb)
                          call stdlib_${ri}$orgbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          iwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (workspace: need bdspac)
                          call stdlib_${ri}$bdsqr( 'U', m, n, m, 0, s, work( ie ), vt,ldvt, u, ldu, &
                                    dum, 1, work( iwork ),info )
                       end if
                    end if
                 end if
              else
                 ! n < mnthr
                 ! path 10t(n greater than m, but not much larger)
                 ! reduce to bidiagonal form without lq decomposition
                 ie = 1
                 itauq = ie + m
                 itaup = itauq + m
                 iwork = itaup + m
                 ! bidiagonalize a
                 ! (workspace: need 3*m + n, prefer 3*m + (m + n)*nb)
                 call stdlib_${ri}$gebrd( m, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                           work( iwork ), lwork-iwork+1,ierr )
                 if( wntuas ) then
                    ! if left singular vectors desired in u, copy result to u
                    ! and generate left bidiagonalizing vectors in u
                    ! (workspace: need 4*m-1, prefer 3*m + (m-1)*nb)
                    call stdlib_${ri}$lacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_${ri}$orgbr( 'Q', m, m, n, u, ldu, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvas ) then
                    ! if right singular vectors desired in vt, copy result to
                    ! vt and generate right bidiagonalizing vectors in vt
                    ! (workspace: need 3*m + nrvt, prefer 3*m + nrvt*nb)
                    call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                    if( wntva )nrvt = n
                    if( wntvs )nrvt = m
                    call stdlib_${ri}$orgbr( 'P', nrvt, n, m, vt, ldvt, work( itaup ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntuo ) then
                    ! if left singular vectors desired in a, generate left
                    ! bidiagonalizing vectors in a
                    ! (workspace: need 4*m-1, prefer 3*m + (m-1)*nb)
                    call stdlib_${ri}$orgbr( 'Q', m, m, n, a, lda, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvo ) then
                    ! if right singular vectors desired in a, generate right
                    ! bidiagonalizing vectors in a
                    ! (workspace: need 4*m, prefer 3*m + m*nb)
                    call stdlib_${ri}$orgbr( 'P', m, n, m, a, lda, work( itaup ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 iwork = ie + m
                 if( wntuas .or. wntuo )nru = m
                 if( wntun )nru = 0
                 if( wntvas .or. wntvo )ncvt = n
                 if( wntvn )ncvt = 0
                 if( ( .not.wntuo ) .and. ( .not.wntvo ) ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in vt
                    ! (workspace: need bdspac)
                    call stdlib_${ri}$bdsqr( 'L', m, ncvt, nru, 0, s, work( ie ), vt,ldvt, u, ldu, dum,&
                               1, work( iwork ), info )
                 else if( ( .not.wntuo ) .and. wntvo ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in a
                    ! (workspace: need bdspac)
                    call stdlib_${ri}$bdsqr( 'L', m, ncvt, nru, 0, s, work( ie ), a, lda,u, ldu, dum, &
                              1, work( iwork ), info )
                 else
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in a and computing right singular
                    ! vectors in vt
                    ! (workspace: need bdspac)
                    call stdlib_${ri}$bdsqr( 'L', m, ncvt, nru, 0, s, work( ie ), vt,ldvt, a, lda, dum,&
                               1, work( iwork ), info )
                 end if
              end if
           end if
           ! if stdlib_${ri}$bdsqr failed to converge, copy unconverged superdiagonals
           ! to work( 2:minmn )
           if( info/=0 ) then
              if( ie>2 ) then
                 do i = 1, minmn - 1
                    work( i+1 ) = work( i+ie-1 )
                 end do
              end if
              if( ie<2 ) then
                 do i = minmn - 1, 1, -1
                    work( i+1 ) = work( i+ie-1 )
                 end do
              end if
           end if
           ! undo scaling if necessary
           if( iscl==1 ) then
              if( anrm>bignum )call stdlib_${ri}$lascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm>bignum )call stdlib_${ri}$lascl( 'G', 0, 0, bignum, anrm, minmn-1,&
                         1, work( 2 ),minmn, ierr )
              if( anrm<smlnum )call stdlib_${ri}$lascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm<smlnum )call stdlib_${ri}$lascl( 'G', 0, 0, smlnum, anrm, minmn-1,&
                         1, work( 2 ),minmn, ierr )
           end if
           ! return optimal workspace in work(1)
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ri}$gesvd

#:endif
#:endfor

     module subroutine stdlib_cgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, rwork, &
     !! CGESVD computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, optionally computing the left and/or right singular
     !! vectors. The SVD is written
     !! A = U * SIGMA * conjugate-transpose(V)
     !! where SIGMA is an M-by-N matrix which is zero except for its
     !! min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
     !! V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
     !! are the singular values of A; they are real and non-negative, and
     !! are returned in descending order.  The first min(m,n) columns of
     !! U and V are the left and right singular vectors of A.
     !! Note that the routine returns V**H, not V.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobu, jobvt
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldvt, lwork, m, n
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*), s(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lquery, wntua, wntuas, wntun, wntuo, wntus, wntva, wntvas, wntvn, wntvo,&
                      wntvs
           integer(ilp) :: blk, chunk, i, ie, ierr, ir, irwork, iscl, itau, itaup, itauq, iu, &
           iwork, ldwrkr, ldwrku, maxwrk, minmn, minwrk, mnthr, ncu, ncvt, nru, nrvt, &
                     wrkbl
           integer(ilp) :: lwork_cgeqrf, lwork_cungqr_n, lwork_cungqr_m, lwork_cgebrd, &
                     lwork_cungbr_p, lwork_cungbr_q, lwork_cgelqf, lwork_cunglq_n, lwork_cunglq_m
           real(sp) :: anrm, bignum, eps, smlnum
           ! Local Arrays 
           real(sp) :: dum(1)
           complex(sp) :: cdum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           minmn = min( m, n )
           wntua = stdlib_lsame( jobu, 'A' )
           wntus = stdlib_lsame( jobu, 'S' )
           wntuas = wntua .or. wntus
           wntuo = stdlib_lsame( jobu, 'O' )
           wntun = stdlib_lsame( jobu, 'N' )
           wntva = stdlib_lsame( jobvt, 'A' )
           wntvs = stdlib_lsame( jobvt, 'S' )
           wntvas = wntva .or. wntvs
           wntvo = stdlib_lsame( jobvt, 'O' )
           wntvn = stdlib_lsame( jobvt, 'N' )
           lquery = ( lwork==-1 )
           if( .not.( wntua .or. wntus .or. wntuo .or. wntun ) ) then
              info = -1
           else if( .not.( wntva .or. wntvs .or. wntvo .or. wntvn ) .or.( wntvo .and. wntuo ) ) &
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( ldu<1 .or. ( wntuas .and. ldu<m ) ) then
              info = -9
           else if( ldvt<1 .or. ( wntva .and. ldvt<n ) .or.( wntvs .and. ldvt<minmn ) ) &
                     then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to
             ! real workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              if( m>=n .and. minmn>0 ) then
                 ! space needed for stdlib_zbdsqr is bdspac = 5*n
                 mnthr = stdlib_ilaenv( 6, 'CGESVD', jobu // jobvt, m, n, 0, 0 )
                 ! compute space needed for stdlib_cgeqrf
                 call stdlib_cgeqrf( m, n, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_cgeqrf = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_cungqr
                 call stdlib_cungqr( m, n, n, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_cungqr_n = int( cdum(1),KIND=ilp)
                 call stdlib_cungqr( m, m, n, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_cungqr_m = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_cgebrd
                 call stdlib_cgebrd( n, n, a, lda, s, dum(1), cdum(1),cdum(1), cdum(1), -1, ierr )
                           
                 lwork_cgebrd = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_cungbr
                 call stdlib_cungbr( 'P', n, n, n, a, lda, cdum(1),cdum(1), -1, ierr )
                 lwork_cungbr_p = int( cdum(1),KIND=ilp)
                 call stdlib_cungbr( 'Q', n, n, n, a, lda, cdum(1),cdum(1), -1, ierr )
                 lwork_cungbr_q = int( cdum(1),KIND=ilp)
                 mnthr = stdlib_ilaenv( 6, 'CGESVD', jobu // jobvt, m, n, 0, 0 )
                 if( m>=mnthr ) then
                    if( wntun ) then
                       ! path 1 (m much larger than n, jobu='n')
                       maxwrk = n + lwork_cgeqrf
                       maxwrk = max( maxwrk, 2*n+lwork_cgebrd )
                       if( wntvo .or. wntvas )maxwrk = max( maxwrk, 2*n+lwork_cungbr_p )
                       minwrk = 3*n
                    else if( wntuo .and. wntvn ) then
                       ! path 2 (m much larger than n, jobu='o', jobvt='n')
                       wrkbl = n + lwork_cgeqrf
                       wrkbl = max( wrkbl, n+lwork_cungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_q )
                       maxwrk = max( n*n+wrkbl, n*n+m*n )
                       minwrk = 2*n + m
                    else if( wntuo .and. wntvas ) then
                       ! path 3 (m much larger than n, jobu='o', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_cgeqrf
                       wrkbl = max( wrkbl, n+lwork_cungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_p )
                       maxwrk = max( n*n+wrkbl, n*n+m*n )
                       minwrk = 2*n + m
                    else if( wntus .and. wntvn ) then
                       ! path 4 (m much larger than n, jobu='s', jobvt='n')
                       wrkbl = n + lwork_cgeqrf
                       wrkbl = max( wrkbl, n+lwork_cungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_q )
                       maxwrk = n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntus .and. wntvo ) then
                       ! path 5 (m much larger than n, jobu='s', jobvt='o')
                       wrkbl = n + lwork_cgeqrf
                       wrkbl = max( wrkbl, n+lwork_cungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_p )
                       maxwrk = 2*n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntus .and. wntvas ) then
                       ! path 6 (m much larger than n, jobu='s', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_cgeqrf
                       wrkbl = max( wrkbl, n+lwork_cungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_p )
                       maxwrk = n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntua .and. wntvn ) then
                       ! path 7 (m much larger than n, jobu='a', jobvt='n')
                       wrkbl = n + lwork_cgeqrf
                       wrkbl = max( wrkbl, n+lwork_cungqr_m )
                       wrkbl = max( wrkbl, 2*n+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_q )
                       maxwrk = n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntua .and. wntvo ) then
                       ! path 8 (m much larger than n, jobu='a', jobvt='o')
                       wrkbl = n + lwork_cgeqrf
                       wrkbl = max( wrkbl, n+lwork_cungqr_m )
                       wrkbl = max( wrkbl, 2*n+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_p )
                       maxwrk = 2*n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntua .and. wntvas ) then
                       ! path 9 (m much larger than n, jobu='a', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_cgeqrf
                       wrkbl = max( wrkbl, n+lwork_cungqr_m )
                       wrkbl = max( wrkbl, 2*n+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_cungbr_p )
                       maxwrk = n*n + wrkbl
                       minwrk = 2*n + m
                    end if
                 else
                    ! path 10 (m at least n, but not much larger)
                    call stdlib_cgebrd( m, n, a, lda, s, dum(1), cdum(1),cdum(1), cdum(1), -1, &
                              ierr )
                    lwork_cgebrd = int( cdum(1),KIND=ilp)
                    maxwrk = 2*n + lwork_cgebrd
                    if( wntus .or. wntuo ) then
                       call stdlib_cungbr( 'Q', m, n, n, a, lda, cdum(1),cdum(1), -1, ierr )
                                 
                       lwork_cungbr_q = int( cdum(1),KIND=ilp)
                       maxwrk = max( maxwrk, 2*n+lwork_cungbr_q )
                    end if
                    if( wntua ) then
                       call stdlib_cungbr( 'Q', m, m, n, a, lda, cdum(1),cdum(1), -1, ierr )
                                 
                       lwork_cungbr_q = int( cdum(1),KIND=ilp)
                       maxwrk = max( maxwrk, 2*n+lwork_cungbr_q )
                    end if
                    if( .not.wntvn ) then
                       maxwrk = max( maxwrk, 2*n+lwork_cungbr_p )
                    end if
                    minwrk = 2*n + m
                 end if
              else if( minmn>0 ) then
                 ! space needed for stdlib_cbdsqr is bdspac = 5*m
                 mnthr = stdlib_ilaenv( 6, 'CGESVD', jobu // jobvt, m, n, 0, 0 )
                 ! compute space needed for stdlib_cgelqf
                 call stdlib_cgelqf( m, n, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_cgelqf = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_cunglq
                 call stdlib_cunglq( n, n, m, cdum(1), n, cdum(1), cdum(1), -1,ierr )
                 lwork_cunglq_n = int( cdum(1),KIND=ilp)
                 call stdlib_cunglq( m, n, m, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_cunglq_m = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_cgebrd
                 call stdlib_cgebrd( m, m, a, lda, s, dum(1), cdum(1),cdum(1), cdum(1), -1, ierr )
                           
                 lwork_cgebrd = int( cdum(1),KIND=ilp)
                  ! compute space needed for stdlib_cungbr p
                 call stdlib_cungbr( 'P', m, m, m, a, n, cdum(1),cdum(1), -1, ierr )
                 lwork_cungbr_p = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_cungbr q
                 call stdlib_cungbr( 'Q', m, m, m, a, n, cdum(1),cdum(1), -1, ierr )
                 lwork_cungbr_q = int( cdum(1),KIND=ilp)
                 if( n>=mnthr ) then
                    if( wntvn ) then
                       ! path 1t(n much larger than m, jobvt='n')
                       maxwrk = m + lwork_cgelqf
                       maxwrk = max( maxwrk, 2*m+lwork_cgebrd )
                       if( wntuo .or. wntuas )maxwrk = max( maxwrk, 2*m+lwork_cungbr_q )
                       minwrk = 3*m
                    else if( wntvo .and. wntun ) then
                       ! path 2t(n much larger than m, jobu='n', jobvt='o')
                       wrkbl = m + lwork_cgelqf
                       wrkbl = max( wrkbl, m+lwork_cunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_p )
                       maxwrk = max( m*m+wrkbl, m*m+m*n )
                       minwrk = 2*m + n
                    else if( wntvo .and. wntuas ) then
                       ! path 3t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='o')
                       wrkbl = m + lwork_cgelqf
                       wrkbl = max( wrkbl, m+lwork_cunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_q )
                       maxwrk = max( m*m+wrkbl, m*m+m*n )
                       minwrk = 2*m + n
                    else if( wntvs .and. wntun ) then
                       ! path 4t(n much larger than m, jobu='n', jobvt='s')
                       wrkbl = m + lwork_cgelqf
                       wrkbl = max( wrkbl, m+lwork_cunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_p )
                       maxwrk = m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntvs .and. wntuo ) then
                       ! path 5t(n much larger than m, jobu='o', jobvt='s')
                       wrkbl = m + lwork_cgelqf
                       wrkbl = max( wrkbl, m+lwork_cunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_q )
                       maxwrk = 2*m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntvs .and. wntuas ) then
                       ! path 6t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='s')
                       wrkbl = m + lwork_cgelqf
                       wrkbl = max( wrkbl, m+lwork_cunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_q )
                       maxwrk = m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntva .and. wntun ) then
                       ! path 7t(n much larger than m, jobu='n', jobvt='a')
                       wrkbl = m + lwork_cgelqf
                       wrkbl = max( wrkbl, m+lwork_cunglq_n )
                       wrkbl = max( wrkbl, 2*m+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_p )
                       maxwrk = m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntva .and. wntuo ) then
                       ! path 8t(n much larger than m, jobu='o', jobvt='a')
                       wrkbl = m + lwork_cgelqf
                       wrkbl = max( wrkbl, m+lwork_cunglq_n )
                       wrkbl = max( wrkbl, 2*m+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_q )
                       maxwrk = 2*m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntva .and. wntuas ) then
                       ! path 9t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='a')
                       wrkbl = m + lwork_cgelqf
                       wrkbl = max( wrkbl, m+lwork_cunglq_n )
                       wrkbl = max( wrkbl, 2*m+lwork_cgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_cungbr_q )
                       maxwrk = m*m + wrkbl
                       minwrk = 2*m + n
                    end if
                 else
                    ! path 10t(n greater than m, but not much larger)
                    call stdlib_cgebrd( m, n, a, lda, s, dum(1), cdum(1),cdum(1), cdum(1), -1, &
                              ierr )
                    lwork_cgebrd = int( cdum(1),KIND=ilp)
                    maxwrk = 2*m + lwork_cgebrd
                    if( wntvs .or. wntvo ) then
                      ! compute space needed for stdlib_cungbr p
                      call stdlib_cungbr( 'P', m, n, m, a, n, cdum(1),cdum(1), -1, ierr )
                      lwork_cungbr_p = int( cdum(1),KIND=ilp)
                      maxwrk = max( maxwrk, 2*m+lwork_cungbr_p )
                    end if
                    if( wntva ) then
                      call stdlib_cungbr( 'P', n,  n, m, a, n, cdum(1),cdum(1), -1, ierr )
                      lwork_cungbr_p = int( cdum(1),KIND=ilp)
                      maxwrk = max( maxwrk, 2*m+lwork_cungbr_p )
                    end if
                    if( .not.wntun ) then
                       maxwrk = max( maxwrk, 2*m+lwork_cungbr_q )
                    end if
                    minwrk = 2*m + n
                 end if
              end if
              maxwrk = max( minwrk, maxwrk )
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGESVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = sqrt( stdlib_slamch( 'S' ) ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', m, n, a, lda, dum )
           iscl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              iscl = 1
              call stdlib_clascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, ierr )
           else if( anrm>bignum ) then
              iscl = 1
              call stdlib_clascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, ierr )
           end if
           if( m>=n ) then
              ! a has at least as many rows as columns. if a has sufficiently
              ! more rows than columns, first reduce using the qr
              ! decomposition (if sufficient workspace available)
              if( m>=mnthr ) then
                 if( wntun ) then
                    ! path 1 (m much larger than n, jobu='n')
                    ! no left singular vectors to be computed
                    itau = 1
                    iwork = itau + n
                    ! compute a=q*r
                    ! (cworkspace: need 2*n, prefer n+n*nb)
                    ! (rworkspace: need 0)
                    call stdlib_cgeqrf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, &
                              ierr )
                    ! zero out below r
                    if( n > 1 ) then
                       call stdlib_claset( 'L', n-1, n-1, czero, czero, a( 2, 1 ),lda )
                    end if
                    ie = 1
                    itauq = 1
                    itaup = itauq + n
                    iwork = itaup + n
                    ! bidiagonalize r in a
                    ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                    ! (rworkspace: need n)
                    call stdlib_cgebrd( n, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( iwork ), lwork-iwork+1,ierr )
                    ncvt = 0
                    if( wntvo .or. wntvas ) then
                       ! if right singular vectors desired, generate p'.
                       ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       ncvt = n
                    end if
                    irwork = ie + n
                    ! perform bidiagonal qr iteration, computing right
                    ! singular vectors of a in a if desired
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_cbdsqr( 'U', n, ncvt, 0, 0, s, rwork( ie ), a, lda,cdum, 1, cdum, &
                              1, rwork( irwork ), info )
                    ! if right singular vectors desired in vt, copy them there
                    if( wntvas )call stdlib_clacpy( 'F', n, n, a, lda, vt, ldvt )
                 else if( wntuo .and. wntvn ) then
                    ! path 2 (m much larger than n, jobu='o', jobvt='n')
                    ! n left singular vectors to be overwritten on a and
                    ! no right singular vectors to be computed
                    if( lwork>=n*n+3*n ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n )+lda*n ) then
                          ! work(iu) is lda by n, work(ir) is lda by n
                          ldwrku = lda
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n )+n*n ) then
                          ! work(iu) is lda by n, work(ir) is n by n
                          ldwrku = lda
                          ldwrkr = n
                       else
                          ! work(iu) is ldwrku by n, work(ir) is n by n
                          ldwrku = ( lwork-n*n ) / n
                          ldwrkr = n
                       end if
                       itau = ir + ldwrkr*n
                       iwork = itau + n
                       ! compute a=q*r
                       ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to work(ir) and zero out below it
                       call stdlib_clacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                       call stdlib_claset( 'L', n-1, n-1, czero, czero,work( ir+1 ), ldwrkr )
                                 
                       ! generate q in a
                       ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in work(ir)
                       ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                       ! (rworkspace: need n)
                       call stdlib_cgebrd( n, n, work( ir ), ldwrkr, s, rwork( ie ),work( itauq ),&
                                  work( itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing r
                       ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                       ! (rworkspace: need 0)
                       call stdlib_cungbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       irwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of r in work(ir)
                       ! (cworkspace: need n*n)
                       ! (rworkspace: need bdspac)
                       call stdlib_cbdsqr( 'U', n, 0, n, 0, s, rwork( ie ), cdum, 1,work( ir ), &
                                 ldwrkr, cdum, 1,rwork( irwork ), info )
                       iu = itauq
                       ! multiply q in a by left singular vectors of r in
                       ! work(ir), storing result in work(iu) and copying to a
                       ! (cworkspace: need n*n+n, prefer n*n+m*n)
                       ! (rworkspace: 0)
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_cgemm( 'N', 'N', chunk, n, n, cone, a( i, 1 ),lda, work( ir &
                                    ), ldwrkr, czero,work( iu ), ldwrku )
                          call stdlib_clacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       ie = 1
                       itauq = 1
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize a
                       ! (cworkspace: need 2*n+m, prefer 2*n+(m+n)*nb)
                       ! (rworkspace: n)
                       call stdlib_cgebrd( m, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing a
                       ! (cworkspace: need 3*n, prefer 2*n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'Q', m, n, n, a, lda, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in a
                       ! (cworkspace: need 0)
                       ! (rworkspace: need bdspac)
                       call stdlib_cbdsqr( 'U', n, 0, m, 0, s, rwork( ie ), cdum, 1,a, lda, cdum, &
                                 1, rwork( irwork ), info )
                    end if
                 else if( wntuo .and. wntvas ) then
                    ! path 3 (m much larger than n, jobu='o', jobvt='s' or 'a')
                    ! n left singular vectors to be overwritten on a and
                    ! n right singular vectors to be computed in vt
                    if( lwork>=n*n+3*n ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n )+lda*n ) then
                          ! work(iu) is lda by n and work(ir) is lda by n
                          ldwrku = lda
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n )+n*n ) then
                          ! work(iu) is lda by n and work(ir) is n by n
                          ldwrku = lda
                          ldwrkr = n
                       else
                          ! work(iu) is ldwrku by n and work(ir) is n by n
                          ldwrku = ( lwork-n*n ) / n
                          ldwrkr = n
                       end if
                       itau = ir + ldwrkr*n
                       iwork = itau + n
                       ! compute a=q*r
                       ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to vt, zeroing out below it
                       call stdlib_clacpy( 'U', n, n, a, lda, vt, ldvt )
                       if( n>1 )call stdlib_claset( 'L', n-1, n-1, czero, czero,vt( 2, 1 ), ldvt )
                                 
                       ! generate q in a
                       ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in vt, copying result to work(ir)
                       ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                       ! (rworkspace: need n)
                       call stdlib_cgebrd( n, n, vt, ldvt, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       call stdlib_clacpy( 'L', n, n, vt, ldvt, work( ir ), ldwrkr )
                       ! generate left vectors bidiagonalizing r in work(ir)
                       ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing r in vt
                       ! (cworkspace: need n*n+3*n-1, prefer n*n+2*n+(n-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of r in work(ir) and computing right
                       ! singular vectors of r in vt
                       ! (cworkspace: need n*n)
                       ! (rworkspace: need bdspac)
                       call stdlib_cbdsqr( 'U', n, n, n, 0, s, rwork( ie ), vt,ldvt, work( ir ), &
                                 ldwrkr, cdum, 1,rwork( irwork ), info )
                       iu = itauq
                       ! multiply q in a by left singular vectors of r in
                       ! work(ir), storing result in work(iu) and copying to a
                       ! (cworkspace: need n*n+n, prefer n*n+m*n)
                       ! (rworkspace: 0)
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_cgemm( 'N', 'N', chunk, n, n, cone, a( i, 1 ),lda, work( ir &
                                    ), ldwrkr, czero,work( iu ), ldwrku )
                          call stdlib_clacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       itau = 1
                       iwork = itau + n
                       ! compute a=q*r
                       ! (cworkspace: need 2*n, prefer n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to vt, zeroing out below it
                       call stdlib_clacpy( 'U', n, n, a, lda, vt, ldvt )
                       if( n>1 )call stdlib_claset( 'L', n-1, n-1, czero, czero,vt( 2, 1 ), ldvt )
                                 
                       ! generate q in a
                       ! (cworkspace: need 2*n, prefer n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in vt
                       ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                       ! (rworkspace: n)
                       call stdlib_cgebrd( n, n, vt, ldvt, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! multiply q in a by left vectors bidiagonalizing r
                       ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cunmbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), a, lda,&
                                  work( iwork ),lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing r in vt
                       ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in a and computing right
                       ! singular vectors of a in vt
                       ! (cworkspace: 0)
                       ! (rworkspace: need bdspac)
                       call stdlib_cbdsqr( 'U', n, n, m, 0, s, rwork( ie ), vt,ldvt, a, lda, cdum,&
                                  1, rwork( irwork ),info )
                    end if
                 else if( wntus ) then
                    if( wntvn ) then
                       ! path 4 (m much larger than n, jobu='s', jobvt='n')
                       ! n left singular vectors to be computed in u and
                       ! no right singular vectors to be computed
                       if( lwork>=n*n+3*n ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(ir) is lda by n
                             ldwrkr = lda
                          else
                             ! work(ir) is n by n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(ir), zeroing out below it
                          call stdlib_clacpy( 'U', n, n, a, lda, work( ir ),ldwrkr )
                          call stdlib_claset( 'L', n-1, n-1, czero, czero,work( ir+1 ), ldwrkr )
                                    
                          ! generate q in a
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(ir)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, work( ir ), ldwrkr, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate left vectors bidiagonalizing r in work(ir)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(ir)
                          ! (cworkspace: need n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, 0, n, 0, s, rwork( ie ), cdum,1, work( ir ),&
                                     ldwrkr, cdum, 1,rwork( irwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(ir), storing result in u
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, n, cone, a, lda,work( ir ), ldwrkr, &
                                    czero, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_claset( 'L', n-1, n-1, czero, czero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left vectors bidiagonalizing r
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, 0, m, 0, s, rwork( ie ), cdum,1, u, ldu, &
                                    cdum, 1, rwork( irwork ),info )
                       end if
                    else if( wntvo ) then
                       ! path 5 (m much larger than n, jobu='s', jobvt='o')
                       ! n left singular vectors to be computed in u and
                       ! n right singular vectors to be overwritten on a
                       if( lwork>=2*n*n+3*n ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*n ) then
                             ! work(iu) is lda by n and work(ir) is lda by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+n )*n ) then
                             ! work(iu) is lda by n and work(ir) is n by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          else
                             ! work(iu) is n by n and work(ir) is n by n
                             ldwrku = n
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (cworkspace: need 2*n*n+2*n, prefer 2*n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_clacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_claset( 'L', n-1, n-1, czero, czero,work( iu+1 ), ldwrku )
                                    
                          ! generate q in a
                          ! (cworkspace: need 2*n*n+2*n, prefer 2*n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to
                          ! work(ir)
                          ! (cworkspace: need   2*n*n+3*n,
                                       ! prefer 2*n*n+2*n+2*n*nb)
                          ! (rworkspace: need   n)
                          call stdlib_cgebrd( n, n, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_clacpy( 'U', n, n, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need 2*n*n+3*n, prefer 2*n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need   2*n*n+3*n-1,
                                       ! prefer 2*n*n+2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in work(ir)
                          ! (cworkspace: need 2*n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, n, n, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                    work( iu ),ldwrku, cdum, 1, rwork( irwork ),info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(iu), storing result in u
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, n, cone, a, lda,work( iu ), ldwrku, &
                                    czero, u, ldu )
                          ! copy right singular vectors of r to a
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_clacpy( 'F', n, n, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_claset( 'L', n-1, n-1, czero, czero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left vectors bidiagonalizing r
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right vectors bidiagonalizing r in a
                          ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in a
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, n, m, 0, s, rwork( ie ), a,lda, u, ldu, &
                                    cdum, 1, rwork( irwork ),info )
                       end if
                    else if( wntvas ) then
                       ! path 6 (m much larger than n, jobu='s', jobvt='s'
                               ! or 'a')
                       ! n left singular vectors to be computed in u and
                       ! n right singular vectors to be computed in vt
                       if( lwork>=n*n+3*n ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is n by n
                             ldwrku = n
                          end if
                          itau = iu + ldwrku*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_clacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_claset( 'L', n-1, n-1, czero, czero,work( iu+1 ), ldwrku )
                                    
                          ! generate q in a
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to vt
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_clacpy( 'U', n, n, work( iu ), ldwrku, vt,ldvt )
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (cworkspace: need   n*n+3*n-1,
                                       ! prefer n*n+2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in vt
                          ! (cworkspace: need n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, n, n, 0, s, rwork( ie ), vt,ldvt, work( iu )&
                                    , ldwrku, cdum, 1,rwork( irwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(iu), storing result in u
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, n, cone, a, lda,work( iu ), ldwrku, &
                                    czero, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to vt, zeroing out below it
                          call stdlib_clacpy( 'U', n, n, a, lda, vt, ldvt )
                          if( n>1 )call stdlib_claset( 'L', n-1, n-1, czero, czero,vt( 2, 1 ), &
                                    ldvt )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in vt
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, vt, ldvt, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in vt
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, n, m, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    end if
                 else if( wntua ) then
                    if( wntvn ) then
                       ! path 7 (m much larger than n, jobu='a', jobvt='n')
                       ! m left singular vectors to be computed in u and
                       ! no right singular vectors to be computed
                       if( lwork>=n*n+max( n+m, 3*n ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(ir) is lda by n
                             ldwrkr = lda
                          else
                             ! work(ir) is n by n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                          ! copy r to work(ir), zeroing out below it
                          call stdlib_clacpy( 'U', n, n, a, lda, work( ir ),ldwrkr )
                          call stdlib_claset( 'L', n-1, n-1, czero, czero,work( ir+1 ), ldwrkr )
                                    
                          ! generate q in u
                          ! (cworkspace: need n*n+n+m, prefer n*n+n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(ir)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, work( ir ), ldwrkr, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(ir)
                          ! (cworkspace: need n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, 0, n, 0, s, rwork( ie ), cdum,1, work( ir ),&
                                     ldwrkr, cdum, 1,rwork( irwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(ir), storing result in a
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, n, cone, u, ldu,work( ir ), ldwrkr, &
                                    czero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_clacpy( 'F', m, n, a, lda, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need n+m, prefer n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_claset( 'L', n-1, n-1, czero, czero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in a
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, 0, m, 0, s, rwork( ie ), cdum,1, u, ldu, &
                                    cdum, 1, rwork( irwork ),info )
                       end if
                    else if( wntvo ) then
                       ! path 8 (m much larger than n, jobu='a', jobvt='o')
                       ! m left singular vectors to be computed in u and
                       ! n right singular vectors to be overwritten on a
                       if( lwork>=2*n*n+max( n+m, 3*n ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*n ) then
                             ! work(iu) is lda by n and work(ir) is lda by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+n )*n ) then
                             ! work(iu) is lda by n and work(ir) is n by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          else
                             ! work(iu) is n by n and work(ir) is n by n
                             ldwrku = n
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n*n+2*n, prefer 2*n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need 2*n*n+n+m, prefer 2*n*n+n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_clacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_claset( 'L', n-1, n-1, czero, czero,work( iu+1 ), ldwrku )
                                    
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to
                          ! work(ir)
                          ! (cworkspace: need   2*n*n+3*n,
                                       ! prefer 2*n*n+2*n+2*n*nb)
                          ! (rworkspace: need   n)
                          call stdlib_cgebrd( n, n, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_clacpy( 'U', n, n, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need 2*n*n+3*n, prefer 2*n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need   2*n*n+3*n-1,
                                       ! prefer 2*n*n+2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in work(ir)
                          ! (cworkspace: need 2*n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, n, n, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                    work( iu ),ldwrku, cdum, 1, rwork( irwork ),info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(iu), storing result in a
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, n, cone, u, ldu,work( iu ), ldwrku, &
                                    czero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_clacpy( 'F', m, n, a, lda, u, ldu )
                          ! copy right singular vectors of r from work(ir) to a
                          call stdlib_clacpy( 'F', n, n, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need n+m, prefer n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_claset( 'L', n-1, n-1, czero, czero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in a
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in a
                          ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in a
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, n, m, 0, s, rwork( ie ), a,lda, u, ldu, &
                                    cdum, 1, rwork( irwork ),info )
                       end if
                    else if( wntvas ) then
                       ! path 9 (m much larger than n, jobu='a', jobvt='s'
                               ! or 'a')
                       ! m left singular vectors to be computed in u and
                       ! n right singular vectors to be computed in vt
                       if( lwork>=n*n+max( n+m, 3*n ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is n by n
                             ldwrku = n
                          end if
                          itau = iu + ldwrku*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need n*n+n+m, prefer n*n+n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_clacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_claset( 'L', n-1, n-1, czero, czero,work( iu+1 ), ldwrku )
                                    
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to vt
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_clacpy( 'U', n, n, work( iu ), ldwrku, vt,ldvt )
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (cworkspace: need   n*n+3*n-1,
                                       ! prefer n*n+2*n+(n-1)*nb)
                          ! (rworkspace: need   0)
                          call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in vt
                          ! (cworkspace: need n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, n, n, 0, s, rwork( ie ), vt,ldvt, work( iu )&
                                    , ldwrku, cdum, 1,rwork( irwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(iu), storing result in a
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, n, cone, u, ldu,work( iu ), ldwrku, &
                                    czero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_clacpy( 'F', m, n, a, lda, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need n+m, prefer n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r from a to vt, zeroing out below it
                          call stdlib_clacpy( 'U', n, n, a, lda, vt, ldvt )
                          if( n>1 )call stdlib_claset( 'L', n-1, n-1, czero, czero,vt( 2, 1 ), &
                                    ldvt )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in vt
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_cgebrd( n, n, vt, ldvt, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in vt
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', n, n, m, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    end if
                 end if
              else
                 ! m < mnthr
                 ! path 10 (m at least n, but not much larger)
                 ! reduce to bidiagonal form without qr decomposition
                 ie = 1
                 itauq = 1
                 itaup = itauq + n
                 iwork = itaup + n
                 ! bidiagonalize a
                 ! (cworkspace: need 2*n+m, prefer 2*n+(m+n)*nb)
                 ! (rworkspace: need n)
                 call stdlib_cgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( iwork ), lwork-iwork+1,ierr )
                 if( wntuas ) then
                    ! if left singular vectors desired in u, copy result to u
                    ! and generate left bidiagonalizing vectors in u
                    ! (cworkspace: need 2*n+ncu, prefer 2*n+ncu*nb)
                    ! (rworkspace: 0)
                    call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                    if( wntus )ncu = n
                    if( wntua )ncu = m
                    call stdlib_cungbr( 'Q', m, ncu, n, u, ldu, work( itauq ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntvas ) then
                    ! if right singular vectors desired in vt, copy result to
                    ! vt and generate right bidiagonalizing vectors in vt
                    ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                    ! (rworkspace: 0)
                    call stdlib_clacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntuo ) then
                    ! if left singular vectors desired in a, generate left
                    ! bidiagonalizing vectors in a
                    ! (cworkspace: need 3*n, prefer 2*n+n*nb)
                    ! (rworkspace: 0)
                    call stdlib_cungbr( 'Q', m, n, n, a, lda, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvo ) then
                    ! if right singular vectors desired in a, generate right
                    ! bidiagonalizing vectors in a
                    ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                    ! (rworkspace: 0)
                    call stdlib_cungbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 irwork = ie + n
                 if( wntuas .or. wntuo )nru = m
                 if( wntun )nru = 0
                 if( wntvas .or. wntvo )ncvt = n
                 if( wntvn )ncvt = 0
                 if( ( .not.wntuo ) .and. ( .not.wntvo ) ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in vt
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_cbdsqr( 'U', n, ncvt, nru, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                              cdum, 1, rwork( irwork ),info )
                 else if( ( .not.wntuo ) .and. wntvo ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in a
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_cbdsqr( 'U', n, ncvt, nru, 0, s, rwork( ie ), a,lda, u, ldu, cdum,&
                               1, rwork( irwork ),info )
                 else
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in a and computing right singular
                    ! vectors in vt
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_cbdsqr( 'U', n, ncvt, nru, 0, s, rwork( ie ), vt,ldvt, a, lda, &
                              cdum, 1, rwork( irwork ),info )
                 end if
              end if
           else
              ! a has more columns than rows. if a has sufficiently more
              ! columns than rows, first reduce using the lq decomposition (if
              ! sufficient workspace available)
              if( n>=mnthr ) then
                 if( wntvn ) then
                    ! path 1t(n much larger than m, jobvt='n')
                    ! no right singular vectors to be computed
                    itau = 1
                    iwork = itau + m
                    ! compute a=l*q
                    ! (cworkspace: need 2*m, prefer m+m*nb)
                    ! (rworkspace: 0)
                    call stdlib_cgelqf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, &
                              ierr )
                    ! zero out above l
                    if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero, a( 1, 2 ),lda )
                    ie = 1
                    itauq = 1
                    itaup = itauq + m
                    iwork = itaup + m
                    ! bidiagonalize l in a
                    ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                    ! (rworkspace: need m)
                    call stdlib_cgebrd( m, m, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( iwork ), lwork-iwork+1,ierr )
                    if( wntuo .or. wntuas ) then
                       ! if left singular vectors desired, generate q
                       ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                    end if
                    irwork = ie + m
                    nru = 0
                    if( wntuo .or. wntuas )nru = m
                    ! perform bidiagonal qr iteration, computing left singular
                    ! vectors of a in a if desired
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_cbdsqr( 'U', m, 0, nru, 0, s, rwork( ie ), cdum, 1,a, lda, cdum, &
                              1, rwork( irwork ), info )
                    ! if left singular vectors desired in u, copy them there
                    if( wntuas )call stdlib_clacpy( 'F', m, m, a, lda, u, ldu )
                 else if( wntvo .and. wntun ) then
                    ! path 2t(n much larger than m, jobu='n', jobvt='o')
                    ! m right singular vectors to be overwritten on a and
                    ! no left singular vectors to be computed
                    if( lwork>=m*m+3*m ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n )+lda*m ) then
                          ! work(iu) is lda by n and work(ir) is lda by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n )+m*m ) then
                          ! work(iu) is lda by n and work(ir) is m by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = m
                       else
                          ! work(iu) is m by chunk and work(ir) is m by m
                          ldwrku = m
                          chunk = ( lwork-m*m ) / m
                          ldwrkr = m
                       end if
                       itau = ir + ldwrkr*m
                       iwork = itau + m
                       ! compute a=l*q
                       ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to work(ir) and zero out above it
                       call stdlib_clacpy( 'L', m, m, a, lda, work( ir ), ldwrkr )
                       call stdlib_claset( 'U', m-1, m-1, czero, czero,work( ir+ldwrkr ), ldwrkr )
                                 
                       ! generate q in a
                       ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cunglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in work(ir)
                       ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                       ! (rworkspace: need m)
                       call stdlib_cgebrd( m, m, work( ir ), ldwrkr, s, rwork( ie ),work( itauq ),&
                                  work( itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing l
                       ! (cworkspace: need m*m+3*m-1, prefer m*m+2*m+(m-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       irwork = ie + m
                       ! perform bidiagonal qr iteration, computing right
                       ! singular vectors of l in work(ir)
                       ! (cworkspace: need m*m)
                       ! (rworkspace: need bdspac)
                       call stdlib_cbdsqr( 'U', m, m, 0, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                 cdum, 1, cdum, 1,rwork( irwork ), info )
                       iu = itauq
                       ! multiply right singular vectors of l in work(ir) by q
                       ! in a, storing result in work(iu) and copying to a
                       ! (cworkspace: need m*m+m, prefer m*m+m*n)
                       ! (rworkspace: 0)
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_cgemm( 'N', 'N', m, blk, m, cone, work( ir ),ldwrkr, a( 1, &
                                    i ), lda, czero,work( iu ), ldwrku )
                          call stdlib_clacpy( 'F', m, blk, work( iu ), ldwrku,a( 1, i ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       ie = 1
                       itauq = 1
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize a
                       ! (cworkspace: need 2*m+n, prefer 2*m+(m+n)*nb)
                       ! (rworkspace: need m)
                       call stdlib_cgebrd( m, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing a
                       ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'P', m, n, m, a, lda, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + m
                       ! perform bidiagonal qr iteration, computing right
                       ! singular vectors of a in a
                       ! (cworkspace: 0)
                       ! (rworkspace: need bdspac)
                       call stdlib_cbdsqr( 'L', m, n, 0, 0, s, rwork( ie ), a, lda,cdum, 1, cdum, &
                                 1, rwork( irwork ), info )
                    end if
                 else if( wntvo .and. wntuas ) then
                    ! path 3t(n much larger than m, jobu='s' or 'a', jobvt='o')
                    ! m right singular vectors to be overwritten on a and
                    ! m left singular vectors to be computed in u
                    if( lwork>=m*m+3*m ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n )+lda*m ) then
                          ! work(iu) is lda by n and work(ir) is lda by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n )+m*m ) then
                          ! work(iu) is lda by n and work(ir) is m by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = m
                       else
                          ! work(iu) is m by chunk and work(ir) is m by m
                          ldwrku = m
                          chunk = ( lwork-m*m ) / m
                          ldwrkr = m
                       end if
                       itau = ir + ldwrkr*m
                       iwork = itau + m
                       ! compute a=l*q
                       ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to u, zeroing about above it
                       call stdlib_clacpy( 'L', m, m, a, lda, u, ldu )
                       if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero, u( 1, 2 ),ldu )
                       ! generate q in a
                       ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cunglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in u, copying result to work(ir)
                       ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                       ! (rworkspace: need m)
                       call stdlib_cgebrd( m, m, u, ldu, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       call stdlib_clacpy( 'U', m, m, u, ldu, work( ir ), ldwrkr )
                       ! generate right vectors bidiagonalizing l in work(ir)
                       ! (cworkspace: need m*m+3*m-1, prefer m*m+2*m+(m-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing l in u
                       ! (cworkspace: need m*m+3*m, prefer m*m+2*m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + m
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of l in u, and computing right
                       ! singular vectors of l in work(ir)
                       ! (cworkspace: need m*m)
                       ! (rworkspace: need bdspac)
                       call stdlib_cbdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( ir ), ldwrkr, u, &
                                 ldu, cdum, 1,rwork( irwork ), info )
                       iu = itauq
                       ! multiply right singular vectors of l in work(ir) by q
                       ! in a, storing result in work(iu) and copying to a
                       ! (cworkspace: need m*m+m, prefer m*m+m*n))
                       ! (rworkspace: 0)
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_cgemm( 'N', 'N', m, blk, m, cone, work( ir ),ldwrkr, a( 1, &
                                    i ), lda, czero,work( iu ), ldwrku )
                          call stdlib_clacpy( 'F', m, blk, work( iu ), ldwrku,a( 1, i ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       itau = 1
                       iwork = itau + m
                       ! compute a=l*q
                       ! (cworkspace: need 2*m, prefer m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to u, zeroing out above it
                       call stdlib_clacpy( 'L', m, m, a, lda, u, ldu )
                       if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero, u( 1, 2 ),ldu )
                       ! generate q in a
                       ! (cworkspace: need 2*m, prefer m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cunglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in u
                       ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                       ! (rworkspace: need m)
                       call stdlib_cgebrd( m, m, u, ldu, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! multiply right vectors bidiagonalizing l by q in a
                       ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_cunmbr( 'P', 'L', 'C', m, n, m, u, ldu,work( itaup ), a, lda, &
                                 work( iwork ),lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing l in u
                       ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_cungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + m
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in u and computing right
                       ! singular vectors of a in a
                       ! (cworkspace: 0)
                       ! (rworkspace: need bdspac)
                       call stdlib_cbdsqr( 'U', m, n, m, 0, s, rwork( ie ), a, lda,u, ldu, cdum, &
                                 1, rwork( irwork ), info )
                    end if
                 else if( wntvs ) then
                    if( wntun ) then
                       ! path 4t(n much larger than m, jobu='n', jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! no left singular vectors to be computed
                       if( lwork>=m*m+3*m ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(ir) is lda by m
                             ldwrkr = lda
                          else
                             ! work(ir) is m by m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(ir), zeroing out above it
                          call stdlib_clacpy( 'L', m, m, a, lda, work( ir ),ldwrkr )
                          call stdlib_claset( 'U', m-1, m-1, czero, czero,work( ir+ldwrkr ), &
                                    ldwrkr )
                          ! generate q in a
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(ir)
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, work( ir ), ldwrkr, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate right vectors bidiagonalizing l in
                          ! work(ir)
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of l in work(ir)
                          ! (cworkspace: need m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, m, 0, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                    cdum, 1, cdum, 1,rwork( irwork ), info )
                          ! multiply right singular vectors of l in work(ir) by
                          ! q in a, storing result in vt
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, m, cone, work( ir ),ldwrkr, a, lda, &
                                    czero, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy result to vt
                          call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero,a( 1, 2 ), lda )
                          ! bidiagonalize l in a
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right vectors bidiagonalizing l by q in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'P', 'L', 'C', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, n, 0, 0, s, rwork( ie ), vt,ldvt, cdum, 1, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    else if( wntuo ) then
                       ! path 5t(n much larger than m, jobu='o', jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! m left singular vectors to be overwritten on a
                       if( lwork>=2*m*m+3*m ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*m ) then
                             ! work(iu) is lda by m and work(ir) is lda by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+m )*m ) then
                             ! work(iu) is lda by m and work(ir) is m by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          else
                             ! work(iu) is m by m and work(ir) is m by m
                             ldwrku = m
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (cworkspace: need 2*m*m+2*m, prefer 2*m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(iu), zeroing out below it
                          call stdlib_clacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_claset( 'U', m-1, m-1, czero, czero,work( iu+ldwrku ), &
                                    ldwrku )
                          ! generate q in a
                          ! (cworkspace: need 2*m*m+2*m, prefer 2*m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to
                          ! work(ir)
                          ! (cworkspace: need   2*m*m+3*m,
                                       ! prefer 2*m*m+2*m+2*m*nb)
                          ! (rworkspace: need   m)
                          call stdlib_cgebrd( m, m, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, m, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need   2*m*m+3*m-1,
                                       ! prefer 2*m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need 2*m*m+3*m, prefer 2*m*m+2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', m, m, m, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in work(ir) and computing
                          ! right singular vectors of l in work(iu)
                          ! (cworkspace: need 2*m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( iu ), ldwrku, &
                                    work( ir ),ldwrkr, cdum, 1, rwork( irwork ),info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in a, storing result in vt
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, m, cone, work( iu ),ldwrku, a, lda, &
                                    czero, vt, ldvt )
                          ! copy left singular vectors of l to a
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_clacpy( 'F', m, m, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero,a( 1, 2 ), lda )
                          ! bidiagonalize l in a
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right vectors bidiagonalizing l by q in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'P', 'L', 'C', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors of l in a
                          ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in a and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, n, m, 0, s, rwork( ie ), vt,ldvt, a, lda, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    else if( wntuas ) then
                       ! path 6t(n much larger than m, jobu='s' or 'a',
                               ! jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! m left singular vectors to be computed in u
                       if( lwork>=m*m+3*m ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is lda by m
                             ldwrku = m
                          end if
                          itau = iu + ldwrku*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_clacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_claset( 'U', m-1, m-1, czero, czero,work( iu+ldwrku ), &
                                    ldwrku )
                          ! generate q in a
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to u
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, m, work( iu ), ldwrku, u,ldu )
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need   m*m+3*m-1,
                                       ! prefer m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in u and computing right
                          ! singular vectors of l in work(iu)
                          ! (cworkspace: need m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( iu ), ldwrku, &
                                    u, ldu, cdum, 1,rwork( irwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in a, storing result in vt
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, m, cone, work( iu ),ldwrku, a, lda, &
                                    czero, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to u, zeroing out above it
                          call stdlib_clacpy( 'L', m, m, a, lda, u, ldu )
                          if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero,u( 1, 2 ), ldu )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in u
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, u, ldu, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in u by q
                          ! in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'P', 'L', 'C', m, n, m, u, ldu,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, n, m, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    end if
                 else if( wntva ) then
                    if( wntun ) then
                       ! path 7t(n much larger than m, jobu='n', jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! no left singular vectors to be computed
                       if( lwork>=m*m+max( n+m, 3*m ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(ir) is lda by m
                             ldwrkr = lda
                          else
                             ! work(ir) is m by m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! copy l to work(ir), zeroing out above it
                          call stdlib_clacpy( 'L', m, m, a, lda, work( ir ),ldwrkr )
                          call stdlib_claset( 'U', m-1, m-1, czero, czero,work( ir+ldwrkr ), &
                                    ldwrkr )
                          ! generate q in vt
                          ! (cworkspace: need m*m+m+n, prefer m*m+m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(ir)
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, work( ir ), ldwrkr, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need   m*m+3*m-1,
                                       ! prefer m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of l in work(ir)
                          ! (cworkspace: need m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, m, 0, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                    cdum, 1, cdum, 1,rwork( irwork ), info )
                          ! multiply right singular vectors of l in work(ir) by
                          ! q in vt, storing result in a
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, m, cone, work( ir ),ldwrkr, vt, ldvt,&
                                     czero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_clacpy( 'F', m, n, a, lda, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need m+n, prefer m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero,a( 1, 2 ), lda )
                          ! bidiagonalize l in a
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in a by q
                          ! in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'P', 'L', 'C', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, n, 0, 0, s, rwork( ie ), vt,ldvt, cdum, 1, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    else if( wntuo ) then
                       ! path 8t(n much larger than m, jobu='o', jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! m left singular vectors to be overwritten on a
                       if( lwork>=2*m*m+max( n+m, 3*m ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*m ) then
                             ! work(iu) is lda by m and work(ir) is lda by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+m )*m ) then
                             ! work(iu) is lda by m and work(ir) is m by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          else
                             ! work(iu) is m by m and work(ir) is m by m
                             ldwrku = m
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m*m+2*m, prefer 2*m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need 2*m*m+m+n, prefer 2*m*m+m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_clacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_claset( 'U', m-1, m-1, czero, czero,work( iu+ldwrku ), &
                                    ldwrku )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to
                          ! work(ir)
                          ! (cworkspace: need   2*m*m+3*m,
                                       ! prefer 2*m*m+2*m+2*m*nb)
                          ! (rworkspace: need   m)
                          call stdlib_cgebrd( m, m, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, m, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need   2*m*m+3*m-1,
                                       ! prefer 2*m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need 2*m*m+3*m, prefer 2*m*m+2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', m, m, m, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in work(ir) and computing
                          ! right singular vectors of l in work(iu)
                          ! (cworkspace: need 2*m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( iu ), ldwrku, &
                                    work( ir ),ldwrkr, cdum, 1, rwork( irwork ),info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in vt, storing result in a
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, m, cone, work( iu ),ldwrku, vt, ldvt,&
                                     czero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_clacpy( 'F', m, n, a, lda, vt, ldvt )
                          ! copy left singular vectors of a from work(ir) to a
                          call stdlib_clacpy( 'F', m, m, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need m+n, prefer m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero,a( 1, 2 ), lda )
                          ! bidiagonalize l in a
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in a by q
                          ! in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'P', 'L', 'C', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in a
                          ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in a and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, n, m, 0, s, rwork( ie ), vt,ldvt, a, lda, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    else if( wntuas ) then
                       ! path 9t(n much larger than m, jobu='s' or 'a',
                               ! jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! m left singular vectors to be computed in u
                       if( lwork>=m*m+max( n+m, 3*m ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(iu) is lda by m
                             ldwrku = lda
                          else
                             ! work(iu) is m by m
                             ldwrku = m
                          end if
                          itau = iu + ldwrku*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need m*m+m+n, prefer m*m+m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_clacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_claset( 'U', m-1, m-1, czero, czero,work( iu+ldwrku ), &
                                    ldwrku )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to u
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_clacpy( 'L', m, m, work( iu ), ldwrku, u,ldu )
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in u and computing right
                          ! singular vectors of l in work(iu)
                          ! (cworkspace: need m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( iu ), ldwrku, &
                                    u, ldu, cdum, 1,rwork( irwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in vt, storing result in a
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_cgemm( 'N', 'N', m, n, m, cone, work( iu ),ldwrku, vt, ldvt,&
                                     czero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_clacpy( 'F', m, n, a, lda, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need m+n, prefer m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to u, zeroing out above it
                          call stdlib_clacpy( 'L', m, m, a, lda, u, ldu )
                          if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero,u( 1, 2 ), ldu )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in u
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_cgebrd( m, m, u, ldu, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in u by q
                          ! in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_cunmbr( 'P', 'L', 'C', m, n, m, u, ldu,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_cungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_cbdsqr( 'U', m, n, m, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    end if
                 end if
              else
                 ! n < mnthr
                 ! path 10t(n greater than m, but not much larger)
                 ! reduce to bidiagonal form without lq decomposition
                 ie = 1
                 itauq = 1
                 itaup = itauq + m
                 iwork = itaup + m
                 ! bidiagonalize a
                 ! (cworkspace: need 2*m+n, prefer 2*m+(m+n)*nb)
                 ! (rworkspace: m)
                 call stdlib_cgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( iwork ), lwork-iwork+1,ierr )
                 if( wntuas ) then
                    ! if left singular vectors desired in u, copy result to u
                    ! and generate left bidiagonalizing vectors in u
                    ! (cworkspace: need 3*m-1, prefer 2*m+(m-1)*nb)
                    ! (rworkspace: 0)
                    call stdlib_clacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_cungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvas ) then
                    ! if right singular vectors desired in vt, copy result to
                    ! vt and generate right bidiagonalizing vectors in vt
                    ! (cworkspace: need 2*m+nrvt, prefer 2*m+nrvt*nb)
                    ! (rworkspace: 0)
                    call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                    if( wntva )nrvt = n
                    if( wntvs )nrvt = m
                    call stdlib_cungbr( 'P', nrvt, n, m, vt, ldvt, work( itaup ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntuo ) then
                    ! if left singular vectors desired in a, generate left
                    ! bidiagonalizing vectors in a
                    ! (cworkspace: need 3*m-1, prefer 2*m+(m-1)*nb)
                    ! (rworkspace: 0)
                    call stdlib_cungbr( 'Q', m, m, n, a, lda, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvo ) then
                    ! if right singular vectors desired in a, generate right
                    ! bidiagonalizing vectors in a
                    ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                    ! (rworkspace: 0)
                    call stdlib_cungbr( 'P', m, n, m, a, lda, work( itaup ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 irwork = ie + m
                 if( wntuas .or. wntuo )nru = m
                 if( wntun )nru = 0
                 if( wntvas .or. wntvo )ncvt = n
                 if( wntvn )ncvt = 0
                 if( ( .not.wntuo ) .and. ( .not.wntvo ) ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in vt
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_cbdsqr( 'L', m, ncvt, nru, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                              cdum, 1, rwork( irwork ),info )
                 else if( ( .not.wntuo ) .and. wntvo ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in a
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_cbdsqr( 'L', m, ncvt, nru, 0, s, rwork( ie ), a,lda, u, ldu, cdum,&
                               1, rwork( irwork ),info )
                 else
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in a and computing right singular
                    ! vectors in vt
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_cbdsqr( 'L', m, ncvt, nru, 0, s, rwork( ie ), vt,ldvt, a, lda, &
                              cdum, 1, rwork( irwork ),info )
                 end if
              end if
           end if
           ! undo scaling if necessary
           if( iscl==1 ) then
              if( anrm>bignum )call stdlib_slascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm>bignum )call stdlib_slascl( 'G', 0, 0, bignum, anrm, minmn-1,&
                         1,rwork( ie ), minmn, ierr )
              if( anrm<smlnum )call stdlib_slascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm<smlnum )call stdlib_slascl( 'G', 0, 0, smlnum, anrm, minmn-1,&
                         1,rwork( ie ), minmn, ierr )
           end if
           ! return optimal workspace in work(1)
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_cgesvd

     module subroutine stdlib_zgesvd( jobu, jobvt, m, n, a, lda, s, u, ldu,vt, ldvt, work, lwork, rwork, &
     !! ZGESVD computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, optionally computing the left and/or right singular
     !! vectors. The SVD is written
     !! A = U * SIGMA * conjugate-transpose(V)
     !! where SIGMA is an M-by-N matrix which is zero except for its
     !! min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
     !! V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
     !! are the singular values of A; they are real and non-negative, and
     !! are returned in descending order.  The first min(m,n) columns of
     !! U and V are the left and right singular vectors of A.
     !! Note that the routine returns V**H, not V.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobu, jobvt
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldvt, lwork, m, n
           ! Array Arguments 
           real(dp), intent(out) :: rwork(*), s(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lquery, wntua, wntuas, wntun, wntuo, wntus, wntva, wntvas, wntvn, wntvo,&
                      wntvs
           integer(ilp) :: blk, chunk, i, ie, ierr, ir, irwork, iscl, itau, itaup, itauq, iu, &
           iwork, ldwrkr, ldwrku, maxwrk, minmn, minwrk, mnthr, ncu, ncvt, nru, nrvt, &
                     wrkbl
           integer(ilp) :: lwork_zgeqrf, lwork_zungqr_n, lwork_zungqr_m, lwork_zgebrd, &
                     lwork_zungbr_p, lwork_zungbr_q, lwork_zgelqf, lwork_zunglq_n, lwork_zunglq_m
           real(dp) :: anrm, bignum, eps, smlnum
           ! Local Arrays 
           real(dp) :: dum(1)
           complex(dp) :: cdum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           minmn = min( m, n )
           wntua = stdlib_lsame( jobu, 'A' )
           wntus = stdlib_lsame( jobu, 'S' )
           wntuas = wntua .or. wntus
           wntuo = stdlib_lsame( jobu, 'O' )
           wntun = stdlib_lsame( jobu, 'N' )
           wntva = stdlib_lsame( jobvt, 'A' )
           wntvs = stdlib_lsame( jobvt, 'S' )
           wntvas = wntva .or. wntvs
           wntvo = stdlib_lsame( jobvt, 'O' )
           wntvn = stdlib_lsame( jobvt, 'N' )
           lquery = ( lwork==-1 )
           if( .not.( wntua .or. wntus .or. wntuo .or. wntun ) ) then
              info = -1
           else if( .not.( wntva .or. wntvs .or. wntvo .or. wntvn ) .or.( wntvo .and. wntuo ) ) &
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( ldu<1 .or. ( wntuas .and. ldu<m ) ) then
              info = -9
           else if( ldvt<1 .or. ( wntva .and. ldvt<n ) .or.( wntvs .and. ldvt<minmn ) ) &
                     then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to
             ! real workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              if( m>=n .and. minmn>0 ) then
                 ! space needed for stdlib_zbdsqr is bdspac = 5*n
                 mnthr = stdlib_ilaenv( 6, 'ZGESVD', jobu // jobvt, m, n, 0, 0 )
                 ! compute space needed for stdlib_zgeqrf
                 call stdlib_zgeqrf( m, n, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_zgeqrf = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_zungqr
                 call stdlib_zungqr( m, n, n, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_zungqr_n = int( cdum(1),KIND=ilp)
                 call stdlib_zungqr( m, m, n, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_zungqr_m = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_zgebrd
                 call stdlib_zgebrd( n, n, a, lda, s, dum(1), cdum(1),cdum(1), cdum(1), -1, ierr )
                           
                 lwork_zgebrd = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_zungbr
                 call stdlib_zungbr( 'P', n, n, n, a, lda, cdum(1),cdum(1), -1, ierr )
                 lwork_zungbr_p = int( cdum(1),KIND=ilp)
                 call stdlib_zungbr( 'Q', n, n, n, a, lda, cdum(1),cdum(1), -1, ierr )
                 lwork_zungbr_q = int( cdum(1),KIND=ilp)
                 if( m>=mnthr ) then
                    if( wntun ) then
                       ! path 1 (m much larger than n, jobu='n')
                       maxwrk = n + lwork_zgeqrf
                       maxwrk = max( maxwrk, 2*n+lwork_zgebrd )
                       if( wntvo .or. wntvas )maxwrk = max( maxwrk, 2*n+lwork_zungbr_p )
                       minwrk = 3*n
                    else if( wntuo .and. wntvn ) then
                       ! path 2 (m much larger than n, jobu='o', jobvt='n')
                       wrkbl = n + lwork_zgeqrf
                       wrkbl = max( wrkbl, n+lwork_zungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_zgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_zungbr_q )
                       maxwrk = max( n*n+wrkbl, n*n+m*n )
                       minwrk = 2*n + m
                    else if( wntuo .and. wntvas ) then
                       ! path 3 (m much larger than n, jobu='o', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_zgeqrf
                       wrkbl = max( wrkbl, n+lwork_zungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_zgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_zungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_zungbr_p )
                       maxwrk = max( n*n+wrkbl, n*n+m*n )
                       minwrk = 2*n + m
                    else if( wntus .and. wntvn ) then
                       ! path 4 (m much larger than n, jobu='s', jobvt='n')
                       wrkbl = n + lwork_zgeqrf
                       wrkbl = max( wrkbl, n+lwork_zungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_zgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_zungbr_q )
                       maxwrk = n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntus .and. wntvo ) then
                       ! path 5 (m much larger than n, jobu='s', jobvt='o')
                       wrkbl = n + lwork_zgeqrf
                       wrkbl = max( wrkbl, n+lwork_zungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_zgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_zungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_zungbr_p )
                       maxwrk = 2*n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntus .and. wntvas ) then
                       ! path 6 (m much larger than n, jobu='s', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_zgeqrf
                       wrkbl = max( wrkbl, n+lwork_zungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_zgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_zungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_zungbr_p )
                       maxwrk = n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntua .and. wntvn ) then
                       ! path 7 (m much larger than n, jobu='a', jobvt='n')
                       wrkbl = n + lwork_zgeqrf
                       wrkbl = max( wrkbl, n+lwork_zungqr_m )
                       wrkbl = max( wrkbl, 2*n+lwork_zgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_zungbr_q )
                       maxwrk = n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntua .and. wntvo ) then
                       ! path 8 (m much larger than n, jobu='a', jobvt='o')
                       wrkbl = n + lwork_zgeqrf
                       wrkbl = max( wrkbl, n+lwork_zungqr_m )
                       wrkbl = max( wrkbl, 2*n+lwork_zgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_zungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_zungbr_p )
                       maxwrk = 2*n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntua .and. wntvas ) then
                       ! path 9 (m much larger than n, jobu='a', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_zgeqrf
                       wrkbl = max( wrkbl, n+lwork_zungqr_m )
                       wrkbl = max( wrkbl, 2*n+lwork_zgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_zungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_zungbr_p )
                       maxwrk = n*n + wrkbl
                       minwrk = 2*n + m
                    end if
                 else
                    ! path 10 (m at least n, but not much larger)
                    call stdlib_zgebrd( m, n, a, lda, s, dum(1), cdum(1),cdum(1), cdum(1), -1, &
                              ierr )
                    lwork_zgebrd = int( cdum(1),KIND=ilp)
                    maxwrk = 2*n + lwork_zgebrd
                    if( wntus .or. wntuo ) then
                       call stdlib_zungbr( 'Q', m, n, n, a, lda, cdum(1),cdum(1), -1, ierr )
                                 
                       lwork_zungbr_q = int( cdum(1),KIND=ilp)
                       maxwrk = max( maxwrk, 2*n+lwork_zungbr_q )
                    end if
                    if( wntua ) then
                       call stdlib_zungbr( 'Q', m, m, n, a, lda, cdum(1),cdum(1), -1, ierr )
                                 
                       lwork_zungbr_q = int( cdum(1),KIND=ilp)
                       maxwrk = max( maxwrk, 2*n+lwork_zungbr_q )
                    end if
                    if( .not.wntvn ) then
                       maxwrk = max( maxwrk, 2*n+lwork_zungbr_p )
                    end if
                    minwrk = 2*n + m
                 end if
              else if( minmn>0 ) then
                 ! space needed for stdlib_zbdsqr is bdspac = 5*m
                 mnthr = stdlib_ilaenv( 6, 'ZGESVD', jobu // jobvt, m, n, 0, 0 )
                 ! compute space needed for stdlib_zgelqf
                 call stdlib_zgelqf( m, n, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_zgelqf = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_zunglq
                 call stdlib_zunglq( n, n, m, cdum(1), n, cdum(1), cdum(1), -1,ierr )
                 lwork_zunglq_n = int( cdum(1),KIND=ilp)
                 call stdlib_zunglq( m, n, m, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_zunglq_m = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_zgebrd
                 call stdlib_zgebrd( m, m, a, lda, s, dum(1), cdum(1),cdum(1), cdum(1), -1, ierr )
                           
                 lwork_zgebrd = int( cdum(1),KIND=ilp)
                  ! compute space needed for stdlib_zungbr p
                 call stdlib_zungbr( 'P', m, m, m, a, n, cdum(1),cdum(1), -1, ierr )
                 lwork_zungbr_p = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_zungbr q
                 call stdlib_zungbr( 'Q', m, m, m, a, n, cdum(1),cdum(1), -1, ierr )
                 lwork_zungbr_q = int( cdum(1),KIND=ilp)
                 if( n>=mnthr ) then
                    if( wntvn ) then
                       ! path 1t(n much larger than m, jobvt='n')
                       maxwrk = m + lwork_zgelqf
                       maxwrk = max( maxwrk, 2*m+lwork_zgebrd )
                       if( wntuo .or. wntuas )maxwrk = max( maxwrk, 2*m+lwork_zungbr_q )
                       minwrk = 3*m
                    else if( wntvo .and. wntun ) then
                       ! path 2t(n much larger than m, jobu='n', jobvt='o')
                       wrkbl = m + lwork_zgelqf
                       wrkbl = max( wrkbl, m+lwork_zunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_zgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_zungbr_p )
                       maxwrk = max( m*m+wrkbl, m*m+m*n )
                       minwrk = 2*m + n
                    else if( wntvo .and. wntuas ) then
                       ! path 3t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='o')
                       wrkbl = m + lwork_zgelqf
                       wrkbl = max( wrkbl, m+lwork_zunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_zgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_zungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_zungbr_q )
                       maxwrk = max( m*m+wrkbl, m*m+m*n )
                       minwrk = 2*m + n
                    else if( wntvs .and. wntun ) then
                       ! path 4t(n much larger than m, jobu='n', jobvt='s')
                       wrkbl = m + lwork_zgelqf
                       wrkbl = max( wrkbl, m+lwork_zunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_zgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_zungbr_p )
                       maxwrk = m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntvs .and. wntuo ) then
                       ! path 5t(n much larger than m, jobu='o', jobvt='s')
                       wrkbl = m + lwork_zgelqf
                       wrkbl = max( wrkbl, m+lwork_zunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_zgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_zungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_zungbr_q )
                       maxwrk = 2*m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntvs .and. wntuas ) then
                       ! path 6t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='s')
                       wrkbl = m + lwork_zgelqf
                       wrkbl = max( wrkbl, m+lwork_zunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_zgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_zungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_zungbr_q )
                       maxwrk = m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntva .and. wntun ) then
                       ! path 7t(n much larger than m, jobu='n', jobvt='a')
                       wrkbl = m + lwork_zgelqf
                       wrkbl = max( wrkbl, m+lwork_zunglq_n )
                       wrkbl = max( wrkbl, 2*m+lwork_zgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_zungbr_p )
                       maxwrk = m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntva .and. wntuo ) then
                       ! path 8t(n much larger than m, jobu='o', jobvt='a')
                       wrkbl = m + lwork_zgelqf
                       wrkbl = max( wrkbl, m+lwork_zunglq_n )
                       wrkbl = max( wrkbl, 2*m+lwork_zgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_zungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_zungbr_q )
                       maxwrk = 2*m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntva .and. wntuas ) then
                       ! path 9t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='a')
                       wrkbl = m + lwork_zgelqf
                       wrkbl = max( wrkbl, m+lwork_zunglq_n )
                       wrkbl = max( wrkbl, 2*m+lwork_zgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_zungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_zungbr_q )
                       maxwrk = m*m + wrkbl
                       minwrk = 2*m + n
                    end if
                 else
                    ! path 10t(n greater than m, but not much larger)
                    call stdlib_zgebrd( m, n, a, lda, s, dum(1), cdum(1),cdum(1), cdum(1), -1, &
                              ierr )
                    lwork_zgebrd = int( cdum(1),KIND=ilp)
                    maxwrk = 2*m + lwork_zgebrd
                    if( wntvs .or. wntvo ) then
                      ! compute space needed for stdlib_zungbr p
                      call stdlib_zungbr( 'P', m, n, m, a, n, cdum(1),cdum(1), -1, ierr )
                      lwork_zungbr_p = int( cdum(1),KIND=ilp)
                      maxwrk = max( maxwrk, 2*m+lwork_zungbr_p )
                    end if
                    if( wntva ) then
                      call stdlib_zungbr( 'P', n,  n, m, a, n, cdum(1),cdum(1), -1, ierr )
                      lwork_zungbr_p = int( cdum(1),KIND=ilp)
                      maxwrk = max( maxwrk, 2*m+lwork_zungbr_p )
                    end if
                    if( .not.wntun ) then
                       maxwrk = max( maxwrk, 2*m+lwork_zungbr_q )
                    end if
                    minwrk = 2*m + n
                 end if
              end if
              maxwrk = max( maxwrk, minwrk )
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGESVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = sqrt( stdlib_dlamch( 'S' ) ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_zlange( 'M', m, n, a, lda, dum )
           iscl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              iscl = 1
              call stdlib_zlascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, ierr )
           else if( anrm>bignum ) then
              iscl = 1
              call stdlib_zlascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, ierr )
           end if
           if( m>=n ) then
              ! a has at least as many rows as columns. if a has sufficiently
              ! more rows than columns, first reduce using the qr
              ! decomposition (if sufficient workspace available)
              if( m>=mnthr ) then
                 if( wntun ) then
                    ! path 1 (m much larger than n, jobu='n')
                    ! no left singular vectors to be computed
                    itau = 1
                    iwork = itau + n
                    ! compute a=q*r
                    ! (cworkspace: need 2*n, prefer n+n*nb)
                    ! (rworkspace: need 0)
                    call stdlib_zgeqrf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, &
                              ierr )
                    ! zero out below r
                    if( n > 1 ) then
                       call stdlib_zlaset( 'L', n-1, n-1, czero, czero, a( 2, 1 ),lda )
                    end if
                    ie = 1
                    itauq = 1
                    itaup = itauq + n
                    iwork = itaup + n
                    ! bidiagonalize r in a
                    ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                    ! (rworkspace: need n)
                    call stdlib_zgebrd( n, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( iwork ), lwork-iwork+1,ierr )
                    ncvt = 0
                    if( wntvo .or. wntvas ) then
                       ! if right singular vectors desired, generate p'.
                       ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_zungbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       ncvt = n
                    end if
                    irwork = ie + n
                    ! perform bidiagonal qr iteration, computing right
                    ! singular vectors of a in a if desired
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_zbdsqr( 'U', n, ncvt, 0, 0, s, rwork( ie ), a, lda,cdum, 1, cdum, &
                              1, rwork( irwork ), info )
                    ! if right singular vectors desired in vt, copy them there
                    if( wntvas )call stdlib_zlacpy( 'F', n, n, a, lda, vt, ldvt )
                 else if( wntuo .and. wntvn ) then
                    ! path 2 (m much larger than n, jobu='o', jobvt='n')
                    ! n left singular vectors to be overwritten on a and
                    ! no right singular vectors to be computed
                    if( lwork>=n*n+3*n ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n )+lda*n ) then
                          ! work(iu) is lda by n, work(ir) is lda by n
                          ldwrku = lda
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n )+n*n ) then
                          ! work(iu) is lda by n, work(ir) is n by n
                          ldwrku = lda
                          ldwrkr = n
                       else
                          ! work(iu) is ldwrku by n, work(ir) is n by n
                          ldwrku = ( lwork-n*n ) / n
                          ldwrkr = n
                       end if
                       itau = ir + ldwrkr*n
                       iwork = itau + n
                       ! compute a=q*r
                       ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_zgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to work(ir) and zero out below it
                       call stdlib_zlacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                       call stdlib_zlaset( 'L', n-1, n-1, czero, czero,work( ir+1 ), ldwrkr )
                                 
                       ! generate q in a
                       ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_zungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in work(ir)
                       ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                       ! (rworkspace: need n)
                       call stdlib_zgebrd( n, n, work( ir ), ldwrkr, s, rwork( ie ),work( itauq ),&
                                  work( itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing r
                       ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                       ! (rworkspace: need 0)
                       call stdlib_zungbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       irwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of r in work(ir)
                       ! (cworkspace: need n*n)
                       ! (rworkspace: need bdspac)
                       call stdlib_zbdsqr( 'U', n, 0, n, 0, s, rwork( ie ), cdum, 1,work( ir ), &
                                 ldwrkr, cdum, 1,rwork( irwork ), info )
                       iu = itauq
                       ! multiply q in a by left singular vectors of r in
                       ! work(ir), storing result in work(iu) and copying to a
                       ! (cworkspace: need n*n+n, prefer n*n+m*n)
                       ! (rworkspace: 0)
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_zgemm( 'N', 'N', chunk, n, n, cone, a( i, 1 ),lda, work( ir &
                                    ), ldwrkr, czero,work( iu ), ldwrku )
                          call stdlib_zlacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       ie = 1
                       itauq = 1
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize a
                       ! (cworkspace: need 2*n+m, prefer 2*n+(m+n)*nb)
                       ! (rworkspace: n)
                       call stdlib_zgebrd( m, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing a
                       ! (cworkspace: need 3*n, prefer 2*n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_zungbr( 'Q', m, n, n, a, lda, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in a
                       ! (cworkspace: need 0)
                       ! (rworkspace: need bdspac)
                       call stdlib_zbdsqr( 'U', n, 0, m, 0, s, rwork( ie ), cdum, 1,a, lda, cdum, &
                                 1, rwork( irwork ), info )
                    end if
                 else if( wntuo .and. wntvas ) then
                    ! path 3 (m much larger than n, jobu='o', jobvt='s' or 'a')
                    ! n left singular vectors to be overwritten on a and
                    ! n right singular vectors to be computed in vt
                    if( lwork>=n*n+3*n ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n )+lda*n ) then
                          ! work(iu) is lda by n and work(ir) is lda by n
                          ldwrku = lda
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n )+n*n ) then
                          ! work(iu) is lda by n and work(ir) is n by n
                          ldwrku = lda
                          ldwrkr = n
                       else
                          ! work(iu) is ldwrku by n and work(ir) is n by n
                          ldwrku = ( lwork-n*n ) / n
                          ldwrkr = n
                       end if
                       itau = ir + ldwrkr*n
                       iwork = itau + n
                       ! compute a=q*r
                       ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_zgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to vt, zeroing out below it
                       call stdlib_zlacpy( 'U', n, n, a, lda, vt, ldvt )
                       if( n>1 )call stdlib_zlaset( 'L', n-1, n-1, czero, czero,vt( 2, 1 ), ldvt )
                                 
                       ! generate q in a
                       ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_zungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in vt, copying result to work(ir)
                       ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                       ! (rworkspace: need n)
                       call stdlib_zgebrd( n, n, vt, ldvt, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       call stdlib_zlacpy( 'L', n, n, vt, ldvt, work( ir ), ldwrkr )
                       ! generate left vectors bidiagonalizing r in work(ir)
                       ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_zungbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing r in vt
                       ! (cworkspace: need n*n+3*n-1, prefer n*n+2*n+(n-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_zungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of r in work(ir) and computing right
                       ! singular vectors of r in vt
                       ! (cworkspace: need n*n)
                       ! (rworkspace: need bdspac)
                       call stdlib_zbdsqr( 'U', n, n, n, 0, s, rwork( ie ), vt,ldvt, work( ir ), &
                                 ldwrkr, cdum, 1,rwork( irwork ), info )
                       iu = itauq
                       ! multiply q in a by left singular vectors of r in
                       ! work(ir), storing result in work(iu) and copying to a
                       ! (cworkspace: need n*n+n, prefer n*n+m*n)
                       ! (rworkspace: 0)
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_zgemm( 'N', 'N', chunk, n, n, cone, a( i, 1 ),lda, work( ir &
                                    ), ldwrkr, czero,work( iu ), ldwrku )
                          call stdlib_zlacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       itau = 1
                       iwork = itau + n
                       ! compute a=q*r
                       ! (cworkspace: need 2*n, prefer n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_zgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to vt, zeroing out below it
                       call stdlib_zlacpy( 'U', n, n, a, lda, vt, ldvt )
                       if( n>1 )call stdlib_zlaset( 'L', n-1, n-1, czero, czero,vt( 2, 1 ), ldvt )
                                 
                       ! generate q in a
                       ! (cworkspace: need 2*n, prefer n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_zungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in vt
                       ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                       ! (rworkspace: n)
                       call stdlib_zgebrd( n, n, vt, ldvt, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! multiply q in a by left vectors bidiagonalizing r
                       ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_zunmbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), a, lda,&
                                  work( iwork ),lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing r in vt
                       ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_zungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in a and computing right
                       ! singular vectors of a in vt
                       ! (cworkspace: 0)
                       ! (rworkspace: need bdspac)
                       call stdlib_zbdsqr( 'U', n, n, m, 0, s, rwork( ie ), vt,ldvt, a, lda, cdum,&
                                  1, rwork( irwork ),info )
                    end if
                 else if( wntus ) then
                    if( wntvn ) then
                       ! path 4 (m much larger than n, jobu='s', jobvt='n')
                       ! n left singular vectors to be computed in u and
                       ! no right singular vectors to be computed
                       if( lwork>=n*n+3*n ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(ir) is lda by n
                             ldwrkr = lda
                          else
                             ! work(ir) is n by n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(ir), zeroing out below it
                          call stdlib_zlacpy( 'U', n, n, a, lda, work( ir ),ldwrkr )
                          call stdlib_zlaset( 'L', n-1, n-1, czero, czero,work( ir+1 ), ldwrkr )
                                    
                          ! generate q in a
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(ir)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_zgebrd( n, n, work( ir ), ldwrkr, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate left vectors bidiagonalizing r in work(ir)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(ir)
                          ! (cworkspace: need n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', n, 0, n, 0, s, rwork( ie ), cdum,1, work( ir ),&
                                     ldwrkr, cdum, 1,rwork( irwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(ir), storing result in u
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_zgemm( 'N', 'N', m, n, n, cone, a, lda,work( ir ), ldwrkr, &
                                    czero, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_zlacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_zlaset( 'L', n-1, n-1, czero, czero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_zgebrd( n, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left vectors bidiagonalizing r
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunmbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', n, 0, m, 0, s, rwork( ie ), cdum,1, u, ldu, &
                                    cdum, 1, rwork( irwork ),info )
                       end if
                    else if( wntvo ) then
                       ! path 5 (m much larger than n, jobu='s', jobvt='o')
                       ! n left singular vectors to be computed in u and
                       ! n right singular vectors to be overwritten on a
                       if( lwork>=2*n*n+3*n ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*n ) then
                             ! work(iu) is lda by n and work(ir) is lda by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+n )*n ) then
                             ! work(iu) is lda by n and work(ir) is n by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          else
                             ! work(iu) is n by n and work(ir) is n by n
                             ldwrku = n
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (cworkspace: need 2*n*n+2*n, prefer 2*n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_zlacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_zlaset( 'L', n-1, n-1, czero, czero,work( iu+1 ), ldwrku )
                                    
                          ! generate q in a
                          ! (cworkspace: need 2*n*n+2*n, prefer 2*n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to
                          ! work(ir)
                          ! (cworkspace: need   2*n*n+3*n,
                                       ! prefer 2*n*n+2*n+2*n*nb)
                          ! (rworkspace: need   n)
                          call stdlib_zgebrd( n, n, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_zlacpy( 'U', n, n, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need 2*n*n+3*n, prefer 2*n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need   2*n*n+3*n-1,
                                       ! prefer 2*n*n+2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'P', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in work(ir)
                          ! (cworkspace: need 2*n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', n, n, n, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                    work( iu ),ldwrku, cdum, 1, rwork( irwork ),info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(iu), storing result in u
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_zgemm( 'N', 'N', m, n, n, cone, a, lda,work( iu ), ldwrku, &
                                    czero, u, ldu )
                          ! copy right singular vectors of r to a
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_zlacpy( 'F', n, n, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_zlacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_zlaset( 'L', n-1, n-1, czero, czero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_zgebrd( n, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left vectors bidiagonalizing r
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunmbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right vectors bidiagonalizing r in a
                          ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in a
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', n, n, m, 0, s, rwork( ie ), a,lda, u, ldu, &
                                    cdum, 1, rwork( irwork ),info )
                       end if
                    else if( wntvas ) then
                       ! path 6 (m much larger than n, jobu='s', jobvt='s'
                               ! or 'a')
                       ! n left singular vectors to be computed in u and
                       ! n right singular vectors to be computed in vt
                       if( lwork>=n*n+3*n ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is n by n
                             ldwrku = n
                          end if
                          itau = iu + ldwrku*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_zlacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_zlaset( 'L', n-1, n-1, czero, czero,work( iu+1 ), ldwrku )
                                    
                          ! generate q in a
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to vt
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_zgebrd( n, n, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_zlacpy( 'U', n, n, work( iu ), ldwrku, vt,ldvt )
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (cworkspace: need   n*n+3*n-1,
                                       ! prefer n*n+2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in vt
                          ! (cworkspace: need n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', n, n, n, 0, s, rwork( ie ), vt,ldvt, work( iu )&
                                    , ldwrku, cdum, 1,rwork( irwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(iu), storing result in u
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_zgemm( 'N', 'N', m, n, n, cone, a, lda,work( iu ), ldwrku, &
                                    czero, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_zlacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to vt, zeroing out below it
                          call stdlib_zlacpy( 'U', n, n, a, lda, vt, ldvt )
                          if( n>1 )call stdlib_zlaset( 'L', n-1, n-1, czero, czero,vt( 2, 1 ), &
                                    ldvt )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in vt
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_zgebrd( n, n, vt, ldvt, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in vt
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunmbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', n, n, m, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    end if
                 else if( wntua ) then
                    if( wntvn ) then
                       ! path 7 (m much larger than n, jobu='a', jobvt='n')
                       ! m left singular vectors to be computed in u and
                       ! no right singular vectors to be computed
                       if( lwork>=n*n+max( n+m, 3*n ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(ir) is lda by n
                             ldwrkr = lda
                          else
                             ! work(ir) is n by n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_zlacpy( 'L', m, n, a, lda, u, ldu )
                          ! copy r to work(ir), zeroing out below it
                          call stdlib_zlacpy( 'U', n, n, a, lda, work( ir ),ldwrkr )
                          call stdlib_zlaset( 'L', n-1, n-1, czero, czero,work( ir+1 ), ldwrkr )
                                    
                          ! generate q in u
                          ! (cworkspace: need n*n+n+m, prefer n*n+n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(ir)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_zgebrd( n, n, work( ir ), ldwrkr, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(ir)
                          ! (cworkspace: need n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', n, 0, n, 0, s, rwork( ie ), cdum,1, work( ir ),&
                                     ldwrkr, cdum, 1,rwork( irwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(ir), storing result in a
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_zgemm( 'N', 'N', m, n, n, cone, u, ldu,work( ir ), ldwrkr, &
                                    czero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_zlacpy( 'F', m, n, a, lda, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_zlacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need n+m, prefer n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_zlaset( 'L', n-1, n-1, czero, czero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_zgebrd( n, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in a
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunmbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', n, 0, m, 0, s, rwork( ie ), cdum,1, u, ldu, &
                                    cdum, 1, rwork( irwork ),info )
                       end if
                    else if( wntvo ) then
                       ! path 8 (m much larger than n, jobu='a', jobvt='o')
                       ! m left singular vectors to be computed in u and
                       ! n right singular vectors to be overwritten on a
                       if( lwork>=2*n*n+max( n+m, 3*n ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*n ) then
                             ! work(iu) is lda by n and work(ir) is lda by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+n )*n ) then
                             ! work(iu) is lda by n and work(ir) is n by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          else
                             ! work(iu) is n by n and work(ir) is n by n
                             ldwrku = n
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n*n+2*n, prefer 2*n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_zlacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need 2*n*n+n+m, prefer 2*n*n+n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_zlacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_zlaset( 'L', n-1, n-1, czero, czero,work( iu+1 ), ldwrku )
                                    
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to
                          ! work(ir)
                          ! (cworkspace: need   2*n*n+3*n,
                                       ! prefer 2*n*n+2*n+2*n*nb)
                          ! (rworkspace: need   n)
                          call stdlib_zgebrd( n, n, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_zlacpy( 'U', n, n, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need 2*n*n+3*n, prefer 2*n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need   2*n*n+3*n-1,
                                       ! prefer 2*n*n+2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'P', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in work(ir)
                          ! (cworkspace: need 2*n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', n, n, n, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                    work( iu ),ldwrku, cdum, 1, rwork( irwork ),info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(iu), storing result in a
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_zgemm( 'N', 'N', m, n, n, cone, u, ldu,work( iu ), ldwrku, &
                                    czero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_zlacpy( 'F', m, n, a, lda, u, ldu )
                          ! copy right singular vectors of r from work(ir) to a
                          call stdlib_zlacpy( 'F', n, n, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_zlacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need n+m, prefer n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_zlaset( 'L', n-1, n-1, czero, czero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_zgebrd( n, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in a
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunmbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in a
                          ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in a
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', n, n, m, 0, s, rwork( ie ), a,lda, u, ldu, &
                                    cdum, 1, rwork( irwork ),info )
                       end if
                    else if( wntvas ) then
                       ! path 9 (m much larger than n, jobu='a', jobvt='s'
                               ! or 'a')
                       ! m left singular vectors to be computed in u and
                       ! n right singular vectors to be computed in vt
                       if( lwork>=n*n+max( n+m, 3*n ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is n by n
                             ldwrku = n
                          end if
                          itau = iu + ldwrku*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_zlacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need n*n+n+m, prefer n*n+n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_zlacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_zlaset( 'L', n-1, n-1, czero, czero,work( iu+1 ), ldwrku )
                                    
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to vt
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_zgebrd( n, n, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_zlacpy( 'U', n, n, work( iu ), ldwrku, vt,ldvt )
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (cworkspace: need   n*n+3*n-1,
                                       ! prefer n*n+2*n+(n-1)*nb)
                          ! (rworkspace: need   0)
                          call stdlib_zungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in vt
                          ! (cworkspace: need n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', n, n, n, 0, s, rwork( ie ), vt,ldvt, work( iu )&
                                    , ldwrku, cdum, 1,rwork( irwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(iu), storing result in a
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_zgemm( 'N', 'N', m, n, n, cone, u, ldu,work( iu ), ldwrku, &
                                    czero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_zlacpy( 'F', m, n, a, lda, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgeqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_zlacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need n+m, prefer n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r from a to vt, zeroing out below it
                          call stdlib_zlacpy( 'U', n, n, a, lda, vt, ldvt )
                          if( n>1 )call stdlib_zlaset( 'L', n-1, n-1, czero, czero,vt( 2, 1 ), &
                                    ldvt )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in vt
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_zgebrd( n, n, vt, ldvt, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in vt
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunmbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', n, n, m, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    end if
                 end if
              else
                 ! m < mnthr
                 ! path 10 (m at least n, but not much larger)
                 ! reduce to bidiagonal form without qr decomposition
                 ie = 1
                 itauq = 1
                 itaup = itauq + n
                 iwork = itaup + n
                 ! bidiagonalize a
                 ! (cworkspace: need 2*n+m, prefer 2*n+(m+n)*nb)
                 ! (rworkspace: need n)
                 call stdlib_zgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( iwork ), lwork-iwork+1,ierr )
                 if( wntuas ) then
                    ! if left singular vectors desired in u, copy result to u
                    ! and generate left bidiagonalizing vectors in u
                    ! (cworkspace: need 2*n+ncu, prefer 2*n+ncu*nb)
                    ! (rworkspace: 0)
                    call stdlib_zlacpy( 'L', m, n, a, lda, u, ldu )
                    if( wntus )ncu = n
                    if( wntua )ncu = m
                    call stdlib_zungbr( 'Q', m, ncu, n, u, ldu, work( itauq ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntvas ) then
                    ! if right singular vectors desired in vt, copy result to
                    ! vt and generate right bidiagonalizing vectors in vt
                    ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                    ! (rworkspace: 0)
                    call stdlib_zlacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_zungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntuo ) then
                    ! if left singular vectors desired in a, generate left
                    ! bidiagonalizing vectors in a
                    ! (cworkspace: need 3*n, prefer 2*n+n*nb)
                    ! (rworkspace: 0)
                    call stdlib_zungbr( 'Q', m, n, n, a, lda, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvo ) then
                    ! if right singular vectors desired in a, generate right
                    ! bidiagonalizing vectors in a
                    ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                    ! (rworkspace: 0)
                    call stdlib_zungbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 irwork = ie + n
                 if( wntuas .or. wntuo )nru = m
                 if( wntun )nru = 0
                 if( wntvas .or. wntvo )ncvt = n
                 if( wntvn )ncvt = 0
                 if( ( .not.wntuo ) .and. ( .not.wntvo ) ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in vt
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_zbdsqr( 'U', n, ncvt, nru, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                              cdum, 1, rwork( irwork ),info )
                 else if( ( .not.wntuo ) .and. wntvo ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in a
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_zbdsqr( 'U', n, ncvt, nru, 0, s, rwork( ie ), a,lda, u, ldu, cdum,&
                               1, rwork( irwork ),info )
                 else
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in a and computing right singular
                    ! vectors in vt
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_zbdsqr( 'U', n, ncvt, nru, 0, s, rwork( ie ), vt,ldvt, a, lda, &
                              cdum, 1, rwork( irwork ),info )
                 end if
              end if
           else
              ! a has more columns than rows. if a has sufficiently more
              ! columns than rows, first reduce using the lq decomposition (if
              ! sufficient workspace available)
              if( n>=mnthr ) then
                 if( wntvn ) then
                    ! path 1t(n much larger than m, jobvt='n')
                    ! no right singular vectors to be computed
                    itau = 1
                    iwork = itau + m
                    ! compute a=l*q
                    ! (cworkspace: need 2*m, prefer m+m*nb)
                    ! (rworkspace: 0)
                    call stdlib_zgelqf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, &
                              ierr )
                    ! zero out above l
                    if (m>1) call stdlib_zlaset( 'U', m-1, m-1, czero, czero, a( 1, 2 ),lda )
                    ie = 1
                    itauq = 1
                    itaup = itauq + m
                    iwork = itaup + m
                    ! bidiagonalize l in a
                    ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                    ! (rworkspace: need m)
                    call stdlib_zgebrd( m, m, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( iwork ), lwork-iwork+1,ierr )
                    if( wntuo .or. wntuas ) then
                       ! if left singular vectors desired, generate q
                       ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_zungbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                    end if
                    irwork = ie + m
                    nru = 0
                    if( wntuo .or. wntuas )nru = m
                    ! perform bidiagonal qr iteration, computing left singular
                    ! vectors of a in a if desired
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_zbdsqr( 'U', m, 0, nru, 0, s, rwork( ie ), cdum, 1,a, lda, cdum, &
                              1, rwork( irwork ), info )
                    ! if left singular vectors desired in u, copy them there
                    if( wntuas )call stdlib_zlacpy( 'F', m, m, a, lda, u, ldu )
                 else if( wntvo .and. wntun ) then
                    ! path 2t(n much larger than m, jobu='n', jobvt='o')
                    ! m right singular vectors to be overwritten on a and
                    ! no left singular vectors to be computed
                    if( lwork>=m*m+3*m ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n )+lda*m ) then
                          ! work(iu) is lda by n and work(ir) is lda by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n )+m*m ) then
                          ! work(iu) is lda by n and work(ir) is m by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = m
                       else
                          ! work(iu) is m by chunk and work(ir) is m by m
                          ldwrku = m
                          chunk = ( lwork-m*m ) / m
                          ldwrkr = m
                       end if
                       itau = ir + ldwrkr*m
                       iwork = itau + m
                       ! compute a=l*q
                       ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_zgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to work(ir) and zero out above it
                       call stdlib_zlacpy( 'L', m, m, a, lda, work( ir ), ldwrkr )
                       call stdlib_zlaset( 'U', m-1, m-1, czero, czero,work( ir+ldwrkr ), ldwrkr )
                                 
                       ! generate q in a
                       ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_zunglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in work(ir)
                       ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                       ! (rworkspace: need m)
                       call stdlib_zgebrd( m, m, work( ir ), ldwrkr, s, rwork( ie ),work( itauq ),&
                                  work( itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing l
                       ! (cworkspace: need m*m+3*m-1, prefer m*m+2*m+(m-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_zungbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       irwork = ie + m
                       ! perform bidiagonal qr iteration, computing right
                       ! singular vectors of l in work(ir)
                       ! (cworkspace: need m*m)
                       ! (rworkspace: need bdspac)
                       call stdlib_zbdsqr( 'U', m, m, 0, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                 cdum, 1, cdum, 1,rwork( irwork ), info )
                       iu = itauq
                       ! multiply right singular vectors of l in work(ir) by q
                       ! in a, storing result in work(iu) and copying to a
                       ! (cworkspace: need m*m+m, prefer m*m+m*n)
                       ! (rworkspace: 0)
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_zgemm( 'N', 'N', m, blk, m, cone, work( ir ),ldwrkr, a( 1, &
                                    i ), lda, czero,work( iu ), ldwrku )
                          call stdlib_zlacpy( 'F', m, blk, work( iu ), ldwrku,a( 1, i ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       ie = 1
                       itauq = 1
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize a
                       ! (cworkspace: need 2*m+n, prefer 2*m+(m+n)*nb)
                       ! (rworkspace: need m)
                       call stdlib_zgebrd( m, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing a
                       ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_zungbr( 'P', m, n, m, a, lda, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + m
                       ! perform bidiagonal qr iteration, computing right
                       ! singular vectors of a in a
                       ! (cworkspace: 0)
                       ! (rworkspace: need bdspac)
                       call stdlib_zbdsqr( 'L', m, n, 0, 0, s, rwork( ie ), a, lda,cdum, 1, cdum, &
                                 1, rwork( irwork ), info )
                    end if
                 else if( wntvo .and. wntuas ) then
                    ! path 3t(n much larger than m, jobu='s' or 'a', jobvt='o')
                    ! m right singular vectors to be overwritten on a and
                    ! m left singular vectors to be computed in u
                    if( lwork>=m*m+3*m ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n )+lda*m ) then
                          ! work(iu) is lda by n and work(ir) is lda by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n )+m*m ) then
                          ! work(iu) is lda by n and work(ir) is m by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = m
                       else
                          ! work(iu) is m by chunk and work(ir) is m by m
                          ldwrku = m
                          chunk = ( lwork-m*m ) / m
                          ldwrkr = m
                       end if
                       itau = ir + ldwrkr*m
                       iwork = itau + m
                       ! compute a=l*q
                       ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_zgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to u, zeroing about above it
                       call stdlib_zlacpy( 'L', m, m, a, lda, u, ldu )
                       if (m>1) call stdlib_zlaset( 'U', m-1, m-1, czero, czero, u( 1, 2 ),ldu )
                       ! generate q in a
                       ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_zunglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in u, copying result to work(ir)
                       ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                       ! (rworkspace: need m)
                       call stdlib_zgebrd( m, m, u, ldu, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       call stdlib_zlacpy( 'U', m, m, u, ldu, work( ir ), ldwrkr )
                       ! generate right vectors bidiagonalizing l in work(ir)
                       ! (cworkspace: need m*m+3*m-1, prefer m*m+2*m+(m-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_zungbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing l in u
                       ! (cworkspace: need m*m+3*m, prefer m*m+2*m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_zungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + m
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of l in u, and computing right
                       ! singular vectors of l in work(ir)
                       ! (cworkspace: need m*m)
                       ! (rworkspace: need bdspac)
                       call stdlib_zbdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( ir ), ldwrkr, u, &
                                 ldu, cdum, 1,rwork( irwork ), info )
                       iu = itauq
                       ! multiply right singular vectors of l in work(ir) by q
                       ! in a, storing result in work(iu) and copying to a
                       ! (cworkspace: need m*m+m, prefer m*m+m*n))
                       ! (rworkspace: 0)
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_zgemm( 'N', 'N', m, blk, m, cone, work( ir ),ldwrkr, a( 1, &
                                    i ), lda, czero,work( iu ), ldwrku )
                          call stdlib_zlacpy( 'F', m, blk, work( iu ), ldwrku,a( 1, i ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       itau = 1
                       iwork = itau + m
                       ! compute a=l*q
                       ! (cworkspace: need 2*m, prefer m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_zgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to u, zeroing out above it
                       call stdlib_zlacpy( 'L', m, m, a, lda, u, ldu )
                       if (m>1) call stdlib_zlaset( 'U', m-1, m-1, czero, czero, u( 1, 2 ),ldu )
                       ! generate q in a
                       ! (cworkspace: need 2*m, prefer m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_zunglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in u
                       ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                       ! (rworkspace: need m)
                       call stdlib_zgebrd( m, m, u, ldu, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! multiply right vectors bidiagonalizing l by q in a
                       ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_zunmbr( 'P', 'L', 'C', m, n, m, u, ldu,work( itaup ), a, lda, &
                                 work( iwork ),lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing l in u
                       ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_zungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + m
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in u and computing right
                       ! singular vectors of a in a
                       ! (cworkspace: 0)
                       ! (rworkspace: need bdspac)
                       call stdlib_zbdsqr( 'U', m, n, m, 0, s, rwork( ie ), a, lda,u, ldu, cdum, &
                                 1, rwork( irwork ), info )
                    end if
                 else if( wntvs ) then
                    if( wntun ) then
                       ! path 4t(n much larger than m, jobu='n', jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! no left singular vectors to be computed
                       if( lwork>=m*m+3*m ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(ir) is lda by m
                             ldwrkr = lda
                          else
                             ! work(ir) is m by m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(ir), zeroing out above it
                          call stdlib_zlacpy( 'L', m, m, a, lda, work( ir ),ldwrkr )
                          call stdlib_zlaset( 'U', m-1, m-1, czero, czero,work( ir+ldwrkr ), &
                                    ldwrkr )
                          ! generate q in a
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(ir)
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_zgebrd( m, m, work( ir ), ldwrkr, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate right vectors bidiagonalizing l in
                          ! work(ir)
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of l in work(ir)
                          ! (cworkspace: need m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', m, m, 0, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                    cdum, 1, cdum, 1,rwork( irwork ), info )
                          ! multiply right singular vectors of l in work(ir) by
                          ! q in a, storing result in vt
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_zgemm( 'N', 'N', m, n, m, cone, work( ir ),ldwrkr, a, lda, &
                                    czero, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy result to vt
                          call stdlib_zlacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_zlaset( 'U', m-1, m-1, czero, czero,a( 1, 2 ), lda )
                          ! bidiagonalize l in a
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_zgebrd( m, m, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right vectors bidiagonalizing l by q in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunmbr( 'P', 'L', 'C', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', m, n, 0, 0, s, rwork( ie ), vt,ldvt, cdum, 1, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    else if( wntuo ) then
                       ! path 5t(n much larger than m, jobu='o', jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! m left singular vectors to be overwritten on a
                       if( lwork>=2*m*m+3*m ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*m ) then
                             ! work(iu) is lda by m and work(ir) is lda by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+m )*m ) then
                             ! work(iu) is lda by m and work(ir) is m by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          else
                             ! work(iu) is m by m and work(ir) is m by m
                             ldwrku = m
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (cworkspace: need 2*m*m+2*m, prefer 2*m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(iu), zeroing out below it
                          call stdlib_zlacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_zlaset( 'U', m-1, m-1, czero, czero,work( iu+ldwrku ), &
                                    ldwrku )
                          ! generate q in a
                          ! (cworkspace: need 2*m*m+2*m, prefer 2*m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to
                          ! work(ir)
                          ! (cworkspace: need   2*m*m+3*m,
                                       ! prefer 2*m*m+2*m+2*m*nb)
                          ! (rworkspace: need   m)
                          call stdlib_zgebrd( m, m, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_zlacpy( 'L', m, m, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need   2*m*m+3*m-1,
                                       ! prefer 2*m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need 2*m*m+3*m, prefer 2*m*m+2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'Q', m, m, m, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in work(ir) and computing
                          ! right singular vectors of l in work(iu)
                          ! (cworkspace: need 2*m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( iu ), ldwrku, &
                                    work( ir ),ldwrkr, cdum, 1, rwork( irwork ),info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in a, storing result in vt
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_zgemm( 'N', 'N', m, n, m, cone, work( iu ),ldwrku, a, lda, &
                                    czero, vt, ldvt )
                          ! copy left singular vectors of l to a
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_zlacpy( 'F', m, m, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_zlacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_zlaset( 'U', m-1, m-1, czero, czero,a( 1, 2 ), lda )
                          ! bidiagonalize l in a
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_zgebrd( m, m, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right vectors bidiagonalizing l by q in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunmbr( 'P', 'L', 'C', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors of l in a
                          ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in a and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', m, n, m, 0, s, rwork( ie ), vt,ldvt, a, lda, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    else if( wntuas ) then
                       ! path 6t(n much larger than m, jobu='s' or 'a',
                               ! jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! m left singular vectors to be computed in u
                       if( lwork>=m*m+3*m ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is lda by m
                             ldwrku = m
                          end if
                          itau = iu + ldwrku*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_zlacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_zlaset( 'U', m-1, m-1, czero, czero,work( iu+ldwrku ), &
                                    ldwrku )
                          ! generate q in a
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to u
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_zgebrd( m, m, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_zlacpy( 'L', m, m, work( iu ), ldwrku, u,ldu )
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need   m*m+3*m-1,
                                       ! prefer m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in u and computing right
                          ! singular vectors of l in work(iu)
                          ! (cworkspace: need m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( iu ), ldwrku, &
                                    u, ldu, cdum, 1,rwork( irwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in a, storing result in vt
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_zgemm( 'N', 'N', m, n, m, cone, work( iu ),ldwrku, a, lda, &
                                    czero, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_zlacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to u, zeroing out above it
                          call stdlib_zlacpy( 'L', m, m, a, lda, u, ldu )
                          if (m>1) call stdlib_zlaset( 'U', m-1, m-1, czero, czero,u( 1, 2 ), ldu )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in u
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_zgebrd( m, m, u, ldu, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in u by q
                          ! in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunmbr( 'P', 'L', 'C', m, n, m, u, ldu,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', m, n, m, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    end if
                 else if( wntva ) then
                    if( wntun ) then
                       ! path 7t(n much larger than m, jobu='n', jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! no left singular vectors to be computed
                       if( lwork>=m*m+max( n+m, 3*m ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(ir) is lda by m
                             ldwrkr = lda
                          else
                             ! work(ir) is m by m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_zlacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! copy l to work(ir), zeroing out above it
                          call stdlib_zlacpy( 'L', m, m, a, lda, work( ir ),ldwrkr )
                          call stdlib_zlaset( 'U', m-1, m-1, czero, czero,work( ir+ldwrkr ), &
                                    ldwrkr )
                          ! generate q in vt
                          ! (cworkspace: need m*m+m+n, prefer m*m+m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(ir)
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_zgebrd( m, m, work( ir ), ldwrkr, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need   m*m+3*m-1,
                                       ! prefer m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of l in work(ir)
                          ! (cworkspace: need m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', m, m, 0, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                    cdum, 1, cdum, 1,rwork( irwork ), info )
                          ! multiply right singular vectors of l in work(ir) by
                          ! q in vt, storing result in a
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_zgemm( 'N', 'N', m, n, m, cone, work( ir ),ldwrkr, vt, ldvt,&
                                     czero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_zlacpy( 'F', m, n, a, lda, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_zlacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need m+n, prefer m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_zlaset( 'U', m-1, m-1, czero, czero,a( 1, 2 ), lda )
                          ! bidiagonalize l in a
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_zgebrd( m, m, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in a by q
                          ! in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunmbr( 'P', 'L', 'C', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', m, n, 0, 0, s, rwork( ie ), vt,ldvt, cdum, 1, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    else if( wntuo ) then
                       ! path 8t(n much larger than m, jobu='o', jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! m left singular vectors to be overwritten on a
                       if( lwork>=2*m*m+max( n+m, 3*m ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*m ) then
                             ! work(iu) is lda by m and work(ir) is lda by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+m )*m ) then
                             ! work(iu) is lda by m and work(ir) is m by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          else
                             ! work(iu) is m by m and work(ir) is m by m
                             ldwrku = m
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m*m+2*m, prefer 2*m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_zlacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need 2*m*m+m+n, prefer 2*m*m+m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_zlacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_zlaset( 'U', m-1, m-1, czero, czero,work( iu+ldwrku ), &
                                    ldwrku )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to
                          ! work(ir)
                          ! (cworkspace: need   2*m*m+3*m,
                                       ! prefer 2*m*m+2*m+2*m*nb)
                          ! (rworkspace: need   m)
                          call stdlib_zgebrd( m, m, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_zlacpy( 'L', m, m, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need   2*m*m+3*m-1,
                                       ! prefer 2*m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need 2*m*m+3*m, prefer 2*m*m+2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'Q', m, m, m, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in work(ir) and computing
                          ! right singular vectors of l in work(iu)
                          ! (cworkspace: need 2*m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( iu ), ldwrku, &
                                    work( ir ),ldwrkr, cdum, 1, rwork( irwork ),info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in vt, storing result in a
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_zgemm( 'N', 'N', m, n, m, cone, work( iu ),ldwrku, vt, ldvt,&
                                     czero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_zlacpy( 'F', m, n, a, lda, vt, ldvt )
                          ! copy left singular vectors of a from work(ir) to a
                          call stdlib_zlacpy( 'F', m, m, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_zlacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need m+n, prefer m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_zlaset( 'U', m-1, m-1, czero, czero,a( 1, 2 ), lda )
                          ! bidiagonalize l in a
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_zgebrd( m, m, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in a by q
                          ! in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunmbr( 'P', 'L', 'C', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in a
                          ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in a and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', m, n, m, 0, s, rwork( ie ), vt,ldvt, a, lda, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    else if( wntuas ) then
                       ! path 9t(n much larger than m, jobu='s' or 'a',
                               ! jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! m left singular vectors to be computed in u
                       if( lwork>=m*m+max( n+m, 3*m ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(iu) is lda by m
                             ldwrku = lda
                          else
                             ! work(iu) is m by m
                             ldwrku = m
                          end if
                          itau = iu + ldwrku*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_zlacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need m*m+m+n, prefer m*m+m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_zlacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_zlaset( 'U', m-1, m-1, czero, czero,work( iu+ldwrku ), &
                                    ldwrku )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to u
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_zgebrd( m, m, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_zlacpy( 'L', m, m, work( iu ), ldwrku, u,ldu )
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in u and computing right
                          ! singular vectors of l in work(iu)
                          ! (cworkspace: need m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( iu ), ldwrku, &
                                    u, ldu, cdum, 1,rwork( irwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in vt, storing result in a
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_zgemm( 'N', 'N', m, n, m, cone, work( iu ),ldwrku, vt, ldvt,&
                                     czero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_zlacpy( 'F', m, n, a, lda, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zgelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_zlacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need m+n, prefer m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to u, zeroing out above it
                          call stdlib_zlacpy( 'L', m, m, a, lda, u, ldu )
                          if (m>1) call stdlib_zlaset( 'U', m-1, m-1, czero, czero,u( 1, 2 ), ldu )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in u
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_zgebrd( m, m, u, ldu, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in u by q
                          ! in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_zunmbr( 'P', 'L', 'C', m, n, m, u, ldu,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_zungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_zbdsqr( 'U', m, n, m, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    end if
                 end if
              else
                 ! n < mnthr
                 ! path 10t(n greater than m, but not much larger)
                 ! reduce to bidiagonal form without lq decomposition
                 ie = 1
                 itauq = 1
                 itaup = itauq + m
                 iwork = itaup + m
                 ! bidiagonalize a
                 ! (cworkspace: need 2*m+n, prefer 2*m+(m+n)*nb)
                 ! (rworkspace: m)
                 call stdlib_zgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( iwork ), lwork-iwork+1,ierr )
                 if( wntuas ) then
                    ! if left singular vectors desired in u, copy result to u
                    ! and generate left bidiagonalizing vectors in u
                    ! (cworkspace: need 3*m-1, prefer 2*m+(m-1)*nb)
                    ! (rworkspace: 0)
                    call stdlib_zlacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_zungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvas ) then
                    ! if right singular vectors desired in vt, copy result to
                    ! vt and generate right bidiagonalizing vectors in vt
                    ! (cworkspace: need 2*m+nrvt, prefer 2*m+nrvt*nb)
                    ! (rworkspace: 0)
                    call stdlib_zlacpy( 'U', m, n, a, lda, vt, ldvt )
                    if( wntva )nrvt = n
                    if( wntvs )nrvt = m
                    call stdlib_zungbr( 'P', nrvt, n, m, vt, ldvt, work( itaup ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntuo ) then
                    ! if left singular vectors desired in a, generate left
                    ! bidiagonalizing vectors in a
                    ! (cworkspace: need 3*m-1, prefer 2*m+(m-1)*nb)
                    ! (rworkspace: 0)
                    call stdlib_zungbr( 'Q', m, m, n, a, lda, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvo ) then
                    ! if right singular vectors desired in a, generate right
                    ! bidiagonalizing vectors in a
                    ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                    ! (rworkspace: 0)
                    call stdlib_zungbr( 'P', m, n, m, a, lda, work( itaup ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 irwork = ie + m
                 if( wntuas .or. wntuo )nru = m
                 if( wntun )nru = 0
                 if( wntvas .or. wntvo )ncvt = n
                 if( wntvn )ncvt = 0
                 if( ( .not.wntuo ) .and. ( .not.wntvo ) ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in vt
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_zbdsqr( 'L', m, ncvt, nru, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                              cdum, 1, rwork( irwork ),info )
                 else if( ( .not.wntuo ) .and. wntvo ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in a
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_zbdsqr( 'L', m, ncvt, nru, 0, s, rwork( ie ), a,lda, u, ldu, cdum,&
                               1, rwork( irwork ),info )
                 else
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in a and computing right singular
                    ! vectors in vt
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_zbdsqr( 'L', m, ncvt, nru, 0, s, rwork( ie ), vt,ldvt, a, lda, &
                              cdum, 1, rwork( irwork ),info )
                 end if
              end if
           end if
           ! undo scaling if necessary
           if( iscl==1 ) then
              if( anrm>bignum )call stdlib_dlascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm>bignum )call stdlib_dlascl( 'G', 0, 0, bignum, anrm, minmn-1,&
                         1,rwork( ie ), minmn, ierr )
              if( anrm<smlnum )call stdlib_dlascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm<smlnum )call stdlib_dlascl( 'G', 0, 0, smlnum, anrm, minmn-1,&
                         1,rwork( ie ), minmn, ierr )
           end if
           ! return optimal workspace in work(1)
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_zgesvd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$gesvd( jobu, jobvt, m, n, a, lda, s, u, ldu,vt, ldvt, work, lwork, rwork, &
     !! ZGESVD: computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, optionally computing the left and/or right singular
     !! vectors. The SVD is written
     !! A = U * SIGMA * conjugate-transpose(V)
     !! where SIGMA is an M-by-N matrix which is zero except for its
     !! min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
     !! V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
     !! are the singular values of A; they are real and non-negative, and
     !! are returned in descending order.  The first min(m,n) columns of
     !! U and V are the left and right singular vectors of A.
     !! Note that the routine returns V**H, not V.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobu, jobvt
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldvt, lwork, m, n
           ! Array Arguments 
           real(${ck}$), intent(out) :: rwork(*), s(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lquery, wntua, wntuas, wntun, wntuo, wntus, wntva, wntvas, wntvn, wntvo,&
                      wntvs
           integer(ilp) :: blk, chunk, i, ie, ierr, ir, irwork, iscl, itau, itaup, itauq, iu, &
           iwork, ldwrkr, ldwrku, maxwrk, minmn, minwrk, mnthr, ncu, ncvt, nru, nrvt, &
                     wrkbl
           integer(ilp) :: lwork_wgeqrf, lwork_wungqr_n, lwork_wungqr_m, lwork_wgebrd, &
                     lwork_wungbr_p, lwork_wungbr_q, lwork_wgelqf, lwork_wunglq_n, lwork_wunglq_m
           real(${ck}$) :: anrm, bignum, eps, smlnum
           ! Local Arrays 
           real(${ck}$) :: dum(1)
           complex(${ck}$) :: cdum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           minmn = min( m, n )
           wntua = stdlib_lsame( jobu, 'A' )
           wntus = stdlib_lsame( jobu, 'S' )
           wntuas = wntua .or. wntus
           wntuo = stdlib_lsame( jobu, 'O' )
           wntun = stdlib_lsame( jobu, 'N' )
           wntva = stdlib_lsame( jobvt, 'A' )
           wntvs = stdlib_lsame( jobvt, 'S' )
           wntvas = wntva .or. wntvs
           wntvo = stdlib_lsame( jobvt, 'O' )
           wntvn = stdlib_lsame( jobvt, 'N' )
           lquery = ( lwork==-1 )
           if( .not.( wntua .or. wntus .or. wntuo .or. wntun ) ) then
              info = -1
           else if( .not.( wntva .or. wntvs .or. wntvo .or. wntvn ) .or.( wntvo .and. wntuo ) ) &
                     then
              info = -2
           else if( m<0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, m ) ) then
              info = -6
           else if( ldu<1 .or. ( wntuas .and. ldu<m ) ) then
              info = -9
           else if( ldvt<1 .or. ( wntva .and. ldvt<n ) .or.( wntvs .and. ldvt<minmn ) ) &
                     then
              info = -11
           end if
           ! compute workspace
            ! (note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace needed at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to
             ! real workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              if( m>=n .and. minmn>0 ) then
                 ! space needed for stdlib_${ci}$bdsqr is bdspac = 5*n
                 mnthr = stdlib_ilaenv( 6, 'ZGESVD', jobu // jobvt, m, n, 0, 0 )
                 ! compute space needed for stdlib_${ci}$geqrf
                 call stdlib_${ci}$geqrf( m, n, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_wgeqrf = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ci}$ungqr
                 call stdlib_${ci}$ungqr( m, n, n, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_wungqr_n = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$ungqr( m, m, n, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_wungqr_m = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ci}$gebrd
                 call stdlib_${ci}$gebrd( n, n, a, lda, s, dum(1), cdum(1),cdum(1), cdum(1), -1, ierr )
                           
                 lwork_wgebrd = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ci}$ungbr
                 call stdlib_${ci}$ungbr( 'P', n, n, n, a, lda, cdum(1),cdum(1), -1, ierr )
                 lwork_wungbr_p = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$ungbr( 'Q', n, n, n, a, lda, cdum(1),cdum(1), -1, ierr )
                 lwork_wungbr_q = int( cdum(1),KIND=ilp)
                 if( m>=mnthr ) then
                    if( wntun ) then
                       ! path 1 (m much larger than n, jobu='n')
                       maxwrk = n + lwork_wgeqrf
                       maxwrk = max( maxwrk, 2*n+lwork_wgebrd )
                       if( wntvo .or. wntvas )maxwrk = max( maxwrk, 2*n+lwork_wungbr_p )
                       minwrk = 3*n
                    else if( wntuo .and. wntvn ) then
                       ! path 2 (m much larger than n, jobu='o', jobvt='n')
                       wrkbl = n + lwork_wgeqrf
                       wrkbl = max( wrkbl, n+lwork_wungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_wgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_wungbr_q )
                       maxwrk = max( n*n+wrkbl, n*n+m*n )
                       minwrk = 2*n + m
                    else if( wntuo .and. wntvas ) then
                       ! path 3 (m much larger than n, jobu='o', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_wgeqrf
                       wrkbl = max( wrkbl, n+lwork_wungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_wgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_wungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_wungbr_p )
                       maxwrk = max( n*n+wrkbl, n*n+m*n )
                       minwrk = 2*n + m
                    else if( wntus .and. wntvn ) then
                       ! path 4 (m much larger than n, jobu='s', jobvt='n')
                       wrkbl = n + lwork_wgeqrf
                       wrkbl = max( wrkbl, n+lwork_wungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_wgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_wungbr_q )
                       maxwrk = n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntus .and. wntvo ) then
                       ! path 5 (m much larger than n, jobu='s', jobvt='o')
                       wrkbl = n + lwork_wgeqrf
                       wrkbl = max( wrkbl, n+lwork_wungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_wgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_wungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_wungbr_p )
                       maxwrk = 2*n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntus .and. wntvas ) then
                       ! path 6 (m much larger than n, jobu='s', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_wgeqrf
                       wrkbl = max( wrkbl, n+lwork_wungqr_n )
                       wrkbl = max( wrkbl, 2*n+lwork_wgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_wungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_wungbr_p )
                       maxwrk = n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntua .and. wntvn ) then
                       ! path 7 (m much larger than n, jobu='a', jobvt='n')
                       wrkbl = n + lwork_wgeqrf
                       wrkbl = max( wrkbl, n+lwork_wungqr_m )
                       wrkbl = max( wrkbl, 2*n+lwork_wgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_wungbr_q )
                       maxwrk = n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntua .and. wntvo ) then
                       ! path 8 (m much larger than n, jobu='a', jobvt='o')
                       wrkbl = n + lwork_wgeqrf
                       wrkbl = max( wrkbl, n+lwork_wungqr_m )
                       wrkbl = max( wrkbl, 2*n+lwork_wgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_wungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_wungbr_p )
                       maxwrk = 2*n*n + wrkbl
                       minwrk = 2*n + m
                    else if( wntua .and. wntvas ) then
                       ! path 9 (m much larger than n, jobu='a', jobvt='s' or
                       ! 'a')
                       wrkbl = n + lwork_wgeqrf
                       wrkbl = max( wrkbl, n+lwork_wungqr_m )
                       wrkbl = max( wrkbl, 2*n+lwork_wgebrd )
                       wrkbl = max( wrkbl, 2*n+lwork_wungbr_q )
                       wrkbl = max( wrkbl, 2*n+lwork_wungbr_p )
                       maxwrk = n*n + wrkbl
                       minwrk = 2*n + m
                    end if
                 else
                    ! path 10 (m at least n, but not much larger)
                    call stdlib_${ci}$gebrd( m, n, a, lda, s, dum(1), cdum(1),cdum(1), cdum(1), -1, &
                              ierr )
                    lwork_wgebrd = int( cdum(1),KIND=ilp)
                    maxwrk = 2*n + lwork_wgebrd
                    if( wntus .or. wntuo ) then
                       call stdlib_${ci}$ungbr( 'Q', m, n, n, a, lda, cdum(1),cdum(1), -1, ierr )
                                 
                       lwork_wungbr_q = int( cdum(1),KIND=ilp)
                       maxwrk = max( maxwrk, 2*n+lwork_wungbr_q )
                    end if
                    if( wntua ) then
                       call stdlib_${ci}$ungbr( 'Q', m, m, n, a, lda, cdum(1),cdum(1), -1, ierr )
                                 
                       lwork_wungbr_q = int( cdum(1),KIND=ilp)
                       maxwrk = max( maxwrk, 2*n+lwork_wungbr_q )
                    end if
                    if( .not.wntvn ) then
                       maxwrk = max( maxwrk, 2*n+lwork_wungbr_p )
                    end if
                    minwrk = 2*n + m
                 end if
              else if( minmn>0 ) then
                 ! space needed for stdlib_${ci}$bdsqr is bdspac = 5*m
                 mnthr = stdlib_ilaenv( 6, 'ZGESVD', jobu // jobvt, m, n, 0, 0 )
                 ! compute space needed for stdlib_${ci}$gelqf
                 call stdlib_${ci}$gelqf( m, n, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_wgelqf = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ci}$unglq
                 call stdlib_${ci}$unglq( n, n, m, cdum(1), n, cdum(1), cdum(1), -1,ierr )
                 lwork_wunglq_n = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$unglq( m, n, m, a, lda, cdum(1), cdum(1), -1, ierr )
                 lwork_wunglq_m = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ci}$gebrd
                 call stdlib_${ci}$gebrd( m, m, a, lda, s, dum(1), cdum(1),cdum(1), cdum(1), -1, ierr )
                           
                 lwork_wgebrd = int( cdum(1),KIND=ilp)
                  ! compute space needed for stdlib_${ci}$ungbr p
                 call stdlib_${ci}$ungbr( 'P', m, m, m, a, n, cdum(1),cdum(1), -1, ierr )
                 lwork_wungbr_p = int( cdum(1),KIND=ilp)
                 ! compute space needed for stdlib_${ci}$ungbr q
                 call stdlib_${ci}$ungbr( 'Q', m, m, m, a, n, cdum(1),cdum(1), -1, ierr )
                 lwork_wungbr_q = int( cdum(1),KIND=ilp)
                 if( n>=mnthr ) then
                    if( wntvn ) then
                       ! path 1t(n much larger than m, jobvt='n')
                       maxwrk = m + lwork_wgelqf
                       maxwrk = max( maxwrk, 2*m+lwork_wgebrd )
                       if( wntuo .or. wntuas )maxwrk = max( maxwrk, 2*m+lwork_wungbr_q )
                       minwrk = 3*m
                    else if( wntvo .and. wntun ) then
                       ! path 2t(n much larger than m, jobu='n', jobvt='o')
                       wrkbl = m + lwork_wgelqf
                       wrkbl = max( wrkbl, m+lwork_wunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_wgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_wungbr_p )
                       maxwrk = max( m*m+wrkbl, m*m+m*n )
                       minwrk = 2*m + n
                    else if( wntvo .and. wntuas ) then
                       ! path 3t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='o')
                       wrkbl = m + lwork_wgelqf
                       wrkbl = max( wrkbl, m+lwork_wunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_wgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_wungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_wungbr_q )
                       maxwrk = max( m*m+wrkbl, m*m+m*n )
                       minwrk = 2*m + n
                    else if( wntvs .and. wntun ) then
                       ! path 4t(n much larger than m, jobu='n', jobvt='s')
                       wrkbl = m + lwork_wgelqf
                       wrkbl = max( wrkbl, m+lwork_wunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_wgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_wungbr_p )
                       maxwrk = m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntvs .and. wntuo ) then
                       ! path 5t(n much larger than m, jobu='o', jobvt='s')
                       wrkbl = m + lwork_wgelqf
                       wrkbl = max( wrkbl, m+lwork_wunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_wgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_wungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_wungbr_q )
                       maxwrk = 2*m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntvs .and. wntuas ) then
                       ! path 6t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='s')
                       wrkbl = m + lwork_wgelqf
                       wrkbl = max( wrkbl, m+lwork_wunglq_m )
                       wrkbl = max( wrkbl, 2*m+lwork_wgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_wungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_wungbr_q )
                       maxwrk = m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntva .and. wntun ) then
                       ! path 7t(n much larger than m, jobu='n', jobvt='a')
                       wrkbl = m + lwork_wgelqf
                       wrkbl = max( wrkbl, m+lwork_wunglq_n )
                       wrkbl = max( wrkbl, 2*m+lwork_wgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_wungbr_p )
                       maxwrk = m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntva .and. wntuo ) then
                       ! path 8t(n much larger than m, jobu='o', jobvt='a')
                       wrkbl = m + lwork_wgelqf
                       wrkbl = max( wrkbl, m+lwork_wunglq_n )
                       wrkbl = max( wrkbl, 2*m+lwork_wgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_wungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_wungbr_q )
                       maxwrk = 2*m*m + wrkbl
                       minwrk = 2*m + n
                    else if( wntva .and. wntuas ) then
                       ! path 9t(n much larger than m, jobu='s' or 'a',
                       ! jobvt='a')
                       wrkbl = m + lwork_wgelqf
                       wrkbl = max( wrkbl, m+lwork_wunglq_n )
                       wrkbl = max( wrkbl, 2*m+lwork_wgebrd )
                       wrkbl = max( wrkbl, 2*m+lwork_wungbr_p )
                       wrkbl = max( wrkbl, 2*m+lwork_wungbr_q )
                       maxwrk = m*m + wrkbl
                       minwrk = 2*m + n
                    end if
                 else
                    ! path 10t(n greater than m, but not much larger)
                    call stdlib_${ci}$gebrd( m, n, a, lda, s, dum(1), cdum(1),cdum(1), cdum(1), -1, &
                              ierr )
                    lwork_wgebrd = int( cdum(1),KIND=ilp)
                    maxwrk = 2*m + lwork_wgebrd
                    if( wntvs .or. wntvo ) then
                      ! compute space needed for stdlib_${ci}$ungbr p
                      call stdlib_${ci}$ungbr( 'P', m, n, m, a, n, cdum(1),cdum(1), -1, ierr )
                      lwork_wungbr_p = int( cdum(1),KIND=ilp)
                      maxwrk = max( maxwrk, 2*m+lwork_wungbr_p )
                    end if
                    if( wntva ) then
                      call stdlib_${ci}$ungbr( 'P', n,  n, m, a, n, cdum(1),cdum(1), -1, ierr )
                      lwork_wungbr_p = int( cdum(1),KIND=ilp)
                      maxwrk = max( maxwrk, 2*m+lwork_wungbr_p )
                    end if
                    if( .not.wntun ) then
                       maxwrk = max( maxwrk, 2*m+lwork_wungbr_q )
                    end if
                    minwrk = 2*m + n
                 end if
              end if
              maxwrk = max( maxwrk, minwrk )
              work( 1 ) = maxwrk
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -13
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGESVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'P' )
           smlnum = sqrt( stdlib_${c2ri(ci)}$lamch( 'S' ) ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ci}$lange( 'M', m, n, a, lda, dum )
           iscl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              iscl = 1
              call stdlib_${ci}$lascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, ierr )
           else if( anrm>bignum ) then
              iscl = 1
              call stdlib_${ci}$lascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, ierr )
           end if
           if( m>=n ) then
              ! a has at least as many rows as columns. if a has sufficiently
              ! more rows than columns, first reduce using the qr
              ! decomposition (if sufficient workspace available)
              if( m>=mnthr ) then
                 if( wntun ) then
                    ! path 1 (m much larger than n, jobu='n')
                    ! no left singular vectors to be computed
                    itau = 1
                    iwork = itau + n
                    ! compute a=q*r
                    ! (cworkspace: need 2*n, prefer n+n*nb)
                    ! (rworkspace: need 0)
                    call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, &
                              ierr )
                    ! zero out below r
                    if( n > 1 ) then
                       call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero, a( 2, 1 ),lda )
                    end if
                    ie = 1
                    itauq = 1
                    itaup = itauq + n
                    iwork = itaup + n
                    ! bidiagonalize r in a
                    ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                    ! (rworkspace: need n)
                    call stdlib_${ci}$gebrd( n, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( iwork ), lwork-iwork+1,ierr )
                    ncvt = 0
                    if( wntvo .or. wntvas ) then
                       ! if right singular vectors desired, generate p'.
                       ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$ungbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       ncvt = n
                    end if
                    irwork = ie + n
                    ! perform bidiagonal qr iteration, computing right
                    ! singular vectors of a in a if desired
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_${ci}$bdsqr( 'U', n, ncvt, 0, 0, s, rwork( ie ), a, lda,cdum, 1, cdum, &
                              1, rwork( irwork ), info )
                    ! if right singular vectors desired in vt, copy them there
                    if( wntvas )call stdlib_${ci}$lacpy( 'F', n, n, a, lda, vt, ldvt )
                 else if( wntuo .and. wntvn ) then
                    ! path 2 (m much larger than n, jobu='o', jobvt='n')
                    ! n left singular vectors to be overwritten on a and
                    ! no right singular vectors to be computed
                    if( lwork>=n*n+3*n ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n )+lda*n ) then
                          ! work(iu) is lda by n, work(ir) is lda by n
                          ldwrku = lda
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n )+n*n ) then
                          ! work(iu) is lda by n, work(ir) is n by n
                          ldwrku = lda
                          ldwrkr = n
                       else
                          ! work(iu) is ldwrku by n, work(ir) is n by n
                          ldwrku = ( lwork-n*n ) / n
                          ldwrkr = n
                       end if
                       itau = ir + ldwrkr*n
                       iwork = itau + n
                       ! compute a=q*r
                       ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to work(ir) and zero out below it
                       call stdlib_${ci}$lacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                       call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero,work( ir+1 ), ldwrkr )
                                 
                       ! generate q in a
                       ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$ungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in work(ir)
                       ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                       ! (rworkspace: need n)
                       call stdlib_${ci}$gebrd( n, n, work( ir ), ldwrkr, s, rwork( ie ),work( itauq ),&
                                  work( itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing r
                       ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                       ! (rworkspace: need 0)
                       call stdlib_${ci}$ungbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       irwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of r in work(ir)
                       ! (cworkspace: need n*n)
                       ! (rworkspace: need bdspac)
                       call stdlib_${ci}$bdsqr( 'U', n, 0, n, 0, s, rwork( ie ), cdum, 1,work( ir ), &
                                 ldwrkr, cdum, 1,rwork( irwork ), info )
                       iu = itauq
                       ! multiply q in a by left singular vectors of r in
                       ! work(ir), storing result in work(iu) and copying to a
                       ! (cworkspace: need n*n+n, prefer n*n+m*n)
                       ! (rworkspace: 0)
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_${ci}$gemm( 'N', 'N', chunk, n, n, cone, a( i, 1 ),lda, work( ir &
                                    ), ldwrkr, czero,work( iu ), ldwrku )
                          call stdlib_${ci}$lacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       ie = 1
                       itauq = 1
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize a
                       ! (cworkspace: need 2*n+m, prefer 2*n+(m+n)*nb)
                       ! (rworkspace: n)
                       call stdlib_${ci}$gebrd( m, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing a
                       ! (cworkspace: need 3*n, prefer 2*n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$ungbr( 'Q', m, n, n, a, lda, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in a
                       ! (cworkspace: need 0)
                       ! (rworkspace: need bdspac)
                       call stdlib_${ci}$bdsqr( 'U', n, 0, m, 0, s, rwork( ie ), cdum, 1,a, lda, cdum, &
                                 1, rwork( irwork ), info )
                    end if
                 else if( wntuo .and. wntvas ) then
                    ! path 3 (m much larger than n, jobu='o', jobvt='s' or 'a')
                    ! n left singular vectors to be overwritten on a and
                    ! n right singular vectors to be computed in vt
                    if( lwork>=n*n+3*n ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n )+lda*n ) then
                          ! work(iu) is lda by n and work(ir) is lda by n
                          ldwrku = lda
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n )+n*n ) then
                          ! work(iu) is lda by n and work(ir) is n by n
                          ldwrku = lda
                          ldwrkr = n
                       else
                          ! work(iu) is ldwrku by n and work(ir) is n by n
                          ldwrku = ( lwork-n*n ) / n
                          ldwrkr = n
                       end if
                       itau = ir + ldwrkr*n
                       iwork = itau + n
                       ! compute a=q*r
                       ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to vt, zeroing out below it
                       call stdlib_${ci}$lacpy( 'U', n, n, a, lda, vt, ldvt )
                       if( n>1 )call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero,vt( 2, 1 ), ldvt )
                                 
                       ! generate q in a
                       ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$ungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in vt, copying result to work(ir)
                       ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                       ! (rworkspace: need n)
                       call stdlib_${ci}$gebrd( n, n, vt, ldvt, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       call stdlib_${ci}$lacpy( 'L', n, n, vt, ldvt, work( ir ), ldwrkr )
                       ! generate left vectors bidiagonalizing r in work(ir)
                       ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$ungbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing r in vt
                       ! (cworkspace: need n*n+3*n-1, prefer n*n+2*n+(n-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$ungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of r in work(ir) and computing right
                       ! singular vectors of r in vt
                       ! (cworkspace: need n*n)
                       ! (rworkspace: need bdspac)
                       call stdlib_${ci}$bdsqr( 'U', n, n, n, 0, s, rwork( ie ), vt,ldvt, work( ir ), &
                                 ldwrkr, cdum, 1,rwork( irwork ), info )
                       iu = itauq
                       ! multiply q in a by left singular vectors of r in
                       ! work(ir), storing result in work(iu) and copying to a
                       ! (cworkspace: need n*n+n, prefer n*n+m*n)
                       ! (rworkspace: 0)
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_${ci}$gemm( 'N', 'N', chunk, n, n, cone, a( i, 1 ),lda, work( ir &
                                    ), ldwrkr, czero,work( iu ), ldwrku )
                          call stdlib_${ci}$lacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       itau = 1
                       iwork = itau + n
                       ! compute a=q*r
                       ! (cworkspace: need 2*n, prefer n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy r to vt, zeroing out below it
                       call stdlib_${ci}$lacpy( 'U', n, n, a, lda, vt, ldvt )
                       if( n>1 )call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero,vt( 2, 1 ), ldvt )
                                 
                       ! generate q in a
                       ! (cworkspace: need 2*n, prefer n+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$ungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + n
                       iwork = itaup + n
                       ! bidiagonalize r in vt
                       ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                       ! (rworkspace: n)
                       call stdlib_${ci}$gebrd( n, n, vt, ldvt, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! multiply q in a by left vectors bidiagonalizing r
                       ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$unmbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), a, lda,&
                                  work( iwork ),lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing r in vt
                       ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$ungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + n
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in a and computing right
                       ! singular vectors of a in vt
                       ! (cworkspace: 0)
                       ! (rworkspace: need bdspac)
                       call stdlib_${ci}$bdsqr( 'U', n, n, m, 0, s, rwork( ie ), vt,ldvt, a, lda, cdum,&
                                  1, rwork( irwork ),info )
                    end if
                 else if( wntus ) then
                    if( wntvn ) then
                       ! path 4 (m much larger than n, jobu='s', jobvt='n')
                       ! n left singular vectors to be computed in u and
                       ! no right singular vectors to be computed
                       if( lwork>=n*n+3*n ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(ir) is lda by n
                             ldwrkr = lda
                          else
                             ! work(ir) is n by n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(ir), zeroing out below it
                          call stdlib_${ci}$lacpy( 'U', n, n, a, lda, work( ir ),ldwrkr )
                          call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero,work( ir+1 ), ldwrkr )
                                    
                          ! generate q in a
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(ir)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_${ci}$gebrd( n, n, work( ir ), ldwrkr, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate left vectors bidiagonalizing r in work(ir)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(ir)
                          ! (cworkspace: need n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', n, 0, n, 0, s, rwork( ie ), cdum,1, work( ir ),&
                                     ldwrkr, cdum, 1,rwork( irwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(ir), storing result in u
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gemm( 'N', 'N', m, n, n, cone, a, lda,work( ir ), ldwrkr, &
                                    czero, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_${ci}$gebrd( n, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left vectors bidiagonalizing r
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unmbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', n, 0, m, 0, s, rwork( ie ), cdum,1, u, ldu, &
                                    cdum, 1, rwork( irwork ),info )
                       end if
                    else if( wntvo ) then
                       ! path 5 (m much larger than n, jobu='s', jobvt='o')
                       ! n left singular vectors to be computed in u and
                       ! n right singular vectors to be overwritten on a
                       if( lwork>=2*n*n+3*n ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*n ) then
                             ! work(iu) is lda by n and work(ir) is lda by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+n )*n ) then
                             ! work(iu) is lda by n and work(ir) is n by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          else
                             ! work(iu) is n by n and work(ir) is n by n
                             ldwrku = n
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (cworkspace: need 2*n*n+2*n, prefer 2*n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_${ci}$lacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero,work( iu+1 ), ldwrku )
                                    
                          ! generate q in a
                          ! (cworkspace: need 2*n*n+2*n, prefer 2*n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to
                          ! work(ir)
                          ! (cworkspace: need   2*n*n+3*n,
                                       ! prefer 2*n*n+2*n+2*n*nb)
                          ! (rworkspace: need   n)
                          call stdlib_${ci}$gebrd( n, n, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'U', n, n, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need 2*n*n+3*n, prefer 2*n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need   2*n*n+3*n-1,
                                       ! prefer 2*n*n+2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'P', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in work(ir)
                          ! (cworkspace: need 2*n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', n, n, n, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                    work( iu ),ldwrku, cdum, 1, rwork( irwork ),info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(iu), storing result in u
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gemm( 'N', 'N', m, n, n, cone, a, lda,work( iu ), ldwrku, &
                                    czero, u, ldu )
                          ! copy right singular vectors of r to a
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$lacpy( 'F', n, n, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_${ci}$gebrd( n, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left vectors bidiagonalizing r
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unmbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right vectors bidiagonalizing r in a
                          ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in a
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', n, n, m, 0, s, rwork( ie ), a,lda, u, ldu, &
                                    cdum, 1, rwork( irwork ),info )
                       end if
                    else if( wntvas ) then
                       ! path 6 (m much larger than n, jobu='s', jobvt='s'
                               ! or 'a')
                       ! n left singular vectors to be computed in u and
                       ! n right singular vectors to be computed in vt
                       if( lwork>=n*n+3*n ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is n by n
                             ldwrku = n
                          end if
                          itau = iu + ldwrku*n
                          iwork = itau + n
                          ! compute a=q*r
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_${ci}$lacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero,work( iu+1 ), ldwrku )
                                    
                          ! generate q in a
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungqr( m, n, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to vt
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_${ci}$gebrd( n, n, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'U', n, n, work( iu ), ldwrku, vt,ldvt )
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (cworkspace: need   n*n+3*n-1,
                                       ! prefer n*n+2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in vt
                          ! (cworkspace: need n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', n, n, n, 0, s, rwork( ie ), vt,ldvt, work( iu )&
                                    , ldwrku, cdum, 1,rwork( irwork ), info )
                          ! multiply q in a by left singular vectors of r in
                          ! work(iu), storing result in u
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gemm( 'N', 'N', m, n, n, cone, a, lda,work( iu ), ldwrku, &
                                    czero, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungqr( m, n, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to vt, zeroing out below it
                          call stdlib_${ci}$lacpy( 'U', n, n, a, lda, vt, ldvt )
                          if( n>1 )call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero,vt( 2, 1 ), &
                                    ldvt )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in vt
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_${ci}$gebrd( n, n, vt, ldvt, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in vt
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unmbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', n, n, m, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    end if
                 else if( wntua ) then
                    if( wntvn ) then
                       ! path 7 (m much larger than n, jobu='a', jobvt='n')
                       ! m left singular vectors to be computed in u and
                       ! no right singular vectors to be computed
                       if( lwork>=n*n+max( n+m, 3*n ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(ir) is lda by n
                             ldwrkr = lda
                          else
                             ! work(ir) is n by n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! copy r to work(ir), zeroing out below it
                          call stdlib_${ci}$lacpy( 'U', n, n, a, lda, work( ir ),ldwrkr )
                          call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero,work( ir+1 ), ldwrkr )
                                    
                          ! generate q in u
                          ! (cworkspace: need n*n+n+m, prefer n*n+n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(ir)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_${ci}$gebrd( n, n, work( ir ), ldwrkr, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'Q', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(ir)
                          ! (cworkspace: need n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', n, 0, n, 0, s, rwork( ie ), cdum,1, work( ir ),&
                                     ldwrkr, cdum, 1,rwork( irwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(ir), storing result in a
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gemm( 'N', 'N', m, n, n, cone, u, ldu,work( ir ), ldwrkr, &
                                    czero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_${ci}$lacpy( 'F', m, n, a, lda, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need n+m, prefer n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_${ci}$gebrd( n, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in a
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unmbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', n, 0, m, 0, s, rwork( ie ), cdum,1, u, ldu, &
                                    cdum, 1, rwork( irwork ),info )
                       end if
                    else if( wntvo ) then
                       ! path 8 (m much larger than n, jobu='a', jobvt='o')
                       ! m left singular vectors to be computed in u and
                       ! n right singular vectors to be overwritten on a
                       if( lwork>=2*n*n+max( n+m, 3*n ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*n ) then
                             ! work(iu) is lda by n and work(ir) is lda by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+n )*n ) then
                             ! work(iu) is lda by n and work(ir) is n by n
                             ldwrku = lda
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          else
                             ! work(iu) is n by n and work(ir) is n by n
                             ldwrku = n
                             ir = iu + ldwrku*n
                             ldwrkr = n
                          end if
                          itau = ir + ldwrkr*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n*n+2*n, prefer 2*n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need 2*n*n+n+m, prefer 2*n*n+n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_${ci}$lacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero,work( iu+1 ), ldwrku )
                                    
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to
                          ! work(ir)
                          ! (cworkspace: need   2*n*n+3*n,
                                       ! prefer 2*n*n+2*n+2*n*nb)
                          ! (rworkspace: need   n)
                          call stdlib_${ci}$gebrd( n, n, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'U', n, n, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need 2*n*n+3*n, prefer 2*n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need   2*n*n+3*n-1,
                                       ! prefer 2*n*n+2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'P', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in work(ir)
                          ! (cworkspace: need 2*n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', n, n, n, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                    work( iu ),ldwrku, cdum, 1, rwork( irwork ),info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(iu), storing result in a
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gemm( 'N', 'N', m, n, n, cone, u, ldu,work( iu ), ldwrku, &
                                    czero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_${ci}$lacpy( 'F', m, n, a, lda, u, ldu )
                          ! copy right singular vectors of r from work(ir) to a
                          call stdlib_${ci}$lacpy( 'F', n, n, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need n+m, prefer n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! zero out below r in a
                          if( n > 1 ) then
                             call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero,a( 2, 1 ), lda )
                                       
                          end if
                          ! bidiagonalize r in a
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_${ci}$gebrd( n, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in a
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unmbr( 'Q', 'R', 'N', m, n, n, a, lda,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in a
                          ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in a
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', n, n, m, 0, s, rwork( ie ), a,lda, u, ldu, &
                                    cdum, 1, rwork( irwork ),info )
                       end if
                    else if( wntvas ) then
                       ! path 9 (m much larger than n, jobu='a', jobvt='s'
                               ! or 'a')
                       ! m left singular vectors to be computed in u and
                       ! n right singular vectors to be computed in vt
                       if( lwork>=n*n+max( n+m, 3*n ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*n ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is n by n
                             ldwrku = n
                          end if
                          itau = iu + ldwrku*n
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need n*n+2*n, prefer n*n+n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need n*n+n+m, prefer n*n+n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r to work(iu), zeroing out below it
                          call stdlib_${ci}$lacpy( 'U', n, n, a, lda, work( iu ),ldwrku )
                          call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero,work( iu+1 ), ldwrku )
                                    
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in work(iu), copying result to vt
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_${ci}$gebrd( n, n, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'U', n, n, work( iu ), ldwrku, vt,ldvt )
                          ! generate left bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need n*n+3*n, prefer n*n+2*n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'Q', n, n, n, work( iu ), ldwrku,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (cworkspace: need   n*n+3*n-1,
                                       ! prefer n*n+2*n+(n-1)*nb)
                          ! (rworkspace: need   0)
                          call stdlib_${ci}$ungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of r in work(iu) and computing
                          ! right singular vectors of r in vt
                          ! (cworkspace: need n*n)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', n, n, n, 0, s, rwork( ie ), vt,ldvt, work( iu )&
                                    , ldwrku, cdum, 1,rwork( irwork ), info )
                          ! multiply q in u by left singular vectors of r in
                          ! work(iu), storing result in a
                          ! (cworkspace: need n*n)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gemm( 'N', 'N', m, n, n, cone, u, ldu,work( iu ), ldwrku, &
                                    czero, a, lda )
                          ! copy left singular vectors of a from a to u
                          call stdlib_${ci}$lacpy( 'F', m, n, a, lda, u, ldu )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + n
                          ! compute a=q*r, copying result to u
                          ! (cworkspace: need 2*n, prefer n+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'L', m, n, a, lda, u, ldu )
                          ! generate q in u
                          ! (cworkspace: need n+m, prefer n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungqr( m, m, n, u, ldu, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy r from a to vt, zeroing out below it
                          call stdlib_${ci}$lacpy( 'U', n, n, a, lda, vt, ldvt )
                          if( n>1 )call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero,vt( 2, 1 ), &
                                    ldvt )
                          ie = 1
                          itauq = itau
                          itaup = itauq + n
                          iwork = itaup + n
                          ! bidiagonalize r in vt
                          ! (cworkspace: need 3*n, prefer 2*n+2*n*nb)
                          ! (rworkspace: need n)
                          call stdlib_${ci}$gebrd( n, n, vt, ldvt, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply q in u by left bidiagonalizing vectors
                          ! in vt
                          ! (cworkspace: need 2*n+m, prefer 2*n+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unmbr( 'Q', 'R', 'N', m, n, n, vt, ldvt,work( itauq ), u, &
                                    ldu, work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in vt
                          ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ),&
                                     lwork-iwork+1, ierr )
                          irwork = ie + n
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', n, n, m, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    end if
                 end if
              else
                 ! m < mnthr
                 ! path 10 (m at least n, but not much larger)
                 ! reduce to bidiagonal form without qr decomposition
                 ie = 1
                 itauq = 1
                 itaup = itauq + n
                 iwork = itaup + n
                 ! bidiagonalize a
                 ! (cworkspace: need 2*n+m, prefer 2*n+(m+n)*nb)
                 ! (rworkspace: need n)
                 call stdlib_${ci}$gebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( iwork ), lwork-iwork+1,ierr )
                 if( wntuas ) then
                    ! if left singular vectors desired in u, copy result to u
                    ! and generate left bidiagonalizing vectors in u
                    ! (cworkspace: need 2*n+ncu, prefer 2*n+ncu*nb)
                    ! (rworkspace: 0)
                    call stdlib_${ci}$lacpy( 'L', m, n, a, lda, u, ldu )
                    if( wntus )ncu = n
                    if( wntua )ncu = m
                    call stdlib_${ci}$ungbr( 'Q', m, ncu, n, u, ldu, work( itauq ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntvas ) then
                    ! if right singular vectors desired in vt, copy result to
                    ! vt and generate right bidiagonalizing vectors in vt
                    ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                    ! (rworkspace: 0)
                    call stdlib_${ci}$lacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_${ci}$ungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntuo ) then
                    ! if left singular vectors desired in a, generate left
                    ! bidiagonalizing vectors in a
                    ! (cworkspace: need 3*n, prefer 2*n+n*nb)
                    ! (rworkspace: 0)
                    call stdlib_${ci}$ungbr( 'Q', m, n, n, a, lda, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvo ) then
                    ! if right singular vectors desired in a, generate right
                    ! bidiagonalizing vectors in a
                    ! (cworkspace: need 3*n-1, prefer 2*n+(n-1)*nb)
                    ! (rworkspace: 0)
                    call stdlib_${ci}$ungbr( 'P', n, n, n, a, lda, work( itaup ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 irwork = ie + n
                 if( wntuas .or. wntuo )nru = m
                 if( wntun )nru = 0
                 if( wntvas .or. wntvo )ncvt = n
                 if( wntvn )ncvt = 0
                 if( ( .not.wntuo ) .and. ( .not.wntvo ) ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in vt
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_${ci}$bdsqr( 'U', n, ncvt, nru, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                              cdum, 1, rwork( irwork ),info )
                 else if( ( .not.wntuo ) .and. wntvo ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in a
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_${ci}$bdsqr( 'U', n, ncvt, nru, 0, s, rwork( ie ), a,lda, u, ldu, cdum,&
                               1, rwork( irwork ),info )
                 else
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in a and computing right singular
                    ! vectors in vt
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_${ci}$bdsqr( 'U', n, ncvt, nru, 0, s, rwork( ie ), vt,ldvt, a, lda, &
                              cdum, 1, rwork( irwork ),info )
                 end if
              end if
           else
              ! a has more columns than rows. if a has sufficiently more
              ! columns than rows, first reduce using the lq decomposition (if
              ! sufficient workspace available)
              if( n>=mnthr ) then
                 if( wntvn ) then
                    ! path 1t(n much larger than m, jobvt='n')
                    ! no right singular vectors to be computed
                    itau = 1
                    iwork = itau + m
                    ! compute a=l*q
                    ! (cworkspace: need 2*m, prefer m+m*nb)
                    ! (rworkspace: 0)
                    call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ), work( iwork ),lwork-iwork+1, &
                              ierr )
                    ! zero out above l
                    if (m>1) call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero, a( 1, 2 ),lda )
                    ie = 1
                    itauq = 1
                    itaup = itauq + m
                    iwork = itaup + m
                    ! bidiagonalize l in a
                    ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                    ! (rworkspace: need m)
                    call stdlib_${ci}$gebrd( m, m, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( iwork ), lwork-iwork+1,ierr )
                    if( wntuo .or. wntuas ) then
                       ! if left singular vectors desired, generate q
                       ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$ungbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                    end if
                    irwork = ie + m
                    nru = 0
                    if( wntuo .or. wntuas )nru = m
                    ! perform bidiagonal qr iteration, computing left singular
                    ! vectors of a in a if desired
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_${ci}$bdsqr( 'U', m, 0, nru, 0, s, rwork( ie ), cdum, 1,a, lda, cdum, &
                              1, rwork( irwork ), info )
                    ! if left singular vectors desired in u, copy them there
                    if( wntuas )call stdlib_${ci}$lacpy( 'F', m, m, a, lda, u, ldu )
                 else if( wntvo .and. wntun ) then
                    ! path 2t(n much larger than m, jobu='n', jobvt='o')
                    ! m right singular vectors to be overwritten on a and
                    ! no left singular vectors to be computed
                    if( lwork>=m*m+3*m ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n )+lda*m ) then
                          ! work(iu) is lda by n and work(ir) is lda by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n )+m*m ) then
                          ! work(iu) is lda by n and work(ir) is m by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = m
                       else
                          ! work(iu) is m by chunk and work(ir) is m by m
                          ldwrku = m
                          chunk = ( lwork-m*m ) / m
                          ldwrkr = m
                       end if
                       itau = ir + ldwrkr*m
                       iwork = itau + m
                       ! compute a=l*q
                       ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to work(ir) and zero out above it
                       call stdlib_${ci}$lacpy( 'L', m, m, a, lda, work( ir ), ldwrkr )
                       call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero,work( ir+ldwrkr ), ldwrkr )
                                 
                       ! generate q in a
                       ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$unglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in work(ir)
                       ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                       ! (rworkspace: need m)
                       call stdlib_${ci}$gebrd( m, m, work( ir ), ldwrkr, s, rwork( ie ),work( itauq ),&
                                  work( itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing l
                       ! (cworkspace: need m*m+3*m-1, prefer m*m+2*m+(m-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$ungbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       irwork = ie + m
                       ! perform bidiagonal qr iteration, computing right
                       ! singular vectors of l in work(ir)
                       ! (cworkspace: need m*m)
                       ! (rworkspace: need bdspac)
                       call stdlib_${ci}$bdsqr( 'U', m, m, 0, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                 cdum, 1, cdum, 1,rwork( irwork ), info )
                       iu = itauq
                       ! multiply right singular vectors of l in work(ir) by q
                       ! in a, storing result in work(iu) and copying to a
                       ! (cworkspace: need m*m+m, prefer m*m+m*n)
                       ! (rworkspace: 0)
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_${ci}$gemm( 'N', 'N', m, blk, m, cone, work( ir ),ldwrkr, a( 1, &
                                    i ), lda, czero,work( iu ), ldwrku )
                          call stdlib_${ci}$lacpy( 'F', m, blk, work( iu ), ldwrku,a( 1, i ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       ie = 1
                       itauq = 1
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize a
                       ! (cworkspace: need 2*m+n, prefer 2*m+(m+n)*nb)
                       ! (rworkspace: need m)
                       call stdlib_${ci}$gebrd( m, n, a, lda, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! generate right vectors bidiagonalizing a
                       ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$ungbr( 'P', m, n, m, a, lda, work( itaup ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + m
                       ! perform bidiagonal qr iteration, computing right
                       ! singular vectors of a in a
                       ! (cworkspace: 0)
                       ! (rworkspace: need bdspac)
                       call stdlib_${ci}$bdsqr( 'L', m, n, 0, 0, s, rwork( ie ), a, lda,cdum, 1, cdum, &
                                 1, rwork( irwork ), info )
                    end if
                 else if( wntvo .and. wntuas ) then
                    ! path 3t(n much larger than m, jobu='s' or 'a', jobvt='o')
                    ! m right singular vectors to be overwritten on a and
                    ! m left singular vectors to be computed in u
                    if( lwork>=m*m+3*m ) then
                       ! sufficient workspace for a fast algorithm
                       ir = 1
                       if( lwork>=max( wrkbl, lda*n )+lda*m ) then
                          ! work(iu) is lda by n and work(ir) is lda by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = lda
                       else if( lwork>=max( wrkbl, lda*n )+m*m ) then
                          ! work(iu) is lda by n and work(ir) is m by m
                          ldwrku = lda
                          chunk = n
                          ldwrkr = m
                       else
                          ! work(iu) is m by chunk and work(ir) is m by m
                          ldwrku = m
                          chunk = ( lwork-m*m ) / m
                          ldwrkr = m
                       end if
                       itau = ir + ldwrkr*m
                       iwork = itau + m
                       ! compute a=l*q
                       ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to u, zeroing about above it
                       call stdlib_${ci}$lacpy( 'L', m, m, a, lda, u, ldu )
                       if (m>1) call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero, u( 1, 2 ),ldu )
                       ! generate q in a
                       ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$unglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in u, copying result to work(ir)
                       ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                       ! (rworkspace: need m)
                       call stdlib_${ci}$gebrd( m, m, u, ldu, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       call stdlib_${ci}$lacpy( 'U', m, m, u, ldu, work( ir ), ldwrkr )
                       ! generate right vectors bidiagonalizing l in work(ir)
                       ! (cworkspace: need m*m+3*m-1, prefer m*m+2*m+(m-1)*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$ungbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), work( &
                                 iwork ),lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing l in u
                       ! (cworkspace: need m*m+3*m, prefer m*m+2*m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$ungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + m
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of l in u, and computing right
                       ! singular vectors of l in work(ir)
                       ! (cworkspace: need m*m)
                       ! (rworkspace: need bdspac)
                       call stdlib_${ci}$bdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( ir ), ldwrkr, u, &
                                 ldu, cdum, 1,rwork( irwork ), info )
                       iu = itauq
                       ! multiply right singular vectors of l in work(ir) by q
                       ! in a, storing result in work(iu) and copying to a
                       ! (cworkspace: need m*m+m, prefer m*m+m*n))
                       ! (rworkspace: 0)
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_${ci}$gemm( 'N', 'N', m, blk, m, cone, work( ir ),ldwrkr, a( 1, &
                                    i ), lda, czero,work( iu ), ldwrku )
                          call stdlib_${ci}$lacpy( 'F', m, blk, work( iu ), ldwrku,a( 1, i ), lda )
                                    
                       end do
                    else
                       ! insufficient workspace for a fast algorithm
                       itau = 1
                       iwork = itau + m
                       ! compute a=l*q
                       ! (cworkspace: need 2*m, prefer m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-iwork+&
                                 1, ierr )
                       ! copy l to u, zeroing out above it
                       call stdlib_${ci}$lacpy( 'L', m, m, a, lda, u, ldu )
                       if (m>1) call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero, u( 1, 2 ),ldu )
                       ! generate q in a
                       ! (cworkspace: need 2*m, prefer m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$unglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                 iwork+1, ierr )
                       ie = 1
                       itauq = itau
                       itaup = itauq + m
                       iwork = itaup + m
                       ! bidiagonalize l in u
                       ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                       ! (rworkspace: need m)
                       call stdlib_${ci}$gebrd( m, m, u, ldu, s, rwork( ie ),work( itauq ), work( &
                                 itaup ),work( iwork ), lwork-iwork+1, ierr )
                       ! multiply right vectors bidiagonalizing l by q in a
                       ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$unmbr( 'P', 'L', 'C', m, n, m, u, ldu,work( itaup ), a, lda, &
                                 work( iwork ),lwork-iwork+1, ierr )
                       ! generate left vectors bidiagonalizing l in u
                       ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                       ! (rworkspace: 0)
                       call stdlib_${ci}$ungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                 lwork-iwork+1, ierr )
                       irwork = ie + m
                       ! perform bidiagonal qr iteration, computing left
                       ! singular vectors of a in u and computing right
                       ! singular vectors of a in a
                       ! (cworkspace: 0)
                       ! (rworkspace: need bdspac)
                       call stdlib_${ci}$bdsqr( 'U', m, n, m, 0, s, rwork( ie ), a, lda,u, ldu, cdum, &
                                 1, rwork( irwork ), info )
                    end if
                 else if( wntvs ) then
                    if( wntun ) then
                       ! path 4t(n much larger than m, jobu='n', jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! no left singular vectors to be computed
                       if( lwork>=m*m+3*m ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(ir) is lda by m
                             ldwrkr = lda
                          else
                             ! work(ir) is m by m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(ir), zeroing out above it
                          call stdlib_${ci}$lacpy( 'L', m, m, a, lda, work( ir ),ldwrkr )
                          call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero,work( ir+ldwrkr ), &
                                    ldwrkr )
                          ! generate q in a
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(ir)
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_${ci}$gebrd( m, m, work( ir ), ldwrkr, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate right vectors bidiagonalizing l in
                          ! work(ir)
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of l in work(ir)
                          ! (cworkspace: need m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', m, m, 0, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                    cdum, 1, cdum, 1,rwork( irwork ), info )
                          ! multiply right singular vectors of l in work(ir) by
                          ! q in a, storing result in vt
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gemm( 'N', 'N', m, n, m, cone, work( ir ),ldwrkr, a, lda, &
                                    czero, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy result to vt
                          call stdlib_${ci}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero,a( 1, 2 ), lda )
                          ! bidiagonalize l in a
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_${ci}$gebrd( m, m, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right vectors bidiagonalizing l by q in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unmbr( 'P', 'L', 'C', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', m, n, 0, 0, s, rwork( ie ), vt,ldvt, cdum, 1, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    else if( wntuo ) then
                       ! path 5t(n much larger than m, jobu='o', jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! m left singular vectors to be overwritten on a
                       if( lwork>=2*m*m+3*m ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*m ) then
                             ! work(iu) is lda by m and work(ir) is lda by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+m )*m ) then
                             ! work(iu) is lda by m and work(ir) is m by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          else
                             ! work(iu) is m by m and work(ir) is m by m
                             ldwrku = m
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (cworkspace: need 2*m*m+2*m, prefer 2*m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(iu), zeroing out below it
                          call stdlib_${ci}$lacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero,work( iu+ldwrku ), &
                                    ldwrku )
                          ! generate q in a
                          ! (cworkspace: need 2*m*m+2*m, prefer 2*m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to
                          ! work(ir)
                          ! (cworkspace: need   2*m*m+3*m,
                                       ! prefer 2*m*m+2*m+2*m*nb)
                          ! (rworkspace: need   m)
                          call stdlib_${ci}$gebrd( m, m, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'L', m, m, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need   2*m*m+3*m-1,
                                       ! prefer 2*m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need 2*m*m+3*m, prefer 2*m*m+2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'Q', m, m, m, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in work(ir) and computing
                          ! right singular vectors of l in work(iu)
                          ! (cworkspace: need 2*m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( iu ), ldwrku, &
                                    work( ir ),ldwrkr, cdum, 1, rwork( irwork ),info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in a, storing result in vt
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gemm( 'N', 'N', m, n, m, cone, work( iu ),ldwrku, a, lda, &
                                    czero, vt, ldvt )
                          ! copy left singular vectors of l to a
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$lacpy( 'F', m, m, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero,a( 1, 2 ), lda )
                          ! bidiagonalize l in a
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_${ci}$gebrd( m, m, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right vectors bidiagonalizing l by q in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unmbr( 'P', 'L', 'C', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors of l in a
                          ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in a and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', m, n, m, 0, s, rwork( ie ), vt,ldvt, a, lda, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    else if( wntuas ) then
                       ! path 6t(n much larger than m, jobu='s' or 'a',
                               ! jobvt='s')
                       ! m right singular vectors to be computed in vt and
                       ! m left singular vectors to be computed in u
                       if( lwork>=m*m+3*m ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(iu) is lda by n
                             ldwrku = lda
                          else
                             ! work(iu) is lda by m
                             ldwrku = m
                          end if
                          itau = iu + ldwrku*m
                          iwork = itau + m
                          ! compute a=l*q
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_${ci}$lacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero,work( iu+ldwrku ), &
                                    ldwrku )
                          ! generate q in a
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unglq( m, n, m, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to u
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_${ci}$gebrd( m, m, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'L', m, m, work( iu ), ldwrku, u,ldu )
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need   m*m+3*m-1,
                                       ! prefer m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in u and computing right
                          ! singular vectors of l in work(iu)
                          ! (cworkspace: need m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( iu ), ldwrku, &
                                    u, ldu, cdum, 1,rwork( irwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in a, storing result in vt
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gemm( 'N', 'N', m, n, m, cone, work( iu ),ldwrku, a, lda, &
                                    czero, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unglq( m, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to u, zeroing out above it
                          call stdlib_${ci}$lacpy( 'L', m, m, a, lda, u, ldu )
                          if (m>1) call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero,u( 1, 2 ), ldu )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in u
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_${ci}$gebrd( m, m, u, ldu, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in u by q
                          ! in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unmbr( 'P', 'L', 'C', m, n, m, u, ldu,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', m, n, m, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    end if
                 else if( wntva ) then
                    if( wntun ) then
                       ! path 7t(n much larger than m, jobu='n', jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! no left singular vectors to be computed
                       if( lwork>=m*m+max( n+m, 3*m ) ) then
                          ! sufficient workspace for a fast algorithm
                          ir = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(ir) is lda by m
                             ldwrkr = lda
                          else
                             ! work(ir) is m by m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! copy l to work(ir), zeroing out above it
                          call stdlib_${ci}$lacpy( 'L', m, m, a, lda, work( ir ),ldwrkr )
                          call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero,work( ir+ldwrkr ), &
                                    ldwrkr )
                          ! generate q in vt
                          ! (cworkspace: need m*m+m+n, prefer m*m+m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(ir)
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_${ci}$gebrd( m, m, work( ir ), ldwrkr, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          ! generate right bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need   m*m+3*m-1,
                                       ! prefer m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'P', m, m, m, work( ir ), ldwrkr,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of l in work(ir)
                          ! (cworkspace: need m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', m, m, 0, 0, s, rwork( ie ),work( ir ), ldwrkr, &
                                    cdum, 1, cdum, 1,rwork( irwork ), info )
                          ! multiply right singular vectors of l in work(ir) by
                          ! q in vt, storing result in a
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gemm( 'N', 'N', m, n, m, cone, work( ir ),ldwrkr, vt, ldvt,&
                                     czero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_${ci}$lacpy( 'F', m, n, a, lda, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need m+n, prefer m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero,a( 1, 2 ), lda )
                          ! bidiagonalize l in a
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_${ci}$gebrd( m, m, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in a by q
                          ! in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unmbr( 'P', 'L', 'C', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', m, n, 0, 0, s, rwork( ie ), vt,ldvt, cdum, 1, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    else if( wntuo ) then
                       ! path 8t(n much larger than m, jobu='o', jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! m left singular vectors to be overwritten on a
                       if( lwork>=2*m*m+max( n+m, 3*m ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+2*lda*m ) then
                             ! work(iu) is lda by m and work(ir) is lda by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = lda
                          else if( lwork>=wrkbl+( lda+m )*m ) then
                             ! work(iu) is lda by m and work(ir) is m by m
                             ldwrku = lda
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          else
                             ! work(iu) is m by m and work(ir) is m by m
                             ldwrku = m
                             ir = iu + ldwrku*m
                             ldwrkr = m
                          end if
                          itau = ir + ldwrkr*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m*m+2*m, prefer 2*m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need 2*m*m+m+n, prefer 2*m*m+m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_${ci}$lacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero,work( iu+ldwrku ), &
                                    ldwrku )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to
                          ! work(ir)
                          ! (cworkspace: need   2*m*m+3*m,
                                       ! prefer 2*m*m+2*m+2*m*nb)
                          ! (rworkspace: need   m)
                          call stdlib_${ci}$gebrd( m, m, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'L', m, m, work( iu ), ldwrku,work( ir ), ldwrkr )
                                    
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need   2*m*m+3*m-1,
                                       ! prefer 2*m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in work(ir)
                          ! (cworkspace: need 2*m*m+3*m, prefer 2*m*m+2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'Q', m, m, m, work( ir ), ldwrkr,work( itauq ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in work(ir) and computing
                          ! right singular vectors of l in work(iu)
                          ! (cworkspace: need 2*m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( iu ), ldwrku, &
                                    work( ir ),ldwrkr, cdum, 1, rwork( irwork ),info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in vt, storing result in a
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gemm( 'N', 'N', m, n, m, cone, work( iu ),ldwrku, vt, ldvt,&
                                     czero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_${ci}$lacpy( 'F', m, n, a, lda, vt, ldvt )
                          ! copy left singular vectors of a from work(ir) to a
                          call stdlib_${ci}$lacpy( 'F', m, m, work( ir ), ldwrkr, a,lda )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need m+n, prefer m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! zero out above l in a
                          if (m>1) call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero,a( 1, 2 ), lda )
                          ! bidiagonalize l in a
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_${ci}$gebrd( m, m, a, lda, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in a by q
                          ! in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unmbr( 'P', 'L', 'C', m, n, m, a, lda,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in a
                          ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'Q', m, m, m, a, lda, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in a and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', m, n, m, 0, s, rwork( ie ), vt,ldvt, a, lda, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    else if( wntuas ) then
                       ! path 9t(n much larger than m, jobu='s' or 'a',
                               ! jobvt='a')
                       ! n right singular vectors to be computed in vt and
                       ! m left singular vectors to be computed in u
                       if( lwork>=m*m+max( n+m, 3*m ) ) then
                          ! sufficient workspace for a fast algorithm
                          iu = 1
                          if( lwork>=wrkbl+lda*m ) then
                             ! work(iu) is lda by m
                             ldwrku = lda
                          else
                             ! work(iu) is m by m
                             ldwrku = m
                          end if
                          itau = iu + ldwrku*m
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need m*m+2*m, prefer m*m+m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need m*m+m+n, prefer m*m+m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to work(iu), zeroing out above it
                          call stdlib_${ci}$lacpy( 'L', m, m, a, lda, work( iu ),ldwrku )
                          call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero,work( iu+ldwrku ), &
                                    ldwrku )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in work(iu), copying result to u
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_${ci}$gebrd( m, m, work( iu ), ldwrku, s,rwork( ie ), work( &
                                    itauq ),work( itaup ), work( iwork ),lwork-iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'L', m, m, work( iu ), ldwrku, u,ldu )
                          ! generate right bidiagonalizing vectors in work(iu)
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+(m-1)*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'P', m, m, m, work( iu ), ldwrku,work( itaup ), &
                                    work( iwork ),lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (cworkspace: need m*m+3*m, prefer m*m+2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of l in u and computing right
                          ! singular vectors of l in work(iu)
                          ! (cworkspace: need m*m)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', m, m, m, 0, s, rwork( ie ),work( iu ), ldwrku, &
                                    u, ldu, cdum, 1,rwork( irwork ), info )
                          ! multiply right singular vectors of l in work(iu) by
                          ! q in vt, storing result in a
                          ! (cworkspace: need m*m)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gemm( 'N', 'N', m, n, m, cone, work( iu ),ldwrku, vt, ldvt,&
                                     czero, a, lda )
                          ! copy right singular vectors of a from a to vt
                          call stdlib_${ci}$lacpy( 'F', m, n, a, lda, vt, ldvt )
                       else
                          ! insufficient workspace for a fast algorithm
                          itau = 1
                          iwork = itau + m
                          ! compute a=l*q, copying result to vt
                          ! (cworkspace: need 2*m, prefer m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ),work( iwork ), lwork-&
                                    iwork+1, ierr )
                          call stdlib_${ci}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                          ! generate q in vt
                          ! (cworkspace: need m+n, prefer m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unglq( n, n, m, vt, ldvt, work( itau ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          ! copy l to u, zeroing out above it
                          call stdlib_${ci}$lacpy( 'L', m, m, a, lda, u, ldu )
                          if (m>1) call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero,u( 1, 2 ), ldu )
                          ie = 1
                          itauq = itau
                          itaup = itauq + m
                          iwork = itaup + m
                          ! bidiagonalize l in u
                          ! (cworkspace: need 3*m, prefer 2*m+2*m*nb)
                          ! (rworkspace: need m)
                          call stdlib_${ci}$gebrd( m, m, u, ldu, s, rwork( ie ),work( itauq ), work( &
                                    itaup ),work( iwork ), lwork-iwork+1, ierr )
                          ! multiply right bidiagonalizing vectors in u by q
                          ! in vt
                          ! (cworkspace: need 2*m+n, prefer 2*m+n*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$unmbr( 'P', 'L', 'C', m, n, m, u, ldu,work( itaup ), vt, &
                                    ldvt,work( iwork ), lwork-iwork+1, ierr )
                          ! generate left bidiagonalizing vectors in u
                          ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                          ! (rworkspace: 0)
                          call stdlib_${ci}$ungbr( 'Q', m, m, m, u, ldu, work( itauq ),work( iwork ), &
                                    lwork-iwork+1, ierr )
                          irwork = ie + m
                          ! perform bidiagonal qr iteration, computing left
                          ! singular vectors of a in u and computing right
                          ! singular vectors of a in vt
                          ! (cworkspace: 0)
                          ! (rworkspace: need bdspac)
                          call stdlib_${ci}$bdsqr( 'U', m, n, m, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                                    cdum, 1,rwork( irwork ), info )
                       end if
                    end if
                 end if
              else
                 ! n < mnthr
                 ! path 10t(n greater than m, but not much larger)
                 ! reduce to bidiagonal form without lq decomposition
                 ie = 1
                 itauq = 1
                 itaup = itauq + m
                 iwork = itaup + m
                 ! bidiagonalize a
                 ! (cworkspace: need 2*m+n, prefer 2*m+(m+n)*nb)
                 ! (rworkspace: m)
                 call stdlib_${ci}$gebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( iwork ), lwork-iwork+1,ierr )
                 if( wntuas ) then
                    ! if left singular vectors desired in u, copy result to u
                    ! and generate left bidiagonalizing vectors in u
                    ! (cworkspace: need 3*m-1, prefer 2*m+(m-1)*nb)
                    ! (rworkspace: 0)
                    call stdlib_${ci}$lacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_${ci}$ungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvas ) then
                    ! if right singular vectors desired in vt, copy result to
                    ! vt and generate right bidiagonalizing vectors in vt
                    ! (cworkspace: need 2*m+nrvt, prefer 2*m+nrvt*nb)
                    ! (rworkspace: 0)
                    call stdlib_${ci}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                    if( wntva )nrvt = n
                    if( wntvs )nrvt = m
                    call stdlib_${ci}$ungbr( 'P', nrvt, n, m, vt, ldvt, work( itaup ),work( iwork ), &
                              lwork-iwork+1, ierr )
                 end if
                 if( wntuo ) then
                    ! if left singular vectors desired in a, generate left
                    ! bidiagonalizing vectors in a
                    ! (cworkspace: need 3*m-1, prefer 2*m+(m-1)*nb)
                    ! (rworkspace: 0)
                    call stdlib_${ci}$ungbr( 'Q', m, m, n, a, lda, work( itauq ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 if( wntvo ) then
                    ! if right singular vectors desired in a, generate right
                    ! bidiagonalizing vectors in a
                    ! (cworkspace: need 3*m, prefer 2*m+m*nb)
                    ! (rworkspace: 0)
                    call stdlib_${ci}$ungbr( 'P', m, n, m, a, lda, work( itaup ),work( iwork ), lwork-&
                              iwork+1, ierr )
                 end if
                 irwork = ie + m
                 if( wntuas .or. wntuo )nru = m
                 if( wntun )nru = 0
                 if( wntvas .or. wntvo )ncvt = n
                 if( wntvn )ncvt = 0
                 if( ( .not.wntuo ) .and. ( .not.wntvo ) ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in vt
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_${ci}$bdsqr( 'L', m, ncvt, nru, 0, s, rwork( ie ), vt,ldvt, u, ldu, &
                              cdum, 1, rwork( irwork ),info )
                 else if( ( .not.wntuo ) .and. wntvo ) then
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in u and computing right singular
                    ! vectors in a
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_${ci}$bdsqr( 'L', m, ncvt, nru, 0, s, rwork( ie ), a,lda, u, ldu, cdum,&
                               1, rwork( irwork ),info )
                 else
                    ! perform bidiagonal qr iteration, if desired, computing
                    ! left singular vectors in a and computing right singular
                    ! vectors in vt
                    ! (cworkspace: 0)
                    ! (rworkspace: need bdspac)
                    call stdlib_${ci}$bdsqr( 'L', m, ncvt, nru, 0, s, rwork( ie ), vt,ldvt, a, lda, &
                              cdum, 1, rwork( irwork ),info )
                 end if
              end if
           end if
           ! undo scaling if necessary
           if( iscl==1 ) then
              if( anrm>bignum )call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm>bignum )call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, bignum, anrm, minmn-1,&
                         1,rwork( ie ), minmn, ierr )
              if( anrm<smlnum )call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm<smlnum )call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, smlnum, anrm, minmn-1,&
                         1,rwork( ie ), minmn, ierr )
           end if
           ! return optimal workspace in work(1)
           work( 1 ) = maxwrk
           return
     end subroutine stdlib_${ci}$gesvd

#:endif
#:endfor





     module pure subroutine stdlib_sbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, work, &
     !! SBDSQR computes the singular values and, optionally, the right and/or
     !! left singular vectors from the singular value decomposition (SVD) of
     !! a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
     !! zero-shift QR algorithm.  The SVD of B has the form
     !! B = Q * S * P**T
     !! where S is the diagonal matrix of singular values, Q is an orthogonal
     !! matrix of left singular vectors, and P is an orthogonal matrix of
     !! right singular vectors.  If left singular vectors are requested, this
     !! subroutine actually returns U*Q instead of Q, and, if right singular
     !! vectors are requested, this subroutine returns P**T*VT instead of
     !! P**T, for given real input matrices U and VT.  When U and VT are the
     !! orthogonal matrices that reduce a general matrix A to bidiagonal
     !! form:  A = U*B*VT, as computed by SGEBRD, then
     !! A = (U*Q) * S * (P**T*VT)
     !! is the SVD of A.  Optionally, the subroutine may also compute Q**T*C
     !! for a given real input matrix C.
     !! See "Computing  Small Singular Values of Bidiagonal Matrices With
     !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
     !! LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
     !! no. 5, pp. 873-912, Sept 1990) and
     !! "Accurate singular values and differential qd algorithms," by
     !! B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
     !! Department, University of California at Berkeley, July 1992
     !! for a detailed description of the algorithm.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           ! Array Arguments 
           real(sp), intent(inout) :: c(ldc,*), d(*), e(*), u(ldu,*), vt(ldvt,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: hndrth = 0.01_sp
           real(sp), parameter :: hndrd = 100.0_sp
           real(sp), parameter :: meigth = -0.125_sp
           integer(ilp), parameter :: maxitr = 6
           
           
           
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: lower, rotate
           integer(ilp) :: i, idir, isub, iter, iterdivn, j, ll, lll, m, maxitdivn, nm1, nm12, &
                     nm13, oldll, oldm
           real(sp) :: abse, abss, cosl, cosr, cs, eps, f, g, h, mu, oldcs, oldsn, r, shift, &
           sigmn, sigmx, sinl, sinr, sll, smax, smin, sminl, sminoa, sn, thresh, tol, tolmul, &
                     unfl
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.lower ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ncvt<0 ) then
              info = -3
           else if( nru<0 ) then
              info = -4
           else if( ncc<0 ) then
              info = -5
           else if( ( ncvt==0 .and. ldvt<1 ) .or.( ncvt>0 .and. ldvt<max( 1, n ) ) ) then
              info = -9
           else if( ldu<max( 1, nru ) ) then
              info = -11
           else if( ( ncc==0 .and. ldc<1 ) .or.( ncc>0 .and. ldc<max( 1, n ) ) ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SBDSQR', -info )
              return
           end if
           if( n==0 )return
           if( n==1 )go to 160
           ! rotate is true if any singular vectors desired, false otherwise
           rotate = ( ncvt>0 ) .or. ( nru>0 ) .or. ( ncc>0 )
           ! if no singular vectors desired, use qd algorithm
           if( .not.rotate ) then
              call stdlib_slasq1( n, d, e, work, info )
           ! if info equals 2, dqds didn't finish, try to finish
              if( info /= 2 ) return
              info = 0
           end if
           nm1 = n - 1
           nm12 = nm1 + nm1
           nm13 = nm12 + nm1
           idir = 0
           ! get machine constants
           eps = stdlib_slamch( 'EPSILON' )
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           if( lower ) then
              do i = 1, n - 1
                 call stdlib_slartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 work( i ) = cs
                 work( nm1+i ) = sn
              end do
              ! update singular vectors if desired
              if( nru>0 )call stdlib_slasr( 'R', 'V', 'F', nru, n, work( 1 ), work( n ), u,ldu )
                        
              if( ncc>0 )call stdlib_slasr( 'L', 'V', 'F', n, ncc, work( 1 ), work( n ), c,ldc )
                        
           end if
           ! compute singular values to relative accuracy tol
           ! (by setting tol to be negative, algorithm will compute
           ! singular values to absolute accuracy abs(tol)*norm(input matrix))
           tolmul = max( ten, min( hndrd, eps**meigth ) )
           tol = tolmul*eps
           ! compute approximate maximum, minimum singular values
           smax = zero
           do i = 1, n
              smax = max( smax, abs( d( i ) ) )
           end do
           do i = 1, n - 1
              smax = max( smax, abs( e( i ) ) )
           end do
           sminl = zero
           if( tol>=zero ) then
              ! relative accuracy desired
              sminoa = abs( d( 1 ) )
              if( sminoa==zero )go to 50
              mu = sminoa
              do i = 2, n
                 mu = abs( d( i ) )*( mu / ( mu+abs( e( i-1 ) ) ) )
                 sminoa = min( sminoa, mu )
                 if( sminoa==zero )go to 50
              end do
              50 continue
              sminoa = sminoa / sqrt( real( n,KIND=sp) )
              thresh = max( tol*sminoa, maxitr*(n*(n*unfl)) )
           else
              ! absolute accuracy desired
              thresh = max( abs( tol )*smax, maxitr*(n*(n*unfl)) )
           end if
           ! prepare for main iteration loop for the singular values
           ! (maxit is the maximum number of passes through the inner
           ! loop permitted before nonconvergence signalled.)
           maxitdivn = maxitr*n
           iterdivn = 0
           iter = -1
           oldll = -1
           oldm = -1
           ! m points to last element of unconverged part of matrix
           m = n
           ! begin main iteration loop
           60 continue
           ! check for convergence or exceeding iteration count
           if( m<=1 )go to 160
           if( iter>=n ) then
              iter = iter - n
              iterdivn = iterdivn + 1
              if( iterdivn>=maxitdivn )go to 200
           end if
           ! find diagonal block of matrix to work on
           if( tol<zero .and. abs( d( m ) )<=thresh )d( m ) = zero
           smax = abs( d( m ) )
           smin = smax
           do lll = 1, m - 1
              ll = m - lll
              abss = abs( d( ll ) )
              abse = abs( e( ll ) )
              if( tol<zero .and. abss<=thresh )d( ll ) = zero
              if( abse<=thresh )go to 80
              smin = min( smin, abss )
              smax = max( smax, abss, abse )
           end do
           ll = 0
           go to 90
           80 continue
           e( ll ) = zero
           ! matrix splits since e(ll) = 0
           if( ll==m-1 ) then
              ! convergence of bottom singular value, return to top of loop
              m = m - 1
              go to 60
           end if
           90 continue
           ll = ll + 1
           ! e(ll) through e(m-1) are nonzero, e(ll-1) is zero
           if( ll==m-1 ) then
              ! 2 by 2 block, handle separately
              call stdlib_slasv2( d( m-1 ), e( m-1 ), d( m ), sigmn, sigmx, sinr,cosr, sinl, cosl &
                        )
              d( m-1 ) = sigmx
              e( m-1 ) = zero
              d( m ) = sigmn
              ! compute singular vectors, if desired
              if( ncvt>0 )call stdlib_srot( ncvt, vt( m-1, 1 ), ldvt, vt( m, 1 ), ldvt, cosr,sinr &
                        )
              if( nru>0 )call stdlib_srot( nru, u( 1, m-1 ), 1, u( 1, m ), 1, cosl, sinl )
              if( ncc>0 )call stdlib_srot( ncc, c( m-1, 1 ), ldc, c( m, 1 ), ldc, cosl,sinl )
                        
              m = m - 2
              go to 60
           end if
           ! if working on new submatrix, choose shift direction
           ! (from larger end diagonal element towards smaller)
           if( ll>oldm .or. m<oldll ) then
              if( abs( d( ll ) )>=abs( d( m ) ) ) then
                 ! chase bulge from top (big end) to bottom (small end)
                 idir = 1
              else
                 ! chase bulge from bottom (big end) to top (small end)
                 idir = 2
              end if
           end if
           ! apply convergence tests
           if( idir==1 ) then
              ! run convergence test in forward direction
              ! first apply standard test to bottom of matrix
              if( abs( e( m-1 ) )<=abs( tol )*abs( d( m ) ) .or.( tol<zero .and. abs( e( m-1 ) )&
                        <=thresh ) ) then
                 e( m-1 ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion forward
                 mu = abs( d( ll ) )
                 sminl = mu
                 do lll = ll, m - 1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll+1 ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           else
              ! run convergence test in backward direction
              ! first apply standard test to top of matrix
              if( abs( e( ll ) )<=abs( tol )*abs( d( ll ) ) .or.( tol<zero .and. abs( e( ll ) )&
                        <=thresh ) ) then
                 e( ll ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion backward
                 mu = abs( d( m ) )
                 sminl = mu
                 do lll = m - 1, ll, -1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           end if
           oldll = ll
           oldm = m
           ! compute shift.  first, test if shifting would ruin relative
           ! accuracy, and if so set the shift to zero.
           if( tol>=zero .and. n*tol*( sminl / smax )<=max( eps, hndrth*tol ) ) then
              ! use a zero shift to avoid loss of relative accuracy
              shift = zero
           else
              ! compute the shift from 2-by-2 block at end of matrix
              if( idir==1 ) then
                 sll = abs( d( ll ) )
                 call stdlib_slas2( d( m-1 ), e( m-1 ), d( m ), shift, r )
              else
                 sll = abs( d( m ) )
                 call stdlib_slas2( d( ll ), e( ll ), d( ll+1 ), shift, r )
              end if
              ! test if shift negligible, and if so set to zero
              if( sll>zero ) then
                 if( ( shift / sll )**2<eps )shift = zero
              end if
           end if
           ! increment iteration count
           iter = iter + m - ll
           ! if shift = 0, do simplified qr iteration
           if( shift==zero ) then
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = ll, m - 1
                    call stdlib_slartg( d( i )*cs, e( i ), cs, sn, r )
                    if( i>ll )e( i-1 ) = oldsn*r
                    call stdlib_slartg( oldcs*r, d( i+1 )*sn, oldcs, oldsn, d( i ) )
                    work( i-ll+1 ) = cs
                    work( i-ll+1+nm1 ) = sn
                    work( i-ll+1+nm12 ) = oldcs
                    work( i-ll+1+nm13 ) = oldsn
                 end do
                 h = d( m )*cs
                 d( m ) = h*oldcs
                 e( m-1 ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_slasr( 'L', 'V', 'F', m-ll+1, ncvt, work( 1 ),work( n ), &
                           vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_slasr( 'R', 'V', 'F', nru, m-ll+1, work( nm12+1 ),work( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_slasr( 'L', 'V', 'F', m-ll+1, ncc, work( nm12+1 ),work( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = m, ll + 1, -1
                    call stdlib_slartg( d( i )*cs, e( i-1 ), cs, sn, r )
                    if( i<m )e( i ) = oldsn*r
                    call stdlib_slartg( oldcs*r, d( i-1 )*sn, oldcs, oldsn, d( i ) )
                    work( i-ll ) = cs
                    work( i-ll+nm1 ) = -sn
                    work( i-ll+nm12 ) = oldcs
                    work( i-ll+nm13 ) = -oldsn
                 end do
                 h = d( ll )*cs
                 d( ll ) = h*oldcs
                 e( ll ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_slasr( 'L', 'V', 'B', m-ll+1, ncvt, work( nm12+1 ),work( &
                           nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_slasr( 'R', 'V', 'B', nru, m-ll+1, work( 1 ),work( n ), u(&
                            1, ll ), ldu )
                 if( ncc>0 )call stdlib_slasr( 'L', 'V', 'B', m-ll+1, ncc, work( 1 ),work( n ), c(&
                            ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
              end if
           else
              ! use nonzero shift
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( ll ) )-shift )*( sign( one, d( ll ) )+shift / d( ll ) )
                 g = e( ll )
                 do i = ll, m - 1
                    call stdlib_slartg( f, g, cosr, sinr, r )
                    if( i>ll )e( i-1 ) = r
                    f = cosr*d( i ) + sinr*e( i )
                    e( i ) = cosr*e( i ) - sinr*d( i )
                    g = sinr*d( i+1 )
                    d( i+1 ) = cosr*d( i+1 )
                    call stdlib_slartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i ) + sinl*d( i+1 )
                    d( i+1 ) = cosl*d( i+1 ) - sinl*e( i )
                    if( i<m-1 ) then
                       g = sinl*e( i+1 )
                       e( i+1 ) = cosl*e( i+1 )
                    end if
                    work( i-ll+1 ) = cosr
                    work( i-ll+1+nm1 ) = sinr
                    work( i-ll+1+nm12 ) = cosl
                    work( i-ll+1+nm13 ) = sinl
                 end do
                 e( m-1 ) = f
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_slasr( 'L', 'V', 'F', m-ll+1, ncvt, work( 1 ),work( n ), &
                           vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_slasr( 'R', 'V', 'F', nru, m-ll+1, work( nm12+1 ),work( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_slasr( 'L', 'V', 'F', m-ll+1, ncc, work( nm12+1 ),work( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( m ) )-shift )*( sign( one, d( m ) )+shift /d( m ) )
                 g = e( m-1 )
                 do i = m, ll + 1, -1
                    call stdlib_slartg( f, g, cosr, sinr, r )
                    if( i<m )e( i ) = r
                    f = cosr*d( i ) + sinr*e( i-1 )
                    e( i-1 ) = cosr*e( i-1 ) - sinr*d( i )
                    g = sinr*d( i-1 )
                    d( i-1 ) = cosr*d( i-1 )
                    call stdlib_slartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i-1 ) + sinl*d( i-1 )
                    d( i-1 ) = cosl*d( i-1 ) - sinl*e( i-1 )
                    if( i>ll+1 ) then
                       g = sinl*e( i-2 )
                       e( i-2 ) = cosl*e( i-2 )
                    end if
                    work( i-ll ) = cosr
                    work( i-ll+nm1 ) = -sinr
                    work( i-ll+nm12 ) = cosl
                    work( i-ll+nm13 ) = -sinl
                 end do
                 e( ll ) = f
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
                 ! update singular vectors if desired
                 if( ncvt>0 )call stdlib_slasr( 'L', 'V', 'B', m-ll+1, ncvt, work( nm12+1 ),work( &
                           nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_slasr( 'R', 'V', 'B', nru, m-ll+1, work( 1 ),work( n ), u(&
                            1, ll ), ldu )
                 if( ncc>0 )call stdlib_slasr( 'L', 'V', 'B', m-ll+1, ncc, work( 1 ),work( n ), c(&
                            ll, 1 ), ldc )
              end if
           end if
           ! qr iteration finished, go back and check convergence
           go to 60
           ! all singular values converged, so make them positive
           160 continue
           do i = 1, n
              if( d( i )<zero ) then
                 d( i ) = -d( i )
                 ! change sign of singular vectors, if desired
                 if( ncvt>0 )call stdlib_sscal( ncvt, negone, vt( i, 1 ), ldvt )
              end if
           end do
           ! sort the singular values into decreasing order (insertion sort on
           ! singular values, but only one transposition per singular vector)
           do i = 1, n - 1
              ! scan for smallest d(i)
              isub = 1
              smin = d( 1 )
              do j = 2, n + 1 - i
                 if( d( j )<=smin ) then
                    isub = j
                    smin = d( j )
                 end if
              end do
              if( isub/=n+1-i ) then
                 ! swap singular values and vectors
                 d( isub ) = d( n+1-i )
                 d( n+1-i ) = smin
                 if( ncvt>0 )call stdlib_sswap( ncvt, vt( isub, 1 ), ldvt, vt( n+1-i, 1 ),ldvt )
                           
                 if( nru>0 )call stdlib_sswap( nru, u( 1, isub ), 1, u( 1, n+1-i ), 1 )
                 if( ncc>0 )call stdlib_sswap( ncc, c( isub, 1 ), ldc, c( n+1-i, 1 ), ldc )
                           
              end if
           end do
           go to 220
           ! maximum number of iterations exceeded, failure to converge
           200 continue
           info = 0
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           220 continue
           return
     end subroutine stdlib_sbdsqr

     module pure subroutine stdlib_dbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, work, &
     !! DBDSQR computes the singular values and, optionally, the right and/or
     !! left singular vectors from the singular value decomposition (SVD) of
     !! a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
     !! zero-shift QR algorithm.  The SVD of B has the form
     !! B = Q * S * P**T
     !! where S is the diagonal matrix of singular values, Q is an orthogonal
     !! matrix of left singular vectors, and P is an orthogonal matrix of
     !! right singular vectors.  If left singular vectors are requested, this
     !! subroutine actually returns U*Q instead of Q, and, if right singular
     !! vectors are requested, this subroutine returns P**T*VT instead of
     !! P**T, for given real input matrices U and VT.  When U and VT are the
     !! orthogonal matrices that reduce a general matrix A to bidiagonal
     !! form:  A = U*B*VT, as computed by DGEBRD, then
     !! A = (U*Q) * S * (P**T*VT)
     !! is the SVD of A.  Optionally, the subroutine may also compute Q**T*C
     !! for a given real input matrix C.
     !! See "Computing  Small Singular Values of Bidiagonal Matrices With
     !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
     !! LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
     !! no. 5, pp. 873-912, Sept 1990) and
     !! "Accurate singular values and differential qd algorithms," by
     !! B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
     !! Department, University of California at Berkeley, July 1992
     !! for a detailed description of the algorithm.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           ! Array Arguments 
           real(dp), intent(inout) :: c(ldc,*), d(*), e(*), u(ldu,*), vt(ldvt,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: hndrth = 0.01_dp
           real(dp), parameter :: hndrd = 100.0_dp
           real(dp), parameter :: meigth = -0.125_dp
           integer(ilp), parameter :: maxitr = 6
           
           
           
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: lower, rotate
           integer(ilp) :: i, idir, isub, iter, iterdivn, j, ll, lll, m, maxitdivn, nm1, nm12, &
                     nm13, oldll, oldm
           real(dp) :: abse, abss, cosl, cosr, cs, eps, f, g, h, mu, oldcs, oldsn, r, shift, &
           sigmn, sigmx, sinl, sinr, sll, smax, smin, sminl, sminoa, sn, thresh, tol, tolmul, &
                     unfl
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.lower ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ncvt<0 ) then
              info = -3
           else if( nru<0 ) then
              info = -4
           else if( ncc<0 ) then
              info = -5
           else if( ( ncvt==0 .and. ldvt<1 ) .or.( ncvt>0 .and. ldvt<max( 1, n ) ) ) then
              info = -9
           else if( ldu<max( 1, nru ) ) then
              info = -11
           else if( ( ncc==0 .and. ldc<1 ) .or.( ncc>0 .and. ldc<max( 1, n ) ) ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DBDSQR', -info )
              return
           end if
           if( n==0 )return
           if( n==1 )go to 160
           ! rotate is true if any singular vectors desired, false otherwise
           rotate = ( ncvt>0 ) .or. ( nru>0 ) .or. ( ncc>0 )
           ! if no singular vectors desired, use qd algorithm
           if( .not.rotate ) then
              call stdlib_dlasq1( n, d, e, work, info )
           ! if info equals 2, dqds didn't finish, try to finish
              if( info /= 2 ) return
              info = 0
           end if
           nm1 = n - 1
           nm12 = nm1 + nm1
           nm13 = nm12 + nm1
           idir = 0
           ! get machine constants
           eps = stdlib_dlamch( 'EPSILON' )
           unfl = stdlib_dlamch( 'SAFE MINIMUM' )
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           if( lower ) then
              do i = 1, n - 1
                 call stdlib_dlartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 work( i ) = cs
                 work( nm1+i ) = sn
              end do
              ! update singular vectors if desired
              if( nru>0 )call stdlib_dlasr( 'R', 'V', 'F', nru, n, work( 1 ), work( n ), u,ldu )
                        
              if( ncc>0 )call stdlib_dlasr( 'L', 'V', 'F', n, ncc, work( 1 ), work( n ), c,ldc )
                        
           end if
           ! compute singular values to relative accuracy tol
           ! (by setting tol to be negative, algorithm will compute
           ! singular values to absolute accuracy abs(tol)*norm(input matrix))
           tolmul = max( ten, min( hndrd, eps**meigth ) )
           tol = tolmul*eps
           ! compute approximate maximum, minimum singular values
           smax = zero
           do i = 1, n
              smax = max( smax, abs( d( i ) ) )
           end do
           do i = 1, n - 1
              smax = max( smax, abs( e( i ) ) )
           end do
           sminl = zero
           if( tol>=zero ) then
              ! relative accuracy desired
              sminoa = abs( d( 1 ) )
              if( sminoa==zero )go to 50
              mu = sminoa
              do i = 2, n
                 mu = abs( d( i ) )*( mu / ( mu+abs( e( i-1 ) ) ) )
                 sminoa = min( sminoa, mu )
                 if( sminoa==zero )go to 50
              end do
              50 continue
              sminoa = sminoa / sqrt( real( n,KIND=dp) )
              thresh = max( tol*sminoa, maxitr*(n*(n*unfl)) )
           else
              ! absolute accuracy desired
              thresh = max( abs( tol )*smax, maxitr*(n*(n*unfl)) )
           end if
           ! prepare for main iteration loop for the singular values
           ! (maxit is the maximum number of passes through the inner
           ! loop permitted before nonconvergence signalled.)
           maxitdivn = maxitr*n
           iterdivn = 0
           iter = -1
           oldll = -1
           oldm = -1
           ! m points to last element of unconverged part of matrix
           m = n
           ! begin main iteration loop
           60 continue
           ! check for convergence or exceeding iteration count
           if( m<=1 )go to 160
           if( iter>=n ) then
              iter = iter - n
              iterdivn = iterdivn + 1
              if( iterdivn>=maxitdivn )go to 200
           end if
           ! find diagonal block of matrix to work on
           if( tol<zero .and. abs( d( m ) )<=thresh )d( m ) = zero
           smax = abs( d( m ) )
           smin = smax
           do lll = 1, m - 1
              ll = m - lll
              abss = abs( d( ll ) )
              abse = abs( e( ll ) )
              if( tol<zero .and. abss<=thresh )d( ll ) = zero
              if( abse<=thresh )go to 80
              smin = min( smin, abss )
              smax = max( smax, abss, abse )
           end do
           ll = 0
           go to 90
           80 continue
           e( ll ) = zero
           ! matrix splits since e(ll) = 0
           if( ll==m-1 ) then
              ! convergence of bottom singular value, return to top of loop
              m = m - 1
              go to 60
           end if
           90 continue
           ll = ll + 1
           ! e(ll) through e(m-1) are nonzero, e(ll-1) is zero
           if( ll==m-1 ) then
              ! 2 by 2 block, handle separately
              call stdlib_dlasv2( d( m-1 ), e( m-1 ), d( m ), sigmn, sigmx, sinr,cosr, sinl, cosl &
                        )
              d( m-1 ) = sigmx
              e( m-1 ) = zero
              d( m ) = sigmn
              ! compute singular vectors, if desired
              if( ncvt>0 )call stdlib_drot( ncvt, vt( m-1, 1 ), ldvt, vt( m, 1 ), ldvt, cosr,sinr &
                        )
              if( nru>0 )call stdlib_drot( nru, u( 1, m-1 ), 1, u( 1, m ), 1, cosl, sinl )
              if( ncc>0 )call stdlib_drot( ncc, c( m-1, 1 ), ldc, c( m, 1 ), ldc, cosl,sinl )
                        
              m = m - 2
              go to 60
           end if
           ! if working on new submatrix, choose shift direction
           ! (from larger end diagonal element towards smaller)
           if( ll>oldm .or. m<oldll ) then
              if( abs( d( ll ) )>=abs( d( m ) ) ) then
                 ! chase bulge from top (big end) to bottom (small end)
                 idir = 1
              else
                 ! chase bulge from bottom (big end) to top (small end)
                 idir = 2
              end if
           end if
           ! apply convergence tests
           if( idir==1 ) then
              ! run convergence test in forward direction
              ! first apply standard test to bottom of matrix
              if( abs( e( m-1 ) )<=abs( tol )*abs( d( m ) ) .or.( tol<zero .and. abs( e( m-1 ) )&
                        <=thresh ) ) then
                 e( m-1 ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion forward
                 mu = abs( d( ll ) )
                 sminl = mu
                 do lll = ll, m - 1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll+1 ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           else
              ! run convergence test in backward direction
              ! first apply standard test to top of matrix
              if( abs( e( ll ) )<=abs( tol )*abs( d( ll ) ) .or.( tol<zero .and. abs( e( ll ) )&
                        <=thresh ) ) then
                 e( ll ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion backward
                 mu = abs( d( m ) )
                 sminl = mu
                 do lll = m - 1, ll, -1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           end if
           oldll = ll
           oldm = m
           ! compute shift.  first, test if shifting would ruin relative
           ! accuracy, and if so set the shift to zero.
           if( tol>=zero .and. n*tol*( sminl / smax )<=max( eps, hndrth*tol ) ) then
              ! use a zero shift to avoid loss of relative accuracy
              shift = zero
           else
              ! compute the shift from 2-by-2 block at end of matrix
              if( idir==1 ) then
                 sll = abs( d( ll ) )
                 call stdlib_dlas2( d( m-1 ), e( m-1 ), d( m ), shift, r )
              else
                 sll = abs( d( m ) )
                 call stdlib_dlas2( d( ll ), e( ll ), d( ll+1 ), shift, r )
              end if
              ! test if shift negligible, and if so set to zero
              if( sll>zero ) then
                 if( ( shift / sll )**2<eps )shift = zero
              end if
           end if
           ! increment iteration count
           iter = iter + m - ll
           ! if shift = 0, do simplified qr iteration
           if( shift==zero ) then
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = ll, m - 1
                    call stdlib_dlartg( d( i )*cs, e( i ), cs, sn, r )
                    if( i>ll )e( i-1 ) = oldsn*r
                    call stdlib_dlartg( oldcs*r, d( i+1 )*sn, oldcs, oldsn, d( i ) )
                    work( i-ll+1 ) = cs
                    work( i-ll+1+nm1 ) = sn
                    work( i-ll+1+nm12 ) = oldcs
                    work( i-ll+1+nm13 ) = oldsn
                 end do
                 h = d( m )*cs
                 d( m ) = h*oldcs
                 e( m-1 ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_dlasr( 'L', 'V', 'F', m-ll+1, ncvt, work( 1 ),work( n ), &
                           vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_dlasr( 'R', 'V', 'F', nru, m-ll+1, work( nm12+1 ),work( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_dlasr( 'L', 'V', 'F', m-ll+1, ncc, work( nm12+1 ),work( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = m, ll + 1, -1
                    call stdlib_dlartg( d( i )*cs, e( i-1 ), cs, sn, r )
                    if( i<m )e( i ) = oldsn*r
                    call stdlib_dlartg( oldcs*r, d( i-1 )*sn, oldcs, oldsn, d( i ) )
                    work( i-ll ) = cs
                    work( i-ll+nm1 ) = -sn
                    work( i-ll+nm12 ) = oldcs
                    work( i-ll+nm13 ) = -oldsn
                 end do
                 h = d( ll )*cs
                 d( ll ) = h*oldcs
                 e( ll ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_dlasr( 'L', 'V', 'B', m-ll+1, ncvt, work( nm12+1 ),work( &
                           nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_dlasr( 'R', 'V', 'B', nru, m-ll+1, work( 1 ),work( n ), u(&
                            1, ll ), ldu )
                 if( ncc>0 )call stdlib_dlasr( 'L', 'V', 'B', m-ll+1, ncc, work( 1 ),work( n ), c(&
                            ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
              end if
           else
              ! use nonzero shift
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( ll ) )-shift )*( sign( one, d( ll ) )+shift / d( ll ) )
                 g = e( ll )
                 do i = ll, m - 1
                    call stdlib_dlartg( f, g, cosr, sinr, r )
                    if( i>ll )e( i-1 ) = r
                    f = cosr*d( i ) + sinr*e( i )
                    e( i ) = cosr*e( i ) - sinr*d( i )
                    g = sinr*d( i+1 )
                    d( i+1 ) = cosr*d( i+1 )
                    call stdlib_dlartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i ) + sinl*d( i+1 )
                    d( i+1 ) = cosl*d( i+1 ) - sinl*e( i )
                    if( i<m-1 ) then
                       g = sinl*e( i+1 )
                       e( i+1 ) = cosl*e( i+1 )
                    end if
                    work( i-ll+1 ) = cosr
                    work( i-ll+1+nm1 ) = sinr
                    work( i-ll+1+nm12 ) = cosl
                    work( i-ll+1+nm13 ) = sinl
                 end do
                 e( m-1 ) = f
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_dlasr( 'L', 'V', 'F', m-ll+1, ncvt, work( 1 ),work( n ), &
                           vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_dlasr( 'R', 'V', 'F', nru, m-ll+1, work( nm12+1 ),work( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_dlasr( 'L', 'V', 'F', m-ll+1, ncc, work( nm12+1 ),work( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( m ) )-shift )*( sign( one, d( m ) )+shift /d( m ) )
                 g = e( m-1 )
                 do i = m, ll + 1, -1
                    call stdlib_dlartg( f, g, cosr, sinr, r )
                    if( i<m )e( i ) = r
                    f = cosr*d( i ) + sinr*e( i-1 )
                    e( i-1 ) = cosr*e( i-1 ) - sinr*d( i )
                    g = sinr*d( i-1 )
                    d( i-1 ) = cosr*d( i-1 )
                    call stdlib_dlartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i-1 ) + sinl*d( i-1 )
                    d( i-1 ) = cosl*d( i-1 ) - sinl*e( i-1 )
                    if( i>ll+1 ) then
                       g = sinl*e( i-2 )
                       e( i-2 ) = cosl*e( i-2 )
                    end if
                    work( i-ll ) = cosr
                    work( i-ll+nm1 ) = -sinr
                    work( i-ll+nm12 ) = cosl
                    work( i-ll+nm13 ) = -sinl
                 end do
                 e( ll ) = f
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
                 ! update singular vectors if desired
                 if( ncvt>0 )call stdlib_dlasr( 'L', 'V', 'B', m-ll+1, ncvt, work( nm12+1 ),work( &
                           nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_dlasr( 'R', 'V', 'B', nru, m-ll+1, work( 1 ),work( n ), u(&
                            1, ll ), ldu )
                 if( ncc>0 )call stdlib_dlasr( 'L', 'V', 'B', m-ll+1, ncc, work( 1 ),work( n ), c(&
                            ll, 1 ), ldc )
              end if
           end if
           ! qr iteration finished, go back and check convergence
           go to 60
           ! all singular values converged, so make them positive
           160 continue
           do i = 1, n
              if( d( i )<zero ) then
                 d( i ) = -d( i )
                 ! change sign of singular vectors, if desired
                 if( ncvt>0 )call stdlib_dscal( ncvt, negone, vt( i, 1 ), ldvt )
              end if
           end do
           ! sort the singular values into decreasing order (insertion sort on
           ! singular values, but only one transposition per singular vector)
           do i = 1, n - 1
              ! scan for smallest d(i)
              isub = 1
              smin = d( 1 )
              do j = 2, n + 1 - i
                 if( d( j )<=smin ) then
                    isub = j
                    smin = d( j )
                 end if
              end do
              if( isub/=n+1-i ) then
                 ! swap singular values and vectors
                 d( isub ) = d( n+1-i )
                 d( n+1-i ) = smin
                 if( ncvt>0 )call stdlib_dswap( ncvt, vt( isub, 1 ), ldvt, vt( n+1-i, 1 ),ldvt )
                           
                 if( nru>0 )call stdlib_dswap( nru, u( 1, isub ), 1, u( 1, n+1-i ), 1 )
                 if( ncc>0 )call stdlib_dswap( ncc, c( isub, 1 ), ldc, c( n+1-i, 1 ), ldc )
                           
              end if
           end do
           go to 220
           ! maximum number of iterations exceeded, failure to converge
           200 continue
           info = 0
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           220 continue
           return
     end subroutine stdlib_dbdsqr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$bdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, work, &
     !! DBDSQR: computes the singular values and, optionally, the right and/or
     !! left singular vectors from the singular value decomposition (SVD) of
     !! a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
     !! zero-shift QR algorithm.  The SVD of B has the form
     !! B = Q * S * P**T
     !! where S is the diagonal matrix of singular values, Q is an orthogonal
     !! matrix of left singular vectors, and P is an orthogonal matrix of
     !! right singular vectors.  If left singular vectors are requested, this
     !! subroutine actually returns U*Q instead of Q, and, if right singular
     !! vectors are requested, this subroutine returns P**T*VT instead of
     !! P**T, for given real input matrices U and VT.  When U and VT are the
     !! orthogonal matrices that reduce a general matrix A to bidiagonal
     !! form:  A = U*B*VT, as computed by DGEBRD, then
     !! A = (U*Q) * S * (P**T*VT)
     !! is the SVD of A.  Optionally, the subroutine may also compute Q**T*C
     !! for a given real input matrix C.
     !! See "Computing  Small Singular Values of Bidiagonal Matrices With
     !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
     !! LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
     !! no. 5, pp. 873-912, Sept 1990) and
     !! "Accurate singular values and differential qd algorithms," by
     !! B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
     !! Department, University of California at Berkeley, July 1992
     !! for a detailed description of the algorithm.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           ! Array Arguments 
           real(${rk}$), intent(inout) :: c(ldc,*), d(*), e(*), u(ldu,*), vt(ldvt,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: hndrth = 0.01_${rk}$
           real(${rk}$), parameter :: hndrd = 100.0_${rk}$
           real(${rk}$), parameter :: meigth = -0.125_${rk}$
           integer(ilp), parameter :: maxitr = 6
           
           
           
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: lower, rotate
           integer(ilp) :: i, idir, isub, iter, iterdivn, j, ll, lll, m, maxitdivn, nm1, nm12, &
                     nm13, oldll, oldm
           real(${rk}$) :: abse, abss, cosl, cosr, cs, eps, f, g, h, mu, oldcs, oldsn, r, shift, &
           sigmn, sigmx, sinl, sinr, sll, smax, smin, sminl, sminoa, sn, thresh, tol, tolmul, &
                     unfl
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.lower ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ncvt<0 ) then
              info = -3
           else if( nru<0 ) then
              info = -4
           else if( ncc<0 ) then
              info = -5
           else if( ( ncvt==0 .and. ldvt<1 ) .or.( ncvt>0 .and. ldvt<max( 1, n ) ) ) then
              info = -9
           else if( ldu<max( 1, nru ) ) then
              info = -11
           else if( ( ncc==0 .and. ldc<1 ) .or.( ncc>0 .and. ldc<max( 1, n ) ) ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DBDSQR', -info )
              return
           end if
           if( n==0 )return
           if( n==1 )go to 160
           ! rotate is true if any singular vectors desired, false otherwise
           rotate = ( ncvt>0 ) .or. ( nru>0 ) .or. ( ncc>0 )
           ! if no singular vectors desired, use qd algorithm
           if( .not.rotate ) then
              call stdlib_${ri}$lasq1( n, d, e, work, info )
           ! if info equals 2, dqds didn't finish, try to finish
              if( info /= 2 ) return
              info = 0
           end if
           nm1 = n - 1
           nm12 = nm1 + nm1
           nm13 = nm12 + nm1
           idir = 0
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           unfl = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           if( lower ) then
              do i = 1, n - 1
                 call stdlib_${ri}$lartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 work( i ) = cs
                 work( nm1+i ) = sn
              end do
              ! update singular vectors if desired
              if( nru>0 )call stdlib_${ri}$lasr( 'R', 'V', 'F', nru, n, work( 1 ), work( n ), u,ldu )
                        
              if( ncc>0 )call stdlib_${ri}$lasr( 'L', 'V', 'F', n, ncc, work( 1 ), work( n ), c,ldc )
                        
           end if
           ! compute singular values to relative accuracy tol
           ! (by setting tol to be negative, algorithm will compute
           ! singular values to absolute accuracy abs(tol)*norm(input matrix))
           tolmul = max( ten, min( hndrd, eps**meigth ) )
           tol = tolmul*eps
           ! compute approximate maximum, minimum singular values
           smax = zero
           do i = 1, n
              smax = max( smax, abs( d( i ) ) )
           end do
           do i = 1, n - 1
              smax = max( smax, abs( e( i ) ) )
           end do
           sminl = zero
           if( tol>=zero ) then
              ! relative accuracy desired
              sminoa = abs( d( 1 ) )
              if( sminoa==zero )go to 50
              mu = sminoa
              do i = 2, n
                 mu = abs( d( i ) )*( mu / ( mu+abs( e( i-1 ) ) ) )
                 sminoa = min( sminoa, mu )
                 if( sminoa==zero )go to 50
              end do
              50 continue
              sminoa = sminoa / sqrt( real( n,KIND=${rk}$) )
              thresh = max( tol*sminoa, maxitr*(n*(n*unfl)) )
           else
              ! absolute accuracy desired
              thresh = max( abs( tol )*smax, maxitr*(n*(n*unfl)) )
           end if
           ! prepare for main iteration loop for the singular values
           ! (maxit is the maximum number of passes through the inner
           ! loop permitted before nonconvergence signalled.)
           maxitdivn = maxitr*n
           iterdivn = 0
           iter = -1
           oldll = -1
           oldm = -1
           ! m points to last element of unconverged part of matrix
           m = n
           ! begin main iteration loop
           60 continue
           ! check for convergence or exceeding iteration count
           if( m<=1 )go to 160
           if( iter>=n ) then
              iter = iter - n
              iterdivn = iterdivn + 1
              if( iterdivn>=maxitdivn )go to 200
           end if
           ! find diagonal block of matrix to work on
           if( tol<zero .and. abs( d( m ) )<=thresh )d( m ) = zero
           smax = abs( d( m ) )
           smin = smax
           do lll = 1, m - 1
              ll = m - lll
              abss = abs( d( ll ) )
              abse = abs( e( ll ) )
              if( tol<zero .and. abss<=thresh )d( ll ) = zero
              if( abse<=thresh )go to 80
              smin = min( smin, abss )
              smax = max( smax, abss, abse )
           end do
           ll = 0
           go to 90
           80 continue
           e( ll ) = zero
           ! matrix splits since e(ll) = 0
           if( ll==m-1 ) then
              ! convergence of bottom singular value, return to top of loop
              m = m - 1
              go to 60
           end if
           90 continue
           ll = ll + 1
           ! e(ll) through e(m-1) are nonzero, e(ll-1) is zero
           if( ll==m-1 ) then
              ! 2 by 2 block, handle separately
              call stdlib_${ri}$lasv2( d( m-1 ), e( m-1 ), d( m ), sigmn, sigmx, sinr,cosr, sinl, cosl &
                        )
              d( m-1 ) = sigmx
              e( m-1 ) = zero
              d( m ) = sigmn
              ! compute singular vectors, if desired
              if( ncvt>0 )call stdlib_${ri}$rot( ncvt, vt( m-1, 1 ), ldvt, vt( m, 1 ), ldvt, cosr,sinr &
                        )
              if( nru>0 )call stdlib_${ri}$rot( nru, u( 1, m-1 ), 1, u( 1, m ), 1, cosl, sinl )
              if( ncc>0 )call stdlib_${ri}$rot( ncc, c( m-1, 1 ), ldc, c( m, 1 ), ldc, cosl,sinl )
                        
              m = m - 2
              go to 60
           end if
           ! if working on new submatrix, choose shift direction
           ! (from larger end diagonal element towards smaller)
           if( ll>oldm .or. m<oldll ) then
              if( abs( d( ll ) )>=abs( d( m ) ) ) then
                 ! chase bulge from top (big end) to bottom (small end)
                 idir = 1
              else
                 ! chase bulge from bottom (big end) to top (small end)
                 idir = 2
              end if
           end if
           ! apply convergence tests
           if( idir==1 ) then
              ! run convergence test in forward direction
              ! first apply standard test to bottom of matrix
              if( abs( e( m-1 ) )<=abs( tol )*abs( d( m ) ) .or.( tol<zero .and. abs( e( m-1 ) )&
                        <=thresh ) ) then
                 e( m-1 ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion forward
                 mu = abs( d( ll ) )
                 sminl = mu
                 do lll = ll, m - 1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll+1 ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           else
              ! run convergence test in backward direction
              ! first apply standard test to top of matrix
              if( abs( e( ll ) )<=abs( tol )*abs( d( ll ) ) .or.( tol<zero .and. abs( e( ll ) )&
                        <=thresh ) ) then
                 e( ll ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion backward
                 mu = abs( d( m ) )
                 sminl = mu
                 do lll = m - 1, ll, -1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           end if
           oldll = ll
           oldm = m
           ! compute shift.  first, test if shifting would ruin relative
           ! accuracy, and if so set the shift to zero.
           if( tol>=zero .and. n*tol*( sminl / smax )<=max( eps, hndrth*tol ) ) then
              ! use a zero shift to avoid loss of relative accuracy
              shift = zero
           else
              ! compute the shift from 2-by-2 block at end of matrix
              if( idir==1 ) then
                 sll = abs( d( ll ) )
                 call stdlib_${ri}$las2( d( m-1 ), e( m-1 ), d( m ), shift, r )
              else
                 sll = abs( d( m ) )
                 call stdlib_${ri}$las2( d( ll ), e( ll ), d( ll+1 ), shift, r )
              end if
              ! test if shift negligible, and if so set to zero
              if( sll>zero ) then
                 if( ( shift / sll )**2<eps )shift = zero
              end if
           end if
           ! increment iteration count
           iter = iter + m - ll
           ! if shift = 0, do simplified qr iteration
           if( shift==zero ) then
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = ll, m - 1
                    call stdlib_${ri}$lartg( d( i )*cs, e( i ), cs, sn, r )
                    if( i>ll )e( i-1 ) = oldsn*r
                    call stdlib_${ri}$lartg( oldcs*r, d( i+1 )*sn, oldcs, oldsn, d( i ) )
                    work( i-ll+1 ) = cs
                    work( i-ll+1+nm1 ) = sn
                    work( i-ll+1+nm12 ) = oldcs
                    work( i-ll+1+nm13 ) = oldsn
                 end do
                 h = d( m )*cs
                 d( m ) = h*oldcs
                 e( m-1 ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_${ri}$lasr( 'L', 'V', 'F', m-ll+1, ncvt, work( 1 ),work( n ), &
                           vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ri}$lasr( 'R', 'V', 'F', nru, m-ll+1, work( nm12+1 ),work( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ri}$lasr( 'L', 'V', 'F', m-ll+1, ncc, work( nm12+1 ),work( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = m, ll + 1, -1
                    call stdlib_${ri}$lartg( d( i )*cs, e( i-1 ), cs, sn, r )
                    if( i<m )e( i ) = oldsn*r
                    call stdlib_${ri}$lartg( oldcs*r, d( i-1 )*sn, oldcs, oldsn, d( i ) )
                    work( i-ll ) = cs
                    work( i-ll+nm1 ) = -sn
                    work( i-ll+nm12 ) = oldcs
                    work( i-ll+nm13 ) = -oldsn
                 end do
                 h = d( ll )*cs
                 d( ll ) = h*oldcs
                 e( ll ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_${ri}$lasr( 'L', 'V', 'B', m-ll+1, ncvt, work( nm12+1 ),work( &
                           nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ri}$lasr( 'R', 'V', 'B', nru, m-ll+1, work( 1 ),work( n ), u(&
                            1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ri}$lasr( 'L', 'V', 'B', m-ll+1, ncc, work( 1 ),work( n ), c(&
                            ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
              end if
           else
              ! use nonzero shift
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( ll ) )-shift )*( sign( one, d( ll ) )+shift / d( ll ) )
                 g = e( ll )
                 do i = ll, m - 1
                    call stdlib_${ri}$lartg( f, g, cosr, sinr, r )
                    if( i>ll )e( i-1 ) = r
                    f = cosr*d( i ) + sinr*e( i )
                    e( i ) = cosr*e( i ) - sinr*d( i )
                    g = sinr*d( i+1 )
                    d( i+1 ) = cosr*d( i+1 )
                    call stdlib_${ri}$lartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i ) + sinl*d( i+1 )
                    d( i+1 ) = cosl*d( i+1 ) - sinl*e( i )
                    if( i<m-1 ) then
                       g = sinl*e( i+1 )
                       e( i+1 ) = cosl*e( i+1 )
                    end if
                    work( i-ll+1 ) = cosr
                    work( i-ll+1+nm1 ) = sinr
                    work( i-ll+1+nm12 ) = cosl
                    work( i-ll+1+nm13 ) = sinl
                 end do
                 e( m-1 ) = f
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_${ri}$lasr( 'L', 'V', 'F', m-ll+1, ncvt, work( 1 ),work( n ), &
                           vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ri}$lasr( 'R', 'V', 'F', nru, m-ll+1, work( nm12+1 ),work( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ri}$lasr( 'L', 'V', 'F', m-ll+1, ncc, work( nm12+1 ),work( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( m ) )-shift )*( sign( one, d( m ) )+shift /d( m ) )
                 g = e( m-1 )
                 do i = m, ll + 1, -1
                    call stdlib_${ri}$lartg( f, g, cosr, sinr, r )
                    if( i<m )e( i ) = r
                    f = cosr*d( i ) + sinr*e( i-1 )
                    e( i-1 ) = cosr*e( i-1 ) - sinr*d( i )
                    g = sinr*d( i-1 )
                    d( i-1 ) = cosr*d( i-1 )
                    call stdlib_${ri}$lartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i-1 ) + sinl*d( i-1 )
                    d( i-1 ) = cosl*d( i-1 ) - sinl*e( i-1 )
                    if( i>ll+1 ) then
                       g = sinl*e( i-2 )
                       e( i-2 ) = cosl*e( i-2 )
                    end if
                    work( i-ll ) = cosr
                    work( i-ll+nm1 ) = -sinr
                    work( i-ll+nm12 ) = cosl
                    work( i-ll+nm13 ) = -sinl
                 end do
                 e( ll ) = f
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
                 ! update singular vectors if desired
                 if( ncvt>0 )call stdlib_${ri}$lasr( 'L', 'V', 'B', m-ll+1, ncvt, work( nm12+1 ),work( &
                           nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ri}$lasr( 'R', 'V', 'B', nru, m-ll+1, work( 1 ),work( n ), u(&
                            1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ri}$lasr( 'L', 'V', 'B', m-ll+1, ncc, work( 1 ),work( n ), c(&
                            ll, 1 ), ldc )
              end if
           end if
           ! qr iteration finished, go back and check convergence
           go to 60
           ! all singular values converged, so make them positive
           160 continue
           do i = 1, n
              if( d( i )<zero ) then
                 d( i ) = -d( i )
                 ! change sign of singular vectors, if desired
                 if( ncvt>0 )call stdlib_${ri}$scal( ncvt, negone, vt( i, 1 ), ldvt )
              end if
           end do
           ! sort the singular values into decreasing order (insertion sort on
           ! singular values, but only one transposition per singular vector)
           do i = 1, n - 1
              ! scan for smallest d(i)
              isub = 1
              smin = d( 1 )
              do j = 2, n + 1 - i
                 if( d( j )<=smin ) then
                    isub = j
                    smin = d( j )
                 end if
              end do
              if( isub/=n+1-i ) then
                 ! swap singular values and vectors
                 d( isub ) = d( n+1-i )
                 d( n+1-i ) = smin
                 if( ncvt>0 )call stdlib_${ri}$swap( ncvt, vt( isub, 1 ), ldvt, vt( n+1-i, 1 ),ldvt )
                           
                 if( nru>0 )call stdlib_${ri}$swap( nru, u( 1, isub ), 1, u( 1, n+1-i ), 1 )
                 if( ncc>0 )call stdlib_${ri}$swap( ncc, c( isub, 1 ), ldc, c( n+1-i, 1 ), ldc )
                           
              end if
           end do
           go to 220
           ! maximum number of iterations exceeded, failure to converge
           200 continue
           info = 0
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           220 continue
           return
     end subroutine stdlib_${ri}$bdsqr

#:endif
#:endfor

     module pure subroutine stdlib_cbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, rwork,&
     !! CBDSQR computes the singular values and, optionally, the right and/or
     !! left singular vectors from the singular value decomposition (SVD) of
     !! a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
     !! zero-shift QR algorithm.  The SVD of B has the form
     !! B = Q * S * P**H
     !! where S is the diagonal matrix of singular values, Q is an orthogonal
     !! matrix of left singular vectors, and P is an orthogonal matrix of
     !! right singular vectors.  If left singular vectors are requested, this
     !! subroutine actually returns U*Q instead of Q, and, if right singular
     !! vectors are requested, this subroutine returns P**H*VT instead of
     !! P**H, for given complex input matrices U and VT.  When U and VT are
     !! the unitary matrices that reduce a general matrix A to bidiagonal
     !! form: A = U*B*VT, as computed by CGEBRD, then
     !! A = (U*Q) * S * (P**H*VT)
     !! is the SVD of A.  Optionally, the subroutine may also compute Q**H*C
     !! for a given complex input matrix C.
     !! See "Computing  Small Singular Values of Bidiagonal Matrices With
     !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
     !! LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
     !! no. 5, pp. 873-912, Sept 1990) and
     !! "Accurate singular values and differential qd algorithms," by
     !! B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
     !! Department, University of California at Berkeley, July 1992
     !! for a detailed description of the algorithm.
                info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           ! Array Arguments 
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: c(ldc,*), u(ldu,*), vt(ldvt,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: hndrth = 0.01_sp
           real(sp), parameter :: hndrd = 100.0_sp
           real(sp), parameter :: meigth = -0.125_sp
           integer(ilp), parameter :: maxitr = 6
           
           
           
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: lower, rotate
           integer(ilp) :: i, idir, isub, iter, j, ll, lll, m, maxit, nm1, nm12, nm13, oldll, &
                     oldm
           real(sp) :: abse, abss, cosl, cosr, cs, eps, f, g, h, mu, oldcs, oldsn, r, shift, &
           sigmn, sigmx, sinl, sinr, sll, smax, smin, sminl, sminoa, sn, thresh, tol, tolmul, &
                     unfl
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.lower ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ncvt<0 ) then
              info = -3
           else if( nru<0 ) then
              info = -4
           else if( ncc<0 ) then
              info = -5
           else if( ( ncvt==0 .and. ldvt<1 ) .or.( ncvt>0 .and. ldvt<max( 1, n ) ) ) then
              info = -9
           else if( ldu<max( 1, nru ) ) then
              info = -11
           else if( ( ncc==0 .and. ldc<1 ) .or.( ncc>0 .and. ldc<max( 1, n ) ) ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CBDSQR', -info )
              return
           end if
           if( n==0 )return
           if( n==1 )go to 160
           ! rotate is true if any singular vectors desired, false otherwise
           rotate = ( ncvt>0 ) .or. ( nru>0 ) .or. ( ncc>0 )
           ! if no singular vectors desired, use qd algorithm
           if( .not.rotate ) then
              call stdlib_slasq1( n, d, e, rwork, info )
           ! if info equals 2, dqds didn't finish, try to finish
              if( info /= 2 ) return
              info = 0
           end if
           nm1 = n - 1
           nm12 = nm1 + nm1
           nm13 = nm12 + nm1
           idir = 0
           ! get machine constants
           eps = stdlib_slamch( 'EPSILON' )
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           if( lower ) then
              do i = 1, n - 1
                 call stdlib_slartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 rwork( i ) = cs
                 rwork( nm1+i ) = sn
              end do
              ! update singular vectors if desired
              if( nru>0 )call stdlib_clasr( 'R', 'V', 'F', nru, n, rwork( 1 ), rwork( n ),u, ldu )
                        
              if( ncc>0 )call stdlib_clasr( 'L', 'V', 'F', n, ncc, rwork( 1 ), rwork( n ),c, ldc )
                        
           end if
           ! compute singular values to relative accuracy tol
           ! (by setting tol to be negative, algorithm will compute
           ! singular values to absolute accuracy abs(tol)*norm(input matrix))
           tolmul = max( ten, min( hndrd, eps**meigth ) )
           tol = tolmul*eps
           ! compute approximate maximum, minimum singular values
           smax = zero
           do i = 1, n
              smax = max( smax, abs( d( i ) ) )
           end do
           do i = 1, n - 1
              smax = max( smax, abs( e( i ) ) )
           end do
           sminl = zero
           if( tol>=zero ) then
              ! relative accuracy desired
              sminoa = abs( d( 1 ) )
              if( sminoa==zero )go to 50
              mu = sminoa
              do i = 2, n
                 mu = abs( d( i ) )*( mu / ( mu+abs( e( i-1 ) ) ) )
                 sminoa = min( sminoa, mu )
                 if( sminoa==zero )go to 50
              end do
              50 continue
              sminoa = sminoa / sqrt( real( n,KIND=sp) )
              thresh = max( tol*sminoa, maxitr*n*n*unfl )
           else
              ! absolute accuracy desired
              thresh = max( abs( tol )*smax, maxitr*n*n*unfl )
           end if
           ! prepare for main iteration loop for the singular values
           ! (maxit is the maximum number of passes through the inner
           ! loop permitted before nonconvergence signalled.)
           maxit = maxitr*n*n
           iter = 0
           oldll = -1
           oldm = -1
           ! m points to last element of unconverged part of matrix
           m = n
           ! begin main iteration loop
           60 continue
           ! check for convergence or exceeding iteration count
           if( m<=1 )go to 160
           if( iter>maxit )go to 200
           ! find diagonal block of matrix to work on
           if( tol<zero .and. abs( d( m ) )<=thresh )d( m ) = zero
           smax = abs( d( m ) )
           smin = smax
           do lll = 1, m - 1
              ll = m - lll
              abss = abs( d( ll ) )
              abse = abs( e( ll ) )
              if( tol<zero .and. abss<=thresh )d( ll ) = zero
              if( abse<=thresh )go to 80
              smin = min( smin, abss )
              smax = max( smax, abss, abse )
           end do
           ll = 0
           go to 90
           80 continue
           e( ll ) = zero
           ! matrix splits since e(ll) = 0
           if( ll==m-1 ) then
              ! convergence of bottom singular value, return to top of loop
              m = m - 1
              go to 60
           end if
           90 continue
           ll = ll + 1
           ! e(ll) through e(m-1) are nonzero, e(ll-1) is zero
           if( ll==m-1 ) then
              ! 2 by 2 block, handle separately
              call stdlib_slasv2( d( m-1 ), e( m-1 ), d( m ), sigmn, sigmx, sinr,cosr, sinl, cosl &
                        )
              d( m-1 ) = sigmx
              e( m-1 ) = zero
              d( m ) = sigmn
              ! compute singular vectors, if desired
              if( ncvt>0 )call stdlib_csrot( ncvt, vt( m-1, 1 ), ldvt, vt( m, 1 ), ldvt,cosr, &
                        sinr )
              if( nru>0 )call stdlib_csrot( nru, u( 1, m-1 ), 1, u( 1, m ), 1, cosl, sinl )
                        
              if( ncc>0 )call stdlib_csrot( ncc, c( m-1, 1 ), ldc, c( m, 1 ), ldc, cosl,sinl )
                        
              m = m - 2
              go to 60
           end if
           ! if working on new submatrix, choose shift direction
           ! (from larger end diagonal element towards smaller)
           if( ll>oldm .or. m<oldll ) then
              if( abs( d( ll ) )>=abs( d( m ) ) ) then
                 ! chase bulge from top (big end) to bottom (small end)
                 idir = 1
              else
                 ! chase bulge from bottom (big end) to top (small end)
                 idir = 2
              end if
           end if
           ! apply convergence tests
           if( idir==1 ) then
              ! run convergence test in forward direction
              ! first apply standard test to bottom of matrix
              if( abs( e( m-1 ) )<=abs( tol )*abs( d( m ) ) .or.( tol<zero .and. abs( e( m-1 ) )&
                        <=thresh ) ) then
                 e( m-1 ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion forward
                 mu = abs( d( ll ) )
                 sminl = mu
                 do lll = ll, m - 1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll+1 ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           else
              ! run convergence test in backward direction
              ! first apply standard test to top of matrix
              if( abs( e( ll ) )<=abs( tol )*abs( d( ll ) ) .or.( tol<zero .and. abs( e( ll ) )&
                        <=thresh ) ) then
                 e( ll ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion backward
                 mu = abs( d( m ) )
                 sminl = mu
                 do lll = m - 1, ll, -1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           end if
           oldll = ll
           oldm = m
           ! compute shift.  first, test if shifting would ruin relative
           ! accuracy, and if so set the shift to zero.
           if( tol>=zero .and. n*tol*( sminl / smax )<=max( eps, hndrth*tol ) ) then
              ! use a zero shift to avoid loss of relative accuracy
              shift = zero
           else
              ! compute the shift from 2-by-2 block at end of matrix
              if( idir==1 ) then
                 sll = abs( d( ll ) )
                 call stdlib_slas2( d( m-1 ), e( m-1 ), d( m ), shift, r )
              else
                 sll = abs( d( m ) )
                 call stdlib_slas2( d( ll ), e( ll ), d( ll+1 ), shift, r )
              end if
              ! test if shift negligible, and if so set to zero
              if( sll>zero ) then
                 if( ( shift / sll )**2<eps )shift = zero
              end if
           end if
           ! increment iteration count
           iter = iter + m - ll
           ! if shift = 0, do simplified qr iteration
           if( shift==zero ) then
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = ll, m - 1
                    call stdlib_slartg( d( i )*cs, e( i ), cs, sn, r )
                    if( i>ll )e( i-1 ) = oldsn*r
                    call stdlib_slartg( oldcs*r, d( i+1 )*sn, oldcs, oldsn, d( i ) )
                    rwork( i-ll+1 ) = cs
                    rwork( i-ll+1+nm1 ) = sn
                    rwork( i-ll+1+nm12 ) = oldcs
                    rwork( i-ll+1+nm13 ) = oldsn
                 end do
                 h = d( m )*cs
                 d( m ) = h*oldcs
                 e( m-1 ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_clasr( 'L', 'V', 'F', m-ll+1, ncvt, rwork( 1 ),rwork( n )&
                           , vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_clasr( 'R', 'V', 'F', nru, m-ll+1, rwork( nm12+1 ),rwork( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_clasr( 'L', 'V', 'F', m-ll+1, ncc, rwork( nm12+1 ),rwork( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = m, ll + 1, -1
                    call stdlib_slartg( d( i )*cs, e( i-1 ), cs, sn, r )
                    if( i<m )e( i ) = oldsn*r
                    call stdlib_slartg( oldcs*r, d( i-1 )*sn, oldcs, oldsn, d( i ) )
                    rwork( i-ll ) = cs
                    rwork( i-ll+nm1 ) = -sn
                    rwork( i-ll+nm12 ) = oldcs
                    rwork( i-ll+nm13 ) = -oldsn
                 end do
                 h = d( ll )*cs
                 d( ll ) = h*oldcs
                 e( ll ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_clasr( 'L', 'V', 'B', m-ll+1, ncvt, rwork( nm12+1 ),&
                           rwork( nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_clasr( 'R', 'V', 'B', nru, m-ll+1, rwork( 1 ),rwork( n ), &
                           u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_clasr( 'L', 'V', 'B', m-ll+1, ncc, rwork( 1 ),rwork( n ), &
                           c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
              end if
           else
              ! use nonzero shift
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( ll ) )-shift )*( sign( one, d( ll ) )+shift / d( ll ) )
                 g = e( ll )
                 do i = ll, m - 1
                    call stdlib_slartg( f, g, cosr, sinr, r )
                    if( i>ll )e( i-1 ) = r
                    f = cosr*d( i ) + sinr*e( i )
                    e( i ) = cosr*e( i ) - sinr*d( i )
                    g = sinr*d( i+1 )
                    d( i+1 ) = cosr*d( i+1 )
                    call stdlib_slartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i ) + sinl*d( i+1 )
                    d( i+1 ) = cosl*d( i+1 ) - sinl*e( i )
                    if( i<m-1 ) then
                       g = sinl*e( i+1 )
                       e( i+1 ) = cosl*e( i+1 )
                    end if
                    rwork( i-ll+1 ) = cosr
                    rwork( i-ll+1+nm1 ) = sinr
                    rwork( i-ll+1+nm12 ) = cosl
                    rwork( i-ll+1+nm13 ) = sinl
                 end do
                 e( m-1 ) = f
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_clasr( 'L', 'V', 'F', m-ll+1, ncvt, rwork( 1 ),rwork( n )&
                           , vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_clasr( 'R', 'V', 'F', nru, m-ll+1, rwork( nm12+1 ),rwork( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_clasr( 'L', 'V', 'F', m-ll+1, ncc, rwork( nm12+1 ),rwork( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( m ) )-shift )*( sign( one, d( m ) )+shift /d( m ) )
                 g = e( m-1 )
                 do i = m, ll + 1, -1
                    call stdlib_slartg( f, g, cosr, sinr, r )
                    if( i<m )e( i ) = r
                    f = cosr*d( i ) + sinr*e( i-1 )
                    e( i-1 ) = cosr*e( i-1 ) - sinr*d( i )
                    g = sinr*d( i-1 )
                    d( i-1 ) = cosr*d( i-1 )
                    call stdlib_slartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i-1 ) + sinl*d( i-1 )
                    d( i-1 ) = cosl*d( i-1 ) - sinl*e( i-1 )
                    if( i>ll+1 ) then
                       g = sinl*e( i-2 )
                       e( i-2 ) = cosl*e( i-2 )
                    end if
                    rwork( i-ll ) = cosr
                    rwork( i-ll+nm1 ) = -sinr
                    rwork( i-ll+nm12 ) = cosl
                    rwork( i-ll+nm13 ) = -sinl
                 end do
                 e( ll ) = f
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
                 ! update singular vectors if desired
                 if( ncvt>0 )call stdlib_clasr( 'L', 'V', 'B', m-ll+1, ncvt, rwork( nm12+1 ),&
                           rwork( nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_clasr( 'R', 'V', 'B', nru, m-ll+1, rwork( 1 ),rwork( n ), &
                           u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_clasr( 'L', 'V', 'B', m-ll+1, ncc, rwork( 1 ),rwork( n ), &
                           c( ll, 1 ), ldc )
              end if
           end if
           ! qr iteration finished, go back and check convergence
           go to 60
           ! all singular values converged, so make them positive
           160 continue
           do i = 1, n
              if( d( i )<zero ) then
                 d( i ) = -d( i )
                 ! change sign of singular vectors, if desired
                 if( ncvt>0 )call stdlib_csscal( ncvt, negone, vt( i, 1 ), ldvt )
              end if
           end do
           ! sort the singular values into decreasing order (insertion sort on
           ! singular values, but only one transposition per singular vector)
           do i = 1, n - 1
              ! scan for smallest d(i)
              isub = 1
              smin = d( 1 )
              do j = 2, n + 1 - i
                 if( d( j )<=smin ) then
                    isub = j
                    smin = d( j )
                 end if
              end do
              if( isub/=n+1-i ) then
                 ! swap singular values and vectors
                 d( isub ) = d( n+1-i )
                 d( n+1-i ) = smin
                 if( ncvt>0 )call stdlib_cswap( ncvt, vt( isub, 1 ), ldvt, vt( n+1-i, 1 ),ldvt )
                           
                 if( nru>0 )call stdlib_cswap( nru, u( 1, isub ), 1, u( 1, n+1-i ), 1 )
                 if( ncc>0 )call stdlib_cswap( ncc, c( isub, 1 ), ldc, c( n+1-i, 1 ), ldc )
                           
              end if
           end do
           go to 220
           ! maximum number of iterations exceeded, failure to converge
           200 continue
           info = 0
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           220 continue
           return
     end subroutine stdlib_cbdsqr

     module pure subroutine stdlib_zbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, rwork,&
     !! ZBDSQR computes the singular values and, optionally, the right and/or
     !! left singular vectors from the singular value decomposition (SVD) of
     !! a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
     !! zero-shift QR algorithm.  The SVD of B has the form
     !! B = Q * S * P**H
     !! where S is the diagonal matrix of singular values, Q is an orthogonal
     !! matrix of left singular vectors, and P is an orthogonal matrix of
     !! right singular vectors.  If left singular vectors are requested, this
     !! subroutine actually returns U*Q instead of Q, and, if right singular
     !! vectors are requested, this subroutine returns P**H*VT instead of
     !! P**H, for given complex input matrices U and VT.  When U and VT are
     !! the unitary matrices that reduce a general matrix A to bidiagonal
     !! form: A = U*B*VT, as computed by ZGEBRD, then
     !! A = (U*Q) * S * (P**H*VT)
     !! is the SVD of A.  Optionally, the subroutine may also compute Q**H*C
     !! for a given complex input matrix C.
     !! See "Computing  Small Singular Values of Bidiagonal Matrices With
     !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
     !! LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
     !! no. 5, pp. 873-912, Sept 1990) and
     !! "Accurate singular values and differential qd algorithms," by
     !! B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
     !! Department, University of California at Berkeley, July 1992
     !! for a detailed description of the algorithm.
                info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           ! Array Arguments 
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: c(ldc,*), u(ldu,*), vt(ldvt,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: hndrth = 0.01_dp
           real(dp), parameter :: hndrd = 100.0_dp
           real(dp), parameter :: meigth = -0.125_dp
           integer(ilp), parameter :: maxitr = 6
           
           
           
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: lower, rotate
           integer(ilp) :: i, idir, isub, iter, j, ll, lll, m, maxit, nm1, nm12, nm13, oldll, &
                     oldm
           real(dp) :: abse, abss, cosl, cosr, cs, eps, f, g, h, mu, oldcs, oldsn, r, shift, &
           sigmn, sigmx, sinl, sinr, sll, smax, smin, sminl, sminoa, sn, thresh, tol, tolmul, &
                     unfl
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.lower ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ncvt<0 ) then
              info = -3
           else if( nru<0 ) then
              info = -4
           else if( ncc<0 ) then
              info = -5
           else if( ( ncvt==0 .and. ldvt<1 ) .or.( ncvt>0 .and. ldvt<max( 1, n ) ) ) then
              info = -9
           else if( ldu<max( 1, nru ) ) then
              info = -11
           else if( ( ncc==0 .and. ldc<1 ) .or.( ncc>0 .and. ldc<max( 1, n ) ) ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZBDSQR', -info )
              return
           end if
           if( n==0 )return
           if( n==1 )go to 160
           ! rotate is true if any singular vectors desired, false otherwise
           rotate = ( ncvt>0 ) .or. ( nru>0 ) .or. ( ncc>0 )
           ! if no singular vectors desired, use qd algorithm
           if( .not.rotate ) then
              call stdlib_dlasq1( n, d, e, rwork, info )
           ! if info equals 2, dqds didn't finish, try to finish
              if( info /= 2 ) return
              info = 0
           end if
           nm1 = n - 1
           nm12 = nm1 + nm1
           nm13 = nm12 + nm1
           idir = 0
           ! get machine constants
           eps = stdlib_dlamch( 'EPSILON' )
           unfl = stdlib_dlamch( 'SAFE MINIMUM' )
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           if( lower ) then
              do i = 1, n - 1
                 call stdlib_dlartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 rwork( i ) = cs
                 rwork( nm1+i ) = sn
              end do
              ! update singular vectors if desired
              if( nru>0 )call stdlib_zlasr( 'R', 'V', 'F', nru, n, rwork( 1 ), rwork( n ),u, ldu )
                        
              if( ncc>0 )call stdlib_zlasr( 'L', 'V', 'F', n, ncc, rwork( 1 ), rwork( n ),c, ldc )
                        
           end if
           ! compute singular values to relative accuracy tol
           ! (by setting tol to be negative, algorithm will compute
           ! singular values to absolute accuracy abs(tol)*norm(input matrix))
           tolmul = max( ten, min( hndrd, eps**meigth ) )
           tol = tolmul*eps
           ! compute approximate maximum, minimum singular values
           smax = zero
           do i = 1, n
              smax = max( smax, abs( d( i ) ) )
           end do
           do i = 1, n - 1
              smax = max( smax, abs( e( i ) ) )
           end do
           sminl = zero
           if( tol>=zero ) then
              ! relative accuracy desired
              sminoa = abs( d( 1 ) )
              if( sminoa==zero )go to 50
              mu = sminoa
              do i = 2, n
                 mu = abs( d( i ) )*( mu / ( mu+abs( e( i-1 ) ) ) )
                 sminoa = min( sminoa, mu )
                 if( sminoa==zero )go to 50
              end do
              50 continue
              sminoa = sminoa / sqrt( real( n,KIND=dp) )
              thresh = max( tol*sminoa, maxitr*n*n*unfl )
           else
              ! absolute accuracy desired
              thresh = max( abs( tol )*smax, maxitr*n*n*unfl )
           end if
           ! prepare for main iteration loop for the singular values
           ! (maxit is the maximum number of passes through the inner
           ! loop permitted before nonconvergence signalled.)
           maxit = maxitr*n*n
           iter = 0
           oldll = -1
           oldm = -1
           ! m points to last element of unconverged part of matrix
           m = n
           ! begin main iteration loop
           60 continue
           ! check for convergence or exceeding iteration count
           if( m<=1 )go to 160
           if( iter>maxit )go to 200
           ! find diagonal block of matrix to work on
           if( tol<zero .and. abs( d( m ) )<=thresh )d( m ) = zero
           smax = abs( d( m ) )
           smin = smax
           do lll = 1, m - 1
              ll = m - lll
              abss = abs( d( ll ) )
              abse = abs( e( ll ) )
              if( tol<zero .and. abss<=thresh )d( ll ) = zero
              if( abse<=thresh )go to 80
              smin = min( smin, abss )
              smax = max( smax, abss, abse )
           end do
           ll = 0
           go to 90
           80 continue
           e( ll ) = zero
           ! matrix splits since e(ll) = 0
           if( ll==m-1 ) then
              ! convergence of bottom singular value, return to top of loop
              m = m - 1
              go to 60
           end if
           90 continue
           ll = ll + 1
           ! e(ll) through e(m-1) are nonzero, e(ll-1) is zero
           if( ll==m-1 ) then
              ! 2 by 2 block, handle separately
              call stdlib_dlasv2( d( m-1 ), e( m-1 ), d( m ), sigmn, sigmx, sinr,cosr, sinl, cosl &
                        )
              d( m-1 ) = sigmx
              e( m-1 ) = zero
              d( m ) = sigmn
              ! compute singular vectors, if desired
              if( ncvt>0 )call stdlib_zdrot( ncvt, vt( m-1, 1 ), ldvt, vt( m, 1 ), ldvt,cosr, &
                        sinr )
              if( nru>0 )call stdlib_zdrot( nru, u( 1, m-1 ), 1, u( 1, m ), 1, cosl, sinl )
                        
              if( ncc>0 )call stdlib_zdrot( ncc, c( m-1, 1 ), ldc, c( m, 1 ), ldc, cosl,sinl )
                        
              m = m - 2
              go to 60
           end if
           ! if working on new submatrix, choose shift direction
           ! (from larger end diagonal element towards smaller)
           if( ll>oldm .or. m<oldll ) then
              if( abs( d( ll ) )>=abs( d( m ) ) ) then
                 ! chase bulge from top (big end) to bottom (small end)
                 idir = 1
              else
                 ! chase bulge from bottom (big end) to top (small end)
                 idir = 2
              end if
           end if
           ! apply convergence tests
           if( idir==1 ) then
              ! run convergence test in forward direction
              ! first apply standard test to bottom of matrix
              if( abs( e( m-1 ) )<=abs( tol )*abs( d( m ) ) .or.( tol<zero .and. abs( e( m-1 ) )&
                        <=thresh ) ) then
                 e( m-1 ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion forward
                 mu = abs( d( ll ) )
                 sminl = mu
                 do lll = ll, m - 1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll+1 ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           else
              ! run convergence test in backward direction
              ! first apply standard test to top of matrix
              if( abs( e( ll ) )<=abs( tol )*abs( d( ll ) ) .or.( tol<zero .and. abs( e( ll ) )&
                        <=thresh ) ) then
                 e( ll ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion backward
                 mu = abs( d( m ) )
                 sminl = mu
                 do lll = m - 1, ll, -1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           end if
           oldll = ll
           oldm = m
           ! compute shift.  first, test if shifting would ruin relative
           ! accuracy, and if so set the shift to zero.
           if( tol>=zero .and. n*tol*( sminl / smax )<=max( eps, hndrth*tol ) ) then
              ! use a zero shift to avoid loss of relative accuracy
              shift = zero
           else
              ! compute the shift from 2-by-2 block at end of matrix
              if( idir==1 ) then
                 sll = abs( d( ll ) )
                 call stdlib_dlas2( d( m-1 ), e( m-1 ), d( m ), shift, r )
              else
                 sll = abs( d( m ) )
                 call stdlib_dlas2( d( ll ), e( ll ), d( ll+1 ), shift, r )
              end if
              ! test if shift negligible, and if so set to zero
              if( sll>zero ) then
                 if( ( shift / sll )**2<eps )shift = zero
              end if
           end if
           ! increment iteration count
           iter = iter + m - ll
           ! if shift = 0, do simplified qr iteration
           if( shift==zero ) then
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = ll, m - 1
                    call stdlib_dlartg( d( i )*cs, e( i ), cs, sn, r )
                    if( i>ll )e( i-1 ) = oldsn*r
                    call stdlib_dlartg( oldcs*r, d( i+1 )*sn, oldcs, oldsn, d( i ) )
                    rwork( i-ll+1 ) = cs
                    rwork( i-ll+1+nm1 ) = sn
                    rwork( i-ll+1+nm12 ) = oldcs
                    rwork( i-ll+1+nm13 ) = oldsn
                 end do
                 h = d( m )*cs
                 d( m ) = h*oldcs
                 e( m-1 ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_zlasr( 'L', 'V', 'F', m-ll+1, ncvt, rwork( 1 ),rwork( n )&
                           , vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_zlasr( 'R', 'V', 'F', nru, m-ll+1, rwork( nm12+1 ),rwork( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_zlasr( 'L', 'V', 'F', m-ll+1, ncc, rwork( nm12+1 ),rwork( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = m, ll + 1, -1
                    call stdlib_dlartg( d( i )*cs, e( i-1 ), cs, sn, r )
                    if( i<m )e( i ) = oldsn*r
                    call stdlib_dlartg( oldcs*r, d( i-1 )*sn, oldcs, oldsn, d( i ) )
                    rwork( i-ll ) = cs
                    rwork( i-ll+nm1 ) = -sn
                    rwork( i-ll+nm12 ) = oldcs
                    rwork( i-ll+nm13 ) = -oldsn
                 end do
                 h = d( ll )*cs
                 d( ll ) = h*oldcs
                 e( ll ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_zlasr( 'L', 'V', 'B', m-ll+1, ncvt, rwork( nm12+1 ),&
                           rwork( nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_zlasr( 'R', 'V', 'B', nru, m-ll+1, rwork( 1 ),rwork( n ), &
                           u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_zlasr( 'L', 'V', 'B', m-ll+1, ncc, rwork( 1 ),rwork( n ), &
                           c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
              end if
           else
              ! use nonzero shift
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( ll ) )-shift )*( sign( one, d( ll ) )+shift / d( ll ) )
                 g = e( ll )
                 do i = ll, m - 1
                    call stdlib_dlartg( f, g, cosr, sinr, r )
                    if( i>ll )e( i-1 ) = r
                    f = cosr*d( i ) + sinr*e( i )
                    e( i ) = cosr*e( i ) - sinr*d( i )
                    g = sinr*d( i+1 )
                    d( i+1 ) = cosr*d( i+1 )
                    call stdlib_dlartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i ) + sinl*d( i+1 )
                    d( i+1 ) = cosl*d( i+1 ) - sinl*e( i )
                    if( i<m-1 ) then
                       g = sinl*e( i+1 )
                       e( i+1 ) = cosl*e( i+1 )
                    end if
                    rwork( i-ll+1 ) = cosr
                    rwork( i-ll+1+nm1 ) = sinr
                    rwork( i-ll+1+nm12 ) = cosl
                    rwork( i-ll+1+nm13 ) = sinl
                 end do
                 e( m-1 ) = f
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_zlasr( 'L', 'V', 'F', m-ll+1, ncvt, rwork( 1 ),rwork( n )&
                           , vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_zlasr( 'R', 'V', 'F', nru, m-ll+1, rwork( nm12+1 ),rwork( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_zlasr( 'L', 'V', 'F', m-ll+1, ncc, rwork( nm12+1 ),rwork( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( m ) )-shift )*( sign( one, d( m ) )+shift /d( m ) )
                 g = e( m-1 )
                 do i = m, ll + 1, -1
                    call stdlib_dlartg( f, g, cosr, sinr, r )
                    if( i<m )e( i ) = r
                    f = cosr*d( i ) + sinr*e( i-1 )
                    e( i-1 ) = cosr*e( i-1 ) - sinr*d( i )
                    g = sinr*d( i-1 )
                    d( i-1 ) = cosr*d( i-1 )
                    call stdlib_dlartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i-1 ) + sinl*d( i-1 )
                    d( i-1 ) = cosl*d( i-1 ) - sinl*e( i-1 )
                    if( i>ll+1 ) then
                       g = sinl*e( i-2 )
                       e( i-2 ) = cosl*e( i-2 )
                    end if
                    rwork( i-ll ) = cosr
                    rwork( i-ll+nm1 ) = -sinr
                    rwork( i-ll+nm12 ) = cosl
                    rwork( i-ll+nm13 ) = -sinl
                 end do
                 e( ll ) = f
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
                 ! update singular vectors if desired
                 if( ncvt>0 )call stdlib_zlasr( 'L', 'V', 'B', m-ll+1, ncvt, rwork( nm12+1 ),&
                           rwork( nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_zlasr( 'R', 'V', 'B', nru, m-ll+1, rwork( 1 ),rwork( n ), &
                           u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_zlasr( 'L', 'V', 'B', m-ll+1, ncc, rwork( 1 ),rwork( n ), &
                           c( ll, 1 ), ldc )
              end if
           end if
           ! qr iteration finished, go back and check convergence
           go to 60
           ! all singular values converged, so make them positive
           160 continue
           do i = 1, n
              if( d( i )<zero ) then
                 d( i ) = -d( i )
                 ! change sign of singular vectors, if desired
                 if( ncvt>0 )call stdlib_zdscal( ncvt, negone, vt( i, 1 ), ldvt )
              end if
           end do
           ! sort the singular values into decreasing order (insertion sort on
           ! singular values, but only one transposition per singular vector)
           do i = 1, n - 1
              ! scan for smallest d(i)
              isub = 1
              smin = d( 1 )
              do j = 2, n + 1 - i
                 if( d( j )<=smin ) then
                    isub = j
                    smin = d( j )
                 end if
              end do
              if( isub/=n+1-i ) then
                 ! swap singular values and vectors
                 d( isub ) = d( n+1-i )
                 d( n+1-i ) = smin
                 if( ncvt>0 )call stdlib_zswap( ncvt, vt( isub, 1 ), ldvt, vt( n+1-i, 1 ),ldvt )
                           
                 if( nru>0 )call stdlib_zswap( nru, u( 1, isub ), 1, u( 1, n+1-i ), 1 )
                 if( ncc>0 )call stdlib_zswap( ncc, c( isub, 1 ), ldc, c( n+1-i, 1 ), ldc )
                           
              end if
           end do
           go to 220
           ! maximum number of iterations exceeded, failure to converge
           200 continue
           info = 0
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           220 continue
           return
     end subroutine stdlib_zbdsqr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$bdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, rwork,&
     !! ZBDSQR: computes the singular values and, optionally, the right and/or
     !! left singular vectors from the singular value decomposition (SVD) of
     !! a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
     !! zero-shift QR algorithm.  The SVD of B has the form
     !! B = Q * S * P**H
     !! where S is the diagonal matrix of singular values, Q is an orthogonal
     !! matrix of left singular vectors, and P is an orthogonal matrix of
     !! right singular vectors.  If left singular vectors are requested, this
     !! subroutine actually returns U*Q instead of Q, and, if right singular
     !! vectors are requested, this subroutine returns P**H*VT instead of
     !! P**H, for given complex input matrices U and VT.  When U and VT are
     !! the unitary matrices that reduce a general matrix A to bidiagonal
     !! form: A = U*B*VT, as computed by ZGEBRD, then
     !! A = (U*Q) * S * (P**H*VT)
     !! is the SVD of A.  Optionally, the subroutine may also compute Q**H*C
     !! for a given complex input matrix C.
     !! See "Computing  Small Singular Values of Bidiagonal Matrices With
     !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
     !! LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
     !! no. 5, pp. 873-912, Sept 1990) and
     !! "Accurate singular values and differential qd algorithms," by
     !! B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
     !! Department, University of California at Berkeley, July 1992
     !! for a detailed description of the algorithm.
                info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           ! Array Arguments 
           real(${ck}$), intent(inout) :: d(*), e(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: c(ldc,*), u(ldu,*), vt(ldvt,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: hndrth = 0.01_${ck}$
           real(${ck}$), parameter :: hndrd = 100.0_${ck}$
           real(${ck}$), parameter :: meigth = -0.125_${ck}$
           integer(ilp), parameter :: maxitr = 6
           
           
           
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: lower, rotate
           integer(ilp) :: i, idir, isub, iter, j, ll, lll, m, maxit, nm1, nm12, nm13, oldll, &
                     oldm
           real(${ck}$) :: abse, abss, cosl, cosr, cs, eps, f, g, h, mu, oldcs, oldsn, r, shift, &
           sigmn, sigmx, sinl, sinr, sll, smax, smin, sminl, sminoa, sn, thresh, tol, tolmul, &
                     unfl
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.lower ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ncvt<0 ) then
              info = -3
           else if( nru<0 ) then
              info = -4
           else if( ncc<0 ) then
              info = -5
           else if( ( ncvt==0 .and. ldvt<1 ) .or.( ncvt>0 .and. ldvt<max( 1, n ) ) ) then
              info = -9
           else if( ldu<max( 1, nru ) ) then
              info = -11
           else if( ( ncc==0 .and. ldc<1 ) .or.( ncc>0 .and. ldc<max( 1, n ) ) ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZBDSQR', -info )
              return
           end if
           if( n==0 )return
           if( n==1 )go to 160
           ! rotate is true if any singular vectors desired, false otherwise
           rotate = ( ncvt>0 ) .or. ( nru>0 ) .or. ( ncc>0 )
           ! if no singular vectors desired, use qd algorithm
           if( .not.rotate ) then
              call stdlib_${c2ri(ci)}$lasq1( n, d, e, rwork, info )
           ! if info equals 2, dqds didn't finish, try to finish
              if( info /= 2 ) return
              info = 0
           end if
           nm1 = n - 1
           nm12 = nm1 + nm1
           nm13 = nm12 + nm1
           idir = 0
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'EPSILON' )
           unfl = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           if( lower ) then
              do i = 1, n - 1
                 call stdlib_${c2ri(ci)}$lartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 rwork( i ) = cs
                 rwork( nm1+i ) = sn
              end do
              ! update singular vectors if desired
              if( nru>0 )call stdlib_${ci}$lasr( 'R', 'V', 'F', nru, n, rwork( 1 ), rwork( n ),u, ldu )
                        
              if( ncc>0 )call stdlib_${ci}$lasr( 'L', 'V', 'F', n, ncc, rwork( 1 ), rwork( n ),c, ldc )
                        
           end if
           ! compute singular values to relative accuracy tol
           ! (by setting tol to be negative, algorithm will compute
           ! singular values to absolute accuracy abs(tol)*norm(input matrix))
           tolmul = max( ten, min( hndrd, eps**meigth ) )
           tol = tolmul*eps
           ! compute approximate maximum, minimum singular values
           smax = zero
           do i = 1, n
              smax = max( smax, abs( d( i ) ) )
           end do
           do i = 1, n - 1
              smax = max( smax, abs( e( i ) ) )
           end do
           sminl = zero
           if( tol>=zero ) then
              ! relative accuracy desired
              sminoa = abs( d( 1 ) )
              if( sminoa==zero )go to 50
              mu = sminoa
              do i = 2, n
                 mu = abs( d( i ) )*( mu / ( mu+abs( e( i-1 ) ) ) )
                 sminoa = min( sminoa, mu )
                 if( sminoa==zero )go to 50
              end do
              50 continue
              sminoa = sminoa / sqrt( real( n,KIND=${ck}$) )
              thresh = max( tol*sminoa, maxitr*n*n*unfl )
           else
              ! absolute accuracy desired
              thresh = max( abs( tol )*smax, maxitr*n*n*unfl )
           end if
           ! prepare for main iteration loop for the singular values
           ! (maxit is the maximum number of passes through the inner
           ! loop permitted before nonconvergence signalled.)
           maxit = maxitr*n*n
           iter = 0
           oldll = -1
           oldm = -1
           ! m points to last element of unconverged part of matrix
           m = n
           ! begin main iteration loop
           60 continue
           ! check for convergence or exceeding iteration count
           if( m<=1 )go to 160
           if( iter>maxit )go to 200
           ! find diagonal block of matrix to work on
           if( tol<zero .and. abs( d( m ) )<=thresh )d( m ) = zero
           smax = abs( d( m ) )
           smin = smax
           do lll = 1, m - 1
              ll = m - lll
              abss = abs( d( ll ) )
              abse = abs( e( ll ) )
              if( tol<zero .and. abss<=thresh )d( ll ) = zero
              if( abse<=thresh )go to 80
              smin = min( smin, abss )
              smax = max( smax, abss, abse )
           end do
           ll = 0
           go to 90
           80 continue
           e( ll ) = zero
           ! matrix splits since e(ll) = 0
           if( ll==m-1 ) then
              ! convergence of bottom singular value, return to top of loop
              m = m - 1
              go to 60
           end if
           90 continue
           ll = ll + 1
           ! e(ll) through e(m-1) are nonzero, e(ll-1) is zero
           if( ll==m-1 ) then
              ! 2 by 2 block, handle separately
              call stdlib_${c2ri(ci)}$lasv2( d( m-1 ), e( m-1 ), d( m ), sigmn, sigmx, sinr,cosr, sinl, cosl &
                        )
              d( m-1 ) = sigmx
              e( m-1 ) = zero
              d( m ) = sigmn
              ! compute singular vectors, if desired
              if( ncvt>0 )call stdlib_${ci}$drot( ncvt, vt( m-1, 1 ), ldvt, vt( m, 1 ), ldvt,cosr, &
                        sinr )
              if( nru>0 )call stdlib_${ci}$drot( nru, u( 1, m-1 ), 1, u( 1, m ), 1, cosl, sinl )
                        
              if( ncc>0 )call stdlib_${ci}$drot( ncc, c( m-1, 1 ), ldc, c( m, 1 ), ldc, cosl,sinl )
                        
              m = m - 2
              go to 60
           end if
           ! if working on new submatrix, choose shift direction
           ! (from larger end diagonal element towards smaller)
           if( ll>oldm .or. m<oldll ) then
              if( abs( d( ll ) )>=abs( d( m ) ) ) then
                 ! chase bulge from top (big end) to bottom (small end)
                 idir = 1
              else
                 ! chase bulge from bottom (big end) to top (small end)
                 idir = 2
              end if
           end if
           ! apply convergence tests
           if( idir==1 ) then
              ! run convergence test in forward direction
              ! first apply standard test to bottom of matrix
              if( abs( e( m-1 ) )<=abs( tol )*abs( d( m ) ) .or.( tol<zero .and. abs( e( m-1 ) )&
                        <=thresh ) ) then
                 e( m-1 ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion forward
                 mu = abs( d( ll ) )
                 sminl = mu
                 do lll = ll, m - 1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll+1 ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           else
              ! run convergence test in backward direction
              ! first apply standard test to top of matrix
              if( abs( e( ll ) )<=abs( tol )*abs( d( ll ) ) .or.( tol<zero .and. abs( e( ll ) )&
                        <=thresh ) ) then
                 e( ll ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion backward
                 mu = abs( d( m ) )
                 sminl = mu
                 do lll = m - 1, ll, -1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           end if
           oldll = ll
           oldm = m
           ! compute shift.  first, test if shifting would ruin relative
           ! accuracy, and if so set the shift to zero.
           if( tol>=zero .and. n*tol*( sminl / smax )<=max( eps, hndrth*tol ) ) then
              ! use a zero shift to avoid loss of relative accuracy
              shift = zero
           else
              ! compute the shift from 2-by-2 block at end of matrix
              if( idir==1 ) then
                 sll = abs( d( ll ) )
                 call stdlib_${c2ri(ci)}$las2( d( m-1 ), e( m-1 ), d( m ), shift, r )
              else
                 sll = abs( d( m ) )
                 call stdlib_${c2ri(ci)}$las2( d( ll ), e( ll ), d( ll+1 ), shift, r )
              end if
              ! test if shift negligible, and if so set to zero
              if( sll>zero ) then
                 if( ( shift / sll )**2<eps )shift = zero
              end if
           end if
           ! increment iteration count
           iter = iter + m - ll
           ! if shift = 0, do simplified qr iteration
           if( shift==zero ) then
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = ll, m - 1
                    call stdlib_${c2ri(ci)}$lartg( d( i )*cs, e( i ), cs, sn, r )
                    if( i>ll )e( i-1 ) = oldsn*r
                    call stdlib_${c2ri(ci)}$lartg( oldcs*r, d( i+1 )*sn, oldcs, oldsn, d( i ) )
                    rwork( i-ll+1 ) = cs
                    rwork( i-ll+1+nm1 ) = sn
                    rwork( i-ll+1+nm12 ) = oldcs
                    rwork( i-ll+1+nm13 ) = oldsn
                 end do
                 h = d( m )*cs
                 d( m ) = h*oldcs
                 e( m-1 ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_${ci}$lasr( 'L', 'V', 'F', m-ll+1, ncvt, rwork( 1 ),rwork( n )&
                           , vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ci}$lasr( 'R', 'V', 'F', nru, m-ll+1, rwork( nm12+1 ),rwork( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ci}$lasr( 'L', 'V', 'F', m-ll+1, ncc, rwork( nm12+1 ),rwork( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = m, ll + 1, -1
                    call stdlib_${c2ri(ci)}$lartg( d( i )*cs, e( i-1 ), cs, sn, r )
                    if( i<m )e( i ) = oldsn*r
                    call stdlib_${c2ri(ci)}$lartg( oldcs*r, d( i-1 )*sn, oldcs, oldsn, d( i ) )
                    rwork( i-ll ) = cs
                    rwork( i-ll+nm1 ) = -sn
                    rwork( i-ll+nm12 ) = oldcs
                    rwork( i-ll+nm13 ) = -oldsn
                 end do
                 h = d( ll )*cs
                 d( ll ) = h*oldcs
                 e( ll ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_${ci}$lasr( 'L', 'V', 'B', m-ll+1, ncvt, rwork( nm12+1 ),&
                           rwork( nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ci}$lasr( 'R', 'V', 'B', nru, m-ll+1, rwork( 1 ),rwork( n ), &
                           u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ci}$lasr( 'L', 'V', 'B', m-ll+1, ncc, rwork( 1 ),rwork( n ), &
                           c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
              end if
           else
              ! use nonzero shift
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( ll ) )-shift )*( sign( one, d( ll ) )+shift / d( ll ) )
                 g = e( ll )
                 do i = ll, m - 1
                    call stdlib_${c2ri(ci)}$lartg( f, g, cosr, sinr, r )
                    if( i>ll )e( i-1 ) = r
                    f = cosr*d( i ) + sinr*e( i )
                    e( i ) = cosr*e( i ) - sinr*d( i )
                    g = sinr*d( i+1 )
                    d( i+1 ) = cosr*d( i+1 )
                    call stdlib_${c2ri(ci)}$lartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i ) + sinl*d( i+1 )
                    d( i+1 ) = cosl*d( i+1 ) - sinl*e( i )
                    if( i<m-1 ) then
                       g = sinl*e( i+1 )
                       e( i+1 ) = cosl*e( i+1 )
                    end if
                    rwork( i-ll+1 ) = cosr
                    rwork( i-ll+1+nm1 ) = sinr
                    rwork( i-ll+1+nm12 ) = cosl
                    rwork( i-ll+1+nm13 ) = sinl
                 end do
                 e( m-1 ) = f
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_${ci}$lasr( 'L', 'V', 'F', m-ll+1, ncvt, rwork( 1 ),rwork( n )&
                           , vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ci}$lasr( 'R', 'V', 'F', nru, m-ll+1, rwork( nm12+1 ),rwork( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ci}$lasr( 'L', 'V', 'F', m-ll+1, ncc, rwork( nm12+1 ),rwork( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( m ) )-shift )*( sign( one, d( m ) )+shift /d( m ) )
                 g = e( m-1 )
                 do i = m, ll + 1, -1
                    call stdlib_${c2ri(ci)}$lartg( f, g, cosr, sinr, r )
                    if( i<m )e( i ) = r
                    f = cosr*d( i ) + sinr*e( i-1 )
                    e( i-1 ) = cosr*e( i-1 ) - sinr*d( i )
                    g = sinr*d( i-1 )
                    d( i-1 ) = cosr*d( i-1 )
                    call stdlib_${c2ri(ci)}$lartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i-1 ) + sinl*d( i-1 )
                    d( i-1 ) = cosl*d( i-1 ) - sinl*e( i-1 )
                    if( i>ll+1 ) then
                       g = sinl*e( i-2 )
                       e( i-2 ) = cosl*e( i-2 )
                    end if
                    rwork( i-ll ) = cosr
                    rwork( i-ll+nm1 ) = -sinr
                    rwork( i-ll+nm12 ) = cosl
                    rwork( i-ll+nm13 ) = -sinl
                 end do
                 e( ll ) = f
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
                 ! update singular vectors if desired
                 if( ncvt>0 )call stdlib_${ci}$lasr( 'L', 'V', 'B', m-ll+1, ncvt, rwork( nm12+1 ),&
                           rwork( nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ci}$lasr( 'R', 'V', 'B', nru, m-ll+1, rwork( 1 ),rwork( n ), &
                           u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ci}$lasr( 'L', 'V', 'B', m-ll+1, ncc, rwork( 1 ),rwork( n ), &
                           c( ll, 1 ), ldc )
              end if
           end if
           ! qr iteration finished, go back and check convergence
           go to 60
           ! all singular values converged, so make them positive
           160 continue
           do i = 1, n
              if( d( i )<zero ) then
                 d( i ) = -d( i )
                 ! change sign of singular vectors, if desired
                 if( ncvt>0 )call stdlib_${ci}$dscal( ncvt, negone, vt( i, 1 ), ldvt )
              end if
           end do
           ! sort the singular values into decreasing order (insertion sort on
           ! singular values, but only one transposition per singular vector)
           do i = 1, n - 1
              ! scan for smallest d(i)
              isub = 1
              smin = d( 1 )
              do j = 2, n + 1 - i
                 if( d( j )<=smin ) then
                    isub = j
                    smin = d( j )
                 end if
              end do
              if( isub/=n+1-i ) then
                 ! swap singular values and vectors
                 d( isub ) = d( n+1-i )
                 d( n+1-i ) = smin
                 if( ncvt>0 )call stdlib_${ci}$swap( ncvt, vt( isub, 1 ), ldvt, vt( n+1-i, 1 ),ldvt )
                           
                 if( nru>0 )call stdlib_${ci}$swap( nru, u( 1, isub ), 1, u( 1, n+1-i ), 1 )
                 if( ncc>0 )call stdlib_${ci}$swap( ncc, c( isub, 1 ), ldc, c( n+1-i, 1 ), ldc )
                           
              end if
           end do
           go to 220
           ! maximum number of iterations exceeded, failure to converge
           200 continue
           info = 0
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           220 continue
           return
     end subroutine stdlib_${ci}$bdsqr

#:endif
#:endfor



     module pure subroutine stdlib_sgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, work, lwork, &
     !! SGESVJ computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^t,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N orthogonal matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
     !! SGESVJ can sometimes compute tiny singular values and their singular vectors much
     !! more accurately than other SVD routines, see below under Further Details.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldv, lwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), v(ldv,*), work(lwork)
           real(sp), intent(out) :: sva(n)
        ! =====================================================================
           ! Local Parameters 
           integer(ilp), parameter :: nsweep = 30
           
           
           ! Local Scalars 
           real(sp) :: aapp, aapp0, aapq, aaqq, apoaq, aqoap, big, bigtheta, cs, ctol, epsln, &
           large, mxaapq, mxsinj, rootbig, rooteps, rootsfmin, roottol, skl, sfmin, small, sn, t, &
                     temp1, theta, thsign, tol
           integer(ilp) :: blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1, iswrot, jbc, jgl, kbl, &
                     lkahead, mvl, n2, n34, n4, nbl, notrot, p, pskipped, q, rowskip, swband
           logical(lk) :: applv, goscale, lower, lsvec, noscale, rotok, rsvec, uctol, &
                     upper
           ! Local Arrays 
           real(sp) :: fastr(5)
           ! Intrinsic Functions 
           ! from lapack
           ! from lapack
           ! Executable Statements 
           ! test the input arguments
           lsvec = stdlib_lsame( jobu, 'U' )
           uctol = stdlib_lsame( jobu, 'C' )
           rsvec = stdlib_lsame( jobv, 'V' )
           applv = stdlib_lsame( jobv, 'A' )
           upper = stdlib_lsame( joba, 'U' )
           lower = stdlib_lsame( joba, 'L' )
           if( .not.( upper .or. lower .or. stdlib_lsame( joba, 'G' ) ) ) then
              info = -1
           else if( .not.( lsvec .or. uctol .or. stdlib_lsame( jobu, 'N' ) ) ) then
              info = -2
           else if( .not.( rsvec .or. applv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( ( n<0 ) .or. ( n>m ) ) then
              info = -5
           else if( lda<m ) then
              info = -7
           else if( mv<0 ) then
              info = -9
           else if( ( rsvec .and. ( ldv<n ) ) .or.( applv .and. ( ldv<mv ) ) ) then
              info = -11
           else if( uctol .and. ( work( 1 )<=one ) ) then
              info = -12
           else if( lwork<max( m+n, 6 ) ) then
              info = -13
           else
              info = 0
           end if
           ! #:(
           if( info/=0 ) then
              call stdlib_xerbla( 'SGESVJ', -info )
              return
           end if
       ! #:) quick return for void matrix
           if( ( m==0 ) .or. ( n==0 ) )return
           ! set numerical parameters
           ! the stopping criterion for jacobi rotations is
           ! max_{i<>j}|a(:,i)^t * a(:,j)|/(||a(:,i)||*||a(:,j)||) < ctol*eps
           ! where eps is the round-off and ctol is defined as follows:
           if( uctol ) then
              ! ... user controlled
              ctol = work( 1 )
           else
              ! ... default
              if( lsvec .or. rsvec .or. applv ) then
                 ctol = sqrt( real( m,KIND=sp) )
              else
                 ctol = real( m,KIND=sp)
              end if
           end if
           ! ... and the machine dependent parameters are
      ! [!]  (make sure that stdlib_slamch() works properly on the target machine.)
           epsln = stdlib_slamch( 'EPSILON' )
           rooteps = sqrt( epsln )
           sfmin = stdlib_slamch( 'SAFEMINIMUM' )
           rootsfmin = sqrt( sfmin )
           small = sfmin / epsln
           big = stdlib_slamch( 'OVERFLOW' )
           ! big         = one    / sfmin
           rootbig = one / rootsfmin
           large = big / sqrt( real( m*n,KIND=sp) )
           bigtheta = one / rooteps
           tol = ctol*epsln
           roottol = sqrt( tol )
           if( real( m,KIND=sp)*epsln>=one ) then
              info = -4
              call stdlib_xerbla( 'SGESVJ', -info )
              return
           end if
           ! initialize the right singular vector matrix.
           if( rsvec ) then
              mvl = n
              call stdlib_slaset( 'A', mvl, n, zero, one, v, ldv )
           else if( applv ) then
              mvl = mv
           end if
           rsvec = rsvec .or. applv
           ! initialize sva( 1:n ) = ( ||a e_i||_2, i = 1:n )
      ! (!)  if necessary, scale a to protect the largest singular value
           ! from overflow. it is possible that saving the largest singular
           ! value destroys the information about the small ones.
           ! this initial scaling is almost minimal in the sense that the
           ! goal is to make sure that no column norm overflows, and that
           ! sqrt(n)*max_i sva(i) does not overflow. if infinite entries
           ! in a are detected, the procedure returns with info=-6.
           skl = one / sqrt( real( m,KIND=sp)*real( n,KIND=sp) )
           noscale = .true.
           goscale = .true.
           if( lower ) then
              ! the input matrix is m-by-n lower triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_slassq( m-p+1, a( p, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'SGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else if( upper ) then
              ! the input matrix is m-by-n upper triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_slassq( p, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'SGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else
              ! the input matrix is m-by-n general dense
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_slassq( m, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'SGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           end if
           if( noscale )skl = one
           ! move the smaller part of the spectrum from the underflow threshold
      ! (!)  start by determining the position of the nonzero entries of the
           ! array sva() relative to ( sfmin, big ).
           aapp = zero
           aaqq = big
           do p = 1, n
              if( sva( p )/=zero )aaqq = min( aaqq, sva( p ) )
              aapp = max( aapp, sva( p ) )
           end do
       ! #:) quick return for zero matrix
           if( aapp==zero ) then
              if( lsvec )call stdlib_slaset( 'G', m, n, zero, one, a, lda )
              work( 1 ) = one
              work( 2 ) = zero
              work( 3 ) = zero
              work( 4 ) = zero
              work( 5 ) = zero
              work( 6 ) = zero
              return
           end if
       ! #:) quick return for one-column matrix
           if( n==1 ) then
              if( lsvec )call stdlib_slascl( 'G', 0, 0, sva( 1 ), skl, m, 1,a( 1, 1 ), lda, ierr )
                        
              work( 1 ) = one / skl
              if( sva( 1 )>=sfmin ) then
                 work( 2 ) = one
              else
                 work( 2 ) = zero
              end if
              work( 3 ) = zero
              work( 4 ) = zero
              work( 5 ) = zero
              work( 6 ) = zero
              return
           end if
           ! protect small singular values from underflow, and try to
           ! avoid underflows/overflows in computing jacobi rotations.
           sn = sqrt( sfmin / epsln )
           temp1 = sqrt( big / real( n,KIND=sp) )
           if( ( aapp<=sn ) .or. ( aaqq>=temp1 ) .or.( ( sn<=aaqq ) .and. ( aapp<=temp1 ) ) ) &
                     then
              temp1 = min( big, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp<=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( aapp*sqrt( real( n,KIND=sp) ) ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq>=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = max( sn / aaqq, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( sqrt( real( n,KIND=sp) )*aapp ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else
              temp1 = one
           end if
           ! scale, if necessary
           if( temp1/=one ) then
              call stdlib_slascl( 'G', 0, 0, one, temp1, n, 1, sva, n, ierr )
           end if
           skl = temp1*skl
           if( skl/=one ) then
              call stdlib_slascl( joba, 0, 0, one, skl, m, n, a, lda, ierr )
              skl = one / skl
           end if
           ! row-cyclic jacobi svd algorithm with column pivoting
           emptsw = ( n*( n-1 ) ) / 2
           notrot = 0
           fastr( 1 ) = zero
           ! a is represented in factored form a = a * diag(work), where diag(work)
           ! is initialized to identity. work is updated during fast scaled
           ! rotations.
           do q = 1, n
              work( q ) = one
           end do
           swband = 3
      ! [tp] swband is a tuning parameter [tp]. it is meaningful and effective
           ! if stdlib_sgesvj is used as a computational routine in the preconditioned
           ! jacobi svd algorithm stdlib_sgesvj. for sweeps i=1:swband the procedure
           ! works on pivots inside a band-like region around the diagonal.
           ! the boundaries are determined dynamically, based on the number of
           ! pivots above a threshold.
           kbl = min( 8, n )
      ! [tp] kbl is a tuning parameter that defines the tile size in the
           ! tiling of the p-q loops of pivot pairs. in general, an optimal
           ! value of kbl depends on the matrix dimensions and on the
           ! parameters of the computer's memory.
           nbl = n / kbl
           if( ( nbl*kbl )/=n )nbl = nbl + 1
           blskip = kbl**2
      ! [tp] blkskip is a tuning parameter that depends on swband and kbl.
           rowskip = min( 5, kbl )
      ! [tp] rowskip is a tuning parameter.
           lkahead = 1
      ! [tp] lkahead is a tuning parameter.
           ! quasi block transformations, using the lower (upper) triangular
           ! structure of the input matrix. the quasi-block-cycling usually
           ! invokes cubic convergence. big part of this cycle is done inside
           ! canonical subspaces of dimensions less than m.
           if( ( lower .or. upper ) .and. ( n>max( 64, 4*kbl ) ) ) then
      ! [tp] the number of partition levels and the actual partition are
           ! tuning parameters.
              n4 = n / 4
              n2 = n / 2
              n34 = 3*n4
              if( applv ) then
                 q = 0
              else
                 q = 1
              end if
              if( lower ) then
           ! this works very well on lower triangular matrices, in particular
           ! in the framework of the preconditioned jacobi svd (xgejsv).
           ! the idea is simple:
           ! [+ 0 0 0]   note that jacobi transformations of [0 0]
           ! [+ + 0 0]                                       [0 0]
           ! [+ + x 0]   actually work on [x 0]              [x 0]
           ! [+ + x x]                    [x x].             [x x]
                 call stdlib_sgsvj0( jobv, m-n34, n-n34, a( n34+1, n34+1 ), lda,work( n34+1 ), &
                 sva( n34+1 ), mvl,v( n34*q+1, n34+1 ), ldv, epsln, sfmin, tol,2, work( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_sgsvj0( jobv, m-n2, n34-n2, a( n2+1, n2+1 ), lda,work( n2+1 ), sva( &
                 n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 2,work( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_sgsvj1( jobv, m-n2, n-n2, n4, a( n2+1, n2+1 ), lda,work( n2+1 ), sva(&
                  n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, &
                            ierr )
                 call stdlib_sgsvj0( jobv, m-n4, n2-n4, a( n4+1, n4+1 ), lda,work( n4+1 ), sva( &
                 n4+1 ), mvl,v( n4*q+1, n4+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_sgsvj0( jobv, m, n4, a, lda, work, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 1, work( n+1 ), lwork-n,ierr )
                 call stdlib_sgsvj1( jobv, m, n2, n4, a, lda, work, sva, mvl, v,ldv, epsln, sfmin,&
                            tol, 1, work( n+1 ),lwork-n, ierr )
              else if( upper ) then
                 call stdlib_sgsvj0( jobv, n4, n4, a, lda, work, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 2, work( n+1 ), lwork-n,ierr )
                 call stdlib_sgsvj0( jobv, n2, n4, a( 1, n4+1 ), lda, work( n4+1 ),sva( n4+1 ), &
                 mvl, v( n4*q+1, n4+1 ), ldv,epsln, sfmin, tol, 1, work( n+1 ), lwork-n,ierr )
                           
                 call stdlib_sgsvj1( jobv, n2, n2, n4, a, lda, work, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, work( n+1 ),lwork-n, ierr )
                 call stdlib_sgsvj0( jobv, n2+n4, n4, a( 1, n2+1 ), lda,work( n2+1 ), sva( n2+1 ),&
                  mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, ierr )
                            
              end if
           end if
           ! .. row-cyclic pivot strategy with de rijk's pivoting ..
           loop_1993: do i = 1, nsweep
           ! .. go go go ...
              mxaapq = zero
              mxsinj = zero
              iswrot = 0
              notrot = 0
              pskipped = 0
           ! each sweep is unrolled using kbl-by-kbl tiles over the pivot pairs
           ! 1 <= p < q <= n. this is the first step toward a blocked implementation
           ! of the rotations. new implementation, based on block transformations,
           ! is under development.
              loop_2000: do ibr = 1, nbl
                 igl = ( ibr-1 )*kbl + 1
                 loop_1002: do ir1 = 0, min( lkahead, nbl-ibr )
                    igl = igl + ir1*kbl
                    loop_2001: do p = igl, min( igl+kbl-1, n-1 )
           ! .. de rijk's pivoting
                       q = stdlib_isamax( n-p+1, sva( p ), 1 ) + p - 1
                       if( p/=q ) then
                          call stdlib_sswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                          if( rsvec )call stdlib_sswap( mvl, v( 1, p ), 1,v( 1, q ), 1 )
                          temp1 = sva( p )
                          sva( p ) = sva( q )
                          sva( q ) = temp1
                          temp1 = work( p )
                          work( p ) = work( q )
                          work( q ) = temp1
                       end if
                       if( ir1==0 ) then
              ! column norms are periodically updated by explicit
              ! norm computation.
              ! caveat:
              ! unfortunately, some blas implementations compute stdlib_snrm2(m,a(1,p),1)
              ! as sqrt(stdlib_sdot(m,a(1,p),1,a(1,p),1)), which may cause the result to
              ! overflow for ||a(:,p)||_2 > sqrt(overflow_threshold), and to
              ! underflow for ||a(:,p)||_2 < sqrt(underflow_threshold).
              ! hence, stdlib_snrm2 cannot be trusted, not even in the case when
              ! the true norm is far from the under(over)flow boundaries.
              ! if properly implemented stdlib_snrm2 is available, the if-then-else
              ! below should read "aapp = stdlib_snrm2( m, a(1,p), 1 ) * work(p)".
                          if( ( sva( p )<rootbig ) .and.( sva( p )>rootsfmin ) ) then
                             sva( p ) = stdlib_snrm2( m, a( 1, p ), 1 )*work( p )
                          else
                             temp1 = zero
                             aapp = one
                             call stdlib_slassq( m, a( 1, p ), 1, temp1, aapp )
                             sva( p ) = temp1*sqrt( aapp )*work( p )
                          end if
                          aapp = sva( p )
                       else
                          aapp = sva( p )
                       end if
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2002: do q = p + 1, min( igl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
                                if( aaqq>=one ) then
                                   rotok = ( small*aapp )<=aaqq
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_sdot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_scopy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_slascl( 'G', 0, 0, aapp,work( p ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_sdot( m, work( n+1 ), 1,a( 1, q ), 1 )*work( &
                                                q ) / aaqq
                                   end if
                                else
                                   rotok = aapp<=( aaqq / small )
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_sdot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_scopy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                      call stdlib_slascl( 'G', 0, 0, aaqq,work( q ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_sdot( m, work( n+1 ), 1,a( 1, p ), 1 )*work( &
                                                p ) / aapp
                                   end if
                                end if
                                mxaapq = max( mxaapq, abs( aapq ) )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq )>tol ) then
                 ! Rotate
      ! [rtd]      rotated = rotated + one
                                   if( ir1==0 ) then
                                      notrot = 0
                                      pskipped = 0
                                      iswrot = iswrot + 1
                                   end if
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq ) / aapq
                                      if( abs( theta )>bigtheta ) then
                                         t = half / theta
                                         fastr( 3 ) = t*work( p ) / work( q )
                                         fastr( 4 ) = -t*work( q ) /work( p )
                                         call stdlib_srotm( m, a( 1, p ), 1,a( 1, q ), 1, fastr )
                                                   
                                         if( rsvec )call stdlib_srotm( mvl,v( 1, p ), 1,v( 1, q ),&
                                                    1,fastr )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq )
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         apoaq = work( p ) / work( q )
                                         aqoap = work( q ) / work( p )
                                         if( work( p )>=one ) then
                                            if( work( q )>=one ) then
                                               fastr( 3 ) = t*apoaq
                                               fastr( 4 ) = -t*aqoap
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q )*cs
                                               call stdlib_srotm( m, a( 1, p ), 1,a( 1, q ), 1,&
                                                         fastr )
                                               if( rsvec )call stdlib_srotm( mvl,v( 1, p ), 1, v( &
                                                         1, q ),1, fastr )
                                            else
                                               call stdlib_saxpy( m, -t*aqoap,a( 1, q ), 1,a( 1, &
                                                         p ), 1 )
                                               call stdlib_saxpy( m, cs*sn*apoaq,a( 1, p ), 1,a( &
                                                         1, q ), 1 )
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q ) / cs
                                               if( rsvec ) then
                                                  call stdlib_saxpy( mvl, -t*aqoap,v( 1, q ), 1,v(&
                                                             1, p ), 1 )
                                                  call stdlib_saxpy( mvl,cs*sn*apoaq,v( 1, p ), 1,&
                                                            v( 1, q ), 1 )
                                               end if
                                            end if
                                         else
                                            if( work( q )>=one ) then
                                               call stdlib_saxpy( m, t*apoaq,a( 1, p ), 1,a( 1, q &
                                                         ), 1 )
                                               call stdlib_saxpy( m, -cs*sn*aqoap,a( 1, q ), 1,a( &
                                                         1, p ), 1 )
                                               work( p ) = work( p ) / cs
                                               work( q ) = work( q )*cs
                                               if( rsvec ) then
                                                  call stdlib_saxpy( mvl, t*apoaq,v( 1, p ), 1,v( &
                                                            1, q ), 1 )
                                                  call stdlib_saxpy( mvl,-cs*sn*aqoap,v( 1, q ), &
                                                            1,v( 1, p ), 1 )
                                               end if
                                            else
                                               if( work( p )>=work( q ) )then
                                                  call stdlib_saxpy( m, -t*aqoap,a( 1, q ), 1,a( &
                                                            1, p ), 1 )
                                                  call stdlib_saxpy( m, cs*sn*apoaq,a( 1, p ), 1,&
                                                            a( 1, q ), 1 )
                                                  work( p ) = work( p )*cs
                                                  work( q ) = work( q ) / cs
                                                  if( rsvec ) then
                                                     call stdlib_saxpy( mvl,-t*aqoap,v( 1, q ), 1,&
                                                               v( 1, p ), 1 )
                                                     call stdlib_saxpy( mvl,cs*sn*apoaq,v( 1, p ),&
                                                                1,v( 1, q ), 1 )
                                                  end if
                                               else
                                                  call stdlib_saxpy( m, t*apoaq,a( 1, p ), 1,a( 1,&
                                                             q ), 1 )
                                                  call stdlib_saxpy( m,-cs*sn*aqoap,a( 1, q ), 1,&
                                                            a( 1, p ), 1 )
                                                  work( p ) = work( p ) / cs
                                                  work( q ) = work( q )*cs
                                                  if( rsvec ) then
                                                     call stdlib_saxpy( mvl,t*apoaq, v( 1, p ),1, &
                                                               v( 1, q ), 1 )
                                                     call stdlib_saxpy( mvl,-cs*sn*aqoap,v( 1, q )&
                                                               , 1,v( 1, p ), 1 )
                                                  end if
                                               end if
                                            end if
                                         end if
                                      end if
                                   else
                    ! .. have to use modified gram-schmidt like transformation
                                      call stdlib_scopy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_slascl( 'G', 0, 0, aapp, one, m,1, work( n+1 ), &
                                                lda,ierr )
                                      call stdlib_slascl( 'G', 0, 0, aaqq, one, m,1, a( 1, q ), &
                                                lda, ierr )
                                      temp1 = -aapq*work( p ) / work( q )
                                      call stdlib_saxpy( m, temp1, work( n+1 ), 1,a( 1, q ), 1 )
                                                
                                      call stdlib_slascl( 'G', 0, 0, one, aaqq, m,1, a( 1, q ), &
                                                lda, ierr )
                                      sva( q ) = aaqq*sqrt( max( zero,one-aapq*aapq ) )
                                      mxsinj = max( mxsinj, sfmin )
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! recompute sva(q), sva(p).
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_snrm2( m, a( 1, q ), 1 )*work( q )
                                                   
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_slassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )*work( q )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_snrm2( m, a( 1, p ), 1 )*work( p )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_slassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )*work( p )
                                      end if
                                      sva( p ) = aapp
                                   end if
                                else
              ! a(:,p) and a(:,q) already numerically orthogonal
                                   if( ir1==0 )notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                end if
                             else
              ! a(:,q) is zero column
                                if( ir1==0 )notrot = notrot + 1
                                pskipped = pskipped + 1
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                if( ir1==0 )aapp = -aapp
                                notrot = 0
                                go to 2103
                             end if
                          end do loop_2002
           ! end q-loop
           2103 continue
           ! bailed out of q-loop
                          sva( p ) = aapp
                       else
                          sva( p ) = aapp
                          if( ( ir1==0 ) .and. ( aapp==zero ) )notrot = notrot + min( igl+kbl-1, &
                                    n ) - p
                       end if
                    end do loop_2001
           ! end of the p-loop
           ! end of doing the block ( ibr, ibr )
                 end do loop_1002
           ! end of ir1-loop
       ! ... go to the off diagonal blocks
                 igl = ( ibr-1 )*kbl + 1
                 loop_2010: do jbc = ibr + 1, nbl
                    jgl = ( jbc-1 )*kbl + 1
              ! doing the block at ( ibr, jbc )
                    ijblsk = 0
                    loop_2100: do p = igl, min( igl+kbl-1, n )
                       aapp = sva( p )
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2200: do q = jgl, min( jgl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
           ! M X 2 Jacobi Svd 
              ! safe gram matrix computation
                                if( aaqq>=one ) then
                                   if( aapp>=aaqq ) then
                                      rotok = ( small*aapp )<=aaqq
                                   else
                                      rotok = ( small*aaqq )<=aapp
                                   end if
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_sdot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_scopy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_slascl( 'G', 0, 0, aapp,work( p ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_sdot( m, work( n+1 ), 1,a( 1, q ), 1 )*work( &
                                                q ) / aaqq
                                   end if
                                else
                                   if( aapp>=aaqq ) then
                                      rotok = aapp<=( aaqq / small )
                                   else
                                      rotok = aaqq<=( aapp / small )
                                   end if
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_sdot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_scopy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                      call stdlib_slascl( 'G', 0, 0, aaqq,work( q ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_sdot( m, work( n+1 ), 1,a( 1, p ), 1 )*work( &
                                                p ) / aapp
                                   end if
                                end if
                                mxaapq = max( mxaapq, abs( aapq ) )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq )>tol ) then
                                   notrot = 0
      ! [rtd]      rotated  = rotated + 1
                                   pskipped = 0
                                   iswrot = iswrot + 1
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq ) / aapq
                                      if( aaqq>aapp0 )theta = -theta
                                      if( abs( theta )>bigtheta ) then
                                         t = half / theta
                                         fastr( 3 ) = t*work( p ) / work( q )
                                         fastr( 4 ) = -t*work( q ) /work( p )
                                         call stdlib_srotm( m, a( 1, p ), 1,a( 1, q ), 1, fastr )
                                                   
                                         if( rsvec )call stdlib_srotm( mvl,v( 1, p ), 1,v( 1, q ),&
                                                    1,fastr )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq )
                                         if( aaqq>aapp0 )thsign = -thsign
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         apoaq = work( p ) / work( q )
                                         aqoap = work( q ) / work( p )
                                         if( work( p )>=one ) then
                                            if( work( q )>=one ) then
                                               fastr( 3 ) = t*apoaq
                                               fastr( 4 ) = -t*aqoap
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q )*cs
                                               call stdlib_srotm( m, a( 1, p ), 1,a( 1, q ), 1,&
                                                         fastr )
                                               if( rsvec )call stdlib_srotm( mvl,v( 1, p ), 1, v( &
                                                         1, q ),1, fastr )
                                            else
                                               call stdlib_saxpy( m, -t*aqoap,a( 1, q ), 1,a( 1, &
                                                         p ), 1 )
                                               call stdlib_saxpy( m, cs*sn*apoaq,a( 1, p ), 1,a( &
                                                         1, q ), 1 )
                                               if( rsvec ) then
                                                  call stdlib_saxpy( mvl, -t*aqoap,v( 1, q ), 1,v(&
                                                             1, p ), 1 )
                                                  call stdlib_saxpy( mvl,cs*sn*apoaq,v( 1, p ), 1,&
                                                            v( 1, q ), 1 )
                                               end if
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q ) / cs
                                            end if
                                         else
                                            if( work( q )>=one ) then
                                               call stdlib_saxpy( m, t*apoaq,a( 1, p ), 1,a( 1, q &
                                                         ), 1 )
                                               call stdlib_saxpy( m, -cs*sn*aqoap,a( 1, q ), 1,a( &
                                                         1, p ), 1 )
                                               if( rsvec ) then
                                                  call stdlib_saxpy( mvl, t*apoaq,v( 1, p ), 1,v( &
                                                            1, q ), 1 )
                                                  call stdlib_saxpy( mvl,-cs*sn*aqoap,v( 1, q ), &
                                                            1,v( 1, p ), 1 )
                                               end if
                                               work( p ) = work( p ) / cs
                                               work( q ) = work( q )*cs
                                            else
                                               if( work( p )>=work( q ) )then
                                                  call stdlib_saxpy( m, -t*aqoap,a( 1, q ), 1,a( &
                                                            1, p ), 1 )
                                                  call stdlib_saxpy( m, cs*sn*apoaq,a( 1, p ), 1,&
                                                            a( 1, q ), 1 )
                                                  work( p ) = work( p )*cs
                                                  work( q ) = work( q ) / cs
                                                  if( rsvec ) then
                                                     call stdlib_saxpy( mvl,-t*aqoap,v( 1, q ), 1,&
                                                               v( 1, p ), 1 )
                                                     call stdlib_saxpy( mvl,cs*sn*apoaq,v( 1, p ),&
                                                                1,v( 1, q ), 1 )
                                                  end if
                                               else
                                                  call stdlib_saxpy( m, t*apoaq,a( 1, p ), 1,a( 1,&
                                                             q ), 1 )
                                                  call stdlib_saxpy( m,-cs*sn*aqoap,a( 1, q ), 1,&
                                                            a( 1, p ), 1 )
                                                  work( p ) = work( p ) / cs
                                                  work( q ) = work( q )*cs
                                                  if( rsvec ) then
                                                     call stdlib_saxpy( mvl,t*apoaq, v( 1, p ),1, &
                                                               v( 1, q ), 1 )
                                                     call stdlib_saxpy( mvl,-cs*sn*aqoap,v( 1, q )&
                                                               , 1,v( 1, p ), 1 )
                                                  end if
                                               end if
                                            end if
                                         end if
                                      end if
                                   else
                                      if( aapp>aaqq ) then
                                         call stdlib_scopy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                                   
                                         call stdlib_slascl( 'G', 0, 0, aapp, one,m, 1, work( n+1 &
                                                   ), lda,ierr )
                                         call stdlib_slascl( 'G', 0, 0, aaqq, one,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         temp1 = -aapq*work( p ) / work( q )
                                         call stdlib_saxpy( m, temp1, work( n+1 ),1, a( 1, q ), 1 &
                                                   )
                                         call stdlib_slascl( 'G', 0, 0, one, aaqq,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         sva( q ) = aaqq*sqrt( max( zero,one-aapq*aapq ) )
                                         mxsinj = max( mxsinj, sfmin )
                                      else
                                         call stdlib_scopy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                                   
                                         call stdlib_slascl( 'G', 0, 0, aaqq, one,m, 1, work( n+1 &
                                                   ), lda,ierr )
                                         call stdlib_slascl( 'G', 0, 0, aapp, one,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         temp1 = -aapq*work( q ) / work( p )
                                         call stdlib_saxpy( m, temp1, work( n+1 ),1, a( 1, p ), 1 &
                                                   )
                                         call stdlib_slascl( 'G', 0, 0, one, aapp,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         sva( p ) = aapp*sqrt( max( zero,one-aapq*aapq ) )
                                         mxsinj = max( mxsinj, sfmin )
                                      end if
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q)
                 ! .. recompute sva(q)
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_snrm2( m, a( 1, q ), 1 )*work( q )
                                                   
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_slassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )*work( q )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )**2<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_snrm2( m, a( 1, p ), 1 )*work( p )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_slassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )*work( p )
                                      end if
                                      sva( p ) = aapp
                                   end if
                    ! end of ok rotation
                                else
                                   notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                   ijblsk = ijblsk + 1
                                end if
                             else
                                notrot = notrot + 1
                                pskipped = pskipped + 1
                                ijblsk = ijblsk + 1
                             end if
                             if( ( i<=swband ) .and. ( ijblsk>=blskip ) )then
                                sva( p ) = aapp
                                notrot = 0
                                go to 2011
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                aapp = -aapp
                                notrot = 0
                                go to 2203
                             end if
                          end do loop_2200
              ! end of the q-loop
              2203 continue
                          sva( p ) = aapp
                       else
                          if( aapp==zero )notrot = notrot +min( jgl+kbl-1, n ) - jgl + 1
                          if( aapp<zero )notrot = 0
                       end if
                    end do loop_2100
           ! end of the p-loop
                 end do loop_2010
           ! end of the jbc-loop
           2011 continue
      ! 2011 bailed out of the jbc-loop
                 do p = igl, min( igl+kbl-1, n )
                    sva( p ) = abs( sva( p ) )
                 end do
      ! **
              end do loop_2000
      ! 2000 :: end of the ibr-loop
           ! .. update sva(n)
              if( ( sva( n )<rootbig ) .and. ( sva( n )>rootsfmin ) )then
                 sva( n ) = stdlib_snrm2( m, a( 1, n ), 1 )*work( n )
              else
                 t = zero
                 aapp = one
                 call stdlib_slassq( m, a( 1, n ), 1, t, aapp )
                 sva( n ) = t*sqrt( aapp )*work( n )
              end if
           ! additional steering devices
              if( ( i<swband ) .and. ( ( mxaapq<=roottol ) .or.( iswrot<=n ) ) )swband = i
              if( ( i>swband+1 ) .and. ( mxaapq<sqrt( real( n,KIND=sp) )*tol ) .and. ( real( n,&
                        KIND=sp)*mxaapq*mxsinj<tol ) ) then
                 go to 1994
              end if
              if( notrot>=emptsw )go to 1994
           end do loop_1993
           ! end i=1:nsweep loop
       ! #:( reaching this point means that the procedure has not converged.
           info = nsweep - 1
           go to 1995
           1994 continue
       ! #:) reaching this point means numerical convergence after the i-th
           ! sweep.
           info = 0
       ! #:) info = 0 confirms successful iterations.
       1995 continue
           ! sort the singular values and find how many are above
           ! the underflow threshold.
           n2 = 0
           n4 = 0
           do p = 1, n - 1
              q = stdlib_isamax( n-p+1, sva( p ), 1 ) + p - 1
              if( p/=q ) then
                 temp1 = sva( p )
                 sva( p ) = sva( q )
                 sva( q ) = temp1
                 temp1 = work( p )
                 work( p ) = work( q )
                 work( q ) = temp1
                 call stdlib_sswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                 if( rsvec )call stdlib_sswap( mvl, v( 1, p ), 1, v( 1, q ), 1 )
              end if
              if( sva( p )/=zero ) then
                 n4 = n4 + 1
                 if( sva( p )*skl>sfmin )n2 = n2 + 1
              end if
           end do
           if( sva( n )/=zero ) then
              n4 = n4 + 1
              if( sva( n )*skl>sfmin )n2 = n2 + 1
           end if
           ! normalize the left singular vectors.
           if( lsvec .or. uctol ) then
              do p = 1, n2
                 call stdlib_sscal( m, work( p ) / sva( p ), a( 1, p ), 1 )
              end do
           end if
           ! scale the product of jacobi rotations (assemble the fast rotations).
           if( rsvec ) then
              if( applv ) then
                 do p = 1, n
                    call stdlib_sscal( mvl, work( p ), v( 1, p ), 1 )
                 end do
              else
                 do p = 1, n
                    temp1 = one / stdlib_snrm2( mvl, v( 1, p ), 1 )
                    call stdlib_sscal( mvl, temp1, v( 1, p ), 1 )
                 end do
              end if
           end if
           ! undo scaling, if necessary (and possible).
           if( ( ( skl>one ) .and. ( sva( 1 )<( big / skl ) ) ).or. ( ( skl<one ) .and. ( sva( &
                     max( n2, 1 ) ) >( sfmin / skl ) ) ) ) then
              do p = 1, n
                 sva( p ) = skl*sva( p )
              end do
              skl = one
           end if
           work( 1 ) = skl
           ! the singular values of a are skl*sva(1:n). if skl/=one
           ! then some of the singular values may overflow or underflow and
           ! the spectrum is given in this factored representation.
           work( 2 ) = real( n4,KIND=sp)
           ! n4 is the number of computed nonzero singular values of a.
           work( 3 ) = real( n2,KIND=sp)
           ! n2 is the number of singular values of a greater than sfmin.
           ! if n2<n, sva(n2:n) contains zeros and/or denormalized numbers
           ! that may carry some information.
           work( 4 ) = real( i,KIND=sp)
           ! i is the index of the last sweep before declaring convergence.
           work( 5 ) = mxaapq
           ! mxaapq is the largest absolute value of scaled pivots in the
           ! last sweep
           work( 6 ) = mxsinj
           ! mxsinj is the largest absolute value of the sines of jacobi angles
           ! in the last sweep
           return
     end subroutine stdlib_sgesvj

     module pure subroutine stdlib_dgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, work, lwork, &
     !! DGESVJ computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^t,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N orthogonal matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
     !! DGESVJ can sometimes compute tiny singular values and their singular vectors much
     !! more accurately than other SVD routines, see below under Further Details.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldv, lwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), v(ldv,*), work(lwork)
           real(dp), intent(out) :: sva(n)
        ! =====================================================================
           ! Local Parameters 
           integer(ilp), parameter :: nsweep = 30
           
           
           ! Local Scalars 
           real(dp) :: aapp, aapp0, aapq, aaqq, apoaq, aqoap, big, bigtheta, cs, ctol, epsln, &
           large, mxaapq, mxsinj, rootbig, rooteps, rootsfmin, roottol, skl, sfmin, small, sn, t, &
                     temp1, theta, thsign, tol
           integer(ilp) :: blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1, iswrot, jbc, jgl, kbl, &
                     lkahead, mvl, n2, n34, n4, nbl, notrot, p, pskipped, q, rowskip, swband
           logical(lk) :: applv, goscale, lower, lsvec, noscale, rotok, rsvec, uctol, &
                     upper
           ! Local Arrays 
           real(dp) :: fastr(5)
           ! Intrinsic Functions 
           ! from lapack
           ! from lapack
           ! Executable Statements 
           ! test the input arguments
           lsvec = stdlib_lsame( jobu, 'U' )
           uctol = stdlib_lsame( jobu, 'C' )
           rsvec = stdlib_lsame( jobv, 'V' )
           applv = stdlib_lsame( jobv, 'A' )
           upper = stdlib_lsame( joba, 'U' )
           lower = stdlib_lsame( joba, 'L' )
           if( .not.( upper .or. lower .or. stdlib_lsame( joba, 'G' ) ) ) then
              info = -1
           else if( .not.( lsvec .or. uctol .or. stdlib_lsame( jobu, 'N' ) ) ) then
              info = -2
           else if( .not.( rsvec .or. applv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( ( n<0 ) .or. ( n>m ) ) then
              info = -5
           else if( lda<m ) then
              info = -7
           else if( mv<0 ) then
              info = -9
           else if( ( rsvec .and. ( ldv<n ) ) .or.( applv .and. ( ldv<mv ) ) ) then
              info = -11
           else if( uctol .and. ( work( 1 )<=one ) ) then
              info = -12
           else if( lwork<max( m+n, 6 ) ) then
              info = -13
           else
              info = 0
           end if
           ! #:(
           if( info/=0 ) then
              call stdlib_xerbla( 'DGESVJ', -info )
              return
           end if
       ! #:) quick return for void matrix
           if( ( m==0 ) .or. ( n==0 ) )return
           ! set numerical parameters
           ! the stopping criterion for jacobi rotations is
           ! max_{i<>j}|a(:,i)^t * a(:,j)|/(||a(:,i)||*||a(:,j)||) < ctol*eps
           ! where eps is the round-off and ctol is defined as follows:
           if( uctol ) then
              ! ... user controlled
              ctol = work( 1 )
           else
              ! ... default
              if( lsvec .or. rsvec .or. applv ) then
                 ctol = sqrt( real( m,KIND=dp) )
              else
                 ctol = real( m,KIND=dp)
              end if
           end if
           ! ... and the machine dependent parameters are
      ! [!]  (make sure that stdlib_dlamch() works properly on the target machine.)
           epsln = stdlib_dlamch( 'EPSILON' )
           rooteps = sqrt( epsln )
           sfmin = stdlib_dlamch( 'SAFEMINIMUM' )
           rootsfmin = sqrt( sfmin )
           small = sfmin / epsln
           big = stdlib_dlamch( 'OVERFLOW' )
           ! big         = one    / sfmin
           rootbig = one / rootsfmin
           large = big / sqrt( real( m*n,KIND=dp) )
           bigtheta = one / rooteps
           tol = ctol*epsln
           roottol = sqrt( tol )
           if( real( m,KIND=dp)*epsln>=one ) then
              info = -4
              call stdlib_xerbla( 'DGESVJ', -info )
              return
           end if
           ! initialize the right singular vector matrix.
           if( rsvec ) then
              mvl = n
              call stdlib_dlaset( 'A', mvl, n, zero, one, v, ldv )
           else if( applv ) then
              mvl = mv
           end if
           rsvec = rsvec .or. applv
           ! initialize sva( 1:n ) = ( ||a e_i||_2, i = 1:n )
      ! (!)  if necessary, scale a to protect the largest singular value
           ! from overflow. it is possible that saving the largest singular
           ! value destroys the information about the small ones.
           ! this initial scaling is almost minimal in the sense that the
           ! goal is to make sure that no column norm overflows, and that
           ! sqrt(n)*max_i sva(i) does not overflow. if infinite entries
           ! in a are detected, the procedure returns with info=-6.
           skl= one / sqrt( real( m,KIND=dp)*real( n,KIND=dp) )
           noscale = .true.
           goscale = .true.
           if( lower ) then
              ! the input matrix is m-by-n lower triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_dlassq( m-p+1, a( p, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'DGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl)
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else if( upper ) then
              ! the input matrix is m-by-n upper triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_dlassq( p, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'DGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl)
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else
              ! the input matrix is m-by-n general dense
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_dlassq( m, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'DGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl)
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           end if
           if( noscale )skl= one
           ! move the smaller part of the spectrum from the underflow threshold
      ! (!)  start by determining the position of the nonzero entries of the
           ! array sva() relative to ( sfmin, big ).
           aapp = zero
           aaqq = big
           do p = 1, n
              if( sva( p )/=zero )aaqq = min( aaqq, sva( p ) )
              aapp = max( aapp, sva( p ) )
           end do
       ! #:) quick return for zero matrix
           if( aapp==zero ) then
              if( lsvec )call stdlib_dlaset( 'G', m, n, zero, one, a, lda )
              work( 1 ) = one
              work( 2 ) = zero
              work( 3 ) = zero
              work( 4 ) = zero
              work( 5 ) = zero
              work( 6 ) = zero
              return
           end if
       ! #:) quick return for one-column matrix
           if( n==1 ) then
              if( lsvec )call stdlib_dlascl( 'G', 0, 0, sva( 1 ), skl, m, 1,a( 1, 1 ), lda, ierr )
                        
              work( 1 ) = one / skl
              if( sva( 1 )>=sfmin ) then
                 work( 2 ) = one
              else
                 work( 2 ) = zero
              end if
              work( 3 ) = zero
              work( 4 ) = zero
              work( 5 ) = zero
              work( 6 ) = zero
              return
           end if
           ! protect small singular values from underflow, and try to
           ! avoid underflows/overflows in computing jacobi rotations.
           sn = sqrt( sfmin / epsln )
           temp1 = sqrt( big / real( n,KIND=dp) )
           if( ( aapp<=sn ) .or. ( aaqq>=temp1 ) .or.( ( sn<=aaqq ) .and. ( aapp<=temp1 ) ) ) &
                     then
              temp1 = min( big, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp<=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( aapp*sqrt( real( n,KIND=dp) ) ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq>=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = max( sn / aaqq, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( sqrt( real( n,KIND=dp) )*aapp ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else
              temp1 = one
           end if
           ! scale, if necessary
           if( temp1/=one ) then
              call stdlib_dlascl( 'G', 0, 0, one, temp1, n, 1, sva, n, ierr )
           end if
           skl= temp1*skl
           if( skl/=one ) then
              call stdlib_dlascl( joba, 0, 0, one, skl, m, n, a, lda, ierr )
              skl= one / skl
           end if
           ! row-cyclic jacobi svd algorithm with column pivoting
           emptsw = ( n*( n-1 ) ) / 2
           notrot = 0
           fastr( 1 ) = zero
           ! a is represented in factored form a = a * diag(work), where diag(work)
           ! is initialized to identity. work is updated during fast scaled
           ! rotations.
           do q = 1, n
              work( q ) = one
           end do
           swband = 3
      ! [tp] swband is a tuning parameter [tp]. it is meaningful and effective
           ! if stdlib_dgesvj is used as a computational routine in the preconditioned
           ! jacobi svd algorithm stdlib_dgesvj. for sweeps i=1:swband the procedure
           ! works on pivots inside a band-like region around the diagonal.
           ! the boundaries are determined dynamically, based on the number of
           ! pivots above a threshold.
           kbl = min( 8, n )
      ! [tp] kbl is a tuning parameter that defines the tile size in the
           ! tiling of the p-q loops of pivot pairs. in general, an optimal
           ! value of kbl depends on the matrix dimensions and on the
           ! parameters of the computer's memory.
           nbl = n / kbl
           if( ( nbl*kbl )/=n )nbl = nbl + 1
           blskip = kbl**2
      ! [tp] blkskip is a tuning parameter that depends on swband and kbl.
           rowskip = min( 5, kbl )
      ! [tp] rowskip is a tuning parameter.
           lkahead = 1
      ! [tp] lkahead is a tuning parameter.
           ! quasi block transformations, using the lower (upper) triangular
           ! structure of the input matrix. the quasi-block-cycling usually
           ! invokes cubic convergence. big part of this cycle is done inside
           ! canonical subspaces of dimensions less than m.
           if( ( lower .or. upper ) .and. ( n>max( 64, 4*kbl ) ) ) then
      ! [tp] the number of partition levels and the actual partition are
           ! tuning parameters.
              n4 = n / 4
              n2 = n / 2
              n34 = 3*n4
              if( applv ) then
                 q = 0
              else
                 q = 1
              end if
              if( lower ) then
           ! this works very well on lower triangular matrices, in particular
           ! in the framework of the preconditioned jacobi svd (xgejsv).
           ! the idea is simple:
           ! [+ 0 0 0]   note that jacobi transformations of [0 0]
           ! [+ + 0 0]                                       [0 0]
           ! [+ + x 0]   actually work on [x 0]              [x 0]
           ! [+ + x x]                    [x x].             [x x]
                 call stdlib_dgsvj0( jobv, m-n34, n-n34, a( n34+1, n34+1 ), lda,work( n34+1 ), &
                 sva( n34+1 ), mvl,v( n34*q+1, n34+1 ), ldv, epsln, sfmin, tol,2, work( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_dgsvj0( jobv, m-n2, n34-n2, a( n2+1, n2+1 ), lda,work( n2+1 ), sva( &
                 n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 2,work( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_dgsvj1( jobv, m-n2, n-n2, n4, a( n2+1, n2+1 ), lda,work( n2+1 ), sva(&
                  n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, &
                            ierr )
                 call stdlib_dgsvj0( jobv, m-n4, n2-n4, a( n4+1, n4+1 ), lda,work( n4+1 ), sva( &
                 n4+1 ), mvl,v( n4*q+1, n4+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_dgsvj0( jobv, m, n4, a, lda, work, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 1, work( n+1 ), lwork-n,ierr )
                 call stdlib_dgsvj1( jobv, m, n2, n4, a, lda, work, sva, mvl, v,ldv, epsln, sfmin,&
                            tol, 1, work( n+1 ),lwork-n, ierr )
              else if( upper ) then
                 call stdlib_dgsvj0( jobv, n4, n4, a, lda, work, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 2, work( n+1 ), lwork-n,ierr )
                 call stdlib_dgsvj0( jobv, n2, n4, a( 1, n4+1 ), lda, work( n4+1 ),sva( n4+1 ), &
                 mvl, v( n4*q+1, n4+1 ), ldv,epsln, sfmin, tol, 1, work( n+1 ), lwork-n,ierr )
                           
                 call stdlib_dgsvj1( jobv, n2, n2, n4, a, lda, work, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, work( n+1 ),lwork-n, ierr )
                 call stdlib_dgsvj0( jobv, n2+n4, n4, a( 1, n2+1 ), lda,work( n2+1 ), sva( n2+1 ),&
                  mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, ierr )
                            
              end if
           end if
           ! .. row-cyclic pivot strategy with de rijk's pivoting ..
           loop_1993: do i = 1, nsweep
           ! .. go go go ...
              mxaapq = zero
              mxsinj = zero
              iswrot = 0
              notrot = 0
              pskipped = 0
           ! each sweep is unrolled using kbl-by-kbl tiles over the pivot pairs
           ! 1 <= p < q <= n. this is the first step toward a blocked implementation
           ! of the rotations. new implementation, based on block transformations,
           ! is under development.
              loop_2000: do ibr = 1, nbl
                 igl = ( ibr-1 )*kbl + 1
                 loop_1002: do ir1 = 0, min( lkahead, nbl-ibr )
                    igl = igl + ir1*kbl
                    loop_2001: do p = igl, min( igl+kbl-1, n-1 )
           ! .. de rijk's pivoting
                       q = stdlib_idamax( n-p+1, sva( p ), 1 ) + p - 1
                       if( p/=q ) then
                          call stdlib_dswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                          if( rsvec )call stdlib_dswap( mvl, v( 1, p ), 1,v( 1, q ), 1 )
                          temp1 = sva( p )
                          sva( p ) = sva( q )
                          sva( q ) = temp1
                          temp1 = work( p )
                          work( p ) = work( q )
                          work( q ) = temp1
                       end if
                       if( ir1==0 ) then
              ! column norms are periodically updated by explicit
              ! norm computation.
              ! caveat:
              ! unfortunately, some blas implementations compute stdlib_dnrm2(m,a(1,p),1)
              ! as sqrt(stdlib_ddot(m,a(1,p),1,a(1,p),1)), which may cause the result to
              ! overflow for ||a(:,p)||_2 > sqrt(overflow_threshold), and to
              ! underflow for ||a(:,p)||_2 < sqrt(underflow_threshold).
              ! hence, stdlib_dnrm2 cannot be trusted, not even in the case when
              ! the true norm is far from the under(over)flow boundaries.
              ! if properly implemented stdlib_dnrm2 is available, the if-then-else
              ! below should read "aapp = stdlib_dnrm2( m, a(1,p), 1 ) * work(p)".
                          if( ( sva( p )<rootbig ) .and.( sva( p )>rootsfmin ) ) then
                             sva( p ) = stdlib_dnrm2( m, a( 1, p ), 1 )*work( p )
                          else
                             temp1 = zero
                             aapp = one
                             call stdlib_dlassq( m, a( 1, p ), 1, temp1, aapp )
                             sva( p ) = temp1*sqrt( aapp )*work( p )
                          end if
                          aapp = sva( p )
                       else
                          aapp = sva( p )
                       end if
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2002: do q = p + 1, min( igl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
                                if( aaqq>=one ) then
                                   rotok = ( small*aapp )<=aaqq
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_ddot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_dcopy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_dlascl( 'G', 0, 0, aapp,work( p ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_ddot( m, work( n+1 ), 1,a( 1, q ), 1 )*work( &
                                                q ) / aaqq
                                   end if
                                else
                                   rotok = aapp<=( aaqq / small )
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_ddot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_dcopy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                      call stdlib_dlascl( 'G', 0, 0, aaqq,work( q ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_ddot( m, work( n+1 ), 1,a( 1, p ), 1 )*work( &
                                                p ) / aapp
                                   end if
                                end if
                                mxaapq = max( mxaapq, abs( aapq ) )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq )>tol ) then
                 ! Rotate
      ! [rtd]      rotated = rotated + one
                                   if( ir1==0 ) then
                                      notrot = 0
                                      pskipped = 0
                                      iswrot = iswrot + 1
                                   end if
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs(aqoap-apoaq)/aapq
                                      if( abs( theta )>bigtheta ) then
                                         t = half / theta
                                         fastr( 3 ) = t*work( p ) / work( q )
                                         fastr( 4 ) = -t*work( q ) /work( p )
                                         call stdlib_drotm( m, a( 1, p ), 1,a( 1, q ), 1, fastr )
                                                   
                                         if( rsvec )call stdlib_drotm( mvl,v( 1, p ), 1,v( 1, q ),&
                                                    1,fastr )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq )
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         apoaq = work( p ) / work( q )
                                         aqoap = work( q ) / work( p )
                                         if( work( p )>=one ) then
                                            if( work( q )>=one ) then
                                               fastr( 3 ) = t*apoaq
                                               fastr( 4 ) = -t*aqoap
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q )*cs
                                               call stdlib_drotm( m, a( 1, p ), 1,a( 1, q ), 1,&
                                                         fastr )
                                               if( rsvec )call stdlib_drotm( mvl,v( 1, p ), 1, v( &
                                                         1, q ),1, fastr )
                                            else
                                               call stdlib_daxpy( m, -t*aqoap,a( 1, q ), 1,a( 1, &
                                                         p ), 1 )
                                               call stdlib_daxpy( m, cs*sn*apoaq,a( 1, p ), 1,a( &
                                                         1, q ), 1 )
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q ) / cs
                                               if( rsvec ) then
                                                  call stdlib_daxpy( mvl, -t*aqoap,v( 1, q ), 1,v(&
                                                             1, p ), 1 )
                                                  call stdlib_daxpy( mvl,cs*sn*apoaq,v( 1, p ), 1,&
                                                            v( 1, q ), 1 )
                                               end if
                                            end if
                                         else
                                            if( work( q )>=one ) then
                                               call stdlib_daxpy( m, t*apoaq,a( 1, p ), 1,a( 1, q &
                                                         ), 1 )
                                               call stdlib_daxpy( m, -cs*sn*aqoap,a( 1, q ), 1,a( &
                                                         1, p ), 1 )
                                               work( p ) = work( p ) / cs
                                               work( q ) = work( q )*cs
                                               if( rsvec ) then
                                                  call stdlib_daxpy( mvl, t*apoaq,v( 1, p ), 1,v( &
                                                            1, q ), 1 )
                                                  call stdlib_daxpy( mvl,-cs*sn*aqoap,v( 1, q ), &
                                                            1,v( 1, p ), 1 )
                                               end if
                                            else
                                               if( work( p )>=work( q ) )then
                                                  call stdlib_daxpy( m, -t*aqoap,a( 1, q ), 1,a( &
                                                            1, p ), 1 )
                                                  call stdlib_daxpy( m, cs*sn*apoaq,a( 1, p ), 1,&
                                                            a( 1, q ), 1 )
                                                  work( p ) = work( p )*cs
                                                  work( q ) = work( q ) / cs
                                                  if( rsvec ) then
                                                     call stdlib_daxpy( mvl,-t*aqoap,v( 1, q ), 1,&
                                                               v( 1, p ), 1 )
                                                     call stdlib_daxpy( mvl,cs*sn*apoaq,v( 1, p ),&
                                                                1,v( 1, q ), 1 )
                                                  end if
                                               else
                                                  call stdlib_daxpy( m, t*apoaq,a( 1, p ), 1,a( 1,&
                                                             q ), 1 )
                                                  call stdlib_daxpy( m,-cs*sn*aqoap,a( 1, q ), 1,&
                                                            a( 1, p ), 1 )
                                                  work( p ) = work( p ) / cs
                                                  work( q ) = work( q )*cs
                                                  if( rsvec ) then
                                                     call stdlib_daxpy( mvl,t*apoaq, v( 1, p ),1, &
                                                               v( 1, q ), 1 )
                                                     call stdlib_daxpy( mvl,-cs*sn*aqoap,v( 1, q )&
                                                               , 1,v( 1, p ), 1 )
                                                  end if
                                               end if
                                            end if
                                         end if
                                      end if
                                   else
                    ! .. have to use modified gram-schmidt like transformation
                                      call stdlib_dcopy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_dlascl( 'G', 0, 0, aapp, one, m,1, work( n+1 ), &
                                                lda,ierr )
                                      call stdlib_dlascl( 'G', 0, 0, aaqq, one, m,1, a( 1, q ), &
                                                lda, ierr )
                                      temp1 = -aapq*work( p ) / work( q )
                                      call stdlib_daxpy( m, temp1, work( n+1 ), 1,a( 1, q ), 1 )
                                                
                                      call stdlib_dlascl( 'G', 0, 0, one, aaqq, m,1, a( 1, q ), &
                                                lda, ierr )
                                      sva( q ) = aaqq*sqrt( max( zero,one-aapq*aapq ) )
                                      mxsinj = max( mxsinj, sfmin )
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! recompute sva(q), sva(p).
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_dnrm2( m, a( 1, q ), 1 )*work( q )
                                                   
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_dlassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )*work( q )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_dnrm2( m, a( 1, p ), 1 )*work( p )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_dlassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )*work( p )
                                      end if
                                      sva( p ) = aapp
                                   end if
                                else
              ! a(:,p) and a(:,q) already numerically orthogonal
                                   if( ir1==0 )notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                end if
                             else
              ! a(:,q) is zero column
                                if( ir1==0 )notrot = notrot + 1
                                pskipped = pskipped + 1
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                if( ir1==0 )aapp = -aapp
                                notrot = 0
                                go to 2103
                             end if
                          end do loop_2002
           ! end q-loop
           2103 continue
           ! bailed out of q-loop
                          sva( p ) = aapp
                       else
                          sva( p ) = aapp
                          if( ( ir1==0 ) .and. ( aapp==zero ) )notrot = notrot + min( igl+kbl-1, &
                                    n ) - p
                       end if
                    end do loop_2001
           ! end of the p-loop
           ! end of doing the block ( ibr, ibr )
                 end do loop_1002
           ! end of ir1-loop
       ! ... go to the off diagonal blocks
                 igl = ( ibr-1 )*kbl + 1
                 loop_2010: do jbc = ibr + 1, nbl
                    jgl = ( jbc-1 )*kbl + 1
              ! doing the block at ( ibr, jbc )
                    ijblsk = 0
                    loop_2100: do p = igl, min( igl+kbl-1, n )
                       aapp = sva( p )
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2200: do q = jgl, min( jgl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
           ! M X 2 Jacobi Svd 
              ! safe gram matrix computation
                                if( aaqq>=one ) then
                                   if( aapp>=aaqq ) then
                                      rotok = ( small*aapp )<=aaqq
                                   else
                                      rotok = ( small*aaqq )<=aapp
                                   end if
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_ddot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_dcopy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_dlascl( 'G', 0, 0, aapp,work( p ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_ddot( m, work( n+1 ), 1,a( 1, q ), 1 )*work( &
                                                q ) / aaqq
                                   end if
                                else
                                   if( aapp>=aaqq ) then
                                      rotok = aapp<=( aaqq / small )
                                   else
                                      rotok = aaqq<=( aapp / small )
                                   end if
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_ddot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_dcopy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                      call stdlib_dlascl( 'G', 0, 0, aaqq,work( q ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_ddot( m, work( n+1 ), 1,a( 1, p ), 1 )*work( &
                                                p ) / aapp
                                   end if
                                end if
                                mxaapq = max( mxaapq, abs( aapq ) )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq )>tol ) then
                                   notrot = 0
      ! [rtd]      rotated  = rotated + 1
                                   pskipped = 0
                                   iswrot = iswrot + 1
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs(aqoap-apoaq)/aapq
                                      if( aaqq>aapp0 )theta = -theta
                                      if( abs( theta )>bigtheta ) then
                                         t = half / theta
                                         fastr( 3 ) = t*work( p ) / work( q )
                                         fastr( 4 ) = -t*work( q ) /work( p )
                                         call stdlib_drotm( m, a( 1, p ), 1,a( 1, q ), 1, fastr )
                                                   
                                         if( rsvec )call stdlib_drotm( mvl,v( 1, p ), 1,v( 1, q ),&
                                                    1,fastr )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq )
                                         if( aaqq>aapp0 )thsign = -thsign
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         apoaq = work( p ) / work( q )
                                         aqoap = work( q ) / work( p )
                                         if( work( p )>=one ) then
                                            if( work( q )>=one ) then
                                               fastr( 3 ) = t*apoaq
                                               fastr( 4 ) = -t*aqoap
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q )*cs
                                               call stdlib_drotm( m, a( 1, p ), 1,a( 1, q ), 1,&
                                                         fastr )
                                               if( rsvec )call stdlib_drotm( mvl,v( 1, p ), 1, v( &
                                                         1, q ),1, fastr )
                                            else
                                               call stdlib_daxpy( m, -t*aqoap,a( 1, q ), 1,a( 1, &
                                                         p ), 1 )
                                               call stdlib_daxpy( m, cs*sn*apoaq,a( 1, p ), 1,a( &
                                                         1, q ), 1 )
                                               if( rsvec ) then
                                                  call stdlib_daxpy( mvl, -t*aqoap,v( 1, q ), 1,v(&
                                                             1, p ), 1 )
                                                  call stdlib_daxpy( mvl,cs*sn*apoaq,v( 1, p ), 1,&
                                                            v( 1, q ), 1 )
                                               end if
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q ) / cs
                                            end if
                                         else
                                            if( work( q )>=one ) then
                                               call stdlib_daxpy( m, t*apoaq,a( 1, p ), 1,a( 1, q &
                                                         ), 1 )
                                               call stdlib_daxpy( m, -cs*sn*aqoap,a( 1, q ), 1,a( &
                                                         1, p ), 1 )
                                               if( rsvec ) then
                                                  call stdlib_daxpy( mvl, t*apoaq,v( 1, p ), 1,v( &
                                                            1, q ), 1 )
                                                  call stdlib_daxpy( mvl,-cs*sn*aqoap,v( 1, q ), &
                                                            1,v( 1, p ), 1 )
                                               end if
                                               work( p ) = work( p ) / cs
                                               work( q ) = work( q )*cs
                                            else
                                               if( work( p )>=work( q ) )then
                                                  call stdlib_daxpy( m, -t*aqoap,a( 1, q ), 1,a( &
                                                            1, p ), 1 )
                                                  call stdlib_daxpy( m, cs*sn*apoaq,a( 1, p ), 1,&
                                                            a( 1, q ), 1 )
                                                  work( p ) = work( p )*cs
                                                  work( q ) = work( q ) / cs
                                                  if( rsvec ) then
                                                     call stdlib_daxpy( mvl,-t*aqoap,v( 1, q ), 1,&
                                                               v( 1, p ), 1 )
                                                     call stdlib_daxpy( mvl,cs*sn*apoaq,v( 1, p ),&
                                                                1,v( 1, q ), 1 )
                                                  end if
                                               else
                                                  call stdlib_daxpy( m, t*apoaq,a( 1, p ), 1,a( 1,&
                                                             q ), 1 )
                                                  call stdlib_daxpy( m,-cs*sn*aqoap,a( 1, q ), 1,&
                                                            a( 1, p ), 1 )
                                                  work( p ) = work( p ) / cs
                                                  work( q ) = work( q )*cs
                                                  if( rsvec ) then
                                                     call stdlib_daxpy( mvl,t*apoaq, v( 1, p ),1, &
                                                               v( 1, q ), 1 )
                                                     call stdlib_daxpy( mvl,-cs*sn*aqoap,v( 1, q )&
                                                               , 1,v( 1, p ), 1 )
                                                  end if
                                               end if
                                            end if
                                         end if
                                      end if
                                   else
                                      if( aapp>aaqq ) then
                                         call stdlib_dcopy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                                   
                                         call stdlib_dlascl( 'G', 0, 0, aapp, one,m, 1, work( n+1 &
                                                   ), lda,ierr )
                                         call stdlib_dlascl( 'G', 0, 0, aaqq, one,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         temp1 = -aapq*work( p ) / work( q )
                                         call stdlib_daxpy( m, temp1, work( n+1 ),1, a( 1, q ), 1 &
                                                   )
                                         call stdlib_dlascl( 'G', 0, 0, one, aaqq,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         sva( q ) = aaqq*sqrt( max( zero,one-aapq*aapq ) )
                                         mxsinj = max( mxsinj, sfmin )
                                      else
                                         call stdlib_dcopy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                                   
                                         call stdlib_dlascl( 'G', 0, 0, aaqq, one,m, 1, work( n+1 &
                                                   ), lda,ierr )
                                         call stdlib_dlascl( 'G', 0, 0, aapp, one,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         temp1 = -aapq*work( q ) / work( p )
                                         call stdlib_daxpy( m, temp1, work( n+1 ),1, a( 1, p ), 1 &
                                                   )
                                         call stdlib_dlascl( 'G', 0, 0, one, aapp,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         sva( p ) = aapp*sqrt( max( zero,one-aapq*aapq ) )
                                         mxsinj = max( mxsinj, sfmin )
                                      end if
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q)
                 ! .. recompute sva(q)
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_dnrm2( m, a( 1, q ), 1 )*work( q )
                                                   
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_dlassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )*work( q )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )**2<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_dnrm2( m, a( 1, p ), 1 )*work( p )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_dlassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )*work( p )
                                      end if
                                      sva( p ) = aapp
                                   end if
                    ! end of ok rotation
                                else
                                   notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                   ijblsk = ijblsk + 1
                                end if
                             else
                                notrot = notrot + 1
                                pskipped = pskipped + 1
                                ijblsk = ijblsk + 1
                             end if
                             if( ( i<=swband ) .and. ( ijblsk>=blskip ) )then
                                sva( p ) = aapp
                                notrot = 0
                                go to 2011
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                aapp = -aapp
                                notrot = 0
                                go to 2203
                             end if
                          end do loop_2200
              ! end of the q-loop
              2203 continue
                          sva( p ) = aapp
                       else
                          if( aapp==zero )notrot = notrot +min( jgl+kbl-1, n ) - jgl + 1
                          if( aapp<zero )notrot = 0
                       end if
                    end do loop_2100
           ! end of the p-loop
                 end do loop_2010
           ! end of the jbc-loop
           2011 continue
      ! 2011 bailed out of the jbc-loop
                 do p = igl, min( igl+kbl-1, n )
                    sva( p ) = abs( sva( p ) )
                 end do
      ! **
              end do loop_2000
      ! 2000 :: end of the ibr-loop
           ! .. update sva(n)
              if( ( sva( n )<rootbig ) .and. ( sva( n )>rootsfmin ) )then
                 sva( n ) = stdlib_dnrm2( m, a( 1, n ), 1 )*work( n )
              else
                 t = zero
                 aapp = one
                 call stdlib_dlassq( m, a( 1, n ), 1, t, aapp )
                 sva( n ) = t*sqrt( aapp )*work( n )
              end if
           ! additional steering devices
              if( ( i<swband ) .and. ( ( mxaapq<=roottol ) .or.( iswrot<=n ) ) )swband = i
              if( ( i>swband+1 ) .and. ( mxaapq<sqrt( real( n,KIND=dp) )*tol ) .and. ( real( n,&
                        KIND=dp)*mxaapq*mxsinj<tol ) ) then
                 go to 1994
              end if
              if( notrot>=emptsw )go to 1994
           end do loop_1993
           ! end i=1:nsweep loop
       ! #:( reaching this point means that the procedure has not converged.
           info = nsweep - 1
           go to 1995
           1994 continue
       ! #:) reaching this point means numerical convergence after the i-th
           ! sweep.
           info = 0
       ! #:) info = 0 confirms successful iterations.
       1995 continue
           ! sort the singular values and find how many are above
           ! the underflow threshold.
           n2 = 0
           n4 = 0
           do p = 1, n - 1
              q = stdlib_idamax( n-p+1, sva( p ), 1 ) + p - 1
              if( p/=q ) then
                 temp1 = sva( p )
                 sva( p ) = sva( q )
                 sva( q ) = temp1
                 temp1 = work( p )
                 work( p ) = work( q )
                 work( q ) = temp1
                 call stdlib_dswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                 if( rsvec )call stdlib_dswap( mvl, v( 1, p ), 1, v( 1, q ), 1 )
              end if
              if( sva( p )/=zero ) then
                 n4 = n4 + 1
                 if( sva( p )*skl>sfmin )n2 = n2 + 1
              end if
           end do
           if( sva( n )/=zero ) then
              n4 = n4 + 1
              if( sva( n )*skl>sfmin )n2 = n2 + 1
           end if
           ! normalize the left singular vectors.
           if( lsvec .or. uctol ) then
              do p = 1, n2
                 call stdlib_dscal( m, work( p ) / sva( p ), a( 1, p ), 1 )
              end do
           end if
           ! scale the product of jacobi rotations (assemble the fast rotations).
           if( rsvec ) then
              if( applv ) then
                 do p = 1, n
                    call stdlib_dscal( mvl, work( p ), v( 1, p ), 1 )
                 end do
              else
                 do p = 1, n
                    temp1 = one / stdlib_dnrm2( mvl, v( 1, p ), 1 )
                    call stdlib_dscal( mvl, temp1, v( 1, p ), 1 )
                 end do
              end if
           end if
           ! undo scaling, if necessary (and possible).
           if( ( ( skl>one ) .and. ( sva( 1 )<( big / skl) ) ).or. ( ( skl<one ) .and. ( sva( max(&
                      n2, 1 ) ) >( sfmin / skl) ) ) ) then
              do p = 1, n
                 sva( p ) = skl*sva( p )
              end do
              skl= one
           end if
           work( 1 ) = skl
           ! the singular values of a are skl*sva(1:n). if skl/=one
           ! then some of the singular values may overflow or underflow and
           ! the spectrum is given in this factored representation.
           work( 2 ) = real( n4,KIND=dp)
           ! n4 is the number of computed nonzero singular values of a.
           work( 3 ) = real( n2,KIND=dp)
           ! n2 is the number of singular values of a greater than sfmin.
           ! if n2<n, sva(n2:n) contains zeros and/or denormalized numbers
           ! that may carry some information.
           work( 4 ) = real( i,KIND=dp)
           ! i is the index of the last sweep before declaring convergence.
           work( 5 ) = mxaapq
           ! mxaapq is the largest absolute value of scaled pivots in the
           ! last sweep
           work( 6 ) = mxsinj
           ! mxsinj is the largest absolute value of the sines of jacobi angles
           ! in the last sweep
           return
     end subroutine stdlib_dgesvj

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$gesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, work, lwork, &
     !! DGESVJ: computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^t,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N orthogonal matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
     !! DGESVJ can sometimes compute tiny singular values and their singular vectors much
     !! more accurately than other SVD routines, see below under Further Details.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldv, lwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), v(ldv,*), work(lwork)
           real(${rk}$), intent(out) :: sva(n)
        ! =====================================================================
           ! Local Parameters 
           integer(ilp), parameter :: nsweep = 30
           
           
           ! Local Scalars 
           real(${rk}$) :: aapp, aapp0, aapq, aaqq, apoaq, aqoap, big, bigtheta, cs, ctol, epsln, &
           large, mxaapq, mxsinj, rootbig, rooteps, rootsfmin, roottol, skl, sfmin, small, sn, t, &
                     temp1, theta, thsign, tol
           integer(ilp) :: blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1, iswrot, jbc, jgl, kbl, &
                     lkahead, mvl, n2, n34, n4, nbl, notrot, p, pskipped, q, rowskip, swband
           logical(lk) :: applv, goscale, lower, lsvec, noscale, rotok, rsvec, uctol, &
                     upper
           ! Local Arrays 
           real(${rk}$) :: fastr(5)
           ! Intrinsic Functions 
           ! from lapack
           ! from lapack
           ! Executable Statements 
           ! test the input arguments
           lsvec = stdlib_lsame( jobu, 'U' )
           uctol = stdlib_lsame( jobu, 'C' )
           rsvec = stdlib_lsame( jobv, 'V' )
           applv = stdlib_lsame( jobv, 'A' )
           upper = stdlib_lsame( joba, 'U' )
           lower = stdlib_lsame( joba, 'L' )
           if( .not.( upper .or. lower .or. stdlib_lsame( joba, 'G' ) ) ) then
              info = -1
           else if( .not.( lsvec .or. uctol .or. stdlib_lsame( jobu, 'N' ) ) ) then
              info = -2
           else if( .not.( rsvec .or. applv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( ( n<0 ) .or. ( n>m ) ) then
              info = -5
           else if( lda<m ) then
              info = -7
           else if( mv<0 ) then
              info = -9
           else if( ( rsvec .and. ( ldv<n ) ) .or.( applv .and. ( ldv<mv ) ) ) then
              info = -11
           else if( uctol .and. ( work( 1 )<=one ) ) then
              info = -12
           else if( lwork<max( m+n, 6 ) ) then
              info = -13
           else
              info = 0
           end if
           ! #:(
           if( info/=0 ) then
              call stdlib_xerbla( 'DGESVJ', -info )
              return
           end if
       ! #:) quick return for void matrix
           if( ( m==0 ) .or. ( n==0 ) )return
           ! set numerical parameters
           ! the stopping criterion for jacobi rotations is
           ! max_{i<>j}|a(:,i)^t * a(:,j)|/(||a(:,i)||*||a(:,j)||) < ctol*eps
           ! where eps is the round-off and ctol is defined as follows:
           if( uctol ) then
              ! ... user controlled
              ctol = work( 1 )
           else
              ! ... default
              if( lsvec .or. rsvec .or. applv ) then
                 ctol = sqrt( real( m,KIND=${rk}$) )
              else
                 ctol = real( m,KIND=${rk}$)
              end if
           end if
           ! ... and the machine dependent parameters are
      ! [!]  (make sure that stdlib_${ri}$lamch() works properly on the target machine.)
           epsln = stdlib_${ri}$lamch( 'EPSILON' )
           rooteps = sqrt( epsln )
           sfmin = stdlib_${ri}$lamch( 'SAFEMINIMUM' )
           rootsfmin = sqrt( sfmin )
           small = sfmin / epsln
           big = stdlib_${ri}$lamch( 'OVERFLOW' )
           ! big         = one    / sfmin
           rootbig = one / rootsfmin
           large = big / sqrt( real( m*n,KIND=${rk}$) )
           bigtheta = one / rooteps
           tol = ctol*epsln
           roottol = sqrt( tol )
           if( real( m,KIND=${rk}$)*epsln>=one ) then
              info = -4
              call stdlib_xerbla( 'DGESVJ', -info )
              return
           end if
           ! initialize the right singular vector matrix.
           if( rsvec ) then
              mvl = n
              call stdlib_${ri}$laset( 'A', mvl, n, zero, one, v, ldv )
           else if( applv ) then
              mvl = mv
           end if
           rsvec = rsvec .or. applv
           ! initialize sva( 1:n ) = ( ||a e_i||_2, i = 1:n )
      ! (!)  if necessary, scale a to protect the largest singular value
           ! from overflow. it is possible that saving the largest singular
           ! value destroys the information about the small ones.
           ! this initial scaling is almost minimal in the sense that the
           ! goal is to make sure that no column norm overflows, and that
           ! sqrt(n)*max_i sva(i) does not overflow. if infinite entries
           ! in a are detected, the procedure returns with info=-6.
           skl= one / sqrt( real( m,KIND=${rk}$)*real( n,KIND=${rk}$) )
           noscale = .true.
           goscale = .true.
           if( lower ) then
              ! the input matrix is m-by-n lower triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_${ri}$lassq( m-p+1, a( p, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'DGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl)
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else if( upper ) then
              ! the input matrix is m-by-n upper triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_${ri}$lassq( p, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'DGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl)
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else
              ! the input matrix is m-by-n general dense
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_${ri}$lassq( m, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'DGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl)
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           end if
           if( noscale )skl= one
           ! move the smaller part of the spectrum from the underflow threshold
      ! (!)  start by determining the position of the nonzero entries of the
           ! array sva() relative to ( sfmin, big ).
           aapp = zero
           aaqq = big
           do p = 1, n
              if( sva( p )/=zero )aaqq = min( aaqq, sva( p ) )
              aapp = max( aapp, sva( p ) )
           end do
       ! #:) quick return for zero matrix
           if( aapp==zero ) then
              if( lsvec )call stdlib_${ri}$laset( 'G', m, n, zero, one, a, lda )
              work( 1 ) = one
              work( 2 ) = zero
              work( 3 ) = zero
              work( 4 ) = zero
              work( 5 ) = zero
              work( 6 ) = zero
              return
           end if
       ! #:) quick return for one-column matrix
           if( n==1 ) then
              if( lsvec )call stdlib_${ri}$lascl( 'G', 0, 0, sva( 1 ), skl, m, 1,a( 1, 1 ), lda, ierr )
                        
              work( 1 ) = one / skl
              if( sva( 1 )>=sfmin ) then
                 work( 2 ) = one
              else
                 work( 2 ) = zero
              end if
              work( 3 ) = zero
              work( 4 ) = zero
              work( 5 ) = zero
              work( 6 ) = zero
              return
           end if
           ! protect small singular values from underflow, and try to
           ! avoid underflows/overflows in computing jacobi rotations.
           sn = sqrt( sfmin / epsln )
           temp1 = sqrt( big / real( n,KIND=${rk}$) )
           if( ( aapp<=sn ) .or. ( aaqq>=temp1 ) .or.( ( sn<=aaqq ) .and. ( aapp<=temp1 ) ) ) &
                     then
              temp1 = min( big, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp<=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( aapp*sqrt( real( n,KIND=${rk}$) ) ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq>=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = max( sn / aaqq, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( sqrt( real( n,KIND=${rk}$) )*aapp ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else
              temp1 = one
           end if
           ! scale, if necessary
           if( temp1/=one ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, one, temp1, n, 1, sva, n, ierr )
           end if
           skl= temp1*skl
           if( skl/=one ) then
              call stdlib_${ri}$lascl( joba, 0, 0, one, skl, m, n, a, lda, ierr )
              skl= one / skl
           end if
           ! row-cyclic jacobi svd algorithm with column pivoting
           emptsw = ( n*( n-1 ) ) / 2
           notrot = 0
           fastr( 1 ) = zero
           ! a is represented in factored form a = a * diag(work), where diag(work)
           ! is initialized to identity. work is updated during fast scaled
           ! rotations.
           do q = 1, n
              work( q ) = one
           end do
           swband = 3
      ! [tp] swband is a tuning parameter [tp]. it is meaningful and effective
           ! if stdlib_${ri}$gesvj is used as a computational routine in the preconditioned
           ! jacobi svd algorithm stdlib_${ri}$gesvj. for sweeps i=1:swband the procedure
           ! works on pivots inside a band-like region around the diagonal.
           ! the boundaries are determined dynamically, based on the number of
           ! pivots above a threshold.
           kbl = min( 8, n )
      ! [tp] kbl is a tuning parameter that defines the tile size in the
           ! tiling of the p-q loops of pivot pairs. in general, an optimal
           ! value of kbl depends on the matrix dimensions and on the
           ! parameters of the computer's memory.
           nbl = n / kbl
           if( ( nbl*kbl )/=n )nbl = nbl + 1
           blskip = kbl**2
      ! [tp] blkskip is a tuning parameter that depends on swband and kbl.
           rowskip = min( 5, kbl )
      ! [tp] rowskip is a tuning parameter.
           lkahead = 1
      ! [tp] lkahead is a tuning parameter.
           ! quasi block transformations, using the lower (upper) triangular
           ! structure of the input matrix. the quasi-block-cycling usually
           ! invokes cubic convergence. big part of this cycle is done inside
           ! canonical subspaces of dimensions less than m.
           if( ( lower .or. upper ) .and. ( n>max( 64, 4*kbl ) ) ) then
      ! [tp] the number of partition levels and the actual partition are
           ! tuning parameters.
              n4 = n / 4
              n2 = n / 2
              n34 = 3*n4
              if( applv ) then
                 q = 0
              else
                 q = 1
              end if
              if( lower ) then
           ! this works very well on lower triangular matrices, in particular
           ! in the framework of the preconditioned jacobi svd (xgejsv).
           ! the idea is simple:
           ! [+ 0 0 0]   note that jacobi transformations of [0 0]
           ! [+ + 0 0]                                       [0 0]
           ! [+ + x 0]   actually work on [x 0]              [x 0]
           ! [+ + x x]                    [x x].             [x x]
                 call stdlib_${ri}$gsvj0( jobv, m-n34, n-n34, a( n34+1, n34+1 ), lda,work( n34+1 ), &
                 sva( n34+1 ), mvl,v( n34*q+1, n34+1 ), ldv, epsln, sfmin, tol,2, work( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_${ri}$gsvj0( jobv, m-n2, n34-n2, a( n2+1, n2+1 ), lda,work( n2+1 ), sva( &
                 n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 2,work( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_${ri}$gsvj1( jobv, m-n2, n-n2, n4, a( n2+1, n2+1 ), lda,work( n2+1 ), sva(&
                  n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, &
                            ierr )
                 call stdlib_${ri}$gsvj0( jobv, m-n4, n2-n4, a( n4+1, n4+1 ), lda,work( n4+1 ), sva( &
                 n4+1 ), mvl,v( n4*q+1, n4+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_${ri}$gsvj0( jobv, m, n4, a, lda, work, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 1, work( n+1 ), lwork-n,ierr )
                 call stdlib_${ri}$gsvj1( jobv, m, n2, n4, a, lda, work, sva, mvl, v,ldv, epsln, sfmin,&
                            tol, 1, work( n+1 ),lwork-n, ierr )
              else if( upper ) then
                 call stdlib_${ri}$gsvj0( jobv, n4, n4, a, lda, work, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 2, work( n+1 ), lwork-n,ierr )
                 call stdlib_${ri}$gsvj0( jobv, n2, n4, a( 1, n4+1 ), lda, work( n4+1 ),sva( n4+1 ), &
                 mvl, v( n4*q+1, n4+1 ), ldv,epsln, sfmin, tol, 1, work( n+1 ), lwork-n,ierr )
                           
                 call stdlib_${ri}$gsvj1( jobv, n2, n2, n4, a, lda, work, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, work( n+1 ),lwork-n, ierr )
                 call stdlib_${ri}$gsvj0( jobv, n2+n4, n4, a( 1, n2+1 ), lda,work( n2+1 ), sva( n2+1 ),&
                  mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, ierr )
                            
              end if
           end if
           ! .. row-cyclic pivot strategy with de rijk's pivoting ..
           loop_1993: do i = 1, nsweep
           ! .. go go go ...
              mxaapq = zero
              mxsinj = zero
              iswrot = 0
              notrot = 0
              pskipped = 0
           ! each sweep is unrolled using kbl-by-kbl tiles over the pivot pairs
           ! 1 <= p < q <= n. this is the first step toward a blocked implementation
           ! of the rotations. new implementation, based on block transformations,
           ! is under development.
              loop_2000: do ibr = 1, nbl
                 igl = ( ibr-1 )*kbl + 1
                 loop_1002: do ir1 = 0, min( lkahead, nbl-ibr )
                    igl = igl + ir1*kbl
                    loop_2001: do p = igl, min( igl+kbl-1, n-1 )
           ! .. de rijk's pivoting
                       q = stdlib_i${ri}$amax( n-p+1, sva( p ), 1 ) + p - 1
                       if( p/=q ) then
                          call stdlib_${ri}$swap( m, a( 1, p ), 1, a( 1, q ), 1 )
                          if( rsvec )call stdlib_${ri}$swap( mvl, v( 1, p ), 1,v( 1, q ), 1 )
                          temp1 = sva( p )
                          sva( p ) = sva( q )
                          sva( q ) = temp1
                          temp1 = work( p )
                          work( p ) = work( q )
                          work( q ) = temp1
                       end if
                       if( ir1==0 ) then
              ! column norms are periodically updated by explicit
              ! norm computation.
              ! caveat:
              ! unfortunately, some blas implementations compute stdlib_${ri}$nrm2(m,a(1,p),1)
              ! as sqrt(stdlib_${ri}$dot(m,a(1,p),1,a(1,p),1)), which may cause the result to
              ! overflow for ||a(:,p)||_2 > sqrt(overflow_threshold), and to
              ! underflow for ||a(:,p)||_2 < sqrt(underflow_threshold).
              ! hence, stdlib_${ri}$nrm2 cannot be trusted, not even in the case when
              ! the true norm is far from the under(over)flow boundaries.
              ! if properly implemented stdlib_${ri}$nrm2 is available, the if-then-else
              ! below should read "aapp = stdlib_${ri}$nrm2( m, a(1,p), 1 ) * work(p)".
                          if( ( sva( p )<rootbig ) .and.( sva( p )>rootsfmin ) ) then
                             sva( p ) = stdlib_${ri}$nrm2( m, a( 1, p ), 1 )*work( p )
                          else
                             temp1 = zero
                             aapp = one
                             call stdlib_${ri}$lassq( m, a( 1, p ), 1, temp1, aapp )
                             sva( p ) = temp1*sqrt( aapp )*work( p )
                          end if
                          aapp = sva( p )
                       else
                          aapp = sva( p )
                       end if
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2002: do q = p + 1, min( igl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
                                if( aaqq>=one ) then
                                   rotok = ( small*aapp )<=aaqq
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_${ri}$dot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_${ri}$copy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aapp,work( p ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_${ri}$dot( m, work( n+1 ), 1,a( 1, q ), 1 )*work( &
                                                q ) / aaqq
                                   end if
                                else
                                   rotok = aapp<=( aaqq / small )
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_${ri}$dot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_${ri}$copy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aaqq,work( q ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_${ri}$dot( m, work( n+1 ), 1,a( 1, p ), 1 )*work( &
                                                p ) / aapp
                                   end if
                                end if
                                mxaapq = max( mxaapq, abs( aapq ) )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq )>tol ) then
                 ! Rotate
      ! [rtd]      rotated = rotated + one
                                   if( ir1==0 ) then
                                      notrot = 0
                                      pskipped = 0
                                      iswrot = iswrot + 1
                                   end if
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs(aqoap-apoaq)/aapq
                                      if( abs( theta )>bigtheta ) then
                                         t = half / theta
                                         fastr( 3 ) = t*work( p ) / work( q )
                                         fastr( 4 ) = -t*work( q ) /work( p )
                                         call stdlib_${ri}$rotm( m, a( 1, p ), 1,a( 1, q ), 1, fastr )
                                                   
                                         if( rsvec )call stdlib_${ri}$rotm( mvl,v( 1, p ), 1,v( 1, q ),&
                                                    1,fastr )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq )
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         apoaq = work( p ) / work( q )
                                         aqoap = work( q ) / work( p )
                                         if( work( p )>=one ) then
                                            if( work( q )>=one ) then
                                               fastr( 3 ) = t*apoaq
                                               fastr( 4 ) = -t*aqoap
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q )*cs
                                               call stdlib_${ri}$rotm( m, a( 1, p ), 1,a( 1, q ), 1,&
                                                         fastr )
                                               if( rsvec )call stdlib_${ri}$rotm( mvl,v( 1, p ), 1, v( &
                                                         1, q ),1, fastr )
                                            else
                                               call stdlib_${ri}$axpy( m, -t*aqoap,a( 1, q ), 1,a( 1, &
                                                         p ), 1 )
                                               call stdlib_${ri}$axpy( m, cs*sn*apoaq,a( 1, p ), 1,a( &
                                                         1, q ), 1 )
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q ) / cs
                                               if( rsvec ) then
                                                  call stdlib_${ri}$axpy( mvl, -t*aqoap,v( 1, q ), 1,v(&
                                                             1, p ), 1 )
                                                  call stdlib_${ri}$axpy( mvl,cs*sn*apoaq,v( 1, p ), 1,&
                                                            v( 1, q ), 1 )
                                               end if
                                            end if
                                         else
                                            if( work( q )>=one ) then
                                               call stdlib_${ri}$axpy( m, t*apoaq,a( 1, p ), 1,a( 1, q &
                                                         ), 1 )
                                               call stdlib_${ri}$axpy( m, -cs*sn*aqoap,a( 1, q ), 1,a( &
                                                         1, p ), 1 )
                                               work( p ) = work( p ) / cs
                                               work( q ) = work( q )*cs
                                               if( rsvec ) then
                                                  call stdlib_${ri}$axpy( mvl, t*apoaq,v( 1, p ), 1,v( &
                                                            1, q ), 1 )
                                                  call stdlib_${ri}$axpy( mvl,-cs*sn*aqoap,v( 1, q ), &
                                                            1,v( 1, p ), 1 )
                                               end if
                                            else
                                               if( work( p )>=work( q ) )then
                                                  call stdlib_${ri}$axpy( m, -t*aqoap,a( 1, q ), 1,a( &
                                                            1, p ), 1 )
                                                  call stdlib_${ri}$axpy( m, cs*sn*apoaq,a( 1, p ), 1,&
                                                            a( 1, q ), 1 )
                                                  work( p ) = work( p )*cs
                                                  work( q ) = work( q ) / cs
                                                  if( rsvec ) then
                                                     call stdlib_${ri}$axpy( mvl,-t*aqoap,v( 1, q ), 1,&
                                                               v( 1, p ), 1 )
                                                     call stdlib_${ri}$axpy( mvl,cs*sn*apoaq,v( 1, p ),&
                                                                1,v( 1, q ), 1 )
                                                  end if
                                               else
                                                  call stdlib_${ri}$axpy( m, t*apoaq,a( 1, p ), 1,a( 1,&
                                                             q ), 1 )
                                                  call stdlib_${ri}$axpy( m,-cs*sn*aqoap,a( 1, q ), 1,&
                                                            a( 1, p ), 1 )
                                                  work( p ) = work( p ) / cs
                                                  work( q ) = work( q )*cs
                                                  if( rsvec ) then
                                                     call stdlib_${ri}$axpy( mvl,t*apoaq, v( 1, p ),1, &
                                                               v( 1, q ), 1 )
                                                     call stdlib_${ri}$axpy( mvl,-cs*sn*aqoap,v( 1, q )&
                                                               , 1,v( 1, p ), 1 )
                                                  end if
                                               end if
                                            end if
                                         end if
                                      end if
                                   else
                    ! .. have to use modified gram-schmidt like transformation
                                      call stdlib_${ri}$copy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aapp, one, m,1, work( n+1 ), &
                                                lda,ierr )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aaqq, one, m,1, a( 1, q ), &
                                                lda, ierr )
                                      temp1 = -aapq*work( p ) / work( q )
                                      call stdlib_${ri}$axpy( m, temp1, work( n+1 ), 1,a( 1, q ), 1 )
                                                
                                      call stdlib_${ri}$lascl( 'G', 0, 0, one, aaqq, m,1, a( 1, q ), &
                                                lda, ierr )
                                      sva( q ) = aaqq*sqrt( max( zero,one-aapq*aapq ) )
                                      mxsinj = max( mxsinj, sfmin )
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! recompute sva(q), sva(p).
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_${ri}$nrm2( m, a( 1, q ), 1 )*work( q )
                                                   
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_${ri}$lassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )*work( q )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_${ri}$nrm2( m, a( 1, p ), 1 )*work( p )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_${ri}$lassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )*work( p )
                                      end if
                                      sva( p ) = aapp
                                   end if
                                else
              ! a(:,p) and a(:,q) already numerically orthogonal
                                   if( ir1==0 )notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                end if
                             else
              ! a(:,q) is zero column
                                if( ir1==0 )notrot = notrot + 1
                                pskipped = pskipped + 1
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                if( ir1==0 )aapp = -aapp
                                notrot = 0
                                go to 2103
                             end if
                          end do loop_2002
           ! end q-loop
           2103 continue
           ! bailed out of q-loop
                          sva( p ) = aapp
                       else
                          sva( p ) = aapp
                          if( ( ir1==0 ) .and. ( aapp==zero ) )notrot = notrot + min( igl+kbl-1, &
                                    n ) - p
                       end if
                    end do loop_2001
           ! end of the p-loop
           ! end of doing the block ( ibr, ibr )
                 end do loop_1002
           ! end of ir1-loop
       ! ... go to the off diagonal blocks
                 igl = ( ibr-1 )*kbl + 1
                 loop_2010: do jbc = ibr + 1, nbl
                    jgl = ( jbc-1 )*kbl + 1
              ! doing the block at ( ibr, jbc )
                    ijblsk = 0
                    loop_2100: do p = igl, min( igl+kbl-1, n )
                       aapp = sva( p )
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2200: do q = jgl, min( jgl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
           ! M X 2 Jacobi Svd 
              ! safe gram matrix computation
                                if( aaqq>=one ) then
                                   if( aapp>=aaqq ) then
                                      rotok = ( small*aapp )<=aaqq
                                   else
                                      rotok = ( small*aaqq )<=aapp
                                   end if
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_${ri}$dot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_${ri}$copy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aapp,work( p ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_${ri}$dot( m, work( n+1 ), 1,a( 1, q ), 1 )*work( &
                                                q ) / aaqq
                                   end if
                                else
                                   if( aapp>=aaqq ) then
                                      rotok = aapp<=( aaqq / small )
                                   else
                                      rotok = aaqq<=( aapp / small )
                                   end if
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_${ri}$dot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_${ri}$copy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aaqq,work( q ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_${ri}$dot( m, work( n+1 ), 1,a( 1, p ), 1 )*work( &
                                                p ) / aapp
                                   end if
                                end if
                                mxaapq = max( mxaapq, abs( aapq ) )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq )>tol ) then
                                   notrot = 0
      ! [rtd]      rotated  = rotated + 1
                                   pskipped = 0
                                   iswrot = iswrot + 1
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs(aqoap-apoaq)/aapq
                                      if( aaqq>aapp0 )theta = -theta
                                      if( abs( theta )>bigtheta ) then
                                         t = half / theta
                                         fastr( 3 ) = t*work( p ) / work( q )
                                         fastr( 4 ) = -t*work( q ) /work( p )
                                         call stdlib_${ri}$rotm( m, a( 1, p ), 1,a( 1, q ), 1, fastr )
                                                   
                                         if( rsvec )call stdlib_${ri}$rotm( mvl,v( 1, p ), 1,v( 1, q ),&
                                                    1,fastr )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq )
                                         if( aaqq>aapp0 )thsign = -thsign
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         apoaq = work( p ) / work( q )
                                         aqoap = work( q ) / work( p )
                                         if( work( p )>=one ) then
                                            if( work( q )>=one ) then
                                               fastr( 3 ) = t*apoaq
                                               fastr( 4 ) = -t*aqoap
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q )*cs
                                               call stdlib_${ri}$rotm( m, a( 1, p ), 1,a( 1, q ), 1,&
                                                         fastr )
                                               if( rsvec )call stdlib_${ri}$rotm( mvl,v( 1, p ), 1, v( &
                                                         1, q ),1, fastr )
                                            else
                                               call stdlib_${ri}$axpy( m, -t*aqoap,a( 1, q ), 1,a( 1, &
                                                         p ), 1 )
                                               call stdlib_${ri}$axpy( m, cs*sn*apoaq,a( 1, p ), 1,a( &
                                                         1, q ), 1 )
                                               if( rsvec ) then
                                                  call stdlib_${ri}$axpy( mvl, -t*aqoap,v( 1, q ), 1,v(&
                                                             1, p ), 1 )
                                                  call stdlib_${ri}$axpy( mvl,cs*sn*apoaq,v( 1, p ), 1,&
                                                            v( 1, q ), 1 )
                                               end if
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q ) / cs
                                            end if
                                         else
                                            if( work( q )>=one ) then
                                               call stdlib_${ri}$axpy( m, t*apoaq,a( 1, p ), 1,a( 1, q &
                                                         ), 1 )
                                               call stdlib_${ri}$axpy( m, -cs*sn*aqoap,a( 1, q ), 1,a( &
                                                         1, p ), 1 )
                                               if( rsvec ) then
                                                  call stdlib_${ri}$axpy( mvl, t*apoaq,v( 1, p ), 1,v( &
                                                            1, q ), 1 )
                                                  call stdlib_${ri}$axpy( mvl,-cs*sn*aqoap,v( 1, q ), &
                                                            1,v( 1, p ), 1 )
                                               end if
                                               work( p ) = work( p ) / cs
                                               work( q ) = work( q )*cs
                                            else
                                               if( work( p )>=work( q ) )then
                                                  call stdlib_${ri}$axpy( m, -t*aqoap,a( 1, q ), 1,a( &
                                                            1, p ), 1 )
                                                  call stdlib_${ri}$axpy( m, cs*sn*apoaq,a( 1, p ), 1,&
                                                            a( 1, q ), 1 )
                                                  work( p ) = work( p )*cs
                                                  work( q ) = work( q ) / cs
                                                  if( rsvec ) then
                                                     call stdlib_${ri}$axpy( mvl,-t*aqoap,v( 1, q ), 1,&
                                                               v( 1, p ), 1 )
                                                     call stdlib_${ri}$axpy( mvl,cs*sn*apoaq,v( 1, p ),&
                                                                1,v( 1, q ), 1 )
                                                  end if
                                               else
                                                  call stdlib_${ri}$axpy( m, t*apoaq,a( 1, p ), 1,a( 1,&
                                                             q ), 1 )
                                                  call stdlib_${ri}$axpy( m,-cs*sn*aqoap,a( 1, q ), 1,&
                                                            a( 1, p ), 1 )
                                                  work( p ) = work( p ) / cs
                                                  work( q ) = work( q )*cs
                                                  if( rsvec ) then
                                                     call stdlib_${ri}$axpy( mvl,t*apoaq, v( 1, p ),1, &
                                                               v( 1, q ), 1 )
                                                     call stdlib_${ri}$axpy( mvl,-cs*sn*aqoap,v( 1, q )&
                                                               , 1,v( 1, p ), 1 )
                                                  end if
                                               end if
                                            end if
                                         end if
                                      end if
                                   else
                                      if( aapp>aaqq ) then
                                         call stdlib_${ri}$copy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                                   
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aapp, one,m, 1, work( n+1 &
                                                   ), lda,ierr )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aaqq, one,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         temp1 = -aapq*work( p ) / work( q )
                                         call stdlib_${ri}$axpy( m, temp1, work( n+1 ),1, a( 1, q ), 1 &
                                                   )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, one, aaqq,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         sva( q ) = aaqq*sqrt( max( zero,one-aapq*aapq ) )
                                         mxsinj = max( mxsinj, sfmin )
                                      else
                                         call stdlib_${ri}$copy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                                   
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aaqq, one,m, 1, work( n+1 &
                                                   ), lda,ierr )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aapp, one,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         temp1 = -aapq*work( q ) / work( p )
                                         call stdlib_${ri}$axpy( m, temp1, work( n+1 ),1, a( 1, p ), 1 &
                                                   )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, one, aapp,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         sva( p ) = aapp*sqrt( max( zero,one-aapq*aapq ) )
                                         mxsinj = max( mxsinj, sfmin )
                                      end if
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q)
                 ! .. recompute sva(q)
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_${ri}$nrm2( m, a( 1, q ), 1 )*work( q )
                                                   
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_${ri}$lassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )*work( q )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )**2<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_${ri}$nrm2( m, a( 1, p ), 1 )*work( p )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_${ri}$lassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )*work( p )
                                      end if
                                      sva( p ) = aapp
                                   end if
                    ! end of ok rotation
                                else
                                   notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                   ijblsk = ijblsk + 1
                                end if
                             else
                                notrot = notrot + 1
                                pskipped = pskipped + 1
                                ijblsk = ijblsk + 1
                             end if
                             if( ( i<=swband ) .and. ( ijblsk>=blskip ) )then
                                sva( p ) = aapp
                                notrot = 0
                                go to 2011
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                aapp = -aapp
                                notrot = 0
                                go to 2203
                             end if
                          end do loop_2200
              ! end of the q-loop
              2203 continue
                          sva( p ) = aapp
                       else
                          if( aapp==zero )notrot = notrot +min( jgl+kbl-1, n ) - jgl + 1
                          if( aapp<zero )notrot = 0
                       end if
                    end do loop_2100
           ! end of the p-loop
                 end do loop_2010
           ! end of the jbc-loop
           2011 continue
      ! 2011 bailed out of the jbc-loop
                 do p = igl, min( igl+kbl-1, n )
                    sva( p ) = abs( sva( p ) )
                 end do
      ! **
              end do loop_2000
      ! 2000 :: end of the ibr-loop
           ! .. update sva(n)
              if( ( sva( n )<rootbig ) .and. ( sva( n )>rootsfmin ) )then
                 sva( n ) = stdlib_${ri}$nrm2( m, a( 1, n ), 1 )*work( n )
              else
                 t = zero
                 aapp = one
                 call stdlib_${ri}$lassq( m, a( 1, n ), 1, t, aapp )
                 sva( n ) = t*sqrt( aapp )*work( n )
              end if
           ! additional steering devices
              if( ( i<swband ) .and. ( ( mxaapq<=roottol ) .or.( iswrot<=n ) ) )swband = i
              if( ( i>swband+1 ) .and. ( mxaapq<sqrt( real( n,KIND=${rk}$) )*tol ) .and. ( real( n,&
                        KIND=${rk}$)*mxaapq*mxsinj<tol ) ) then
                 go to 1994
              end if
              if( notrot>=emptsw )go to 1994
           end do loop_1993
           ! end i=1:nsweep loop
       ! #:( reaching this point means that the procedure has not converged.
           info = nsweep - 1
           go to 1995
           1994 continue
       ! #:) reaching this point means numerical convergence after the i-th
           ! sweep.
           info = 0
       ! #:) info = 0 confirms successful iterations.
       1995 continue
           ! sort the singular values and find how many are above
           ! the underflow threshold.
           n2 = 0
           n4 = 0
           do p = 1, n - 1
              q = stdlib_i${ri}$amax( n-p+1, sva( p ), 1 ) + p - 1
              if( p/=q ) then
                 temp1 = sva( p )
                 sva( p ) = sva( q )
                 sva( q ) = temp1
                 temp1 = work( p )
                 work( p ) = work( q )
                 work( q ) = temp1
                 call stdlib_${ri}$swap( m, a( 1, p ), 1, a( 1, q ), 1 )
                 if( rsvec )call stdlib_${ri}$swap( mvl, v( 1, p ), 1, v( 1, q ), 1 )
              end if
              if( sva( p )/=zero ) then
                 n4 = n4 + 1
                 if( sva( p )*skl>sfmin )n2 = n2 + 1
              end if
           end do
           if( sva( n )/=zero ) then
              n4 = n4 + 1
              if( sva( n )*skl>sfmin )n2 = n2 + 1
           end if
           ! normalize the left singular vectors.
           if( lsvec .or. uctol ) then
              do p = 1, n2
                 call stdlib_${ri}$scal( m, work( p ) / sva( p ), a( 1, p ), 1 )
              end do
           end if
           ! scale the product of jacobi rotations (assemble the fast rotations).
           if( rsvec ) then
              if( applv ) then
                 do p = 1, n
                    call stdlib_${ri}$scal( mvl, work( p ), v( 1, p ), 1 )
                 end do
              else
                 do p = 1, n
                    temp1 = one / stdlib_${ri}$nrm2( mvl, v( 1, p ), 1 )
                    call stdlib_${ri}$scal( mvl, temp1, v( 1, p ), 1 )
                 end do
              end if
           end if
           ! undo scaling, if necessary (and possible).
           if( ( ( skl>one ) .and. ( sva( 1 )<( big / skl) ) ).or. ( ( skl<one ) .and. ( sva( max(&
                      n2, 1 ) ) >( sfmin / skl) ) ) ) then
              do p = 1, n
                 sva( p ) = skl*sva( p )
              end do
              skl= one
           end if
           work( 1 ) = skl
           ! the singular values of a are skl*sva(1:n). if skl/=one
           ! then some of the singular values may overflow or underflow and
           ! the spectrum is given in this factored representation.
           work( 2 ) = real( n4,KIND=${rk}$)
           ! n4 is the number of computed nonzero singular values of a.
           work( 3 ) = real( n2,KIND=${rk}$)
           ! n2 is the number of singular values of a greater than sfmin.
           ! if n2<n, sva(n2:n) contains zeros and/or denormalized numbers
           ! that may carry some information.
           work( 4 ) = real( i,KIND=${rk}$)
           ! i is the index of the last sweep before declaring convergence.
           work( 5 ) = mxaapq
           ! mxaapq is the largest absolute value of scaled pivots in the
           ! last sweep
           work( 6 ) = mxsinj
           ! mxsinj is the largest absolute value of the sines of jacobi angles
           ! in the last sweep
           return
     end subroutine stdlib_${ri}$gesvj

#:endif
#:endfor

     module pure subroutine stdlib_cgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, cwork, lwork, &
     rwork, lrwork, info )
     !! CGESVJ computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N unitary matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldv, lwork, lrwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), v(ldv,*), cwork(lwork)
           real(sp), intent(inout) :: rwork(lrwork)
           real(sp), intent(out) :: sva(n)
        ! =====================================================================
           ! Local Parameters 
           integer(ilp), parameter :: nsweep = 30
           
           
           
           ! Local Scalars 
           complex(sp) :: aapq, ompq
           real(sp) :: aapp, aapp0, aapq1, aaqq, apoaq, aqoap, big, bigtheta, cs, ctol, epsln, &
           mxaapq, mxsinj, rootbig, rooteps, rootsfmin, roottol, skl, sfmin, small, sn, t, temp1, &
                     theta, thsign, tol
           integer(ilp) :: blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1, iswrot, jbc, jgl, kbl, &
                     lkahead, mvl, n2, n34, n4, nbl, notrot, p, pskipped, q, rowskip, swband
           logical(lk) :: applv, goscale, lower, lquery, lsvec, noscale, rotok, rsvec, uctol, &
                     upper
           ! Intrinsic Functions 
           ! from lapack
           ! from lapack
           ! Executable Statements 
           ! test the input arguments
           lsvec = stdlib_lsame( jobu, 'U' ) .or. stdlib_lsame( jobu, 'F' )
           uctol = stdlib_lsame( jobu, 'C' )
           rsvec = stdlib_lsame( jobv, 'V' ) .or. stdlib_lsame( jobv, 'J' )
           applv = stdlib_lsame( jobv, 'A' )
           upper = stdlib_lsame( joba, 'U' )
           lower = stdlib_lsame( joba, 'L' )
           lquery = ( lwork == -1 ) .or. ( lrwork == -1 )
           if( .not.( upper .or. lower .or. stdlib_lsame( joba, 'G' ) ) ) then
              info = -1
           else if( .not.( lsvec .or. uctol .or. stdlib_lsame( jobu, 'N' ) ) ) then
              info = -2
           else if( .not.( rsvec .or. applv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( ( n<0 ) .or. ( n>m ) ) then
              info = -5
           else if( lda<m ) then
              info = -7
           else if( mv<0 ) then
              info = -9
           else if( ( rsvec .and. ( ldv<n ) ) .or.( applv .and. ( ldv<mv ) ) ) then
              info = -11
           else if( uctol .and. ( rwork( 1 )<=one ) ) then
              info = -12
           else if( lwork<( m+n ) .and. ( .not.lquery ) ) then
              info = -13
           else if( lrwork<max( n, 6 ) .and. ( .not.lquery ) ) then
              info = -15
           else
              info = 0
           end if
           ! #:(
           if( info/=0 ) then
              call stdlib_xerbla( 'CGESVJ', -info )
              return
           else if ( lquery ) then
              cwork(1) = m + n
              rwork(1) = max( n, 6 )
              return
           end if
       ! #:) quick return for void matrix
           if( ( m==0 ) .or. ( n==0 ) )return
           ! set numerical parameters
           ! the stopping criterion for jacobi rotations is
           ! max_{i<>j}|a(:,i)^* * a(:,j)| / (||a(:,i)||*||a(:,j)||) < ctol*eps
           ! where eps is the round-off and ctol is defined as follows:
           if( uctol ) then
              ! ... user controlled
              ctol = rwork( 1 )
           else
              ! ... default
              if( lsvec .or. rsvec .or. applv ) then
                 ctol = sqrt( real( m,KIND=sp) )
              else
                 ctol = real( m,KIND=sp)
              end if
           end if
           ! ... and the machine dependent parameters are
      ! [!]  (make sure that stdlib_slamch() works properly on the target machine.)
           epsln = stdlib_slamch( 'EPSILON' )
           rooteps = sqrt( epsln )
           sfmin = stdlib_slamch( 'SAFEMINIMUM' )
           rootsfmin = sqrt( sfmin )
           small = sfmin / epsln
            ! big = stdlib_slamch( 'overflow' )
           big     = one  / sfmin
           rootbig = one / rootsfmin
           ! large = big / sqrt( real( m*n,KIND=sp) )
           bigtheta = one / rooteps
           tol = ctol*epsln
           roottol = sqrt( tol )
           if( real( m,KIND=sp)*epsln>=one ) then
              info = -4
              call stdlib_xerbla( 'CGESVJ', -info )
              return
           end if
           ! initialize the right singular vector matrix.
           if( rsvec ) then
              mvl = n
              call stdlib_claset( 'A', mvl, n, czero, cone, v, ldv )
           else if( applv ) then
              mvl = mv
           end if
           rsvec = rsvec .or. applv
           ! initialize sva( 1:n ) = ( ||a e_i||_2, i = 1:n )
      ! (!)  if necessary, scale a to protect the largest singular value
           ! from overflow. it is possible that saving the largest singular
           ! value destroys the information about the small ones.
           ! this initial scaling is almost minimal in the sense that the
           ! goal is to make sure that no column norm overflows, and that
           ! sqrt(n)*max_i sva(i) does not overflow. if infinite entries
           ! in a are detected, the procedure returns with info=-6.
           skl = one / sqrt( real( m,KIND=sp)*real( n,KIND=sp) )
           noscale = .true.
           goscale = .true.
           if( lower ) then
              ! the input matrix is m-by-n lower triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_classq( m-p+1, a( p, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'CGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else if( upper ) then
              ! the input matrix is m-by-n upper triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_classq( p, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'CGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else
              ! the input matrix is m-by-n general dense
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_classq( m, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'CGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           end if
           if( noscale )skl = one
           ! move the smaller part of the spectrum from the underflow threshold
      ! (!)  start by determining the position of the nonzero entries of the
           ! array sva() relative to ( sfmin, big ).
           aapp = zero
           aaqq = big
           do p = 1, n
              if( sva( p )/=zero )aaqq = min( aaqq, sva( p ) )
              aapp = max( aapp, sva( p ) )
           end do
       ! #:) quick return for zero matrix
           if( aapp==zero ) then
              if( lsvec )call stdlib_claset( 'G', m, n, czero, cone, a, lda )
              rwork( 1 ) = one
              rwork( 2 ) = zero
              rwork( 3 ) = zero
              rwork( 4 ) = zero
              rwork( 5 ) = zero
              rwork( 6 ) = zero
              return
           end if
       ! #:) quick return for one-column matrix
           if( n==1 ) then
              if( lsvec )call stdlib_clascl( 'G', 0, 0, sva( 1 ), skl, m, 1,a( 1, 1 ), lda, ierr )
                        
              rwork( 1 ) = one / skl
              if( sva( 1 )>=sfmin ) then
                 rwork( 2 ) = one
              else
                 rwork( 2 ) = zero
              end if
              rwork( 3 ) = zero
              rwork( 4 ) = zero
              rwork( 5 ) = zero
              rwork( 6 ) = zero
              return
           end if
           ! protect small singular values from underflow, and try to
           ! avoid underflows/overflows in computing jacobi rotations.
           sn = sqrt( sfmin / epsln )
           temp1 = sqrt( big / real( n,KIND=sp) )
           if( ( aapp<=sn ) .or. ( aaqq>=temp1 ) .or.( ( sn<=aaqq ) .and. ( aapp<=temp1 ) ) ) &
                     then
              temp1 = min( big, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp<=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( aapp*sqrt( real( n,KIND=sp) ) ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq>=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = max( sn / aaqq, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( sqrt( real( n,KIND=sp) )*aapp ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else
              temp1 = one
           end if
           ! scale, if necessary
           if( temp1/=one ) then
              call stdlib_slascl( 'G', 0, 0, one, temp1, n, 1, sva, n, ierr )
           end if
           skl = temp1*skl
           if( skl/=one ) then
              call stdlib_clascl( joba, 0, 0, one, skl, m, n, a, lda, ierr )
              skl = one / skl
           end if
           ! row-cyclic jacobi svd algorithm with column pivoting
           emptsw = ( n*( n-1 ) ) / 2
           notrot = 0
           do q = 1, n
              cwork( q ) = cone
           end do
           swband = 3
      ! [tp] swband is a tuning parameter [tp]. it is meaningful and effective
           ! if stdlib_cgesvj is used as a computational routine in the preconditioned
           ! jacobi svd algorithm stdlib_cgejsv. for sweeps i=1:swband the procedure
           ! works on pivots inside a band-like region around the diagonal.
           ! the boundaries are determined dynamically, based on the number of
           ! pivots above a threshold.
           kbl = min( 8, n )
      ! [tp] kbl is a tuning parameter that defines the tile size in the
           ! tiling of the p-q loops of pivot pairs. in general, an optimal
           ! value of kbl depends on the matrix dimensions and on the
           ! parameters of the computer's memory.
           nbl = n / kbl
           if( ( nbl*kbl )/=n )nbl = nbl + 1
           blskip = kbl**2
      ! [tp] blkskip is a tuning parameter that depends on swband and kbl.
           rowskip = min( 5, kbl )
      ! [tp] rowskip is a tuning parameter.
           lkahead = 1
      ! [tp] lkahead is a tuning parameter.
           ! quasi block transformations, using the lower (upper) triangular
           ! structure of the input matrix. the quasi-block-cycling usually
           ! invokes cubic convergence. big part of this cycle is done inside
           ! canonical subspaces of dimensions less than m.
           if( ( lower .or. upper ) .and. ( n>max( 64, 4*kbl ) ) ) then
      ! [tp] the number of partition levels and the actual partition are
           ! tuning parameters.
              n4 = n / 4
              n2 = n / 2
              n34 = 3*n4
              if( applv ) then
                 q = 0
              else
                 q = 1
              end if
              if( lower ) then
           ! this works very well on lower triangular matrices, in particular
           ! in the framework of the preconditioned jacobi svd (xgejsv).
           ! the idea is simple:
           ! [+ 0 0 0]   note that jacobi transformations of [0 0]
           ! [+ + 0 0]                                       [0 0]
           ! [+ + x 0]   actually work on [x 0]              [x 0]
           ! [+ + x x]                    [x x].             [x x]
                 call stdlib_cgsvj0( jobv, m-n34, n-n34, a( n34+1, n34+1 ), lda,cwork( n34+1 ), &
                 sva( n34+1 ), mvl,v( n34*q+1, n34+1 ), ldv, epsln, sfmin, tol,2, cwork( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_cgsvj0( jobv, m-n2, n34-n2, a( n2+1, n2+1 ), lda,cwork( n2+1 ), sva( &
                 n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 2,cwork( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_cgsvj1( jobv, m-n2, n-n2, n4, a( n2+1, n2+1 ), lda,cwork( n2+1 ), &
                 sva( n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_cgsvj0( jobv, m-n4, n2-n4, a( n4+1, n4+1 ), lda,cwork( n4+1 ), sva( &
                 n4+1 ), mvl,v( n4*q+1, n4+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_cgsvj0( jobv, m, n4, a, lda, cwork, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 1, cwork( n+1 ), lwork-n,ierr )
                 call stdlib_cgsvj1( jobv, m, n2, n4, a, lda, cwork, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, cwork( n+1 ),lwork-n, ierr )
              else if( upper ) then
                 call stdlib_cgsvj0( jobv, n4, n4, a, lda, cwork, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 2, cwork( n+1 ), lwork-n,ierr )
                 call stdlib_cgsvj0( jobv, n2, n4, a( 1, n4+1 ), lda, cwork( n4+1 ),sva( n4+1 ), &
                 mvl, v( n4*q+1, n4+1 ), ldv,epsln, sfmin, tol, 1, cwork( n+1 ), lwork-n,ierr )
                           
                 call stdlib_cgsvj1( jobv, n2, n2, n4, a, lda, cwork, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, cwork( n+1 ),lwork-n, ierr )
                 call stdlib_cgsvj0( jobv, n2+n4, n4, a( 1, n2+1 ), lda,cwork( n2+1 ), sva( n2+1 )&
                 , mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), lwork-n, ierr )
                           
              end if
           end if
           ! .. row-cyclic pivot strategy with de rijk's pivoting ..
           loop_1993: do i = 1, nsweep
           ! .. go go go ...
              mxaapq = zero
              mxsinj = zero
              iswrot = 0
              notrot = 0
              pskipped = 0
           ! each sweep is unrolled using kbl-by-kbl tiles over the pivot pairs
           ! 1 <= p < q <= n. this is the first step toward a blocked implementation
           ! of the rotations. new implementation, based on block transformations,
           ! is under development.
              loop_2000: do ibr = 1, nbl
                 igl = ( ibr-1 )*kbl + 1
                 loop_1002: do ir1 = 0, min( lkahead, nbl-ibr )
                    igl = igl + ir1*kbl
                    loop_2001: do p = igl, min( igl+kbl-1, n-1 )
           ! .. de rijk's pivoting
                       q = stdlib_isamax( n-p+1, sva( p ), 1 ) + p - 1
                       if( p/=q ) then
                          call stdlib_cswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                          if( rsvec )call stdlib_cswap( mvl, v( 1, p ), 1,v( 1, q ), 1 )
                          temp1 = sva( p )
                          sva( p ) = sva( q )
                          sva( q ) = temp1
                          aapq = cwork(p)
                          cwork(p) = cwork(q)
                          cwork(q) = aapq
                       end if
                       if( ir1==0 ) then
              ! column norms are periodically updated by explicit
              ! norm computation.
      ! [!]     caveat:
              ! unfortunately, some blas implementations compute stdlib_scnrm2(m,a(1,p),1)
              ! as sqrt(s=stdlib_cdotc(m,a(1,p),1,a(1,p),1)), which may cause the result to
              ! overflow for ||a(:,p)||_2 > sqrt(overflow_threshold), and to
              ! underflow for ||a(:,p)||_2 < sqrt(underflow_threshold).
              ! hence, stdlib_scnrm2 cannot be trusted, not even in the case when
              ! the true norm is far from the under(over)flow boundaries.
              ! if properly implemented stdlib_scnrm2 is available, the if-then-else-end if
              ! below should be replaced with "aapp = stdlib_scnrm2( m, a(1,p), 1 )".
                          if( ( sva( p )<rootbig ) .and.( sva( p )>rootsfmin ) ) then
                             sva( p ) = stdlib_scnrm2( m, a( 1, p ), 1 )
                          else
                             temp1 = zero
                             aapp = one
                             call stdlib_classq( m, a( 1, p ), 1, temp1, aapp )
                             sva( p ) = temp1*sqrt( aapp )
                          end if
                          aapp = sva( p )
                       else
                          aapp = sva( p )
                       end if
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2002: do q = p + 1, min( igl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
                                if( aaqq>=one ) then
                                   rotok = ( small*aapp )<=aaqq
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_cdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aaqq ) / aapp
                                   else
                                      call stdlib_ccopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_clascl( 'G', 0, 0, aapp, one,m, 1, cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_cdotc( m, cwork(n+1), 1,a( 1, q ), 1 ) / &
                                                aaqq
                                   end if
                                else
                                   rotok = aapp<=( aaqq / small )
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_cdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aapp ) / aaqq
                                   else
                                      call stdlib_ccopy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                      call stdlib_clascl( 'G', 0, 0, aaqq,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_cdotc( m, a(1, p ), 1,cwork(n+1), 1 ) / &
                                                aapp
                                   end if
                                end if
                                 ! aapq = aapq * conjg( cwork(p) ) * cwork(q)
                                aapq1  = -abs(aapq)
                                mxaapq = max( mxaapq, -aapq1 )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq1 )>tol ) then
                                    ompq = aapq / abs(aapq)
                 ! Rotate
      ! [rtd]      rotated = rotated + one
                                   if( ir1==0 ) then
                                      notrot = 0
                                      pskipped = 0
                                      iswrot = iswrot + 1
                                   end if
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/aapq1
                                      if( abs( theta )>bigtheta ) then
                                         t  = half / theta
                                         cs = one
                                         call stdlib_crot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *t )
                                         if ( rsvec ) then
                                             call stdlib_crot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*t )
                                         end if
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq1 )
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         call stdlib_crot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *sn )
                                         if ( rsvec ) then
                                             call stdlib_crot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*sn )
                                         end if
                                      end if
                                      cwork(p) = -cwork(q) * ompq
                                      else
                    ! .. have to use modified gram-schmidt like transformation
                                      call stdlib_ccopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_clascl( 'G', 0, 0, aapp, one, m,1, cwork(n+1), &
                                                lda,ierr )
                                      call stdlib_clascl( 'G', 0, 0, aaqq, one, m,1, a( 1, q ), &
                                                lda, ierr )
                                      call stdlib_caxpy( m, -aapq, cwork(n+1), 1,a( 1, q ), 1 )
                                                
                                      call stdlib_clascl( 'G', 0, 0, one, aaqq, m,1, a( 1, q ), &
                                                lda, ierr )
                                      sva( q ) = aaqq*sqrt( max( zero,one-aapq1*aapq1 ) )
                                      mxsinj = max( mxsinj, sfmin )
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! recompute sva(q), sva(p).
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_scnrm2( m, a( 1, q ), 1 )
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_classq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_scnrm2( m, a( 1, p ), 1 )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_classq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )
                                      end if
                                      sva( p ) = aapp
                                   end if
                                else
                                   ! a(:,p) and a(:,q) already numerically orthogonal
                                   if( ir1==0 )notrot = notrot + 1
      ! [rtd]      skipped  = skipped + 1
                                   pskipped = pskipped + 1
                                end if
                             else
                                ! a(:,q) is zero column
                                if( ir1==0 )notrot = notrot + 1
                                pskipped = pskipped + 1
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                if( ir1==0 )aapp = -aapp
                                notrot = 0
                                go to 2103
                             end if
                          end do loop_2002
           ! end q-loop
           2103 continue
           ! bailed out of q-loop
                          sva( p ) = aapp
                       else
                          sva( p ) = aapp
                          if( ( ir1==0 ) .and. ( aapp==zero ) )notrot = notrot + min( igl+kbl-1, &
                                    n ) - p
                       end if
                    end do loop_2001
           ! end of the p-loop
           ! end of doing the block ( ibr, ibr )
                 end do loop_1002
           ! end of ir1-loop
       ! ... go to the off diagonal blocks
                 igl = ( ibr-1 )*kbl + 1
                 loop_2010: do jbc = ibr + 1, nbl
                    jgl = ( jbc-1 )*kbl + 1
              ! doing the block at ( ibr, jbc )
                    ijblsk = 0
                    loop_2100: do p = igl, min( igl+kbl-1, n )
                       aapp = sva( p )
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2200: do q = jgl, min( jgl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
           ! M X 2 Jacobi Svd 
              ! safe gram matrix computation
                                if( aaqq>=one ) then
                                   if( aapp>=aaqq ) then
                                      rotok = ( small*aapp )<=aaqq
                                   else
                                      rotok = ( small*aaqq )<=aapp
                                   end if
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_cdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aaqq ) / aapp
                                   else
                                      call stdlib_ccopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_clascl( 'G', 0, 0, aapp,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_cdotc( m, cwork(n+1), 1,a( 1, q ), 1 ) / &
                                                aaqq
                                   end if
                                else
                                   if( aapp>=aaqq ) then
                                      rotok = aapp<=( aaqq / small )
                                   else
                                      rotok = aaqq<=( aapp / small )
                                   end if
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_cdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / max(&
                                                aaqq,aapp) )/ min(aaqq,aapp)
                                   else
                                      call stdlib_ccopy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                      call stdlib_clascl( 'G', 0, 0, aaqq,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_cdotc( m, a( 1, p ), 1,cwork(n+1),  1 ) / &
                                                aapp
                                   end if
                                end if
                                 ! aapq = aapq * conjg(cwork(p))*cwork(q)
                                aapq1  = -abs(aapq)
                                mxaapq = max( mxaapq, -aapq1 )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq1 )>tol ) then
                                   ompq = aapq / abs(aapq)
                                   notrot = 0
      ! [rtd]      rotated  = rotated + 1
                                   pskipped = 0
                                   iswrot = iswrot + 1
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/ aapq1
                                      if( aaqq>aapp0 )theta = -theta
                                      if( abs( theta )>bigtheta ) then
                                         t  = half / theta
                                         cs = one
                                         call stdlib_crot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *t )
                                         if( rsvec ) then
                                             call stdlib_crot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*t )
                                         end if
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq1 )
                                         if( aaqq>aapp0 )thsign = -thsign
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         call stdlib_crot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *sn )
                                         if( rsvec ) then
                                             call stdlib_crot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*sn )
                                         end if
                                      end if
                                      cwork(p) = -cwork(q) * ompq
                                   else
                    ! .. have to use modified gram-schmidt like transformation
                                    if( aapp>aaqq ) then
                                         call stdlib_ccopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                                   
                                         call stdlib_clascl( 'G', 0, 0, aapp, one,m, 1, cwork(n+1)&
                                                   ,lda,ierr )
                                         call stdlib_clascl( 'G', 0, 0, aaqq, one,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         call stdlib_caxpy( m, -aapq, cwork(n+1),1, a( 1, q ), 1 )
                                                   
                                         call stdlib_clascl( 'G', 0, 0, one, aaqq,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         sva( q ) = aaqq*sqrt( max( zero,one-aapq1*aapq1 ) )
                                                   
                                         mxsinj = max( mxsinj, sfmin )
                                    else
                                        call stdlib_ccopy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                         call stdlib_clascl( 'G', 0, 0, aaqq, one,m, 1, cwork(n+1)&
                                                   ,lda,ierr )
                                         call stdlib_clascl( 'G', 0, 0, aapp, one,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         call stdlib_caxpy( m, -conjg(aapq),cwork(n+1), 1, a( 1, &
                                                   p ), 1 )
                                         call stdlib_clascl( 'G', 0, 0, one, aapp,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         sva( p ) = aapp*sqrt( max( zero,one-aapq1*aapq1 ) )
                                                   
                                         mxsinj = max( mxsinj, sfmin )
                                    end if
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! .. recompute sva(q), sva(p)
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_scnrm2( m, a( 1, q ), 1)
                                       else
                                         t = zero
                                         aaqq = one
                                         call stdlib_classq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )**2<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_scnrm2( m, a( 1, p ), 1 )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_classq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )
                                      end if
                                      sva( p ) = aapp
                                   end if
                    ! end of ok rotation
                                else
                                   notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                   ijblsk = ijblsk + 1
                                end if
                             else
                                notrot = notrot + 1
                                pskipped = pskipped + 1
                                ijblsk = ijblsk + 1
                             end if
                             if( ( i<=swband ) .and. ( ijblsk>=blskip ) )then
                                sva( p ) = aapp
                                notrot = 0
                                go to 2011
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                aapp = -aapp
                                notrot = 0
                                go to 2203
                             end if
                          end do loop_2200
              ! end of the q-loop
              2203 continue
                          sva( p ) = aapp
                       else
                          if( aapp==zero )notrot = notrot +min( jgl+kbl-1, n ) - jgl + 1
                          if( aapp<zero )notrot = 0
                       end if
                    end do loop_2100
           ! end of the p-loop
                 end do loop_2010
           ! end of the jbc-loop
           2011 continue
      ! 2011 bailed out of the jbc-loop
                 do p = igl, min( igl+kbl-1, n )
                    sva( p ) = abs( sva( p ) )
                 end do
      ! **
              end do loop_2000
      ! 2000 :: end of the ibr-loop
           ! .. update sva(n)
              if( ( sva( n )<rootbig ) .and. ( sva( n )>rootsfmin ) )then
                 sva( n ) = stdlib_scnrm2( m, a( 1, n ), 1 )
              else
                 t = zero
                 aapp = one
                 call stdlib_classq( m, a( 1, n ), 1, t, aapp )
                 sva( n ) = t*sqrt( aapp )
              end if
           ! additional steering devices
              if( ( i<swband ) .and. ( ( mxaapq<=roottol ) .or.( iswrot<=n ) ) )swband = i
              if( ( i>swband+1 ) .and. ( mxaapq<sqrt( real( n,KIND=sp) )*tol ) .and. ( real( n,&
                        KIND=sp)*mxaapq*mxsinj<tol ) ) then
                 go to 1994
              end if
              if( notrot>=emptsw )go to 1994
           end do loop_1993
           ! end i=1:nsweep loop
       ! #:( reaching this point means that the procedure has not converged.
           info = nsweep - 1
           go to 1995
           1994 continue
       ! #:) reaching this point means numerical convergence after the i-th
           ! sweep.
           info = 0
       ! #:) info = 0 confirms successful iterations.
       1995 continue
           ! sort the singular values and find how many are above
           ! the underflow threshold.
           n2 = 0
           n4 = 0
           do p = 1, n - 1
              q = stdlib_isamax( n-p+1, sva( p ), 1 ) + p - 1
              if( p/=q ) then
                 temp1 = sva( p )
                 sva( p ) = sva( q )
                 sva( q ) = temp1
                 call stdlib_cswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                 if( rsvec )call stdlib_cswap( mvl, v( 1, p ), 1, v( 1, q ), 1 )
              end if
              if( sva( p )/=zero ) then
                 n4 = n4 + 1
                 if( sva( p )*skl>sfmin )n2 = n2 + 1
              end if
           end do
           if( sva( n )/=zero ) then
              n4 = n4 + 1
              if( sva( n )*skl>sfmin )n2 = n2 + 1
           end if
           ! normalize the left singular vectors.
           if( lsvec .or. uctol ) then
              do p = 1, n4
                 ! call stdlib_csscal( m, one / sva( p ), a( 1, p ), 1 )
                 call stdlib_clascl( 'G',0,0, sva(p), one, m, 1, a(1,p), m, ierr )
              end do
           end if
           ! scale the product of jacobi rotations.
           if( rsvec ) then
                 do p = 1, n
                    temp1 = one / stdlib_scnrm2( mvl, v( 1, p ), 1 )
                    call stdlib_csscal( mvl, temp1, v( 1, p ), 1 )
                 end do
           end if
           ! undo scaling, if necessary (and possible).
           if( ( ( skl>one ) .and. ( sva( 1 )<( big / skl ) ) ).or. ( ( skl<one ) .and. ( sva( &
                     max( n2, 1 ) ) >( sfmin / skl ) ) ) ) then
              do p = 1, n
                 sva( p ) = skl*sva( p )
              end do
              skl = one
           end if
           rwork( 1 ) = skl
           ! the singular values of a are skl*sva(1:n). if skl/=one
           ! then some of the singular values may overflow or underflow and
           ! the spectrum is given in this factored representation.
           rwork( 2 ) = real( n4,KIND=sp)
           ! n4 is the number of computed nonzero singular values of a.
           rwork( 3 ) = real( n2,KIND=sp)
           ! n2 is the number of singular values of a greater than sfmin.
           ! if n2<n, sva(n2:n) contains zeros and/or denormalized numbers
           ! that may carry some information.
           rwork( 4 ) = real( i,KIND=sp)
           ! i is the index of the last sweep before declaring convergence.
           rwork( 5 ) = mxaapq
           ! mxaapq is the largest absolute value of scaled pivots in the
           ! last sweep
           rwork( 6 ) = mxsinj
           ! mxsinj is the largest absolute value of the sines of jacobi angles
           ! in the last sweep
           return
     end subroutine stdlib_cgesvj

     module pure subroutine stdlib_zgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, cwork, lwork, rwork, lrwork, info )
     !! ZGESVJ computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N unitary matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldv, lwork, lrwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*), v(ldv,*), cwork(lwork)
           real(dp), intent(inout) :: rwork(lrwork)
           real(dp), intent(out) :: sva(n)
        ! =====================================================================
           ! Local Parameters 
           integer(ilp), parameter :: nsweep = 30
           
           
           
           ! Local Scalars 
           complex(dp) :: aapq, ompq
           real(dp) :: aapp, aapp0, aapq1, aaqq, apoaq, aqoap, big, bigtheta, cs, ctol, epsln, &
           mxaapq, mxsinj, rootbig, rooteps, rootsfmin, roottol, skl, sfmin, small, sn, t, temp1, &
                     theta, thsign, tol
           integer(ilp) :: blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1, iswrot, jbc, jgl, kbl, &
                     lkahead, mvl, n2, n34, n4, nbl, notrot, p, pskipped, q, rowskip, swband
           logical(lk) :: applv, goscale, lower, lquery, lsvec, noscale, rotok, rsvec, uctol, &
                     upper
           ! Intrinsic Functions 
           ! from lapack
           ! from lapack
           ! Executable Statements 
           ! test the input arguments
           lsvec = stdlib_lsame( jobu, 'U' ) .or. stdlib_lsame( jobu, 'F' )
           uctol = stdlib_lsame( jobu, 'C' )
           rsvec = stdlib_lsame( jobv, 'V' ) .or. stdlib_lsame( jobv, 'J' )
           applv = stdlib_lsame( jobv, 'A' )
           upper = stdlib_lsame( joba, 'U' )
           lower = stdlib_lsame( joba, 'L' )
           lquery = ( lwork == -1 ) .or. ( lrwork == -1 )
           if( .not.( upper .or. lower .or. stdlib_lsame( joba, 'G' ) ) ) then
              info = -1
           else if( .not.( lsvec .or. uctol .or. stdlib_lsame( jobu, 'N' ) ) ) then
              info = -2
           else if( .not.( rsvec .or. applv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( ( n<0 ) .or. ( n>m ) ) then
              info = -5
           else if( lda<m ) then
              info = -7
           else if( mv<0 ) then
              info = -9
           else if( ( rsvec .and. ( ldv<n ) ) .or.( applv .and. ( ldv<mv ) ) ) then
              info = -11
           else if( uctol .and. ( rwork( 1 )<=one ) ) then
              info = -12
           else if( ( lwork<( m+n ) ) .and. ( .not.lquery ) ) then
              info = -13
           else if( ( lrwork<max( n, 6 ) ) .and. ( .not.lquery ) ) then
              info = -15
           else
              info = 0
           end if
           ! #:(
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGESVJ', -info )
              return
           else if ( lquery ) then
              cwork(1) = m + n
              rwork(1) = max( n, 6 )
              return
           end if
       ! #:) quick return for void matrix
           if( ( m==0 ) .or. ( n==0 ) )return
           ! set numerical parameters
           ! the stopping criterion for jacobi rotations is
           ! max_{i<>j}|a(:,i)^* * a(:,j)| / (||a(:,i)||*||a(:,j)||) < ctol*eps
           ! where eps is the round-off and ctol is defined as follows:
           if( uctol ) then
              ! ... user controlled
              ctol = rwork( 1 )
           else
              ! ... default
              if( lsvec .or. rsvec .or. applv ) then
                 ctol = sqrt( real( m,KIND=dp) )
              else
                 ctol = real( m,KIND=dp)
              end if
           end if
           ! ... and the machine dependent parameters are
      ! [!]  (make sure that stdlib_slamch() works properly on the target machine.)
           epsln = stdlib_dlamch( 'EPSILON' )
           rooteps = sqrt( epsln )
           sfmin = stdlib_dlamch( 'SAFEMINIMUM' )
           rootsfmin = sqrt( sfmin )
           small = sfmin / epsln
           big = stdlib_dlamch( 'OVERFLOW' )
           ! big         = one    / sfmin
           rootbig = one / rootsfmin
            ! large = big / sqrt( real( m*n,KIND=dp) )
           bigtheta = one / rooteps
           tol = ctol*epsln
           roottol = sqrt( tol )
           if( real( m,KIND=dp)*epsln>=one ) then
              info = -4
              call stdlib_xerbla( 'ZGESVJ', -info )
              return
           end if
           ! initialize the right singular vector matrix.
           if( rsvec ) then
              mvl = n
              call stdlib_zlaset( 'A', mvl, n, czero, cone, v, ldv )
           else if( applv ) then
              mvl = mv
           end if
           rsvec = rsvec .or. applv
           ! initialize sva( 1:n ) = ( ||a e_i||_2, i = 1:n )
      ! (!)  if necessary, scale a to protect the largest singular value
           ! from overflow. it is possible that saving the largest singular
           ! value destroys the information about the small ones.
           ! this initial scaling is almost minimal in the sense that the
           ! goal is to make sure that no column norm overflows, and that
           ! sqrt(n)*max_i sva(i) does not overflow. if infinite entries
           ! in a are detected, the procedure returns with info=-6.
           skl = one / sqrt( real( m,KIND=dp)*real( n,KIND=dp) )
           noscale = .true.
           goscale = .true.
           if( lower ) then
              ! the input matrix is m-by-n lower triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_zlassq( m-p+1, a( p, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'ZGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else if( upper ) then
              ! the input matrix is m-by-n upper triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_zlassq( p, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'ZGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else
              ! the input matrix is m-by-n general dense
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_zlassq( m, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'ZGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           end if
           if( noscale )skl = one
           ! move the smaller part of the spectrum from the underflow threshold
      ! (!)  start by determining the position of the nonzero entries of the
           ! array sva() relative to ( sfmin, big ).
           aapp = zero
           aaqq = big
           do p = 1, n
              if( sva( p )/=zero )aaqq = min( aaqq, sva( p ) )
              aapp = max( aapp, sva( p ) )
           end do
       ! #:) quick return for zero matrix
           if( aapp==zero ) then
              if( lsvec )call stdlib_zlaset( 'G', m, n, czero, cone, a, lda )
              rwork( 1 ) = one
              rwork( 2 ) = zero
              rwork( 3 ) = zero
              rwork( 4 ) = zero
              rwork( 5 ) = zero
              rwork( 6 ) = zero
              return
           end if
       ! #:) quick return for one-column matrix
           if( n==1 ) then
              if( lsvec )call stdlib_zlascl( 'G', 0, 0, sva( 1 ), skl, m, 1,a( 1, 1 ), lda, ierr )
                        
              rwork( 1 ) = one / skl
              if( sva( 1 )>=sfmin ) then
                 rwork( 2 ) = one
              else
                 rwork( 2 ) = zero
              end if
              rwork( 3 ) = zero
              rwork( 4 ) = zero
              rwork( 5 ) = zero
              rwork( 6 ) = zero
              return
           end if
           ! protect small singular values from underflow, and try to
           ! avoid underflows/overflows in computing jacobi rotations.
           sn = sqrt( sfmin / epsln )
           temp1 = sqrt( big / real( n,KIND=dp) )
           if( ( aapp<=sn ) .or. ( aaqq>=temp1 ) .or.( ( sn<=aaqq ) .and. ( aapp<=temp1 ) ) ) &
                     then
              temp1 = min( big, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp<=temp1 ) ) then
              temp1 = min( sn / aaqq, big / (aapp*sqrt( real(n,KIND=dp)) ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq>=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = max( sn / aaqq, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( sqrt( real( n,KIND=dp) )*aapp ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else
              temp1 = one
           end if
           ! scale, if necessary
           if( temp1/=one ) then
              call stdlib_dlascl( 'G', 0, 0, one, temp1, n, 1, sva, n, ierr )
           end if
           skl = temp1*skl
           if( skl/=one ) then
              call stdlib_zlascl( joba, 0, 0, one, skl, m, n, a, lda, ierr )
              skl = one / skl
           end if
           ! row-cyclic jacobi svd algorithm with column pivoting
           emptsw = ( n*( n-1 ) ) / 2
           notrot = 0
           do q = 1, n
              cwork( q ) = cone
           end do
           swband = 3
      ! [tp] swband is a tuning parameter [tp]. it is meaningful and effective
           ! if stdlib_zgesvj is used as a computational routine in the preconditioned
           ! jacobi svd algorithm stdlib_zgejsv. for sweeps i=1:swband the procedure
           ! works on pivots inside a band-like region around the diagonal.
           ! the boundaries are determined dynamically, based on the number of
           ! pivots above a threshold.
           kbl = min( 8, n )
      ! [tp] kbl is a tuning parameter that defines the tile size in the
           ! tiling of the p-q loops of pivot pairs. in general, an optimal
           ! value of kbl depends on the matrix dimensions and on the
           ! parameters of the computer's memory.
           nbl = n / kbl
           if( ( nbl*kbl )/=n )nbl = nbl + 1
           blskip = kbl**2
      ! [tp] blkskip is a tuning parameter that depends on swband and kbl.
           rowskip = min( 5, kbl )
      ! [tp] rowskip is a tuning parameter.
           lkahead = 1
      ! [tp] lkahead is a tuning parameter.
           ! quasi block transformations, using the lower (upper) triangular
           ! structure of the input matrix. the quasi-block-cycling usually
           ! invokes cubic convergence. big part of this cycle is done inside
           ! canonical subspaces of dimensions less than m.
           if( ( lower .or. upper ) .and. ( n>max( 64, 4*kbl ) ) ) then
      ! [tp] the number of partition levels and the actual partition are
           ! tuning parameters.
              n4 = n / 4
              n2 = n / 2
              n34 = 3*n4
              if( applv ) then
                 q = 0
              else
                 q = 1
              end if
              if( lower ) then
           ! this works very well on lower triangular matrices, in particular
           ! in the framework of the preconditioned jacobi svd (xgejsv).
           ! the idea is simple:
           ! [+ 0 0 0]   note that jacobi transformations of [0 0]
           ! [+ + 0 0]                                       [0 0]
           ! [+ + x 0]   actually work on [x 0]              [x 0]
           ! [+ + x x]                    [x x].             [x x]
                 call stdlib_zgsvj0( jobv, m-n34, n-n34, a( n34+1, n34+1 ), lda,cwork( n34+1 ), &
                 sva( n34+1 ), mvl,v( n34*q+1, n34+1 ), ldv, epsln, sfmin, tol,2, cwork( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_zgsvj0( jobv, m-n2, n34-n2, a( n2+1, n2+1 ), lda,cwork( n2+1 ), sva( &
                 n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 2,cwork( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_zgsvj1( jobv, m-n2, n-n2, n4, a( n2+1, n2+1 ), lda,cwork( n2+1 ), &
                 sva( n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_zgsvj0( jobv, m-n4, n2-n4, a( n4+1, n4+1 ), lda,cwork( n4+1 ), sva( &
                 n4+1 ), mvl,v( n4*q+1, n4+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_zgsvj0( jobv, m, n4, a, lda, cwork, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 1, cwork( n+1 ), lwork-n,ierr )
                 call stdlib_zgsvj1( jobv, m, n2, n4, a, lda, cwork, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, cwork( n+1 ),lwork-n, ierr )
              else if( upper ) then
                 call stdlib_zgsvj0( jobv, n4, n4, a, lda, cwork, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 2, cwork( n+1 ), lwork-n,ierr )
                 call stdlib_zgsvj0( jobv, n2, n4, a( 1, n4+1 ), lda, cwork( n4+1 ),sva( n4+1 ), &
                 mvl, v( n4*q+1, n4+1 ), ldv,epsln, sfmin, tol, 1, cwork( n+1 ), lwork-n,ierr )
                           
                 call stdlib_zgsvj1( jobv, n2, n2, n4, a, lda, cwork, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, cwork( n+1 ),lwork-n, ierr )
                 call stdlib_zgsvj0( jobv, n2+n4, n4, a( 1, n2+1 ), lda,cwork( n2+1 ), sva( n2+1 )&
                 , mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), lwork-n, ierr )
                           
              end if
           end if
           ! .. row-cyclic pivot strategy with de rijk's pivoting ..
           loop_1993: do i = 1, nsweep
           ! .. go go go ...
              mxaapq = zero
              mxsinj = zero
              iswrot = 0
              notrot = 0
              pskipped = 0
           ! each sweep is unrolled using kbl-by-kbl tiles over the pivot pairs
           ! 1 <= p < q <= n. this is the first step toward a blocked implementation
           ! of the rotations. new implementation, based on block transformations,
           ! is under development.
              loop_2000: do ibr = 1, nbl
                 igl = ( ibr-1 )*kbl + 1
                 loop_1002: do ir1 = 0, min( lkahead, nbl-ibr )
                    igl = igl + ir1*kbl
                    loop_2001: do p = igl, min( igl+kbl-1, n-1 )
           ! .. de rijk's pivoting
                       q = stdlib_idamax( n-p+1, sva( p ), 1 ) + p - 1
                       if( p/=q ) then
                          call stdlib_zswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                          if( rsvec )call stdlib_zswap( mvl, v( 1, p ), 1,v( 1, q ), 1 )
                          temp1 = sva( p )
                          sva( p ) = sva( q )
                          sva( q ) = temp1
                          aapq = cwork(p)
                          cwork(p) = cwork(q)
                          cwork(q) = aapq
                       end if
                       if( ir1==0 ) then
              ! column norms are periodically updated by explicit
              ! norm computation.
      ! [!]     caveat:
              ! unfortunately, some blas implementations compute stdlib_dznrm2(m,a(1,p),1)
              ! as sqrt(s=stdlib_cdotc(m,a(1,p),1,a(1,p),1)), which may cause the result to
              ! overflow for ||a(:,p)||_2 > sqrt(overflow_threshold), and to
              ! underflow for ||a(:,p)||_2 < sqrt(underflow_threshold).
              ! hence, stdlib_dznrm2 cannot be trusted, not even in the case when
              ! the true norm is far from the under(over)flow boundaries.
              ! if properly implemented stdlib_scnrm2 is available, the if-then-else-end if
              ! below should be replaced with "aapp = stdlib_dznrm2( m, a(1,p), 1 )".
                          if( ( sva( p )<rootbig ) .and.( sva( p )>rootsfmin ) ) then
                             sva( p ) = stdlib_dznrm2( m, a( 1, p ), 1 )
                          else
                             temp1 = zero
                             aapp = one
                             call stdlib_zlassq( m, a( 1, p ), 1, temp1, aapp )
                             sva( p ) = temp1*sqrt( aapp )
                          end if
                          aapp = sva( p )
                       else
                          aapp = sva( p )
                       end if
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2002: do q = p + 1, min( igl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
                                if( aaqq>=one ) then
                                   rotok = ( small*aapp )<=aaqq
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_zdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aaqq ) / aapp
                                   else
                                      call stdlib_zcopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_zlascl( 'G', 0, 0, aapp, one,m, 1, cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_zdotc( m, cwork(n+1), 1,a( 1, q ), 1 ) / &
                                                aaqq
                                   end if
                                else
                                   rotok = aapp<=( aaqq / small )
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_zdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aapp ) / aaqq
                                   else
                                      call stdlib_zcopy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                      call stdlib_zlascl( 'G', 0, 0, aaqq,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_zdotc( m, a(1, p ), 1,cwork(n+1), 1 ) / &
                                                aapp
                                   end if
                                end if
                                 ! aapq = aapq * conjg( cwork(p) ) * cwork(q)
                                aapq1  = -abs(aapq)
                                mxaapq = max( mxaapq, -aapq1 )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq1 )>tol ) then
                                ompq = aapq / abs(aapq)
                 ! Rotate
      ! [rtd]      rotated = rotated + one
                                   if( ir1==0 ) then
                                      notrot = 0
                                      pskipped = 0
                                      iswrot = iswrot + 1
                                   end if
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/aapq1
                                      if( abs( theta )>bigtheta ) then
                                         t  = half / theta
                                         cs = one
                                         call stdlib_zrot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *t )
                                         if ( rsvec ) then
                                             call stdlib_zrot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*t )
                                         end if
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq1 )
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         call stdlib_zrot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *sn )
                                         if ( rsvec ) then
                                             call stdlib_zrot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*sn )
                                         end if
                                      end if
                                      cwork(p) = -cwork(q) * ompq
                                      else
                    ! .. have to use modified gram-schmidt like transformation
                                      call stdlib_zcopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_zlascl( 'G', 0, 0, aapp, one, m,1, cwork(n+1), &
                                                lda,ierr )
                                      call stdlib_zlascl( 'G', 0, 0, aaqq, one, m,1, a( 1, q ), &
                                                lda, ierr )
                                      call stdlib_zaxpy( m, -aapq, cwork(n+1), 1,a( 1, q ), 1 )
                                                
                                      call stdlib_zlascl( 'G', 0, 0, one, aaqq, m,1, a( 1, q ), &
                                                lda, ierr )
                                      sva( q ) = aaqq*sqrt( max( zero,one-aapq1*aapq1 ) )
                                      mxsinj = max( mxsinj, sfmin )
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! recompute sva(q), sva(p).
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_dznrm2( m, a( 1, q ), 1 )
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_zlassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_dznrm2( m, a( 1, p ), 1 )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_zlassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )
                                      end if
                                      sva( p ) = aapp
                                   end if
                                else
                                   ! a(:,p) and a(:,q) already numerically orthogonal
                                   if( ir1==0 )notrot = notrot + 1
      ! [rtd]      skipped  = skipped + 1
                                   pskipped = pskipped + 1
                                end if
                             else
                                ! a(:,q) is zero column
                                if( ir1==0 )notrot = notrot + 1
                                pskipped = pskipped + 1
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                if( ir1==0 )aapp = -aapp
                                notrot = 0
                                go to 2103
                             end if
                          end do loop_2002
           ! end q-loop
           2103 continue
           ! bailed out of q-loop
                          sva( p ) = aapp
                       else
                          sva( p ) = aapp
                          if( ( ir1==0 ) .and. ( aapp==zero ) )notrot = notrot + min( igl+kbl-1, &
                                    n ) - p
                       end if
                    end do loop_2001
           ! end of the p-loop
           ! end of doing the block ( ibr, ibr )
                 end do loop_1002
           ! end of ir1-loop
       ! ... go to the off diagonal blocks
                 igl = ( ibr-1 )*kbl + 1
                 loop_2010: do jbc = ibr + 1, nbl
                    jgl = ( jbc-1 )*kbl + 1
              ! doing the block at ( ibr, jbc )
                    ijblsk = 0
                    loop_2100: do p = igl, min( igl+kbl-1, n )
                       aapp = sva( p )
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2200: do q = jgl, min( jgl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
           ! M X 2 Jacobi Svd 
              ! safe gram matrix computation
                                if( aaqq>=one ) then
                                   if( aapp>=aaqq ) then
                                      rotok = ( small*aapp )<=aaqq
                                   else
                                      rotok = ( small*aaqq )<=aapp
                                   end if
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_zdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aaqq ) / aapp
                                   else
                                      call stdlib_zcopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_zlascl( 'G', 0, 0, aapp,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_zdotc( m, cwork(n+1), 1,a( 1, q ), 1 ) / &
                                                aaqq
                                   end if
                                else
                                   if( aapp>=aaqq ) then
                                      rotok = aapp<=( aaqq / small )
                                   else
                                      rotok = aaqq<=( aapp / small )
                                   end if
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_zdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / max(&
                                                aaqq,aapp) )/ min(aaqq,aapp)
                                   else
                                      call stdlib_zcopy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                      call stdlib_zlascl( 'G', 0, 0, aaqq,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_zdotc( m, a( 1, p ), 1,cwork(n+1),  1 ) / &
                                                aapp
                                   end if
                                end if
                                 ! aapq = aapq * conjg(cwork(p))*cwork(q)
                                aapq1  = -abs(aapq)
                                mxaapq = max( mxaapq, -aapq1 )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq1 )>tol ) then
                                   ompq = aapq / abs(aapq)
                                   notrot = 0
      ! [rtd]      rotated  = rotated + 1
                                   pskipped = 0
                                   iswrot = iswrot + 1
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/ aapq1
                                      if( aaqq>aapp0 )theta = -theta
                                      if( abs( theta )>bigtheta ) then
                                         t  = half / theta
                                         cs = one
                                         call stdlib_zrot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *t )
                                         if( rsvec ) then
                                             call stdlib_zrot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*t )
                                         end if
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq1 )
                                         if( aaqq>aapp0 )thsign = -thsign
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         call stdlib_zrot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *sn )
                                         if( rsvec ) then
                                             call stdlib_zrot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*sn )
                                         end if
                                      end if
                                      cwork(p) = -cwork(q) * ompq
                                   else
                    ! .. have to use modified gram-schmidt like transformation
                                    if( aapp>aaqq ) then
                                         call stdlib_zcopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                                   
                                         call stdlib_zlascl( 'G', 0, 0, aapp, one,m, 1, cwork(n+1)&
                                                   ,lda,ierr )
                                         call stdlib_zlascl( 'G', 0, 0, aaqq, one,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         call stdlib_zaxpy( m, -aapq, cwork(n+1),1, a( 1, q ), 1 )
                                                   
                                         call stdlib_zlascl( 'G', 0, 0, one, aaqq,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         sva( q ) = aaqq*sqrt( max( zero,one-aapq1*aapq1 ) )
                                                   
                                         mxsinj = max( mxsinj, sfmin )
                                    else
                                        call stdlib_zcopy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                         call stdlib_zlascl( 'G', 0, 0, aaqq, one,m, 1, cwork(n+1)&
                                                   ,lda,ierr )
                                         call stdlib_zlascl( 'G', 0, 0, aapp, one,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         call stdlib_zaxpy( m, -conjg(aapq),cwork(n+1), 1, a( 1, &
                                                   p ), 1 )
                                         call stdlib_zlascl( 'G', 0, 0, one, aapp,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         sva( p ) = aapp*sqrt( max( zero,one-aapq1*aapq1 ) )
                                                   
                                         mxsinj = max( mxsinj, sfmin )
                                    end if
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! .. recompute sva(q), sva(p)
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_dznrm2( m, a( 1, q ), 1)
                                       else
                                         t = zero
                                         aaqq = one
                                         call stdlib_zlassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )**2<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_dznrm2( m, a( 1, p ), 1 )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_zlassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )
                                      end if
                                      sva( p ) = aapp
                                   end if
                    ! end of ok rotation
                                else
                                   notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                   ijblsk = ijblsk + 1
                                end if
                             else
                                notrot = notrot + 1
                                pskipped = pskipped + 1
                                ijblsk = ijblsk + 1
                             end if
                             if( ( i<=swband ) .and. ( ijblsk>=blskip ) )then
                                sva( p ) = aapp
                                notrot = 0
                                go to 2011
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                aapp = -aapp
                                notrot = 0
                                go to 2203
                             end if
                          end do loop_2200
              ! end of the q-loop
              2203 continue
                          sva( p ) = aapp
                       else
                          if( aapp==zero )notrot = notrot +min( jgl+kbl-1, n ) - jgl + 1
                          if( aapp<zero )notrot = 0
                       end if
                    end do loop_2100
           ! end of the p-loop
                 end do loop_2010
           ! end of the jbc-loop
           2011 continue
      ! 2011 bailed out of the jbc-loop
                 do p = igl, min( igl+kbl-1, n )
                    sva( p ) = abs( sva( p ) )
                 end do
      ! **
              end do loop_2000
      ! 2000 :: end of the ibr-loop
           ! .. update sva(n)
              if( ( sva( n )<rootbig ) .and. ( sva( n )>rootsfmin ) )then
                 sva( n ) = stdlib_dznrm2( m, a( 1, n ), 1 )
              else
                 t = zero
                 aapp = one
                 call stdlib_zlassq( m, a( 1, n ), 1, t, aapp )
                 sva( n ) = t*sqrt( aapp )
              end if
           ! additional steering devices
              if( ( i<swband ) .and. ( ( mxaapq<=roottol ) .or.( iswrot<=n ) ) )swband = i
              if( ( i>swband+1 ) .and. ( mxaapq<sqrt( real( n,KIND=dp) )*tol ) .and. ( real( n,&
                        KIND=dp)*mxaapq*mxsinj<tol ) ) then
                 go to 1994
              end if
              if( notrot>=emptsw )go to 1994
           end do loop_1993
           ! end i=1:nsweep loop
       ! #:( reaching this point means that the procedure has not converged.
           info = nsweep - 1
           go to 1995
           1994 continue
       ! #:) reaching this point means numerical convergence after the i-th
           ! sweep.
           info = 0
       ! #:) info = 0 confirms successful iterations.
       1995 continue
           ! sort the singular values and find how many are above
           ! the underflow threshold.
           n2 = 0
           n4 = 0
           do p = 1, n - 1
              q = stdlib_idamax( n-p+1, sva( p ), 1 ) + p - 1
              if( p/=q ) then
                 temp1 = sva( p )
                 sva( p ) = sva( q )
                 sva( q ) = temp1
                 call stdlib_zswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                 if( rsvec )call stdlib_zswap( mvl, v( 1, p ), 1, v( 1, q ), 1 )
              end if
              if( sva( p )/=zero ) then
                 n4 = n4 + 1
                 if( sva( p )*skl>sfmin )n2 = n2 + 1
              end if
           end do
           if( sva( n )/=zero ) then
              n4 = n4 + 1
              if( sva( n )*skl>sfmin )n2 = n2 + 1
           end if
           ! normalize the left singular vectors.
           if( lsvec .or. uctol ) then
              do p = 1, n4
                  ! call stdlib_zdscal( m, one / sva( p ), a( 1, p ), 1 )
                 call stdlib_zlascl( 'G',0,0, sva(p), one, m, 1, a(1,p), m, ierr )
              end do
           end if
           ! scale the product of jacobi rotations.
           if( rsvec ) then
                 do p = 1, n
                    temp1 = one / stdlib_dznrm2( mvl, v( 1, p ), 1 )
                    call stdlib_zdscal( mvl, temp1, v( 1, p ), 1 )
                 end do
           end if
           ! undo scaling, if necessary (and possible).
           if( ( ( skl>one ) .and. ( sva( 1 )<( big / skl ) ) ).or. ( ( skl<one ) .and. ( sva( &
                     max( n2, 1 ) ) >( sfmin / skl ) ) ) ) then
              do p = 1, n
                 sva( p ) = skl*sva( p )
              end do
              skl = one
           end if
           rwork( 1 ) = skl
           ! the singular values of a are skl*sva(1:n). if skl/=one
           ! then some of the singular values may overflow or underflow and
           ! the spectrum is given in this factored representation.
           rwork( 2 ) = real( n4,KIND=dp)
           ! n4 is the number of computed nonzero singular values of a.
           rwork( 3 ) = real( n2,KIND=dp)
           ! n2 is the number of singular values of a greater than sfmin.
           ! if n2<n, sva(n2:n) contains zeros and/or denormalized numbers
           ! that may carry some information.
           rwork( 4 ) = real( i,KIND=dp)
           ! i is the index of the last sweep before declaring convergence.
           rwork( 5 ) = mxaapq
           ! mxaapq is the largest absolute value of scaled pivots in the
           ! last sweep
           rwork( 6 ) = mxsinj
           ! mxsinj is the largest absolute value of the sines of jacobi angles
           ! in the last sweep
           return
     end subroutine stdlib_zgesvj

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$gesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, cwork, lwork, rwork, lrwork, info )
     !! ZGESVJ: computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N unitary matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldv, lwork, lrwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*), v(ldv,*), cwork(lwork)
           real(${ck}$), intent(inout) :: rwork(lrwork)
           real(${ck}$), intent(out) :: sva(n)
        ! =====================================================================
           ! Local Parameters 
           integer(ilp), parameter :: nsweep = 30
           
           
           
           ! Local Scalars 
           complex(${ck}$) :: aapq, ompq
           real(${ck}$) :: aapp, aapp0, aapq1, aaqq, apoaq, aqoap, big, bigtheta, cs, ctol, epsln, &
           mxaapq, mxsinj, rootbig, rooteps, rootsfmin, roottol, skl, sfmin, small, sn, t, temp1, &
                     theta, thsign, tol
           integer(ilp) :: blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1, iswrot, jbc, jgl, kbl, &
                     lkahead, mvl, n2, n34, n4, nbl, notrot, p, pskipped, q, rowskip, swband
           logical(lk) :: applv, goscale, lower, lquery, lsvec, noscale, rotok, rsvec, uctol, &
                     upper
           ! Intrinsic Functions 
           ! from lapack
           ! from lapack
           ! Executable Statements 
           ! test the input arguments
           lsvec = stdlib_lsame( jobu, 'U' ) .or. stdlib_lsame( jobu, 'F' )
           uctol = stdlib_lsame( jobu, 'C' )
           rsvec = stdlib_lsame( jobv, 'V' ) .or. stdlib_lsame( jobv, 'J' )
           applv = stdlib_lsame( jobv, 'A' )
           upper = stdlib_lsame( joba, 'U' )
           lower = stdlib_lsame( joba, 'L' )
           lquery = ( lwork == -1 ) .or. ( lrwork == -1 )
           if( .not.( upper .or. lower .or. stdlib_lsame( joba, 'G' ) ) ) then
              info = -1
           else if( .not.( lsvec .or. uctol .or. stdlib_lsame( jobu, 'N' ) ) ) then
              info = -2
           else if( .not.( rsvec .or. applv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( ( n<0 ) .or. ( n>m ) ) then
              info = -5
           else if( lda<m ) then
              info = -7
           else if( mv<0 ) then
              info = -9
           else if( ( rsvec .and. ( ldv<n ) ) .or.( applv .and. ( ldv<mv ) ) ) then
              info = -11
           else if( uctol .and. ( rwork( 1 )<=one ) ) then
              info = -12
           else if( ( lwork<( m+n ) ) .and. ( .not.lquery ) ) then
              info = -13
           else if( ( lrwork<max( n, 6 ) ) .and. ( .not.lquery ) ) then
              info = -15
           else
              info = 0
           end if
           ! #:(
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGESVJ', -info )
              return
           else if ( lquery ) then
              cwork(1) = m + n
              rwork(1) = max( n, 6 )
              return
           end if
       ! #:) quick return for void matrix
           if( ( m==0 ) .or. ( n==0 ) )return
           ! set numerical parameters
           ! the stopping criterion for jacobi rotations is
           ! max_{i<>j}|a(:,i)^* * a(:,j)| / (||a(:,i)||*||a(:,j)||) < ctol*eps
           ! where eps is the round-off and ctol is defined as follows:
           if( uctol ) then
              ! ... user controlled
              ctol = rwork( 1 )
           else
              ! ... default
              if( lsvec .or. rsvec .or. applv ) then
                 ctol = sqrt( real( m,KIND=${ck}$) )
              else
                 ctol = real( m,KIND=${ck}$)
              end if
           end if
           ! ... and the machine dependent parameters are
      ! [!]  (make sure that stdlib_dlamch() works properly on the target machine.)
           epsln = stdlib_${c2ri(ci)}$lamch( 'EPSILON' )
           rooteps = sqrt( epsln )
           sfmin = stdlib_${c2ri(ci)}$lamch( 'SAFEMINIMUM' )
           rootsfmin = sqrt( sfmin )
           small = sfmin / epsln
           big = stdlib_${c2ri(ci)}$lamch( 'OVERFLOW' )
           ! big         = one    / sfmin
           rootbig = one / rootsfmin
            ! large = big / sqrt( real( m*n,KIND=${ck}$) )
           bigtheta = one / rooteps
           tol = ctol*epsln
           roottol = sqrt( tol )
           if( real( m,KIND=${ck}$)*epsln>=one ) then
              info = -4
              call stdlib_xerbla( 'ZGESVJ', -info )
              return
           end if
           ! initialize the right singular vector matrix.
           if( rsvec ) then
              mvl = n
              call stdlib_${ci}$laset( 'A', mvl, n, czero, cone, v, ldv )
           else if( applv ) then
              mvl = mv
           end if
           rsvec = rsvec .or. applv
           ! initialize sva( 1:n ) = ( ||a e_i||_2, i = 1:n )
      ! (!)  if necessary, scale a to protect the largest singular value
           ! from overflow. it is possible that saving the largest singular
           ! value destroys the information about the small ones.
           ! this initial scaling is almost minimal in the sense that the
           ! goal is to make sure that no column norm overflows, and that
           ! sqrt(n)*max_i sva(i) does not overflow. if infinite entries
           ! in a are detected, the procedure returns with info=-6.
           skl = one / sqrt( real( m,KIND=${ck}$)*real( n,KIND=${ck}$) )
           noscale = .true.
           goscale = .true.
           if( lower ) then
              ! the input matrix is m-by-n lower triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_${ci}$lassq( m-p+1, a( p, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'ZGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else if( upper ) then
              ! the input matrix is m-by-n upper triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_${ci}$lassq( p, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'ZGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else
              ! the input matrix is m-by-n general dense
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_${ci}$lassq( m, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'ZGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           end if
           if( noscale )skl = one
           ! move the smaller part of the spectrum from the underflow threshold
      ! (!)  start by determining the position of the nonzero entries of the
           ! array sva() relative to ( sfmin, big ).
           aapp = zero
           aaqq = big
           do p = 1, n
              if( sva( p )/=zero )aaqq = min( aaqq, sva( p ) )
              aapp = max( aapp, sva( p ) )
           end do
       ! #:) quick return for zero matrix
           if( aapp==zero ) then
              if( lsvec )call stdlib_${ci}$laset( 'G', m, n, czero, cone, a, lda )
              rwork( 1 ) = one
              rwork( 2 ) = zero
              rwork( 3 ) = zero
              rwork( 4 ) = zero
              rwork( 5 ) = zero
              rwork( 6 ) = zero
              return
           end if
       ! #:) quick return for one-column matrix
           if( n==1 ) then
              if( lsvec )call stdlib_${ci}$lascl( 'G', 0, 0, sva( 1 ), skl, m, 1,a( 1, 1 ), lda, ierr )
                        
              rwork( 1 ) = one / skl
              if( sva( 1 )>=sfmin ) then
                 rwork( 2 ) = one
              else
                 rwork( 2 ) = zero
              end if
              rwork( 3 ) = zero
              rwork( 4 ) = zero
              rwork( 5 ) = zero
              rwork( 6 ) = zero
              return
           end if
           ! protect small singular values from underflow, and try to
           ! avoid underflows/overflows in computing jacobi rotations.
           sn = sqrt( sfmin / epsln )
           temp1 = sqrt( big / real( n,KIND=${ck}$) )
           if( ( aapp<=sn ) .or. ( aaqq>=temp1 ) .or.( ( sn<=aaqq ) .and. ( aapp<=temp1 ) ) ) &
                     then
              temp1 = min( big, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp<=temp1 ) ) then
              temp1 = min( sn / aaqq, big / (aapp*sqrt( real(n,KIND=${ck}$)) ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq>=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = max( sn / aaqq, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( sqrt( real( n,KIND=${ck}$) )*aapp ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else
              temp1 = one
           end if
           ! scale, if necessary
           if( temp1/=one ) then
              call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, one, temp1, n, 1, sva, n, ierr )
           end if
           skl = temp1*skl
           if( skl/=one ) then
              call stdlib_${ci}$lascl( joba, 0, 0, one, skl, m, n, a, lda, ierr )
              skl = one / skl
           end if
           ! row-cyclic jacobi svd algorithm with column pivoting
           emptsw = ( n*( n-1 ) ) / 2
           notrot = 0
           do q = 1, n
              cwork( q ) = cone
           end do
           swband = 3
      ! [tp] swband is a tuning parameter [tp]. it is meaningful and effective
           ! if stdlib_${ci}$gesvj is used as a computational routine in the preconditioned
           ! jacobi svd algorithm stdlib_${ci}$gejsv. for sweeps i=1:swband the procedure
           ! works on pivots inside a band-like region around the diagonal.
           ! the boundaries are determined dynamically, based on the number of
           ! pivots above a threshold.
           kbl = min( 8, n )
      ! [tp] kbl is a tuning parameter that defines the tile size in the
           ! tiling of the p-q loops of pivot pairs. in general, an optimal
           ! value of kbl depends on the matrix dimensions and on the
           ! parameters of the computer's memory.
           nbl = n / kbl
           if( ( nbl*kbl )/=n )nbl = nbl + 1
           blskip = kbl**2
      ! [tp] blkskip is a tuning parameter that depends on swband and kbl.
           rowskip = min( 5, kbl )
      ! [tp] rowskip is a tuning parameter.
           lkahead = 1
      ! [tp] lkahead is a tuning parameter.
           ! quasi block transformations, using the lower (upper) triangular
           ! structure of the input matrix. the quasi-block-cycling usually
           ! invokes cubic convergence. big part of this cycle is done inside
           ! canonical subspaces of dimensions less than m.
           if( ( lower .or. upper ) .and. ( n>max( 64, 4*kbl ) ) ) then
      ! [tp] the number of partition levels and the actual partition are
           ! tuning parameters.
              n4 = n / 4
              n2 = n / 2
              n34 = 3*n4
              if( applv ) then
                 q = 0
              else
                 q = 1
              end if
              if( lower ) then
           ! this works very well on lower triangular matrices, in particular
           ! in the framework of the preconditioned jacobi svd (xgejsv).
           ! the idea is simple:
           ! [+ 0 0 0]   note that jacobi transformations of [0 0]
           ! [+ + 0 0]                                       [0 0]
           ! [+ + x 0]   actually work on [x 0]              [x 0]
           ! [+ + x x]                    [x x].             [x x]
                 call stdlib_${ci}$gsvj0( jobv, m-n34, n-n34, a( n34+1, n34+1 ), lda,cwork( n34+1 ), &
                 sva( n34+1 ), mvl,v( n34*q+1, n34+1 ), ldv, epsln, sfmin, tol,2, cwork( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_${ci}$gsvj0( jobv, m-n2, n34-n2, a( n2+1, n2+1 ), lda,cwork( n2+1 ), sva( &
                 n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 2,cwork( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_${ci}$gsvj1( jobv, m-n2, n-n2, n4, a( n2+1, n2+1 ), lda,cwork( n2+1 ), &
                 sva( n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_${ci}$gsvj0( jobv, m-n4, n2-n4, a( n4+1, n4+1 ), lda,cwork( n4+1 ), sva( &
                 n4+1 ), mvl,v( n4*q+1, n4+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_${ci}$gsvj0( jobv, m, n4, a, lda, cwork, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 1, cwork( n+1 ), lwork-n,ierr )
                 call stdlib_${ci}$gsvj1( jobv, m, n2, n4, a, lda, cwork, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, cwork( n+1 ),lwork-n, ierr )
              else if( upper ) then
                 call stdlib_${ci}$gsvj0( jobv, n4, n4, a, lda, cwork, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 2, cwork( n+1 ), lwork-n,ierr )
                 call stdlib_${ci}$gsvj0( jobv, n2, n4, a( 1, n4+1 ), lda, cwork( n4+1 ),sva( n4+1 ), &
                 mvl, v( n4*q+1, n4+1 ), ldv,epsln, sfmin, tol, 1, cwork( n+1 ), lwork-n,ierr )
                           
                 call stdlib_${ci}$gsvj1( jobv, n2, n2, n4, a, lda, cwork, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, cwork( n+1 ),lwork-n, ierr )
                 call stdlib_${ci}$gsvj0( jobv, n2+n4, n4, a( 1, n2+1 ), lda,cwork( n2+1 ), sva( n2+1 )&
                 , mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), lwork-n, ierr )
                           
              end if
           end if
           ! .. row-cyclic pivot strategy with de rijk's pivoting ..
           loop_1993: do i = 1, nsweep
           ! .. go go go ...
              mxaapq = zero
              mxsinj = zero
              iswrot = 0
              notrot = 0
              pskipped = 0
           ! each sweep is unrolled using kbl-by-kbl tiles over the pivot pairs
           ! 1 <= p < q <= n. this is the first step toward a blocked implementation
           ! of the rotations. new implementation, based on block transformations,
           ! is under development.
              loop_2000: do ibr = 1, nbl
                 igl = ( ibr-1 )*kbl + 1
                 loop_1002: do ir1 = 0, min( lkahead, nbl-ibr )
                    igl = igl + ir1*kbl
                    loop_2001: do p = igl, min( igl+kbl-1, n-1 )
           ! .. de rijk's pivoting
                       q = stdlib_i${c2ri(ci)}$amax( n-p+1, sva( p ), 1 ) + p - 1
                       if( p/=q ) then
                          call stdlib_${ci}$swap( m, a( 1, p ), 1, a( 1, q ), 1 )
                          if( rsvec )call stdlib_${ci}$swap( mvl, v( 1, p ), 1,v( 1, q ), 1 )
                          temp1 = sva( p )
                          sva( p ) = sva( q )
                          sva( q ) = temp1
                          aapq = cwork(p)
                          cwork(p) = cwork(q)
                          cwork(q) = aapq
                       end if
                       if( ir1==0 ) then
              ! column norms are periodically updated by explicit
              ! norm computation.
      ! [!]     caveat:
              ! unfortunately, some blas implementations compute stdlib_${c2ri(ci)}$znrm2(m,a(1,p),1)
              ! as sqrt(s=stdlib_zdotc(m,a(1,p),1,a(1,p),1)), which may cause the result to
              ! overflow for ||a(:,p)||_2 > sqrt(overflow_threshold), and to
              ! underflow for ||a(:,p)||_2 < sqrt(underflow_threshold).
              ! hence, stdlib_${c2ri(ci)}$znrm2 cannot be trusted, not even in the case when
              ! the true norm is far from the under(over)flow boundaries.
              ! if properly implemented stdlib_dcnrm2 is available, the if-then-else-end if
              ! below should be replaced with "aapp = stdlib_${c2ri(ci)}$znrm2( m, a(1,p), 1 )".
                          if( ( sva( p )<rootbig ) .and.( sva( p )>rootsfmin ) ) then
                             sva( p ) = stdlib_${c2ri(ci)}$znrm2( m, a( 1, p ), 1 )
                          else
                             temp1 = zero
                             aapp = one
                             call stdlib_${ci}$lassq( m, a( 1, p ), 1, temp1, aapp )
                             sva( p ) = temp1*sqrt( aapp )
                          end if
                          aapp = sva( p )
                       else
                          aapp = sva( p )
                       end if
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2002: do q = p + 1, min( igl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
                                if( aaqq>=one ) then
                                   rotok = ( small*aapp )<=aaqq
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_${ci}$dotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aaqq ) / aapp
                                   else
                                      call stdlib_${ci}$copy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_${ci}$lascl( 'G', 0, 0, aapp, one,m, 1, cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_${ci}$dotc( m, cwork(n+1), 1,a( 1, q ), 1 ) / &
                                                aaqq
                                   end if
                                else
                                   rotok = aapp<=( aaqq / small )
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_${ci}$dotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aapp ) / aaqq
                                   else
                                      call stdlib_${ci}$copy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                      call stdlib_${ci}$lascl( 'G', 0, 0, aaqq,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_${ci}$dotc( m, a(1, p ), 1,cwork(n+1), 1 ) / &
                                                aapp
                                   end if
                                end if
                                 ! aapq = aapq * conjg( cwork(p) ) * cwork(q)
                                aapq1  = -abs(aapq)
                                mxaapq = max( mxaapq, -aapq1 )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq1 )>tol ) then
                                ompq = aapq / abs(aapq)
                 ! Rotate
      ! [rtd]      rotated = rotated + one
                                   if( ir1==0 ) then
                                      notrot = 0
                                      pskipped = 0
                                      iswrot = iswrot + 1
                                   end if
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/aapq1
                                      if( abs( theta )>bigtheta ) then
                                         t  = half / theta
                                         cs = one
                                         call stdlib_${ci}$rot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *t )
                                         if ( rsvec ) then
                                             call stdlib_${ci}$rot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*t )
                                         end if
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq1 )
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         call stdlib_${ci}$rot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *sn )
                                         if ( rsvec ) then
                                             call stdlib_${ci}$rot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*sn )
                                         end if
                                      end if
                                      cwork(p) = -cwork(q) * ompq
                                      else
                    ! .. have to use modified gram-schmidt like transformation
                                      call stdlib_${ci}$copy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_${ci}$lascl( 'G', 0, 0, aapp, one, m,1, cwork(n+1), &
                                                lda,ierr )
                                      call stdlib_${ci}$lascl( 'G', 0, 0, aaqq, one, m,1, a( 1, q ), &
                                                lda, ierr )
                                      call stdlib_${ci}$axpy( m, -aapq, cwork(n+1), 1,a( 1, q ), 1 )
                                                
                                      call stdlib_${ci}$lascl( 'G', 0, 0, one, aaqq, m,1, a( 1, q ), &
                                                lda, ierr )
                                      sva( q ) = aaqq*sqrt( max( zero,one-aapq1*aapq1 ) )
                                      mxsinj = max( mxsinj, sfmin )
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! recompute sva(q), sva(p).
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_${c2ri(ci)}$znrm2( m, a( 1, q ), 1 )
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_${ci}$lassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_${c2ri(ci)}$znrm2( m, a( 1, p ), 1 )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_${ci}$lassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )
                                      end if
                                      sva( p ) = aapp
                                   end if
                                else
                                   ! a(:,p) and a(:,q) already numerically orthogonal
                                   if( ir1==0 )notrot = notrot + 1
      ! [rtd]      skipped  = skipped + 1
                                   pskipped = pskipped + 1
                                end if
                             else
                                ! a(:,q) is zero column
                                if( ir1==0 )notrot = notrot + 1
                                pskipped = pskipped + 1
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                if( ir1==0 )aapp = -aapp
                                notrot = 0
                                go to 2103
                             end if
                          end do loop_2002
           ! end q-loop
           2103 continue
           ! bailed out of q-loop
                          sva( p ) = aapp
                       else
                          sva( p ) = aapp
                          if( ( ir1==0 ) .and. ( aapp==zero ) )notrot = notrot + min( igl+kbl-1, &
                                    n ) - p
                       end if
                    end do loop_2001
           ! end of the p-loop
           ! end of doing the block ( ibr, ibr )
                 end do loop_1002
           ! end of ir1-loop
       ! ... go to the off diagonal blocks
                 igl = ( ibr-1 )*kbl + 1
                 loop_2010: do jbc = ibr + 1, nbl
                    jgl = ( jbc-1 )*kbl + 1
              ! doing the block at ( ibr, jbc )
                    ijblsk = 0
                    loop_2100: do p = igl, min( igl+kbl-1, n )
                       aapp = sva( p )
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2200: do q = jgl, min( jgl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
           ! M X 2 Jacobi Svd 
              ! safe gram matrix computation
                                if( aaqq>=one ) then
                                   if( aapp>=aaqq ) then
                                      rotok = ( small*aapp )<=aaqq
                                   else
                                      rotok = ( small*aaqq )<=aapp
                                   end if
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_${ci}$dotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aaqq ) / aapp
                                   else
                                      call stdlib_${ci}$copy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_${ci}$lascl( 'G', 0, 0, aapp,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_${ci}$dotc( m, cwork(n+1), 1,a( 1, q ), 1 ) / &
                                                aaqq
                                   end if
                                else
                                   if( aapp>=aaqq ) then
                                      rotok = aapp<=( aaqq / small )
                                   else
                                      rotok = aaqq<=( aapp / small )
                                   end if
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_${ci}$dotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / max(&
                                                aaqq,aapp) )/ min(aaqq,aapp)
                                   else
                                      call stdlib_${ci}$copy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                      call stdlib_${ci}$lascl( 'G', 0, 0, aaqq,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_${ci}$dotc( m, a( 1, p ), 1,cwork(n+1),  1 ) / &
                                                aapp
                                   end if
                                end if
                                 ! aapq = aapq * conjg(cwork(p))*cwork(q)
                                aapq1  = -abs(aapq)
                                mxaapq = max( mxaapq, -aapq1 )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq1 )>tol ) then
                                   ompq = aapq / abs(aapq)
                                   notrot = 0
      ! [rtd]      rotated  = rotated + 1
                                   pskipped = 0
                                   iswrot = iswrot + 1
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/ aapq1
                                      if( aaqq>aapp0 )theta = -theta
                                      if( abs( theta )>bigtheta ) then
                                         t  = half / theta
                                         cs = one
                                         call stdlib_${ci}$rot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *t )
                                         if( rsvec ) then
                                             call stdlib_${ci}$rot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*t )
                                         end if
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq1 )
                                         if( aaqq>aapp0 )thsign = -thsign
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         call stdlib_${ci}$rot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *sn )
                                         if( rsvec ) then
                                             call stdlib_${ci}$rot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*sn )
                                         end if
                                      end if
                                      cwork(p) = -cwork(q) * ompq
                                   else
                    ! .. have to use modified gram-schmidt like transformation
                                    if( aapp>aaqq ) then
                                         call stdlib_${ci}$copy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                                   
                                         call stdlib_${ci}$lascl( 'G', 0, 0, aapp, one,m, 1, cwork(n+1)&
                                                   ,lda,ierr )
                                         call stdlib_${ci}$lascl( 'G', 0, 0, aaqq, one,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         call stdlib_${ci}$axpy( m, -aapq, cwork(n+1),1, a( 1, q ), 1 )
                                                   
                                         call stdlib_${ci}$lascl( 'G', 0, 0, one, aaqq,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         sva( q ) = aaqq*sqrt( max( zero,one-aapq1*aapq1 ) )
                                                   
                                         mxsinj = max( mxsinj, sfmin )
                                    else
                                        call stdlib_${ci}$copy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                         call stdlib_${ci}$lascl( 'G', 0, 0, aaqq, one,m, 1, cwork(n+1)&
                                                   ,lda,ierr )
                                         call stdlib_${ci}$lascl( 'G', 0, 0, aapp, one,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         call stdlib_${ci}$axpy( m, -conjg(aapq),cwork(n+1), 1, a( 1, &
                                                   p ), 1 )
                                         call stdlib_${ci}$lascl( 'G', 0, 0, one, aapp,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         sva( p ) = aapp*sqrt( max( zero,one-aapq1*aapq1 ) )
                                                   
                                         mxsinj = max( mxsinj, sfmin )
                                    end if
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! .. recompute sva(q), sva(p)
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_${c2ri(ci)}$znrm2( m, a( 1, q ), 1)
                                       else
                                         t = zero
                                         aaqq = one
                                         call stdlib_${ci}$lassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )**2<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_${c2ri(ci)}$znrm2( m, a( 1, p ), 1 )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_${ci}$lassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )
                                      end if
                                      sva( p ) = aapp
                                   end if
                    ! end of ok rotation
                                else
                                   notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                   ijblsk = ijblsk + 1
                                end if
                             else
                                notrot = notrot + 1
                                pskipped = pskipped + 1
                                ijblsk = ijblsk + 1
                             end if
                             if( ( i<=swband ) .and. ( ijblsk>=blskip ) )then
                                sva( p ) = aapp
                                notrot = 0
                                go to 2011
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                aapp = -aapp
                                notrot = 0
                                go to 2203
                             end if
                          end do loop_2200
              ! end of the q-loop
              2203 continue
                          sva( p ) = aapp
                       else
                          if( aapp==zero )notrot = notrot +min( jgl+kbl-1, n ) - jgl + 1
                          if( aapp<zero )notrot = 0
                       end if
                    end do loop_2100
           ! end of the p-loop
                 end do loop_2010
           ! end of the jbc-loop
           2011 continue
      ! 2011 bailed out of the jbc-loop
                 do p = igl, min( igl+kbl-1, n )
                    sva( p ) = abs( sva( p ) )
                 end do
      ! **
              end do loop_2000
      ! 2000 :: end of the ibr-loop
           ! .. update sva(n)
              if( ( sva( n )<rootbig ) .and. ( sva( n )>rootsfmin ) )then
                 sva( n ) = stdlib_${c2ri(ci)}$znrm2( m, a( 1, n ), 1 )
              else
                 t = zero
                 aapp = one
                 call stdlib_${ci}$lassq( m, a( 1, n ), 1, t, aapp )
                 sva( n ) = t*sqrt( aapp )
              end if
           ! additional steering devices
              if( ( i<swband ) .and. ( ( mxaapq<=roottol ) .or.( iswrot<=n ) ) )swband = i
              if( ( i>swband+1 ) .and. ( mxaapq<sqrt( real( n,KIND=${ck}$) )*tol ) .and. ( real( n,&
                        KIND=${ck}$)*mxaapq*mxsinj<tol ) ) then
                 go to 1994
              end if
              if( notrot>=emptsw )go to 1994
           end do loop_1993
           ! end i=1:nsweep loop
       ! #:( reaching this point means that the procedure has not converged.
           info = nsweep - 1
           go to 1995
           1994 continue
       ! #:) reaching this point means numerical convergence after the i-th
           ! sweep.
           info = 0
       ! #:) info = 0 confirms successful iterations.
       1995 continue
           ! sort the singular values and find how many are above
           ! the underflow threshold.
           n2 = 0
           n4 = 0
           do p = 1, n - 1
              q = stdlib_i${c2ri(ci)}$amax( n-p+1, sva( p ), 1 ) + p - 1
              if( p/=q ) then
                 temp1 = sva( p )
                 sva( p ) = sva( q )
                 sva( q ) = temp1
                 call stdlib_${ci}$swap( m, a( 1, p ), 1, a( 1, q ), 1 )
                 if( rsvec )call stdlib_${ci}$swap( mvl, v( 1, p ), 1, v( 1, q ), 1 )
              end if
              if( sva( p )/=zero ) then
                 n4 = n4 + 1
                 if( sva( p )*skl>sfmin )n2 = n2 + 1
              end if
           end do
           if( sva( n )/=zero ) then
              n4 = n4 + 1
              if( sva( n )*skl>sfmin )n2 = n2 + 1
           end if
           ! normalize the left singular vectors.
           if( lsvec .or. uctol ) then
              do p = 1, n4
                  ! call stdlib_${ci}$dscal( m, one / sva( p ), a( 1, p ), 1 )
                 call stdlib_${ci}$lascl( 'G',0,0, sva(p), one, m, 1, a(1,p), m, ierr )
              end do
           end if
           ! scale the product of jacobi rotations.
           if( rsvec ) then
                 do p = 1, n
                    temp1 = one / stdlib_${c2ri(ci)}$znrm2( mvl, v( 1, p ), 1 )
                    call stdlib_${ci}$dscal( mvl, temp1, v( 1, p ), 1 )
                 end do
           end if
           ! undo scaling, if necessary (and possible).
           if( ( ( skl>one ) .and. ( sva( 1 )<( big / skl ) ) ).or. ( ( skl<one ) .and. ( sva( &
                     max( n2, 1 ) ) >( sfmin / skl ) ) ) ) then
              do p = 1, n
                 sva( p ) = skl*sva( p )
              end do
              skl = one
           end if
           rwork( 1 ) = skl
           ! the singular values of a are skl*sva(1:n). if skl/=one
           ! then some of the singular values may overflow or underflow and
           ! the spectrum is given in this factored representation.
           rwork( 2 ) = real( n4,KIND=${ck}$)
           ! n4 is the number of computed nonzero singular values of a.
           rwork( 3 ) = real( n2,KIND=${ck}$)
           ! n2 is the number of singular values of a greater than sfmin.
           ! if n2<n, sva(n2:n) contains zeros and/or denormalized numbers
           ! that may carry some information.
           rwork( 4 ) = real( i,KIND=${ck}$)
           ! i is the index of the last sweep before declaring convergence.
           rwork( 5 ) = mxaapq
           ! mxaapq is the largest absolute value of scaled pivots in the
           ! last sweep
           rwork( 6 ) = mxsinj
           ! mxsinj is the largest absolute value of the sines of jacobi angles
           ! in the last sweep
           return
     end subroutine stdlib_${ci}$gesvj

#:endif
#:endfor





     module subroutine stdlib_sgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, iwork, info )
     !! SGESDD computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, optionally computing the left and right singular
     !! vectors.  If singular vectors are desired, it uses a
     !! divide-and-conquer algorithm.
     !! The SVD is written
     !! A = U * SIGMA * transpose(V)
     !! where SIGMA is an M-by-N matrix which is zero except for its
     !! min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
     !! V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
     !! are the singular values of A; they are real and non-negative, and
     !! are returned in descending order.  The first min(m,n) columns of
     !! U and V are the left and right singular vectors of A.
     !! Note that the routine returns VT = V**T, not V.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldvt, lwork, m, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: s(*), u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wntqa, wntqas, wntqn, wntqo, wntqs
           integer(ilp) :: bdspac, blk, chunk, i, ie, ierr, il, ir, iscl, itau, itaup, itauq, iu, &
                     ivt, ldwkvt, ldwrkl, ldwrkr, ldwrku, maxwrk, minmn, minwrk, mnthr, nwork, wrkbl
           integer(ilp) :: lwork_sgebrd_mn, lwork_sgebrd_mm, lwork_sgebrd_nn, lwork_sgelqf_mn, &
           lwork_sgeqrf_mn, lwork_sorgbr_p_mm, lwork_sorgbr_q_nn, lwork_sorglq_mn, &
           lwork_sorglq_nn, lwork_sorgqr_mm, lwork_sorgqr_mn, lwork_sormbr_prt_mm, &
           lwork_sormbr_qln_mm, lwork_sormbr_prt_mn, lwork_sormbr_qln_mn, lwork_sormbr_prt_nn, &
                     lwork_sormbr_qln_nn
           real(sp) :: anrm, bignum, eps, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(sp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info   = 0
           minmn  = min( m, n )
           wntqa  = stdlib_lsame( jobz, 'A' )
           wntqs  = stdlib_lsame( jobz, 'S' )
           wntqas = wntqa .or. wntqs
           wntqo  = stdlib_lsame( jobz, 'O' )
           wntqn  = stdlib_lsame( jobz, 'N' )
           lquery = ( lwork==-1 )
           if( .not.( wntqa .or. wntqs .or. wntqo .or. wntqn ) ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldu<1 .or. ( wntqas .and. ldu<m ) .or.( wntqo .and. m<n .and. ldu<m ) ) &
                     then
              info = -8
           else if( ldvt<1 .or. ( wntqa .and. ldvt<n ) .or.( wntqs .and. ldvt<minmn ) .or.( wntqo &
                     .and. m>=n .and. ldvt<n ) ) then
              info = -10
           end if
           ! compute workspace
             ! note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace allocated at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              bdspac = 0
              mnthr  = int( minmn*11.0_sp / 6.0_sp,KIND=ilp)
              if( m>=n .and. minmn>0 ) then
                 ! compute space needed for stdlib_sbdsdc
                 if( wntqn ) then
                    ! stdlib_sbdsdc needs only 4*n (or 6*n for uplo=l for lapack <= 3.6_sp)
                    ! keep 7*n for backwards compatibility.
                    bdspac = 7*n
                 else
                    bdspac = 3*n*n + 4*n
                 end if
                 ! compute space preferred for each routine
                 call stdlib_sgebrd( m, n, dum(1), m, dum(1), dum(1), dum(1),dum(1), dum(1), -1, &
                           ierr )
                 lwork_sgebrd_mn = int( dum(1),KIND=ilp)
                 call stdlib_sgebrd( n, n, dum(1), n, dum(1), dum(1), dum(1),dum(1), dum(1), -1, &
                           ierr )
                 lwork_sgebrd_nn = int( dum(1),KIND=ilp)
                 call stdlib_sgeqrf( m, n, dum(1), m, dum(1), dum(1), -1, ierr )
                 lwork_sgeqrf_mn = int( dum(1),KIND=ilp)
                 call stdlib_sorgbr( 'Q', n, n, n, dum(1), n, dum(1), dum(1), -1,ierr )
                 lwork_sorgbr_q_nn = int( dum(1),KIND=ilp)
                 call stdlib_sorgqr( m, m, n, dum(1), m, dum(1), dum(1), -1, ierr )
                 lwork_sorgqr_mm = int( dum(1),KIND=ilp)
                 call stdlib_sorgqr( m, n, n, dum(1), m, dum(1), dum(1), -1, ierr )
                 lwork_sorgqr_mn = int( dum(1),KIND=ilp)
                 call stdlib_sormbr( 'P', 'R', 'T', n, n, n, dum(1), n,dum(1), dum(1), n, dum(1), &
                           -1, ierr )
                 lwork_sormbr_prt_nn = int( dum(1),KIND=ilp)
                 call stdlib_sormbr( 'Q', 'L', 'N', n, n, n, dum(1), n,dum(1), dum(1), n, dum(1), &
                           -1, ierr )
                 lwork_sormbr_qln_nn = int( dum(1),KIND=ilp)
                 call stdlib_sormbr( 'Q', 'L', 'N', m, n, n, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_sormbr_qln_mn = int( dum(1),KIND=ilp)
                 call stdlib_sormbr( 'Q', 'L', 'N', m, m, n, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_sormbr_qln_mm = int( dum(1),KIND=ilp)
                 if( m>=mnthr ) then
                    if( wntqn ) then
                       ! path 1 (m >> n, jobz='n')
                       wrkbl = n + lwork_sgeqrf_mn
                       wrkbl = max( wrkbl, 3*n + lwork_sgebrd_nn )
                       maxwrk = max( wrkbl, bdspac + n )
                       minwrk = bdspac + n
                    else if( wntqo ) then
                       ! path 2 (m >> n, jobz='o')
                       wrkbl = n + lwork_sgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_sorgqr_mn )
                       wrkbl = max( wrkbl, 3*n + lwork_sgebrd_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_sormbr_qln_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_sormbr_prt_nn )
                       wrkbl = max( wrkbl, 3*n + bdspac )
                       maxwrk = wrkbl + 2*n*n
                       minwrk = bdspac + 2*n*n + 3*n
                    else if( wntqs ) then
                       ! path 3 (m >> n, jobz='s')
                       wrkbl = n + lwork_sgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_sorgqr_mn )
                       wrkbl = max( wrkbl, 3*n + lwork_sgebrd_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_sormbr_qln_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_sormbr_prt_nn )
                       wrkbl = max( wrkbl, 3*n + bdspac )
                       maxwrk = wrkbl + n*n
                       minwrk = bdspac + n*n + 3*n
                    else if( wntqa ) then
                       ! path 4 (m >> n, jobz='a')
                       wrkbl = n + lwork_sgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_sorgqr_mm )
                       wrkbl = max( wrkbl, 3*n + lwork_sgebrd_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_sormbr_qln_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_sormbr_prt_nn )
                       wrkbl = max( wrkbl, 3*n + bdspac )
                       maxwrk = wrkbl + n*n
                       minwrk = n*n + max( 3*n + bdspac, n + m )
                    end if
                 else
                    ! path 5 (m >= n, but not much larger)
                    wrkbl = 3*n + lwork_sgebrd_mn
                    if( wntqn ) then
                       ! path 5n (m >= n, jobz='n')
                       maxwrk = max( wrkbl, 3*n + bdspac )
                       minwrk = 3*n + max( m, bdspac )
                    else if( wntqo ) then
                       ! path 5o (m >= n, jobz='o')
                       wrkbl = max( wrkbl, 3*n + lwork_sormbr_prt_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_sormbr_qln_mn )
                       wrkbl = max( wrkbl, 3*n + bdspac )
                       maxwrk = wrkbl + m*n
                       minwrk = 3*n + max( m, n*n + bdspac )
                    else if( wntqs ) then
                       ! path 5s (m >= n, jobz='s')
                       wrkbl = max( wrkbl, 3*n + lwork_sormbr_qln_mn )
                       wrkbl = max( wrkbl, 3*n + lwork_sormbr_prt_nn )
                       maxwrk = max( wrkbl, 3*n + bdspac )
                       minwrk = 3*n + max( m, bdspac )
                    else if( wntqa ) then
                       ! path 5a (m >= n, jobz='a')
                       wrkbl = max( wrkbl, 3*n + lwork_sormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*n + lwork_sormbr_prt_nn )
                       maxwrk = max( wrkbl, 3*n + bdspac )
                       minwrk = 3*n + max( m, bdspac )
                    end if
                 end if
              else if( minmn>0 ) then
                 ! compute space needed for stdlib_sbdsdc
                 if( wntqn ) then
                    ! stdlib_sbdsdc needs only 4*n (or 6*n for uplo=l for lapack <= 3.6_sp)
                    ! keep 7*n for backwards compatibility.
                    bdspac = 7*m
                 else
                    bdspac = 3*m*m + 4*m
                 end if
                 ! compute space preferred for each routine
                 call stdlib_sgebrd( m, n, dum(1), m, dum(1), dum(1), dum(1),dum(1), dum(1), -1, &
                           ierr )
                 lwork_sgebrd_mn = int( dum(1),KIND=ilp)
                 call stdlib_sgebrd( m, m, a, m, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                           
                 lwork_sgebrd_mm = int( dum(1),KIND=ilp)
                 call stdlib_sgelqf( m, n, a, m, dum(1), dum(1), -1, ierr )
                 lwork_sgelqf_mn = int( dum(1),KIND=ilp)
                 call stdlib_sorglq( n, n, m, dum(1), n, dum(1), dum(1), -1, ierr )
                 lwork_sorglq_nn = int( dum(1),KIND=ilp)
                 call stdlib_sorglq( m, n, m, a, m, dum(1), dum(1), -1, ierr )
                 lwork_sorglq_mn = int( dum(1),KIND=ilp)
                 call stdlib_sorgbr( 'P', m, m, m, a, n, dum(1), dum(1), -1, ierr )
                 lwork_sorgbr_p_mm = int( dum(1),KIND=ilp)
                 call stdlib_sormbr( 'P', 'R', 'T', m, m, m, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_sormbr_prt_mm = int( dum(1),KIND=ilp)
                 call stdlib_sormbr( 'P', 'R', 'T', m, n, m, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_sormbr_prt_mn = int( dum(1),KIND=ilp)
                 call stdlib_sormbr( 'P', 'R', 'T', n, n, m, dum(1), n,dum(1), dum(1), n, dum(1), &
                           -1, ierr )
                 lwork_sormbr_prt_nn = int( dum(1),KIND=ilp)
                 call stdlib_sormbr( 'Q', 'L', 'N', m, m, m, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_sormbr_qln_mm = int( dum(1),KIND=ilp)
                 if( n>=mnthr ) then
                    if( wntqn ) then
                       ! path 1t (n >> m, jobz='n')
                       wrkbl = m + lwork_sgelqf_mn
                       wrkbl = max( wrkbl, 3*m + lwork_sgebrd_mm )
                       maxwrk = max( wrkbl, bdspac + m )
                       minwrk = bdspac + m
                    else if( wntqo ) then
                       ! path 2t (n >> m, jobz='o')
                       wrkbl = m + lwork_sgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_sorglq_mn )
                       wrkbl = max( wrkbl, 3*m + lwork_sgebrd_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_sormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_sormbr_prt_mm )
                       wrkbl = max( wrkbl, 3*m + bdspac )
                       maxwrk = wrkbl + 2*m*m
                       minwrk = bdspac + 2*m*m + 3*m
                    else if( wntqs ) then
                       ! path 3t (n >> m, jobz='s')
                       wrkbl = m + lwork_sgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_sorglq_mn )
                       wrkbl = max( wrkbl, 3*m + lwork_sgebrd_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_sormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_sormbr_prt_mm )
                       wrkbl = max( wrkbl, 3*m + bdspac )
                       maxwrk = wrkbl + m*m
                       minwrk = bdspac + m*m + 3*m
                    else if( wntqa ) then
                       ! path 4t (n >> m, jobz='a')
                       wrkbl = m + lwork_sgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_sorglq_nn )
                       wrkbl = max( wrkbl, 3*m + lwork_sgebrd_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_sormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_sormbr_prt_mm )
                       wrkbl = max( wrkbl, 3*m + bdspac )
                       maxwrk = wrkbl + m*m
                       minwrk = m*m + max( 3*m + bdspac, m + n )
                    end if
                 else
                    ! path 5t (n > m, but not much larger)
                    wrkbl = 3*m + lwork_sgebrd_mn
                    if( wntqn ) then
                       ! path 5tn (n > m, jobz='n')
                       maxwrk = max( wrkbl, 3*m + bdspac )
                       minwrk = 3*m + max( n, bdspac )
                    else if( wntqo ) then
                       ! path 5to (n > m, jobz='o')
                       wrkbl = max( wrkbl, 3*m + lwork_sormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_sormbr_prt_mn )
                       wrkbl = max( wrkbl, 3*m + bdspac )
                       maxwrk = wrkbl + m*n
                       minwrk = 3*m + max( n, m*m + bdspac )
                    else if( wntqs ) then
                       ! path 5ts (n > m, jobz='s')
                       wrkbl = max( wrkbl, 3*m + lwork_sormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_sormbr_prt_mn )
                       maxwrk = max( wrkbl, 3*m + bdspac )
                       minwrk = 3*m + max( n, bdspac )
                    else if( wntqa ) then
                       ! path 5ta (n > m, jobz='a')
                       wrkbl = max( wrkbl, 3*m + lwork_sormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_sormbr_prt_nn )
                       maxwrk = max( wrkbl, 3*m + bdspac )
                       minwrk = 3*m + max( n, bdspac )
                    end if
                 end if
              end if
              maxwrk = max( maxwrk, minwrk )
              work( 1 ) = stdlib_sroundup_lwork( maxwrk )
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGESDD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = sqrt( stdlib_slamch( 'S' ) ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_slange( 'M', m, n, a, lda, dum )
           if( stdlib_sisnan( anrm ) ) then
               info = -4
               return
           end if
           iscl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              iscl = 1
              call stdlib_slascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, ierr )
           else if( anrm>bignum ) then
              iscl = 1
              call stdlib_slascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, ierr )
           end if
           if( m>=n ) then
              ! a has at least as many rows as columns. if a has sufficiently
              ! more rows than columns, first reduce using the qr
              ! decomposition (if sufficient workspace available)
              if( m>=mnthr ) then
                 if( wntqn ) then
                    ! path 1 (m >> n, jobz='n')
                    ! no singular vectors to be computed
                    itau = 1
                    nwork = itau + n
                    ! compute a=q*r
                    ! workspace: need   n [tau] + n    [work]
                    ! workspace: prefer n [tau] + n*nb [work]
                    call stdlib_sgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! zero out below r
                    if (n>1) call stdlib_slaset( 'L', n-1, n-1, zero, zero, a( 2, 1 ), lda )
                    ie = 1
                    itauq = ie + n
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in a
                    ! workspace: need   3*n [e, tauq, taup] + n      [work]
                    ! workspace: prefer 3*n [e, tauq, taup] + 2*n*nb [work]
                    call stdlib_sgebrd( n, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( nwork ), lwork-nwork+1,ierr )
                    nwork = ie + n
                    ! perform bidiagonal svd, computing singular values only
                    ! workspace: need   n [e] + bdspac
                    call stdlib_sbdsdc( 'U', 'N', n, s, work( ie ), dum, 1, dum, 1,dum, idum, &
                              work( nwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 2 (m >> n, jobz = 'o')
                    ! n left singular vectors to be overwritten on a and
                    ! n right singular vectors to be computed in vt
                    ir = 1
                    ! work(ir) is ldwrkr by n
                    if( lwork >= lda*n + n*n + 3*n + bdspac ) then
                       ldwrkr = lda
                    else
                       ldwrkr = ( lwork - n*n - 3*n - bdspac ) / n
                    end if
                    itau = ir + ldwrkr*n
                    nwork = itau + n
                    ! compute a=q*r
                    ! workspace: need   n*n [r] + n [tau] + n    [work]
                    ! workspace: prefer n*n [r] + n [tau] + n*nb [work]
                    call stdlib_sgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! copy r to work(ir), zeroing out below it
                    call stdlib_slacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                    call stdlib_slaset( 'L', n - 1, n - 1, zero, zero, work(ir+1),ldwrkr )
                    ! generate q in a
                    ! workspace: need   n*n [r] + n [tau] + n    [work]
                    ! workspace: prefer n*n [r] + n [tau] + n*nb [work]
                    call stdlib_sorgqr( m, n, n, a, lda, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ie = itau
                    itauq = ie + n
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in work(ir)
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n      [work]
                    ! workspace: prefer n*n [r] + 3*n [e, tauq, taup] + 2*n*nb [work]
                    call stdlib_sgebrd( n, n, work( ir ), ldwrkr, s, work( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork - nwork + 1, ierr )
                    ! work(iu) is n by n
                    iu = nwork
                    nwork = iu + n*n
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in work(iu) and computing right
                    ! singular vectors of bidiagonal matrix in vt
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n*n [u] + bdspac
                    call stdlib_sbdsdc( 'U', 'I', n, s, work( ie ), work( iu ), n,vt, ldvt, dum, &
                              idum, work( nwork ), iwork,info )
                    ! overwrite work(iu) by left singular vectors of r
                    ! and vt by right singular vectors of r
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n*n [u] + n    [work]
                    ! workspace: prefer n*n [r] + 3*n [e, tauq, taup] + n*n [u] + n*nb [work]
                    call stdlib_sormbr( 'Q', 'L', 'N', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                              work( iu ), n, work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_sormbr( 'P', 'R', 'T', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork - nwork + 1, ierr )
                    ! multiply q in a by left singular vectors of r in
                    ! work(iu), storing result in work(ir) and copying to a
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n*n [u]
                    ! workspace: prefer m*n [r] + 3*n [e, tauq, taup] + n*n [u]
                    do i = 1, m, ldwrkr
                       chunk = min( m - i + 1, ldwrkr )
                       call stdlib_sgemm( 'N', 'N', chunk, n, n, one, a( i, 1 ),lda, work( iu ), &
                                 n, zero, work( ir ),ldwrkr )
                       call stdlib_slacpy( 'F', chunk, n, work( ir ), ldwrkr,a( i, 1 ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 3 (m >> n, jobz='s')
                    ! n left singular vectors to be computed in u and
                    ! n right singular vectors to be computed in vt
                    ir = 1
                    ! work(ir) is n by n
                    ldwrkr = n
                    itau = ir + ldwrkr*n
                    nwork = itau + n
                    ! compute a=q*r
                    ! workspace: need   n*n [r] + n [tau] + n    [work]
                    ! workspace: prefer n*n [r] + n [tau] + n*nb [work]
                    call stdlib_sgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! copy r to work(ir), zeroing out below it
                    call stdlib_slacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                    call stdlib_slaset( 'L', n - 1, n - 1, zero, zero, work(ir+1),ldwrkr )
                    ! generate q in a
                    ! workspace: need   n*n [r] + n [tau] + n    [work]
                    ! workspace: prefer n*n [r] + n [tau] + n*nb [work]
                    call stdlib_sorgqr( m, n, n, a, lda, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ie = itau
                    itauq = ie + n
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in work(ir)
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n      [work]
                    ! workspace: prefer n*n [r] + 3*n [e, tauq, taup] + 2*n*nb [work]
                    call stdlib_sgebrd( n, n, work( ir ), ldwrkr, s, work( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork - nwork + 1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagoal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + bdspac
                    call stdlib_sbdsdc( 'U', 'I', n, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! overwrite u by left singular vectors of r and vt
                    ! by right singular vectors of r
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n    [work]
                    ! workspace: prefer n*n [r] + 3*n [e, tauq, taup] + n*nb [work]
                    call stdlib_sormbr( 'Q', 'L', 'N', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                              u, ldu, work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_sormbr( 'P', 'R', 'T', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork - nwork + 1, ierr )
                    ! multiply q in a by left singular vectors of r in
                    ! work(ir), storing result in u
                    ! workspace: need   n*n [r]
                    call stdlib_slacpy( 'F', n, n, u, ldu, work( ir ), ldwrkr )
                    call stdlib_sgemm( 'N', 'N', m, n, n, one, a, lda, work( ir ),ldwrkr, zero, u,&
                               ldu )
                 else if( wntqa ) then
                    ! path 4 (m >> n, jobz='a')
                    ! m left singular vectors to be computed in u and
                    ! n right singular vectors to be computed in vt
                    iu = 1
                    ! work(iu) is n by n
                    ldwrku = n
                    itau = iu + ldwrku*n
                    nwork = itau + n
                    ! compute a=q*r, copying result to u
                    ! workspace: need   n*n [u] + n [tau] + n    [work]
                    ! workspace: prefer n*n [u] + n [tau] + n*nb [work]
                    call stdlib_sgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    call stdlib_slacpy( 'L', m, n, a, lda, u, ldu )
                    ! generate q in u
                    ! workspace: need   n*n [u] + n [tau] + m    [work]
                    ! workspace: prefer n*n [u] + n [tau] + m*nb [work]
                    call stdlib_sorgqr( m, m, n, u, ldu, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ! produce r in a, zeroing out other entries
                    if (n>1) call stdlib_slaset( 'L', n-1, n-1, zero, zero, a( 2, 1 ), lda )
                    ie = itau
                    itauq = ie + n
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in a
                    ! workspace: need   n*n [u] + 3*n [e, tauq, taup] + n      [work]
                    ! workspace: prefer n*n [u] + 3*n [e, tauq, taup] + 2*n*nb [work]
                    call stdlib_sgebrd( n, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( nwork ), lwork-nwork+1,ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in work(iu) and computing right
                    ! singular vectors of bidiagonal matrix in vt
                    ! workspace: need   n*n [u] + 3*n [e, tauq, taup] + bdspac
                    call stdlib_sbdsdc( 'U', 'I', n, s, work( ie ), work( iu ), n,vt, ldvt, dum, &
                              idum, work( nwork ), iwork,info )
                    ! overwrite work(iu) by left singular vectors of r and vt
                    ! by right singular vectors of r
                    ! workspace: need   n*n [u] + 3*n [e, tauq, taup] + n    [work]
                    ! workspace: prefer n*n [u] + 3*n [e, tauq, taup] + n*nb [work]
                    call stdlib_sormbr( 'Q', 'L', 'N', n, n, n, a, lda,work( itauq ), work( iu ), &
                              ldwrku,work( nwork ), lwork - nwork + 1, ierr )
                    call stdlib_sormbr( 'P', 'R', 'T', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    ! multiply q in u by left singular vectors of r in
                    ! work(iu), storing result in a
                    ! workspace: need   n*n [u]
                    call stdlib_sgemm( 'N', 'N', m, n, n, one, u, ldu, work( iu ),ldwrku, zero, a,&
                               lda )
                    ! copy left singular vectors of a from a to u
                    call stdlib_slacpy( 'F', m, n, a, lda, u, ldu )
                 end if
              else
                 ! m < mnthr
                 ! path 5 (m >= n, but not much larger)
                 ! reduce to bidiagonal form without qr decomposition
                 ie = 1
                 itauq = ie + n
                 itaup = itauq + n
                 nwork = itaup + n
                 ! bidiagonalize a
                 ! workspace: need   3*n [e, tauq, taup] + m        [work]
                 ! workspace: prefer 3*n [e, tauq, taup] + (m+n)*nb [work]
                 call stdlib_sgebrd( m, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 5n (m >= n, jobz='n')
                    ! perform bidiagonal svd, only computing singular values
                    ! workspace: need   3*n [e, tauq, taup] + bdspac
                    call stdlib_sbdsdc( 'U', 'N', n, s, work( ie ), dum, 1, dum, 1,dum, idum, &
                              work( nwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 5o (m >= n, jobz='o')
                    iu = nwork
                    if( lwork >= m*n + 3*n + bdspac ) then
                       ! work( iu ) is m by n
                       ldwrku = m
                       nwork = iu + ldwrku*n
                       call stdlib_slaset( 'F', m, n, zero, zero, work( iu ),ldwrku )
                       ! ir is unused; silence compile warnings
                       ir = -1
                    else
                       ! work( iu ) is n by n
                       ldwrku = n
                       nwork = iu + ldwrku*n
                       ! work(ir) is ldwrkr by n
                       ir = nwork
                       ldwrkr = ( lwork - n*n - 3*n ) / n
                    end if
                    nwork = iu + ldwrku*n
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in work(iu) and computing right
                    ! singular vectors of bidiagonal matrix in vt
                    ! workspace: need   3*n [e, tauq, taup] + n*n [u] + bdspac
                    call stdlib_sbdsdc( 'U', 'I', n, s, work( ie ), work( iu ),ldwrku, vt, ldvt, &
                              dum, idum, work( nwork ),iwork, info )
                    ! overwrite vt by right singular vectors of a
                    ! workspace: need   3*n [e, tauq, taup] + n*n [u] + n    [work]
                    ! workspace: prefer 3*n [e, tauq, taup] + n*n [u] + n*nb [work]
                    call stdlib_sormbr( 'P', 'R', 'T', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    if( lwork >= m*n + 3*n + bdspac ) then
                       ! path 5o-fast
                       ! overwrite work(iu) by left singular vectors of a
                       ! workspace: need   3*n [e, tauq, taup] + m*n [u] + n    [work]
                       ! workspace: prefer 3*n [e, tauq, taup] + m*n [u] + n*nb [work]
                       call stdlib_sormbr( 'Q', 'L', 'N', m, n, n, a, lda,work( itauq ), work( iu &
                                 ), ldwrku,work( nwork ), lwork - nwork + 1, ierr )
                       ! copy left singular vectors of a from work(iu) to a
                       call stdlib_slacpy( 'F', m, n, work( iu ), ldwrku, a, lda )
                    else
                       ! path 5o-slow
                       ! generate q in a
                       ! workspace: need   3*n [e, tauq, taup] + n*n [u] + n    [work]
                       ! workspace: prefer 3*n [e, tauq, taup] + n*n [u] + n*nb [work]
                       call stdlib_sorgbr( 'Q', m, n, n, a, lda, work( itauq ),work( nwork ), &
                                 lwork - nwork + 1, ierr )
                       ! multiply q in a by left singular vectors of
                       ! bidiagonal matrix in work(iu), storing result in
                       ! work(ir) and copying to a
                       ! workspace: need   3*n [e, tauq, taup] + n*n [u] + nb*n [r]
                       ! workspace: prefer 3*n [e, tauq, taup] + n*n [u] + m*n  [r]
                       do i = 1, m, ldwrkr
                          chunk = min( m - i + 1, ldwrkr )
                          call stdlib_sgemm( 'N', 'N', chunk, n, n, one, a( i, 1 ),lda, work( iu )&
                                    , ldwrku, zero,work( ir ), ldwrkr )
                          call stdlib_slacpy( 'F', chunk, n, work( ir ), ldwrkr,a( i, 1 ), lda )
                                    
                       end do
                    end if
                 else if( wntqs ) then
                    ! path 5s (m >= n, jobz='s')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   3*n [e, tauq, taup] + bdspac
                    call stdlib_slaset( 'F', m, n, zero, zero, u, ldu )
                    call stdlib_sbdsdc( 'U', 'I', n, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! overwrite u by left singular vectors of a and vt
                    ! by right singular vectors of a
                    ! workspace: need   3*n [e, tauq, taup] + n    [work]
                    ! workspace: prefer 3*n [e, tauq, taup] + n*nb [work]
                    call stdlib_sormbr( 'Q', 'L', 'N', m, n, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_sormbr( 'P', 'R', 'T', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                 else if( wntqa ) then
                    ! path 5a (m >= n, jobz='a')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   3*n [e, tauq, taup] + bdspac
                    call stdlib_slaset( 'F', m, m, zero, zero, u, ldu )
                    call stdlib_sbdsdc( 'U', 'I', n, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! set the right corner of u to identity matrix
                    if( m>n ) then
                       call stdlib_slaset( 'F', m - n, m - n, zero, one, u(n+1,n+1),ldu )
                    end if
                    ! overwrite u by left singular vectors of a and vt
                    ! by right singular vectors of a
                    ! workspace: need   3*n [e, tauq, taup] + m    [work]
                    ! workspace: prefer 3*n [e, tauq, taup] + m*nb [work]
                    call stdlib_sormbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_sormbr( 'P', 'R', 'T', n, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                 end if
              end if
           else
              ! a has more columns than rows. if a has sufficiently more
              ! columns than rows, first reduce using the lq decomposition (if
              ! sufficient workspace available)
              if( n>=mnthr ) then
                 if( wntqn ) then
                    ! path 1t (n >> m, jobz='n')
                    ! no singular vectors to be computed
                    itau = 1
                    nwork = itau + m
                    ! compute a=l*q
                    ! workspace: need   m [tau] + m [work]
                    ! workspace: prefer m [tau] + m*nb [work]
                    call stdlib_sgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! zero out above l
                    if (m>1) call stdlib_slaset( 'U', m-1, m-1, zero, zero, a( 1, 2 ), lda )
                    ie = 1
                    itauq = ie + m
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in a
                    ! workspace: need   3*m [e, tauq, taup] + m      [work]
                    ! workspace: prefer 3*m [e, tauq, taup] + 2*m*nb [work]
                    call stdlib_sgebrd( m, m, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( nwork ), lwork-nwork+1,ierr )
                    nwork = ie + m
                    ! perform bidiagonal svd, computing singular values only
                    ! workspace: need   m [e] + bdspac
                    call stdlib_sbdsdc( 'U', 'N', m, s, work( ie ), dum, 1, dum, 1,dum, idum, &
                              work( nwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 2t (n >> m, jobz='o')
                    ! m right singular vectors to be overwritten on a and
                    ! m left singular vectors to be computed in u
                    ivt = 1
                    ! work(ivt) is m by m
                    ! work(il)  is m by m; it is later resized to m by chunk for gemm
                    il = ivt + m*m
                    if( lwork >= m*n + m*m + 3*m + bdspac ) then
                       ldwrkl = m
                       chunk = n
                    else
                       ldwrkl = m
                       chunk = ( lwork - m*m ) / m
                    end if
                    itau = il + ldwrkl*m
                    nwork = itau + m
                    ! compute a=l*q
                    ! workspace: need   m*m [vt] + m*m [l] + m [tau] + m    [work]
                    ! workspace: prefer m*m [vt] + m*m [l] + m [tau] + m*nb [work]
                    call stdlib_sgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! copy l to work(il), zeroing about above it
                    call stdlib_slacpy( 'L', m, m, a, lda, work( il ), ldwrkl )
                    call stdlib_slaset( 'U', m - 1, m - 1, zero, zero,work( il + ldwrkl ), ldwrkl &
                              )
                    ! generate q in a
                    ! workspace: need   m*m [vt] + m*m [l] + m [tau] + m    [work]
                    ! workspace: prefer m*m [vt] + m*m [l] + m [tau] + m*nb [work]
                    call stdlib_sorglq( m, n, m, a, lda, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ie = itau
                    itauq = ie + m
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in work(il)
                    ! workspace: need   m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + m      [work]
                    ! workspace: prefer m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + 2*m*nb [work]
                    call stdlib_sgebrd( m, m, work( il ), ldwrkl, s, work( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork - nwork + 1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u, and computing right singular
                    ! vectors of bidiagonal matrix in work(ivt)
                    ! workspace: need   m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + bdspac
                    call stdlib_sbdsdc( 'U', 'I', m, s, work( ie ), u, ldu,work( ivt ), m, dum, &
                              idum, work( nwork ),iwork, info )
                    ! overwrite u by left singular vectors of l and work(ivt)
                    ! by right singular vectors of l
                    ! workspace: need   m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + m    [work]
                    ! workspace: prefer m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + m*nb [work]
                    call stdlib_sormbr( 'Q', 'L', 'N', m, m, m, work( il ), ldwrkl,work( itauq ), &
                              u, ldu, work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_sormbr( 'P', 'R', 'T', m, m, m, work( il ), ldwrkl,work( itaup ), &
                              work( ivt ), m,work( nwork ), lwork - nwork + 1, ierr )
                    ! multiply right singular vectors of l in work(ivt) by q
                    ! in a, storing result in work(il) and copying to a
                    ! workspace: need   m*m [vt] + m*m [l]
                    ! workspace: prefer m*m [vt] + m*n [l]
                    ! at this point, l is resized as m by chunk.
                    do i = 1, n, chunk
                       blk = min( n - i + 1, chunk )
                       call stdlib_sgemm( 'N', 'N', m, blk, m, one, work( ivt ), m,a( 1, i ), lda,&
                                  zero, work( il ), ldwrkl )
                       call stdlib_slacpy( 'F', m, blk, work( il ), ldwrkl,a( 1, i ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 3t (n >> m, jobz='s')
                    ! m right singular vectors to be computed in vt and
                    ! m left singular vectors to be computed in u
                    il = 1
                    ! work(il) is m by m
                    ldwrkl = m
                    itau = il + ldwrkl*m
                    nwork = itau + m
                    ! compute a=l*q
                    ! workspace: need   m*m [l] + m [tau] + m    [work]
                    ! workspace: prefer m*m [l] + m [tau] + m*nb [work]
                    call stdlib_sgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! copy l to work(il), zeroing out above it
                    call stdlib_slacpy( 'L', m, m, a, lda, work( il ), ldwrkl )
                    call stdlib_slaset( 'U', m - 1, m - 1, zero, zero,work( il + ldwrkl ), ldwrkl &
                              )
                    ! generate q in a
                    ! workspace: need   m*m [l] + m [tau] + m    [work]
                    ! workspace: prefer m*m [l] + m [tau] + m*nb [work]
                    call stdlib_sorglq( m, n, m, a, lda, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ie = itau
                    itauq = ie + m
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in work(iu).
                    ! workspace: need   m*m [l] + 3*m [e, tauq, taup] + m      [work]
                    ! workspace: prefer m*m [l] + 3*m [e, tauq, taup] + 2*m*nb [work]
                    call stdlib_sgebrd( m, m, work( il ), ldwrkl, s, work( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork - nwork + 1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   m*m [l] + 3*m [e, tauq, taup] + bdspac
                    call stdlib_sbdsdc( 'U', 'I', m, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! overwrite u by left singular vectors of l and vt
                    ! by right singular vectors of l
                    ! workspace: need   m*m [l] + 3*m [e, tauq, taup] + m    [work]
                    ! workspace: prefer m*m [l] + 3*m [e, tauq, taup] + m*nb [work]
                    call stdlib_sormbr( 'Q', 'L', 'N', m, m, m, work( il ), ldwrkl,work( itauq ), &
                              u, ldu, work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_sormbr( 'P', 'R', 'T', m, m, m, work( il ), ldwrkl,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork - nwork + 1, ierr )
                    ! multiply right singular vectors of l in work(il) by
                    ! q in a, storing result in vt
                    ! workspace: need   m*m [l]
                    call stdlib_slacpy( 'F', m, m, vt, ldvt, work( il ), ldwrkl )
                    call stdlib_sgemm( 'N', 'N', m, n, m, one, work( il ), ldwrkl,a, lda, zero, &
                              vt, ldvt )
                 else if( wntqa ) then
                    ! path 4t (n >> m, jobz='a')
                    ! n right singular vectors to be computed in vt and
                    ! m left singular vectors to be computed in u
                    ivt = 1
                    ! work(ivt) is m by m
                    ldwkvt = m
                    itau = ivt + ldwkvt*m
                    nwork = itau + m
                    ! compute a=l*q, copying result to vt
                    ! workspace: need   m*m [vt] + m [tau] + m    [work]
                    ! workspace: prefer m*m [vt] + m [tau] + m*nb [work]
                    call stdlib_sgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    call stdlib_slacpy( 'U', m, n, a, lda, vt, ldvt )
                    ! generate q in vt
                    ! workspace: need   m*m [vt] + m [tau] + n    [work]
                    ! workspace: prefer m*m [vt] + m [tau] + n*nb [work]
                    call stdlib_sorglq( n, n, m, vt, ldvt, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ! produce l in a, zeroing out other entries
                    if (m>1) call stdlib_slaset( 'U', m-1, m-1, zero, zero, a( 1, 2 ), lda )
                    ie = itau
                    itauq = ie + m
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in a
                    ! workspace: need   m*m [vt] + 3*m [e, tauq, taup] + m      [work]
                    ! workspace: prefer m*m [vt] + 3*m [e, tauq, taup] + 2*m*nb [work]
                    call stdlib_sgebrd( m, m, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( nwork ), lwork-nwork+1,ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in work(ivt)
                    ! workspace: need   m*m [vt] + 3*m [e, tauq, taup] + bdspac
                    call stdlib_sbdsdc( 'U', 'I', m, s, work( ie ), u, ldu,work( ivt ), ldwkvt, &
                              dum, idum,work( nwork ), iwork, info )
                    ! overwrite u by left singular vectors of l and work(ivt)
                    ! by right singular vectors of l
                    ! workspace: need   m*m [vt] + 3*m [e, tauq, taup]+ m    [work]
                    ! workspace: prefer m*m [vt] + 3*m [e, tauq, taup]+ m*nb [work]
                    call stdlib_sormbr( 'Q', 'L', 'N', m, m, m, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_sormbr( 'P', 'R', 'T', m, m, m, a, lda,work( itaup ), work( ivt ),&
                               ldwkvt,work( nwork ), lwork - nwork + 1, ierr )
                    ! multiply right singular vectors of l in work(ivt) by
                    ! q in vt, storing result in a
                    ! workspace: need   m*m [vt]
                    call stdlib_sgemm( 'N', 'N', m, n, m, one, work( ivt ), ldwkvt,vt, ldvt, zero,&
                               a, lda )
                    ! copy right singular vectors of a from a to vt
                    call stdlib_slacpy( 'F', m, n, a, lda, vt, ldvt )
                 end if
              else
                 ! n < mnthr
                 ! path 5t (n > m, but not much larger)
                 ! reduce to bidiagonal form without lq decomposition
                 ie = 1
                 itauq = ie + m
                 itaup = itauq + m
                 nwork = itaup + m
                 ! bidiagonalize a
                 ! workspace: need   3*m [e, tauq, taup] + n        [work]
                 ! workspace: prefer 3*m [e, tauq, taup] + (m+n)*nb [work]
                 call stdlib_sgebrd( m, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 5tn (n > m, jobz='n')
                    ! perform bidiagonal svd, only computing singular values
                    ! workspace: need   3*m [e, tauq, taup] + bdspac
                    call stdlib_sbdsdc( 'L', 'N', m, s, work( ie ), dum, 1, dum, 1,dum, idum, &
                              work( nwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 5to (n > m, jobz='o')
                    ldwkvt = m
                    ivt = nwork
                    if( lwork >= m*n + 3*m + bdspac ) then
                       ! work( ivt ) is m by n
                       call stdlib_slaset( 'F', m, n, zero, zero, work( ivt ),ldwkvt )
                       nwork = ivt + ldwkvt*n
                       ! il is unused; silence compile warnings
                       il = -1
                    else
                       ! work( ivt ) is m by m
                       nwork = ivt + ldwkvt*m
                       il = nwork
                       ! work(il) is m by chunk
                       chunk = ( lwork - m*m - 3*m ) / m
                    end if
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in work(ivt)
                    ! workspace: need   3*m [e, tauq, taup] + m*m [vt] + bdspac
                    call stdlib_sbdsdc( 'L', 'I', m, s, work( ie ), u, ldu,work( ivt ), ldwkvt, &
                              dum, idum,work( nwork ), iwork, info )
                    ! overwrite u by left singular vectors of a
                    ! workspace: need   3*m [e, tauq, taup] + m*m [vt] + m    [work]
                    ! workspace: prefer 3*m [e, tauq, taup] + m*m [vt] + m*nb [work]
                    call stdlib_sormbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    if( lwork >= m*n + 3*m + bdspac ) then
                       ! path 5to-fast
                       ! overwrite work(ivt) by left singular vectors of a
                       ! workspace: need   3*m [e, tauq, taup] + m*n [vt] + m    [work]
                       ! workspace: prefer 3*m [e, tauq, taup] + m*n [vt] + m*nb [work]
                       call stdlib_sormbr( 'P', 'R', 'T', m, n, m, a, lda,work( itaup ), work( &
                                 ivt ), ldwkvt,work( nwork ), lwork - nwork + 1, ierr )
                       ! copy right singular vectors of a from work(ivt) to a
                       call stdlib_slacpy( 'F', m, n, work( ivt ), ldwkvt, a, lda )
                    else
                       ! path 5to-slow
                       ! generate p**t in a
                       ! workspace: need   3*m [e, tauq, taup] + m*m [vt] + m    [work]
                       ! workspace: prefer 3*m [e, tauq, taup] + m*m [vt] + m*nb [work]
                       call stdlib_sorgbr( 'P', m, n, m, a, lda, work( itaup ),work( nwork ), &
                                 lwork - nwork + 1, ierr )
                       ! multiply q in a by right singular vectors of
                       ! bidiagonal matrix in work(ivt), storing result in
                       ! work(il) and copying to a
                       ! workspace: need   3*m [e, tauq, taup] + m*m [vt] + m*nb [l]
                       ! workspace: prefer 3*m [e, tauq, taup] + m*m [vt] + m*n  [l]
                       do i = 1, n, chunk
                          blk = min( n - i + 1, chunk )
                          call stdlib_sgemm( 'N', 'N', m, blk, m, one, work( ivt ),ldwkvt, a( 1, &
                                    i ), lda, zero,work( il ), m )
                          call stdlib_slacpy( 'F', m, blk, work( il ), m, a( 1, i ),lda )
                       end do
                    end if
                 else if( wntqs ) then
                    ! path 5ts (n > m, jobz='s')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   3*m [e, tauq, taup] + bdspac
                    call stdlib_slaset( 'F', m, n, zero, zero, vt, ldvt )
                    call stdlib_sbdsdc( 'L', 'I', m, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! overwrite u by left singular vectors of a and vt
                    ! by right singular vectors of a
                    ! workspace: need   3*m [e, tauq, taup] + m    [work]
                    ! workspace: prefer 3*m [e, tauq, taup] + m*nb [work]
                    call stdlib_sormbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_sormbr( 'P', 'R', 'T', m, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                 else if( wntqa ) then
                    ! path 5ta (n > m, jobz='a')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   3*m [e, tauq, taup] + bdspac
                    call stdlib_slaset( 'F', n, n, zero, zero, vt, ldvt )
                    call stdlib_sbdsdc( 'L', 'I', m, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! set the right corner of vt to identity matrix
                    if( n>m ) then
                       call stdlib_slaset( 'F', n-m, n-m, zero, one, vt(m+1,m+1),ldvt )
                    end if
                    ! overwrite u by left singular vectors of a and vt
                    ! by right singular vectors of a
                    ! workspace: need   3*m [e, tauq, taup] + n    [work]
                    ! workspace: prefer 3*m [e, tauq, taup] + n*nb [work]
                    call stdlib_sormbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_sormbr( 'P', 'R', 'T', n, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                 end if
              end if
           end if
           ! undo scaling if necessary
           if( iscl==1 ) then
              if( anrm>bignum )call stdlib_slascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( anrm<smlnum )call stdlib_slascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,&
                        ierr )
           end if
           ! return optimal workspace in work(1)
           work( 1 ) = stdlib_sroundup_lwork( maxwrk )
           return
     end subroutine stdlib_sgesdd

     module subroutine stdlib_dgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, iwork, info )
     !! DGESDD computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, optionally computing the left and right singular
     !! vectors.  If singular vectors are desired, it uses a
     !! divide-and-conquer algorithm.
     !! The SVD is written
     !! A = U * SIGMA * transpose(V)
     !! where SIGMA is an M-by-N matrix which is zero except for its
     !! min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
     !! V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
     !! are the singular values of A; they are real and non-negative, and
     !! are returned in descending order.  The first min(m,n) columns of
     !! U and V are the left and right singular vectors of A.
     !! Note that the routine returns VT = V**T, not V.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldvt, lwork, m, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: s(*), u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wntqa, wntqas, wntqn, wntqo, wntqs
           integer(ilp) :: bdspac, blk, chunk, i, ie, ierr, il, ir, iscl, itau, itaup, itauq, iu, &
                     ivt, ldwkvt, ldwrkl, ldwrkr, ldwrku, maxwrk, minmn, minwrk, mnthr, nwork, wrkbl
           integer(ilp) :: lwork_dgebrd_mn, lwork_dgebrd_mm, lwork_dgebrd_nn, lwork_dgelqf_mn, &
           lwork_dgeqrf_mn, lwork_dorgbr_p_mm, lwork_dorgbr_q_nn, lwork_dorglq_mn, &
           lwork_dorglq_nn, lwork_dorgqr_mm, lwork_dorgqr_mn, lwork_dormbr_prt_mm, &
           lwork_dormbr_qln_mm, lwork_dormbr_prt_mn, lwork_dormbr_qln_mn, lwork_dormbr_prt_nn, &
                     lwork_dormbr_qln_nn
           real(dp) :: anrm, bignum, eps, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(dp) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info   = 0
           minmn  = min( m, n )
           wntqa  = stdlib_lsame( jobz, 'A' )
           wntqs  = stdlib_lsame( jobz, 'S' )
           wntqas = wntqa .or. wntqs
           wntqo  = stdlib_lsame( jobz, 'O' )
           wntqn  = stdlib_lsame( jobz, 'N' )
           lquery = ( lwork==-1 )
           if( .not.( wntqa .or. wntqs .or. wntqo .or. wntqn ) ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldu<1 .or. ( wntqas .and. ldu<m ) .or.( wntqo .and. m<n .and. ldu<m ) ) &
                     then
              info = -8
           else if( ldvt<1 .or. ( wntqa .and. ldvt<n ) .or.( wntqs .and. ldvt<minmn ) .or.( wntqo &
                     .and. m>=n .and. ldvt<n ) ) then
              info = -10
           end if
           ! compute workspace
             ! note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace allocated at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              bdspac = 0
              mnthr  = int( minmn*11.0_dp / 6.0_dp,KIND=ilp)
              if( m>=n .and. minmn>0 ) then
                 ! compute space needed for stdlib_dbdsdc
                 if( wntqn ) then
                    ! stdlib_dbdsdc needs only 4*n (or 6*n for uplo=l for lapack <= 3.6_dp)
                    ! keep 7*n for backwards compatibility.
                    bdspac = 7*n
                 else
                    bdspac = 3*n*n + 4*n
                 end if
                 ! compute space preferred for each routine
                 call stdlib_dgebrd( m, n, dum(1), m, dum(1), dum(1), dum(1),dum(1), dum(1), -1, &
                           ierr )
                 lwork_dgebrd_mn = int( dum(1),KIND=ilp)
                 call stdlib_dgebrd( n, n, dum(1), n, dum(1), dum(1), dum(1),dum(1), dum(1), -1, &
                           ierr )
                 lwork_dgebrd_nn = int( dum(1),KIND=ilp)
                 call stdlib_dgeqrf( m, n, dum(1), m, dum(1), dum(1), -1, ierr )
                 lwork_dgeqrf_mn = int( dum(1),KIND=ilp)
                 call stdlib_dorgbr( 'Q', n, n, n, dum(1), n, dum(1), dum(1), -1,ierr )
                 lwork_dorgbr_q_nn = int( dum(1),KIND=ilp)
                 call stdlib_dorgqr( m, m, n, dum(1), m, dum(1), dum(1), -1, ierr )
                 lwork_dorgqr_mm = int( dum(1),KIND=ilp)
                 call stdlib_dorgqr( m, n, n, dum(1), m, dum(1), dum(1), -1, ierr )
                 lwork_dorgqr_mn = int( dum(1),KIND=ilp)
                 call stdlib_dormbr( 'P', 'R', 'T', n, n, n, dum(1), n,dum(1), dum(1), n, dum(1), &
                           -1, ierr )
                 lwork_dormbr_prt_nn = int( dum(1),KIND=ilp)
                 call stdlib_dormbr( 'Q', 'L', 'N', n, n, n, dum(1), n,dum(1), dum(1), n, dum(1), &
                           -1, ierr )
                 lwork_dormbr_qln_nn = int( dum(1),KIND=ilp)
                 call stdlib_dormbr( 'Q', 'L', 'N', m, n, n, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_dormbr_qln_mn = int( dum(1),KIND=ilp)
                 call stdlib_dormbr( 'Q', 'L', 'N', m, m, n, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_dormbr_qln_mm = int( dum(1),KIND=ilp)
                 if( m>=mnthr ) then
                    if( wntqn ) then
                       ! path 1 (m >> n, jobz='n')
                       wrkbl = n + lwork_dgeqrf_mn
                       wrkbl = max( wrkbl, 3*n + lwork_dgebrd_nn )
                       maxwrk = max( wrkbl, bdspac + n )
                       minwrk = bdspac + n
                    else if( wntqo ) then
                       ! path 2 (m >> n, jobz='o')
                       wrkbl = n + lwork_dgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_dorgqr_mn )
                       wrkbl = max( wrkbl, 3*n + lwork_dgebrd_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_dormbr_qln_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_dormbr_prt_nn )
                       wrkbl = max( wrkbl, 3*n + bdspac )
                       maxwrk = wrkbl + 2*n*n
                       minwrk = bdspac + 2*n*n + 3*n
                    else if( wntqs ) then
                       ! path 3 (m >> n, jobz='s')
                       wrkbl = n + lwork_dgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_dorgqr_mn )
                       wrkbl = max( wrkbl, 3*n + lwork_dgebrd_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_dormbr_qln_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_dormbr_prt_nn )
                       wrkbl = max( wrkbl, 3*n + bdspac )
                       maxwrk = wrkbl + n*n
                       minwrk = bdspac + n*n + 3*n
                    else if( wntqa ) then
                       ! path 4 (m >> n, jobz='a')
                       wrkbl = n + lwork_dgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_dorgqr_mm )
                       wrkbl = max( wrkbl, 3*n + lwork_dgebrd_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_dormbr_qln_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_dormbr_prt_nn )
                       wrkbl = max( wrkbl, 3*n + bdspac )
                       maxwrk = wrkbl + n*n
                       minwrk = n*n + max( 3*n + bdspac, n + m )
                    end if
                 else
                    ! path 5 (m >= n, but not much larger)
                    wrkbl = 3*n + lwork_dgebrd_mn
                    if( wntqn ) then
                       ! path 5n (m >= n, jobz='n')
                       maxwrk = max( wrkbl, 3*n + bdspac )
                       minwrk = 3*n + max( m, bdspac )
                    else if( wntqo ) then
                       ! path 5o (m >= n, jobz='o')
                       wrkbl = max( wrkbl, 3*n + lwork_dormbr_prt_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_dormbr_qln_mn )
                       wrkbl = max( wrkbl, 3*n + bdspac )
                       maxwrk = wrkbl + m*n
                       minwrk = 3*n + max( m, n*n + bdspac )
                    else if( wntqs ) then
                       ! path 5s (m >= n, jobz='s')
                       wrkbl = max( wrkbl, 3*n + lwork_dormbr_qln_mn )
                       wrkbl = max( wrkbl, 3*n + lwork_dormbr_prt_nn )
                       maxwrk = max( wrkbl, 3*n + bdspac )
                       minwrk = 3*n + max( m, bdspac )
                    else if( wntqa ) then
                       ! path 5a (m >= n, jobz='a')
                       wrkbl = max( wrkbl, 3*n + lwork_dormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*n + lwork_dormbr_prt_nn )
                       maxwrk = max( wrkbl, 3*n + bdspac )
                       minwrk = 3*n + max( m, bdspac )
                    end if
                 end if
              else if( minmn>0 ) then
                 ! compute space needed for stdlib_dbdsdc
                 if( wntqn ) then
                    ! stdlib_dbdsdc needs only 4*n (or 6*n for uplo=l for lapack <= 3.6_dp)
                    ! keep 7*n for backwards compatibility.
                    bdspac = 7*m
                 else
                    bdspac = 3*m*m + 4*m
                 end if
                 ! compute space preferred for each routine
                 call stdlib_dgebrd( m, n, dum(1), m, dum(1), dum(1), dum(1),dum(1), dum(1), -1, &
                           ierr )
                 lwork_dgebrd_mn = int( dum(1),KIND=ilp)
                 call stdlib_dgebrd( m, m, a, m, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                           
                 lwork_dgebrd_mm = int( dum(1),KIND=ilp)
                 call stdlib_dgelqf( m, n, a, m, dum(1), dum(1), -1, ierr )
                 lwork_dgelqf_mn = int( dum(1),KIND=ilp)
                 call stdlib_dorglq( n, n, m, dum(1), n, dum(1), dum(1), -1, ierr )
                 lwork_dorglq_nn = int( dum(1),KIND=ilp)
                 call stdlib_dorglq( m, n, m, a, m, dum(1), dum(1), -1, ierr )
                 lwork_dorglq_mn = int( dum(1),KIND=ilp)
                 call stdlib_dorgbr( 'P', m, m, m, a, n, dum(1), dum(1), -1, ierr )
                 lwork_dorgbr_p_mm = int( dum(1),KIND=ilp)
                 call stdlib_dormbr( 'P', 'R', 'T', m, m, m, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_dormbr_prt_mm = int( dum(1),KIND=ilp)
                 call stdlib_dormbr( 'P', 'R', 'T', m, n, m, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_dormbr_prt_mn = int( dum(1),KIND=ilp)
                 call stdlib_dormbr( 'P', 'R', 'T', n, n, m, dum(1), n,dum(1), dum(1), n, dum(1), &
                           -1, ierr )
                 lwork_dormbr_prt_nn = int( dum(1),KIND=ilp)
                 call stdlib_dormbr( 'Q', 'L', 'N', m, m, m, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_dormbr_qln_mm = int( dum(1),KIND=ilp)
                 if( n>=mnthr ) then
                    if( wntqn ) then
                       ! path 1t (n >> m, jobz='n')
                       wrkbl = m + lwork_dgelqf_mn
                       wrkbl = max( wrkbl, 3*m + lwork_dgebrd_mm )
                       maxwrk = max( wrkbl, bdspac + m )
                       minwrk = bdspac + m
                    else if( wntqo ) then
                       ! path 2t (n >> m, jobz='o')
                       wrkbl = m + lwork_dgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_dorglq_mn )
                       wrkbl = max( wrkbl, 3*m + lwork_dgebrd_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_dormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_dormbr_prt_mm )
                       wrkbl = max( wrkbl, 3*m + bdspac )
                       maxwrk = wrkbl + 2*m*m
                       minwrk = bdspac + 2*m*m + 3*m
                    else if( wntqs ) then
                       ! path 3t (n >> m, jobz='s')
                       wrkbl = m + lwork_dgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_dorglq_mn )
                       wrkbl = max( wrkbl, 3*m + lwork_dgebrd_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_dormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_dormbr_prt_mm )
                       wrkbl = max( wrkbl, 3*m + bdspac )
                       maxwrk = wrkbl + m*m
                       minwrk = bdspac + m*m + 3*m
                    else if( wntqa ) then
                       ! path 4t (n >> m, jobz='a')
                       wrkbl = m + lwork_dgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_dorglq_nn )
                       wrkbl = max( wrkbl, 3*m + lwork_dgebrd_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_dormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_dormbr_prt_mm )
                       wrkbl = max( wrkbl, 3*m + bdspac )
                       maxwrk = wrkbl + m*m
                       minwrk = m*m + max( 3*m + bdspac, m + n )
                    end if
                 else
                    ! path 5t (n > m, but not much larger)
                    wrkbl = 3*m + lwork_dgebrd_mn
                    if( wntqn ) then
                       ! path 5tn (n > m, jobz='n')
                       maxwrk = max( wrkbl, 3*m + bdspac )
                       minwrk = 3*m + max( n, bdspac )
                    else if( wntqo ) then
                       ! path 5to (n > m, jobz='o')
                       wrkbl = max( wrkbl, 3*m + lwork_dormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_dormbr_prt_mn )
                       wrkbl = max( wrkbl, 3*m + bdspac )
                       maxwrk = wrkbl + m*n
                       minwrk = 3*m + max( n, m*m + bdspac )
                    else if( wntqs ) then
                       ! path 5ts (n > m, jobz='s')
                       wrkbl = max( wrkbl, 3*m + lwork_dormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_dormbr_prt_mn )
                       maxwrk = max( wrkbl, 3*m + bdspac )
                       minwrk = 3*m + max( n, bdspac )
                    else if( wntqa ) then
                       ! path 5ta (n > m, jobz='a')
                       wrkbl = max( wrkbl, 3*m + lwork_dormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_dormbr_prt_nn )
                       maxwrk = max( wrkbl, 3*m + bdspac )
                       minwrk = 3*m + max( n, bdspac )
                    end if
                 end if
              end if
              maxwrk = max( maxwrk, minwrk )
              work( 1 ) = stdlib_droundup_lwork( maxwrk )
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGESDD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = sqrt( stdlib_dlamch( 'S' ) ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_dlange( 'M', m, n, a, lda, dum )
           if( stdlib_disnan( anrm ) ) then
               info = -4
               return
           end if
           iscl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              iscl = 1
              call stdlib_dlascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, ierr )
           else if( anrm>bignum ) then
              iscl = 1
              call stdlib_dlascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, ierr )
           end if
           if( m>=n ) then
              ! a has at least as many rows as columns. if a has sufficiently
              ! more rows than columns, first reduce using the qr
              ! decomposition (if sufficient workspace available)
              if( m>=mnthr ) then
                 if( wntqn ) then
                    ! path 1 (m >> n, jobz='n')
                    ! no singular vectors to be computed
                    itau = 1
                    nwork = itau + n
                    ! compute a=q*r
                    ! workspace: need   n [tau] + n    [work]
                    ! workspace: prefer n [tau] + n*nb [work]
                    call stdlib_dgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! zero out below r
                    if (n>1) call stdlib_dlaset( 'L', n-1, n-1, zero, zero, a( 2, 1 ), lda )
                    ie = 1
                    itauq = ie + n
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in a
                    ! workspace: need   3*n [e, tauq, taup] + n      [work]
                    ! workspace: prefer 3*n [e, tauq, taup] + 2*n*nb [work]
                    call stdlib_dgebrd( n, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( nwork ), lwork-nwork+1,ierr )
                    nwork = ie + n
                    ! perform bidiagonal svd, computing singular values only
                    ! workspace: need   n [e] + bdspac
                    call stdlib_dbdsdc( 'U', 'N', n, s, work( ie ), dum, 1, dum, 1,dum, idum, &
                              work( nwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 2 (m >> n, jobz = 'o')
                    ! n left singular vectors to be overwritten on a and
                    ! n right singular vectors to be computed in vt
                    ir = 1
                    ! work(ir) is ldwrkr by n
                    if( lwork >= lda*n + n*n + 3*n + bdspac ) then
                       ldwrkr = lda
                    else
                       ldwrkr = ( lwork - n*n - 3*n - bdspac ) / n
                    end if
                    itau = ir + ldwrkr*n
                    nwork = itau + n
                    ! compute a=q*r
                    ! workspace: need   n*n [r] + n [tau] + n    [work]
                    ! workspace: prefer n*n [r] + n [tau] + n*nb [work]
                    call stdlib_dgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! copy r to work(ir), zeroing out below it
                    call stdlib_dlacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                    call stdlib_dlaset( 'L', n - 1, n - 1, zero, zero, work(ir+1),ldwrkr )
                    ! generate q in a
                    ! workspace: need   n*n [r] + n [tau] + n    [work]
                    ! workspace: prefer n*n [r] + n [tau] + n*nb [work]
                    call stdlib_dorgqr( m, n, n, a, lda, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ie = itau
                    itauq = ie + n
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in work(ir)
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n      [work]
                    ! workspace: prefer n*n [r] + 3*n [e, tauq, taup] + 2*n*nb [work]
                    call stdlib_dgebrd( n, n, work( ir ), ldwrkr, s, work( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork - nwork + 1, ierr )
                    ! work(iu) is n by n
                    iu = nwork
                    nwork = iu + n*n
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in work(iu) and computing right
                    ! singular vectors of bidiagonal matrix in vt
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n*n [u] + bdspac
                    call stdlib_dbdsdc( 'U', 'I', n, s, work( ie ), work( iu ), n,vt, ldvt, dum, &
                              idum, work( nwork ), iwork,info )
                    ! overwrite work(iu) by left singular vectors of r
                    ! and vt by right singular vectors of r
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n*n [u] + n    [work]
                    ! workspace: prefer n*n [r] + 3*n [e, tauq, taup] + n*n [u] + n*nb [work]
                    call stdlib_dormbr( 'Q', 'L', 'N', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                              work( iu ), n, work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_dormbr( 'P', 'R', 'T', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork - nwork + 1, ierr )
                    ! multiply q in a by left singular vectors of r in
                    ! work(iu), storing result in work(ir) and copying to a
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n*n [u]
                    ! workspace: prefer m*n [r] + 3*n [e, tauq, taup] + n*n [u]
                    do i = 1, m, ldwrkr
                       chunk = min( m - i + 1, ldwrkr )
                       call stdlib_dgemm( 'N', 'N', chunk, n, n, one, a( i, 1 ),lda, work( iu ), &
                                 n, zero, work( ir ),ldwrkr )
                       call stdlib_dlacpy( 'F', chunk, n, work( ir ), ldwrkr,a( i, 1 ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 3 (m >> n, jobz='s')
                    ! n left singular vectors to be computed in u and
                    ! n right singular vectors to be computed in vt
                    ir = 1
                    ! work(ir) is n by n
                    ldwrkr = n
                    itau = ir + ldwrkr*n
                    nwork = itau + n
                    ! compute a=q*r
                    ! workspace: need   n*n [r] + n [tau] + n    [work]
                    ! workspace: prefer n*n [r] + n [tau] + n*nb [work]
                    call stdlib_dgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! copy r to work(ir), zeroing out below it
                    call stdlib_dlacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                    call stdlib_dlaset( 'L', n - 1, n - 1, zero, zero, work(ir+1),ldwrkr )
                    ! generate q in a
                    ! workspace: need   n*n [r] + n [tau] + n    [work]
                    ! workspace: prefer n*n [r] + n [tau] + n*nb [work]
                    call stdlib_dorgqr( m, n, n, a, lda, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ie = itau
                    itauq = ie + n
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in work(ir)
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n      [work]
                    ! workspace: prefer n*n [r] + 3*n [e, tauq, taup] + 2*n*nb [work]
                    call stdlib_dgebrd( n, n, work( ir ), ldwrkr, s, work( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork - nwork + 1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagoal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + bdspac
                    call stdlib_dbdsdc( 'U', 'I', n, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! overwrite u by left singular vectors of r and vt
                    ! by right singular vectors of r
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n    [work]
                    ! workspace: prefer n*n [r] + 3*n [e, tauq, taup] + n*nb [work]
                    call stdlib_dormbr( 'Q', 'L', 'N', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                              u, ldu, work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_dormbr( 'P', 'R', 'T', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork - nwork + 1, ierr )
                    ! multiply q in a by left singular vectors of r in
                    ! work(ir), storing result in u
                    ! workspace: need   n*n [r]
                    call stdlib_dlacpy( 'F', n, n, u, ldu, work( ir ), ldwrkr )
                    call stdlib_dgemm( 'N', 'N', m, n, n, one, a, lda, work( ir ),ldwrkr, zero, u,&
                               ldu )
                 else if( wntqa ) then
                    ! path 4 (m >> n, jobz='a')
                    ! m left singular vectors to be computed in u and
                    ! n right singular vectors to be computed in vt
                    iu = 1
                    ! work(iu) is n by n
                    ldwrku = n
                    itau = iu + ldwrku*n
                    nwork = itau + n
                    ! compute a=q*r, copying result to u
                    ! workspace: need   n*n [u] + n [tau] + n    [work]
                    ! workspace: prefer n*n [u] + n [tau] + n*nb [work]
                    call stdlib_dgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    call stdlib_dlacpy( 'L', m, n, a, lda, u, ldu )
                    ! generate q in u
                    ! workspace: need   n*n [u] + n [tau] + m    [work]
                    ! workspace: prefer n*n [u] + n [tau] + m*nb [work]
                    call stdlib_dorgqr( m, m, n, u, ldu, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ! produce r in a, zeroing out other entries
                    if (n>1) call stdlib_dlaset( 'L', n-1, n-1, zero, zero, a( 2, 1 ), lda )
                    ie = itau
                    itauq = ie + n
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in a
                    ! workspace: need   n*n [u] + 3*n [e, tauq, taup] + n      [work]
                    ! workspace: prefer n*n [u] + 3*n [e, tauq, taup] + 2*n*nb [work]
                    call stdlib_dgebrd( n, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( nwork ), lwork-nwork+1,ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in work(iu) and computing right
                    ! singular vectors of bidiagonal matrix in vt
                    ! workspace: need   n*n [u] + 3*n [e, tauq, taup] + bdspac
                    call stdlib_dbdsdc( 'U', 'I', n, s, work( ie ), work( iu ), n,vt, ldvt, dum, &
                              idum, work( nwork ), iwork,info )
                    ! overwrite work(iu) by left singular vectors of r and vt
                    ! by right singular vectors of r
                    ! workspace: need   n*n [u] + 3*n [e, tauq, taup] + n    [work]
                    ! workspace: prefer n*n [u] + 3*n [e, tauq, taup] + n*nb [work]
                    call stdlib_dormbr( 'Q', 'L', 'N', n, n, n, a, lda,work( itauq ), work( iu ), &
                              ldwrku,work( nwork ), lwork - nwork + 1, ierr )
                    call stdlib_dormbr( 'P', 'R', 'T', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    ! multiply q in u by left singular vectors of r in
                    ! work(iu), storing result in a
                    ! workspace: need   n*n [u]
                    call stdlib_dgemm( 'N', 'N', m, n, n, one, u, ldu, work( iu ),ldwrku, zero, a,&
                               lda )
                    ! copy left singular vectors of a from a to u
                    call stdlib_dlacpy( 'F', m, n, a, lda, u, ldu )
                 end if
              else
                 ! m < mnthr
                 ! path 5 (m >= n, but not much larger)
                 ! reduce to bidiagonal form without qr decomposition
                 ie = 1
                 itauq = ie + n
                 itaup = itauq + n
                 nwork = itaup + n
                 ! bidiagonalize a
                 ! workspace: need   3*n [e, tauq, taup] + m        [work]
                 ! workspace: prefer 3*n [e, tauq, taup] + (m+n)*nb [work]
                 call stdlib_dgebrd( m, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 5n (m >= n, jobz='n')
                    ! perform bidiagonal svd, only computing singular values
                    ! workspace: need   3*n [e, tauq, taup] + bdspac
                    call stdlib_dbdsdc( 'U', 'N', n, s, work( ie ), dum, 1, dum, 1,dum, idum, &
                              work( nwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 5o (m >= n, jobz='o')
                    iu = nwork
                    if( lwork >= m*n + 3*n + bdspac ) then
                       ! work( iu ) is m by n
                       ldwrku = m
                       nwork = iu + ldwrku*n
                       call stdlib_dlaset( 'F', m, n, zero, zero, work( iu ),ldwrku )
                       ! ir is unused; silence compile warnings
                       ir = -1
                    else
                       ! work( iu ) is n by n
                       ldwrku = n
                       nwork = iu + ldwrku*n
                       ! work(ir) is ldwrkr by n
                       ir = nwork
                       ldwrkr = ( lwork - n*n - 3*n ) / n
                    end if
                    nwork = iu + ldwrku*n
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in work(iu) and computing right
                    ! singular vectors of bidiagonal matrix in vt
                    ! workspace: need   3*n [e, tauq, taup] + n*n [u] + bdspac
                    call stdlib_dbdsdc( 'U', 'I', n, s, work( ie ), work( iu ),ldwrku, vt, ldvt, &
                              dum, idum, work( nwork ),iwork, info )
                    ! overwrite vt by right singular vectors of a
                    ! workspace: need   3*n [e, tauq, taup] + n*n [u] + n    [work]
                    ! workspace: prefer 3*n [e, tauq, taup] + n*n [u] + n*nb [work]
                    call stdlib_dormbr( 'P', 'R', 'T', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    if( lwork >= m*n + 3*n + bdspac ) then
                       ! path 5o-fast
                       ! overwrite work(iu) by left singular vectors of a
                       ! workspace: need   3*n [e, tauq, taup] + m*n [u] + n    [work]
                       ! workspace: prefer 3*n [e, tauq, taup] + m*n [u] + n*nb [work]
                       call stdlib_dormbr( 'Q', 'L', 'N', m, n, n, a, lda,work( itauq ), work( iu &
                                 ), ldwrku,work( nwork ), lwork - nwork + 1, ierr )
                       ! copy left singular vectors of a from work(iu) to a
                       call stdlib_dlacpy( 'F', m, n, work( iu ), ldwrku, a, lda )
                    else
                       ! path 5o-slow
                       ! generate q in a
                       ! workspace: need   3*n [e, tauq, taup] + n*n [u] + n    [work]
                       ! workspace: prefer 3*n [e, tauq, taup] + n*n [u] + n*nb [work]
                       call stdlib_dorgbr( 'Q', m, n, n, a, lda, work( itauq ),work( nwork ), &
                                 lwork - nwork + 1, ierr )
                       ! multiply q in a by left singular vectors of
                       ! bidiagonal matrix in work(iu), storing result in
                       ! work(ir) and copying to a
                       ! workspace: need   3*n [e, tauq, taup] + n*n [u] + nb*n [r]
                       ! workspace: prefer 3*n [e, tauq, taup] + n*n [u] + m*n  [r]
                       do i = 1, m, ldwrkr
                          chunk = min( m - i + 1, ldwrkr )
                          call stdlib_dgemm( 'N', 'N', chunk, n, n, one, a( i, 1 ),lda, work( iu )&
                                    , ldwrku, zero,work( ir ), ldwrkr )
                          call stdlib_dlacpy( 'F', chunk, n, work( ir ), ldwrkr,a( i, 1 ), lda )
                                    
                       end do
                    end if
                 else if( wntqs ) then
                    ! path 5s (m >= n, jobz='s')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   3*n [e, tauq, taup] + bdspac
                    call stdlib_dlaset( 'F', m, n, zero, zero, u, ldu )
                    call stdlib_dbdsdc( 'U', 'I', n, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! overwrite u by left singular vectors of a and vt
                    ! by right singular vectors of a
                    ! workspace: need   3*n [e, tauq, taup] + n    [work]
                    ! workspace: prefer 3*n [e, tauq, taup] + n*nb [work]
                    call stdlib_dormbr( 'Q', 'L', 'N', m, n, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_dormbr( 'P', 'R', 'T', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                 else if( wntqa ) then
                    ! path 5a (m >= n, jobz='a')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   3*n [e, tauq, taup] + bdspac
                    call stdlib_dlaset( 'F', m, m, zero, zero, u, ldu )
                    call stdlib_dbdsdc( 'U', 'I', n, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! set the right corner of u to identity matrix
                    if( m>n ) then
                       call stdlib_dlaset( 'F', m - n, m - n, zero, one, u(n+1,n+1),ldu )
                    end if
                    ! overwrite u by left singular vectors of a and vt
                    ! by right singular vectors of a
                    ! workspace: need   3*n [e, tauq, taup] + m    [work]
                    ! workspace: prefer 3*n [e, tauq, taup] + m*nb [work]
                    call stdlib_dormbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_dormbr( 'P', 'R', 'T', n, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                 end if
              end if
           else
              ! a has more columns than rows. if a has sufficiently more
              ! columns than rows, first reduce using the lq decomposition (if
              ! sufficient workspace available)
              if( n>=mnthr ) then
                 if( wntqn ) then
                    ! path 1t (n >> m, jobz='n')
                    ! no singular vectors to be computed
                    itau = 1
                    nwork = itau + m
                    ! compute a=l*q
                    ! workspace: need   m [tau] + m [work]
                    ! workspace: prefer m [tau] + m*nb [work]
                    call stdlib_dgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! zero out above l
                    if (m>1) call stdlib_dlaset( 'U', m-1, m-1, zero, zero, a( 1, 2 ), lda )
                    ie = 1
                    itauq = ie + m
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in a
                    ! workspace: need   3*m [e, tauq, taup] + m      [work]
                    ! workspace: prefer 3*m [e, tauq, taup] + 2*m*nb [work]
                    call stdlib_dgebrd( m, m, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( nwork ), lwork-nwork+1,ierr )
                    nwork = ie + m
                    ! perform bidiagonal svd, computing singular values only
                    ! workspace: need   m [e] + bdspac
                    call stdlib_dbdsdc( 'U', 'N', m, s, work( ie ), dum, 1, dum, 1,dum, idum, &
                              work( nwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 2t (n >> m, jobz='o')
                    ! m right singular vectors to be overwritten on a and
                    ! m left singular vectors to be computed in u
                    ivt = 1
                    ! work(ivt) is m by m
                    ! work(il)  is m by m; it is later resized to m by chunk for gemm
                    il = ivt + m*m
                    if( lwork >= m*n + m*m + 3*m + bdspac ) then
                       ldwrkl = m
                       chunk = n
                    else
                       ldwrkl = m
                       chunk = ( lwork - m*m ) / m
                    end if
                    itau = il + ldwrkl*m
                    nwork = itau + m
                    ! compute a=l*q
                    ! workspace: need   m*m [vt] + m*m [l] + m [tau] + m    [work]
                    ! workspace: prefer m*m [vt] + m*m [l] + m [tau] + m*nb [work]
                    call stdlib_dgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! copy l to work(il), zeroing about above it
                    call stdlib_dlacpy( 'L', m, m, a, lda, work( il ), ldwrkl )
                    call stdlib_dlaset( 'U', m - 1, m - 1, zero, zero,work( il + ldwrkl ), ldwrkl &
                              )
                    ! generate q in a
                    ! workspace: need   m*m [vt] + m*m [l] + m [tau] + m    [work]
                    ! workspace: prefer m*m [vt] + m*m [l] + m [tau] + m*nb [work]
                    call stdlib_dorglq( m, n, m, a, lda, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ie = itau
                    itauq = ie + m
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in work(il)
                    ! workspace: need   m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + m      [work]
                    ! workspace: prefer m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + 2*m*nb [work]
                    call stdlib_dgebrd( m, m, work( il ), ldwrkl, s, work( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork - nwork + 1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u, and computing right singular
                    ! vectors of bidiagonal matrix in work(ivt)
                    ! workspace: need   m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + bdspac
                    call stdlib_dbdsdc( 'U', 'I', m, s, work( ie ), u, ldu,work( ivt ), m, dum, &
                              idum, work( nwork ),iwork, info )
                    ! overwrite u by left singular vectors of l and work(ivt)
                    ! by right singular vectors of l
                    ! workspace: need   m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + m    [work]
                    ! workspace: prefer m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + m*nb [work]
                    call stdlib_dormbr( 'Q', 'L', 'N', m, m, m, work( il ), ldwrkl,work( itauq ), &
                              u, ldu, work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_dormbr( 'P', 'R', 'T', m, m, m, work( il ), ldwrkl,work( itaup ), &
                              work( ivt ), m,work( nwork ), lwork - nwork + 1, ierr )
                    ! multiply right singular vectors of l in work(ivt) by q
                    ! in a, storing result in work(il) and copying to a
                    ! workspace: need   m*m [vt] + m*m [l]
                    ! workspace: prefer m*m [vt] + m*n [l]
                    ! at this point, l is resized as m by chunk.
                    do i = 1, n, chunk
                       blk = min( n - i + 1, chunk )
                       call stdlib_dgemm( 'N', 'N', m, blk, m, one, work( ivt ), m,a( 1, i ), lda,&
                                  zero, work( il ), ldwrkl )
                       call stdlib_dlacpy( 'F', m, blk, work( il ), ldwrkl,a( 1, i ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 3t (n >> m, jobz='s')
                    ! m right singular vectors to be computed in vt and
                    ! m left singular vectors to be computed in u
                    il = 1
                    ! work(il) is m by m
                    ldwrkl = m
                    itau = il + ldwrkl*m
                    nwork = itau + m
                    ! compute a=l*q
                    ! workspace: need   m*m [l] + m [tau] + m    [work]
                    ! workspace: prefer m*m [l] + m [tau] + m*nb [work]
                    call stdlib_dgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! copy l to work(il), zeroing out above it
                    call stdlib_dlacpy( 'L', m, m, a, lda, work( il ), ldwrkl )
                    call stdlib_dlaset( 'U', m - 1, m - 1, zero, zero,work( il + ldwrkl ), ldwrkl &
                              )
                    ! generate q in a
                    ! workspace: need   m*m [l] + m [tau] + m    [work]
                    ! workspace: prefer m*m [l] + m [tau] + m*nb [work]
                    call stdlib_dorglq( m, n, m, a, lda, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ie = itau
                    itauq = ie + m
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in work(iu).
                    ! workspace: need   m*m [l] + 3*m [e, tauq, taup] + m      [work]
                    ! workspace: prefer m*m [l] + 3*m [e, tauq, taup] + 2*m*nb [work]
                    call stdlib_dgebrd( m, m, work( il ), ldwrkl, s, work( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork - nwork + 1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   m*m [l] + 3*m [e, tauq, taup] + bdspac
                    call stdlib_dbdsdc( 'U', 'I', m, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! overwrite u by left singular vectors of l and vt
                    ! by right singular vectors of l
                    ! workspace: need   m*m [l] + 3*m [e, tauq, taup] + m    [work]
                    ! workspace: prefer m*m [l] + 3*m [e, tauq, taup] + m*nb [work]
                    call stdlib_dormbr( 'Q', 'L', 'N', m, m, m, work( il ), ldwrkl,work( itauq ), &
                              u, ldu, work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_dormbr( 'P', 'R', 'T', m, m, m, work( il ), ldwrkl,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork - nwork + 1, ierr )
                    ! multiply right singular vectors of l in work(il) by
                    ! q in a, storing result in vt
                    ! workspace: need   m*m [l]
                    call stdlib_dlacpy( 'F', m, m, vt, ldvt, work( il ), ldwrkl )
                    call stdlib_dgemm( 'N', 'N', m, n, m, one, work( il ), ldwrkl,a, lda, zero, &
                              vt, ldvt )
                 else if( wntqa ) then
                    ! path 4t (n >> m, jobz='a')
                    ! n right singular vectors to be computed in vt and
                    ! m left singular vectors to be computed in u
                    ivt = 1
                    ! work(ivt) is m by m
                    ldwkvt = m
                    itau = ivt + ldwkvt*m
                    nwork = itau + m
                    ! compute a=l*q, copying result to vt
                    ! workspace: need   m*m [vt] + m [tau] + m    [work]
                    ! workspace: prefer m*m [vt] + m [tau] + m*nb [work]
                    call stdlib_dgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    call stdlib_dlacpy( 'U', m, n, a, lda, vt, ldvt )
                    ! generate q in vt
                    ! workspace: need   m*m [vt] + m [tau] + n    [work]
                    ! workspace: prefer m*m [vt] + m [tau] + n*nb [work]
                    call stdlib_dorglq( n, n, m, vt, ldvt, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ! produce l in a, zeroing out other entries
                    if (m>1) call stdlib_dlaset( 'U', m-1, m-1, zero, zero, a( 1, 2 ), lda )
                    ie = itau
                    itauq = ie + m
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in a
                    ! workspace: need   m*m [vt] + 3*m [e, tauq, taup] + m      [work]
                    ! workspace: prefer m*m [vt] + 3*m [e, tauq, taup] + 2*m*nb [work]
                    call stdlib_dgebrd( m, m, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( nwork ), lwork-nwork+1,ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in work(ivt)
                    ! workspace: need   m*m [vt] + 3*m [e, tauq, taup] + bdspac
                    call stdlib_dbdsdc( 'U', 'I', m, s, work( ie ), u, ldu,work( ivt ), ldwkvt, &
                              dum, idum,work( nwork ), iwork, info )
                    ! overwrite u by left singular vectors of l and work(ivt)
                    ! by right singular vectors of l
                    ! workspace: need   m*m [vt] + 3*m [e, tauq, taup]+ m    [work]
                    ! workspace: prefer m*m [vt] + 3*m [e, tauq, taup]+ m*nb [work]
                    call stdlib_dormbr( 'Q', 'L', 'N', m, m, m, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_dormbr( 'P', 'R', 'T', m, m, m, a, lda,work( itaup ), work( ivt ),&
                               ldwkvt,work( nwork ), lwork - nwork + 1, ierr )
                    ! multiply right singular vectors of l in work(ivt) by
                    ! q in vt, storing result in a
                    ! workspace: need   m*m [vt]
                    call stdlib_dgemm( 'N', 'N', m, n, m, one, work( ivt ), ldwkvt,vt, ldvt, zero,&
                               a, lda )
                    ! copy right singular vectors of a from a to vt
                    call stdlib_dlacpy( 'F', m, n, a, lda, vt, ldvt )
                 end if
              else
                 ! n < mnthr
                 ! path 5t (n > m, but not much larger)
                 ! reduce to bidiagonal form without lq decomposition
                 ie = 1
                 itauq = ie + m
                 itaup = itauq + m
                 nwork = itaup + m
                 ! bidiagonalize a
                 ! workspace: need   3*m [e, tauq, taup] + n        [work]
                 ! workspace: prefer 3*m [e, tauq, taup] + (m+n)*nb [work]
                 call stdlib_dgebrd( m, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 5tn (n > m, jobz='n')
                    ! perform bidiagonal svd, only computing singular values
                    ! workspace: need   3*m [e, tauq, taup] + bdspac
                    call stdlib_dbdsdc( 'L', 'N', m, s, work( ie ), dum, 1, dum, 1,dum, idum, &
                              work( nwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 5to (n > m, jobz='o')
                    ldwkvt = m
                    ivt = nwork
                    if( lwork >= m*n + 3*m + bdspac ) then
                       ! work( ivt ) is m by n
                       call stdlib_dlaset( 'F', m, n, zero, zero, work( ivt ),ldwkvt )
                       nwork = ivt + ldwkvt*n
                       ! il is unused; silence compile warnings
                       il = -1
                    else
                       ! work( ivt ) is m by m
                       nwork = ivt + ldwkvt*m
                       il = nwork
                       ! work(il) is m by chunk
                       chunk = ( lwork - m*m - 3*m ) / m
                    end if
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in work(ivt)
                    ! workspace: need   3*m [e, tauq, taup] + m*m [vt] + bdspac
                    call stdlib_dbdsdc( 'L', 'I', m, s, work( ie ), u, ldu,work( ivt ), ldwkvt, &
                              dum, idum,work( nwork ), iwork, info )
                    ! overwrite u by left singular vectors of a
                    ! workspace: need   3*m [e, tauq, taup] + m*m [vt] + m    [work]
                    ! workspace: prefer 3*m [e, tauq, taup] + m*m [vt] + m*nb [work]
                    call stdlib_dormbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    if( lwork >= m*n + 3*m + bdspac ) then
                       ! path 5to-fast
                       ! overwrite work(ivt) by left singular vectors of a
                       ! workspace: need   3*m [e, tauq, taup] + m*n [vt] + m    [work]
                       ! workspace: prefer 3*m [e, tauq, taup] + m*n [vt] + m*nb [work]
                       call stdlib_dormbr( 'P', 'R', 'T', m, n, m, a, lda,work( itaup ), work( &
                                 ivt ), ldwkvt,work( nwork ), lwork - nwork + 1, ierr )
                       ! copy right singular vectors of a from work(ivt) to a
                       call stdlib_dlacpy( 'F', m, n, work( ivt ), ldwkvt, a, lda )
                    else
                       ! path 5to-slow
                       ! generate p**t in a
                       ! workspace: need   3*m [e, tauq, taup] + m*m [vt] + m    [work]
                       ! workspace: prefer 3*m [e, tauq, taup] + m*m [vt] + m*nb [work]
                       call stdlib_dorgbr( 'P', m, n, m, a, lda, work( itaup ),work( nwork ), &
                                 lwork - nwork + 1, ierr )
                       ! multiply q in a by right singular vectors of
                       ! bidiagonal matrix in work(ivt), storing result in
                       ! work(il) and copying to a
                       ! workspace: need   3*m [e, tauq, taup] + m*m [vt] + m*nb [l]
                       ! workspace: prefer 3*m [e, tauq, taup] + m*m [vt] + m*n  [l]
                       do i = 1, n, chunk
                          blk = min( n - i + 1, chunk )
                          call stdlib_dgemm( 'N', 'N', m, blk, m, one, work( ivt ),ldwkvt, a( 1, &
                                    i ), lda, zero,work( il ), m )
                          call stdlib_dlacpy( 'F', m, blk, work( il ), m, a( 1, i ),lda )
                       end do
                    end if
                 else if( wntqs ) then
                    ! path 5ts (n > m, jobz='s')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   3*m [e, tauq, taup] + bdspac
                    call stdlib_dlaset( 'F', m, n, zero, zero, vt, ldvt )
                    call stdlib_dbdsdc( 'L', 'I', m, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! overwrite u by left singular vectors of a and vt
                    ! by right singular vectors of a
                    ! workspace: need   3*m [e, tauq, taup] + m    [work]
                    ! workspace: prefer 3*m [e, tauq, taup] + m*nb [work]
                    call stdlib_dormbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_dormbr( 'P', 'R', 'T', m, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                 else if( wntqa ) then
                    ! path 5ta (n > m, jobz='a')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   3*m [e, tauq, taup] + bdspac
                    call stdlib_dlaset( 'F', n, n, zero, zero, vt, ldvt )
                    call stdlib_dbdsdc( 'L', 'I', m, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! set the right corner of vt to identity matrix
                    if( n>m ) then
                       call stdlib_dlaset( 'F', n-m, n-m, zero, one, vt(m+1,m+1),ldvt )
                    end if
                    ! overwrite u by left singular vectors of a and vt
                    ! by right singular vectors of a
                    ! workspace: need   3*m [e, tauq, taup] + n    [work]
                    ! workspace: prefer 3*m [e, tauq, taup] + n*nb [work]
                    call stdlib_dormbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_dormbr( 'P', 'R', 'T', n, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                 end if
              end if
           end if
           ! undo scaling if necessary
           if( iscl==1 ) then
              if( anrm>bignum )call stdlib_dlascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( anrm<smlnum )call stdlib_dlascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,&
                        ierr )
           end if
           ! return optimal workspace in work(1)
           work( 1 ) = stdlib_droundup_lwork( maxwrk )
           return
     end subroutine stdlib_dgesdd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$gesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, iwork, info )
     !! DGESDD: computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, optionally computing the left and right singular
     !! vectors.  If singular vectors are desired, it uses a
     !! divide-and-conquer algorithm.
     !! The SVD is written
     !! A = U * SIGMA * transpose(V)
     !! where SIGMA is an M-by-N matrix which is zero except for its
     !! min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
     !! V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
     !! are the singular values of A; they are real and non-negative, and
     !! are returned in descending order.  The first min(m,n) columns of
     !! U and V are the left and right singular vectors of A.
     !! Note that the routine returns VT = V**T, not V.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldvt, lwork, m, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: s(*), u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wntqa, wntqas, wntqn, wntqo, wntqs
           integer(ilp) :: bdspac, blk, chunk, i, ie, ierr, il, ir, iscl, itau, itaup, itauq, iu, &
                     ivt, ldwkvt, ldwrkl, ldwrkr, ldwrku, maxwrk, minmn, minwrk, mnthr, nwork, wrkbl
           integer(ilp) :: lwork_qgebrd_mn, lwork_qgebrd_mm, lwork_qgebrd_nn, lwork_qgelqf_mn, &
           lwork_qgeqrf_mn, lwork_qorgbr_p_mm, lwork_qorgbr_q_nn, lwork_qorglq_mn, &
           lwork_qorglq_nn, lwork_qorgqr_mm, lwork_qorgqr_mn, lwork_qormbr_prt_mm, &
           lwork_qormbr_qln_mm, lwork_qormbr_prt_mn, lwork_qormbr_qln_mn, lwork_qormbr_prt_nn, &
                     lwork_qormbr_qln_nn
           real(${rk}$) :: anrm, bignum, eps, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(${rk}$) :: dum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info   = 0
           minmn  = min( m, n )
           wntqa  = stdlib_lsame( jobz, 'A' )
           wntqs  = stdlib_lsame( jobz, 'S' )
           wntqas = wntqa .or. wntqs
           wntqo  = stdlib_lsame( jobz, 'O' )
           wntqn  = stdlib_lsame( jobz, 'N' )
           lquery = ( lwork==-1 )
           if( .not.( wntqa .or. wntqs .or. wntqo .or. wntqn ) ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldu<1 .or. ( wntqas .and. ldu<m ) .or.( wntqo .and. m<n .and. ldu<m ) ) &
                     then
              info = -8
           else if( ldvt<1 .or. ( wntqa .and. ldvt<n ) .or.( wntqs .and. ldvt<minmn ) .or.( wntqo &
                     .and. m>=n .and. ldvt<n ) ) then
              info = -10
           end if
           ! compute workspace
             ! note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace allocated at that point in the code,
             ! as well as the preferred amount for good performance.
             ! nb refers to the optimal block size for the immediately
             ! following subroutine, as returned by stdlib_ilaenv.
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              bdspac = 0
              mnthr  = int( minmn*11.0_${rk}$ / 6.0_${rk}$,KIND=ilp)
              if( m>=n .and. minmn>0 ) then
                 ! compute space needed for stdlib_${ri}$bdsdc
                 if( wntqn ) then
                    ! stdlib_${ri}$bdsdc needs only 4*n (or 6*n for uplo=l for lapack <= 3.6_${rk}$)
                    ! keep 7*n for backwards compatibility.
                    bdspac = 7*n
                 else
                    bdspac = 3*n*n + 4*n
                 end if
                 ! compute space preferred for each routine
                 call stdlib_${ri}$gebrd( m, n, dum(1), m, dum(1), dum(1), dum(1),dum(1), dum(1), -1, &
                           ierr )
                 lwork_qgebrd_mn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$gebrd( n, n, dum(1), n, dum(1), dum(1), dum(1),dum(1), dum(1), -1, &
                           ierr )
                 lwork_qgebrd_nn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$geqrf( m, n, dum(1), m, dum(1), dum(1), -1, ierr )
                 lwork_qgeqrf_mn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$orgbr( 'Q', n, n, n, dum(1), n, dum(1), dum(1), -1,ierr )
                 lwork_qorgbr_q_nn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$orgqr( m, m, n, dum(1), m, dum(1), dum(1), -1, ierr )
                 lwork_qorgqr_mm = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$orgqr( m, n, n, dum(1), m, dum(1), dum(1), -1, ierr )
                 lwork_qorgqr_mn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$ormbr( 'P', 'R', 'T', n, n, n, dum(1), n,dum(1), dum(1), n, dum(1), &
                           -1, ierr )
                 lwork_qormbr_prt_nn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$ormbr( 'Q', 'L', 'N', n, n, n, dum(1), n,dum(1), dum(1), n, dum(1), &
                           -1, ierr )
                 lwork_qormbr_qln_nn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, n, n, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_qormbr_qln_mn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, m, n, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_qormbr_qln_mm = int( dum(1),KIND=ilp)
                 if( m>=mnthr ) then
                    if( wntqn ) then
                       ! path 1 (m >> n, jobz='n')
                       wrkbl = n + lwork_qgeqrf_mn
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd_nn )
                       maxwrk = max( wrkbl, bdspac + n )
                       minwrk = bdspac + n
                    else if( wntqo ) then
                       ! path 2 (m >> n, jobz='o')
                       wrkbl = n + lwork_qgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_qorgqr_mn )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_qln_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_prt_nn )
                       wrkbl = max( wrkbl, 3*n + bdspac )
                       maxwrk = wrkbl + 2*n*n
                       minwrk = bdspac + 2*n*n + 3*n
                    else if( wntqs ) then
                       ! path 3 (m >> n, jobz='s')
                       wrkbl = n + lwork_qgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_qorgqr_mn )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_qln_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_prt_nn )
                       wrkbl = max( wrkbl, 3*n + bdspac )
                       maxwrk = wrkbl + n*n
                       minwrk = bdspac + n*n + 3*n
                    else if( wntqa ) then
                       ! path 4 (m >> n, jobz='a')
                       wrkbl = n + lwork_qgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_qorgqr_mm )
                       wrkbl = max( wrkbl, 3*n + lwork_qgebrd_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_qln_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_prt_nn )
                       wrkbl = max( wrkbl, 3*n + bdspac )
                       maxwrk = wrkbl + n*n
                       minwrk = n*n + max( 3*n + bdspac, n + m )
                    end if
                 else
                    ! path 5 (m >= n, but not much larger)
                    wrkbl = 3*n + lwork_qgebrd_mn
                    if( wntqn ) then
                       ! path 5n (m >= n, jobz='n')
                       maxwrk = max( wrkbl, 3*n + bdspac )
                       minwrk = 3*n + max( m, bdspac )
                    else if( wntqo ) then
                       ! path 5o (m >= n, jobz='o')
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_prt_nn )
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_qln_mn )
                       wrkbl = max( wrkbl, 3*n + bdspac )
                       maxwrk = wrkbl + m*n
                       minwrk = 3*n + max( m, n*n + bdspac )
                    else if( wntqs ) then
                       ! path 5s (m >= n, jobz='s')
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_qln_mn )
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_prt_nn )
                       maxwrk = max( wrkbl, 3*n + bdspac )
                       minwrk = 3*n + max( m, bdspac )
                    else if( wntqa ) then
                       ! path 5a (m >= n, jobz='a')
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*n + lwork_qormbr_prt_nn )
                       maxwrk = max( wrkbl, 3*n + bdspac )
                       minwrk = 3*n + max( m, bdspac )
                    end if
                 end if
              else if( minmn>0 ) then
                 ! compute space needed for stdlib_${ri}$bdsdc
                 if( wntqn ) then
                    ! stdlib_${ri}$bdsdc needs only 4*n (or 6*n for uplo=l for lapack <= 3.6_${rk}$)
                    ! keep 7*n for backwards compatibility.
                    bdspac = 7*m
                 else
                    bdspac = 3*m*m + 4*m
                 end if
                 ! compute space preferred for each routine
                 call stdlib_${ri}$gebrd( m, n, dum(1), m, dum(1), dum(1), dum(1),dum(1), dum(1), -1, &
                           ierr )
                 lwork_qgebrd_mn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$gebrd( m, m, a, m, s, dum(1), dum(1),dum(1), dum(1), -1, ierr )
                           
                 lwork_qgebrd_mm = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$gelqf( m, n, a, m, dum(1), dum(1), -1, ierr )
                 lwork_qgelqf_mn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$orglq( n, n, m, dum(1), n, dum(1), dum(1), -1, ierr )
                 lwork_qorglq_nn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$orglq( m, n, m, a, m, dum(1), dum(1), -1, ierr )
                 lwork_qorglq_mn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$orgbr( 'P', m, m, m, a, n, dum(1), dum(1), -1, ierr )
                 lwork_qorgbr_p_mm = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$ormbr( 'P', 'R', 'T', m, m, m, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_qormbr_prt_mm = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$ormbr( 'P', 'R', 'T', m, n, m, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_qormbr_prt_mn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$ormbr( 'P', 'R', 'T', n, n, m, dum(1), n,dum(1), dum(1), n, dum(1), &
                           -1, ierr )
                 lwork_qormbr_prt_nn = int( dum(1),KIND=ilp)
                 call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, m, m, dum(1), m,dum(1), dum(1), m, dum(1), &
                           -1, ierr )
                 lwork_qormbr_qln_mm = int( dum(1),KIND=ilp)
                 if( n>=mnthr ) then
                    if( wntqn ) then
                       ! path 1t (n >> m, jobz='n')
                       wrkbl = m + lwork_qgelqf_mn
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd_mm )
                       maxwrk = max( wrkbl, bdspac + m )
                       minwrk = bdspac + m
                    else if( wntqo ) then
                       ! path 2t (n >> m, jobz='o')
                       wrkbl = m + lwork_qgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_qorglq_mn )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_prt_mm )
                       wrkbl = max( wrkbl, 3*m + bdspac )
                       maxwrk = wrkbl + 2*m*m
                       minwrk = bdspac + 2*m*m + 3*m
                    else if( wntqs ) then
                       ! path 3t (n >> m, jobz='s')
                       wrkbl = m + lwork_qgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_qorglq_mn )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_prt_mm )
                       wrkbl = max( wrkbl, 3*m + bdspac )
                       maxwrk = wrkbl + m*m
                       minwrk = bdspac + m*m + 3*m
                    else if( wntqa ) then
                       ! path 4t (n >> m, jobz='a')
                       wrkbl = m + lwork_qgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_qorglq_nn )
                       wrkbl = max( wrkbl, 3*m + lwork_qgebrd_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_prt_mm )
                       wrkbl = max( wrkbl, 3*m + bdspac )
                       maxwrk = wrkbl + m*m
                       minwrk = m*m + max( 3*m + bdspac, m + n )
                    end if
                 else
                    ! path 5t (n > m, but not much larger)
                    wrkbl = 3*m + lwork_qgebrd_mn
                    if( wntqn ) then
                       ! path 5tn (n > m, jobz='n')
                       maxwrk = max( wrkbl, 3*m + bdspac )
                       minwrk = 3*m + max( n, bdspac )
                    else if( wntqo ) then
                       ! path 5to (n > m, jobz='o')
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_prt_mn )
                       wrkbl = max( wrkbl, 3*m + bdspac )
                       maxwrk = wrkbl + m*n
                       minwrk = 3*m + max( n, m*m + bdspac )
                    else if( wntqs ) then
                       ! path 5ts (n > m, jobz='s')
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_prt_mn )
                       maxwrk = max( wrkbl, 3*m + bdspac )
                       minwrk = 3*m + max( n, bdspac )
                    else if( wntqa ) then
                       ! path 5ta (n > m, jobz='a')
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_qln_mm )
                       wrkbl = max( wrkbl, 3*m + lwork_qormbr_prt_nn )
                       maxwrk = max( wrkbl, 3*m + bdspac )
                       minwrk = 3*m + max( n, bdspac )
                    end if
                 end if
              end if
              maxwrk = max( maxwrk, minwrk )
              work( 1 ) = stdlib_${ri}$roundup_lwork( maxwrk )
              if( lwork<minwrk .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGESDD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = sqrt( stdlib_${ri}$lamch( 'S' ) ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ri}$lange( 'M', m, n, a, lda, dum )
           if( stdlib_${ri}$isnan( anrm ) ) then
               info = -4
               return
           end if
           iscl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              iscl = 1
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, ierr )
           else if( anrm>bignum ) then
              iscl = 1
              call stdlib_${ri}$lascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, ierr )
           end if
           if( m>=n ) then
              ! a has at least as many rows as columns. if a has sufficiently
              ! more rows than columns, first reduce using the qr
              ! decomposition (if sufficient workspace available)
              if( m>=mnthr ) then
                 if( wntqn ) then
                    ! path 1 (m >> n, jobz='n')
                    ! no singular vectors to be computed
                    itau = 1
                    nwork = itau + n
                    ! compute a=q*r
                    ! workspace: need   n [tau] + n    [work]
                    ! workspace: prefer n [tau] + n*nb [work]
                    call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! zero out below r
                    if (n>1) call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero, a( 2, 1 ), lda )
                    ie = 1
                    itauq = ie + n
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in a
                    ! workspace: need   3*n [e, tauq, taup] + n      [work]
                    ! workspace: prefer 3*n [e, tauq, taup] + 2*n*nb [work]
                    call stdlib_${ri}$gebrd( n, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( nwork ), lwork-nwork+1,ierr )
                    nwork = ie + n
                    ! perform bidiagonal svd, computing singular values only
                    ! workspace: need   n [e] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'N', n, s, work( ie ), dum, 1, dum, 1,dum, idum, &
                              work( nwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 2 (m >> n, jobz = 'o')
                    ! n left singular vectors to be overwritten on a and
                    ! n right singular vectors to be computed in vt
                    ir = 1
                    ! work(ir) is ldwrkr by n
                    if( lwork >= lda*n + n*n + 3*n + bdspac ) then
                       ldwrkr = lda
                    else
                       ldwrkr = ( lwork - n*n - 3*n - bdspac ) / n
                    end if
                    itau = ir + ldwrkr*n
                    nwork = itau + n
                    ! compute a=q*r
                    ! workspace: need   n*n [r] + n [tau] + n    [work]
                    ! workspace: prefer n*n [r] + n [tau] + n*nb [work]
                    call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! copy r to work(ir), zeroing out below it
                    call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                    call stdlib_${ri}$laset( 'L', n - 1, n - 1, zero, zero, work(ir+1),ldwrkr )
                    ! generate q in a
                    ! workspace: need   n*n [r] + n [tau] + n    [work]
                    ! workspace: prefer n*n [r] + n [tau] + n*nb [work]
                    call stdlib_${ri}$orgqr( m, n, n, a, lda, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ie = itau
                    itauq = ie + n
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in work(ir)
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n      [work]
                    ! workspace: prefer n*n [r] + 3*n [e, tauq, taup] + 2*n*nb [work]
                    call stdlib_${ri}$gebrd( n, n, work( ir ), ldwrkr, s, work( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork - nwork + 1, ierr )
                    ! work(iu) is n by n
                    iu = nwork
                    nwork = iu + n*n
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in work(iu) and computing right
                    ! singular vectors of bidiagonal matrix in vt
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n*n [u] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'I', n, s, work( ie ), work( iu ), n,vt, ldvt, dum, &
                              idum, work( nwork ), iwork,info )
                    ! overwrite work(iu) by left singular vectors of r
                    ! and vt by right singular vectors of r
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n*n [u] + n    [work]
                    ! workspace: prefer n*n [r] + 3*n [e, tauq, taup] + n*n [u] + n*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                              work( iu ), n, work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork - nwork + 1, ierr )
                    ! multiply q in a by left singular vectors of r in
                    ! work(iu), storing result in work(ir) and copying to a
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n*n [u]
                    ! workspace: prefer m*n [r] + 3*n [e, tauq, taup] + n*n [u]
                    do i = 1, m, ldwrkr
                       chunk = min( m - i + 1, ldwrkr )
                       call stdlib_${ri}$gemm( 'N', 'N', chunk, n, n, one, a( i, 1 ),lda, work( iu ), &
                                 n, zero, work( ir ),ldwrkr )
                       call stdlib_${ri}$lacpy( 'F', chunk, n, work( ir ), ldwrkr,a( i, 1 ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 3 (m >> n, jobz='s')
                    ! n left singular vectors to be computed in u and
                    ! n right singular vectors to be computed in vt
                    ir = 1
                    ! work(ir) is n by n
                    ldwrkr = n
                    itau = ir + ldwrkr*n
                    nwork = itau + n
                    ! compute a=q*r
                    ! workspace: need   n*n [r] + n [tau] + n    [work]
                    ! workspace: prefer n*n [r] + n [tau] + n*nb [work]
                    call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! copy r to work(ir), zeroing out below it
                    call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                    call stdlib_${ri}$laset( 'L', n - 1, n - 1, zero, zero, work(ir+1),ldwrkr )
                    ! generate q in a
                    ! workspace: need   n*n [r] + n [tau] + n    [work]
                    ! workspace: prefer n*n [r] + n [tau] + n*nb [work]
                    call stdlib_${ri}$orgqr( m, n, n, a, lda, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ie = itau
                    itauq = ie + n
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in work(ir)
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n      [work]
                    ! workspace: prefer n*n [r] + 3*n [e, tauq, taup] + 2*n*nb [work]
                    call stdlib_${ri}$gebrd( n, n, work( ir ), ldwrkr, s, work( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork - nwork + 1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagoal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'I', n, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! overwrite u by left singular vectors of r and vt
                    ! by right singular vectors of r
                    ! workspace: need   n*n [r] + 3*n [e, tauq, taup] + n    [work]
                    ! workspace: prefer n*n [r] + 3*n [e, tauq, taup] + n*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                              u, ldu, work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork - nwork + 1, ierr )
                    ! multiply q in a by left singular vectors of r in
                    ! work(ir), storing result in u
                    ! workspace: need   n*n [r]
                    call stdlib_${ri}$lacpy( 'F', n, n, u, ldu, work( ir ), ldwrkr )
                    call stdlib_${ri}$gemm( 'N', 'N', m, n, n, one, a, lda, work( ir ),ldwrkr, zero, u,&
                               ldu )
                 else if( wntqa ) then
                    ! path 4 (m >> n, jobz='a')
                    ! m left singular vectors to be computed in u and
                    ! n right singular vectors to be computed in vt
                    iu = 1
                    ! work(iu) is n by n
                    ldwrku = n
                    itau = iu + ldwrku*n
                    nwork = itau + n
                    ! compute a=q*r, copying result to u
                    ! workspace: need   n*n [u] + n [tau] + n    [work]
                    ! workspace: prefer n*n [u] + n [tau] + n*nb [work]
                    call stdlib_${ri}$geqrf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    call stdlib_${ri}$lacpy( 'L', m, n, a, lda, u, ldu )
                    ! generate q in u
                    ! workspace: need   n*n [u] + n [tau] + m    [work]
                    ! workspace: prefer n*n [u] + n [tau] + m*nb [work]
                    call stdlib_${ri}$orgqr( m, m, n, u, ldu, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ! produce r in a, zeroing out other entries
                    if (n>1) call stdlib_${ri}$laset( 'L', n-1, n-1, zero, zero, a( 2, 1 ), lda )
                    ie = itau
                    itauq = ie + n
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in a
                    ! workspace: need   n*n [u] + 3*n [e, tauq, taup] + n      [work]
                    ! workspace: prefer n*n [u] + 3*n [e, tauq, taup] + 2*n*nb [work]
                    call stdlib_${ri}$gebrd( n, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( nwork ), lwork-nwork+1,ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in work(iu) and computing right
                    ! singular vectors of bidiagonal matrix in vt
                    ! workspace: need   n*n [u] + 3*n [e, tauq, taup] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'I', n, s, work( ie ), work( iu ), n,vt, ldvt, dum, &
                              idum, work( nwork ), iwork,info )
                    ! overwrite work(iu) by left singular vectors of r and vt
                    ! by right singular vectors of r
                    ! workspace: need   n*n [u] + 3*n [e, tauq, taup] + n    [work]
                    ! workspace: prefer n*n [u] + 3*n [e, tauq, taup] + n*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', n, n, n, a, lda,work( itauq ), work( iu ), &
                              ldwrku,work( nwork ), lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    ! multiply q in u by left singular vectors of r in
                    ! work(iu), storing result in a
                    ! workspace: need   n*n [u]
                    call stdlib_${ri}$gemm( 'N', 'N', m, n, n, one, u, ldu, work( iu ),ldwrku, zero, a,&
                               lda )
                    ! copy left singular vectors of a from a to u
                    call stdlib_${ri}$lacpy( 'F', m, n, a, lda, u, ldu )
                 end if
              else
                 ! m < mnthr
                 ! path 5 (m >= n, but not much larger)
                 ! reduce to bidiagonal form without qr decomposition
                 ie = 1
                 itauq = ie + n
                 itaup = itauq + n
                 nwork = itaup + n
                 ! bidiagonalize a
                 ! workspace: need   3*n [e, tauq, taup] + m        [work]
                 ! workspace: prefer 3*n [e, tauq, taup] + (m+n)*nb [work]
                 call stdlib_${ri}$gebrd( m, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 5n (m >= n, jobz='n')
                    ! perform bidiagonal svd, only computing singular values
                    ! workspace: need   3*n [e, tauq, taup] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'N', n, s, work( ie ), dum, 1, dum, 1,dum, idum, &
                              work( nwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 5o (m >= n, jobz='o')
                    iu = nwork
                    if( lwork >= m*n + 3*n + bdspac ) then
                       ! work( iu ) is m by n
                       ldwrku = m
                       nwork = iu + ldwrku*n
                       call stdlib_${ri}$laset( 'F', m, n, zero, zero, work( iu ),ldwrku )
                       ! ir is unused; silence compile warnings
                       ir = -1
                    else
                       ! work( iu ) is n by n
                       ldwrku = n
                       nwork = iu + ldwrku*n
                       ! work(ir) is ldwrkr by n
                       ir = nwork
                       ldwrkr = ( lwork - n*n - 3*n ) / n
                    end if
                    nwork = iu + ldwrku*n
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in work(iu) and computing right
                    ! singular vectors of bidiagonal matrix in vt
                    ! workspace: need   3*n [e, tauq, taup] + n*n [u] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'I', n, s, work( ie ), work( iu ),ldwrku, vt, ldvt, &
                              dum, idum, work( nwork ),iwork, info )
                    ! overwrite vt by right singular vectors of a
                    ! workspace: need   3*n [e, tauq, taup] + n*n [u] + n    [work]
                    ! workspace: prefer 3*n [e, tauq, taup] + n*n [u] + n*nb [work]
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    if( lwork >= m*n + 3*n + bdspac ) then
                       ! path 5o-fast
                       ! overwrite work(iu) by left singular vectors of a
                       ! workspace: need   3*n [e, tauq, taup] + m*n [u] + n    [work]
                       ! workspace: prefer 3*n [e, tauq, taup] + m*n [u] + n*nb [work]
                       call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, n, n, a, lda,work( itauq ), work( iu &
                                 ), ldwrku,work( nwork ), lwork - nwork + 1, ierr )
                       ! copy left singular vectors of a from work(iu) to a
                       call stdlib_${ri}$lacpy( 'F', m, n, work( iu ), ldwrku, a, lda )
                    else
                       ! path 5o-slow
                       ! generate q in a
                       ! workspace: need   3*n [e, tauq, taup] + n*n [u] + n    [work]
                       ! workspace: prefer 3*n [e, tauq, taup] + n*n [u] + n*nb [work]
                       call stdlib_${ri}$orgbr( 'Q', m, n, n, a, lda, work( itauq ),work( nwork ), &
                                 lwork - nwork + 1, ierr )
                       ! multiply q in a by left singular vectors of
                       ! bidiagonal matrix in work(iu), storing result in
                       ! work(ir) and copying to a
                       ! workspace: need   3*n [e, tauq, taup] + n*n [u] + nb*n [r]
                       ! workspace: prefer 3*n [e, tauq, taup] + n*n [u] + m*n  [r]
                       do i = 1, m, ldwrkr
                          chunk = min( m - i + 1, ldwrkr )
                          call stdlib_${ri}$gemm( 'N', 'N', chunk, n, n, one, a( i, 1 ),lda, work( iu )&
                                    , ldwrku, zero,work( ir ), ldwrkr )
                          call stdlib_${ri}$lacpy( 'F', chunk, n, work( ir ), ldwrkr,a( i, 1 ), lda )
                                    
                       end do
                    end if
                 else if( wntqs ) then
                    ! path 5s (m >= n, jobz='s')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   3*n [e, tauq, taup] + bdspac
                    call stdlib_${ri}$laset( 'F', m, n, zero, zero, u, ldu )
                    call stdlib_${ri}$bdsdc( 'U', 'I', n, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! overwrite u by left singular vectors of a and vt
                    ! by right singular vectors of a
                    ! workspace: need   3*n [e, tauq, taup] + n    [work]
                    ! workspace: prefer 3*n [e, tauq, taup] + n*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, n, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                 else if( wntqa ) then
                    ! path 5a (m >= n, jobz='a')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   3*n [e, tauq, taup] + bdspac
                    call stdlib_${ri}$laset( 'F', m, m, zero, zero, u, ldu )
                    call stdlib_${ri}$bdsdc( 'U', 'I', n, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! set the right corner of u to identity matrix
                    if( m>n ) then
                       call stdlib_${ri}$laset( 'F', m - n, m - n, zero, one, u(n+1,n+1),ldu )
                    end if
                    ! overwrite u by left singular vectors of a and vt
                    ! by right singular vectors of a
                    ! workspace: need   3*n [e, tauq, taup] + m    [work]
                    ! workspace: prefer 3*n [e, tauq, taup] + m*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', n, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                 end if
              end if
           else
              ! a has more columns than rows. if a has sufficiently more
              ! columns than rows, first reduce using the lq decomposition (if
              ! sufficient workspace available)
              if( n>=mnthr ) then
                 if( wntqn ) then
                    ! path 1t (n >> m, jobz='n')
                    ! no singular vectors to be computed
                    itau = 1
                    nwork = itau + m
                    ! compute a=l*q
                    ! workspace: need   m [tau] + m [work]
                    ! workspace: prefer m [tau] + m*nb [work]
                    call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! zero out above l
                    if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, a( 1, 2 ), lda )
                    ie = 1
                    itauq = ie + m
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in a
                    ! workspace: need   3*m [e, tauq, taup] + m      [work]
                    ! workspace: prefer 3*m [e, tauq, taup] + 2*m*nb [work]
                    call stdlib_${ri}$gebrd( m, m, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( nwork ), lwork-nwork+1,ierr )
                    nwork = ie + m
                    ! perform bidiagonal svd, computing singular values only
                    ! workspace: need   m [e] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'N', m, s, work( ie ), dum, 1, dum, 1,dum, idum, &
                              work( nwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 2t (n >> m, jobz='o')
                    ! m right singular vectors to be overwritten on a and
                    ! m left singular vectors to be computed in u
                    ivt = 1
                    ! work(ivt) is m by m
                    ! work(il)  is m by m; it is later resized to m by chunk for gemm
                    il = ivt + m*m
                    if( lwork >= m*n + m*m + 3*m + bdspac ) then
                       ldwrkl = m
                       chunk = n
                    else
                       ldwrkl = m
                       chunk = ( lwork - m*m ) / m
                    end if
                    itau = il + ldwrkl*m
                    nwork = itau + m
                    ! compute a=l*q
                    ! workspace: need   m*m [vt] + m*m [l] + m [tau] + m    [work]
                    ! workspace: prefer m*m [vt] + m*m [l] + m [tau] + m*nb [work]
                    call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! copy l to work(il), zeroing about above it
                    call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( il ), ldwrkl )
                    call stdlib_${ri}$laset( 'U', m - 1, m - 1, zero, zero,work( il + ldwrkl ), ldwrkl &
                              )
                    ! generate q in a
                    ! workspace: need   m*m [vt] + m*m [l] + m [tau] + m    [work]
                    ! workspace: prefer m*m [vt] + m*m [l] + m [tau] + m*nb [work]
                    call stdlib_${ri}$orglq( m, n, m, a, lda, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ie = itau
                    itauq = ie + m
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in work(il)
                    ! workspace: need   m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + m      [work]
                    ! workspace: prefer m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + 2*m*nb [work]
                    call stdlib_${ri}$gebrd( m, m, work( il ), ldwrkl, s, work( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork - nwork + 1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u, and computing right singular
                    ! vectors of bidiagonal matrix in work(ivt)
                    ! workspace: need   m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'I', m, s, work( ie ), u, ldu,work( ivt ), m, dum, &
                              idum, work( nwork ),iwork, info )
                    ! overwrite u by left singular vectors of l and work(ivt)
                    ! by right singular vectors of l
                    ! workspace: need   m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + m    [work]
                    ! workspace: prefer m*m [vt] + m*m [l] + 3*m [e, tauq, taup] + m*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, m, m, work( il ), ldwrkl,work( itauq ), &
                              u, ldu, work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', m, m, m, work( il ), ldwrkl,work( itaup ), &
                              work( ivt ), m,work( nwork ), lwork - nwork + 1, ierr )
                    ! multiply right singular vectors of l in work(ivt) by q
                    ! in a, storing result in work(il) and copying to a
                    ! workspace: need   m*m [vt] + m*m [l]
                    ! workspace: prefer m*m [vt] + m*n [l]
                    ! at this point, l is resized as m by chunk.
                    do i = 1, n, chunk
                       blk = min( n - i + 1, chunk )
                       call stdlib_${ri}$gemm( 'N', 'N', m, blk, m, one, work( ivt ), m,a( 1, i ), lda,&
                                  zero, work( il ), ldwrkl )
                       call stdlib_${ri}$lacpy( 'F', m, blk, work( il ), ldwrkl,a( 1, i ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 3t (n >> m, jobz='s')
                    ! m right singular vectors to be computed in vt and
                    ! m left singular vectors to be computed in u
                    il = 1
                    ! work(il) is m by m
                    ldwrkl = m
                    itau = il + ldwrkl*m
                    nwork = itau + m
                    ! compute a=l*q
                    ! workspace: need   m*m [l] + m [tau] + m    [work]
                    ! workspace: prefer m*m [l] + m [tau] + m*nb [work]
                    call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    ! copy l to work(il), zeroing out above it
                    call stdlib_${ri}$lacpy( 'L', m, m, a, lda, work( il ), ldwrkl )
                    call stdlib_${ri}$laset( 'U', m - 1, m - 1, zero, zero,work( il + ldwrkl ), ldwrkl &
                              )
                    ! generate q in a
                    ! workspace: need   m*m [l] + m [tau] + m    [work]
                    ! workspace: prefer m*m [l] + m [tau] + m*nb [work]
                    call stdlib_${ri}$orglq( m, n, m, a, lda, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ie = itau
                    itauq = ie + m
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in work(iu).
                    ! workspace: need   m*m [l] + 3*m [e, tauq, taup] + m      [work]
                    ! workspace: prefer m*m [l] + 3*m [e, tauq, taup] + 2*m*nb [work]
                    call stdlib_${ri}$gebrd( m, m, work( il ), ldwrkl, s, work( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork - nwork + 1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   m*m [l] + 3*m [e, tauq, taup] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'I', m, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! overwrite u by left singular vectors of l and vt
                    ! by right singular vectors of l
                    ! workspace: need   m*m [l] + 3*m [e, tauq, taup] + m    [work]
                    ! workspace: prefer m*m [l] + 3*m [e, tauq, taup] + m*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, m, m, work( il ), ldwrkl,work( itauq ), &
                              u, ldu, work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', m, m, m, work( il ), ldwrkl,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork - nwork + 1, ierr )
                    ! multiply right singular vectors of l in work(il) by
                    ! q in a, storing result in vt
                    ! workspace: need   m*m [l]
                    call stdlib_${ri}$lacpy( 'F', m, m, vt, ldvt, work( il ), ldwrkl )
                    call stdlib_${ri}$gemm( 'N', 'N', m, n, m, one, work( il ), ldwrkl,a, lda, zero, &
                              vt, ldvt )
                 else if( wntqa ) then
                    ! path 4t (n >> m, jobz='a')
                    ! n right singular vectors to be computed in vt and
                    ! m left singular vectors to be computed in u
                    ivt = 1
                    ! work(ivt) is m by m
                    ldwkvt = m
                    itau = ivt + ldwkvt*m
                    nwork = itau + m
                    ! compute a=l*q, copying result to vt
                    ! workspace: need   m*m [vt] + m [tau] + m    [work]
                    ! workspace: prefer m*m [vt] + m [tau] + m*nb [work]
                    call stdlib_${ri}$gelqf( m, n, a, lda, work( itau ), work( nwork ),lwork - nwork + &
                              1, ierr )
                    call stdlib_${ri}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                    ! generate q in vt
                    ! workspace: need   m*m [vt] + m [tau] + n    [work]
                    ! workspace: prefer m*m [vt] + m [tau] + n*nb [work]
                    call stdlib_${ri}$orglq( n, n, m, vt, ldvt, work( itau ),work( nwork ), lwork - &
                              nwork + 1, ierr )
                    ! produce l in a, zeroing out other entries
                    if (m>1) call stdlib_${ri}$laset( 'U', m-1, m-1, zero, zero, a( 1, 2 ), lda )
                    ie = itau
                    itauq = ie + m
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in a
                    ! workspace: need   m*m [vt] + 3*m [e, tauq, taup] + m      [work]
                    ! workspace: prefer m*m [vt] + 3*m [e, tauq, taup] + 2*m*nb [work]
                    call stdlib_${ri}$gebrd( m, m, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                              work( nwork ), lwork-nwork+1,ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in work(ivt)
                    ! workspace: need   m*m [vt] + 3*m [e, tauq, taup] + bdspac
                    call stdlib_${ri}$bdsdc( 'U', 'I', m, s, work( ie ), u, ldu,work( ivt ), ldwkvt, &
                              dum, idum,work( nwork ), iwork, info )
                    ! overwrite u by left singular vectors of l and work(ivt)
                    ! by right singular vectors of l
                    ! workspace: need   m*m [vt] + 3*m [e, tauq, taup]+ m    [work]
                    ! workspace: prefer m*m [vt] + 3*m [e, tauq, taup]+ m*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, m, m, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', m, m, m, a, lda,work( itaup ), work( ivt ),&
                               ldwkvt,work( nwork ), lwork - nwork + 1, ierr )
                    ! multiply right singular vectors of l in work(ivt) by
                    ! q in vt, storing result in a
                    ! workspace: need   m*m [vt]
                    call stdlib_${ri}$gemm( 'N', 'N', m, n, m, one, work( ivt ), ldwkvt,vt, ldvt, zero,&
                               a, lda )
                    ! copy right singular vectors of a from a to vt
                    call stdlib_${ri}$lacpy( 'F', m, n, a, lda, vt, ldvt )
                 end if
              else
                 ! n < mnthr
                 ! path 5t (n > m, but not much larger)
                 ! reduce to bidiagonal form without lq decomposition
                 ie = 1
                 itauq = ie + m
                 itaup = itauq + m
                 nwork = itaup + m
                 ! bidiagonalize a
                 ! workspace: need   3*m [e, tauq, taup] + n        [work]
                 ! workspace: prefer 3*m [e, tauq, taup] + (m+n)*nb [work]
                 call stdlib_${ri}$gebrd( m, n, a, lda, s, work( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 5tn (n > m, jobz='n')
                    ! perform bidiagonal svd, only computing singular values
                    ! workspace: need   3*m [e, tauq, taup] + bdspac
                    call stdlib_${ri}$bdsdc( 'L', 'N', m, s, work( ie ), dum, 1, dum, 1,dum, idum, &
                              work( nwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 5to (n > m, jobz='o')
                    ldwkvt = m
                    ivt = nwork
                    if( lwork >= m*n + 3*m + bdspac ) then
                       ! work( ivt ) is m by n
                       call stdlib_${ri}$laset( 'F', m, n, zero, zero, work( ivt ),ldwkvt )
                       nwork = ivt + ldwkvt*n
                       ! il is unused; silence compile warnings
                       il = -1
                    else
                       ! work( ivt ) is m by m
                       nwork = ivt + ldwkvt*m
                       il = nwork
                       ! work(il) is m by chunk
                       chunk = ( lwork - m*m - 3*m ) / m
                    end if
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in work(ivt)
                    ! workspace: need   3*m [e, tauq, taup] + m*m [vt] + bdspac
                    call stdlib_${ri}$bdsdc( 'L', 'I', m, s, work( ie ), u, ldu,work( ivt ), ldwkvt, &
                              dum, idum,work( nwork ), iwork, info )
                    ! overwrite u by left singular vectors of a
                    ! workspace: need   3*m [e, tauq, taup] + m*m [vt] + m    [work]
                    ! workspace: prefer 3*m [e, tauq, taup] + m*m [vt] + m*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    if( lwork >= m*n + 3*m + bdspac ) then
                       ! path 5to-fast
                       ! overwrite work(ivt) by left singular vectors of a
                       ! workspace: need   3*m [e, tauq, taup] + m*n [vt] + m    [work]
                       ! workspace: prefer 3*m [e, tauq, taup] + m*n [vt] + m*nb [work]
                       call stdlib_${ri}$ormbr( 'P', 'R', 'T', m, n, m, a, lda,work( itaup ), work( &
                                 ivt ), ldwkvt,work( nwork ), lwork - nwork + 1, ierr )
                       ! copy right singular vectors of a from work(ivt) to a
                       call stdlib_${ri}$lacpy( 'F', m, n, work( ivt ), ldwkvt, a, lda )
                    else
                       ! path 5to-slow
                       ! generate p**t in a
                       ! workspace: need   3*m [e, tauq, taup] + m*m [vt] + m    [work]
                       ! workspace: prefer 3*m [e, tauq, taup] + m*m [vt] + m*nb [work]
                       call stdlib_${ri}$orgbr( 'P', m, n, m, a, lda, work( itaup ),work( nwork ), &
                                 lwork - nwork + 1, ierr )
                       ! multiply q in a by right singular vectors of
                       ! bidiagonal matrix in work(ivt), storing result in
                       ! work(il) and copying to a
                       ! workspace: need   3*m [e, tauq, taup] + m*m [vt] + m*nb [l]
                       ! workspace: prefer 3*m [e, tauq, taup] + m*m [vt] + m*n  [l]
                       do i = 1, n, chunk
                          blk = min( n - i + 1, chunk )
                          call stdlib_${ri}$gemm( 'N', 'N', m, blk, m, one, work( ivt ),ldwkvt, a( 1, &
                                    i ), lda, zero,work( il ), m )
                          call stdlib_${ri}$lacpy( 'F', m, blk, work( il ), m, a( 1, i ),lda )
                       end do
                    end if
                 else if( wntqs ) then
                    ! path 5ts (n > m, jobz='s')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   3*m [e, tauq, taup] + bdspac
                    call stdlib_${ri}$laset( 'F', m, n, zero, zero, vt, ldvt )
                    call stdlib_${ri}$bdsdc( 'L', 'I', m, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! overwrite u by left singular vectors of a and vt
                    ! by right singular vectors of a
                    ! workspace: need   3*m [e, tauq, taup] + m    [work]
                    ! workspace: prefer 3*m [e, tauq, taup] + m*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', m, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                 else if( wntqa ) then
                    ! path 5ta (n > m, jobz='a')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in u and computing right singular
                    ! vectors of bidiagonal matrix in vt
                    ! workspace: need   3*m [e, tauq, taup] + bdspac
                    call stdlib_${ri}$laset( 'F', n, n, zero, zero, vt, ldvt )
                    call stdlib_${ri}$bdsdc( 'L', 'I', m, s, work( ie ), u, ldu, vt,ldvt, dum, idum, &
                              work( nwork ), iwork,info )
                    ! set the right corner of vt to identity matrix
                    if( n>m ) then
                       call stdlib_${ri}$laset( 'F', n-m, n-m, zero, one, vt(m+1,m+1),ldvt )
                    end if
                    ! overwrite u by left singular vectors of a and vt
                    ! by right singular vectors of a
                    ! workspace: need   3*m [e, tauq, taup] + n    [work]
                    ! workspace: prefer 3*m [e, tauq, taup] + n*nb [work]
                    call stdlib_${ri}$ormbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork - nwork + 1, ierr )
                    call stdlib_${ri}$ormbr( 'P', 'R', 'T', n, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork - nwork + 1, ierr )
                 end if
              end if
           end if
           ! undo scaling if necessary
           if( iscl==1 ) then
              if( anrm>bignum )call stdlib_${ri}$lascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( anrm<smlnum )call stdlib_${ri}$lascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,&
                        ierr )
           end if
           ! return optimal workspace in work(1)
           work( 1 ) = stdlib_${ri}$roundup_lwork( maxwrk )
           return
     end subroutine stdlib_${ri}$gesdd

#:endif
#:endfor

     module subroutine stdlib_cgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, rwork, iwork, &
     !! CGESDD computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, optionally computing the left and/or right singular
     !! vectors, by using divide-and-conquer method. The SVD is written
     !! A = U * SIGMA * conjugate-transpose(V)
     !! where SIGMA is an M-by-N matrix which is zero except for its
     !! min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
     !! V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
     !! are the singular values of A; they are real and non-negative, and
     !! are returned in descending order.  The first min(m,n) columns of
     !! U and V are the left and right singular vectors of A.
     !! Note that the routine returns VT = V**H, not V.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldvt, lwork, m, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: rwork(*), s(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lquery, wntqa, wntqas, wntqn, wntqo, wntqs
           integer(ilp) :: blk, chunk, i, ie, ierr, il, ir, iru, irvt, iscl, itau, itaup, itauq, &
           iu, ivt, ldwkvt, ldwrkl, ldwrkr, ldwrku, maxwrk, minmn, minwrk, mnthr1, mnthr2, nrwork,&
                      nwork, wrkbl
           integer(ilp) :: lwork_cgebrd_mn, lwork_cgebrd_mm, lwork_cgebrd_nn, lwork_cgelqf_mn, &
           lwork_cgeqrf_mn, lwork_cungbr_p_mn, lwork_cungbr_p_nn, lwork_cungbr_q_mn, &
           lwork_cungbr_q_mm, lwork_cunglq_mn, lwork_cunglq_nn, lwork_cungqr_mm, lwork_cungqr_mn, &
           lwork_cunmbr_prc_mm, lwork_cunmbr_qln_mm, lwork_cunmbr_prc_mn, lwork_cunmbr_qln_mn, &
                     lwork_cunmbr_prc_nn, lwork_cunmbr_qln_nn
           real(sp) :: anrm, bignum, eps, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(sp) :: dum(1)
           complex(sp) :: cdum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info   = 0
           minmn  = min( m, n )
           mnthr1 = int( minmn*17.0_sp / 9.0_sp,KIND=ilp)
           mnthr2 = int( minmn*5.0_sp / 3.0_sp,KIND=ilp)
           wntqa  = stdlib_lsame( jobz, 'A' )
           wntqs  = stdlib_lsame( jobz, 'S' )
           wntqas = wntqa .or. wntqs
           wntqo  = stdlib_lsame( jobz, 'O' )
           wntqn  = stdlib_lsame( jobz, 'N' )
           lquery = ( lwork==-1 )
           minwrk = 1
           maxwrk = 1
           if( .not.( wntqa .or. wntqs .or. wntqo .or. wntqn ) ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldu<1 .or. ( wntqas .and. ldu<m ) .or.( wntqo .and. m<n .and. ldu<m ) ) &
                     then
              info = -8
           else if( ldvt<1 .or. ( wntqa .and. ldvt<n ) .or.( wntqs .and. ldvt<minmn ) .or.( wntqo &
                     .and. m>=n .and. ldvt<n ) ) then
              info = -10
           end if
           ! compute workspace
             ! note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace allocated at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to
             ! real workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              if( m>=n .and. minmn>0 ) then
                 ! there is no complex work space needed for bidiagonal svd
                 ! the realwork space needed for bidiagonal svd (stdlib_sbdsdc,KIND=sp) is
                 ! bdspac = 3*n*n + 4*n for singular values and vectors;
                 ! bdspac = 4*n         for singular values only;
                 ! not including e, ru, and rvt matrices.
                 ! compute space preferred for each routine
                 call stdlib_cgebrd( m, n, cdum(1), m, dum(1), dum(1), cdum(1),cdum(1), cdum(1), -&
                           1, ierr )
                 lwork_cgebrd_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cgebrd( n, n, cdum(1), n, dum(1), dum(1), cdum(1),cdum(1), cdum(1), -&
                           1, ierr )
                 lwork_cgebrd_nn = int( cdum(1),KIND=ilp)
                 call stdlib_cgeqrf( m, n, cdum(1), m, cdum(1), cdum(1), -1, ierr )
                 lwork_cgeqrf_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cungbr( 'P', n, n, n, cdum(1), n, cdum(1), cdum(1),-1, ierr )
                 lwork_cungbr_p_nn = int( cdum(1),KIND=ilp)
                 call stdlib_cungbr( 'Q', m, m, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_cungbr_q_mm = int( cdum(1),KIND=ilp)
                 call stdlib_cungbr( 'Q', m, n, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_cungbr_q_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cungqr( m, m, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_cungqr_mm = int( cdum(1),KIND=ilp)
                 call stdlib_cungqr( m, n, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_cungqr_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cunmbr( 'P', 'R', 'C', n, n, n, cdum(1), n, cdum(1),cdum(1), n, cdum(&
                           1), -1, ierr )
                 lwork_cunmbr_prc_nn = int( cdum(1),KIND=ilp)
                 call stdlib_cunmbr( 'Q', 'L', 'N', m, m, n, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_cunmbr_qln_mm = int( cdum(1),KIND=ilp)
                 call stdlib_cunmbr( 'Q', 'L', 'N', m, n, n, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_cunmbr_qln_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cunmbr( 'Q', 'L', 'N', n, n, n, cdum(1), n, cdum(1),cdum(1), n, cdum(&
                           1), -1, ierr )
                 lwork_cunmbr_qln_nn = int( cdum(1),KIND=ilp)
                 if( m>=mnthr1 ) then
                    if( wntqn ) then
                       ! path 1 (m >> n, jobz='n')
                       maxwrk = n + lwork_cgeqrf_mn
                       maxwrk = max( maxwrk, 2*n + lwork_cgebrd_nn )
                       minwrk = 3*n
                    else if( wntqo ) then
                       ! path 2 (m >> n, jobz='o')
                       wrkbl = n + lwork_cgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_cungqr_mn )
                       wrkbl = max( wrkbl, 2*n + lwork_cgebrd_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_cunmbr_qln_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_cunmbr_prc_nn )
                       maxwrk = m*n + n*n + wrkbl
                       minwrk = 2*n*n + 3*n
                    else if( wntqs ) then
                       ! path 3 (m >> n, jobz='s')
                       wrkbl = n + lwork_cgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_cungqr_mn )
                       wrkbl = max( wrkbl, 2*n + lwork_cgebrd_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_cunmbr_qln_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_cunmbr_prc_nn )
                       maxwrk = n*n + wrkbl
                       minwrk = n*n + 3*n
                    else if( wntqa ) then
                       ! path 4 (m >> n, jobz='a')
                       wrkbl = n + lwork_cgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_cungqr_mm )
                       wrkbl = max( wrkbl, 2*n + lwork_cgebrd_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_cunmbr_qln_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_cunmbr_prc_nn )
                       maxwrk = n*n + wrkbl
                       minwrk = n*n + max( 3*n, n + m )
                    end if
                 else if( m>=mnthr2 ) then
                    ! path 5 (m >> n, but not as much as mnthr1)
                    maxwrk = 2*n + lwork_cgebrd_mn
                    minwrk = 2*n + m
                    if( wntqo ) then
                       ! path 5o (m >> n, jobz='o')
                       maxwrk = max( maxwrk, 2*n + lwork_cungbr_p_nn )
                       maxwrk = max( maxwrk, 2*n + lwork_cungbr_q_mn )
                       maxwrk = maxwrk + m*n
                       minwrk = minwrk + n*n
                    else if( wntqs ) then
                       ! path 5s (m >> n, jobz='s')
                       maxwrk = max( maxwrk, 2*n + lwork_cungbr_p_nn )
                       maxwrk = max( maxwrk, 2*n + lwork_cungbr_q_mn )
                    else if( wntqa ) then
                       ! path 5a (m >> n, jobz='a')
                       maxwrk = max( maxwrk, 2*n + lwork_cungbr_p_nn )
                       maxwrk = max( maxwrk, 2*n + lwork_cungbr_q_mm )
                    end if
                 else
                    ! path 6 (m >= n, but not much larger)
                    maxwrk = 2*n + lwork_cgebrd_mn
                    minwrk = 2*n + m
                    if( wntqo ) then
                       ! path 6o (m >= n, jobz='o')
                       maxwrk = max( maxwrk, 2*n + lwork_cunmbr_prc_nn )
                       maxwrk = max( maxwrk, 2*n + lwork_cunmbr_qln_mn )
                       maxwrk = maxwrk + m*n
                       minwrk = minwrk + n*n
                    else if( wntqs ) then
                       ! path 6s (m >= n, jobz='s')
                       maxwrk = max( maxwrk, 2*n + lwork_cunmbr_qln_mn )
                       maxwrk = max( maxwrk, 2*n + lwork_cunmbr_prc_nn )
                    else if( wntqa ) then
                       ! path 6a (m >= n, jobz='a')
                       maxwrk = max( maxwrk, 2*n + lwork_cunmbr_qln_mm )
                       maxwrk = max( maxwrk, 2*n + lwork_cunmbr_prc_nn )
                    end if
                 end if
              else if( minmn>0 ) then
                 ! there is no complex work space needed for bidiagonal svd
                 ! the realwork space needed for bidiagonal svd (stdlib_sbdsdc,KIND=sp) is
                 ! bdspac = 3*m*m + 4*m for singular values and vectors;
                 ! bdspac = 4*m         for singular values only;
                 ! not including e, ru, and rvt matrices.
                 ! compute space preferred for each routine
                 call stdlib_cgebrd( m, n, cdum(1), m, dum(1), dum(1), cdum(1),cdum(1), cdum(1), -&
                           1, ierr )
                 lwork_cgebrd_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cgebrd( m, m, cdum(1), m, dum(1), dum(1), cdum(1),cdum(1), cdum(1), -&
                           1, ierr )
                 lwork_cgebrd_mm = int( cdum(1),KIND=ilp)
                 call stdlib_cgelqf( m, n, cdum(1), m, cdum(1), cdum(1), -1, ierr )
                 lwork_cgelqf_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cungbr( 'P', m, n, m, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_cungbr_p_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cungbr( 'P', n, n, m, cdum(1), n, cdum(1), cdum(1),-1, ierr )
                 lwork_cungbr_p_nn = int( cdum(1),KIND=ilp)
                 call stdlib_cungbr( 'Q', m, m, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_cungbr_q_mm = int( cdum(1),KIND=ilp)
                 call stdlib_cunglq( m, n, m, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_cunglq_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cunglq( n, n, m, cdum(1), n, cdum(1), cdum(1),-1, ierr )
                 lwork_cunglq_nn = int( cdum(1),KIND=ilp)
                 call stdlib_cunmbr( 'P', 'R', 'C', m, m, m, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_cunmbr_prc_mm = int( cdum(1),KIND=ilp)
                 call stdlib_cunmbr( 'P', 'R', 'C', m, n, m, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_cunmbr_prc_mn = int( cdum(1),KIND=ilp)
                 call stdlib_cunmbr( 'P', 'R', 'C', n, n, m, cdum(1), n, cdum(1),cdum(1), n, cdum(&
                           1), -1, ierr )
                 lwork_cunmbr_prc_nn = int( cdum(1),KIND=ilp)
                 call stdlib_cunmbr( 'Q', 'L', 'N', m, m, m, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_cunmbr_qln_mm = int( cdum(1),KIND=ilp)
                 if( n>=mnthr1 ) then
                    if( wntqn ) then
                       ! path 1t (n >> m, jobz='n')
                       maxwrk = m + lwork_cgelqf_mn
                       maxwrk = max( maxwrk, 2*m + lwork_cgebrd_mm )
                       minwrk = 3*m
                    else if( wntqo ) then
                       ! path 2t (n >> m, jobz='o')
                       wrkbl = m + lwork_cgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_cunglq_mn )
                       wrkbl = max( wrkbl, 2*m + lwork_cgebrd_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_cunmbr_qln_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_cunmbr_prc_mm )
                       maxwrk = m*n + m*m + wrkbl
                       minwrk = 2*m*m + 3*m
                    else if( wntqs ) then
                       ! path 3t (n >> m, jobz='s')
                       wrkbl = m + lwork_cgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_cunglq_mn )
                       wrkbl = max( wrkbl, 2*m + lwork_cgebrd_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_cunmbr_qln_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_cunmbr_prc_mm )
                       maxwrk = m*m + wrkbl
                       minwrk = m*m + 3*m
                    else if( wntqa ) then
                       ! path 4t (n >> m, jobz='a')
                       wrkbl = m + lwork_cgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_cunglq_nn )
                       wrkbl = max( wrkbl, 2*m + lwork_cgebrd_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_cunmbr_qln_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_cunmbr_prc_mm )
                       maxwrk = m*m + wrkbl
                       minwrk = m*m + max( 3*m, m + n )
                    end if
                 else if( n>=mnthr2 ) then
                    ! path 5t (n >> m, but not as much as mnthr1)
                    maxwrk = 2*m + lwork_cgebrd_mn
                    minwrk = 2*m + n
                    if( wntqo ) then
                       ! path 5to (n >> m, jobz='o')
                       maxwrk = max( maxwrk, 2*m + lwork_cungbr_q_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_cungbr_p_mn )
                       maxwrk = maxwrk + m*n
                       minwrk = minwrk + m*m
                    else if( wntqs ) then
                       ! path 5ts (n >> m, jobz='s')
                       maxwrk = max( maxwrk, 2*m + lwork_cungbr_q_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_cungbr_p_mn )
                    else if( wntqa ) then
                       ! path 5ta (n >> m, jobz='a')
                       maxwrk = max( maxwrk, 2*m + lwork_cungbr_q_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_cungbr_p_nn )
                    end if
                 else
                    ! path 6t (n > m, but not much larger)
                    maxwrk = 2*m + lwork_cgebrd_mn
                    minwrk = 2*m + n
                    if( wntqo ) then
                       ! path 6to (n > m, jobz='o')
                       maxwrk = max( maxwrk, 2*m + lwork_cunmbr_qln_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_cunmbr_prc_mn )
                       maxwrk = maxwrk + m*n
                       minwrk = minwrk + m*m
                    else if( wntqs ) then
                       ! path 6ts (n > m, jobz='s')
                       maxwrk = max( maxwrk, 2*m + lwork_cunmbr_qln_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_cunmbr_prc_mn )
                    else if( wntqa ) then
                       ! path 6ta (n > m, jobz='a')
                       maxwrk = max( maxwrk, 2*m + lwork_cunmbr_qln_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_cunmbr_prc_nn )
                    end if
                 end if
              end if
              maxwrk = max( maxwrk, minwrk )
           end if
           if( info==0 ) then
              work( 1 ) = stdlib_sroundup_lwork( maxwrk )
              if( lwork<minwrk .and. .not. lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGESDD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = sqrt( stdlib_slamch( 'S' ) ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_clange( 'M', m, n, a, lda, dum )
           if( stdlib_sisnan ( anrm ) ) then
               info = -4
               return
           end if
           iscl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              iscl = 1
              call stdlib_clascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, ierr )
           else if( anrm>bignum ) then
              iscl = 1
              call stdlib_clascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, ierr )
           end if
           if( m>=n ) then
              ! a has at least as many rows as columns. if a has sufficiently
              ! more rows than columns, first reduce using the qr
              ! decomposition (if sufficient workspace available)
              if( m>=mnthr1 ) then
                 if( wntqn ) then
                    ! path 1 (m >> n, jobz='n')
                    ! no singular vectors to be computed
                    itau = 1
                    nwork = itau + n
                    ! compute a=q*r
                    ! cworkspace: need   n [tau] + n    [work]
                    ! cworkspace: prefer n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! zero out below r
                    if (n>1) call stdlib_claset( 'L', n-1, n-1, czero, czero, a( 2, 1 ),lda )
                    ie = 1
                    itauq = 1
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in a
                    ! cworkspace: need   2*n [tauq, taup] + n      [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + 2*n*nb [work]
                    ! rworkspace: need   n [e]
                    call stdlib_cgebrd( n, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( nwork ), lwork-nwork+1,ierr )
                    nrwork = ie + n
                    ! perform bidiagonal svd, compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + bdspac
                    call stdlib_sbdsdc( 'U', 'N', n, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 2 (m >> n, jobz='o')
                    ! n left singular vectors to be overwritten on a and
                    ! n right singular vectors to be computed in vt
                    iu = 1
                    ! work(iu) is n by n
                    ldwrku = n
                    ir = iu + ldwrku*n
                    if( lwork >= m*n + n*n + 3*n ) then
                       ! work(ir) is m by n
                       ldwrkr = m
                    else
                       ldwrkr = ( lwork - n*n - 3*n ) / n
                    end if
                    itau = ir + ldwrkr*n
                    nwork = itau + n
                    ! compute a=q*r
                    ! cworkspace: need   n*n [u] + n*n [r] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! copy r to work( ir ), zeroing out below it
                    call stdlib_clacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                    call stdlib_claset( 'L', n-1, n-1, czero, czero, work( ir+1 ),ldwrkr )
                    ! generate q in a
                    ! cworkspace: need   n*n [u] + n*n [r] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cungqr( m, n, n, a, lda, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ie = 1
                    itauq = itau
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in work(ir)
                    ! cworkspace: need   n*n [u] + n*n [r] + 2*n [tauq, taup] + n      [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + 2*n [tauq, taup] + 2*n*nb [work]
                    ! rworkspace: need   n [e]
                    call stdlib_cgebrd( n, n, work( ir ), ldwrkr, s, rwork( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of r in work(iru) and computing right singular vectors
                    ! of r in work(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = ie + n
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_sbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix work(iu)
                    ! overwrite work(iu) by the left singular vectors of r
                    ! cworkspace: need   n*n [u] + n*n [r] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', n, n, rwork( iru ), n, work( iu ),ldwrku )
                    call stdlib_cunmbr( 'Q', 'L', 'N', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                              work( iu ), ldwrku,work( nwork ), lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix vt
                    ! overwrite vt by the right singular vectors of r
                    ! cworkspace: need   n*n [u] + n*n [r] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork-nwork+1, ierr )
                    ! multiply q in a by left singular vectors of r in
                    ! work(iu), storing result in work(ir) and copying to a
                    ! cworkspace: need   n*n [u] + n*n [r]
                    ! cworkspace: prefer n*n [u] + m*n [r]
                    ! rworkspace: need   0
                    do i = 1, m, ldwrkr
                       chunk = min( m-i+1, ldwrkr )
                       call stdlib_cgemm( 'N', 'N', chunk, n, n, cone, a( i, 1 ),lda, work( iu ), &
                                 ldwrku, czero,work( ir ), ldwrkr )
                       call stdlib_clacpy( 'F', chunk, n, work( ir ), ldwrkr,a( i, 1 ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 3 (m >> n, jobz='s')
                    ! n left singular vectors to be computed in u and
                    ! n right singular vectors to be computed in vt
                    ir = 1
                    ! work(ir) is n by n
                    ldwrkr = n
                    itau = ir + ldwrkr*n
                    nwork = itau + n
                    ! compute a=q*r
                    ! cworkspace: need   n*n [r] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [r] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! copy r to work(ir), zeroing out below it
                    call stdlib_clacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                    call stdlib_claset( 'L', n-1, n-1, czero, czero, work( ir+1 ),ldwrkr )
                    ! generate q in a
                    ! cworkspace: need   n*n [r] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [r] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cungqr( m, n, n, a, lda, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ie = 1
                    itauq = itau
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in work(ir)
                    ! cworkspace: need   n*n [r] + 2*n [tauq, taup] + n      [work]
                    ! cworkspace: prefer n*n [r] + 2*n [tauq, taup] + 2*n*nb [work]
                    ! rworkspace: need   n [e]
                    call stdlib_cgebrd( n, n, work( ir ), ldwrkr, s, rwork( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = ie + n
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_sbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix u
                    ! overwrite u by left singular vectors of r
                    ! cworkspace: need   n*n [r] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [r] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', n, n, rwork( iru ), n, u, ldu )
                    call stdlib_cunmbr( 'Q', 'L', 'N', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                              u, ldu, work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix vt
                    ! overwrite vt by right singular vectors of r
                    ! cworkspace: need   n*n [r] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [r] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork-nwork+1, ierr )
                    ! multiply q in a by left singular vectors of r in
                    ! work(ir), storing result in u
                    ! cworkspace: need   n*n [r]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'F', n, n, u, ldu, work( ir ), ldwrkr )
                    call stdlib_cgemm( 'N', 'N', m, n, n, cone, a, lda, work( ir ),ldwrkr, czero, &
                              u, ldu )
                 else if( wntqa ) then
                    ! path 4 (m >> n, jobz='a')
                    ! m left singular vectors to be computed in u and
                    ! n right singular vectors to be computed in vt
                    iu = 1
                    ! work(iu) is n by n
                    ldwrku = n
                    itau = iu + ldwrku*n
                    nwork = itau + n
                    ! compute a=q*r, copying result to u
                    ! cworkspace: need   n*n [u] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [u] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                    ! generate q in u
                    ! cworkspace: need   n*n [u] + n [tau] + m    [work]
                    ! cworkspace: prefer n*n [u] + n [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cungqr( m, m, n, u, ldu, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ! produce r in a, zeroing out below it
                    if (n>1) call stdlib_claset( 'L', n-1, n-1, czero, czero, a( 2, 1 ),lda )
                    ie = 1
                    itauq = itau
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in a
                    ! cworkspace: need   n*n [u] + 2*n [tauq, taup] + n      [work]
                    ! cworkspace: prefer n*n [u] + 2*n [tauq, taup] + 2*n*nb [work]
                    ! rworkspace: need   n [e]
                    call stdlib_cgebrd( n, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( nwork ), lwork-nwork+1,ierr )
                    iru = ie + n
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    call stdlib_sbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix work(iu)
                    ! overwrite work(iu) by left singular vectors of r
                    ! cworkspace: need   n*n [u] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [u] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', n, n, rwork( iru ), n, work( iu ),ldwrku )
                    call stdlib_cunmbr( 'Q', 'L', 'N', n, n, n, a, lda,work( itauq ), work( iu ), &
                              ldwrku,work( nwork ), lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix vt
                    ! overwrite vt by right singular vectors of r
                    ! cworkspace: need   n*n [u] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [u] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! multiply q in u by left singular vectors of r in
                    ! work(iu), storing result in a
                    ! cworkspace: need   n*n [u]
                    ! rworkspace: need   0
                    call stdlib_cgemm( 'N', 'N', m, n, n, cone, u, ldu, work( iu ),ldwrku, czero, &
                              a, lda )
                    ! copy left singular vectors of a from a to u
                    call stdlib_clacpy( 'F', m, n, a, lda, u, ldu )
                 end if
              else if( m>=mnthr2 ) then
                 ! mnthr2 <= m < mnthr1
                 ! path 5 (m >> n, but not as much as mnthr1)
                 ! reduce to bidiagonal form without qr decomposition, use
                 ! stdlib_cungbr and matrix multiplication to compute singular vectors
                 ie = 1
                 nrwork = ie + n
                 itauq = 1
                 itaup = itauq + n
                 nwork = itaup + n
                 ! bidiagonalize a
                 ! cworkspace: need   2*n [tauq, taup] + m        [work]
                 ! cworkspace: prefer 2*n [tauq, taup] + (m+n)*nb [work]
                 ! rworkspace: need   n [e]
                 call stdlib_cgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 5n (m >> n, jobz='n')
                    ! compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + bdspac
                    call stdlib_sbdsdc( 'U', 'N', n, s, rwork( ie ), dum, 1,dum,1,dum, idum, &
                              rwork( nrwork ), iwork, info )
                 else if( wntqo ) then
                    iu = nwork
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    ! path 5o (m >> n, jobz='o')
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! generate q in a
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cungbr( 'Q', m, n, n, a, lda, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    if( lwork >= m*n + 3*n ) then
                       ! work( iu ) is m by n
                       ldwrku = m
                    else
                       ! work(iu) is ldwrku by n
                       ldwrku = ( lwork - 3*n ) / n
                    end if
                    nwork = iu + ldwrku*n
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    call stdlib_sbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply realmatrix rwork(irvt,KIND=sp) by p**h in vt,
                    ! storing the result in work(iu), copying to vt
                    ! cworkspace: need   2*n [tauq, taup] + n*n [u]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + 2*n*n [rwork]
                    call stdlib_clarcm( n, n, rwork( irvt ), n, vt, ldvt,work( iu ), ldwrku, &
                              rwork( nrwork ) )
                    call stdlib_clacpy( 'F', n, n, work( iu ), ldwrku, vt, ldvt )
                    ! multiply q in a by realmatrix rwork(iru,KIND=sp), storing the
                    ! result in work(iu), copying to a
                    ! cworkspace: need   2*n [tauq, taup] + n*n [u]
                    ! cworkspace: prefer 2*n [tauq, taup] + m*n [u]
                    ! rworkspace: need   n [e] + n*n [ru] + 2*n*n [rwork]
                    ! rworkspace: prefer n [e] + n*n [ru] + 2*m*n [rwork] < n + 5*n*n since m < 2*n here
                    nrwork = irvt
                    do i = 1, m, ldwrku
                       chunk = min( m-i+1, ldwrku )
                       call stdlib_clacrm( chunk, n, a( i, 1 ), lda, rwork( iru ),n, work( iu ), &
                                 ldwrku, rwork( nrwork ) )
                       call stdlib_clacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 5s (m >> n, jobz='s')
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! copy a to u, generate q
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                    call stdlib_cungbr( 'Q', m, n, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_sbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply realmatrix rwork(irvt,KIND=sp) by p**h in vt,
                    ! storing the result in a, copying to vt
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + 2*n*n [rwork]
                    call stdlib_clarcm( n, n, rwork( irvt ), n, vt, ldvt, a, lda,rwork( nrwork ) )
                              
                    call stdlib_clacpy( 'F', n, n, a, lda, vt, ldvt )
                    ! multiply q in u by realmatrix rwork(iru,KIND=sp), storing the
                    ! result in a, copying to u
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + 2*m*n [rwork] < n + 5*n*n since m < 2*n here
                    nrwork = irvt
                    call stdlib_clacrm( m, n, u, ldu, rwork( iru ), n, a, lda,rwork( nrwork ) )
                              
                    call stdlib_clacpy( 'F', m, n, a, lda, u, ldu )
                 else
                    ! path 5a (m >> n, jobz='a')
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_cungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! copy a to u, generate q
                    ! cworkspace: need   2*n [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'L', m, n, a, lda, u, ldu )
                    call stdlib_cungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_sbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply realmatrix rwork(irvt,KIND=sp) by p**h in vt,
                    ! storing the result in a, copying to vt
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + 2*n*n [rwork]
                    call stdlib_clarcm( n, n, rwork( irvt ), n, vt, ldvt, a, lda,rwork( nrwork ) )
                              
                    call stdlib_clacpy( 'F', n, n, a, lda, vt, ldvt )
                    ! multiply q in u by realmatrix rwork(iru,KIND=sp), storing the
                    ! result in a, copying to u
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + 2*m*n [rwork] < n + 5*n*n since m < 2*n here
                    nrwork = irvt
                    call stdlib_clacrm( m, n, u, ldu, rwork( iru ), n, a, lda,rwork( nrwork ) )
                              
                    call stdlib_clacpy( 'F', m, n, a, lda, u, ldu )
                 end if
              else
                 ! m < mnthr2
                 ! path 6 (m >= n, but not much larger)
                 ! reduce to bidiagonal form without qr decomposition
                 ! use stdlib_cunmbr to compute singular vectors
                 ie = 1
                 nrwork = ie + n
                 itauq = 1
                 itaup = itauq + n
                 nwork = itaup + n
                 ! bidiagonalize a
                 ! cworkspace: need   2*n [tauq, taup] + m        [work]
                 ! cworkspace: prefer 2*n [tauq, taup] + (m+n)*nb [work]
                 ! rworkspace: need   n [e]
                 call stdlib_cgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 6n (m >= n, jobz='n')
                    ! compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + bdspac
                    call stdlib_sbdsdc( 'U', 'N', n, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    iu = nwork
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    if( lwork >= m*n + 3*n ) then
                       ! work( iu ) is m by n
                       ldwrku = m
                    else
                       ! work( iu ) is ldwrku by n
                       ldwrku = ( lwork - 3*n ) / n
                    end if
                    nwork = iu + ldwrku*n
                    ! path 6o (m >= n, jobz='o')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    call stdlib_sbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + n*n [u] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*n [u] + n*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_clacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                    if( lwork >= m*n + 3*n ) then
                       ! path 6o-fast
                       ! copy realmatrix rwork(iru,KIND=sp) to complex matrix work(iu)
                       ! overwrite work(iu) by left singular vectors of a, copying
                       ! to a
                       ! cworkspace: need   2*n [tauq, taup] + m*n [u] + n    [work]
                       ! cworkspace: prefer 2*n [tauq, taup] + m*n [u] + n*nb [work]
                       ! rworkspace: need   n [e] + n*n [ru]
                       call stdlib_claset( 'F', m, n, czero, czero, work( iu ),ldwrku )
                       call stdlib_clacp2( 'F', n, n, rwork( iru ), n, work( iu ),ldwrku )
                       call stdlib_cunmbr( 'Q', 'L', 'N', m, n, n, a, lda,work( itauq ), work( iu &
                                 ), ldwrku,work( nwork ), lwork-nwork+1, ierr )
                       call stdlib_clacpy( 'F', m, n, work( iu ), ldwrku, a, lda )
                    else
                       ! path 6o-slow
                       ! generate q in a
                       ! cworkspace: need   2*n [tauq, taup] + n*n [u] + n    [work]
                       ! cworkspace: prefer 2*n [tauq, taup] + n*n [u] + n*nb [work]
                       ! rworkspace: need   0
                       call stdlib_cungbr( 'Q', m, n, n, a, lda, work( itauq ),work( nwork ), &
                                 lwork-nwork+1, ierr )
                       ! multiply q in a by realmatrix rwork(iru,KIND=sp), storing the
                       ! result in work(iu), copying to a
                       ! cworkspace: need   2*n [tauq, taup] + n*n [u]
                       ! cworkspace: prefer 2*n [tauq, taup] + m*n [u]
                       ! rworkspace: need   n [e] + n*n [ru] + 2*n*n [rwork]
                       ! rworkspace: prefer n [e] + n*n [ru] + 2*m*n [rwork] < n + 5*n*n since m < 2*n here
                       nrwork = irvt
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_clacrm( chunk, n, a( i, 1 ), lda,rwork( iru ), n, work( iu )&
                                    , ldwrku,rwork( nrwork ) )
                          call stdlib_clacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    end if
                 else if( wntqs ) then
                    ! path 6s (m >= n, jobz='s')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_sbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_claset( 'F', m, n, czero, czero, u, ldu )
                    call stdlib_clacp2( 'F', n, n, rwork( iru ), n, u, ldu )
                    call stdlib_cunmbr( 'Q', 'L', 'N', m, n, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_clacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                 else
                    ! path 6a (m >= n, jobz='a')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_sbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! set the right corner of u to identity matrix
                    call stdlib_claset( 'F', m, m, czero, czero, u, ldu )
                    if( m>n ) then
                       call stdlib_claset( 'F', m-n, m-n, czero, cone,u( n+1, n+1 ), ldu )
                    end if
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + m*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_clacp2( 'F', n, n, rwork( iru ), n, u, ldu )
                    call stdlib_cunmbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_clacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                 end if
              end if
           else
              ! a has more columns than rows. if a has sufficiently more
              ! columns than rows, first reduce using the lq decomposition (if
              ! sufficient workspace available)
              if( n>=mnthr1 ) then
                 if( wntqn ) then
                    ! path 1t (n >> m, jobz='n')
                    ! no singular vectors to be computed
                    itau = 1
                    nwork = itau + m
                    ! compute a=l*q
                    ! cworkspace: need   m [tau] + m    [work]
                    ! cworkspace: prefer m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! zero out above l
                    if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero, a( 1, 2 ),lda )
                    ie = 1
                    itauq = 1
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in a
                    ! cworkspace: need   2*m [tauq, taup] + m      [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + 2*m*nb [work]
                    ! rworkspace: need   m [e]
                    call stdlib_cgebrd( m, m, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( nwork ), lwork-nwork+1,ierr )
                    nrwork = ie + m
                    ! perform bidiagonal svd, compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + bdspac
                    call stdlib_sbdsdc( 'U', 'N', m, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 2t (n >> m, jobz='o')
                    ! m right singular vectors to be overwritten on a and
                    ! m left singular vectors to be computed in u
                    ivt = 1
                    ldwkvt = m
                    ! work(ivt) is m by m
                    il = ivt + ldwkvt*m
                    if( lwork >= m*n + m*m + 3*m ) then
                       ! work(il) m by n
                       ldwrkl = m
                       chunk = n
                    else
                       ! work(il) is m by chunk
                       ldwrkl = m
                       chunk = ( lwork - m*m - 3*m ) / m
                    end if
                    itau = il + ldwrkl*chunk
                    nwork = itau + m
                    ! compute a=l*q
                    ! cworkspace: need   m*m [vt] + m*m [l] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! copy l to work(il), zeroing about above it
                    call stdlib_clacpy( 'L', m, m, a, lda, work( il ), ldwrkl )
                    call stdlib_claset( 'U', m-1, m-1, czero, czero,work( il+ldwrkl ), ldwrkl )
                              
                    ! generate q in a
                    ! cworkspace: need   m*m [vt] + m*m [l] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cunglq( m, n, m, a, lda, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ie = 1
                    itauq = itau
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in work(il)
                    ! cworkspace: need   m*m [vt] + m*m [l] + 2*m [tauq, taup] + m      [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + 2*m [tauq, taup] + 2*m*nb [work]
                    ! rworkspace: need   m [e]
                    call stdlib_cgebrd( m, m, work( il ), ldwrkl, s, rwork( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [ru] + m*m [rvt] + bdspac
                    iru = ie + m
                    irvt = iru + m*m
                    nrwork = irvt + m*m
                    call stdlib_sbdsdc( 'U', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix work(iu)
                    ! overwrite work(iu) by the left singular vectors of l
                    ! cworkspace: need   m*m [vt] + m*m [l] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_cunmbr( 'Q', 'L', 'N', m, m, m, work( il ), ldwrkl,work( itauq ), &
                              u, ldu, work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix work(ivt)
                    ! overwrite work(ivt) by the right singular vectors of l
                    ! cworkspace: need   m*m [vt] + m*m [l] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', m, m, rwork( irvt ), m, work( ivt ),ldwkvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', m, m, m, work( il ), ldwrkl,work( itaup ), &
                              work( ivt ), ldwkvt,work( nwork ), lwork-nwork+1, ierr )
                    ! multiply right singular vectors of l in work(il) by q
                    ! in a, storing result in work(il) and copying to a
                    ! cworkspace: need   m*m [vt] + m*m [l]
                    ! cworkspace: prefer m*m [vt] + m*n [l]
                    ! rworkspace: need   0
                    do i = 1, n, chunk
                       blk = min( n-i+1, chunk )
                       call stdlib_cgemm( 'N', 'N', m, blk, m, cone, work( ivt ), m,a( 1, i ), &
                                 lda, czero, work( il ),ldwrkl )
                       call stdlib_clacpy( 'F', m, blk, work( il ), ldwrkl,a( 1, i ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 3t (n >> m, jobz='s')
                    ! m right singular vectors to be computed in vt and
                    ! m left singular vectors to be computed in u
                    il = 1
                    ! work(il) is m by m
                    ldwrkl = m
                    itau = il + ldwrkl*m
                    nwork = itau + m
                    ! compute a=l*q
                    ! cworkspace: need   m*m [l] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [l] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! copy l to work(il), zeroing out above it
                    call stdlib_clacpy( 'L', m, m, a, lda, work( il ), ldwrkl )
                    call stdlib_claset( 'U', m-1, m-1, czero, czero,work( il+ldwrkl ), ldwrkl )
                              
                    ! generate q in a
                    ! cworkspace: need   m*m [l] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [l] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cunglq( m, n, m, a, lda, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ie = 1
                    itauq = itau
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in work(il)
                    ! cworkspace: need   m*m [l] + 2*m [tauq, taup] + m      [work]
                    ! cworkspace: prefer m*m [l] + 2*m [tauq, taup] + 2*m*nb [work]
                    ! rworkspace: need   m [e]
                    call stdlib_cgebrd( m, m, work( il ), ldwrkl, s, rwork( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [ru] + m*m [rvt] + bdspac
                    iru = ie + m
                    irvt = iru + m*m
                    nrwork = irvt + m*m
                    call stdlib_sbdsdc( 'U', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix u
                    ! overwrite u by left singular vectors of l
                    ! cworkspace: need   m*m [l] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [l] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_cunmbr( 'Q', 'L', 'N', m, m, m, work( il ), ldwrkl,work( itauq ), &
                              u, ldu, work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix vt
                    ! overwrite vt by left singular vectors of l
                    ! cworkspace: need   m*m [l] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [l] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', m, m, rwork( irvt ), m, vt, ldvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', m, m, m, work( il ), ldwrkl,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork-nwork+1, ierr )
                    ! copy vt to work(il), multiply right singular vectors of l
                    ! in work(il) by q in a, storing result in vt
                    ! cworkspace: need   m*m [l]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'F', m, m, vt, ldvt, work( il ), ldwrkl )
                    call stdlib_cgemm( 'N', 'N', m, n, m, cone, work( il ), ldwrkl,a, lda, czero, &
                              vt, ldvt )
                 else if( wntqa ) then
                    ! path 4t (n >> m, jobz='a')
                    ! n right singular vectors to be computed in vt and
                    ! m left singular vectors to be computed in u
                    ivt = 1
                    ! work(ivt) is m by m
                    ldwkvt = m
                    itau = ivt + ldwkvt*m
                    nwork = itau + m
                    ! compute a=l*q, copying result to vt
                    ! cworkspace: need   m*m [vt] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                    ! generate q in vt
                    ! cworkspace: need   m*m [vt] + m [tau] + n    [work]
                    ! cworkspace: prefer m*m [vt] + m [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cunglq( n, n, m, vt, ldvt, work( itau ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! produce l in a, zeroing out above it
                    if (m>1) call stdlib_claset( 'U', m-1, m-1, czero, czero, a( 1, 2 ),lda )
                    ie = 1
                    itauq = itau
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in a
                    ! cworkspace: need   m*m [vt] + 2*m [tauq, taup] + m      [work]
                    ! cworkspace: prefer m*m [vt] + 2*m [tauq, taup] + 2*m*nb [work]
                    ! rworkspace: need   m [e]
                    call stdlib_cgebrd( m, m, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( nwork ), lwork-nwork+1,ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [ru] + m*m [rvt] + bdspac
                    iru = ie + m
                    irvt = iru + m*m
                    nrwork = irvt + m*m
                    call stdlib_sbdsdc( 'U', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix u
                    ! overwrite u by left singular vectors of l
                    ! cworkspace: need   m*m [vt] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [vt] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_cunmbr( 'Q', 'L', 'N', m, m, m, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix work(ivt)
                    ! overwrite work(ivt) by right singular vectors of l
                    ! cworkspace: need   m*m [vt] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [vt] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacp2( 'F', m, m, rwork( irvt ), m, work( ivt ),ldwkvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', m, m, m, a, lda,work( itaup ), work( ivt ),&
                               ldwkvt,work( nwork ), lwork-nwork+1, ierr )
                    ! multiply right singular vectors of l in work(ivt) by
                    ! q in vt, storing result in a
                    ! cworkspace: need   m*m [vt]
                    ! rworkspace: need   0
                    call stdlib_cgemm( 'N', 'N', m, n, m, cone, work( ivt ), ldwkvt,vt, ldvt, &
                              czero, a, lda )
                    ! copy right singular vectors of a from a to vt
                    call stdlib_clacpy( 'F', m, n, a, lda, vt, ldvt )
                 end if
              else if( n>=mnthr2 ) then
                 ! mnthr2 <= n < mnthr1
                 ! path 5t (n >> m, but not as much as mnthr1)
                 ! reduce to bidiagonal form without qr decomposition, use
                 ! stdlib_cungbr and matrix multiplication to compute singular vectors
                 ie = 1
                 nrwork = ie + m
                 itauq = 1
                 itaup = itauq + m
                 nwork = itaup + m
                 ! bidiagonalize a
                 ! cworkspace: need   2*m [tauq, taup] + n        [work]
                 ! cworkspace: prefer 2*m [tauq, taup] + (m+n)*nb [work]
                 ! rworkspace: need   m [e]
                 call stdlib_cgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 5tn (n >> m, jobz='n')
                    ! compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + bdspac
                    call stdlib_sbdsdc( 'L', 'N', m, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    ivt = nwork
                    ! path 5to (n >> m, jobz='o')
                    ! copy a to u, generate q
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_cungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! generate p**h in a
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_cungbr( 'P', m, n, m, a, lda, work( itaup ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ldwkvt = m
                    if( lwork >= m*n + 3*m ) then
                       ! work( ivt ) is m by n
                       nwork = ivt + ldwkvt*n
                       chunk = n
                    else
                       ! work( ivt ) is m by chunk
                       chunk = ( lwork - 3*m ) / m
                       nwork = ivt + ldwkvt*chunk
                    end if
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    call stdlib_sbdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply q in u by realmatrix rwork(irvt,KIND=sp)
                    ! storing the result in work(ivt), copying to u
                    ! cworkspace: need   2*m [tauq, taup] + m*m [vt]
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + 2*m*m [rwork]
                    call stdlib_clacrm( m, m, u, ldu, rwork( iru ), m, work( ivt ),ldwkvt, rwork( &
                              nrwork ) )
                    call stdlib_clacpy( 'F', m, m, work( ivt ), ldwkvt, u, ldu )
                    ! multiply rwork(irvt) by p**h in a, storing the
                    ! result in work(ivt), copying to a
                    ! cworkspace: need   2*m [tauq, taup] + m*m [vt]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*n [vt]
                    ! rworkspace: need   m [e] + m*m [rvt] + 2*m*m [rwork]
                    ! rworkspace: prefer m [e] + m*m [rvt] + 2*m*n [rwork] < m + 5*m*m since n < 2*m here
                    nrwork = iru
                    do i = 1, n, chunk
                       blk = min( n-i+1, chunk )
                       call stdlib_clarcm( m, blk, rwork( irvt ), m, a( 1, i ), lda,work( ivt ), &
                                 ldwkvt, rwork( nrwork ) )
                       call stdlib_clacpy( 'F', m, blk, work( ivt ), ldwkvt,a( 1, i ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 5ts (n >> m, jobz='s')
                    ! copy a to u, generate q
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_cungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                    call stdlib_cungbr( 'P', m, n, m, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_sbdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply q in u by realmatrix rwork(iru,KIND=sp), storing the
                    ! result in a, copying to u
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + 2*m*m [rwork]
                    call stdlib_clacrm( m, m, u, ldu, rwork( iru ), m, a, lda,rwork( nrwork ) )
                              
                    call stdlib_clacpy( 'F', m, m, a, lda, u, ldu )
                    ! multiply realmatrix rwork(irvt,KIND=sp) by p**h in vt,
                    ! storing the result in a, copying to vt
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + 2*m*n [rwork] < m + 5*m*m since n < 2*m here
                    nrwork = iru
                    call stdlib_clarcm( m, n, rwork( irvt ), m, vt, ldvt, a, lda,rwork( nrwork ) )
                              
                    call stdlib_clacpy( 'F', m, n, a, lda, vt, ldvt )
                 else
                    ! path 5ta (n >> m, jobz='a')
                    ! copy a to u, generate q
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_cungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*m [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_clacpy( 'U', m, n, a, lda, vt, ldvt )
                    call stdlib_cungbr( 'P', n, n, m, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_sbdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply q in u by realmatrix rwork(iru,KIND=sp), storing the
                    ! result in a, copying to u
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + 2*m*m [rwork]
                    call stdlib_clacrm( m, m, u, ldu, rwork( iru ), m, a, lda,rwork( nrwork ) )
                              
                    call stdlib_clacpy( 'F', m, m, a, lda, u, ldu )
                    ! multiply realmatrix rwork(irvt,KIND=sp) by p**h in vt,
                    ! storing the result in a, copying to vt
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + 2*m*n [rwork] < m + 5*m*m since n < 2*m here
                    nrwork = iru
                    call stdlib_clarcm( m, n, rwork( irvt ), m, vt, ldvt, a, lda,rwork( nrwork ) )
                              
                    call stdlib_clacpy( 'F', m, n, a, lda, vt, ldvt )
                 end if
              else
                 ! n < mnthr2
                 ! path 6t (n > m, but not much larger)
                 ! reduce to bidiagonal form without lq decomposition
                 ! use stdlib_cunmbr to compute singular vectors
                 ie = 1
                 nrwork = ie + m
                 itauq = 1
                 itaup = itauq + m
                 nwork = itaup + m
                 ! bidiagonalize a
                 ! cworkspace: need   2*m [tauq, taup] + n        [work]
                 ! cworkspace: prefer 2*m [tauq, taup] + (m+n)*nb [work]
                 ! rworkspace: need   m [e]
                 call stdlib_cgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 6tn (n > m, jobz='n')
                    ! compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + bdspac
                    call stdlib_sbdsdc( 'L', 'N', m, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 6to (n > m, jobz='o')
                    ldwkvt = m
                    ivt = nwork
                    if( lwork >= m*n + 3*m ) then
                       ! work( ivt ) is m by n
                       call stdlib_claset( 'F', m, n, czero, czero, work( ivt ),ldwkvt )
                       nwork = ivt + ldwkvt*n
                    else
                       ! work( ivt ) is m by chunk
                       chunk = ( lwork - 3*m ) / m
                       nwork = ivt + ldwkvt*chunk
                    end if
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_sbdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + m*m [vt] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*m [vt] + m*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru]
                    call stdlib_clacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_cunmbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    if( lwork >= m*n + 3*m ) then
                       ! path 6to-fast
                       ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix work(ivt)
                       ! overwrite work(ivt) by right singular vectors of a,
                       ! copying to a
                       ! cworkspace: need   2*m [tauq, taup] + m*n [vt] + m    [work]
                       ! cworkspace: prefer 2*m [tauq, taup] + m*n [vt] + m*nb [work]
                       ! rworkspace: need   m [e] + m*m [rvt]
                       call stdlib_clacp2( 'F', m, m, rwork( irvt ), m, work( ivt ),ldwkvt )
                                 
                       call stdlib_cunmbr( 'P', 'R', 'C', m, n, m, a, lda,work( itaup ), work( &
                                 ivt ), ldwkvt,work( nwork ), lwork-nwork+1, ierr )
                       call stdlib_clacpy( 'F', m, n, work( ivt ), ldwkvt, a, lda )
                    else
                       ! path 6to-slow
                       ! generate p**h in a
                       ! cworkspace: need   2*m [tauq, taup] + m*m [vt] + m    [work]
                       ! cworkspace: prefer 2*m [tauq, taup] + m*m [vt] + m*nb [work]
                       ! rworkspace: need   0
                       call stdlib_cungbr( 'P', m, n, m, a, lda, work( itaup ),work( nwork ), &
                                 lwork-nwork+1, ierr )
                       ! multiply q in a by realmatrix rwork(iru,KIND=sp), storing the
                       ! result in work(iu), copying to a
                       ! cworkspace: need   2*m [tauq, taup] + m*m [vt]
                       ! cworkspace: prefer 2*m [tauq, taup] + m*n [vt]
                       ! rworkspace: need   m [e] + m*m [rvt] + 2*m*m [rwork]
                       ! rworkspace: prefer m [e] + m*m [rvt] + 2*m*n [rwork] < m + 5*m*m since n < 2*m here
                       nrwork = iru
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_clarcm( m, blk, rwork( irvt ), m, a( 1, i ),lda, work( ivt )&
                                    , ldwkvt,rwork( nrwork ) )
                          call stdlib_clacpy( 'F', m, blk, work( ivt ), ldwkvt,a( 1, i ), lda )
                                    
                       end do
                    end if
                 else if( wntqs ) then
                    ! path 6ts (n > m, jobz='s')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_sbdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru]
                    call stdlib_clacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_cunmbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt]
                    call stdlib_claset( 'F', m, n, czero, czero, vt, ldvt )
                    call stdlib_clacp2( 'F', m, m, rwork( irvt ), m, vt, ldvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', m, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                 else
                    ! path 6ta (n > m, jobz='a')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_sbdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=sp) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru]
                    call stdlib_clacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_cunmbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! set all of vt to identity matrix
                    call stdlib_claset( 'F', n, n, czero, cone, vt, ldvt )
                    ! copy realmatrix rwork(irvt,KIND=sp) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + n*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt]
                    call stdlib_clacp2( 'F', m, m, rwork( irvt ), m, vt, ldvt )
                    call stdlib_cunmbr( 'P', 'R', 'C', n, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                 end if
              end if
           end if
           ! undo scaling if necessary
           if( iscl==1 ) then
              if( anrm>bignum )call stdlib_slascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm>bignum )call stdlib_slascl( 'G', 0, 0, bignum, anrm, minmn-1,&
                         1,rwork( ie ), minmn, ierr )
              if( anrm<smlnum )call stdlib_slascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm<smlnum )call stdlib_slascl( 'G', 0, 0, smlnum, anrm, minmn-1,&
                         1,rwork( ie ), minmn, ierr )
           end if
           ! return optimal workspace in work(1)
           work( 1 ) = stdlib_sroundup_lwork( maxwrk )
           return
     end subroutine stdlib_cgesdd

     module subroutine stdlib_zgesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, rwork, iwork, &
     !! ZGESDD computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, optionally computing the left and/or right singular
     !! vectors, by using divide-and-conquer method. The SVD is written
     !! A = U * SIGMA * conjugate-transpose(V)
     !! where SIGMA is an M-by-N matrix which is zero except for its
     !! min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
     !! V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
     !! are the singular values of A; they are real and non-negative, and
     !! are returned in descending order.  The first min(m,n) columns of
     !! U and V are the left and right singular vectors of A.
     !! Note that the routine returns VT = V**H, not V.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldvt, lwork, m, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(out) :: rwork(*), s(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lquery, wntqa, wntqas, wntqn, wntqo, wntqs
           integer(ilp) :: blk, chunk, i, ie, ierr, il, ir, iru, irvt, iscl, itau, itaup, itauq, &
           iu, ivt, ldwkvt, ldwrkl, ldwrkr, ldwrku, maxwrk, minmn, minwrk, mnthr1, mnthr2, nrwork,&
                      nwork, wrkbl
           integer(ilp) :: lwork_zgebrd_mn, lwork_zgebrd_mm, lwork_zgebrd_nn, lwork_zgelqf_mn, &
           lwork_zgeqrf_mn, lwork_zungbr_p_mn, lwork_zungbr_p_nn, lwork_zungbr_q_mn, &
           lwork_zungbr_q_mm, lwork_zunglq_mn, lwork_zunglq_nn, lwork_zungqr_mm, lwork_zungqr_mn, &
           lwork_zunmbr_prc_mm, lwork_zunmbr_qln_mm, lwork_zunmbr_prc_mn, lwork_zunmbr_qln_mn, &
                     lwork_zunmbr_prc_nn, lwork_zunmbr_qln_nn
           real(dp) :: anrm, bignum, eps, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(dp) :: dum(1)
           complex(dp) :: cdum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info   = 0
           minmn  = min( m, n )
           mnthr1 = int( minmn*17.0_dp / 9.0_dp,KIND=ilp)
           mnthr2 = int( minmn*5.0_dp / 3.0_dp,KIND=ilp)
           wntqa  = stdlib_lsame( jobz, 'A' )
           wntqs  = stdlib_lsame( jobz, 'S' )
           wntqas = wntqa .or. wntqs
           wntqo  = stdlib_lsame( jobz, 'O' )
           wntqn  = stdlib_lsame( jobz, 'N' )
           lquery = ( lwork==-1 )
           minwrk = 1
           maxwrk = 1
           if( .not.( wntqa .or. wntqs .or. wntqo .or. wntqn ) ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldu<1 .or. ( wntqas .and. ldu<m ) .or.( wntqo .and. m<n .and. ldu<m ) ) &
                     then
              info = -8
           else if( ldvt<1 .or. ( wntqa .and. ldvt<n ) .or.( wntqs .and. ldvt<minmn ) .or.( wntqo &
                     .and. m>=n .and. ldvt<n ) ) then
              info = -10
           end if
           ! compute workspace
             ! note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace allocated at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to
             ! real workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              if( m>=n .and. minmn>0 ) then
                 ! there is no complex work space needed for bidiagonal svd
                 ! the realwork space needed for bidiagonal svd (stdlib_dbdsdc,KIND=dp) is
                 ! bdspac = 3*n*n + 4*n for singular values and vectors;
                 ! bdspac = 4*n         for singular values only;
                 ! not including e, ru, and rvt matrices.
                 ! compute space preferred for each routine
                 call stdlib_zgebrd( m, n, cdum(1), m, dum(1), dum(1), cdum(1),cdum(1), cdum(1), -&
                           1, ierr )
                 lwork_zgebrd_mn = int( cdum(1),KIND=ilp)
                 call stdlib_zgebrd( n, n, cdum(1), n, dum(1), dum(1), cdum(1),cdum(1), cdum(1), -&
                           1, ierr )
                 lwork_zgebrd_nn = int( cdum(1),KIND=ilp)
                 call stdlib_zgeqrf( m, n, cdum(1), m, cdum(1), cdum(1), -1, ierr )
                 lwork_zgeqrf_mn = int( cdum(1),KIND=ilp)
                 call stdlib_zungbr( 'P', n, n, n, cdum(1), n, cdum(1), cdum(1),-1, ierr )
                 lwork_zungbr_p_nn = int( cdum(1),KIND=ilp)
                 call stdlib_zungbr( 'Q', m, m, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_zungbr_q_mm = int( cdum(1),KIND=ilp)
                 call stdlib_zungbr( 'Q', m, n, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_zungbr_q_mn = int( cdum(1),KIND=ilp)
                 call stdlib_zungqr( m, m, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_zungqr_mm = int( cdum(1),KIND=ilp)
                 call stdlib_zungqr( m, n, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_zungqr_mn = int( cdum(1),KIND=ilp)
                 call stdlib_zunmbr( 'P', 'R', 'C', n, n, n, cdum(1), n, cdum(1),cdum(1), n, cdum(&
                           1), -1, ierr )
                 lwork_zunmbr_prc_nn = int( cdum(1),KIND=ilp)
                 call stdlib_zunmbr( 'Q', 'L', 'N', m, m, n, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_zunmbr_qln_mm = int( cdum(1),KIND=ilp)
                 call stdlib_zunmbr( 'Q', 'L', 'N', m, n, n, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_zunmbr_qln_mn = int( cdum(1),KIND=ilp)
                 call stdlib_zunmbr( 'Q', 'L', 'N', n, n, n, cdum(1), n, cdum(1),cdum(1), n, cdum(&
                           1), -1, ierr )
                 lwork_zunmbr_qln_nn = int( cdum(1),KIND=ilp)
                 if( m>=mnthr1 ) then
                    if( wntqn ) then
                       ! path 1 (m >> n, jobz='n')
                       maxwrk = n + lwork_zgeqrf_mn
                       maxwrk = max( maxwrk, 2*n + lwork_zgebrd_nn )
                       minwrk = 3*n
                    else if( wntqo ) then
                       ! path 2 (m >> n, jobz='o')
                       wrkbl = n + lwork_zgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_zungqr_mn )
                       wrkbl = max( wrkbl, 2*n + lwork_zgebrd_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_zunmbr_qln_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_zunmbr_prc_nn )
                       maxwrk = m*n + n*n + wrkbl
                       minwrk = 2*n*n + 3*n
                    else if( wntqs ) then
                       ! path 3 (m >> n, jobz='s')
                       wrkbl = n + lwork_zgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_zungqr_mn )
                       wrkbl = max( wrkbl, 2*n + lwork_zgebrd_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_zunmbr_qln_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_zunmbr_prc_nn )
                       maxwrk = n*n + wrkbl
                       minwrk = n*n + 3*n
                    else if( wntqa ) then
                       ! path 4 (m >> n, jobz='a')
                       wrkbl = n + lwork_zgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_zungqr_mm )
                       wrkbl = max( wrkbl, 2*n + lwork_zgebrd_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_zunmbr_qln_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_zunmbr_prc_nn )
                       maxwrk = n*n + wrkbl
                       minwrk = n*n + max( 3*n, n + m )
                    end if
                 else if( m>=mnthr2 ) then
                    ! path 5 (m >> n, but not as much as mnthr1)
                    maxwrk = 2*n + lwork_zgebrd_mn
                    minwrk = 2*n + m
                    if( wntqo ) then
                       ! path 5o (m >> n, jobz='o')
                       maxwrk = max( maxwrk, 2*n + lwork_zungbr_p_nn )
                       maxwrk = max( maxwrk, 2*n + lwork_zungbr_q_mn )
                       maxwrk = maxwrk + m*n
                       minwrk = minwrk + n*n
                    else if( wntqs ) then
                       ! path 5s (m >> n, jobz='s')
                       maxwrk = max( maxwrk, 2*n + lwork_zungbr_p_nn )
                       maxwrk = max( maxwrk, 2*n + lwork_zungbr_q_mn )
                    else if( wntqa ) then
                       ! path 5a (m >> n, jobz='a')
                       maxwrk = max( maxwrk, 2*n + lwork_zungbr_p_nn )
                       maxwrk = max( maxwrk, 2*n + lwork_zungbr_q_mm )
                    end if
                 else
                    ! path 6 (m >= n, but not much larger)
                    maxwrk = 2*n + lwork_zgebrd_mn
                    minwrk = 2*n + m
                    if( wntqo ) then
                       ! path 6o (m >= n, jobz='o')
                       maxwrk = max( maxwrk, 2*n + lwork_zunmbr_prc_nn )
                       maxwrk = max( maxwrk, 2*n + lwork_zunmbr_qln_mn )
                       maxwrk = maxwrk + m*n
                       minwrk = minwrk + n*n
                    else if( wntqs ) then
                       ! path 6s (m >= n, jobz='s')
                       maxwrk = max( maxwrk, 2*n + lwork_zunmbr_qln_mn )
                       maxwrk = max( maxwrk, 2*n + lwork_zunmbr_prc_nn )
                    else if( wntqa ) then
                       ! path 6a (m >= n, jobz='a')
                       maxwrk = max( maxwrk, 2*n + lwork_zunmbr_qln_mm )
                       maxwrk = max( maxwrk, 2*n + lwork_zunmbr_prc_nn )
                    end if
                 end if
              else if( minmn>0 ) then
                 ! there is no complex work space needed for bidiagonal svd
                 ! the realwork space needed for bidiagonal svd (stdlib_dbdsdc,KIND=dp) is
                 ! bdspac = 3*m*m + 4*m for singular values and vectors;
                 ! bdspac = 4*m         for singular values only;
                 ! not including e, ru, and rvt matrices.
                 ! compute space preferred for each routine
                 call stdlib_zgebrd( m, n, cdum(1), m, dum(1), dum(1), cdum(1),cdum(1), cdum(1), -&
                           1, ierr )
                 lwork_zgebrd_mn = int( cdum(1),KIND=ilp)
                 call stdlib_zgebrd( m, m, cdum(1), m, dum(1), dum(1), cdum(1),cdum(1), cdum(1), -&
                           1, ierr )
                 lwork_zgebrd_mm = int( cdum(1),KIND=ilp)
                 call stdlib_zgelqf( m, n, cdum(1), m, cdum(1), cdum(1), -1, ierr )
                 lwork_zgelqf_mn = int( cdum(1),KIND=ilp)
                 call stdlib_zungbr( 'P', m, n, m, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_zungbr_p_mn = int( cdum(1),KIND=ilp)
                 call stdlib_zungbr( 'P', n, n, m, cdum(1), n, cdum(1), cdum(1),-1, ierr )
                 lwork_zungbr_p_nn = int( cdum(1),KIND=ilp)
                 call stdlib_zungbr( 'Q', m, m, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_zungbr_q_mm = int( cdum(1),KIND=ilp)
                 call stdlib_zunglq( m, n, m, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_zunglq_mn = int( cdum(1),KIND=ilp)
                 call stdlib_zunglq( n, n, m, cdum(1), n, cdum(1), cdum(1),-1, ierr )
                 lwork_zunglq_nn = int( cdum(1),KIND=ilp)
                 call stdlib_zunmbr( 'P', 'R', 'C', m, m, m, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_zunmbr_prc_mm = int( cdum(1),KIND=ilp)
                 call stdlib_zunmbr( 'P', 'R', 'C', m, n, m, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_zunmbr_prc_mn = int( cdum(1),KIND=ilp)
                 call stdlib_zunmbr( 'P', 'R', 'C', n, n, m, cdum(1), n, cdum(1),cdum(1), n, cdum(&
                           1), -1, ierr )
                 lwork_zunmbr_prc_nn = int( cdum(1),KIND=ilp)
                 call stdlib_zunmbr( 'Q', 'L', 'N', m, m, m, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_zunmbr_qln_mm = int( cdum(1),KIND=ilp)
                 if( n>=mnthr1 ) then
                    if( wntqn ) then
                       ! path 1t (n >> m, jobz='n')
                       maxwrk = m + lwork_zgelqf_mn
                       maxwrk = max( maxwrk, 2*m + lwork_zgebrd_mm )
                       minwrk = 3*m
                    else if( wntqo ) then
                       ! path 2t (n >> m, jobz='o')
                       wrkbl = m + lwork_zgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_zunglq_mn )
                       wrkbl = max( wrkbl, 2*m + lwork_zgebrd_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_zunmbr_qln_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_zunmbr_prc_mm )
                       maxwrk = m*n + m*m + wrkbl
                       minwrk = 2*m*m + 3*m
                    else if( wntqs ) then
                       ! path 3t (n >> m, jobz='s')
                       wrkbl = m + lwork_zgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_zunglq_mn )
                       wrkbl = max( wrkbl, 2*m + lwork_zgebrd_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_zunmbr_qln_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_zunmbr_prc_mm )
                       maxwrk = m*m + wrkbl
                       minwrk = m*m + 3*m
                    else if( wntqa ) then
                       ! path 4t (n >> m, jobz='a')
                       wrkbl = m + lwork_zgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_zunglq_nn )
                       wrkbl = max( wrkbl, 2*m + lwork_zgebrd_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_zunmbr_qln_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_zunmbr_prc_mm )
                       maxwrk = m*m + wrkbl
                       minwrk = m*m + max( 3*m, m + n )
                    end if
                 else if( n>=mnthr2 ) then
                    ! path 5t (n >> m, but not as much as mnthr1)
                    maxwrk = 2*m + lwork_zgebrd_mn
                    minwrk = 2*m + n
                    if( wntqo ) then
                       ! path 5to (n >> m, jobz='o')
                       maxwrk = max( maxwrk, 2*m + lwork_zungbr_q_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_zungbr_p_mn )
                       maxwrk = maxwrk + m*n
                       minwrk = minwrk + m*m
                    else if( wntqs ) then
                       ! path 5ts (n >> m, jobz='s')
                       maxwrk = max( maxwrk, 2*m + lwork_zungbr_q_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_zungbr_p_mn )
                    else if( wntqa ) then
                       ! path 5ta (n >> m, jobz='a')
                       maxwrk = max( maxwrk, 2*m + lwork_zungbr_q_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_zungbr_p_nn )
                    end if
                 else
                    ! path 6t (n > m, but not much larger)
                    maxwrk = 2*m + lwork_zgebrd_mn
                    minwrk = 2*m + n
                    if( wntqo ) then
                       ! path 6to (n > m, jobz='o')
                       maxwrk = max( maxwrk, 2*m + lwork_zunmbr_qln_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_zunmbr_prc_mn )
                       maxwrk = maxwrk + m*n
                       minwrk = minwrk + m*m
                    else if( wntqs ) then
                       ! path 6ts (n > m, jobz='s')
                       maxwrk = max( maxwrk, 2*m + lwork_zunmbr_qln_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_zunmbr_prc_mn )
                    else if( wntqa ) then
                       ! path 6ta (n > m, jobz='a')
                       maxwrk = max( maxwrk, 2*m + lwork_zunmbr_qln_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_zunmbr_prc_nn )
                    end if
                 end if
              end if
              maxwrk = max( maxwrk, minwrk )
           end if
           if( info==0 ) then
              work( 1 ) = stdlib_droundup_lwork( maxwrk )
              if( lwork<minwrk .and. .not. lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGESDD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = sqrt( stdlib_dlamch( 'S' ) ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_zlange( 'M', m, n, a, lda, dum )
           if( stdlib_disnan( anrm ) ) then
               info = -4
               return
           end if
           iscl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              iscl = 1
              call stdlib_zlascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, ierr )
           else if( anrm>bignum ) then
              iscl = 1
              call stdlib_zlascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, ierr )
           end if
           if( m>=n ) then
              ! a has at least as many rows as columns. if a has sufficiently
              ! more rows than columns, first reduce using the qr
              ! decomposition (if sufficient workspace available)
              if( m>=mnthr1 ) then
                 if( wntqn ) then
                    ! path 1 (m >> n, jobz='n')
                    ! no singular vectors to be computed
                    itau = 1
                    nwork = itau + n
                    ! compute a=q*r
                    ! cworkspace: need   n [tau] + n    [work]
                    ! cworkspace: prefer n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! zero out below r
                    if (n>1) call stdlib_zlaset( 'L', n-1, n-1, czero, czero, a( 2, 1 ),lda )
                    ie = 1
                    itauq = 1
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in a
                    ! cworkspace: need   2*n [tauq, taup] + n      [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + 2*n*nb [work]
                    ! rworkspace: need   n [e]
                    call stdlib_zgebrd( n, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( nwork ), lwork-nwork+1,ierr )
                    nrwork = ie + n
                    ! perform bidiagonal svd, compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + bdspac
                    call stdlib_dbdsdc( 'U', 'N', n, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 2 (m >> n, jobz='o')
                    ! n left singular vectors to be overwritten on a and
                    ! n right singular vectors to be computed in vt
                    iu = 1
                    ! work(iu) is n by n
                    ldwrku = n
                    ir = iu + ldwrku*n
                    if( lwork >= m*n + n*n + 3*n ) then
                       ! work(ir) is m by n
                       ldwrkr = m
                    else
                       ldwrkr = ( lwork - n*n - 3*n ) / n
                    end if
                    itau = ir + ldwrkr*n
                    nwork = itau + n
                    ! compute a=q*r
                    ! cworkspace: need   n*n [u] + n*n [r] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! copy r to work( ir ), zeroing out below it
                    call stdlib_zlacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                    call stdlib_zlaset( 'L', n-1, n-1, czero, czero, work( ir+1 ),ldwrkr )
                    ! generate q in a
                    ! cworkspace: need   n*n [u] + n*n [r] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zungqr( m, n, n, a, lda, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ie = 1
                    itauq = itau
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in work(ir)
                    ! cworkspace: need   n*n [u] + n*n [r] + 2*n [tauq, taup] + n      [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + 2*n [tauq, taup] + 2*n*nb [work]
                    ! rworkspace: need   n [e]
                    call stdlib_zgebrd( n, n, work( ir ), ldwrkr, s, rwork( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of r in work(iru) and computing right singular vectors
                    ! of r in work(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = ie + n
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_dbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=dp) to complex matrix work(iu)
                    ! overwrite work(iu) by the left singular vectors of r
                    ! cworkspace: need   n*n [u] + n*n [r] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacp2( 'F', n, n, rwork( iru ), n, work( iu ),ldwrku )
                    call stdlib_zunmbr( 'Q', 'L', 'N', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                              work( iu ), ldwrku,work( nwork ), lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=dp) to complex matrix vt
                    ! overwrite vt by the right singular vectors of r
                    ! cworkspace: need   n*n [u] + n*n [r] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_zunmbr( 'P', 'R', 'C', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork-nwork+1, ierr )
                    ! multiply q in a by left singular vectors of r in
                    ! work(iu), storing result in work(ir) and copying to a
                    ! cworkspace: need   n*n [u] + n*n [r]
                    ! cworkspace: prefer n*n [u] + m*n [r]
                    ! rworkspace: need   0
                    do i = 1, m, ldwrkr
                       chunk = min( m-i+1, ldwrkr )
                       call stdlib_zgemm( 'N', 'N', chunk, n, n, cone, a( i, 1 ),lda, work( iu ), &
                                 ldwrku, czero,work( ir ), ldwrkr )
                       call stdlib_zlacpy( 'F', chunk, n, work( ir ), ldwrkr,a( i, 1 ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 3 (m >> n, jobz='s')
                    ! n left singular vectors to be computed in u and
                    ! n right singular vectors to be computed in vt
                    ir = 1
                    ! work(ir) is n by n
                    ldwrkr = n
                    itau = ir + ldwrkr*n
                    nwork = itau + n
                    ! compute a=q*r
                    ! cworkspace: need   n*n [r] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [r] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! copy r to work(ir), zeroing out below it
                    call stdlib_zlacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                    call stdlib_zlaset( 'L', n-1, n-1, czero, czero, work( ir+1 ),ldwrkr )
                    ! generate q in a
                    ! cworkspace: need   n*n [r] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [r] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zungqr( m, n, n, a, lda, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ie = 1
                    itauq = itau
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in work(ir)
                    ! cworkspace: need   n*n [r] + 2*n [tauq, taup] + n      [work]
                    ! cworkspace: prefer n*n [r] + 2*n [tauq, taup] + 2*n*nb [work]
                    ! rworkspace: need   n [e]
                    call stdlib_zgebrd( n, n, work( ir ), ldwrkr, s, rwork( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = ie + n
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_dbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=dp) to complex matrix u
                    ! overwrite u by left singular vectors of r
                    ! cworkspace: need   n*n [r] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [r] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacp2( 'F', n, n, rwork( iru ), n, u, ldu )
                    call stdlib_zunmbr( 'Q', 'L', 'N', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                              u, ldu, work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=dp) to complex matrix vt
                    ! overwrite vt by right singular vectors of r
                    ! cworkspace: need   n*n [r] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [r] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_zunmbr( 'P', 'R', 'C', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork-nwork+1, ierr )
                    ! multiply q in a by left singular vectors of r in
                    ! work(ir), storing result in u
                    ! cworkspace: need   n*n [r]
                    ! rworkspace: need   0
                    call stdlib_zlacpy( 'F', n, n, u, ldu, work( ir ), ldwrkr )
                    call stdlib_zgemm( 'N', 'N', m, n, n, cone, a, lda, work( ir ),ldwrkr, czero, &
                              u, ldu )
                 else if( wntqa ) then
                    ! path 4 (m >> n, jobz='a')
                    ! m left singular vectors to be computed in u and
                    ! n right singular vectors to be computed in vt
                    iu = 1
                    ! work(iu) is n by n
                    ldwrku = n
                    itau = iu + ldwrku*n
                    nwork = itau + n
                    ! compute a=q*r, copying result to u
                    ! cworkspace: need   n*n [u] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [u] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zgeqrf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    call stdlib_zlacpy( 'L', m, n, a, lda, u, ldu )
                    ! generate q in u
                    ! cworkspace: need   n*n [u] + n [tau] + m    [work]
                    ! cworkspace: prefer n*n [u] + n [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zungqr( m, m, n, u, ldu, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ! produce r in a, zeroing out below it
                    if (n>1) call stdlib_zlaset( 'L', n-1, n-1, czero, czero, a( 2, 1 ),lda )
                    ie = 1
                    itauq = itau
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in a
                    ! cworkspace: need   n*n [u] + 2*n [tauq, taup] + n      [work]
                    ! cworkspace: prefer n*n [u] + 2*n [tauq, taup] + 2*n*nb [work]
                    ! rworkspace: need   n [e]
                    call stdlib_zgebrd( n, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( nwork ), lwork-nwork+1,ierr )
                    iru = ie + n
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    call stdlib_dbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=dp) to complex matrix work(iu)
                    ! overwrite work(iu) by left singular vectors of r
                    ! cworkspace: need   n*n [u] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [u] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacp2( 'F', n, n, rwork( iru ), n, work( iu ),ldwrku )
                    call stdlib_zunmbr( 'Q', 'L', 'N', n, n, n, a, lda,work( itauq ), work( iu ), &
                              ldwrku,work( nwork ), lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=dp) to complex matrix vt
                    ! overwrite vt by right singular vectors of r
                    ! cworkspace: need   n*n [u] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [u] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_zunmbr( 'P', 'R', 'C', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! multiply q in u by left singular vectors of r in
                    ! work(iu), storing result in a
                    ! cworkspace: need   n*n [u]
                    ! rworkspace: need   0
                    call stdlib_zgemm( 'N', 'N', m, n, n, cone, u, ldu, work( iu ),ldwrku, czero, &
                              a, lda )
                    ! copy left singular vectors of a from a to u
                    call stdlib_zlacpy( 'F', m, n, a, lda, u, ldu )
                 end if
              else if( m>=mnthr2 ) then
                 ! mnthr2 <= m < mnthr1
                 ! path 5 (m >> n, but not as much as mnthr1)
                 ! reduce to bidiagonal form without qr decomposition, use
                 ! stdlib_zungbr and matrix multiplication to compute singular vectors
                 ie = 1
                 nrwork = ie + n
                 itauq = 1
                 itaup = itauq + n
                 nwork = itaup + n
                 ! bidiagonalize a
                 ! cworkspace: need   2*n [tauq, taup] + m        [work]
                 ! cworkspace: prefer 2*n [tauq, taup] + (m+n)*nb [work]
                 ! rworkspace: need   n [e]
                 call stdlib_zgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 5n (m >> n, jobz='n')
                    ! compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + bdspac
                    call stdlib_dbdsdc( 'U', 'N', n, s, rwork( ie ), dum, 1,dum,1,dum, idum, &
                              rwork( nrwork ), iwork, info )
                 else if( wntqo ) then
                    iu = nwork
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    ! path 5o (m >> n, jobz='o')
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_zungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! generate q in a
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zungbr( 'Q', m, n, n, a, lda, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    if( lwork >= m*n + 3*n ) then
                       ! work( iu ) is m by n
                       ldwrku = m
                    else
                       ! work(iu) is ldwrku by n
                       ldwrku = ( lwork - 3*n ) / n
                    end if
                    nwork = iu + ldwrku*n
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    call stdlib_dbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply realmatrix rwork(irvt,KIND=dp) by p**h in vt,
                    ! storing the result in work(iu), copying to vt
                    ! cworkspace: need   2*n [tauq, taup] + n*n [u]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + 2*n*n [rwork]
                    call stdlib_zlarcm( n, n, rwork( irvt ), n, vt, ldvt,work( iu ), ldwrku, &
                              rwork( nrwork ) )
                    call stdlib_zlacpy( 'F', n, n, work( iu ), ldwrku, vt, ldvt )
                    ! multiply q in a by realmatrix rwork(iru,KIND=dp), storing the
                    ! result in work(iu), copying to a
                    ! cworkspace: need   2*n [tauq, taup] + n*n [u]
                    ! cworkspace: prefer 2*n [tauq, taup] + m*n [u]
                    ! rworkspace: need   n [e] + n*n [ru] + 2*n*n [rwork]
                    ! rworkspace: prefer n [e] + n*n [ru] + 2*m*n [rwork] < n + 5*n*n since m < 2*n here
                    nrwork = irvt
                    do i = 1, m, ldwrku
                       chunk = min( m-i+1, ldwrku )
                       call stdlib_zlacrm( chunk, n, a( i, 1 ), lda, rwork( iru ),n, work( iu ), &
                                 ldwrku, rwork( nrwork ) )
                       call stdlib_zlacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 5s (m >> n, jobz='s')
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_zungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! copy a to u, generate q
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacpy( 'L', m, n, a, lda, u, ldu )
                    call stdlib_zungbr( 'Q', m, n, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_dbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply realmatrix rwork(irvt,KIND=dp) by p**h in vt,
                    ! storing the result in a, copying to vt
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + 2*n*n [rwork]
                    call stdlib_zlarcm( n, n, rwork( irvt ), n, vt, ldvt, a, lda,rwork( nrwork ) )
                              
                    call stdlib_zlacpy( 'F', n, n, a, lda, vt, ldvt )
                    ! multiply q in u by realmatrix rwork(iru,KIND=dp), storing the
                    ! result in a, copying to u
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + 2*m*n [rwork] < n + 5*n*n since m < 2*n here
                    nrwork = irvt
                    call stdlib_zlacrm( m, n, u, ldu, rwork( iru ), n, a, lda,rwork( nrwork ) )
                              
                    call stdlib_zlacpy( 'F', m, n, a, lda, u, ldu )
                 else
                    ! path 5a (m >> n, jobz='a')
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_zungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! copy a to u, generate q
                    ! cworkspace: need   2*n [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacpy( 'L', m, n, a, lda, u, ldu )
                    call stdlib_zungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_dbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply realmatrix rwork(irvt,KIND=dp) by p**h in vt,
                    ! storing the result in a, copying to vt
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + 2*n*n [rwork]
                    call stdlib_zlarcm( n, n, rwork( irvt ), n, vt, ldvt, a, lda,rwork( nrwork ) )
                              
                    call stdlib_zlacpy( 'F', n, n, a, lda, vt, ldvt )
                    ! multiply q in u by realmatrix rwork(iru,KIND=dp), storing the
                    ! result in a, copying to u
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + 2*m*n [rwork] < n + 5*n*n since m < 2*n here
                    nrwork = irvt
                    call stdlib_zlacrm( m, n, u, ldu, rwork( iru ), n, a, lda,rwork( nrwork ) )
                              
                    call stdlib_zlacpy( 'F', m, n, a, lda, u, ldu )
                 end if
              else
                 ! m < mnthr2
                 ! path 6 (m >= n, but not much larger)
                 ! reduce to bidiagonal form without qr decomposition
                 ! use stdlib_zunmbr to compute singular vectors
                 ie = 1
                 nrwork = ie + n
                 itauq = 1
                 itaup = itauq + n
                 nwork = itaup + n
                 ! bidiagonalize a
                 ! cworkspace: need   2*n [tauq, taup] + m        [work]
                 ! cworkspace: prefer 2*n [tauq, taup] + (m+n)*nb [work]
                 ! rworkspace: need   n [e]
                 call stdlib_zgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 6n (m >= n, jobz='n')
                    ! compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + bdspac
                    call stdlib_dbdsdc( 'U', 'N', n, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    iu = nwork
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    if( lwork >= m*n + 3*n ) then
                       ! work( iu ) is m by n
                       ldwrku = m
                    else
                       ! work( iu ) is ldwrku by n
                       ldwrku = ( lwork - 3*n ) / n
                    end if
                    nwork = iu + ldwrku*n
                    ! path 6o (m >= n, jobz='o')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    call stdlib_dbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(irvt,KIND=dp) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + n*n [u] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*n [u] + n*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_zlacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_zunmbr( 'P', 'R', 'C', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                    if( lwork >= m*n + 3*n ) then
                       ! path 6o-fast
                       ! copy realmatrix rwork(iru,KIND=dp) to complex matrix work(iu)
                       ! overwrite work(iu) by left singular vectors of a, copying
                       ! to a
                       ! cworkspace: need   2*n [tauq, taup] + m*n [u] + n    [work]
                       ! cworkspace: prefer 2*n [tauq, taup] + m*n [u] + n*nb [work]
                       ! rworkspace: need   n [e] + n*n [ru]
                       call stdlib_zlaset( 'F', m, n, czero, czero, work( iu ),ldwrku )
                       call stdlib_zlacp2( 'F', n, n, rwork( iru ), n, work( iu ),ldwrku )
                       call stdlib_zunmbr( 'Q', 'L', 'N', m, n, n, a, lda,work( itauq ), work( iu &
                                 ), ldwrku,work( nwork ), lwork-nwork+1, ierr )
                       call stdlib_zlacpy( 'F', m, n, work( iu ), ldwrku, a, lda )
                    else
                       ! path 6o-slow
                       ! generate q in a
                       ! cworkspace: need   2*n [tauq, taup] + n*n [u] + n    [work]
                       ! cworkspace: prefer 2*n [tauq, taup] + n*n [u] + n*nb [work]
                       ! rworkspace: need   0
                       call stdlib_zungbr( 'Q', m, n, n, a, lda, work( itauq ),work( nwork ), &
                                 lwork-nwork+1, ierr )
                       ! multiply q in a by realmatrix rwork(iru,KIND=dp), storing the
                       ! result in work(iu), copying to a
                       ! cworkspace: need   2*n [tauq, taup] + n*n [u]
                       ! cworkspace: prefer 2*n [tauq, taup] + m*n [u]
                       ! rworkspace: need   n [e] + n*n [ru] + 2*n*n [rwork]
                       ! rworkspace: prefer n [e] + n*n [ru] + 2*m*n [rwork] < n + 5*n*n since m < 2*n here
                       nrwork = irvt
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_zlacrm( chunk, n, a( i, 1 ), lda,rwork( iru ), n, work( iu )&
                                    , ldwrku,rwork( nrwork ) )
                          call stdlib_zlacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    end if
                 else if( wntqs ) then
                    ! path 6s (m >= n, jobz='s')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_dbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=dp) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_zlaset( 'F', m, n, czero, czero, u, ldu )
                    call stdlib_zlacp2( 'F', n, n, rwork( iru ), n, u, ldu )
                    call stdlib_zunmbr( 'Q', 'L', 'N', m, n, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=dp) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_zlacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_zunmbr( 'P', 'R', 'C', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                 else
                    ! path 6a (m >= n, jobz='a')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_dbdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! set the right corner of u to identity matrix
                    call stdlib_zlaset( 'F', m, m, czero, czero, u, ldu )
                    if( m>n ) then
                       call stdlib_zlaset( 'F', m-n, m-n, czero, cone,u( n+1, n+1 ), ldu )
                    end if
                    ! copy realmatrix rwork(iru,KIND=dp) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + m*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_zlacp2( 'F', n, n, rwork( iru ), n, u, ldu )
                    call stdlib_zunmbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=dp) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_zlacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_zunmbr( 'P', 'R', 'C', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                 end if
              end if
           else
              ! a has more columns than rows. if a has sufficiently more
              ! columns than rows, first reduce using the lq decomposition (if
              ! sufficient workspace available)
              if( n>=mnthr1 ) then
                 if( wntqn ) then
                    ! path 1t (n >> m, jobz='n')
                    ! no singular vectors to be computed
                    itau = 1
                    nwork = itau + m
                    ! compute a=l*q
                    ! cworkspace: need   m [tau] + m    [work]
                    ! cworkspace: prefer m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! zero out above l
                    if (m>1) call stdlib_zlaset( 'U', m-1, m-1, czero, czero, a( 1, 2 ),lda )
                    ie = 1
                    itauq = 1
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in a
                    ! cworkspace: need   2*m [tauq, taup] + m      [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + 2*m*nb [work]
                    ! rworkspace: need   m [e]
                    call stdlib_zgebrd( m, m, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( nwork ), lwork-nwork+1,ierr )
                    nrwork = ie + m
                    ! perform bidiagonal svd, compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + bdspac
                    call stdlib_dbdsdc( 'U', 'N', m, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 2t (n >> m, jobz='o')
                    ! m right singular vectors to be overwritten on a and
                    ! m left singular vectors to be computed in u
                    ivt = 1
                    ldwkvt = m
                    ! work(ivt) is m by m
                    il = ivt + ldwkvt*m
                    if( lwork >= m*n + m*m + 3*m ) then
                       ! work(il) m by n
                       ldwrkl = m
                       chunk = n
                    else
                       ! work(il) is m by chunk
                       ldwrkl = m
                       chunk = ( lwork - m*m - 3*m ) / m
                    end if
                    itau = il + ldwrkl*chunk
                    nwork = itau + m
                    ! compute a=l*q
                    ! cworkspace: need   m*m [vt] + m*m [l] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! copy l to work(il), zeroing about above it
                    call stdlib_zlacpy( 'L', m, m, a, lda, work( il ), ldwrkl )
                    call stdlib_zlaset( 'U', m-1, m-1, czero, czero,work( il+ldwrkl ), ldwrkl )
                              
                    ! generate q in a
                    ! cworkspace: need   m*m [vt] + m*m [l] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zunglq( m, n, m, a, lda, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ie = 1
                    itauq = itau
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in work(il)
                    ! cworkspace: need   m*m [vt] + m*m [l] + 2*m [tauq, taup] + m      [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + 2*m [tauq, taup] + 2*m*nb [work]
                    ! rworkspace: need   m [e]
                    call stdlib_zgebrd( m, m, work( il ), ldwrkl, s, rwork( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [ru] + m*m [rvt] + bdspac
                    iru = ie + m
                    irvt = iru + m*m
                    nrwork = irvt + m*m
                    call stdlib_dbdsdc( 'U', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=dp) to complex matrix work(iu)
                    ! overwrite work(iu) by the left singular vectors of l
                    ! cworkspace: need   m*m [vt] + m*m [l] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_zunmbr( 'Q', 'L', 'N', m, m, m, work( il ), ldwrkl,work( itauq ), &
                              u, ldu, work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=dp) to complex matrix work(ivt)
                    ! overwrite work(ivt) by the right singular vectors of l
                    ! cworkspace: need   m*m [vt] + m*m [l] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacp2( 'F', m, m, rwork( irvt ), m, work( ivt ),ldwkvt )
                    call stdlib_zunmbr( 'P', 'R', 'C', m, m, m, work( il ), ldwrkl,work( itaup ), &
                              work( ivt ), ldwkvt,work( nwork ), lwork-nwork+1, ierr )
                    ! multiply right singular vectors of l in work(il) by q
                    ! in a, storing result in work(il) and copying to a
                    ! cworkspace: need   m*m [vt] + m*m [l]
                    ! cworkspace: prefer m*m [vt] + m*n [l]
                    ! rworkspace: need   0
                    do i = 1, n, chunk
                       blk = min( n-i+1, chunk )
                       call stdlib_zgemm( 'N', 'N', m, blk, m, cone, work( ivt ), m,a( 1, i ), &
                                 lda, czero, work( il ),ldwrkl )
                       call stdlib_zlacpy( 'F', m, blk, work( il ), ldwrkl,a( 1, i ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 3t (n >> m, jobz='s')
                    ! m right singular vectors to be computed in vt and
                    ! m left singular vectors to be computed in u
                    il = 1
                    ! work(il) is m by m
                    ldwrkl = m
                    itau = il + ldwrkl*m
                    nwork = itau + m
                    ! compute a=l*q
                    ! cworkspace: need   m*m [l] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [l] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! copy l to work(il), zeroing out above it
                    call stdlib_zlacpy( 'L', m, m, a, lda, work( il ), ldwrkl )
                    call stdlib_zlaset( 'U', m-1, m-1, czero, czero,work( il+ldwrkl ), ldwrkl )
                              
                    ! generate q in a
                    ! cworkspace: need   m*m [l] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [l] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zunglq( m, n, m, a, lda, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ie = 1
                    itauq = itau
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in work(il)
                    ! cworkspace: need   m*m [l] + 2*m [tauq, taup] + m      [work]
                    ! cworkspace: prefer m*m [l] + 2*m [tauq, taup] + 2*m*nb [work]
                    ! rworkspace: need   m [e]
                    call stdlib_zgebrd( m, m, work( il ), ldwrkl, s, rwork( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [ru] + m*m [rvt] + bdspac
                    iru = ie + m
                    irvt = iru + m*m
                    nrwork = irvt + m*m
                    call stdlib_dbdsdc( 'U', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=dp) to complex matrix u
                    ! overwrite u by left singular vectors of l
                    ! cworkspace: need   m*m [l] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [l] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_zunmbr( 'Q', 'L', 'N', m, m, m, work( il ), ldwrkl,work( itauq ), &
                              u, ldu, work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=dp) to complex matrix vt
                    ! overwrite vt by left singular vectors of l
                    ! cworkspace: need   m*m [l] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [l] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacp2( 'F', m, m, rwork( irvt ), m, vt, ldvt )
                    call stdlib_zunmbr( 'P', 'R', 'C', m, m, m, work( il ), ldwrkl,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork-nwork+1, ierr )
                    ! copy vt to work(il), multiply right singular vectors of l
                    ! in work(il) by q in a, storing result in vt
                    ! cworkspace: need   m*m [l]
                    ! rworkspace: need   0
                    call stdlib_zlacpy( 'F', m, m, vt, ldvt, work( il ), ldwrkl )
                    call stdlib_zgemm( 'N', 'N', m, n, m, cone, work( il ), ldwrkl,a, lda, czero, &
                              vt, ldvt )
                 else if( wntqa ) then
                    ! path 4t (n >> m, jobz='a')
                    ! n right singular vectors to be computed in vt and
                    ! m left singular vectors to be computed in u
                    ivt = 1
                    ! work(ivt) is m by m
                    ldwkvt = m
                    itau = ivt + ldwkvt*m
                    nwork = itau + m
                    ! compute a=l*q, copying result to vt
                    ! cworkspace: need   m*m [vt] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zgelqf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    call stdlib_zlacpy( 'U', m, n, a, lda, vt, ldvt )
                    ! generate q in vt
                    ! cworkspace: need   m*m [vt] + m [tau] + n    [work]
                    ! cworkspace: prefer m*m [vt] + m [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zunglq( n, n, m, vt, ldvt, work( itau ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! produce l in a, zeroing out above it
                    if (m>1) call stdlib_zlaset( 'U', m-1, m-1, czero, czero, a( 1, 2 ),lda )
                    ie = 1
                    itauq = itau
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in a
                    ! cworkspace: need   m*m [vt] + 2*m [tauq, taup] + m      [work]
                    ! cworkspace: prefer m*m [vt] + 2*m [tauq, taup] + 2*m*nb [work]
                    ! rworkspace: need   m [e]
                    call stdlib_zgebrd( m, m, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( nwork ), lwork-nwork+1,ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [ru] + m*m [rvt] + bdspac
                    iru = ie + m
                    irvt = iru + m*m
                    nrwork = irvt + m*m
                    call stdlib_dbdsdc( 'U', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=dp) to complex matrix u
                    ! overwrite u by left singular vectors of l
                    ! cworkspace: need   m*m [vt] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [vt] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_zunmbr( 'Q', 'L', 'N', m, m, m, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=dp) to complex matrix work(ivt)
                    ! overwrite work(ivt) by right singular vectors of l
                    ! cworkspace: need   m*m [vt] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [vt] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacp2( 'F', m, m, rwork( irvt ), m, work( ivt ),ldwkvt )
                    call stdlib_zunmbr( 'P', 'R', 'C', m, m, m, a, lda,work( itaup ), work( ivt ),&
                               ldwkvt,work( nwork ), lwork-nwork+1, ierr )
                    ! multiply right singular vectors of l in work(ivt) by
                    ! q in vt, storing result in a
                    ! cworkspace: need   m*m [vt]
                    ! rworkspace: need   0
                    call stdlib_zgemm( 'N', 'N', m, n, m, cone, work( ivt ), ldwkvt,vt, ldvt, &
                              czero, a, lda )
                    ! copy right singular vectors of a from a to vt
                    call stdlib_zlacpy( 'F', m, n, a, lda, vt, ldvt )
                 end if
              else if( n>=mnthr2 ) then
                 ! mnthr2 <= n < mnthr1
                 ! path 5t (n >> m, but not as much as mnthr1)
                 ! reduce to bidiagonal form without qr decomposition, use
                 ! stdlib_zungbr and matrix multiplication to compute singular vectors
                 ie = 1
                 nrwork = ie + m
                 itauq = 1
                 itaup = itauq + m
                 nwork = itaup + m
                 ! bidiagonalize a
                 ! cworkspace: need   2*m [tauq, taup] + n        [work]
                 ! cworkspace: prefer 2*m [tauq, taup] + (m+n)*nb [work]
                 ! rworkspace: need   m [e]
                 call stdlib_zgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 5tn (n >> m, jobz='n')
                    ! compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + bdspac
                    call stdlib_dbdsdc( 'L', 'N', m, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    ivt = nwork
                    ! path 5to (n >> m, jobz='o')
                    ! copy a to u, generate q
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_zungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! generate p**h in a
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zungbr( 'P', m, n, m, a, lda, work( itaup ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ldwkvt = m
                    if( lwork >= m*n + 3*m ) then
                       ! work( ivt ) is m by n
                       nwork = ivt + ldwkvt*n
                       chunk = n
                    else
                       ! work( ivt ) is m by chunk
                       chunk = ( lwork - 3*m ) / m
                       nwork = ivt + ldwkvt*chunk
                    end if
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    call stdlib_dbdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply q in u by realmatrix rwork(irvt,KIND=dp)
                    ! storing the result in work(ivt), copying to u
                    ! cworkspace: need   2*m [tauq, taup] + m*m [vt]
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + 2*m*m [rwork]
                    call stdlib_zlacrm( m, m, u, ldu, rwork( iru ), m, work( ivt ),ldwkvt, rwork( &
                              nrwork ) )
                    call stdlib_zlacpy( 'F', m, m, work( ivt ), ldwkvt, u, ldu )
                    ! multiply rwork(irvt) by p**h in a, storing the
                    ! result in work(ivt), copying to a
                    ! cworkspace: need   2*m [tauq, taup] + m*m [vt]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*n [vt]
                    ! rworkspace: need   m [e] + m*m [rvt] + 2*m*m [rwork]
                    ! rworkspace: prefer m [e] + m*m [rvt] + 2*m*n [rwork] < m + 5*m*m since n < 2*m here
                    nrwork = iru
                    do i = 1, n, chunk
                       blk = min( n-i+1, chunk )
                       call stdlib_zlarcm( m, blk, rwork( irvt ), m, a( 1, i ), lda,work( ivt ), &
                                 ldwkvt, rwork( nrwork ) )
                       call stdlib_zlacpy( 'F', m, blk, work( ivt ), ldwkvt,a( 1, i ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 5ts (n >> m, jobz='s')
                    ! copy a to u, generate q
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_zungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacpy( 'U', m, n, a, lda, vt, ldvt )
                    call stdlib_zungbr( 'P', m, n, m, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_dbdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply q in u by realmatrix rwork(iru,KIND=dp), storing the
                    ! result in a, copying to u
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + 2*m*m [rwork]
                    call stdlib_zlacrm( m, m, u, ldu, rwork( iru ), m, a, lda,rwork( nrwork ) )
                              
                    call stdlib_zlacpy( 'F', m, m, a, lda, u, ldu )
                    ! multiply realmatrix rwork(irvt,KIND=dp) by p**h in vt,
                    ! storing the result in a, copying to vt
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + 2*m*n [rwork] < m + 5*m*m since n < 2*m here
                    nrwork = iru
                    call stdlib_zlarcm( m, n, rwork( irvt ), m, vt, ldvt, a, lda,rwork( nrwork ) )
                              
                    call stdlib_zlacpy( 'F', m, n, a, lda, vt, ldvt )
                 else
                    ! path 5ta (n >> m, jobz='a')
                    ! copy a to u, generate q
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_zungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*m [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_zlacpy( 'U', m, n, a, lda, vt, ldvt )
                    call stdlib_zungbr( 'P', n, n, m, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_dbdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply q in u by realmatrix rwork(iru,KIND=dp), storing the
                    ! result in a, copying to u
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + 2*m*m [rwork]
                    call stdlib_zlacrm( m, m, u, ldu, rwork( iru ), m, a, lda,rwork( nrwork ) )
                              
                    call stdlib_zlacpy( 'F', m, m, a, lda, u, ldu )
                    ! multiply realmatrix rwork(irvt,KIND=dp) by p**h in vt,
                    ! storing the result in a, copying to vt
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + 2*m*n [rwork] < m + 5*m*m since n < 2*m here
                    nrwork = iru
                    call stdlib_zlarcm( m, n, rwork( irvt ), m, vt, ldvt, a, lda,rwork( nrwork ) )
                              
                    call stdlib_zlacpy( 'F', m, n, a, lda, vt, ldvt )
                 end if
              else
                 ! n < mnthr2
                 ! path 6t (n > m, but not much larger)
                 ! reduce to bidiagonal form without lq decomposition
                 ! use stdlib_zunmbr to compute singular vectors
                 ie = 1
                 nrwork = ie + m
                 itauq = 1
                 itaup = itauq + m
                 nwork = itaup + m
                 ! bidiagonalize a
                 ! cworkspace: need   2*m [tauq, taup] + n        [work]
                 ! cworkspace: prefer 2*m [tauq, taup] + (m+n)*nb [work]
                 ! rworkspace: need   m [e]
                 call stdlib_zgebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 6tn (n > m, jobz='n')
                    ! compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + bdspac
                    call stdlib_dbdsdc( 'L', 'N', m, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 6to (n > m, jobz='o')
                    ldwkvt = m
                    ivt = nwork
                    if( lwork >= m*n + 3*m ) then
                       ! work( ivt ) is m by n
                       call stdlib_zlaset( 'F', m, n, czero, czero, work( ivt ),ldwkvt )
                       nwork = ivt + ldwkvt*n
                    else
                       ! work( ivt ) is m by chunk
                       chunk = ( lwork - 3*m ) / m
                       nwork = ivt + ldwkvt*chunk
                    end if
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_dbdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=dp) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + m*m [vt] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*m [vt] + m*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru]
                    call stdlib_zlacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_zunmbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    if( lwork >= m*n + 3*m ) then
                       ! path 6to-fast
                       ! copy realmatrix rwork(irvt,KIND=dp) to complex matrix work(ivt)
                       ! overwrite work(ivt) by right singular vectors of a,
                       ! copying to a
                       ! cworkspace: need   2*m [tauq, taup] + m*n [vt] + m    [work]
                       ! cworkspace: prefer 2*m [tauq, taup] + m*n [vt] + m*nb [work]
                       ! rworkspace: need   m [e] + m*m [rvt]
                       call stdlib_zlacp2( 'F', m, m, rwork( irvt ), m, work( ivt ),ldwkvt )
                                 
                       call stdlib_zunmbr( 'P', 'R', 'C', m, n, m, a, lda,work( itaup ), work( &
                                 ivt ), ldwkvt,work( nwork ), lwork-nwork+1, ierr )
                       call stdlib_zlacpy( 'F', m, n, work( ivt ), ldwkvt, a, lda )
                    else
                       ! path 6to-slow
                       ! generate p**h in a
                       ! cworkspace: need   2*m [tauq, taup] + m*m [vt] + m    [work]
                       ! cworkspace: prefer 2*m [tauq, taup] + m*m [vt] + m*nb [work]
                       ! rworkspace: need   0
                       call stdlib_zungbr( 'P', m, n, m, a, lda, work( itaup ),work( nwork ), &
                                 lwork-nwork+1, ierr )
                       ! multiply q in a by realmatrix rwork(iru,KIND=dp), storing the
                       ! result in work(iu), copying to a
                       ! cworkspace: need   2*m [tauq, taup] + m*m [vt]
                       ! cworkspace: prefer 2*m [tauq, taup] + m*n [vt]
                       ! rworkspace: need   m [e] + m*m [rvt] + 2*m*m [rwork]
                       ! rworkspace: prefer m [e] + m*m [rvt] + 2*m*n [rwork] < m + 5*m*m since n < 2*m here
                       nrwork = iru
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_zlarcm( m, blk, rwork( irvt ), m, a( 1, i ),lda, work( ivt )&
                                    , ldwkvt,rwork( nrwork ) )
                          call stdlib_zlacpy( 'F', m, blk, work( ivt ), ldwkvt,a( 1, i ), lda )
                                    
                       end do
                    end if
                 else if( wntqs ) then
                    ! path 6ts (n > m, jobz='s')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_dbdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=dp) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru]
                    call stdlib_zlacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_zunmbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=dp) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt]
                    call stdlib_zlaset( 'F', m, n, czero, czero, vt, ldvt )
                    call stdlib_zlacp2( 'F', m, m, rwork( irvt ), m, vt, ldvt )
                    call stdlib_zunmbr( 'P', 'R', 'C', m, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                 else
                    ! path 6ta (n > m, jobz='a')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_dbdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=dp) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru]
                    call stdlib_zlacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_zunmbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! set all of vt to identity matrix
                    call stdlib_zlaset( 'F', n, n, czero, cone, vt, ldvt )
                    ! copy realmatrix rwork(irvt,KIND=dp) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + n*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt]
                    call stdlib_zlacp2( 'F', m, m, rwork( irvt ), m, vt, ldvt )
                    call stdlib_zunmbr( 'P', 'R', 'C', n, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                 end if
              end if
           end if
           ! undo scaling if necessary
           if( iscl==1 ) then
              if( anrm>bignum )call stdlib_dlascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm>bignum )call stdlib_dlascl( 'G', 0, 0, bignum, anrm, minmn-1,&
                         1,rwork( ie ), minmn, ierr )
              if( anrm<smlnum )call stdlib_dlascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm<smlnum )call stdlib_dlascl( 'G', 0, 0, smlnum, anrm, minmn-1,&
                         1,rwork( ie ), minmn, ierr )
           end if
           ! return optimal workspace in work(1)
           work( 1 ) = stdlib_droundup_lwork( maxwrk )
           return
     end subroutine stdlib_zgesdd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$gesdd( jobz, m, n, a, lda, s, u, ldu, vt, ldvt,work, lwork, rwork, iwork, &
     !! ZGESDD: computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, optionally computing the left and/or right singular
     !! vectors, by using divide-and-conquer method. The SVD is written
     !! A = U * SIGMA * conjugate-transpose(V)
     !! where SIGMA is an M-by-N matrix which is zero except for its
     !! min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
     !! V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
     !! are the singular values of A; they are real and non-negative, and
     !! are returned in descending order.  The first min(m,n) columns of
     !! U and V are the left and right singular vectors of A.
     !! Note that the routine returns VT = V**H, not V.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldvt, lwork, m, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: rwork(*), s(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lquery, wntqa, wntqas, wntqn, wntqo, wntqs
           integer(ilp) :: blk, chunk, i, ie, ierr, il, ir, iru, irvt, iscl, itau, itaup, itauq, &
           iu, ivt, ldwkvt, ldwrkl, ldwrkr, ldwrku, maxwrk, minmn, minwrk, mnthr1, mnthr2, nrwork,&
                      nwork, wrkbl
           integer(ilp) :: lwork_wgebrd_mn, lwork_wgebrd_mm, lwork_wgebrd_nn, lwork_wgelqf_mn, &
           lwork_wgeqrf_mn, lwork_wungbr_p_mn, lwork_wungbr_p_nn, lwork_wungbr_q_mn, &
           lwork_wungbr_q_mm, lwork_wunglq_mn, lwork_wunglq_nn, lwork_wungqr_mm, lwork_wungqr_mn, &
           lwork_wunmbr_prc_mm, lwork_wunmbr_qln_mm, lwork_wunmbr_prc_mn, lwork_wunmbr_qln_mn, &
                     lwork_wunmbr_prc_nn, lwork_wunmbr_qln_nn
           real(${ck}$) :: anrm, bignum, eps, smlnum
           ! Local Arrays 
           integer(ilp) :: idum(1)
           real(${ck}$) :: dum(1)
           complex(${ck}$) :: cdum(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info   = 0
           minmn  = min( m, n )
           mnthr1 = int( minmn*17.0_${ck}$ / 9.0_${ck}$,KIND=ilp)
           mnthr2 = int( minmn*5.0_${ck}$ / 3.0_${ck}$,KIND=ilp)
           wntqa  = stdlib_lsame( jobz, 'A' )
           wntqs  = stdlib_lsame( jobz, 'S' )
           wntqas = wntqa .or. wntqs
           wntqo  = stdlib_lsame( jobz, 'O' )
           wntqn  = stdlib_lsame( jobz, 'N' )
           lquery = ( lwork==-1 )
           minwrk = 1
           maxwrk = 1
           if( .not.( wntqa .or. wntqs .or. wntqo .or. wntqn ) ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldu<1 .or. ( wntqas .and. ldu<m ) .or.( wntqo .and. m<n .and. ldu<m ) ) &
                     then
              info = -8
           else if( ldvt<1 .or. ( wntqa .and. ldvt<n ) .or.( wntqs .and. ldvt<minmn ) .or.( wntqo &
                     .and. m>=n .and. ldvt<n ) ) then
              info = -10
           end if
           ! compute workspace
             ! note: comments in the code beginning "workspace:" describe the
             ! minimal amount of workspace allocated at that point in the code,
             ! as well as the preferred amount for good performance.
             ! cworkspace refers to complex workspace, and rworkspace to
             ! real workspace. nb refers to the optimal block size for the
             ! immediately following subroutine, as returned by stdlib_ilaenv.)
           if( info==0 ) then
              minwrk = 1
              maxwrk = 1
              if( m>=n .and. minmn>0 ) then
                 ! there is no complex work space needed for bidiagonal svd
                 ! the realwork space needed for bidiagonal svd (stdlib_${c2ri(ci)}$bdsdc,KIND=${ck}$) is
                 ! bdspac = 3*n*n + 4*n for singular values and vectors;
                 ! bdspac = 4*n         for singular values only;
                 ! not including e, ru, and rvt matrices.
                 ! compute space preferred for each routine
                 call stdlib_${ci}$gebrd( m, n, cdum(1), m, dum(1), dum(1), cdum(1),cdum(1), cdum(1), -&
                           1, ierr )
                 lwork_wgebrd_mn = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$gebrd( n, n, cdum(1), n, dum(1), dum(1), cdum(1),cdum(1), cdum(1), -&
                           1, ierr )
                 lwork_wgebrd_nn = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$geqrf( m, n, cdum(1), m, cdum(1), cdum(1), -1, ierr )
                 lwork_wgeqrf_mn = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$ungbr( 'P', n, n, n, cdum(1), n, cdum(1), cdum(1),-1, ierr )
                 lwork_wungbr_p_nn = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$ungbr( 'Q', m, m, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_wungbr_q_mm = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$ungbr( 'Q', m, n, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_wungbr_q_mn = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$ungqr( m, m, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_wungqr_mm = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$ungqr( m, n, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_wungqr_mn = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$unmbr( 'P', 'R', 'C', n, n, n, cdum(1), n, cdum(1),cdum(1), n, cdum(&
                           1), -1, ierr )
                 lwork_wunmbr_prc_nn = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$unmbr( 'Q', 'L', 'N', m, m, n, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_wunmbr_qln_mm = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$unmbr( 'Q', 'L', 'N', m, n, n, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_wunmbr_qln_mn = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$unmbr( 'Q', 'L', 'N', n, n, n, cdum(1), n, cdum(1),cdum(1), n, cdum(&
                           1), -1, ierr )
                 lwork_wunmbr_qln_nn = int( cdum(1),KIND=ilp)
                 if( m>=mnthr1 ) then
                    if( wntqn ) then
                       ! path 1 (m >> n, jobz='n')
                       maxwrk = n + lwork_wgeqrf_mn
                       maxwrk = max( maxwrk, 2*n + lwork_wgebrd_nn )
                       minwrk = 3*n
                    else if( wntqo ) then
                       ! path 2 (m >> n, jobz='o')
                       wrkbl = n + lwork_wgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_wungqr_mn )
                       wrkbl = max( wrkbl, 2*n + lwork_wgebrd_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_wunmbr_qln_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_wunmbr_prc_nn )
                       maxwrk = m*n + n*n + wrkbl
                       minwrk = 2*n*n + 3*n
                    else if( wntqs ) then
                       ! path 3 (m >> n, jobz='s')
                       wrkbl = n + lwork_wgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_wungqr_mn )
                       wrkbl = max( wrkbl, 2*n + lwork_wgebrd_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_wunmbr_qln_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_wunmbr_prc_nn )
                       maxwrk = n*n + wrkbl
                       minwrk = n*n + 3*n
                    else if( wntqa ) then
                       ! path 4 (m >> n, jobz='a')
                       wrkbl = n + lwork_wgeqrf_mn
                       wrkbl = max( wrkbl,   n + lwork_wungqr_mm )
                       wrkbl = max( wrkbl, 2*n + lwork_wgebrd_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_wunmbr_qln_nn )
                       wrkbl = max( wrkbl, 2*n + lwork_wunmbr_prc_nn )
                       maxwrk = n*n + wrkbl
                       minwrk = n*n + max( 3*n, n + m )
                    end if
                 else if( m>=mnthr2 ) then
                    ! path 5 (m >> n, but not as much as mnthr1)
                    maxwrk = 2*n + lwork_wgebrd_mn
                    minwrk = 2*n + m
                    if( wntqo ) then
                       ! path 5o (m >> n, jobz='o')
                       maxwrk = max( maxwrk, 2*n + lwork_wungbr_p_nn )
                       maxwrk = max( maxwrk, 2*n + lwork_wungbr_q_mn )
                       maxwrk = maxwrk + m*n
                       minwrk = minwrk + n*n
                    else if( wntqs ) then
                       ! path 5s (m >> n, jobz='s')
                       maxwrk = max( maxwrk, 2*n + lwork_wungbr_p_nn )
                       maxwrk = max( maxwrk, 2*n + lwork_wungbr_q_mn )
                    else if( wntqa ) then
                       ! path 5a (m >> n, jobz='a')
                       maxwrk = max( maxwrk, 2*n + lwork_wungbr_p_nn )
                       maxwrk = max( maxwrk, 2*n + lwork_wungbr_q_mm )
                    end if
                 else
                    ! path 6 (m >= n, but not much larger)
                    maxwrk = 2*n + lwork_wgebrd_mn
                    minwrk = 2*n + m
                    if( wntqo ) then
                       ! path 6o (m >= n, jobz='o')
                       maxwrk = max( maxwrk, 2*n + lwork_wunmbr_prc_nn )
                       maxwrk = max( maxwrk, 2*n + lwork_wunmbr_qln_mn )
                       maxwrk = maxwrk + m*n
                       minwrk = minwrk + n*n
                    else if( wntqs ) then
                       ! path 6s (m >= n, jobz='s')
                       maxwrk = max( maxwrk, 2*n + lwork_wunmbr_qln_mn )
                       maxwrk = max( maxwrk, 2*n + lwork_wunmbr_prc_nn )
                    else if( wntqa ) then
                       ! path 6a (m >= n, jobz='a')
                       maxwrk = max( maxwrk, 2*n + lwork_wunmbr_qln_mm )
                       maxwrk = max( maxwrk, 2*n + lwork_wunmbr_prc_nn )
                    end if
                 end if
              else if( minmn>0 ) then
                 ! there is no complex work space needed for bidiagonal svd
                 ! the realwork space needed for bidiagonal svd (stdlib_${c2ri(ci)}$bdsdc,KIND=${ck}$) is
                 ! bdspac = 3*m*m + 4*m for singular values and vectors;
                 ! bdspac = 4*m         for singular values only;
                 ! not including e, ru, and rvt matrices.
                 ! compute space preferred for each routine
                 call stdlib_${ci}$gebrd( m, n, cdum(1), m, dum(1), dum(1), cdum(1),cdum(1), cdum(1), -&
                           1, ierr )
                 lwork_wgebrd_mn = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$gebrd( m, m, cdum(1), m, dum(1), dum(1), cdum(1),cdum(1), cdum(1), -&
                           1, ierr )
                 lwork_wgebrd_mm = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$gelqf( m, n, cdum(1), m, cdum(1), cdum(1), -1, ierr )
                 lwork_wgelqf_mn = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$ungbr( 'P', m, n, m, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_wungbr_p_mn = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$ungbr( 'P', n, n, m, cdum(1), n, cdum(1), cdum(1),-1, ierr )
                 lwork_wungbr_p_nn = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$ungbr( 'Q', m, m, n, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_wungbr_q_mm = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$unglq( m, n, m, cdum(1), m, cdum(1), cdum(1),-1, ierr )
                 lwork_wunglq_mn = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$unglq( n, n, m, cdum(1), n, cdum(1), cdum(1),-1, ierr )
                 lwork_wunglq_nn = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$unmbr( 'P', 'R', 'C', m, m, m, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_wunmbr_prc_mm = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$unmbr( 'P', 'R', 'C', m, n, m, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_wunmbr_prc_mn = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$unmbr( 'P', 'R', 'C', n, n, m, cdum(1), n, cdum(1),cdum(1), n, cdum(&
                           1), -1, ierr )
                 lwork_wunmbr_prc_nn = int( cdum(1),KIND=ilp)
                 call stdlib_${ci}$unmbr( 'Q', 'L', 'N', m, m, m, cdum(1), m, cdum(1),cdum(1), m, cdum(&
                           1), -1, ierr )
                 lwork_wunmbr_qln_mm = int( cdum(1),KIND=ilp)
                 if( n>=mnthr1 ) then
                    if( wntqn ) then
                       ! path 1t (n >> m, jobz='n')
                       maxwrk = m + lwork_wgelqf_mn
                       maxwrk = max( maxwrk, 2*m + lwork_wgebrd_mm )
                       minwrk = 3*m
                    else if( wntqo ) then
                       ! path 2t (n >> m, jobz='o')
                       wrkbl = m + lwork_wgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_wunglq_mn )
                       wrkbl = max( wrkbl, 2*m + lwork_wgebrd_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_wunmbr_qln_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_wunmbr_prc_mm )
                       maxwrk = m*n + m*m + wrkbl
                       minwrk = 2*m*m + 3*m
                    else if( wntqs ) then
                       ! path 3t (n >> m, jobz='s')
                       wrkbl = m + lwork_wgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_wunglq_mn )
                       wrkbl = max( wrkbl, 2*m + lwork_wgebrd_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_wunmbr_qln_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_wunmbr_prc_mm )
                       maxwrk = m*m + wrkbl
                       minwrk = m*m + 3*m
                    else if( wntqa ) then
                       ! path 4t (n >> m, jobz='a')
                       wrkbl = m + lwork_wgelqf_mn
                       wrkbl = max( wrkbl,   m + lwork_wunglq_nn )
                       wrkbl = max( wrkbl, 2*m + lwork_wgebrd_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_wunmbr_qln_mm )
                       wrkbl = max( wrkbl, 2*m + lwork_wunmbr_prc_mm )
                       maxwrk = m*m + wrkbl
                       minwrk = m*m + max( 3*m, m + n )
                    end if
                 else if( n>=mnthr2 ) then
                    ! path 5t (n >> m, but not as much as mnthr1)
                    maxwrk = 2*m + lwork_wgebrd_mn
                    minwrk = 2*m + n
                    if( wntqo ) then
                       ! path 5to (n >> m, jobz='o')
                       maxwrk = max( maxwrk, 2*m + lwork_wungbr_q_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_wungbr_p_mn )
                       maxwrk = maxwrk + m*n
                       minwrk = minwrk + m*m
                    else if( wntqs ) then
                       ! path 5ts (n >> m, jobz='s')
                       maxwrk = max( maxwrk, 2*m + lwork_wungbr_q_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_wungbr_p_mn )
                    else if( wntqa ) then
                       ! path 5ta (n >> m, jobz='a')
                       maxwrk = max( maxwrk, 2*m + lwork_wungbr_q_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_wungbr_p_nn )
                    end if
                 else
                    ! path 6t (n > m, but not much larger)
                    maxwrk = 2*m + lwork_wgebrd_mn
                    minwrk = 2*m + n
                    if( wntqo ) then
                       ! path 6to (n > m, jobz='o')
                       maxwrk = max( maxwrk, 2*m + lwork_wunmbr_qln_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_wunmbr_prc_mn )
                       maxwrk = maxwrk + m*n
                       minwrk = minwrk + m*m
                    else if( wntqs ) then
                       ! path 6ts (n > m, jobz='s')
                       maxwrk = max( maxwrk, 2*m + lwork_wunmbr_qln_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_wunmbr_prc_mn )
                    else if( wntqa ) then
                       ! path 6ta (n > m, jobz='a')
                       maxwrk = max( maxwrk, 2*m + lwork_wunmbr_qln_mm )
                       maxwrk = max( maxwrk, 2*m + lwork_wunmbr_prc_nn )
                    end if
                 end if
              end if
              maxwrk = max( maxwrk, minwrk )
           end if
           if( info==0 ) then
              work( 1 ) = stdlib_${c2ri(ci)}$roundup_lwork( maxwrk )
              if( lwork<minwrk .and. .not. lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGESDD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              return
           end if
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'P' )
           smlnum = sqrt( stdlib_${c2ri(ci)}$lamch( 'S' ) ) / eps
           bignum = one / smlnum
           ! scale a if max element outside range [smlnum,bignum]
           anrm = stdlib_${ci}$lange( 'M', m, n, a, lda, dum )
           if( stdlib_${c2ri(ci)}$isnan( anrm ) ) then
               info = -4
               return
           end if
           iscl = 0
           if( anrm>zero .and. anrm<smlnum ) then
              iscl = 1
              call stdlib_${ci}$lascl( 'G', 0, 0, anrm, smlnum, m, n, a, lda, ierr )
           else if( anrm>bignum ) then
              iscl = 1
              call stdlib_${ci}$lascl( 'G', 0, 0, anrm, bignum, m, n, a, lda, ierr )
           end if
           if( m>=n ) then
              ! a has at least as many rows as columns. if a has sufficiently
              ! more rows than columns, first reduce using the qr
              ! decomposition (if sufficient workspace available)
              if( m>=mnthr1 ) then
                 if( wntqn ) then
                    ! path 1 (m >> n, jobz='n')
                    ! no singular vectors to be computed
                    itau = 1
                    nwork = itau + n
                    ! compute a=q*r
                    ! cworkspace: need   n [tau] + n    [work]
                    ! cworkspace: prefer n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! zero out below r
                    if (n>1) call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero, a( 2, 1 ),lda )
                    ie = 1
                    itauq = 1
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in a
                    ! cworkspace: need   2*n [tauq, taup] + n      [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + 2*n*nb [work]
                    ! rworkspace: need   n [e]
                    call stdlib_${ci}$gebrd( n, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( nwork ), lwork-nwork+1,ierr )
                    nrwork = ie + n
                    ! perform bidiagonal svd, compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + bdspac
                    call stdlib_${c2ri(ci)}$bdsdc( 'U', 'N', n, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 2 (m >> n, jobz='o')
                    ! n left singular vectors to be overwritten on a and
                    ! n right singular vectors to be computed in vt
                    iu = 1
                    ! work(iu) is n by n
                    ldwrku = n
                    ir = iu + ldwrku*n
                    if( lwork >= m*n + n*n + 3*n ) then
                       ! work(ir) is m by n
                       ldwrkr = m
                    else
                       ldwrkr = ( lwork - n*n - 3*n ) / n
                    end if
                    itau = ir + ldwrkr*n
                    nwork = itau + n
                    ! compute a=q*r
                    ! cworkspace: need   n*n [u] + n*n [r] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! copy r to work( ir ), zeroing out below it
                    call stdlib_${ci}$lacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                    call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero, work( ir+1 ),ldwrkr )
                    ! generate q in a
                    ! cworkspace: need   n*n [u] + n*n [r] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$ungqr( m, n, n, a, lda, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ie = 1
                    itauq = itau
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in work(ir)
                    ! cworkspace: need   n*n [u] + n*n [r] + 2*n [tauq, taup] + n      [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + 2*n [tauq, taup] + 2*n*nb [work]
                    ! rworkspace: need   n [e]
                    call stdlib_${ci}$gebrd( n, n, work( ir ), ldwrkr, s, rwork( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of r in work(iru) and computing right singular vectors
                    ! of r in work(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = ie + n
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_${c2ri(ci)}$bdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=${ck}$) to complex matrix work(iu)
                    ! overwrite work(iu) by the left singular vectors of r
                    ! cworkspace: need   n*n [u] + n*n [r] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacp2( 'F', n, n, rwork( iru ), n, work( iu ),ldwrku )
                    call stdlib_${ci}$unmbr( 'Q', 'L', 'N', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                              work( iu ), ldwrku,work( nwork ), lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=${ck}$) to complex matrix vt
                    ! overwrite vt by the right singular vectors of r
                    ! cworkspace: need   n*n [u] + n*n [r] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [u] + n*n [r] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_${ci}$unmbr( 'P', 'R', 'C', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork-nwork+1, ierr )
                    ! multiply q in a by left singular vectors of r in
                    ! work(iu), storing result in work(ir) and copying to a
                    ! cworkspace: need   n*n [u] + n*n [r]
                    ! cworkspace: prefer n*n [u] + m*n [r]
                    ! rworkspace: need   0
                    do i = 1, m, ldwrkr
                       chunk = min( m-i+1, ldwrkr )
                       call stdlib_${ci}$gemm( 'N', 'N', chunk, n, n, cone, a( i, 1 ),lda, work( iu ), &
                                 ldwrku, czero,work( ir ), ldwrkr )
                       call stdlib_${ci}$lacpy( 'F', chunk, n, work( ir ), ldwrkr,a( i, 1 ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 3 (m >> n, jobz='s')
                    ! n left singular vectors to be computed in u and
                    ! n right singular vectors to be computed in vt
                    ir = 1
                    ! work(ir) is n by n
                    ldwrkr = n
                    itau = ir + ldwrkr*n
                    nwork = itau + n
                    ! compute a=q*r
                    ! cworkspace: need   n*n [r] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [r] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! copy r to work(ir), zeroing out below it
                    call stdlib_${ci}$lacpy( 'U', n, n, a, lda, work( ir ), ldwrkr )
                    call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero, work( ir+1 ),ldwrkr )
                    ! generate q in a
                    ! cworkspace: need   n*n [r] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [r] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$ungqr( m, n, n, a, lda, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ie = 1
                    itauq = itau
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in work(ir)
                    ! cworkspace: need   n*n [r] + 2*n [tauq, taup] + n      [work]
                    ! cworkspace: prefer n*n [r] + 2*n [tauq, taup] + 2*n*nb [work]
                    ! rworkspace: need   n [e]
                    call stdlib_${ci}$gebrd( n, n, work( ir ), ldwrkr, s, rwork( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = ie + n
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_${c2ri(ci)}$bdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=${ck}$) to complex matrix u
                    ! overwrite u by left singular vectors of r
                    ! cworkspace: need   n*n [r] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [r] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacp2( 'F', n, n, rwork( iru ), n, u, ldu )
                    call stdlib_${ci}$unmbr( 'Q', 'L', 'N', n, n, n, work( ir ), ldwrkr,work( itauq ), &
                              u, ldu, work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=${ck}$) to complex matrix vt
                    ! overwrite vt by right singular vectors of r
                    ! cworkspace: need   n*n [r] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [r] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_${ci}$unmbr( 'P', 'R', 'C', n, n, n, work( ir ), ldwrkr,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork-nwork+1, ierr )
                    ! multiply q in a by left singular vectors of r in
                    ! work(ir), storing result in u
                    ! cworkspace: need   n*n [r]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacpy( 'F', n, n, u, ldu, work( ir ), ldwrkr )
                    call stdlib_${ci}$gemm( 'N', 'N', m, n, n, cone, a, lda, work( ir ),ldwrkr, czero, &
                              u, ldu )
                 else if( wntqa ) then
                    ! path 4 (m >> n, jobz='a')
                    ! m left singular vectors to be computed in u and
                    ! n right singular vectors to be computed in vt
                    iu = 1
                    ! work(iu) is n by n
                    ldwrku = n
                    itau = iu + ldwrku*n
                    nwork = itau + n
                    ! compute a=q*r, copying result to u
                    ! cworkspace: need   n*n [u] + n [tau] + n    [work]
                    ! cworkspace: prefer n*n [u] + n [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$geqrf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    call stdlib_${ci}$lacpy( 'L', m, n, a, lda, u, ldu )
                    ! generate q in u
                    ! cworkspace: need   n*n [u] + n [tau] + m    [work]
                    ! cworkspace: prefer n*n [u] + n [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$ungqr( m, m, n, u, ldu, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ! produce r in a, zeroing out below it
                    if (n>1) call stdlib_${ci}$laset( 'L', n-1, n-1, czero, czero, a( 2, 1 ),lda )
                    ie = 1
                    itauq = itau
                    itaup = itauq + n
                    nwork = itaup + n
                    ! bidiagonalize r in a
                    ! cworkspace: need   n*n [u] + 2*n [tauq, taup] + n      [work]
                    ! cworkspace: prefer n*n [u] + 2*n [tauq, taup] + 2*n*nb [work]
                    ! rworkspace: need   n [e]
                    call stdlib_${ci}$gebrd( n, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( nwork ), lwork-nwork+1,ierr )
                    iru = ie + n
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    call stdlib_${c2ri(ci)}$bdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=${ck}$) to complex matrix work(iu)
                    ! overwrite work(iu) by left singular vectors of r
                    ! cworkspace: need   n*n [u] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [u] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacp2( 'F', n, n, rwork( iru ), n, work( iu ),ldwrku )
                    call stdlib_${ci}$unmbr( 'Q', 'L', 'N', n, n, n, a, lda,work( itauq ), work( iu ), &
                              ldwrku,work( nwork ), lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=${ck}$) to complex matrix vt
                    ! overwrite vt by right singular vectors of r
                    ! cworkspace: need   n*n [u] + 2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer n*n [u] + 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_${ci}$unmbr( 'P', 'R', 'C', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! multiply q in u by left singular vectors of r in
                    ! work(iu), storing result in a
                    ! cworkspace: need   n*n [u]
                    ! rworkspace: need   0
                    call stdlib_${ci}$gemm( 'N', 'N', m, n, n, cone, u, ldu, work( iu ),ldwrku, czero, &
                              a, lda )
                    ! copy left singular vectors of a from a to u
                    call stdlib_${ci}$lacpy( 'F', m, n, a, lda, u, ldu )
                 end if
              else if( m>=mnthr2 ) then
                 ! mnthr2 <= m < mnthr1
                 ! path 5 (m >> n, but not as much as mnthr1)
                 ! reduce to bidiagonal form without qr decomposition, use
                 ! stdlib_${ci}$ungbr and matrix multiplication to compute singular vectors
                 ie = 1
                 nrwork = ie + n
                 itauq = 1
                 itaup = itauq + n
                 nwork = itaup + n
                 ! bidiagonalize a
                 ! cworkspace: need   2*n [tauq, taup] + m        [work]
                 ! cworkspace: prefer 2*n [tauq, taup] + (m+n)*nb [work]
                 ! rworkspace: need   n [e]
                 call stdlib_${ci}$gebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 5n (m >> n, jobz='n')
                    ! compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + bdspac
                    call stdlib_${c2ri(ci)}$bdsdc( 'U', 'N', n, s, rwork( ie ), dum, 1,dum,1,dum, idum, &
                              rwork( nrwork ), iwork, info )
                 else if( wntqo ) then
                    iu = nwork
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    ! path 5o (m >> n, jobz='o')
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_${ci}$ungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! generate q in a
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$ungbr( 'Q', m, n, n, a, lda, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    if( lwork >= m*n + 3*n ) then
                       ! work( iu ) is m by n
                       ldwrku = m
                    else
                       ! work(iu) is ldwrku by n
                       ldwrku = ( lwork - 3*n ) / n
                    end if
                    nwork = iu + ldwrku*n
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    call stdlib_${c2ri(ci)}$bdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply realmatrix rwork(irvt,KIND=${ck}$) by p**h in vt,
                    ! storing the result in work(iu), copying to vt
                    ! cworkspace: need   2*n [tauq, taup] + n*n [u]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + 2*n*n [rwork]
                    call stdlib_${ci}$larcm( n, n, rwork( irvt ), n, vt, ldvt,work( iu ), ldwrku, &
                              rwork( nrwork ) )
                    call stdlib_${ci}$lacpy( 'F', n, n, work( iu ), ldwrku, vt, ldvt )
                    ! multiply q in a by realmatrix rwork(iru,KIND=${ck}$), storing the
                    ! result in work(iu), copying to a
                    ! cworkspace: need   2*n [tauq, taup] + n*n [u]
                    ! cworkspace: prefer 2*n [tauq, taup] + m*n [u]
                    ! rworkspace: need   n [e] + n*n [ru] + 2*n*n [rwork]
                    ! rworkspace: prefer n [e] + n*n [ru] + 2*m*n [rwork] < n + 5*n*n since m < 2*n here
                    nrwork = irvt
                    do i = 1, m, ldwrku
                       chunk = min( m-i+1, ldwrku )
                       call stdlib_${ci}$lacrm( chunk, n, a( i, 1 ), lda, rwork( iru ),n, work( iu ), &
                                 ldwrku, rwork( nrwork ) )
                       call stdlib_${ci}$lacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 5s (m >> n, jobz='s')
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_${ci}$ungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! copy a to u, generate q
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacpy( 'L', m, n, a, lda, u, ldu )
                    call stdlib_${ci}$ungbr( 'Q', m, n, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_${c2ri(ci)}$bdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply realmatrix rwork(irvt,KIND=${ck}$) by p**h in vt,
                    ! storing the result in a, copying to vt
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + 2*n*n [rwork]
                    call stdlib_${ci}$larcm( n, n, rwork( irvt ), n, vt, ldvt, a, lda,rwork( nrwork ) )
                              
                    call stdlib_${ci}$lacpy( 'F', n, n, a, lda, vt, ldvt )
                    ! multiply q in u by realmatrix rwork(iru,KIND=${ck}$), storing the
                    ! result in a, copying to u
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + 2*m*n [rwork] < n + 5*n*n since m < 2*n here
                    nrwork = irvt
                    call stdlib_${ci}$lacrm( m, n, u, ldu, rwork( iru ), n, a, lda,rwork( nrwork ) )
                              
                    call stdlib_${ci}$lacpy( 'F', m, n, a, lda, u, ldu )
                 else
                    ! path 5a (m >> n, jobz='a')
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacpy( 'U', n, n, a, lda, vt, ldvt )
                    call stdlib_${ci}$ungbr( 'P', n, n, n, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! copy a to u, generate q
                    ! cworkspace: need   2*n [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacpy( 'L', m, n, a, lda, u, ldu )
                    call stdlib_${ci}$ungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_${c2ri(ci)}$bdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply realmatrix rwork(irvt,KIND=${ck}$) by p**h in vt,
                    ! storing the result in a, copying to vt
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + 2*n*n [rwork]
                    call stdlib_${ci}$larcm( n, n, rwork( irvt ), n, vt, ldvt, a, lda,rwork( nrwork ) )
                              
                    call stdlib_${ci}$lacpy( 'F', n, n, a, lda, vt, ldvt )
                    ! multiply q in u by realmatrix rwork(iru,KIND=${ck}$), storing the
                    ! result in a, copying to u
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + 2*m*n [rwork] < n + 5*n*n since m < 2*n here
                    nrwork = irvt
                    call stdlib_${ci}$lacrm( m, n, u, ldu, rwork( iru ), n, a, lda,rwork( nrwork ) )
                              
                    call stdlib_${ci}$lacpy( 'F', m, n, a, lda, u, ldu )
                 end if
              else
                 ! m < mnthr2
                 ! path 6 (m >= n, but not much larger)
                 ! reduce to bidiagonal form without qr decomposition
                 ! use stdlib_${ci}$unmbr to compute singular vectors
                 ie = 1
                 nrwork = ie + n
                 itauq = 1
                 itaup = itauq + n
                 nwork = itaup + n
                 ! bidiagonalize a
                 ! cworkspace: need   2*n [tauq, taup] + m        [work]
                 ! cworkspace: prefer 2*n [tauq, taup] + (m+n)*nb [work]
                 ! rworkspace: need   n [e]
                 call stdlib_${ci}$gebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 6n (m >= n, jobz='n')
                    ! compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + bdspac
                    call stdlib_${c2ri(ci)}$bdsdc( 'U', 'N', n, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    iu = nwork
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    if( lwork >= m*n + 3*n ) then
                       ! work( iu ) is m by n
                       ldwrku = m
                    else
                       ! work( iu ) is ldwrku by n
                       ldwrku = ( lwork - 3*n ) / n
                    end if
                    nwork = iu + ldwrku*n
                    ! path 6o (m >= n, jobz='o')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    call stdlib_${c2ri(ci)}$bdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(irvt,KIND=${ck}$) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + n*n [u] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*n [u] + n*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_${ci}$lacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_${ci}$unmbr( 'P', 'R', 'C', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                    if( lwork >= m*n + 3*n ) then
                       ! path 6o-fast
                       ! copy realmatrix rwork(iru,KIND=${ck}$) to complex matrix work(iu)
                       ! overwrite work(iu) by left singular vectors of a, copying
                       ! to a
                       ! cworkspace: need   2*n [tauq, taup] + m*n [u] + n    [work]
                       ! cworkspace: prefer 2*n [tauq, taup] + m*n [u] + n*nb [work]
                       ! rworkspace: need   n [e] + n*n [ru]
                       call stdlib_${ci}$laset( 'F', m, n, czero, czero, work( iu ),ldwrku )
                       call stdlib_${ci}$lacp2( 'F', n, n, rwork( iru ), n, work( iu ),ldwrku )
                       call stdlib_${ci}$unmbr( 'Q', 'L', 'N', m, n, n, a, lda,work( itauq ), work( iu &
                                 ), ldwrku,work( nwork ), lwork-nwork+1, ierr )
                       call stdlib_${ci}$lacpy( 'F', m, n, work( iu ), ldwrku, a, lda )
                    else
                       ! path 6o-slow
                       ! generate q in a
                       ! cworkspace: need   2*n [tauq, taup] + n*n [u] + n    [work]
                       ! cworkspace: prefer 2*n [tauq, taup] + n*n [u] + n*nb [work]
                       ! rworkspace: need   0
                       call stdlib_${ci}$ungbr( 'Q', m, n, n, a, lda, work( itauq ),work( nwork ), &
                                 lwork-nwork+1, ierr )
                       ! multiply q in a by realmatrix rwork(iru,KIND=${ck}$), storing the
                       ! result in work(iu), copying to a
                       ! cworkspace: need   2*n [tauq, taup] + n*n [u]
                       ! cworkspace: prefer 2*n [tauq, taup] + m*n [u]
                       ! rworkspace: need   n [e] + n*n [ru] + 2*n*n [rwork]
                       ! rworkspace: prefer n [e] + n*n [ru] + 2*m*n [rwork] < n + 5*n*n since m < 2*n here
                       nrwork = irvt
                       do i = 1, m, ldwrku
                          chunk = min( m-i+1, ldwrku )
                          call stdlib_${ci}$lacrm( chunk, n, a( i, 1 ), lda,rwork( iru ), n, work( iu )&
                                    , ldwrku,rwork( nrwork ) )
                          call stdlib_${ci}$lacpy( 'F', chunk, n, work( iu ), ldwrku,a( i, 1 ), lda )
                                    
                       end do
                    end if
                 else if( wntqs ) then
                    ! path 6s (m >= n, jobz='s')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_${c2ri(ci)}$bdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=${ck}$) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_${ci}$laset( 'F', m, n, czero, czero, u, ldu )
                    call stdlib_${ci}$lacp2( 'F', n, n, rwork( iru ), n, u, ldu )
                    call stdlib_${ci}$unmbr( 'Q', 'L', 'N', m, n, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=${ck}$) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_${ci}$lacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_${ci}$unmbr( 'P', 'R', 'C', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                 else
                    ! path 6a (m >= n, jobz='a')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt] + bdspac
                    iru = nrwork
                    irvt = iru + n*n
                    nrwork = irvt + n*n
                    call stdlib_${c2ri(ci)}$bdsdc( 'U', 'I', n, s, rwork( ie ), rwork( iru ),n, rwork( irvt )&
                              , n, dum, idum,rwork( nrwork ), iwork, info )
                    ! set the right corner of u to identity matrix
                    call stdlib_${ci}$laset( 'F', m, m, czero, czero, u, ldu )
                    if( m>n ) then
                       call stdlib_${ci}$laset( 'F', m-n, m-n, czero, cone,u( n+1, n+1 ), ldu )
                    end if
                    ! copy realmatrix rwork(iru,KIND=${ck}$) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + m*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_${ci}$lacp2( 'F', n, n, rwork( iru ), n, u, ldu )
                    call stdlib_${ci}$unmbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=${ck}$) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*n [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*n [tauq, taup] + n*nb [work]
                    ! rworkspace: need   n [e] + n*n [ru] + n*n [rvt]
                    call stdlib_${ci}$lacp2( 'F', n, n, rwork( irvt ), n, vt, ldvt )
                    call stdlib_${ci}$unmbr( 'P', 'R', 'C', n, n, n, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                 end if
              end if
           else
              ! a has more columns than rows. if a has sufficiently more
              ! columns than rows, first reduce using the lq decomposition (if
              ! sufficient workspace available)
              if( n>=mnthr1 ) then
                 if( wntqn ) then
                    ! path 1t (n >> m, jobz='n')
                    ! no singular vectors to be computed
                    itau = 1
                    nwork = itau + m
                    ! compute a=l*q
                    ! cworkspace: need   m [tau] + m    [work]
                    ! cworkspace: prefer m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! zero out above l
                    if (m>1) call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero, a( 1, 2 ),lda )
                    ie = 1
                    itauq = 1
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in a
                    ! cworkspace: need   2*m [tauq, taup] + m      [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + 2*m*nb [work]
                    ! rworkspace: need   m [e]
                    call stdlib_${ci}$gebrd( m, m, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( nwork ), lwork-nwork+1,ierr )
                    nrwork = ie + m
                    ! perform bidiagonal svd, compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + bdspac
                    call stdlib_${c2ri(ci)}$bdsdc( 'U', 'N', m, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 2t (n >> m, jobz='o')
                    ! m right singular vectors to be overwritten on a and
                    ! m left singular vectors to be computed in u
                    ivt = 1
                    ldwkvt = m
                    ! work(ivt) is m by m
                    il = ivt + ldwkvt*m
                    if( lwork >= m*n + m*m + 3*m ) then
                       ! work(il) m by n
                       ldwrkl = m
                       chunk = n
                    else
                       ! work(il) is m by chunk
                       ldwrkl = m
                       chunk = ( lwork - m*m - 3*m ) / m
                    end if
                    itau = il + ldwrkl*chunk
                    nwork = itau + m
                    ! compute a=l*q
                    ! cworkspace: need   m*m [vt] + m*m [l] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! copy l to work(il), zeroing about above it
                    call stdlib_${ci}$lacpy( 'L', m, m, a, lda, work( il ), ldwrkl )
                    call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero,work( il+ldwrkl ), ldwrkl )
                              
                    ! generate q in a
                    ! cworkspace: need   m*m [vt] + m*m [l] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$unglq( m, n, m, a, lda, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ie = 1
                    itauq = itau
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in work(il)
                    ! cworkspace: need   m*m [vt] + m*m [l] + 2*m [tauq, taup] + m      [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + 2*m [tauq, taup] + 2*m*nb [work]
                    ! rworkspace: need   m [e]
                    call stdlib_${ci}$gebrd( m, m, work( il ), ldwrkl, s, rwork( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [ru] + m*m [rvt] + bdspac
                    iru = ie + m
                    irvt = iru + m*m
                    nrwork = irvt + m*m
                    call stdlib_${c2ri(ci)}$bdsdc( 'U', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=${ck}$) to complex matrix work(iu)
                    ! overwrite work(iu) by the left singular vectors of l
                    ! cworkspace: need   m*m [vt] + m*m [l] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_${ci}$unmbr( 'Q', 'L', 'N', m, m, m, work( il ), ldwrkl,work( itauq ), &
                              u, ldu, work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=${ck}$) to complex matrix work(ivt)
                    ! overwrite work(ivt) by the right singular vectors of l
                    ! cworkspace: need   m*m [vt] + m*m [l] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m*m [l] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacp2( 'F', m, m, rwork( irvt ), m, work( ivt ),ldwkvt )
                    call stdlib_${ci}$unmbr( 'P', 'R', 'C', m, m, m, work( il ), ldwrkl,work( itaup ), &
                              work( ivt ), ldwkvt,work( nwork ), lwork-nwork+1, ierr )
                    ! multiply right singular vectors of l in work(il) by q
                    ! in a, storing result in work(il) and copying to a
                    ! cworkspace: need   m*m [vt] + m*m [l]
                    ! cworkspace: prefer m*m [vt] + m*n [l]
                    ! rworkspace: need   0
                    do i = 1, n, chunk
                       blk = min( n-i+1, chunk )
                       call stdlib_${ci}$gemm( 'N', 'N', m, blk, m, cone, work( ivt ), m,a( 1, i ), &
                                 lda, czero, work( il ),ldwrkl )
                       call stdlib_${ci}$lacpy( 'F', m, blk, work( il ), ldwrkl,a( 1, i ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 3t (n >> m, jobz='s')
                    ! m right singular vectors to be computed in vt and
                    ! m left singular vectors to be computed in u
                    il = 1
                    ! work(il) is m by m
                    ldwrkl = m
                    itau = il + ldwrkl*m
                    nwork = itau + m
                    ! compute a=l*q
                    ! cworkspace: need   m*m [l] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [l] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    ! copy l to work(il), zeroing out above it
                    call stdlib_${ci}$lacpy( 'L', m, m, a, lda, work( il ), ldwrkl )
                    call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero,work( il+ldwrkl ), ldwrkl )
                              
                    ! generate q in a
                    ! cworkspace: need   m*m [l] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [l] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$unglq( m, n, m, a, lda, work( itau ),work( nwork ), lwork-nwork+&
                              1, ierr )
                    ie = 1
                    itauq = itau
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in work(il)
                    ! cworkspace: need   m*m [l] + 2*m [tauq, taup] + m      [work]
                    ! cworkspace: prefer m*m [l] + 2*m [tauq, taup] + 2*m*nb [work]
                    ! rworkspace: need   m [e]
                    call stdlib_${ci}$gebrd( m, m, work( il ), ldwrkl, s, rwork( ie ),work( itauq ), &
                              work( itaup ), work( nwork ),lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [ru] + m*m [rvt] + bdspac
                    iru = ie + m
                    irvt = iru + m*m
                    nrwork = irvt + m*m
                    call stdlib_${c2ri(ci)}$bdsdc( 'U', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=${ck}$) to complex matrix u
                    ! overwrite u by left singular vectors of l
                    ! cworkspace: need   m*m [l] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [l] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_${ci}$unmbr( 'Q', 'L', 'N', m, m, m, work( il ), ldwrkl,work( itauq ), &
                              u, ldu, work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=${ck}$) to complex matrix vt
                    ! overwrite vt by left singular vectors of l
                    ! cworkspace: need   m*m [l] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [l] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacp2( 'F', m, m, rwork( irvt ), m, vt, ldvt )
                    call stdlib_${ci}$unmbr( 'P', 'R', 'C', m, m, m, work( il ), ldwrkl,work( itaup ), &
                              vt, ldvt, work( nwork ),lwork-nwork+1, ierr )
                    ! copy vt to work(il), multiply right singular vectors of l
                    ! in work(il) by q in a, storing result in vt
                    ! cworkspace: need   m*m [l]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacpy( 'F', m, m, vt, ldvt, work( il ), ldwrkl )
                    call stdlib_${ci}$gemm( 'N', 'N', m, n, m, cone, work( il ), ldwrkl,a, lda, czero, &
                              vt, ldvt )
                 else if( wntqa ) then
                    ! path 4t (n >> m, jobz='a')
                    ! n right singular vectors to be computed in vt and
                    ! m left singular vectors to be computed in u
                    ivt = 1
                    ! work(ivt) is m by m
                    ldwkvt = m
                    itau = ivt + ldwkvt*m
                    nwork = itau + m
                    ! compute a=l*q, copying result to vt
                    ! cworkspace: need   m*m [vt] + m [tau] + m    [work]
                    ! cworkspace: prefer m*m [vt] + m [tau] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$gelqf( m, n, a, lda, work( itau ), work( nwork ),lwork-nwork+1, &
                              ierr )
                    call stdlib_${ci}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                    ! generate q in vt
                    ! cworkspace: need   m*m [vt] + m [tau] + n    [work]
                    ! cworkspace: prefer m*m [vt] + m [tau] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$unglq( n, n, m, vt, ldvt, work( itau ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! produce l in a, zeroing out above it
                    if (m>1) call stdlib_${ci}$laset( 'U', m-1, m-1, czero, czero, a( 1, 2 ),lda )
                    ie = 1
                    itauq = itau
                    itaup = itauq + m
                    nwork = itaup + m
                    ! bidiagonalize l in a
                    ! cworkspace: need   m*m [vt] + 2*m [tauq, taup] + m      [work]
                    ! cworkspace: prefer m*m [vt] + 2*m [tauq, taup] + 2*m*nb [work]
                    ! rworkspace: need   m [e]
                    call stdlib_${ci}$gebrd( m, m, a, lda, s, rwork( ie ), work( itauq ),work( itaup ),&
                               work( nwork ), lwork-nwork+1,ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [ru] + m*m [rvt] + bdspac
                    iru = ie + m
                    irvt = iru + m*m
                    nrwork = irvt + m*m
                    call stdlib_${c2ri(ci)}$bdsdc( 'U', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=${ck}$) to complex matrix u
                    ! overwrite u by left singular vectors of l
                    ! cworkspace: need   m*m [vt] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [vt] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_${ci}$unmbr( 'Q', 'L', 'N', m, m, m, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=${ck}$) to complex matrix work(ivt)
                    ! overwrite work(ivt) by right singular vectors of l
                    ! cworkspace: need   m*m [vt] + 2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer m*m [vt] + 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacp2( 'F', m, m, rwork( irvt ), m, work( ivt ),ldwkvt )
                    call stdlib_${ci}$unmbr( 'P', 'R', 'C', m, m, m, a, lda,work( itaup ), work( ivt ),&
                               ldwkvt,work( nwork ), lwork-nwork+1, ierr )
                    ! multiply right singular vectors of l in work(ivt) by
                    ! q in vt, storing result in a
                    ! cworkspace: need   m*m [vt]
                    ! rworkspace: need   0
                    call stdlib_${ci}$gemm( 'N', 'N', m, n, m, cone, work( ivt ), ldwkvt,vt, ldvt, &
                              czero, a, lda )
                    ! copy right singular vectors of a from a to vt
                    call stdlib_${ci}$lacpy( 'F', m, n, a, lda, vt, ldvt )
                 end if
              else if( n>=mnthr2 ) then
                 ! mnthr2 <= n < mnthr1
                 ! path 5t (n >> m, but not as much as mnthr1)
                 ! reduce to bidiagonal form without qr decomposition, use
                 ! stdlib_${ci}$ungbr and matrix multiplication to compute singular vectors
                 ie = 1
                 nrwork = ie + m
                 itauq = 1
                 itaup = itauq + m
                 nwork = itaup + m
                 ! bidiagonalize a
                 ! cworkspace: need   2*m [tauq, taup] + n        [work]
                 ! cworkspace: prefer 2*m [tauq, taup] + (m+n)*nb [work]
                 ! rworkspace: need   m [e]
                 call stdlib_${ci}$gebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 5tn (n >> m, jobz='n')
                    ! compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + bdspac
                    call stdlib_${c2ri(ci)}$bdsdc( 'L', 'N', m, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    ivt = nwork
                    ! path 5to (n >> m, jobz='o')
                    ! copy a to u, generate q
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_${ci}$ungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! generate p**h in a
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$ungbr( 'P', m, n, m, a, lda, work( itaup ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ldwkvt = m
                    if( lwork >= m*n + 3*m ) then
                       ! work( ivt ) is m by n
                       nwork = ivt + ldwkvt*n
                       chunk = n
                    else
                       ! work( ivt ) is m by chunk
                       chunk = ( lwork - 3*m ) / m
                       nwork = ivt + ldwkvt*chunk
                    end if
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    call stdlib_${c2ri(ci)}$bdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply q in u by realmatrix rwork(irvt,KIND=${ck}$)
                    ! storing the result in work(ivt), copying to u
                    ! cworkspace: need   2*m [tauq, taup] + m*m [vt]
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + 2*m*m [rwork]
                    call stdlib_${ci}$lacrm( m, m, u, ldu, rwork( iru ), m, work( ivt ),ldwkvt, rwork( &
                              nrwork ) )
                    call stdlib_${ci}$lacpy( 'F', m, m, work( ivt ), ldwkvt, u, ldu )
                    ! multiply rwork(irvt) by p**h in a, storing the
                    ! result in work(ivt), copying to a
                    ! cworkspace: need   2*m [tauq, taup] + m*m [vt]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*n [vt]
                    ! rworkspace: need   m [e] + m*m [rvt] + 2*m*m [rwork]
                    ! rworkspace: prefer m [e] + m*m [rvt] + 2*m*n [rwork] < m + 5*m*m since n < 2*m here
                    nrwork = iru
                    do i = 1, n, chunk
                       blk = min( n-i+1, chunk )
                       call stdlib_${ci}$larcm( m, blk, rwork( irvt ), m, a( 1, i ), lda,work( ivt ), &
                                 ldwkvt, rwork( nrwork ) )
                       call stdlib_${ci}$lacpy( 'F', m, blk, work( ivt ), ldwkvt,a( 1, i ), lda )
                                 
                    end do
                 else if( wntqs ) then
                    ! path 5ts (n >> m, jobz='s')
                    ! copy a to u, generate q
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_${ci}$ungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                    call stdlib_${ci}$ungbr( 'P', m, n, m, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_${c2ri(ci)}$bdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply q in u by realmatrix rwork(iru,KIND=${ck}$), storing the
                    ! result in a, copying to u
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + 2*m*m [rwork]
                    call stdlib_${ci}$lacrm( m, m, u, ldu, rwork( iru ), m, a, lda,rwork( nrwork ) )
                              
                    call stdlib_${ci}$lacpy( 'F', m, m, a, lda, u, ldu )
                    ! multiply realmatrix rwork(irvt,KIND=${ck}$) by p**h in vt,
                    ! storing the result in a, copying to vt
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + 2*m*n [rwork] < m + 5*m*m since n < 2*m here
                    nrwork = iru
                    call stdlib_${ci}$larcm( m, n, rwork( irvt ), m, vt, ldvt, a, lda,rwork( nrwork ) )
                              
                    call stdlib_${ci}$lacpy( 'F', m, n, a, lda, vt, ldvt )
                 else
                    ! path 5ta (n >> m, jobz='a')
                    ! copy a to u, generate q
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacpy( 'L', m, m, a, lda, u, ldu )
                    call stdlib_${ci}$ungbr( 'Q', m, m, n, u, ldu, work( itauq ),work( nwork ), lwork-&
                              nwork+1, ierr )
                    ! copy a to vt, generate p**h
                    ! cworkspace: need   2*m [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + n*nb [work]
                    ! rworkspace: need   0
                    call stdlib_${ci}$lacpy( 'U', m, n, a, lda, vt, ldvt )
                    call stdlib_${ci}$ungbr( 'P', n, n, m, vt, ldvt, work( itaup ),work( nwork ), &
                              lwork-nwork+1, ierr )
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_${c2ri(ci)}$bdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! multiply q in u by realmatrix rwork(iru,KIND=${ck}$), storing the
                    ! result in a, copying to u
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + 2*m*m [rwork]
                    call stdlib_${ci}$lacrm( m, m, u, ldu, rwork( iru ), m, a, lda,rwork( nrwork ) )
                              
                    call stdlib_${ci}$lacpy( 'F', m, m, a, lda, u, ldu )
                    ! multiply realmatrix rwork(irvt,KIND=${ck}$) by p**h in vt,
                    ! storing the result in a, copying to vt
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + 2*m*n [rwork] < m + 5*m*m since n < 2*m here
                    nrwork = iru
                    call stdlib_${ci}$larcm( m, n, rwork( irvt ), m, vt, ldvt, a, lda,rwork( nrwork ) )
                              
                    call stdlib_${ci}$lacpy( 'F', m, n, a, lda, vt, ldvt )
                 end if
              else
                 ! n < mnthr2
                 ! path 6t (n > m, but not much larger)
                 ! reduce to bidiagonal form without lq decomposition
                 ! use stdlib_${ci}$unmbr to compute singular vectors
                 ie = 1
                 nrwork = ie + m
                 itauq = 1
                 itaup = itauq + m
                 nwork = itaup + m
                 ! bidiagonalize a
                 ! cworkspace: need   2*m [tauq, taup] + n        [work]
                 ! cworkspace: prefer 2*m [tauq, taup] + (m+n)*nb [work]
                 ! rworkspace: need   m [e]
                 call stdlib_${ci}$gebrd( m, n, a, lda, s, rwork( ie ), work( itauq ),work( itaup ), &
                           work( nwork ), lwork-nwork+1,ierr )
                 if( wntqn ) then
                    ! path 6tn (n > m, jobz='n')
                    ! compute singular values only
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + bdspac
                    call stdlib_${c2ri(ci)}$bdsdc( 'L', 'N', m, s, rwork( ie ), dum,1,dum,1,dum, idum, rwork(&
                               nrwork ), iwork, info )
                 else if( wntqo ) then
                    ! path 6to (n > m, jobz='o')
                    ldwkvt = m
                    ivt = nwork
                    if( lwork >= m*n + 3*m ) then
                       ! work( ivt ) is m by n
                       call stdlib_${ci}$laset( 'F', m, n, czero, czero, work( ivt ),ldwkvt )
                       nwork = ivt + ldwkvt*n
                    else
                       ! work( ivt ) is m by chunk
                       chunk = ( lwork - 3*m ) / m
                       nwork = ivt + ldwkvt*chunk
                    end if
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_${c2ri(ci)}$bdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=${ck}$) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + m*m [vt] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*m [vt] + m*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru]
                    call stdlib_${ci}$lacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_${ci}$unmbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    if( lwork >= m*n + 3*m ) then
                       ! path 6to-fast
                       ! copy realmatrix rwork(irvt,KIND=${ck}$) to complex matrix work(ivt)
                       ! overwrite work(ivt) by right singular vectors of a,
                       ! copying to a
                       ! cworkspace: need   2*m [tauq, taup] + m*n [vt] + m    [work]
                       ! cworkspace: prefer 2*m [tauq, taup] + m*n [vt] + m*nb [work]
                       ! rworkspace: need   m [e] + m*m [rvt]
                       call stdlib_${ci}$lacp2( 'F', m, m, rwork( irvt ), m, work( ivt ),ldwkvt )
                                 
                       call stdlib_${ci}$unmbr( 'P', 'R', 'C', m, n, m, a, lda,work( itaup ), work( &
                                 ivt ), ldwkvt,work( nwork ), lwork-nwork+1, ierr )
                       call stdlib_${ci}$lacpy( 'F', m, n, work( ivt ), ldwkvt, a, lda )
                    else
                       ! path 6to-slow
                       ! generate p**h in a
                       ! cworkspace: need   2*m [tauq, taup] + m*m [vt] + m    [work]
                       ! cworkspace: prefer 2*m [tauq, taup] + m*m [vt] + m*nb [work]
                       ! rworkspace: need   0
                       call stdlib_${ci}$ungbr( 'P', m, n, m, a, lda, work( itaup ),work( nwork ), &
                                 lwork-nwork+1, ierr )
                       ! multiply q in a by realmatrix rwork(iru,KIND=${ck}$), storing the
                       ! result in work(iu), copying to a
                       ! cworkspace: need   2*m [tauq, taup] + m*m [vt]
                       ! cworkspace: prefer 2*m [tauq, taup] + m*n [vt]
                       ! rworkspace: need   m [e] + m*m [rvt] + 2*m*m [rwork]
                       ! rworkspace: prefer m [e] + m*m [rvt] + 2*m*n [rwork] < m + 5*m*m since n < 2*m here
                       nrwork = iru
                       do i = 1, n, chunk
                          blk = min( n-i+1, chunk )
                          call stdlib_${ci}$larcm( m, blk, rwork( irvt ), m, a( 1, i ),lda, work( ivt )&
                                    , ldwkvt,rwork( nrwork ) )
                          call stdlib_${ci}$lacpy( 'F', m, blk, work( ivt ), ldwkvt,a( 1, i ), lda )
                                    
                       end do
                    end if
                 else if( wntqs ) then
                    ! path 6ts (n > m, jobz='s')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_${c2ri(ci)}$bdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=${ck}$) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru]
                    call stdlib_${ci}$lacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_${ci}$unmbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! copy realmatrix rwork(irvt,KIND=${ck}$) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt]
                    call stdlib_${ci}$laset( 'F', m, n, czero, czero, vt, ldvt )
                    call stdlib_${ci}$lacp2( 'F', m, m, rwork( irvt ), m, vt, ldvt )
                    call stdlib_${ci}$unmbr( 'P', 'R', 'C', m, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                 else
                    ! path 6ta (n > m, jobz='a')
                    ! perform bidiagonal svd, computing left singular vectors
                    ! of bidiagonal matrix in rwork(iru) and computing right
                    ! singular vectors of bidiagonal matrix in rwork(irvt)
                    ! cworkspace: need   0
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru] + bdspac
                    irvt = nrwork
                    iru = irvt + m*m
                    nrwork = iru + m*m
                    call stdlib_${c2ri(ci)}$bdsdc( 'L', 'I', m, s, rwork( ie ), rwork( iru ),m, rwork( irvt )&
                              , m, dum, idum,rwork( nrwork ), iwork, info )
                    ! copy realmatrix rwork(iru,KIND=${ck}$) to complex matrix u
                    ! overwrite u by left singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + m    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + m*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt] + m*m [ru]
                    call stdlib_${ci}$lacp2( 'F', m, m, rwork( iru ), m, u, ldu )
                    call stdlib_${ci}$unmbr( 'Q', 'L', 'N', m, m, n, a, lda,work( itauq ), u, ldu, &
                              work( nwork ),lwork-nwork+1, ierr )
                    ! set all of vt to identity matrix
                    call stdlib_${ci}$laset( 'F', n, n, czero, cone, vt, ldvt )
                    ! copy realmatrix rwork(irvt,KIND=${ck}$) to complex matrix vt
                    ! overwrite vt by right singular vectors of a
                    ! cworkspace: need   2*m [tauq, taup] + n    [work]
                    ! cworkspace: prefer 2*m [tauq, taup] + n*nb [work]
                    ! rworkspace: need   m [e] + m*m [rvt]
                    call stdlib_${ci}$lacp2( 'F', m, m, rwork( irvt ), m, vt, ldvt )
                    call stdlib_${ci}$unmbr( 'P', 'R', 'C', n, n, m, a, lda,work( itaup ), vt, ldvt, &
                              work( nwork ),lwork-nwork+1, ierr )
                 end if
              end if
           end if
           ! undo scaling if necessary
           if( iscl==1 ) then
              if( anrm>bignum )call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, bignum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm>bignum )call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, bignum, anrm, minmn-1,&
                         1,rwork( ie ), minmn, ierr )
              if( anrm<smlnum )call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, smlnum, anrm, minmn, 1, s, minmn,&
                        ierr )
              if( info/=0 .and. anrm<smlnum )call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, smlnum, anrm, minmn-1,&
                         1,rwork( ie ), minmn, ierr )
           end if
           ! return optimal workspace in work(1)
           work( 1 ) = stdlib_${c2ri(ci)}$roundup_lwork( maxwrk )
           return
     end subroutine stdlib_${ci}$gesdd

#:endif
#:endfor



     module pure subroutine stdlib_sbdsdc( uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq,work, iwork, &
     !! SBDSDC computes the singular value decomposition (SVD) of a real
     !! N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
     !! using a divide and conquer method, where S is a diagonal matrix
     !! with non-negative diagonal elements (the singular values of B), and
     !! U and VT are orthogonal matrices of left and right singular vectors,
     !! respectively. SBDSDC can be used to compute all singular values,
     !! and optionally, singular vectors or singular vectors in compact form.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.  See SLASD3 for details.
     !! The code currently calls SLASDQ if singular values only are desired.
     !! However, it can be slightly modified to compute singular values
     !! using the divide and conquer method.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu, ldvt, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iq(*), iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: q(*), u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
        ! changed dimension statement in comment describing e from (n) to
        ! (n-1).  sven, 17 feb 05.
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: difl, difr, givcol, givnum, givptr, i, ic, icompq, ierr, ii, is, iu, &
           iuplo, ivt, j, k, kk, mlvl, nm1, nsize, perm, poles, qstart, smlsiz, smlszp, sqre, &
                     start, wstart, z
           real(sp) :: cs, eps, orgnrm, p, r, sn
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           iuplo = 0
           if( stdlib_lsame( uplo, 'U' ) )iuplo = 1
           if( stdlib_lsame( uplo, 'L' ) )iuplo = 2
           if( stdlib_lsame( compq, 'N' ) ) then
              icompq = 0
           else if( stdlib_lsame( compq, 'P' ) ) then
              icompq = 1
           else if( stdlib_lsame( compq, 'I' ) ) then
              icompq = 2
           else
              icompq = -1
           end if
           if( iuplo==0 ) then
              info = -1
           else if( icompq<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ( ldu<1 ) .or. ( ( icompq==2 ) .and. ( ldu<n ) ) ) then
              info = -7
           else if( ( ldvt<1 ) .or. ( ( icompq==2 ) .and. ( ldvt<n ) ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SBDSDC', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           smlsiz = stdlib_ilaenv( 9, 'SBDSDC', ' ', 0, 0, 0, 0 )
           if( n==1 ) then
              if( icompq==1 ) then
                 q( 1 ) = sign( one, d( 1 ) )
                 q( 1+smlsiz*n ) = one
              else if( icompq==2 ) then
                 u( 1, 1 ) = sign( one, d( 1 ) )
                 vt( 1, 1 ) = one
              end if
              d( 1 ) = abs( d( 1 ) )
              return
           end if
           nm1 = n - 1
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           wstart = 1
           qstart = 3
           if( icompq==1 ) then
              call stdlib_scopy( n, d, 1, q( 1 ), 1 )
              call stdlib_scopy( n-1, e, 1, q( n+1 ), 1 )
           end if
           if( iuplo==2 ) then
              qstart = 5
              if( icompq == 2 ) wstart = 2*n - 1
              do i = 1, n - 1
                 call stdlib_slartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 if( icompq==1 ) then
                    q( i+2*n ) = cs
                    q( i+3*n ) = sn
                 else if( icompq==2 ) then
                    work( i ) = cs
                    work( nm1+i ) = -sn
                 end if
              end do
           end if
           ! if icompq = 0, use stdlib_slasdq to compute the singular values.
           if( icompq==0 ) then
              ! ignore wstart, instead using work( 1 ), since the two vectors
              ! for cs and -sn above are added only if icompq == 2,
              ! and adding them exceeds documented work size of 4*n.
              call stdlib_slasdq( 'U', 0, n, 0, 0, 0, d, e, vt, ldvt, u, ldu, u,ldu, work( 1 ), &
                        info )
              go to 40
           end if
           ! if n is smaller than the minimum divide size smlsiz, then solve
           ! the problem with another solver.
           if( n<=smlsiz ) then
              if( icompq==2 ) then
                 call stdlib_slaset( 'A', n, n, zero, one, u, ldu )
                 call stdlib_slaset( 'A', n, n, zero, one, vt, ldvt )
                 call stdlib_slasdq( 'U', 0, n, n, n, 0, d, e, vt, ldvt, u, ldu, u,ldu, work( &
                           wstart ), info )
              else if( icompq==1 ) then
                 iu = 1
                 ivt = iu + n
                 call stdlib_slaset( 'A', n, n, zero, one, q( iu+( qstart-1 )*n ),n )
                 call stdlib_slaset( 'A', n, n, zero, one, q( ivt+( qstart-1 )*n ),n )
                 call stdlib_slasdq( 'U', 0, n, n, n, 0, d, e,q( ivt+( qstart-1 )*n ), n,q( iu+( &
                           qstart-1 )*n ), n,q( iu+( qstart-1 )*n ), n, work( wstart ),info )
              end if
              go to 40
           end if
           if( icompq==2 ) then
              call stdlib_slaset( 'A', n, n, zero, one, u, ldu )
              call stdlib_slaset( 'A', n, n, zero, one, vt, ldvt )
           end if
           ! scale.
           orgnrm = stdlib_slanst( 'M', n, d, e )
           if( orgnrm==zero )return
           call stdlib_slascl( 'G', 0, 0, orgnrm, one, n, 1, d, n, ierr )
           call stdlib_slascl( 'G', 0, 0, orgnrm, one, nm1, 1, e, nm1, ierr )
           eps = stdlib_slamch( 'EPSILON' )
           mlvl = int( log( real( n,KIND=sp) / real( smlsiz+1,KIND=sp) ) / log( two ),KIND=ilp) + &
                     1
           smlszp = smlsiz + 1
           if( icompq==1 ) then
              iu = 1
              ivt = 1 + smlsiz
              difl = ivt + smlszp
              difr = difl + mlvl
              z = difr + mlvl*2
              ic = z + mlvl
              is = ic + 1
              poles = is + 1
              givnum = poles + 2*mlvl
              k = 1
              givptr = 2
              perm = 3
              givcol = perm + mlvl
           end if
           do i = 1, n
              if( abs( d( i ) )<eps ) then
                 d( i ) = sign( eps, d( i ) )
              end if
           end do
           start = 1
           sqre = 0
           loop_30: do i = 1, nm1
              if( ( abs( e( i ) )<eps ) .or. ( i==nm1 ) ) then
              ! subproblem found. first determine its size and then
              ! apply divide and conquer on it.
                 if( i<nm1 ) then
              ! a subproblem with e(i) small for i < nm1.
                    nsize = i - start + 1
                 else if( abs( e( i ) )>=eps ) then
              ! a subproblem with e(nm1) not too small but i = nm1.
                    nsize = n - start + 1
                 else
              ! a subproblem with e(nm1) small. this implies an
              ! 1-by-1 subproblem at d(n). solve this 1-by-1 problem
              ! first.
                    nsize = i - start + 1
                    if( icompq==2 ) then
                       u( n, n ) = sign( one, d( n ) )
                       vt( n, n ) = one
                    else if( icompq==1 ) then
                       q( n+( qstart-1 )*n ) = sign( one, d( n ) )
                       q( n+( smlsiz+qstart-1 )*n ) = one
                    end if
                    d( n ) = abs( d( n ) )
                 end if
                 if( icompq==2 ) then
                    call stdlib_slasd0( nsize, sqre, d( start ), e( start ),u( start, start ), &
                              ldu, vt( start, start ),ldvt, smlsiz, iwork, work( wstart ), info )
                 else
                    call stdlib_slasda( icompq, smlsiz, nsize, sqre, d( start ),e( start ), q( &
                    start+( iu+qstart-2 )*n ), n,q( start+( ivt+qstart-2 )*n ),iq( start+k*n ), q(&
                     start+( difl+qstart-2 )*n ), q( start+( difr+qstart-2 )*n ),q( start+( z+&
                     qstart-2 )*n ),q( start+( poles+qstart-2 )*n ),iq( start+givptr*n ), iq( &
                     start+givcol*n ),n, iq( start+perm*n ),q( start+( givnum+qstart-2 )*n ),q( &
                     start+( ic+qstart-2 )*n ),q( start+( is+qstart-2 )*n ),work( wstart ), iwork,&
                                info )
                 end if
                 if( info/=0 ) then
                    return
                 end if
                 start = i + 1
              end if
           end do loop_30
           ! unscale
           call stdlib_slascl( 'G', 0, 0, one, orgnrm, n, 1, d, n, ierr )
           40 continue
           ! use selection sort to minimize swaps of singular vectors
           do ii = 2, n
              i = ii - 1
              kk = i
              p = d( i )
              do j = ii, n
                 if( d( j )>p ) then
                    kk = j
                    p = d( j )
                 end if
              end do
              if( kk/=i ) then
                 d( kk ) = d( i )
                 d( i ) = p
                 if( icompq==1 ) then
                    iq( i ) = kk
                 else if( icompq==2 ) then
                    call stdlib_sswap( n, u( 1, i ), 1, u( 1, kk ), 1 )
                    call stdlib_sswap( n, vt( i, 1 ), ldvt, vt( kk, 1 ), ldvt )
                 end if
              else if( icompq==1 ) then
                 iq( i ) = i
              end if
           end do
           ! if icompq = 1, use iq(n,1) as the indicator for uplo
           if( icompq==1 ) then
              if( iuplo==1 ) then
                 iq( n ) = 1
              else
                 iq( n ) = 0
              end if
           end if
           ! if b is lower bidiagonal, update u by those givens rotations
           ! which rotated b to be upper bidiagonal
           if( ( iuplo==2 ) .and. ( icompq==2 ) )call stdlib_slasr( 'L', 'V', 'B', n, n, work( 1 )&
                     , work( n ), u, ldu )
           return
     end subroutine stdlib_sbdsdc

     module pure subroutine stdlib_dbdsdc( uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq,work, iwork, &
     !! DBDSDC computes the singular value decomposition (SVD) of a real
     !! N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
     !! using a divide and conquer method, where S is a diagonal matrix
     !! with non-negative diagonal elements (the singular values of B), and
     !! U and VT are orthogonal matrices of left and right singular vectors,
     !! respectively. DBDSDC can be used to compute all singular values,
     !! and optionally, singular vectors or singular vectors in compact form.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.  See DLASD3 for details.
     !! The code currently calls DLASDQ if singular values only are desired.
     !! However, it can be slightly modified to compute singular values
     !! using the divide and conquer method.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu, ldvt, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iq(*), iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: q(*), u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
        ! changed dimension statement in comment describing e from (n) to
        ! (n-1).  sven, 17 feb 05.
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: difl, difr, givcol, givnum, givptr, i, ic, icompq, ierr, ii, is, iu, &
           iuplo, ivt, j, k, kk, mlvl, nm1, nsize, perm, poles, qstart, smlsiz, smlszp, sqre, &
                     start, wstart, z
           real(dp) :: cs, eps, orgnrm, p, r, sn
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           iuplo = 0
           if( stdlib_lsame( uplo, 'U' ) )iuplo = 1
           if( stdlib_lsame( uplo, 'L' ) )iuplo = 2
           if( stdlib_lsame( compq, 'N' ) ) then
              icompq = 0
           else if( stdlib_lsame( compq, 'P' ) ) then
              icompq = 1
           else if( stdlib_lsame( compq, 'I' ) ) then
              icompq = 2
           else
              icompq = -1
           end if
           if( iuplo==0 ) then
              info = -1
           else if( icompq<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ( ldu<1 ) .or. ( ( icompq==2 ) .and. ( ldu<n ) ) ) then
              info = -7
           else if( ( ldvt<1 ) .or. ( ( icompq==2 ) .and. ( ldvt<n ) ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DBDSDC', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           smlsiz = stdlib_ilaenv( 9, 'DBDSDC', ' ', 0, 0, 0, 0 )
           if( n==1 ) then
              if( icompq==1 ) then
                 q( 1 ) = sign( one, d( 1 ) )
                 q( 1+smlsiz*n ) = one
              else if( icompq==2 ) then
                 u( 1, 1 ) = sign( one, d( 1 ) )
                 vt( 1, 1 ) = one
              end if
              d( 1 ) = abs( d( 1 ) )
              return
           end if
           nm1 = n - 1
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           wstart = 1
           qstart = 3
           if( icompq==1 ) then
              call stdlib_dcopy( n, d, 1, q( 1 ), 1 )
              call stdlib_dcopy( n-1, e, 1, q( n+1 ), 1 )
           end if
           if( iuplo==2 ) then
              qstart = 5
              if( icompq == 2 ) wstart = 2*n - 1
              do i = 1, n - 1
                 call stdlib_dlartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 if( icompq==1 ) then
                    q( i+2*n ) = cs
                    q( i+3*n ) = sn
                 else if( icompq==2 ) then
                    work( i ) = cs
                    work( nm1+i ) = -sn
                 end if
              end do
           end if
           ! if icompq = 0, use stdlib_dlasdq to compute the singular values.
           if( icompq==0 ) then
              ! ignore wstart, instead using work( 1 ), since the two vectors
              ! for cs and -sn above are added only if icompq == 2,
              ! and adding them exceeds documented work size of 4*n.
              call stdlib_dlasdq( 'U', 0, n, 0, 0, 0, d, e, vt, ldvt, u, ldu, u,ldu, work( 1 ), &
                        info )
              go to 40
           end if
           ! if n is smaller than the minimum divide size smlsiz, then solve
           ! the problem with another solver.
           if( n<=smlsiz ) then
              if( icompq==2 ) then
                 call stdlib_dlaset( 'A', n, n, zero, one, u, ldu )
                 call stdlib_dlaset( 'A', n, n, zero, one, vt, ldvt )
                 call stdlib_dlasdq( 'U', 0, n, n, n, 0, d, e, vt, ldvt, u, ldu, u,ldu, work( &
                           wstart ), info )
              else if( icompq==1 ) then
                 iu = 1
                 ivt = iu + n
                 call stdlib_dlaset( 'A', n, n, zero, one, q( iu+( qstart-1 )*n ),n )
                 call stdlib_dlaset( 'A', n, n, zero, one, q( ivt+( qstart-1 )*n ),n )
                 call stdlib_dlasdq( 'U', 0, n, n, n, 0, d, e,q( ivt+( qstart-1 )*n ), n,q( iu+( &
                           qstart-1 )*n ), n,q( iu+( qstart-1 )*n ), n, work( wstart ),info )
              end if
              go to 40
           end if
           if( icompq==2 ) then
              call stdlib_dlaset( 'A', n, n, zero, one, u, ldu )
              call stdlib_dlaset( 'A', n, n, zero, one, vt, ldvt )
           end if
           ! scale.
           orgnrm = stdlib_dlanst( 'M', n, d, e )
           if( orgnrm==zero )return
           call stdlib_dlascl( 'G', 0, 0, orgnrm, one, n, 1, d, n, ierr )
           call stdlib_dlascl( 'G', 0, 0, orgnrm, one, nm1, 1, e, nm1, ierr )
           eps = (0.9e+0_dp)*stdlib_dlamch( 'EPSILON' )
           mlvl = int( log( real( n,KIND=dp) / real( smlsiz+1,KIND=dp) ) / log( two ),KIND=ilp) + &
                     1
           smlszp = smlsiz + 1
           if( icompq==1 ) then
              iu = 1
              ivt = 1 + smlsiz
              difl = ivt + smlszp
              difr = difl + mlvl
              z = difr + mlvl*2
              ic = z + mlvl
              is = ic + 1
              poles = is + 1
              givnum = poles + 2*mlvl
              k = 1
              givptr = 2
              perm = 3
              givcol = perm + mlvl
           end if
           do i = 1, n
              if( abs( d( i ) )<eps ) then
                 d( i ) = sign( eps, d( i ) )
              end if
           end do
           start = 1
           sqre = 0
           loop_30: do i = 1, nm1
              if( ( abs( e( i ) )<eps ) .or. ( i==nm1 ) ) then
                 ! subproblem found. first determine its size and then
                 ! apply divide and conquer on it.
                 if( i<nm1 ) then
                    ! a subproblem with e(i) small for i < nm1.
                    nsize = i - start + 1
                 else if( abs( e( i ) )>=eps ) then
                    ! a subproblem with e(nm1) not too small but i = nm1.
                    nsize = n - start + 1
                 else
                    ! a subproblem with e(nm1) small. this implies an
                    ! 1-by-1 subproblem at d(n). solve this 1-by-1 problem
                    ! first.
                    nsize = i - start + 1
                    if( icompq==2 ) then
                       u( n, n ) = sign( one, d( n ) )
                       vt( n, n ) = one
                    else if( icompq==1 ) then
                       q( n+( qstart-1 )*n ) = sign( one, d( n ) )
                       q( n+( smlsiz+qstart-1 )*n ) = one
                    end if
                    d( n ) = abs( d( n ) )
                 end if
                 if( icompq==2 ) then
                    call stdlib_dlasd0( nsize, sqre, d( start ), e( start ),u( start, start ), &
                              ldu, vt( start, start ),ldvt, smlsiz, iwork, work( wstart ), info )
                 else
                    call stdlib_dlasda( icompq, smlsiz, nsize, sqre, d( start ),e( start ), q( &
                    start+( iu+qstart-2 )*n ), n,q( start+( ivt+qstart-2 )*n ),iq( start+k*n ), q(&
                     start+( difl+qstart-2 )*n ), q( start+( difr+qstart-2 )*n ),q( start+( z+&
                     qstart-2 )*n ),q( start+( poles+qstart-2 )*n ),iq( start+givptr*n ), iq( &
                     start+givcol*n ),n, iq( start+perm*n ),q( start+( givnum+qstart-2 )*n ),q( &
                     start+( ic+qstart-2 )*n ),q( start+( is+qstart-2 )*n ),work( wstart ), iwork,&
                                info )
                 end if
                 if( info/=0 ) then
                    return
                 end if
                 start = i + 1
              end if
           end do loop_30
           ! unscale
           call stdlib_dlascl( 'G', 0, 0, one, orgnrm, n, 1, d, n, ierr )
           40 continue
           ! use selection sort to minimize swaps of singular vectors
           do ii = 2, n
              i = ii - 1
              kk = i
              p = d( i )
              do j = ii, n
                 if( d( j )>p ) then
                    kk = j
                    p = d( j )
                 end if
              end do
              if( kk/=i ) then
                 d( kk ) = d( i )
                 d( i ) = p
                 if( icompq==1 ) then
                    iq( i ) = kk
                 else if( icompq==2 ) then
                    call stdlib_dswap( n, u( 1, i ), 1, u( 1, kk ), 1 )
                    call stdlib_dswap( n, vt( i, 1 ), ldvt, vt( kk, 1 ), ldvt )
                 end if
              else if( icompq==1 ) then
                 iq( i ) = i
              end if
           end do
           ! if icompq = 1, use iq(n,1) as the indicator for uplo
           if( icompq==1 ) then
              if( iuplo==1 ) then
                 iq( n ) = 1
              else
                 iq( n ) = 0
              end if
           end if
           ! if b is lower bidiagonal, update u by those givens rotations
           ! which rotated b to be upper bidiagonal
           if( ( iuplo==2 ) .and. ( icompq==2 ) )call stdlib_dlasr( 'L', 'V', 'B', n, n, work( 1 )&
                     , work( n ), u, ldu )
           return
     end subroutine stdlib_dbdsdc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$bdsdc( uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq,work, iwork, &
     !! DBDSDC: computes the singular value decomposition (SVD) of a real
     !! N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
     !! using a divide and conquer method, where S is a diagonal matrix
     !! with non-negative diagonal elements (the singular values of B), and
     !! U and VT are orthogonal matrices of left and right singular vectors,
     !! respectively. DBDSDC can be used to compute all singular values,
     !! and optionally, singular vectors or singular vectors in compact form.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.  See DLASD3 for details.
     !! The code currently calls DLASDQ if singular values only are desired.
     !! However, it can be slightly modified to compute singular values
     !! using the divide and conquer method.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu, ldvt, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iq(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: q(*), u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
        ! changed dimension statement in comment describing e from (n) to
        ! (n-1).  sven, 17 feb 05.
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: difl, difr, givcol, givnum, givptr, i, ic, icompq, ierr, ii, is, iu, &
           iuplo, ivt, j, k, kk, mlvl, nm1, nsize, perm, poles, qstart, smlsiz, smlszp, sqre, &
                     start, wstart, z
           real(${rk}$) :: cs, eps, orgnrm, p, r, sn
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           iuplo = 0
           if( stdlib_lsame( uplo, 'U' ) )iuplo = 1
           if( stdlib_lsame( uplo, 'L' ) )iuplo = 2
           if( stdlib_lsame( compq, 'N' ) ) then
              icompq = 0
           else if( stdlib_lsame( compq, 'P' ) ) then
              icompq = 1
           else if( stdlib_lsame( compq, 'I' ) ) then
              icompq = 2
           else
              icompq = -1
           end if
           if( iuplo==0 ) then
              info = -1
           else if( icompq<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ( ldu<1 ) .or. ( ( icompq==2 ) .and. ( ldu<n ) ) ) then
              info = -7
           else if( ( ldvt<1 ) .or. ( ( icompq==2 ) .and. ( ldvt<n ) ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DBDSDC', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           smlsiz = stdlib_ilaenv( 9, 'DBDSDC', ' ', 0, 0, 0, 0 )
           if( n==1 ) then
              if( icompq==1 ) then
                 q( 1 ) = sign( one, d( 1 ) )
                 q( 1+smlsiz*n ) = one
              else if( icompq==2 ) then
                 u( 1, 1 ) = sign( one, d( 1 ) )
                 vt( 1, 1 ) = one
              end if
              d( 1 ) = abs( d( 1 ) )
              return
           end if
           nm1 = n - 1
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           wstart = 1
           qstart = 3
           if( icompq==1 ) then
              call stdlib_${ri}$copy( n, d, 1, q( 1 ), 1 )
              call stdlib_${ri}$copy( n-1, e, 1, q( n+1 ), 1 )
           end if
           if( iuplo==2 ) then
              qstart = 5
              if( icompq == 2 ) wstart = 2*n - 1
              do i = 1, n - 1
                 call stdlib_${ri}$lartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 if( icompq==1 ) then
                    q( i+2*n ) = cs
                    q( i+3*n ) = sn
                 else if( icompq==2 ) then
                    work( i ) = cs
                    work( nm1+i ) = -sn
                 end if
              end do
           end if
           ! if icompq = 0, use stdlib_${ri}$lasdq to compute the singular values.
           if( icompq==0 ) then
              ! ignore wstart, instead using work( 1 ), since the two vectors
              ! for cs and -sn above are added only if icompq == 2,
              ! and adding them exceeds documented work size of 4*n.
              call stdlib_${ri}$lasdq( 'U', 0, n, 0, 0, 0, d, e, vt, ldvt, u, ldu, u,ldu, work( 1 ), &
                        info )
              go to 40
           end if
           ! if n is smaller than the minimum divide size smlsiz, then solve
           ! the problem with another solver.
           if( n<=smlsiz ) then
              if( icompq==2 ) then
                 call stdlib_${ri}$laset( 'A', n, n, zero, one, u, ldu )
                 call stdlib_${ri}$laset( 'A', n, n, zero, one, vt, ldvt )
                 call stdlib_${ri}$lasdq( 'U', 0, n, n, n, 0, d, e, vt, ldvt, u, ldu, u,ldu, work( &
                           wstart ), info )
              else if( icompq==1 ) then
                 iu = 1
                 ivt = iu + n
                 call stdlib_${ri}$laset( 'A', n, n, zero, one, q( iu+( qstart-1 )*n ),n )
                 call stdlib_${ri}$laset( 'A', n, n, zero, one, q( ivt+( qstart-1 )*n ),n )
                 call stdlib_${ri}$lasdq( 'U', 0, n, n, n, 0, d, e,q( ivt+( qstart-1 )*n ), n,q( iu+( &
                           qstart-1 )*n ), n,q( iu+( qstart-1 )*n ), n, work( wstart ),info )
              end if
              go to 40
           end if
           if( icompq==2 ) then
              call stdlib_${ri}$laset( 'A', n, n, zero, one, u, ldu )
              call stdlib_${ri}$laset( 'A', n, n, zero, one, vt, ldvt )
           end if
           ! scale.
           orgnrm = stdlib_${ri}$lanst( 'M', n, d, e )
           if( orgnrm==zero )return
           call stdlib_${ri}$lascl( 'G', 0, 0, orgnrm, one, n, 1, d, n, ierr )
           call stdlib_${ri}$lascl( 'G', 0, 0, orgnrm, one, nm1, 1, e, nm1, ierr )
           eps = (0.9e+0_${rk}$)*stdlib_${ri}$lamch( 'EPSILON' )
           mlvl = int( log( real( n,KIND=${rk}$) / real( smlsiz+1,KIND=${rk}$) ) / log( two ),KIND=ilp) + &
                     1
           smlszp = smlsiz + 1
           if( icompq==1 ) then
              iu = 1
              ivt = 1 + smlsiz
              difl = ivt + smlszp
              difr = difl + mlvl
              z = difr + mlvl*2
              ic = z + mlvl
              is = ic + 1
              poles = is + 1
              givnum = poles + 2*mlvl
              k = 1
              givptr = 2
              perm = 3
              givcol = perm + mlvl
           end if
           do i = 1, n
              if( abs( d( i ) )<eps ) then
                 d( i ) = sign( eps, d( i ) )
              end if
           end do
           start = 1
           sqre = 0
           loop_30: do i = 1, nm1
              if( ( abs( e( i ) )<eps ) .or. ( i==nm1 ) ) then
                 ! subproblem found. first determine its size and then
                 ! apply divide and conquer on it.
                 if( i<nm1 ) then
                    ! a subproblem with e(i) small for i < nm1.
                    nsize = i - start + 1
                 else if( abs( e( i ) )>=eps ) then
                    ! a subproblem with e(nm1) not too small but i = nm1.
                    nsize = n - start + 1
                 else
                    ! a subproblem with e(nm1) small. this implies an
                    ! 1-by-1 subproblem at d(n). solve this 1-by-1 problem
                    ! first.
                    nsize = i - start + 1
                    if( icompq==2 ) then
                       u( n, n ) = sign( one, d( n ) )
                       vt( n, n ) = one
                    else if( icompq==1 ) then
                       q( n+( qstart-1 )*n ) = sign( one, d( n ) )
                       q( n+( smlsiz+qstart-1 )*n ) = one
                    end if
                    d( n ) = abs( d( n ) )
                 end if
                 if( icompq==2 ) then
                    call stdlib_${ri}$lasd0( nsize, sqre, d( start ), e( start ),u( start, start ), &
                              ldu, vt( start, start ),ldvt, smlsiz, iwork, work( wstart ), info )
                 else
                    call stdlib_${ri}$lasda( icompq, smlsiz, nsize, sqre, d( start ),e( start ), q( &
                    start+( iu+qstart-2 )*n ), n,q( start+( ivt+qstart-2 )*n ),iq( start+k*n ), q(&
                     start+( difl+qstart-2 )*n ), q( start+( difr+qstart-2 )*n ),q( start+( z+&
                     qstart-2 )*n ),q( start+( poles+qstart-2 )*n ),iq( start+givptr*n ), iq( &
                     start+givcol*n ),n, iq( start+perm*n ),q( start+( givnum+qstart-2 )*n ),q( &
                     start+( ic+qstart-2 )*n ),q( start+( is+qstart-2 )*n ),work( wstart ), iwork,&
                                info )
                 end if
                 if( info/=0 ) then
                    return
                 end if
                 start = i + 1
              end if
           end do loop_30
           ! unscale
           call stdlib_${ri}$lascl( 'G', 0, 0, one, orgnrm, n, 1, d, n, ierr )
           40 continue
           ! use selection sort to minimize swaps of singular vectors
           do ii = 2, n
              i = ii - 1
              kk = i
              p = d( i )
              do j = ii, n
                 if( d( j )>p ) then
                    kk = j
                    p = d( j )
                 end if
              end do
              if( kk/=i ) then
                 d( kk ) = d( i )
                 d( i ) = p
                 if( icompq==1 ) then
                    iq( i ) = kk
                 else if( icompq==2 ) then
                    call stdlib_${ri}$swap( n, u( 1, i ), 1, u( 1, kk ), 1 )
                    call stdlib_${ri}$swap( n, vt( i, 1 ), ldvt, vt( kk, 1 ), ldvt )
                 end if
              else if( icompq==1 ) then
                 iq( i ) = i
              end if
           end do
           ! if icompq = 1, use iq(n,1) as the indicator for uplo
           if( icompq==1 ) then
              if( iuplo==1 ) then
                 iq( n ) = 1
              else
                 iq( n ) = 0
              end if
           end if
           ! if b is lower bidiagonal, update u by those givens rotations
           ! which rotated b to be upper bidiagonal
           if( ( iuplo==2 ) .and. ( icompq==2 ) )call stdlib_${ri}$lasr( 'L', 'V', 'B', n, n, work( 1 )&
                     , work( n ), u, ldu )
           return
     end subroutine stdlib_${ri}$bdsdc

#:endif
#:endfor



     module pure subroutine stdlib_sgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, ldu, &
     !! SGEJSV computes the singular value decomposition (SVD) of a real M-by-N
     !! matrix [A], where M >= N. The SVD of [A] is written as
     !! [A] = [U] * [SIGMA] * [V]^t,
     !! where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
     !! diagonal elements, [U] is an M-by-N (or M-by-M) orthonormal matrix, and
     !! [V] is an N-by-N orthogonal matrix. The diagonal elements of [SIGMA] are
     !! the singular values of [A]. The columns of [U] and [V] are the left and
     !! the right singular vectors of [A], respectively. The matrices [U] and [V]
     !! are computed and stored in the arrays U and V, respectively. The diagonal
     !! of [SIGMA] is computed and stored in the array SVA.
     !! SGEJSV can sometimes compute tiny singular values and their singular vectors much
     !! more accurately than other SVD routines, see below under Further Details.
               v, ldv,work, lwork, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldv, lwork, m, n
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: sva(n), u(ldu,*), v(ldv,*), work(lwork)
           integer(ilp), intent(out) :: iwork(*)
           character, intent(in) :: joba, jobp, jobr, jobt, jobu, jobv
        ! ===========================================================================
           
           ! Local Scalars 
           real(sp) :: aapp, aaqq, aatmax, aatmin, big, big1, cond_ok, condr1, condr2, entra, &
                     entrat, epsln, maxprj, scalem, sconda, sfmin, small, temp1, uscal1, uscal2, xsc
           integer(ilp) :: ierr, n1, nr, numrank, p, q, warning
           logical(lk) :: almort, defr, errest, goscal, jracc, kill, lsvec, l2aber, l2kill, &
                     l2pert, l2rank, l2tran, noscal, rowpiv, rsvec, transp
           ! Intrinsic Functions 
           ! test the input arguments
           lsvec  = stdlib_lsame( jobu, 'U' ) .or. stdlib_lsame( jobu, 'F' )
           jracc  = stdlib_lsame( jobv, 'J' )
           rsvec  = stdlib_lsame( jobv, 'V' ) .or. jracc
           rowpiv = stdlib_lsame( joba, 'F' ) .or. stdlib_lsame( joba, 'G' )
           l2rank = stdlib_lsame( joba, 'R' )
           l2aber = stdlib_lsame( joba, 'A' )
           errest = stdlib_lsame( joba, 'E' ) .or. stdlib_lsame( joba, 'G' )
           l2tran = stdlib_lsame( jobt, 'T' )
           l2kill = stdlib_lsame( jobr, 'R' )
           defr   = stdlib_lsame( jobr, 'N' )
           l2pert = stdlib_lsame( jobp, 'P' )
           if ( .not.(rowpiv .or. l2rank .or. l2aber .or.errest .or. stdlib_lsame( joba, 'C' ) )) &
                     then
              info = - 1
           else if ( .not.( lsvec  .or. stdlib_lsame( jobu, 'N' ) .or.stdlib_lsame( jobu, 'W' )) )&
                      then
              info = - 2
           else if ( .not.( rsvec .or. stdlib_lsame( jobv, 'N' ) .or.stdlib_lsame( jobv, 'W' )) &
                     .or. ( jracc .and. (.not.lsvec) ) ) then
              info = - 3
           else if ( .not. ( l2kill .or. defr ) )    then
              info = - 4
           else if ( .not. ( l2tran .or. stdlib_lsame( jobt, 'N' ) ) ) then
              info = - 5
           else if ( .not. ( l2pert .or. stdlib_lsame( jobp, 'N' ) ) ) then
              info = - 6
           else if ( m < 0 ) then
              info = - 7
           else if ( ( n < 0 ) .or. ( n > m ) ) then
              info = - 8
           else if ( lda < m ) then
              info = - 10
           else if ( lsvec .and. ( ldu < m ) ) then
              info = - 13
           else if ( rsvec .and. ( ldv < n ) ) then
              info = - 15
           else if ( (.not.(lsvec .or. rsvec .or. errest).and.(lwork < max(7,4*n+1,2*m+n))) .or.(&
           .not.(lsvec .or. rsvec) .and. errest .and.(lwork < max(7,4*n+n*n,2*m+n))) .or.(lsvec &
           .and. (.not.rsvec) .and. (lwork < max(7,2*m+n,4*n+1))).or.(rsvec .and. (.not.lsvec) &
           .and. (lwork < max(7,2*m+n,4*n+1))).or.(lsvec .and. rsvec .and. (.not.jracc) .and.(&
           lwork<max(2*m+n,6*n+2*n*n))).or. (lsvec .and. rsvec .and. jracc .and.lwork<max(2*m+n,&
                     4*n+n*n,2*n+n*n+6)))then
              info = - 17
           else
              ! #:)
              info = 0
           end if
           if ( info /= 0 ) then
             ! #:(
              call stdlib_xerbla( 'SGEJSV', - info )
              return
           end if
           ! quick return for void matrix (y3k safe)
       ! #:)
           if ( ( m == 0 ) .or. ( n == 0 ) ) then
              iwork(1:3) = 0
              work(1:7) = 0
              return
           endif
           ! determine whether the matrix u should be m x n or m x m
           if ( lsvec ) then
              n1 = n
              if ( stdlib_lsame( jobu, 'F' ) ) n1 = m
           end if
           ! set numerical parameters
      ! !    note: make sure stdlib_slamch() does not fail on the target architecture.
           epsln = stdlib_slamch('EPSILON')
           sfmin = stdlib_slamch('SAFEMINIMUM')
           small = sfmin / epsln
           big   = stdlib_slamch('O')
           ! big   = one / sfmin
           ! initialize sva(1:n) = diag( ||a e_i||_2 )_1^n
      ! (!)  if necessary, scale sva() to protect the largest norm from
           ! overflow. it is possible that this scaling pushes the smallest
           ! column norm left from the underflow threshold (extreme case).
           scalem  = one / sqrt(real(m,KIND=sp)*real(n,KIND=sp))
           noscal  = .true.
           goscal  = .true.
           do p = 1, n
              aapp = zero
              aaqq = one
              call stdlib_slassq( m, a(1,p), 1, aapp, aaqq )
              if ( aapp > big ) then
                 info = - 9
                 call stdlib_xerbla( 'SGEJSV', -info )
                 return
              end if
              aaqq = sqrt(aaqq)
              if ( ( aapp < (big / aaqq) ) .and. noscal  ) then
                 sva(p)  = aapp * aaqq
              else
                 noscal  = .false.
                 sva(p)  = aapp * ( aaqq * scalem )
                 if ( goscal ) then
                    goscal = .false.
                    call stdlib_sscal( p-1, scalem, sva, 1 )
                 end if
              end if
           end do
           if ( noscal ) scalem = one
           aapp = zero
           aaqq = big
           do p = 1, n
              aapp = max( aapp, sva(p) )
              if ( sva(p) /= zero ) aaqq = min( aaqq, sva(p) )
           end do
           ! quick return for zero m x n matrix
       ! #:)
           if ( aapp == zero ) then
              if ( lsvec ) call stdlib_slaset( 'G', m, n1, zero, one, u, ldu )
              if ( rsvec ) call stdlib_slaset( 'G', n, n,  zero, one, v, ldv )
              work(1) = one
              work(2) = one
              if ( errest ) work(3) = one
              if ( lsvec .and. rsvec ) then
                 work(4) = one
                 work(5) = one
              end if
              if ( l2tran ) then
                 work(6) = zero
                 work(7) = zero
              end if
              iwork(1) = 0
              iwork(2) = 0
              iwork(3) = 0
              return
           end if
           ! issue warning if denormalized column norms detected. override the
           ! high relative accuracy request. issue licence to kill columns
           ! (set them to zero) whose norm is less than sigma_max / big (roughly).
       ! #:(
           warning = 0
           if ( aaqq <= sfmin ) then
              l2rank = .true.
              l2kill = .true.
              warning = 1
           end if
           ! quick return for one-column matrix
       ! #:)
           if ( n == 1 ) then
              if ( lsvec ) then
                 call stdlib_slascl( 'G',0,0,sva(1),scalem, m,1,a(1,1),lda,ierr )
                 call stdlib_slacpy( 'A', m, 1, a, lda, u, ldu )
                 ! computing all m left singular vectors of the m x 1 matrix
                 if ( n1 /= n  ) then
                    call stdlib_sgeqrf( m, n, u,ldu, work, work(n+1),lwork-n,ierr )
                    call stdlib_sorgqr( m,n1,1, u,ldu,work,work(n+1),lwork-n,ierr )
                    call stdlib_scopy( m, a(1,1), 1, u(1,1), 1 )
                 end if
              end if
              if ( rsvec ) then
                  v(1,1) = one
              end if
              if ( sva(1) < (big*scalem) ) then
                 sva(1)  = sva(1) / scalem
                 scalem  = one
              end if
              work(1) = one / scalem
              work(2) = one
              if ( sva(1) /= zero ) then
                 iwork(1) = 1
                 if ( ( sva(1) / scalem) >= sfmin ) then
                    iwork(2) = 1
                 else
                    iwork(2) = 0
                 end if
              else
                 iwork(1) = 0
                 iwork(2) = 0
              end if
              iwork(3) = 0
              if ( errest ) work(3) = one
              if ( lsvec .and. rsvec ) then
                 work(4) = one
                 work(5) = one
              end if
              if ( l2tran ) then
                 work(6) = zero
                 work(7) = zero
              end if
              return
           end if
           transp = .false.
           l2tran = l2tran .and. ( m == n )
           aatmax = -one
           aatmin =  big
           if ( rowpiv .or. l2tran ) then
           ! compute the row norms, needed to determine row pivoting sequence
           ! (in the case of heavily row weighted a, row pivoting is strongly
           ! advised) and to collect information needed to compare the
           ! structures of a * a^t and a^t * a (in the case l2tran==.true.).
              if ( l2tran ) then
                 do p = 1, m
                    xsc   = zero
                    temp1 = one
                    call stdlib_slassq( n, a(p,1), lda, xsc, temp1 )
                    ! stdlib_slassq gets both the ell_2 and the ell_infinity norm
                    ! in one pass through the vector
                    work(m+n+p)  = xsc * scalem
                    work(n+p)    = xsc * (scalem*sqrt(temp1))
                    aatmax = max( aatmax, work(n+p) )
                    if (work(n+p) /= zero) aatmin = min(aatmin,work(n+p))
                 end do
              else
                 do p = 1, m
                    work(m+n+p) = scalem*abs( a(p,stdlib_isamax(n,a(p,1),lda)) )
                    aatmax = max( aatmax, work(m+n+p) )
                    aatmin = min( aatmin, work(m+n+p) )
                 end do
              end if
           end if
           ! for square matrix a try to determine whether a^t  would be  better
           ! input for the preconditioned jacobi svd, with faster convergence.
           ! the decision is based on an o(n) function of the vector of column
           ! and row norms of a, based on the shannon entropy. this should give
           ! the right choice in most cases when the difference actually matters.
           ! it may fail and pick the slower converging side.
           entra  = zero
           entrat = zero
           if ( l2tran ) then
              xsc   = zero
              temp1 = one
              call stdlib_slassq( n, sva, 1, xsc, temp1 )
              temp1 = one / temp1
              entra = zero
              do p = 1, n
                 big1  = ( ( sva(p) / xsc )**2 ) * temp1
                 if ( big1 /= zero ) entra = entra + big1 * log(big1)
              end do
              entra = - entra / log(real(n,KIND=sp))
              ! now, sva().^2/trace(a^t * a) is a point in the probability simplex.
              ! it is derived from the diagonal of  a^t * a.  do the same with the
              ! diagonal of a * a^t, compute the entropy of the corresponding
              ! probability distribution. note that a * a^t and a^t * a have the
              ! same trace.
              entrat = zero
              do p = n+1, n+m
                 big1 = ( ( work(p) / xsc )**2 ) * temp1
                 if ( big1 /= zero ) entrat = entrat + big1 * log(big1)
              end do
              entrat = - entrat / log(real(m,KIND=sp))
              ! analyze the entropies and decide a or a^t. smaller entropy
              ! usually means better input for the algorithm.
              transp = ( entrat < entra )
              ! if a^t is better than a, transpose a.
              if ( transp ) then
                 ! in an optimal implementation, this trivial transpose
                 ! should be replaced with faster transpose.
                 do p = 1, n - 1
                    do q = p + 1, n
                        temp1 = a(q,p)
                       a(q,p) = a(p,q)
                       a(p,q) = temp1
                    end do
                 end do
                 do p = 1, n
                    work(m+n+p) = sva(p)
                    sva(p)      = work(n+p)
                 end do
                 temp1  = aapp
                 aapp   = aatmax
                 aatmax = temp1
                 temp1  = aaqq
                 aaqq   = aatmin
                 aatmin = temp1
                 kill   = lsvec
                 lsvec  = rsvec
                 rsvec  = kill
                 if ( lsvec ) n1 = n
                 rowpiv = .true.
              end if
           end if
           ! end if l2tran
           ! scale the matrix so that its maximal singular value remains less
           ! than sqrt(big) -- the matrix is scaled so that its maximal column
           ! has euclidean norm equal to sqrt(big/n). the only reason to keep
           ! sqrt(big) instead of big is the fact that stdlib_sgejsv uses lapack and
           ! blas routines that, in some implementations, are not capable of
           ! working in the full interval [sfmin,big] and that they may provoke
           ! overflows in the intermediate results. if the singular values spread
           ! from sfmin to big, then stdlib_sgesvj will compute them. so, in that case,
           ! one should use stdlib_sgesvj instead of stdlib_sgejsv.
           big1   = sqrt( big )
           temp1  = sqrt( big / real(n,KIND=sp) )
           call stdlib_slascl( 'G', 0, 0, aapp, temp1, n, 1, sva, n, ierr )
           if ( aaqq > (aapp * sfmin) ) then
               aaqq = ( aaqq / aapp ) * temp1
           else
               aaqq = ( aaqq * temp1 ) / aapp
           end if
           temp1 = temp1 * scalem
           call stdlib_slascl( 'G', 0, 0, aapp, temp1, m, n, a, lda, ierr )
           ! to undo scaling at the end of this procedure, multiply the
           ! computed singular values with uscal2 / uscal1.
           uscal1 = temp1
           uscal2 = aapp
           if ( l2kill ) then
              ! l2kill enforces computation of nonzero singular values in
              ! the restricted range of condition number of the initial a,
              ! sigma_max(a) / sigma_min(a) approx. sqrt(big)/sqrt(sfmin).
              xsc = sqrt( sfmin )
           else
              xsc = small
              ! now, if the condition number of a is too big,
              ! sigma_max(a) / sigma_min(a) > sqrt(big/n) * epsln / sfmin,
              ! as a precaution measure, the full svd is computed using stdlib_sgesvj
              ! with accumulated jacobi rotations. this provides numerically
              ! more robust computation, at the cost of slightly increased run
              ! time. depending on the concrete implementation of blas and lapack
              ! (i.e. how they behave in presence of extreme ill-conditioning) the
              ! implementor may decide to remove this switch.
              if ( ( aaqq<sqrt(sfmin) ) .and. lsvec .and. rsvec ) then
                 jracc = .true.
              end if
           end if
           if ( aaqq < xsc ) then
              do p = 1, n
                 if ( sva(p) < xsc ) then
                    call stdlib_slaset( 'A', m, 1, zero, zero, a(1,p), lda )
                    sva(p) = zero
                 end if
              end do
           end if
           ! preconditioning using qr factorization with pivoting
           if ( rowpiv ) then
              ! optional row permutation (bjoerck row pivoting):
              ! a result by cox and higham shows that the bjoerck's
              ! row pivoting combined with standard column pivoting
              ! has similar effect as powell-reid complete pivoting.
              ! the ell-infinity norms of a are made nonincreasing.
              do p = 1, m - 1
                 q = stdlib_isamax( m-p+1, work(m+n+p), 1 ) + p - 1
                 iwork(2*n+p) = q
                 if ( p /= q ) then
                    temp1       = work(m+n+p)
                    work(m+n+p) = work(m+n+q)
                    work(m+n+q) = temp1
                 end if
              end do
              call stdlib_slaswp( n, a, lda, 1, m-1, iwork(2*n+1), 1 )
           end if
           ! end of the preparation phase (scaling, optional sorting and
           ! transposing, optional flushing of small columns).
           ! preconditioning
           ! if the full svd is needed, the right singular vectors are computed
           ! from a matrix equation, and for that we need theoretical analysis
           ! of the businger-golub pivoting. so we use stdlib_sgeqp3 as the first rr qrf.
           ! in all other cases the first rr qrf can be chosen by other criteria
           ! (eg speed by replacing global with restricted window pivoting, such
           ! as in sgeqpx from toms # 782). good results will be obtained using
           ! sgeqpx with properly (!) chosen numerical parameters.
           ! any improvement of stdlib_sgeqp3 improves overall performance of stdlib_sgejsv.
           ! a * p1 = q1 * [ r1^t 0]^t:
           do p = 1, n
              ! All Columns Are Free Columns
              iwork(p) = 0
           end do
           call stdlib_sgeqp3( m,n,a,lda, iwork,work, work(n+1),lwork-n, ierr )
           ! the upper triangular matrix r1 from the first qrf is inspected for
           ! rank deficiency and possibilities for deflation, or possible
           ! ill-conditioning. depending on the user specified flag l2rank,
           ! the procedure explores possibilities to reduce the numerical
           ! rank by inspecting the computed upper triangular factor. if
           ! l2rank or l2aber are up, then stdlib_sgejsv will compute the svd of
           ! a + da, where ||da|| <= f(m,n)*epsln.
           nr = 1
           if ( l2aber ) then
              ! standard absolute error bound suffices. all sigma_i with
              ! sigma_i < n*epsln*||a|| are flushed to zero. this is an
              ! aggressive enforcement of lower numerical rank by introducing a
              ! backward error of the order of n*epsln*||a||.
              temp1 = sqrt(real(n,KIND=sp))*epsln
              do p = 2, n
                 if ( abs(a(p,p)) >= (temp1*abs(a(1,1))) ) then
                    nr = nr + 1
                 else
                    go to 3002
                 end if
              end do
              3002 continue
           else if ( l2rank ) then
              ! .. similarly as above, only slightly more gentle (less aggressive).
              ! sudden drop on the diagonal of r1 is used as the criterion for
              ! close-to-rank-deficient.
              temp1 = sqrt(sfmin)
              do p = 2, n
                 if ( ( abs(a(p,p)) < (epsln*abs(a(p-1,p-1))) ) .or.( abs(a(p,p)) < small ) .or.( &
                           l2kill .and. (abs(a(p,p)) < temp1) ) ) go to 3402
                 nr = nr + 1
              end do
              3402 continue
           else
              ! the goal is high relative accuracy. however, if the matrix
              ! has high scaled condition number the relative accuracy is in
              ! general not feasible. later on, a condition number estimator
              ! will be deployed to estimate the scaled condition number.
              ! here we just remove the underflowed part of the triangular
              ! factor. this prevents the situation in which the code is
              ! working hard to get the accuracy not warranted by the data.
              temp1  = sqrt(sfmin)
              do p = 2, n
                 if ( ( abs(a(p,p)) < small ) .or.( l2kill .and. (abs(a(p,p)) < temp1) ) ) go to &
                           3302
                 nr = nr + 1
              end do
              3302 continue
           end if
           almort = .false.
           if ( nr == n ) then
              maxprj = one
              do p = 2, n
                 temp1  = abs(a(p,p)) / sva(iwork(p))
                 maxprj = min( maxprj, temp1 )
              end do
              if ( maxprj**2 >= one - real(n,KIND=sp)*epsln ) almort = .true.
           end if
           sconda = - one
           condr1 = - one
           condr2 = - one
           if ( errest ) then
              if ( n == nr ) then
                 if ( rsvec ) then
                    ! V Is Available As Workspace
                    call stdlib_slacpy( 'U', n, n, a, lda, v, ldv )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_sscal( p, one/temp1, v(1,p), 1 )
                    end do
                    call stdlib_spocon( 'U', n, v, ldv, one, temp1,work(n+1), iwork(2*n+m+1), &
                              ierr )
                 else if ( lsvec ) then
                    ! U Is Available As Workspace
                    call stdlib_slacpy( 'U', n, n, a, lda, u, ldu )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_sscal( p, one/temp1, u(1,p), 1 )
                    end do
                    call stdlib_spocon( 'U', n, u, ldu, one, temp1,work(n+1), iwork(2*n+m+1), &
                              ierr )
                 else
                    call stdlib_slacpy( 'U', n, n, a, lda, work(n+1), n )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_sscal( p, one/temp1, work(n+(p-1)*n+1), 1 )
                    end do
                 ! The Columns Of R Are Scaled To Have Unit Euclidean Lengths
                    call stdlib_spocon( 'U', n, work(n+1), n, one, temp1,work(n+n*n+1), iwork(2*n+&
                              m+1), ierr )
                 end if
                 sconda = one / sqrt(temp1)
                 ! sconda is an estimate of sqrt(||(r^t * r)^(-1)||_1).
                 ! n^(-1/4) * sconda <= ||r^(-1)||_2 <= n^(1/4) * sconda
              else
                 sconda = - one
              end if
           end if
           l2pert = l2pert .and. ( abs( a(1,1)/a(nr,nr) ) > sqrt(big1) )
           ! if there is no violent scaling, artificial perturbation is not needed.
           ! phase 3:
           if ( .not. ( rsvec .or. lsvec ) ) then
               ! singular values only
               ! .. transpose a(1:nr,1:n)
              do p = 1, min( n-1, nr )
                 call stdlib_scopy( n-p, a(p,p+1), lda, a(p+1,p), 1 )
              end do
              ! the following two do-loops introduce small relative perturbation
              ! into the strict upper triangle of the lower triangular matrix.
              ! small entries below the main diagonal are also changed.
              ! this modification is useful if the computing environment does not
              ! provide/allow flush to zero underflow, for it prevents many
              ! annoying denormalized numbers in case of strongly scaled matrices.
              ! the perturbation is structured so that it does not introduce any
              ! new perturbation of the singular values, and it does not destroy
              ! the job done by the preconditioner.
              ! the licence for this perturbation is in the variable l2pert, which
              ! should be .false. if flush to zero underflow is active.
              if ( .not. almort ) then
                 if ( l2pert ) then
                    ! xsc = sqrt(small)
                    xsc = epsln / real(n,KIND=sp)
                    do q = 1, nr
                       temp1 = xsc*abs(a(q,q))
                       do p = 1, n
                          if ( ( (p>q) .and. (abs(a(p,q))<=temp1) ).or. ( p < q ) )a(p,q) = sign( &
                                    temp1, a(p,q) )
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_slaset( 'U', nr-1,nr-1, zero,zero, a(1,2),lda )
                 end if
                  ! Second Preconditioning Using The Qr Factorization
                 call stdlib_sgeqrf( n,nr, a,lda, work, work(n+1),lwork-n, ierr )
                 ! And Transpose Upper To Lower Triangular
                 do p = 1, nr - 1
                    call stdlib_scopy( nr-p, a(p,p+1), lda, a(p+1,p), 1 )
                 end do
              end if
                 ! row-cyclic jacobi svd algorithm with column pivoting
                 ! .. again some perturbation (a "background noise") is added
                 ! to drown denormals
                 if ( l2pert ) then
                    ! xsc = sqrt(small)
                    xsc = epsln / real(n,KIND=sp)
                    do q = 1, nr
                       temp1 = xsc*abs(a(q,q))
                       do p = 1, nr
                          if ( ( (p>q) .and. (abs(a(p,q))<=temp1) ).or. ( p < q ) )a(p,q) = sign( &
                                    temp1, a(p,q) )
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_slaset( 'U', nr-1, nr-1, zero, zero, a(1,2), lda )
                 end if
                 ! .. and one-sided jacobi rotations are started on a lower
                 ! triangular matrix (plus perturbation which is ignored in
                 ! the part which destroys triangular form (confusing?!))
                 call stdlib_sgesvj( 'L', 'NOU', 'NOV', nr, nr, a, lda, sva,n, v, ldv, work, &
                           lwork, info )
                 scalem  = work(1)
                 numrank = nint(work(2),KIND=ilp)
           else if ( rsvec .and. ( .not. lsvec ) ) then
              ! -> singular values and right singular vectors <-
              if ( almort ) then
                 ! In This Case Nr Equals N
                 do p = 1, nr
                    call stdlib_scopy( n-p+1, a(p,p), lda, v(p,p), 1 )
                 end do
                 if (nr>1) call stdlib_slaset( 'UPPER', nr-1, nr-1, zero, zero, v(1,2), ldv )
                 call stdlib_sgesvj( 'L','U','N', n, nr, v,ldv, sva, nr, a,lda,work, lwork, info )
                           
                 scalem  = work(1)
                 numrank = nint(work(2),KIND=ilp)
              else
              ! .. two more qr factorizations ( one qrf is not enough, two require
              ! accumulated product of jacobi rotations, three are perfect )
                 if (nr>1) call stdlib_slaset( 'LOWER', nr-1, nr-1, zero, zero, a(2,1), lda )
                 call stdlib_sgelqf( nr, n, a, lda, work, work(n+1), lwork-n, ierr)
                 call stdlib_slacpy( 'LOWER', nr, nr, a, lda, v, ldv )
                 if (nr>1) call stdlib_slaset( 'UPPER', nr-1, nr-1, zero, zero, v(1,2), ldv )
                 call stdlib_sgeqrf( nr, nr, v, ldv, work(n+1), work(2*n+1),lwork-2*n, ierr )
                           
                 do p = 1, nr
                    call stdlib_scopy( nr-p+1, v(p,p), ldv, v(p,p), 1 )
                 end do
                 if (nr>1) call stdlib_slaset( 'UPPER', nr-1, nr-1, zero, zero, v(1,2), ldv )
                 call stdlib_sgesvj( 'LOWER', 'U','N', nr, nr, v,ldv, sva, nr, u,ldu, work(n+1), &
                           lwork-n, info )
                 scalem  = work(n+1)
                 numrank = nint(work(n+2),KIND=ilp)
                 if ( nr < n ) then
                    call stdlib_slaset( 'A',n-nr, nr, zero,zero, v(nr+1,1),   ldv )
                    call stdlib_slaset( 'A',nr, n-nr, zero,zero, v(1,nr+1),   ldv )
                    call stdlib_slaset( 'A',n-nr,n-nr,zero,one, v(nr+1,nr+1), ldv )
                 end if
              call stdlib_sormlq( 'LEFT', 'TRANSPOSE', n, n, nr, a, lda, work,v, ldv, work(n+1), &
                        lwork-n, ierr )
              end if
              do p = 1, n
                 call stdlib_scopy( n, v(p,1), ldv, a(iwork(p),1), lda )
              end do
              call stdlib_slacpy( 'ALL', n, n, a, lda, v, ldv )
              if ( transp ) then
                 call stdlib_slacpy( 'ALL', n, n, v, ldv, u, ldu )
              end if
           else if ( lsvec .and. ( .not. rsvec ) ) then
              ! Singular Values And Left Singular Vectors                 
              ! Second Preconditioning Step To Avoid Need To Accumulate
              ! jacobi rotations in the jacobi iterations.
              do p = 1, nr
                 call stdlib_scopy( n-p+1, a(p,p), lda, u(p,p), 1 )
              end do
              if (nr>1) call stdlib_slaset( 'UPPER', nr-1, nr-1, zero, zero, u(1,2), ldu )
              call stdlib_sgeqrf( n, nr, u, ldu, work(n+1), work(2*n+1),lwork-2*n, ierr )
              do p = 1, nr - 1
                 call stdlib_scopy( nr-p, u(p,p+1), ldu, u(p+1,p), 1 )
              end do
              if (nr>1) call stdlib_slaset( 'UPPER', nr-1, nr-1, zero, zero, u(1,2), ldu )
              call stdlib_sgesvj( 'LOWER', 'U', 'N', nr,nr, u, ldu, sva, nr, a,lda, work(n+1), &
                        lwork-n, info )
              scalem  = work(n+1)
              numrank = nint(work(n+2),KIND=ilp)
              if ( nr < m ) then
                 call stdlib_slaset( 'A',  m-nr, nr,zero, zero, u(nr+1,1), ldu )
                 if ( nr < n1 ) then
                    call stdlib_slaset( 'A',nr, n1-nr, zero, zero, u(1,nr+1), ldu )
                    call stdlib_slaset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                 end if
              end if
              call stdlib_sormqr( 'LEFT', 'NO TR', m, n1, n, a, lda, work, u,ldu, work(n+1), &
                        lwork-n, ierr )
              if ( rowpiv )call stdlib_slaswp( n1, u, ldu, 1, m-1, iwork(2*n+1), -1 )
              do p = 1, n1
                 xsc = one / stdlib_snrm2( m, u(1,p), 1 )
                 call stdlib_sscal( m, xsc, u(1,p), 1 )
              end do
              if ( transp ) then
                 call stdlib_slacpy( 'ALL', n, n, u, ldu, v, ldv )
              end if
           else
              ! Full Svd 
              if ( .not. jracc ) then
              if ( .not. almort ) then
                 ! second preconditioning step (qrf [with pivoting])
                 ! note that the composition of transpose, qrf and transpose is
                 ! equivalent to an lqf call. since in many libraries the qrf
                 ! seems to be better optimized than the lqf, we do explicit
                 ! transpose and use the qrf. this is subject to changes in an
                 ! optimized implementation of stdlib_sgejsv.
                 do p = 1, nr
                    call stdlib_scopy( n-p+1, a(p,p), lda, v(p,p), 1 )
                 end do
                 ! The Following Two Loops Perturb Small Entries To Avoid
                 ! denormals in the second qr factorization, where they are
                 ! as good as zeros. this is done to avoid painfully slow
                 ! computation with denormals. the relative size of the perturbation
                 ! is a parameter that can be changed by the implementer.
                 ! this perturbation device will be obsolete on machines with
                 ! properly implemented arithmetic.
                 ! to switch it off, set l2pert=.false. to remove it from  the
                 ! code, remove the action under l2pert=.true., leave the else part.
                 ! the following two loops should be blocked and fused with the
                 ! transposed copy above.
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do q = 1, nr
                       temp1 = xsc*abs( v(q,q) )
                       do p = 1, n
                          if ( ( p > q ) .and. ( abs(v(p,q)) <= temp1 ).or. ( p < q ) )v(p,q) = &
                                    sign( temp1, v(p,q) )
                          if ( p < q ) v(p,q) = - v(p,q)
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_slaset( 'U', nr-1, nr-1, zero, zero, v(1,2), ldv )
                 end if
                 ! estimate the row scaled condition number of r1
                 ! (if r1 is rectangular, n > nr, then the condition number
                 ! of the leading nr x nr submatrix is estimated.)
                 call stdlib_slacpy( 'L', nr, nr, v, ldv, work(2*n+1), nr )
                 do p = 1, nr
                    temp1 = stdlib_snrm2(nr-p+1,work(2*n+(p-1)*nr+p),1)
                    call stdlib_sscal(nr-p+1,one/temp1,work(2*n+(p-1)*nr+p),1)
                 end do
                 call stdlib_spocon('LOWER',nr,work(2*n+1),nr,one,temp1,work(2*n+nr*nr+1),iwork(m+&
                           2*n+1),ierr)
                 condr1 = one / sqrt(temp1)
                 ! Here Need A Second Opinion On The Condition Number
                 ! Then Assume Worst Case Scenario
                 ! r1 is ok for inverse <=> condr1 < real(n,KIND=sp)
                 ! more conservative    <=> condr1 < sqrt(real(n,KIND=sp))
                 cond_ok = sqrt(real(nr,KIND=sp))
      ! [tp]       cond_ok is a tuning parameter.
                 if ( condr1 < cond_ok ) then
                    ! .. the second qrf without pivoting. note: in an optimized
                    ! implementation, this qrf should be implemented as the qrf
                    ! of a lower triangular matrix.
                    ! r1^t = q2 * r2
                    call stdlib_sgeqrf( n, nr, v, ldv, work(n+1), work(2*n+1),lwork-2*n, ierr )
                              
                    if ( l2pert ) then
                       xsc = sqrt(small)/epsln
                       do p = 2, nr
                          do q = 1, p - 1
                             temp1 = xsc * min(abs(v(p,p)),abs(v(q,q)))
                             if ( abs(v(q,p)) <= temp1 )v(q,p) = sign( temp1, v(q,p) )
                          end do
                       end do
                    end if
                    if ( nr /= n )call stdlib_slacpy( 'A', n, nr, v, ldv, work(2*n+1), n )
                    ! .. save ...
                 ! This Transposed Copy Should Be Better Than Naive
                    do p = 1, nr - 1
                       call stdlib_scopy( nr-p, v(p,p+1), ldv, v(p+1,p), 1 )
                    end do
                    condr2 = condr1
                 else
                    ! .. ill-conditioned case: second qrf with pivoting
                    ! note that windowed pivoting would be equally good
                    ! numerically, and more run-time efficient. so, in
                    ! an optimal implementation, the next call to stdlib_sgeqp3
                    ! should be replaced with eg. call sgeqpx (acm toms #782)
                    ! with properly (carefully) chosen parameters.
                    ! r1^t * p2 = q2 * r2
                    do p = 1, nr
                       iwork(n+p) = 0
                    end do
                    call stdlib_sgeqp3( n, nr, v, ldv, iwork(n+1), work(n+1),work(2*n+1), lwork-&
                              2*n, ierr )
      ! *               call stdlib_sgeqrf( n, nr, v, ldv, work(n+1), work(2*n+1),
      ! *     $              lwork-2*n, ierr )
                    if ( l2pert ) then
                       xsc = sqrt(small)
                       do p = 2, nr
                          do q = 1, p - 1
                             temp1 = xsc * min(abs(v(p,p)),abs(v(q,q)))
                             if ( abs(v(q,p)) <= temp1 )v(q,p) = sign( temp1, v(q,p) )
                          end do
                       end do
                    end if
                    call stdlib_slacpy( 'A', n, nr, v, ldv, work(2*n+1), n )
                    if ( l2pert ) then
                       xsc = sqrt(small)
                       do p = 2, nr
                          do q = 1, p - 1
                             temp1 = xsc * min(abs(v(p,p)),abs(v(q,q)))
                             v(p,q) = - sign( temp1, v(q,p) )
                          end do
                       end do
                    else
                       if (nr>1) call stdlib_slaset( 'L',nr-1,nr-1,zero,zero,v(2,1),ldv )
                    end if
                    ! now, compute r2 = l3 * q3, the lq factorization.
                    call stdlib_sgelqf( nr, nr, v, ldv, work(2*n+n*nr+1),work(2*n+n*nr+nr+1), &
                              lwork-2*n-n*nr-nr, ierr )
                    ! And Estimate The Condition Number
                    call stdlib_slacpy( 'L',nr,nr,v,ldv,work(2*n+n*nr+nr+1),nr )
                    do p = 1, nr
                       temp1 = stdlib_snrm2( p, work(2*n+n*nr+nr+p), nr )
                       call stdlib_sscal( p, one/temp1, work(2*n+n*nr+nr+p), nr )
                    end do
                    call stdlib_spocon( 'L',nr,work(2*n+n*nr+nr+1),nr,one,temp1,work(2*n+n*nr+nr+&
                              nr*nr+1),iwork(m+2*n+1),ierr )
                    condr2 = one / sqrt(temp1)
                    if ( condr2 >= cond_ok ) then
                       ! Save The Householder Vectors Used For Q3
                       ! (this overwrites the copy of r2, as it will not be
                       ! needed in this branch, but it does not overwritte the
                       ! huseholder vectors of q2.).
                       call stdlib_slacpy( 'U', nr, nr, v, ldv, work(2*n+1), n )
                       ! And The Rest Of The Information On Q3 Is In
                       ! work(2*n+n*nr+1:2*n+n*nr+n)
                    end if
                 end if
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do q = 2, nr
                       temp1 = xsc * v(q,q)
                       do p = 1, q - 1
                          ! v(p,q) = - sign( temp1, v(q,p) )
                          v(p,q) = - sign( temp1, v(p,q) )
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_slaset( 'U', nr-1,nr-1, zero,zero, v(1,2), ldv )
                 end if
              ! second preconditioning finished; continue with jacobi svd
              ! the input matrix is lower trinagular.
              ! recover the right singular vectors as solution of a well
              ! conditioned triangular matrix equation.
                 if ( condr1 < cond_ok ) then
                    call stdlib_sgesvj( 'L','U','N',nr,nr,v,ldv,sva,nr,u,ldu,work(2*n+n*nr+nr+1),&
                              lwork-2*n-n*nr-nr,info )
                    scalem  = work(2*n+n*nr+nr+1)
                    numrank = nint(work(2*n+n*nr+nr+2),KIND=ilp)
                    do p = 1, nr
                       call stdlib_scopy( nr, v(1,p), 1, u(1,p), 1 )
                       call stdlib_sscal( nr, sva(p),    v(1,p), 1 )
                    end do
              ! Pick The Right Matrix Equation And Solve It
                    if ( nr == n ) then
       ! :))             .. best case, r1 is inverted. the solution of this matrix
                       ! equation is q2*v2 = the product of the jacobi rotations
                       ! used in stdlib_sgesvj, premultiplied with the orthogonal matrix
                       ! from the second qr factorization.
                       call stdlib_strsm( 'L','U','N','N', nr,nr,one, a,lda, v,ldv )
                    else
                       ! .. r1 is well conditioned, but non-square. transpose(r2)
                       ! is inverted to get the product of the jacobi rotations
                       ! used in stdlib_sgesvj. the q-factor from the second qr
                       ! factorization is then built in explicitly.
                       call stdlib_strsm('L','U','T','N',nr,nr,one,work(2*n+1),n,v,ldv)
                       if ( nr < n ) then
                         call stdlib_slaset('A',n-nr,nr,zero,zero,v(nr+1,1),ldv)
                         call stdlib_slaset('A',nr,n-nr,zero,zero,v(1,nr+1),ldv)
                         call stdlib_slaset('A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv)
                       end if
                       call stdlib_sormqr('L','N',n,n,nr,work(2*n+1),n,work(n+1),v,ldv,work(2*n+&
                                 n*nr+nr+1),lwork-2*n-n*nr-nr,ierr)
                    end if
                 else if ( condr2 < cond_ok ) then
       ! :)           .. the input matrix a is very likely a relative of
                    ! the kahan matrix :)
                    ! the matrix r2 is inverted. the solution of the matrix equation
                    ! is q3^t*v3 = the product of the jacobi rotations (appplied to
                    ! the lower triangular l3 from the lq factorization of
                    ! r2=l3*q3), pre-multiplied with the transposed q3.
                    call stdlib_sgesvj( 'L', 'U', 'N', nr, nr, v, ldv, sva, nr, u,ldu, work(2*n+&
                              n*nr+nr+1), lwork-2*n-n*nr-nr, info )
                    scalem  = work(2*n+n*nr+nr+1)
                    numrank = nint(work(2*n+n*nr+nr+2),KIND=ilp)
                    do p = 1, nr
                       call stdlib_scopy( nr, v(1,p), 1, u(1,p), 1 )
                       call stdlib_sscal( nr, sva(p),    u(1,p), 1 )
                    end do
                    call stdlib_strsm('L','U','N','N',nr,nr,one,work(2*n+1),n,u,ldu)
                    ! Apply The Permutation From The Second Qr Factorization
                    do q = 1, nr
                       do p = 1, nr
                          work(2*n+n*nr+nr+iwork(n+p)) = u(p,q)
                       end do
                       do p = 1, nr
                          u(p,q) = work(2*n+n*nr+nr+p)
                       end do
                    end do
                    if ( nr < n ) then
                       call stdlib_slaset( 'A',n-nr,nr,zero,zero,v(nr+1,1),ldv )
                       call stdlib_slaset( 'A',nr,n-nr,zero,zero,v(1,nr+1),ldv )
                       call stdlib_slaset( 'A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv )
                    end if
                    call stdlib_sormqr( 'L','N',n,n,nr,work(2*n+1),n,work(n+1),v,ldv,work(2*n+&
                              n*nr+nr+1),lwork-2*n-n*nr-nr,ierr )
                 else
                    ! last line of defense.
       ! #:(          this is a rather pathological case: no scaled condition
                    ! improvement after two pivoted qr factorizations. other
                    ! possibility is that the rank revealing qr factorization
                    ! or the condition estimator has failed, or the cond_ok
                    ! is set very close to one (which is unnecessary). normally,
                    ! this branch should never be executed, but in rare cases of
                    ! failure of the rrqr or condition estimator, the last line of
                    ! defense ensures that stdlib_sgejsv completes the task.
                    ! compute the full svd of l3 using stdlib_sgesvj with explicit
                    ! accumulation of jacobi rotations.
                    call stdlib_sgesvj( 'L', 'U', 'V', nr, nr, v, ldv, sva, nr, u,ldu, work(2*n+&
                              n*nr+nr+1), lwork-2*n-n*nr-nr, info )
                    scalem  = work(2*n+n*nr+nr+1)
                    numrank = nint(work(2*n+n*nr+nr+2),KIND=ilp)
                    if ( nr < n ) then
                       call stdlib_slaset( 'A',n-nr,nr,zero,zero,v(nr+1,1),ldv )
                       call stdlib_slaset( 'A',nr,n-nr,zero,zero,v(1,nr+1),ldv )
                       call stdlib_slaset( 'A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv )
                    end if
                    call stdlib_sormqr( 'L','N',n,n,nr,work(2*n+1),n,work(n+1),v,ldv,work(2*n+&
                              n*nr+nr+1),lwork-2*n-n*nr-nr,ierr )
                    call stdlib_sormlq( 'L', 'T', nr, nr, nr, work(2*n+1), n,work(2*n+n*nr+1), u, &
                              ldu, work(2*n+n*nr+nr+1),lwork-2*n-n*nr-nr, ierr )
                    do q = 1, nr
                       do p = 1, nr
                          work(2*n+n*nr+nr+iwork(n+p)) = u(p,q)
                       end do
                       do p = 1, nr
                          u(p,q) = work(2*n+n*nr+nr+p)
                       end do
                    end do
                 end if
                 ! permute the rows of v using the (column) permutation from the
                 ! first qrf. also, scale the columns to make them unit in
                 ! euclidean norm. this applies to all cases.
                 temp1 = sqrt(real(n,KIND=sp)) * epsln
                 do q = 1, n
                    do p = 1, n
                       work(2*n+n*nr+nr+iwork(p)) = v(p,q)
                    end do
                    do p = 1, n
                       v(p,q) = work(2*n+n*nr+nr+p)
                    end do
                    xsc = one / stdlib_snrm2( n, v(1,q), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_sscal( n, xsc, &
                              v(1,q), 1 )
                 end do
                 ! at this moment, v contains the right singular vectors of a.
                 ! next, assemble the left singular vector matrix u (m x n).
                 if ( nr < m ) then
                    call stdlib_slaset( 'A', m-nr, nr, zero, zero, u(nr+1,1), ldu )
                    if ( nr < n1 ) then
                       call stdlib_slaset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                       call stdlib_slaset('A',m-nr,n1-nr,zero,one,u(nr+1,nr+1),ldu)
                    end if
                 end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! matrix u. this applies to all cases.
                 call stdlib_sormqr( 'LEFT', 'NO_TR', m, n1, n, a, lda, work, u,ldu, work(n+1), &
                           lwork-n, ierr )
                 ! the columns of u are normalized. the cost is o(m*n) flops.
                 temp1 = sqrt(real(m,KIND=sp)) * epsln
                 do p = 1, nr
                    xsc = one / stdlib_snrm2( m, u(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_sscal( m, xsc, &
                              u(1,p), 1 )
                 end do
                 ! if the initial qrf is computed with row pivoting, the left
                 ! singular vectors must be adjusted.
                 if ( rowpiv )call stdlib_slaswp( n1, u, ldu, 1, m-1, iwork(2*n+1), -1 )
              else
              ! The Initial Matrix A Has Almost Orthogonal Columns And
              ! the second qrf is not needed
                 call stdlib_slacpy( 'UPPER', n, n, a, lda, work(n+1), n )
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do p = 2, n
                       temp1 = xsc * work( n + (p-1)*n + p )
                       do q = 1, p - 1
                          work(n+(q-1)*n+p)=-sign(temp1,work(n+(p-1)*n+q))
                       end do
                    end do
                 else
                    call stdlib_slaset( 'LOWER',n-1,n-1,zero,zero,work(n+2),n )
                 end if
                 call stdlib_sgesvj( 'UPPER', 'U', 'N', n, n, work(n+1), n, sva,n, u, ldu, work(n+&
                           n*n+1), lwork-n-n*n, info )
                 scalem  = work(n+n*n+1)
                 numrank = nint(work(n+n*n+2),KIND=ilp)
                 do p = 1, n
                    call stdlib_scopy( n, work(n+(p-1)*n+1), 1, u(1,p), 1 )
                    call stdlib_sscal( n, sva(p), work(n+(p-1)*n+1), 1 )
                 end do
                 call stdlib_strsm( 'LEFT', 'UPPER', 'NOTRANS', 'NO UD', n, n,one, a, lda, work(n+&
                           1), n )
                 do p = 1, n
                    call stdlib_scopy( n, work(n+p), n, v(iwork(p),1), ldv )
                 end do
                 temp1 = sqrt(real(n,KIND=sp))*epsln
                 do p = 1, n
                    xsc = one / stdlib_snrm2( n, v(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_sscal( n, xsc, &
                              v(1,p), 1 )
                 end do
                 ! assemble the left singular vector matrix u (m x n).
                 if ( n < m ) then
                    call stdlib_slaset( 'A',  m-n, n, zero, zero, u(n+1,1), ldu )
                    if ( n < n1 ) then
                       call stdlib_slaset( 'A',n,  n1-n, zero, zero,  u(1,n+1),ldu )
                       call stdlib_slaset( 'A',m-n,n1-n, zero, one,u(n+1,n+1),ldu )
                    end if
                 end if
                 call stdlib_sormqr( 'LEFT', 'NO TR', m, n1, n, a, lda, work, u,ldu, work(n+1), &
                           lwork-n, ierr )
                 temp1 = sqrt(real(m,KIND=sp))*epsln
                 do p = 1, n1
                    xsc = one / stdlib_snrm2( m, u(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_sscal( m, xsc, &
                              u(1,p), 1 )
                 end do
                 if ( rowpiv )call stdlib_slaswp( n1, u, ldu, 1, m-1, iwork(2*n+1), -1 )
              end if
              ! end of the  >> almost orthogonal case <<  in the full svd
              else
              ! this branch deploys a preconditioned jacobi svd with explicitly
              ! accumulated rotations. it is included as optional, mainly for
              ! experimental purposes. it does perform well, and can also be used.
              ! in this implementation, this branch will be automatically activated
              ! if the  condition number sigma_max(a) / sigma_min(a) is predicted
              ! to be greater than the overflow threshold. this is because the
              ! a posteriori computation of the singular vectors assumes robust
              ! implementation of blas and some lapack procedures, capable of working
              ! in presence of extreme values. since that is not always the case, ...
              do p = 1, nr
                 call stdlib_scopy( n-p+1, a(p,p), lda, v(p,p), 1 )
              end do
              if ( l2pert ) then
                 xsc = sqrt(small/epsln)
                 do q = 1, nr
                    temp1 = xsc*abs( v(q,q) )
                    do p = 1, n
                       if ( ( p > q ) .and. ( abs(v(p,q)) <= temp1 ).or. ( p < q ) )v(p,q) = sign(&
                                  temp1, v(p,q) )
                       if ( p < q ) v(p,q) = - v(p,q)
                    end do
                 end do
              else
                 if (nr>1) call stdlib_slaset( 'U', nr-1, nr-1, zero, zero, v(1,2), ldv )
              end if
              call stdlib_sgeqrf( n, nr, v, ldv, work(n+1), work(2*n+1),lwork-2*n, ierr )
              call stdlib_slacpy( 'L', n, nr, v, ldv, work(2*n+1), n )
              do p = 1, nr
                 call stdlib_scopy( nr-p+1, v(p,p), ldv, u(p,p), 1 )
              end do
              if ( l2pert ) then
                 xsc = sqrt(small/epsln)
                 do q = 2, nr
                    do p = 1, q - 1
                       temp1 = xsc * min(abs(u(p,p)),abs(u(q,q)))
                       u(p,q) = - sign( temp1, u(q,p) )
                    end do
                 end do
              else
                 if (nr>1) call stdlib_slaset('U', nr-1, nr-1, zero, zero, u(1,2), ldu )
              end if
              call stdlib_sgesvj( 'L', 'U', 'V', nr, nr, u, ldu, sva,n, v, ldv, work(2*n+n*nr+1), &
                        lwork-2*n-n*nr, info )
              scalem  = work(2*n+n*nr+1)
              numrank = nint(work(2*n+n*nr+2),KIND=ilp)
              if ( nr < n ) then
                 call stdlib_slaset( 'A',n-nr,nr,zero,zero,v(nr+1,1),ldv )
                 call stdlib_slaset( 'A',nr,n-nr,zero,zero,v(1,nr+1),ldv )
                 call stdlib_slaset( 'A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv )
              end if
              call stdlib_sormqr( 'L','N',n,n,nr,work(2*n+1),n,work(n+1),v,ldv,work(2*n+n*nr+nr+1)&
                        ,lwork-2*n-n*nr-nr,ierr )
                 ! permute the rows of v using the (column) permutation from the
                 ! first qrf. also, scale the columns to make them unit in
                 ! euclidean norm. this applies to all cases.
                 temp1 = sqrt(real(n,KIND=sp)) * epsln
                 do q = 1, n
                    do p = 1, n
                       work(2*n+n*nr+nr+iwork(p)) = v(p,q)
                    end do
                    do p = 1, n
                       v(p,q) = work(2*n+n*nr+nr+p)
                    end do
                    xsc = one / stdlib_snrm2( n, v(1,q), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_sscal( n, xsc, &
                              v(1,q), 1 )
                 end do
                 ! at this moment, v contains the right singular vectors of a.
                 ! next, assemble the left singular vector matrix u (m x n).
              if ( nr < m ) then
                 call stdlib_slaset( 'A',  m-nr, nr, zero, zero, u(nr+1,1), ldu )
                 if ( nr < n1 ) then
                    call stdlib_slaset( 'A',nr,  n1-nr, zero, zero,  u(1,nr+1),ldu )
                    call stdlib_slaset( 'A',m-nr,n1-nr, zero, one,u(nr+1,nr+1),ldu )
                 end if
              end if
              call stdlib_sormqr( 'LEFT', 'NO TR', m, n1, n, a, lda, work, u,ldu, work(n+1), &
                        lwork-n, ierr )
                 if ( rowpiv )call stdlib_slaswp( n1, u, ldu, 1, m-1, iwork(2*n+1), -1 )
              end if
              if ( transp ) then
                 ! .. swap u and v because the procedure worked on a^t
                 do p = 1, n
                    call stdlib_sswap( n, u(1,p), 1, v(1,p), 1 )
                 end do
              end if
           end if
           ! end of the full svd
           ! undo scaling, if necessary (and possible)
           if ( uscal2 <= (big/sva(1))*uscal1 ) then
              call stdlib_slascl( 'G', 0, 0, uscal1, uscal2, nr, 1, sva, n, ierr )
              uscal1 = one
              uscal2 = one
           end if
           if ( nr < n ) then
              do p = nr+1, n
                 sva(p) = zero
              end do
           end if
           work(1) = uscal2 * scalem
           work(2) = uscal1
           if ( errest ) work(3) = sconda
           if ( lsvec .and. rsvec ) then
              work(4) = condr1
              work(5) = condr2
           end if
           if ( l2tran ) then
              work(6) = entra
              work(7) = entrat
           end if
           iwork(1) = nr
           iwork(2) = numrank
           iwork(3) = warning
           return
     end subroutine stdlib_sgejsv

     module pure subroutine stdlib_dgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, ldu, &
     !! DGEJSV computes the singular value decomposition (SVD) of a real M-by-N
     !! matrix [A], where M >= N. The SVD of [A] is written as
     !! [A] = [U] * [SIGMA] * [V]^t,
     !! where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
     !! diagonal elements, [U] is an M-by-N (or M-by-M) orthonormal matrix, and
     !! [V] is an N-by-N orthogonal matrix. The diagonal elements of [SIGMA] are
     !! the singular values of [A]. The columns of [U] and [V] are the left and
     !! the right singular vectors of [A], respectively. The matrices [U] and [V]
     !! are computed and stored in the arrays U and V, respectively. The diagonal
     !! of [SIGMA] is computed and stored in the array SVA.
     !! DGEJSV can sometimes compute tiny singular values and their singular vectors much
     !! more accurately than other SVD routines, see below under Further Details.
               v, ldv,work, lwork, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldv, lwork, m, n
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: sva(n), u(ldu,*), v(ldv,*), work(lwork)
           integer(ilp), intent(out) :: iwork(*)
           character, intent(in) :: joba, jobp, jobr, jobt, jobu, jobv
        ! ===========================================================================
           
           ! Local Scalars 
           real(dp) :: aapp, aaqq, aatmax, aatmin, big, big1, cond_ok, condr1, condr2, entra, &
                     entrat, epsln, maxprj, scalem, sconda, sfmin, small, temp1, uscal1, uscal2, xsc
           integer(ilp) :: ierr, n1, nr, numrank, p, q, warning
           logical(lk) :: almort, defr, errest, goscal, jracc, kill, lsvec, l2aber, l2kill, &
                     l2pert, l2rank, l2tran, noscal, rowpiv, rsvec, transp
           ! Intrinsic Functions 
           ! test the input arguments
           lsvec  = stdlib_lsame( jobu, 'U' ) .or. stdlib_lsame( jobu, 'F' )
           jracc  = stdlib_lsame( jobv, 'J' )
           rsvec  = stdlib_lsame( jobv, 'V' ) .or. jracc
           rowpiv = stdlib_lsame( joba, 'F' ) .or. stdlib_lsame( joba, 'G' )
           l2rank = stdlib_lsame( joba, 'R' )
           l2aber = stdlib_lsame( joba, 'A' )
           errest = stdlib_lsame( joba, 'E' ) .or. stdlib_lsame( joba, 'G' )
           l2tran = stdlib_lsame( jobt, 'T' )
           l2kill = stdlib_lsame( jobr, 'R' )
           defr   = stdlib_lsame( jobr, 'N' )
           l2pert = stdlib_lsame( jobp, 'P' )
           if ( .not.(rowpiv .or. l2rank .or. l2aber .or.errest .or. stdlib_lsame( joba, 'C' ) )) &
                     then
              info = - 1
           else if ( .not.( lsvec  .or. stdlib_lsame( jobu, 'N' ) .or.stdlib_lsame( jobu, 'W' )) )&
                      then
              info = - 2
           else if ( .not.( rsvec .or. stdlib_lsame( jobv, 'N' ) .or.stdlib_lsame( jobv, 'W' )) &
                     .or. ( jracc .and. (.not.lsvec) ) ) then
              info = - 3
           else if ( .not. ( l2kill .or. defr ) )    then
              info = - 4
           else if ( .not. ( l2tran .or. stdlib_lsame( jobt, 'N' ) ) ) then
              info = - 5
           else if ( .not. ( l2pert .or. stdlib_lsame( jobp, 'N' ) ) ) then
              info = - 6
           else if ( m < 0 ) then
              info = - 7
           else if ( ( n < 0 ) .or. ( n > m ) ) then
              info = - 8
           else if ( lda < m ) then
              info = - 10
           else if ( lsvec .and. ( ldu < m ) ) then
              info = - 13
           else if ( rsvec .and. ( ldv < n ) ) then
              info = - 15
           else if ( (.not.(lsvec .or. rsvec .or. errest).and.(lwork < max(7,4*n+1,2*m+n))) .or.(&
           .not.(lsvec .or. rsvec) .and. errest .and.(lwork < max(7,4*n+n*n,2*m+n))) .or.(lsvec &
           .and. (.not.rsvec) .and. (lwork < max(7,2*m+n,4*n+1))).or.(rsvec .and. (.not.lsvec) &
           .and. (lwork < max(7,2*m+n,4*n+1))).or.(lsvec .and. rsvec .and. (.not.jracc) .and.(&
           lwork<max(2*m+n,6*n+2*n*n))).or. (lsvec .and. rsvec .and. jracc .and.lwork<max(2*m+n,&
                     4*n+n*n,2*n+n*n+6)))then
              info = - 17
           else
              ! #:)
              info = 0
           end if
           if ( info /= 0 ) then
             ! #:(
              call stdlib_xerbla( 'DGEJSV', - info )
              return
           end if
           ! quick return for void matrix (y3k safe)
       ! #:)
           if ( ( m == 0 ) .or. ( n == 0 ) ) then
              iwork(1:3) = 0
              work(1:7) = 0
              return
           endif
           ! determine whether the matrix u should be m x n or m x m
           if ( lsvec ) then
              n1 = n
              if ( stdlib_lsame( jobu, 'F' ) ) n1 = m
           end if
           ! set numerical parameters
      ! !    note: make sure stdlib_dlamch() does not fail on the target architecture.
           epsln = stdlib_dlamch('EPSILON')
           sfmin = stdlib_dlamch('SAFEMINIMUM')
           small = sfmin / epsln
           big   = stdlib_dlamch('O')
           ! big   = one / sfmin
           ! initialize sva(1:n) = diag( ||a e_i||_2 )_1^n
      ! (!)  if necessary, scale sva() to protect the largest norm from
           ! overflow. it is possible that this scaling pushes the smallest
           ! column norm left from the underflow threshold (extreme case).
           scalem  = one / sqrt(real(m,KIND=dp)*real(n,KIND=dp))
           noscal  = .true.
           goscal  = .true.
           do p = 1, n
              aapp = zero
              aaqq = one
              call stdlib_dlassq( m, a(1,p), 1, aapp, aaqq )
              if ( aapp > big ) then
                 info = - 9
                 call stdlib_xerbla( 'DGEJSV', -info )
                 return
              end if
              aaqq = sqrt(aaqq)
              if ( ( aapp < (big / aaqq) ) .and. noscal  ) then
                 sva(p)  = aapp * aaqq
              else
                 noscal  = .false.
                 sva(p)  = aapp * ( aaqq * scalem )
                 if ( goscal ) then
                    goscal = .false.
                    call stdlib_dscal( p-1, scalem, sva, 1 )
                 end if
              end if
           end do
           if ( noscal ) scalem = one
           aapp = zero
           aaqq = big
           do p = 1, n
              aapp = max( aapp, sva(p) )
              if ( sva(p) /= zero ) aaqq = min( aaqq, sva(p) )
           end do
           ! quick return for zero m x n matrix
       ! #:)
           if ( aapp == zero ) then
              if ( lsvec ) call stdlib_dlaset( 'G', m, n1, zero, one, u, ldu )
              if ( rsvec ) call stdlib_dlaset( 'G', n, n,  zero, one, v, ldv )
              work(1) = one
              work(2) = one
              if ( errest ) work(3) = one
              if ( lsvec .and. rsvec ) then
                 work(4) = one
                 work(5) = one
              end if
              if ( l2tran ) then
                 work(6) = zero
                 work(7) = zero
              end if
              iwork(1) = 0
              iwork(2) = 0
              iwork(3) = 0
              return
           end if
           ! issue warning if denormalized column norms detected. override the
           ! high relative accuracy request. issue licence to kill columns
           ! (set them to zero) whose norm is less than sigma_max / big (roughly).
       ! #:(
           warning = 0
           if ( aaqq <= sfmin ) then
              l2rank = .true.
              l2kill = .true.
              warning = 1
           end if
           ! quick return for one-column matrix
       ! #:)
           if ( n == 1 ) then
              if ( lsvec ) then
                 call stdlib_dlascl( 'G',0,0,sva(1),scalem, m,1,a(1,1),lda,ierr )
                 call stdlib_dlacpy( 'A', m, 1, a, lda, u, ldu )
                 ! computing all m left singular vectors of the m x 1 matrix
                 if ( n1 /= n  ) then
                    call stdlib_dgeqrf( m, n, u,ldu, work, work(n+1),lwork-n,ierr )
                    call stdlib_dorgqr( m,n1,1, u,ldu,work,work(n+1),lwork-n,ierr )
                    call stdlib_dcopy( m, a(1,1), 1, u(1,1), 1 )
                 end if
              end if
              if ( rsvec ) then
                  v(1,1) = one
              end if
              if ( sva(1) < (big*scalem) ) then
                 sva(1)  = sva(1) / scalem
                 scalem  = one
              end if
              work(1) = one / scalem
              work(2) = one
              if ( sva(1) /= zero ) then
                 iwork(1) = 1
                 if ( ( sva(1) / scalem) >= sfmin ) then
                    iwork(2) = 1
                 else
                    iwork(2) = 0
                 end if
              else
                 iwork(1) = 0
                 iwork(2) = 0
              end if
              iwork(3) = 0
              if ( errest ) work(3) = one
              if ( lsvec .and. rsvec ) then
                 work(4) = one
                 work(5) = one
              end if
              if ( l2tran ) then
                 work(6) = zero
                 work(7) = zero
              end if
              return
           end if
           transp = .false.
           l2tran = l2tran .and. ( m == n )
           aatmax = -one
           aatmin =  big
           if ( rowpiv .or. l2tran ) then
           ! compute the row norms, needed to determine row pivoting sequence
           ! (in the case of heavily row weighted a, row pivoting is strongly
           ! advised) and to collect information needed to compare the
           ! structures of a * a^t and a^t * a (in the case l2tran==.true.).
              if ( l2tran ) then
                 do p = 1, m
                    xsc   = zero
                    temp1 = one
                    call stdlib_dlassq( n, a(p,1), lda, xsc, temp1 )
                    ! stdlib_dlassq gets both the ell_2 and the ell_infinity norm
                    ! in one pass through the vector
                    work(m+n+p)  = xsc * scalem
                    work(n+p)    = xsc * (scalem*sqrt(temp1))
                    aatmax = max( aatmax, work(n+p) )
                    if (work(n+p) /= zero) aatmin = min(aatmin,work(n+p))
                 end do
              else
                 do p = 1, m
                    work(m+n+p) = scalem*abs( a(p,stdlib_idamax(n,a(p,1),lda)) )
                    aatmax = max( aatmax, work(m+n+p) )
                    aatmin = min( aatmin, work(m+n+p) )
                 end do
              end if
           end if
           ! for square matrix a try to determine whether a^t  would be  better
           ! input for the preconditioned jacobi svd, with faster convergence.
           ! the decision is based on an o(n) function of the vector of column
           ! and row norms of a, based on the shannon entropy. this should give
           ! the right choice in most cases when the difference actually matters.
           ! it may fail and pick the slower converging side.
           entra  = zero
           entrat = zero
           if ( l2tran ) then
              xsc   = zero
              temp1 = one
              call stdlib_dlassq( n, sva, 1, xsc, temp1 )
              temp1 = one / temp1
              entra = zero
              do p = 1, n
                 big1  = ( ( sva(p) / xsc )**2 ) * temp1
                 if ( big1 /= zero ) entra = entra + big1 * log(big1)
              end do
              entra = - entra / log(real(n,KIND=dp))
              ! now, sva().^2/trace(a^t * a) is a point in the probability simplex.
              ! it is derived from the diagonal of  a^t * a.  do the same with the
              ! diagonal of a * a^t, compute the entropy of the corresponding
              ! probability distribution. note that a * a^t and a^t * a have the
              ! same trace.
              entrat = zero
              do p = n+1, n+m
                 big1 = ( ( work(p) / xsc )**2 ) * temp1
                 if ( big1 /= zero ) entrat = entrat + big1 * log(big1)
              end do
              entrat = - entrat / log(real(m,KIND=dp))
              ! analyze the entropies and decide a or a^t. smaller entropy
              ! usually means better input for the algorithm.
              transp = ( entrat < entra )
              ! if a^t is better than a, transpose a.
              if ( transp ) then
                 ! in an optimal implementation, this trivial transpose
                 ! should be replaced with faster transpose.
                 do p = 1, n - 1
                    do q = p + 1, n
                        temp1 = a(q,p)
                       a(q,p) = a(p,q)
                       a(p,q) = temp1
                    end do
                 end do
                 do p = 1, n
                    work(m+n+p) = sva(p)
                    sva(p)      = work(n+p)
                 end do
                 temp1  = aapp
                 aapp   = aatmax
                 aatmax = temp1
                 temp1  = aaqq
                 aaqq   = aatmin
                 aatmin = temp1
                 kill   = lsvec
                 lsvec  = rsvec
                 rsvec  = kill
                 if ( lsvec ) n1 = n
                 rowpiv = .true.
              end if
           end if
           ! end if l2tran
           ! scale the matrix so that its maximal singular value remains less
           ! than sqrt(big) -- the matrix is scaled so that its maximal column
           ! has euclidean norm equal to sqrt(big/n). the only reason to keep
           ! sqrt(big) instead of big is the fact that stdlib_dgejsv uses lapack and
           ! blas routines that, in some implementations, are not capable of
           ! working in the full interval [sfmin,big] and that they may provoke
           ! overflows in the intermediate results. if the singular values spread
           ! from sfmin to big, then stdlib_dgesvj will compute them. so, in that case,
           ! one should use stdlib_dgesvj instead of stdlib_dgejsv.
           big1   = sqrt( big )
           temp1  = sqrt( big / real(n,KIND=dp) )
           call stdlib_dlascl( 'G', 0, 0, aapp, temp1, n, 1, sva, n, ierr )
           if ( aaqq > (aapp * sfmin) ) then
               aaqq = ( aaqq / aapp ) * temp1
           else
               aaqq = ( aaqq * temp1 ) / aapp
           end if
           temp1 = temp1 * scalem
           call stdlib_dlascl( 'G', 0, 0, aapp, temp1, m, n, a, lda, ierr )
           ! to undo scaling at the end of this procedure, multiply the
           ! computed singular values with uscal2 / uscal1.
           uscal1 = temp1
           uscal2 = aapp
           if ( l2kill ) then
              ! l2kill enforces computation of nonzero singular values in
              ! the restricted range of condition number of the initial a,
              ! sigma_max(a) / sigma_min(a) approx. sqrt(big)/sqrt(sfmin).
              xsc = sqrt( sfmin )
           else
              xsc = small
              ! now, if the condition number of a is too big,
              ! sigma_max(a) / sigma_min(a) > sqrt(big/n) * epsln / sfmin,
              ! as a precaution measure, the full svd is computed using stdlib_dgesvj
              ! with accumulated jacobi rotations. this provides numerically
              ! more robust computation, at the cost of slightly increased run
              ! time. depending on the concrete implementation of blas and lapack
              ! (i.e. how they behave in presence of extreme ill-conditioning) the
              ! implementor may decide to remove this switch.
              if ( ( aaqq<sqrt(sfmin) ) .and. lsvec .and. rsvec ) then
                 jracc = .true.
              end if
           end if
           if ( aaqq < xsc ) then
              do p = 1, n
                 if ( sva(p) < xsc ) then
                    call stdlib_dlaset( 'A', m, 1, zero, zero, a(1,p), lda )
                    sva(p) = zero
                 end if
              end do
           end if
           ! preconditioning using qr factorization with pivoting
           if ( rowpiv ) then
              ! optional row permutation (bjoerck row pivoting):
              ! a result by cox and higham shows that the bjoerck's
              ! row pivoting combined with standard column pivoting
              ! has similar effect as powell-reid complete pivoting.
              ! the ell-infinity norms of a are made nonincreasing.
              do p = 1, m - 1
                 q = stdlib_idamax( m-p+1, work(m+n+p), 1 ) + p - 1
                 iwork(2*n+p) = q
                 if ( p /= q ) then
                    temp1       = work(m+n+p)
                    work(m+n+p) = work(m+n+q)
                    work(m+n+q) = temp1
                 end if
              end do
              call stdlib_dlaswp( n, a, lda, 1, m-1, iwork(2*n+1), 1 )
           end if
           ! end of the preparation phase (scaling, optional sorting and
           ! transposing, optional flushing of small columns).
           ! preconditioning
           ! if the full svd is needed, the right singular vectors are computed
           ! from a matrix equation, and for that we need theoretical analysis
           ! of the businger-golub pivoting. so we use stdlib_dgeqp3 as the first rr qrf.
           ! in all other cases the first rr qrf can be chosen by other criteria
           ! (eg speed by replacing global with restricted window pivoting, such
           ! as in sgeqpx from toms # 782). good results will be obtained using
           ! sgeqpx with properly (!) chosen numerical parameters.
           ! any improvement of stdlib_dgeqp3 improves overall performance of stdlib_dgejsv.
           ! a * p1 = q1 * [ r1^t 0]^t:
           do p = 1, n
              ! All Columns Are Free Columns
              iwork(p) = 0
           end do
           call stdlib_dgeqp3( m,n,a,lda, iwork,work, work(n+1),lwork-n, ierr )
           ! the upper triangular matrix r1 from the first qrf is inspected for
           ! rank deficiency and possibilities for deflation, or possible
           ! ill-conditioning. depending on the user specified flag l2rank,
           ! the procedure explores possibilities to reduce the numerical
           ! rank by inspecting the computed upper triangular factor. if
           ! l2rank or l2aber are up, then stdlib_dgejsv will compute the svd of
           ! a + da, where ||da|| <= f(m,n)*epsln.
           nr = 1
           if ( l2aber ) then
              ! standard absolute error bound suffices. all sigma_i with
              ! sigma_i < n*epsln*||a|| are flushed to zero. this is an
              ! aggressive enforcement of lower numerical rank by introducing a
              ! backward error of the order of n*epsln*||a||.
              temp1 = sqrt(real(n,KIND=dp))*epsln
              do p = 2, n
                 if ( abs(a(p,p)) >= (temp1*abs(a(1,1))) ) then
                    nr = nr + 1
                 else
                    go to 3002
                 end if
              end do
              3002 continue
           else if ( l2rank ) then
              ! .. similarly as above, only slightly more gentle (less aggressive).
              ! sudden drop on the diagonal of r1 is used as the criterion for
              ! close-to-rank-deficient.
              temp1 = sqrt(sfmin)
              do p = 2, n
                 if ( ( abs(a(p,p)) < (epsln*abs(a(p-1,p-1))) ) .or.( abs(a(p,p)) < small ) .or.( &
                           l2kill .and. (abs(a(p,p)) < temp1) ) ) go to 3402
                 nr = nr + 1
              end do
              3402 continue
           else
              ! the goal is high relative accuracy. however, if the matrix
              ! has high scaled condition number the relative accuracy is in
              ! general not feasible. later on, a condition number estimator
              ! will be deployed to estimate the scaled condition number.
              ! here we just remove the underflowed part of the triangular
              ! factor. this prevents the situation in which the code is
              ! working hard to get the accuracy not warranted by the data.
              temp1  = sqrt(sfmin)
              do p = 2, n
                 if ( ( abs(a(p,p)) < small ) .or.( l2kill .and. (abs(a(p,p)) < temp1) ) ) go to &
                           3302
                 nr = nr + 1
              end do
              3302 continue
           end if
           almort = .false.
           if ( nr == n ) then
              maxprj = one
              do p = 2, n
                 temp1  = abs(a(p,p)) / sva(iwork(p))
                 maxprj = min( maxprj, temp1 )
              end do
              if ( maxprj**2 >= one - real(n,KIND=dp)*epsln ) almort = .true.
           end if
           sconda = - one
           condr1 = - one
           condr2 = - one
           if ( errest ) then
              if ( n == nr ) then
                 if ( rsvec ) then
                    ! V Is Available As Workspace
                    call stdlib_dlacpy( 'U', n, n, a, lda, v, ldv )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_dscal( p, one/temp1, v(1,p), 1 )
                    end do
                    call stdlib_dpocon( 'U', n, v, ldv, one, temp1,work(n+1), iwork(2*n+m+1), &
                              ierr )
                 else if ( lsvec ) then
                    ! U Is Available As Workspace
                    call stdlib_dlacpy( 'U', n, n, a, lda, u, ldu )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_dscal( p, one/temp1, u(1,p), 1 )
                    end do
                    call stdlib_dpocon( 'U', n, u, ldu, one, temp1,work(n+1), iwork(2*n+m+1), &
                              ierr )
                 else
                    call stdlib_dlacpy( 'U', n, n, a, lda, work(n+1), n )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_dscal( p, one/temp1, work(n+(p-1)*n+1), 1 )
                    end do
                 ! The Columns Of R Are Scaled To Have Unit Euclidean Lengths
                    call stdlib_dpocon( 'U', n, work(n+1), n, one, temp1,work(n+n*n+1), iwork(2*n+&
                              m+1), ierr )
                 end if
                 sconda = one / sqrt(temp1)
                 ! sconda is an estimate of sqrt(||(r^t * r)^(-1)||_1).
                 ! n^(-1/4) * sconda <= ||r^(-1)||_2 <= n^(1/4) * sconda
              else
                 sconda = - one
              end if
           end if
           l2pert = l2pert .and. ( abs( a(1,1)/a(nr,nr) ) > sqrt(big1) )
           ! if there is no violent scaling, artificial perturbation is not needed.
           ! phase 3:
           if ( .not. ( rsvec .or. lsvec ) ) then
               ! singular values only
               ! .. transpose a(1:nr,1:n)
              do p = 1, min( n-1, nr )
                 call stdlib_dcopy( n-p, a(p,p+1), lda, a(p+1,p), 1 )
              end do
              ! the following two do-loops introduce small relative perturbation
              ! into the strict upper triangle of the lower triangular matrix.
              ! small entries below the main diagonal are also changed.
              ! this modification is useful if the computing environment does not
              ! provide/allow flush to zero underflow, for it prevents many
              ! annoying denormalized numbers in case of strongly scaled matrices.
              ! the perturbation is structured so that it does not introduce any
              ! new perturbation of the singular values, and it does not destroy
              ! the job done by the preconditioner.
              ! the licence for this perturbation is in the variable l2pert, which
              ! should be .false. if flush to zero underflow is active.
              if ( .not. almort ) then
                 if ( l2pert ) then
                    ! xsc = sqrt(small)
                    xsc = epsln / real(n,KIND=dp)
                    do q = 1, nr
                       temp1 = xsc*abs(a(q,q))
                       do p = 1, n
                          if ( ( (p>q) .and. (abs(a(p,q))<=temp1) ).or. ( p < q ) )a(p,q) = sign( &
                                    temp1, a(p,q) )
                       end do
                    end do
                 else
                    call stdlib_dlaset( 'U', nr-1,nr-1, zero,zero, a(1,2),lda )
                 end if
                  ! Second Preconditioning Using The Qr Factorization
                 call stdlib_dgeqrf( n,nr, a,lda, work, work(n+1),lwork-n, ierr )
                 ! And Transpose Upper To Lower Triangular
                 do p = 1, nr - 1
                    call stdlib_dcopy( nr-p, a(p,p+1), lda, a(p+1,p), 1 )
                 end do
              end if
                 ! row-cyclic jacobi svd algorithm with column pivoting
                 ! .. again some perturbation (a "background noise") is added
                 ! to drown denormals
                 if ( l2pert ) then
                    ! xsc = sqrt(small)
                    xsc = epsln / real(n,KIND=dp)
                    do q = 1, nr
                       temp1 = xsc*abs(a(q,q))
                       do p = 1, nr
                          if ( ( (p>q) .and. (abs(a(p,q))<=temp1) ).or. ( p < q ) )a(p,q) = sign( &
                                    temp1, a(p,q) )
                       end do
                    end do
                 else
                    call stdlib_dlaset( 'U', nr-1, nr-1, zero, zero, a(1,2), lda )
                 end if
                 ! .. and one-sided jacobi rotations are started on a lower
                 ! triangular matrix (plus perturbation which is ignored in
                 ! the part which destroys triangular form (confusing?!))
                 call stdlib_dgesvj( 'L', 'NOU', 'NOV', nr, nr, a, lda, sva,n, v, ldv, work, &
                           lwork, info )
                 scalem  = work(1)
                 numrank = nint(work(2),KIND=ilp)
           else if ( rsvec .and. ( .not. lsvec ) ) then
              ! -> singular values and right singular vectors <-
              if ( almort ) then
                 ! In This Case Nr Equals N
                 do p = 1, nr
                    call stdlib_dcopy( n-p+1, a(p,p), lda, v(p,p), 1 )
                 end do
                 call stdlib_dlaset( 'UPPER', nr-1, nr-1, zero, zero, v(1,2), ldv )
                 call stdlib_dgesvj( 'L','U','N', n, nr, v,ldv, sva, nr, a,lda,work, lwork, info )
                           
                 scalem  = work(1)
                 numrank = nint(work(2),KIND=ilp)
              else
              ! .. two more qr factorizations ( one qrf is not enough, two require
              ! accumulated product of jacobi rotations, three are perfect )
                 call stdlib_dlaset( 'LOWER', nr-1, nr-1, zero, zero, a(2,1), lda )
                 call stdlib_dgelqf( nr, n, a, lda, work, work(n+1), lwork-n, ierr)
                 call stdlib_dlacpy( 'LOWER', nr, nr, a, lda, v, ldv )
                 call stdlib_dlaset( 'UPPER', nr-1, nr-1, zero, zero, v(1,2), ldv )
                 call stdlib_dgeqrf( nr, nr, v, ldv, work(n+1), work(2*n+1),lwork-2*n, ierr )
                           
                 do p = 1, nr
                    call stdlib_dcopy( nr-p+1, v(p,p), ldv, v(p,p), 1 )
                 end do
                 call stdlib_dlaset( 'UPPER', nr-1, nr-1, zero, zero, v(1,2), ldv )
                 call stdlib_dgesvj( 'LOWER', 'U','N', nr, nr, v,ldv, sva, nr, u,ldu, work(n+1), &
                           lwork, info )
                 scalem  = work(n+1)
                 numrank = nint(work(n+2),KIND=ilp)
                 if ( nr < n ) then
                    call stdlib_dlaset( 'A',n-nr, nr, zero,zero, v(nr+1,1),   ldv )
                    call stdlib_dlaset( 'A',nr, n-nr, zero,zero, v(1,nr+1),   ldv )
                    call stdlib_dlaset( 'A',n-nr,n-nr,zero,one, v(nr+1,nr+1), ldv )
                 end if
              call stdlib_dormlq( 'LEFT', 'TRANSPOSE', n, n, nr, a, lda, work,v, ldv, work(n+1), &
                        lwork-n, ierr )
              end if
              do p = 1, n
                 call stdlib_dcopy( n, v(p,1), ldv, a(iwork(p),1), lda )
              end do
              call stdlib_dlacpy( 'ALL', n, n, a, lda, v, ldv )
              if ( transp ) then
                 call stdlib_dlacpy( 'ALL', n, n, v, ldv, u, ldu )
              end if
           else if ( lsvec .and. ( .not. rsvec ) ) then
              ! Singular Values And Left Singular Vectors                 
              ! Second Preconditioning Step To Avoid Need To Accumulate
              ! jacobi rotations in the jacobi iterations.
              do p = 1, nr
                 call stdlib_dcopy( n-p+1, a(p,p), lda, u(p,p), 1 )
              end do
              call stdlib_dlaset( 'UPPER', nr-1, nr-1, zero, zero, u(1,2), ldu )
              call stdlib_dgeqrf( n, nr, u, ldu, work(n+1), work(2*n+1),lwork-2*n, ierr )
              do p = 1, nr - 1
                 call stdlib_dcopy( nr-p, u(p,p+1), ldu, u(p+1,p), 1 )
              end do
              call stdlib_dlaset( 'UPPER', nr-1, nr-1, zero, zero, u(1,2), ldu )
              call stdlib_dgesvj( 'LOWER', 'U', 'N', nr,nr, u, ldu, sva, nr, a,lda, work(n+1), &
                        lwork-n, info )
              scalem  = work(n+1)
              numrank = nint(work(n+2),KIND=ilp)
              if ( nr < m ) then
                 call stdlib_dlaset( 'A',  m-nr, nr,zero, zero, u(nr+1,1), ldu )
                 if ( nr < n1 ) then
                    call stdlib_dlaset( 'A',nr, n1-nr, zero, zero, u(1,nr+1), ldu )
                    call stdlib_dlaset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                 end if
              end if
              call stdlib_dormqr( 'LEFT', 'NO TR', m, n1, n, a, lda, work, u,ldu, work(n+1), &
                        lwork-n, ierr )
              if ( rowpiv )call stdlib_dlaswp( n1, u, ldu, 1, m-1, iwork(2*n+1), -1 )
              do p = 1, n1
                 xsc = one / stdlib_dnrm2( m, u(1,p), 1 )
                 call stdlib_dscal( m, xsc, u(1,p), 1 )
              end do
              if ( transp ) then
                 call stdlib_dlacpy( 'ALL', n, n, u, ldu, v, ldv )
              end if
           else
              ! Full Svd 
              if ( .not. jracc ) then
              if ( .not. almort ) then
                 ! second preconditioning step (qrf [with pivoting])
                 ! note that the composition of transpose, qrf and transpose is
                 ! equivalent to an lqf call. since in many libraries the qrf
                 ! seems to be better optimized than the lqf, we do explicit
                 ! transpose and use the qrf. this is subject to changes in an
                 ! optimized implementation of stdlib_dgejsv.
                 do p = 1, nr
                    call stdlib_dcopy( n-p+1, a(p,p), lda, v(p,p), 1 )
                 end do
                 ! The Following Two Loops Perturb Small Entries To Avoid
                 ! denormals in the second qr factorization, where they are
                 ! as good as zeros. this is done to avoid painfully slow
                 ! computation with denormals. the relative size of the perturbation
                 ! is a parameter that can be changed by the implementer.
                 ! this perturbation device will be obsolete on machines with
                 ! properly implemented arithmetic.
                 ! to switch it off, set l2pert=.false. to remove it from  the
                 ! code, remove the action under l2pert=.true., leave the else part.
                 ! the following two loops should be blocked and fused with the
                 ! transposed copy above.
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do q = 1, nr
                       temp1 = xsc*abs( v(q,q) )
                       do p = 1, n
                          if ( ( p > q ) .and. ( abs(v(p,q)) <= temp1 ).or. ( p < q ) )v(p,q) = &
                                    sign( temp1, v(p,q) )
                          if ( p < q ) v(p,q) = - v(p,q)
                       end do
                    end do
                 else
                    call stdlib_dlaset( 'U', nr-1, nr-1, zero, zero, v(1,2), ldv )
                 end if
                 ! estimate the row scaled condition number of r1
                 ! (if r1 is rectangular, n > nr, then the condition number
                 ! of the leading nr x nr submatrix is estimated.)
                 call stdlib_dlacpy( 'L', nr, nr, v, ldv, work(2*n+1), nr )
                 do p = 1, nr
                    temp1 = stdlib_dnrm2(nr-p+1,work(2*n+(p-1)*nr+p),1)
                    call stdlib_dscal(nr-p+1,one/temp1,work(2*n+(p-1)*nr+p),1)
                 end do
                 call stdlib_dpocon('LOWER',nr,work(2*n+1),nr,one,temp1,work(2*n+nr*nr+1),iwork(m+&
                           2*n+1),ierr)
                 condr1 = one / sqrt(temp1)
                 ! Here Need A Second Opinion On The Condition Number
                 ! Then Assume Worst Case Scenario
                 ! r1 is ok for inverse <=> condr1 < real(n,KIND=dp)
                 ! more conservative    <=> condr1 < sqrt(real(n,KIND=dp))
                 cond_ok = sqrt(real(nr,KIND=dp))
      ! [tp]       cond_ok is a tuning parameter.
                 if ( condr1 < cond_ok ) then
                    ! .. the second qrf without pivoting. note: in an optimized
                    ! implementation, this qrf should be implemented as the qrf
                    ! of a lower triangular matrix.
                    ! r1^t = q2 * r2
                    call stdlib_dgeqrf( n, nr, v, ldv, work(n+1), work(2*n+1),lwork-2*n, ierr )
                              
                    if ( l2pert ) then
                       xsc = sqrt(small)/epsln
                       do p = 2, nr
                          do q = 1, p - 1
                             temp1 = xsc * min(abs(v(p,p)),abs(v(q,q)))
                             if ( abs(v(q,p)) <= temp1 )v(q,p) = sign( temp1, v(q,p) )
                          end do
                       end do
                    end if
                    if ( nr /= n )call stdlib_dlacpy( 'A', n, nr, v, ldv, work(2*n+1), n )
                    ! .. save ...
                 ! This Transposed Copy Should Be Better Than Naive
                    do p = 1, nr - 1
                       call stdlib_dcopy( nr-p, v(p,p+1), ldv, v(p+1,p), 1 )
                    end do
                    condr2 = condr1
                 else
                    ! .. ill-conditioned case: second qrf with pivoting
                    ! note that windowed pivoting would be equally good
                    ! numerically, and more run-time efficient. so, in
                    ! an optimal implementation, the next call to stdlib_dgeqp3
                    ! should be replaced with eg. call sgeqpx (acm toms #782)
                    ! with properly (carefully) chosen parameters.
                    ! r1^t * p2 = q2 * r2
                    do p = 1, nr
                       iwork(n+p) = 0
                    end do
                    call stdlib_dgeqp3( n, nr, v, ldv, iwork(n+1), work(n+1),work(2*n+1), lwork-&
                              2*n, ierr )
      ! *               call stdlib_dgeqrf( n, nr, v, ldv, work(n+1), work(2*n+1),
      ! *     $              lwork-2*n, ierr )
                    if ( l2pert ) then
                       xsc = sqrt(small)
                       do p = 2, nr
                          do q = 1, p - 1
                             temp1 = xsc * min(abs(v(p,p)),abs(v(q,q)))
                             if ( abs(v(q,p)) <= temp1 )v(q,p) = sign( temp1, v(q,p) )
                          end do
                       end do
                    end if
                    call stdlib_dlacpy( 'A', n, nr, v, ldv, work(2*n+1), n )
                    if ( l2pert ) then
                       xsc = sqrt(small)
                       do p = 2, nr
                          do q = 1, p - 1
                             temp1 = xsc * min(abs(v(p,p)),abs(v(q,q)))
                             v(p,q) = - sign( temp1, v(q,p) )
                          end do
                       end do
                    else
                       call stdlib_dlaset( 'L',nr-1,nr-1,zero,zero,v(2,1),ldv )
                    end if
                    ! now, compute r2 = l3 * q3, the lq factorization.
                    call stdlib_dgelqf( nr, nr, v, ldv, work(2*n+n*nr+1),work(2*n+n*nr+nr+1), &
                              lwork-2*n-n*nr-nr, ierr )
                    ! And Estimate The Condition Number
                    call stdlib_dlacpy( 'L',nr,nr,v,ldv,work(2*n+n*nr+nr+1),nr )
                    do p = 1, nr
                       temp1 = stdlib_dnrm2( p, work(2*n+n*nr+nr+p), nr )
                       call stdlib_dscal( p, one/temp1, work(2*n+n*nr+nr+p), nr )
                    end do
                    call stdlib_dpocon( 'L',nr,work(2*n+n*nr+nr+1),nr,one,temp1,work(2*n+n*nr+nr+&
                              nr*nr+1),iwork(m+2*n+1),ierr )
                    condr2 = one / sqrt(temp1)
                    if ( condr2 >= cond_ok ) then
                       ! Save The Householder Vectors Used For Q3
                       ! (this overwrites the copy of r2, as it will not be
                       ! needed in this branch, but it does not overwritte the
                       ! huseholder vectors of q2.).
                       call stdlib_dlacpy( 'U', nr, nr, v, ldv, work(2*n+1), n )
                       ! And The Rest Of The Information On Q3 Is In
                       ! work(2*n+n*nr+1:2*n+n*nr+n)
                    end if
                 end if
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do q = 2, nr
                       temp1 = xsc * v(q,q)
                       do p = 1, q - 1
                          ! v(p,q) = - sign( temp1, v(q,p) )
                          v(p,q) = - sign( temp1, v(p,q) )
                       end do
                    end do
                 else
                    call stdlib_dlaset( 'U', nr-1,nr-1, zero,zero, v(1,2), ldv )
                 end if
              ! second preconditioning finished; continue with jacobi svd
              ! the input matrix is lower trinagular.
              ! recover the right singular vectors as solution of a well
              ! conditioned triangular matrix equation.
                 if ( condr1 < cond_ok ) then
                    call stdlib_dgesvj( 'L','U','N',nr,nr,v,ldv,sva,nr,u,ldu,work(2*n+n*nr+nr+1),&
                              lwork-2*n-n*nr-nr,info )
                    scalem  = work(2*n+n*nr+nr+1)
                    numrank = nint(work(2*n+n*nr+nr+2),KIND=ilp)
                    do p = 1, nr
                       call stdlib_dcopy( nr, v(1,p), 1, u(1,p), 1 )
                       call stdlib_dscal( nr, sva(p),    v(1,p), 1 )
                    end do
              ! Pick The Right Matrix Equation And Solve It
                    if ( nr == n ) then
       ! :))             .. best case, r1 is inverted. the solution of this matrix
                       ! equation is q2*v2 = the product of the jacobi rotations
                       ! used in stdlib_dgesvj, premultiplied with the orthogonal matrix
                       ! from the second qr factorization.
                       call stdlib_dtrsm( 'L','U','N','N', nr,nr,one, a,lda, v,ldv )
                    else
                       ! .. r1 is well conditioned, but non-square. transpose(r2)
                       ! is inverted to get the product of the jacobi rotations
                       ! used in stdlib_dgesvj. the q-factor from the second qr
                       ! factorization is then built in explicitly.
                       call stdlib_dtrsm('L','U','T','N',nr,nr,one,work(2*n+1),n,v,ldv)
                       if ( nr < n ) then
                         call stdlib_dlaset('A',n-nr,nr,zero,zero,v(nr+1,1),ldv)
                         call stdlib_dlaset('A',nr,n-nr,zero,zero,v(1,nr+1),ldv)
                         call stdlib_dlaset('A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv)
                       end if
                       call stdlib_dormqr('L','N',n,n,nr,work(2*n+1),n,work(n+1),v,ldv,work(2*n+&
                                 n*nr+nr+1),lwork-2*n-n*nr-nr,ierr)
                    end if
                 else if ( condr2 < cond_ok ) then
       ! :)           .. the input matrix a is very likely a relative of
                    ! the kahan matrix :)
                    ! the matrix r2 is inverted. the solution of the matrix equation
                    ! is q3^t*v3 = the product of the jacobi rotations (appplied to
                    ! the lower triangular l3 from the lq factorization of
                    ! r2=l3*q3), pre-multiplied with the transposed q3.
                    call stdlib_dgesvj( 'L', 'U', 'N', nr, nr, v, ldv, sva, nr, u,ldu, work(2*n+&
                              n*nr+nr+1), lwork-2*n-n*nr-nr, info )
                    scalem  = work(2*n+n*nr+nr+1)
                    numrank = nint(work(2*n+n*nr+nr+2),KIND=ilp)
                    do p = 1, nr
                       call stdlib_dcopy( nr, v(1,p), 1, u(1,p), 1 )
                       call stdlib_dscal( nr, sva(p),    u(1,p), 1 )
                    end do
                    call stdlib_dtrsm('L','U','N','N',nr,nr,one,work(2*n+1),n,u,ldu)
                    ! Apply The Permutation From The Second Qr Factorization
                    do q = 1, nr
                       do p = 1, nr
                          work(2*n+n*nr+nr+iwork(n+p)) = u(p,q)
                       end do
                       do p = 1, nr
                          u(p,q) = work(2*n+n*nr+nr+p)
                       end do
                    end do
                    if ( nr < n ) then
                       call stdlib_dlaset( 'A',n-nr,nr,zero,zero,v(nr+1,1),ldv )
                       call stdlib_dlaset( 'A',nr,n-nr,zero,zero,v(1,nr+1),ldv )
                       call stdlib_dlaset( 'A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv )
                    end if
                    call stdlib_dormqr( 'L','N',n,n,nr,work(2*n+1),n,work(n+1),v,ldv,work(2*n+&
                              n*nr+nr+1),lwork-2*n-n*nr-nr,ierr )
                 else
                    ! last line of defense.
       ! #:(          this is a rather pathological case: no scaled condition
                    ! improvement after two pivoted qr factorizations. other
                    ! possibility is that the rank revealing qr factorization
                    ! or the condition estimator has failed, or the cond_ok
                    ! is set very close to one (which is unnecessary). normally,
                    ! this branch should never be executed, but in rare cases of
                    ! failure of the rrqr or condition estimator, the last line of
                    ! defense ensures that stdlib_dgejsv completes the task.
                    ! compute the full svd of l3 using stdlib_dgesvj with explicit
                    ! accumulation of jacobi rotations.
                    call stdlib_dgesvj( 'L', 'U', 'V', nr, nr, v, ldv, sva, nr, u,ldu, work(2*n+&
                              n*nr+nr+1), lwork-2*n-n*nr-nr, info )
                    scalem  = work(2*n+n*nr+nr+1)
                    numrank = nint(work(2*n+n*nr+nr+2),KIND=ilp)
                    if ( nr < n ) then
                       call stdlib_dlaset( 'A',n-nr,nr,zero,zero,v(nr+1,1),ldv )
                       call stdlib_dlaset( 'A',nr,n-nr,zero,zero,v(1,nr+1),ldv )
                       call stdlib_dlaset( 'A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv )
                    end if
                    call stdlib_dormqr( 'L','N',n,n,nr,work(2*n+1),n,work(n+1),v,ldv,work(2*n+&
                              n*nr+nr+1),lwork-2*n-n*nr-nr,ierr )
                    call stdlib_dormlq( 'L', 'T', nr, nr, nr, work(2*n+1), n,work(2*n+n*nr+1), u, &
                              ldu, work(2*n+n*nr+nr+1),lwork-2*n-n*nr-nr, ierr )
                    do q = 1, nr
                       do p = 1, nr
                          work(2*n+n*nr+nr+iwork(n+p)) = u(p,q)
                       end do
                       do p = 1, nr
                          u(p,q) = work(2*n+n*nr+nr+p)
                       end do
                    end do
                 end if
                 ! permute the rows of v using the (column) permutation from the
                 ! first qrf. also, scale the columns to make them unit in
                 ! euclidean norm. this applies to all cases.
                 temp1 = sqrt(real(n,KIND=dp)) * epsln
                 do q = 1, n
                    do p = 1, n
                       work(2*n+n*nr+nr+iwork(p)) = v(p,q)
                    end do
                    do p = 1, n
                       v(p,q) = work(2*n+n*nr+nr+p)
                    end do
                    xsc = one / stdlib_dnrm2( n, v(1,q), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_dscal( n, xsc, &
                              v(1,q), 1 )
                 end do
                 ! at this moment, v contains the right singular vectors of a.
                 ! next, assemble the left singular vector matrix u (m x n).
                 if ( nr < m ) then
                    call stdlib_dlaset( 'A', m-nr, nr, zero, zero, u(nr+1,1), ldu )
                    if ( nr < n1 ) then
                       call stdlib_dlaset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                       call stdlib_dlaset('A',m-nr,n1-nr,zero,one,u(nr+1,nr+1),ldu)
                    end if
                 end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! matrix u. this applies to all cases.
                 call stdlib_dormqr( 'LEFT', 'NO_TR', m, n1, n, a, lda, work, u,ldu, work(n+1), &
                           lwork-n, ierr )
                 ! the columns of u are normalized. the cost is o(m*n) flops.
                 temp1 = sqrt(real(m,KIND=dp)) * epsln
                 do p = 1, nr
                    xsc = one / stdlib_dnrm2( m, u(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_dscal( m, xsc, &
                              u(1,p), 1 )
                 end do
                 ! if the initial qrf is computed with row pivoting, the left
                 ! singular vectors must be adjusted.
                 if ( rowpiv )call stdlib_dlaswp( n1, u, ldu, 1, m-1, iwork(2*n+1), -1 )
              else
              ! The Initial Matrix A Has Almost Orthogonal Columns And
              ! the second qrf is not needed
                 call stdlib_dlacpy( 'UPPER', n, n, a, lda, work(n+1), n )
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do p = 2, n
                       temp1 = xsc * work( n + (p-1)*n + p )
                       do q = 1, p - 1
                          work(n+(q-1)*n+p)=-sign(temp1,work(n+(p-1)*n+q))
                       end do
                    end do
                 else
                    call stdlib_dlaset( 'LOWER',n-1,n-1,zero,zero,work(n+2),n )
                 end if
                 call stdlib_dgesvj( 'UPPER', 'U', 'N', n, n, work(n+1), n, sva,n, u, ldu, work(n+&
                           n*n+1), lwork-n-n*n, info )
                 scalem  = work(n+n*n+1)
                 numrank = nint(work(n+n*n+2),KIND=ilp)
                 do p = 1, n
                    call stdlib_dcopy( n, work(n+(p-1)*n+1), 1, u(1,p), 1 )
                    call stdlib_dscal( n, sva(p), work(n+(p-1)*n+1), 1 )
                 end do
                 call stdlib_dtrsm( 'LEFT', 'UPPER', 'NOTRANS', 'NO UD', n, n,one, a, lda, work(n+&
                           1), n )
                 do p = 1, n
                    call stdlib_dcopy( n, work(n+p), n, v(iwork(p),1), ldv )
                 end do
                 temp1 = sqrt(real(n,KIND=dp))*epsln
                 do p = 1, n
                    xsc = one / stdlib_dnrm2( n, v(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_dscal( n, xsc, &
                              v(1,p), 1 )
                 end do
                 ! assemble the left singular vector matrix u (m x n).
                 if ( n < m ) then
                    call stdlib_dlaset( 'A',  m-n, n, zero, zero, u(n+1,1), ldu )
                    if ( n < n1 ) then
                       call stdlib_dlaset( 'A',n,  n1-n, zero, zero,  u(1,n+1),ldu )
                       call stdlib_dlaset( 'A',m-n,n1-n, zero, one,u(n+1,n+1),ldu )
                    end if
                 end if
                 call stdlib_dormqr( 'LEFT', 'NO TR', m, n1, n, a, lda, work, u,ldu, work(n+1), &
                           lwork-n, ierr )
                 temp1 = sqrt(real(m,KIND=dp))*epsln
                 do p = 1, n1
                    xsc = one / stdlib_dnrm2( m, u(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_dscal( m, xsc, &
                              u(1,p), 1 )
                 end do
                 if ( rowpiv )call stdlib_dlaswp( n1, u, ldu, 1, m-1, iwork(2*n+1), -1 )
              end if
              ! end of the  >> almost orthogonal case <<  in the full svd
              else
              ! this branch deploys a preconditioned jacobi svd with explicitly
              ! accumulated rotations. it is included as optional, mainly for
              ! experimental purposes. it does perform well, and can also be used.
              ! in this implementation, this branch will be automatically activated
              ! if the  condition number sigma_max(a) / sigma_min(a) is predicted
              ! to be greater than the overflow threshold. this is because the
              ! a posteriori computation of the singular vectors assumes robust
              ! implementation of blas and some lapack procedures, capable of working
              ! in presence of extreme values. since that is not always the case, ...
              do p = 1, nr
                 call stdlib_dcopy( n-p+1, a(p,p), lda, v(p,p), 1 )
              end do
              if ( l2pert ) then
                 xsc = sqrt(small/epsln)
                 do q = 1, nr
                    temp1 = xsc*abs( v(q,q) )
                    do p = 1, n
                       if ( ( p > q ) .and. ( abs(v(p,q)) <= temp1 ).or. ( p < q ) )v(p,q) = sign(&
                                  temp1, v(p,q) )
                       if ( p < q ) v(p,q) = - v(p,q)
                    end do
                 end do
              else
                 call stdlib_dlaset( 'U', nr-1, nr-1, zero, zero, v(1,2), ldv )
              end if
              call stdlib_dgeqrf( n, nr, v, ldv, work(n+1), work(2*n+1),lwork-2*n, ierr )
              call stdlib_dlacpy( 'L', n, nr, v, ldv, work(2*n+1), n )
              do p = 1, nr
                 call stdlib_dcopy( nr-p+1, v(p,p), ldv, u(p,p), 1 )
              end do
              if ( l2pert ) then
                 xsc = sqrt(small/epsln)
                 do q = 2, nr
                    do p = 1, q - 1
                       temp1 = xsc * min(abs(u(p,p)),abs(u(q,q)))
                       u(p,q) = - sign( temp1, u(q,p) )
                    end do
                 end do
              else
                 call stdlib_dlaset('U', nr-1, nr-1, zero, zero, u(1,2), ldu )
              end if
              call stdlib_dgesvj( 'G', 'U', 'V', nr, nr, u, ldu, sva,n, v, ldv, work(2*n+n*nr+1), &
                        lwork-2*n-n*nr, info )
              scalem  = work(2*n+n*nr+1)
              numrank = nint(work(2*n+n*nr+2),KIND=ilp)
              if ( nr < n ) then
                 call stdlib_dlaset( 'A',n-nr,nr,zero,zero,v(nr+1,1),ldv )
                 call stdlib_dlaset( 'A',nr,n-nr,zero,zero,v(1,nr+1),ldv )
                 call stdlib_dlaset( 'A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv )
              end if
              call stdlib_dormqr( 'L','N',n,n,nr,work(2*n+1),n,work(n+1),v,ldv,work(2*n+n*nr+nr+1)&
                        ,lwork-2*n-n*nr-nr,ierr )
                 ! permute the rows of v using the (column) permutation from the
                 ! first qrf. also, scale the columns to make them unit in
                 ! euclidean norm. this applies to all cases.
                 temp1 = sqrt(real(n,KIND=dp)) * epsln
                 do q = 1, n
                    do p = 1, n
                       work(2*n+n*nr+nr+iwork(p)) = v(p,q)
                    end do
                    do p = 1, n
                       v(p,q) = work(2*n+n*nr+nr+p)
                    end do
                    xsc = one / stdlib_dnrm2( n, v(1,q), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_dscal( n, xsc, &
                              v(1,q), 1 )
                 end do
                 ! at this moment, v contains the right singular vectors of a.
                 ! next, assemble the left singular vector matrix u (m x n).
              if ( nr < m ) then
                 call stdlib_dlaset( 'A',  m-nr, nr, zero, zero, u(nr+1,1), ldu )
                 if ( nr < n1 ) then
                    call stdlib_dlaset( 'A',nr,  n1-nr, zero, zero,  u(1,nr+1),ldu )
                    call stdlib_dlaset( 'A',m-nr,n1-nr, zero, one,u(nr+1,nr+1),ldu )
                 end if
              end if
              call stdlib_dormqr( 'LEFT', 'NO TR', m, n1, n, a, lda, work, u,ldu, work(n+1), &
                        lwork-n, ierr )
                 if ( rowpiv )call stdlib_dlaswp( n1, u, ldu, 1, m-1, iwork(2*n+1), -1 )
              end if
              if ( transp ) then
                 ! .. swap u and v because the procedure worked on a^t
                 do p = 1, n
                    call stdlib_dswap( n, u(1,p), 1, v(1,p), 1 )
                 end do
              end if
           end if
           ! end of the full svd
           ! undo scaling, if necessary (and possible)
           if ( uscal2 <= (big/sva(1))*uscal1 ) then
              call stdlib_dlascl( 'G', 0, 0, uscal1, uscal2, nr, 1, sva, n, ierr )
              uscal1 = one
              uscal2 = one
           end if
           if ( nr < n ) then
              do p = nr+1, n
                 sva(p) = zero
              end do
           end if
           work(1) = uscal2 * scalem
           work(2) = uscal1
           if ( errest ) work(3) = sconda
           if ( lsvec .and. rsvec ) then
              work(4) = condr1
              work(5) = condr2
           end if
           if ( l2tran ) then
              work(6) = entra
              work(7) = entrat
           end if
           iwork(1) = nr
           iwork(2) = numrank
           iwork(3) = warning
           return
     end subroutine stdlib_dgejsv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$gejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, ldu, &
     !! DGEJSV: computes the singular value decomposition (SVD) of a real M-by-N
     !! matrix [A], where M >= N. The SVD of [A] is written as
     !! [A] = [U] * [SIGMA] * [V]^t,
     !! where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
     !! diagonal elements, [U] is an M-by-N (or M-by-M) orthonormal matrix, and
     !! [V] is an N-by-N orthogonal matrix. The diagonal elements of [SIGMA] are
     !! the singular values of [A]. The columns of [U] and [V] are the left and
     !! the right singular vectors of [A], respectively. The matrices [U] and [V]
     !! are computed and stored in the arrays U and V, respectively. The diagonal
     !! of [SIGMA] is computed and stored in the array SVA.
     !! DGEJSV can sometimes compute tiny singular values and their singular vectors much
     !! more accurately than other SVD routines, see below under Further Details.
               v, ldv,work, lwork, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldv, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: sva(n), u(ldu,*), v(ldv,*), work(lwork)
           integer(ilp), intent(out) :: iwork(*)
           character, intent(in) :: joba, jobp, jobr, jobt, jobu, jobv
        ! ===========================================================================
           
           ! Local Scalars 
           real(${rk}$) :: aapp, aaqq, aatmax, aatmin, big, big1, cond_ok, condr1, condr2, entra, &
                     entrat, epsln, maxprj, scalem, sconda, sfmin, small, temp1, uscal1, uscal2, xsc
           integer(ilp) :: ierr, n1, nr, numrank, p, q, warning
           logical(lk) :: almort, defr, errest, goscal, jracc, kill, lsvec, l2aber, l2kill, &
                     l2pert, l2rank, l2tran, noscal, rowpiv, rsvec, transp
           ! Intrinsic Functions 
           ! test the input arguments
           lsvec  = stdlib_lsame( jobu, 'U' ) .or. stdlib_lsame( jobu, 'F' )
           jracc  = stdlib_lsame( jobv, 'J' )
           rsvec  = stdlib_lsame( jobv, 'V' ) .or. jracc
           rowpiv = stdlib_lsame( joba, 'F' ) .or. stdlib_lsame( joba, 'G' )
           l2rank = stdlib_lsame( joba, 'R' )
           l2aber = stdlib_lsame( joba, 'A' )
           errest = stdlib_lsame( joba, 'E' ) .or. stdlib_lsame( joba, 'G' )
           l2tran = stdlib_lsame( jobt, 'T' )
           l2kill = stdlib_lsame( jobr, 'R' )
           defr   = stdlib_lsame( jobr, 'N' )
           l2pert = stdlib_lsame( jobp, 'P' )
           if ( .not.(rowpiv .or. l2rank .or. l2aber .or.errest .or. stdlib_lsame( joba, 'C' ) )) &
                     then
              info = - 1
           else if ( .not.( lsvec  .or. stdlib_lsame( jobu, 'N' ) .or.stdlib_lsame( jobu, 'W' )) )&
                      then
              info = - 2
           else if ( .not.( rsvec .or. stdlib_lsame( jobv, 'N' ) .or.stdlib_lsame( jobv, 'W' )) &
                     .or. ( jracc .and. (.not.lsvec) ) ) then
              info = - 3
           else if ( .not. ( l2kill .or. defr ) )    then
              info = - 4
           else if ( .not. ( l2tran .or. stdlib_lsame( jobt, 'N' ) ) ) then
              info = - 5
           else if ( .not. ( l2pert .or. stdlib_lsame( jobp, 'N' ) ) ) then
              info = - 6
           else if ( m < 0 ) then
              info = - 7
           else if ( ( n < 0 ) .or. ( n > m ) ) then
              info = - 8
           else if ( lda < m ) then
              info = - 10
           else if ( lsvec .and. ( ldu < m ) ) then
              info = - 13
           else if ( rsvec .and. ( ldv < n ) ) then
              info = - 15
           else if ( (.not.(lsvec .or. rsvec .or. errest).and.(lwork < max(7,4*n+1,2*m+n))) .or.(&
           .not.(lsvec .or. rsvec) .and. errest .and.(lwork < max(7,4*n+n*n,2*m+n))) .or.(lsvec &
           .and. (.not.rsvec) .and. (lwork < max(7,2*m+n,4*n+1))).or.(rsvec .and. (.not.lsvec) &
           .and. (lwork < max(7,2*m+n,4*n+1))).or.(lsvec .and. rsvec .and. (.not.jracc) .and.(&
           lwork<max(2*m+n,6*n+2*n*n))).or. (lsvec .and. rsvec .and. jracc .and.lwork<max(2*m+n,&
                     4*n+n*n,2*n+n*n+6)))then
              info = - 17
           else
              ! #:)
              info = 0
           end if
           if ( info /= 0 ) then
             ! #:(
              call stdlib_xerbla( 'DGEJSV', - info )
              return
           end if
           ! quick return for void matrix (y3k safe)
       ! #:)
           if ( ( m == 0 ) .or. ( n == 0 ) ) then
              iwork(1:3) = 0
              work(1:7) = 0
              return
           endif
           ! determine whether the matrix u should be m x n or m x m
           if ( lsvec ) then
              n1 = n
              if ( stdlib_lsame( jobu, 'F' ) ) n1 = m
           end if
           ! set numerical parameters
      ! !    note: make sure stdlib_${ri}$lamch() does not fail on the target architecture.
           epsln = stdlib_${ri}$lamch('EPSILON')
           sfmin = stdlib_${ri}$lamch('SAFEMINIMUM')
           small = sfmin / epsln
           big   = stdlib_${ri}$lamch('O')
           ! big   = one / sfmin
           ! initialize sva(1:n) = diag( ||a e_i||_2 )_1^n
      ! (!)  if necessary, scale sva() to protect the largest norm from
           ! overflow. it is possible that this scaling pushes the smallest
           ! column norm left from the underflow threshold (extreme case).
           scalem  = one / sqrt(real(m,KIND=${rk}$)*real(n,KIND=${rk}$))
           noscal  = .true.
           goscal  = .true.
           do p = 1, n
              aapp = zero
              aaqq = one
              call stdlib_${ri}$lassq( m, a(1,p), 1, aapp, aaqq )
              if ( aapp > big ) then
                 info = - 9
                 call stdlib_xerbla( 'DGEJSV', -info )
                 return
              end if
              aaqq = sqrt(aaqq)
              if ( ( aapp < (big / aaqq) ) .and. noscal  ) then
                 sva(p)  = aapp * aaqq
              else
                 noscal  = .false.
                 sva(p)  = aapp * ( aaqq * scalem )
                 if ( goscal ) then
                    goscal = .false.
                    call stdlib_${ri}$scal( p-1, scalem, sva, 1 )
                 end if
              end if
           end do
           if ( noscal ) scalem = one
           aapp = zero
           aaqq = big
           do p = 1, n
              aapp = max( aapp, sva(p) )
              if ( sva(p) /= zero ) aaqq = min( aaqq, sva(p) )
           end do
           ! quick return for zero m x n matrix
       ! #:)
           if ( aapp == zero ) then
              if ( lsvec ) call stdlib_${ri}$laset( 'G', m, n1, zero, one, u, ldu )
              if ( rsvec ) call stdlib_${ri}$laset( 'G', n, n,  zero, one, v, ldv )
              work(1) = one
              work(2) = one
              if ( errest ) work(3) = one
              if ( lsvec .and. rsvec ) then
                 work(4) = one
                 work(5) = one
              end if
              if ( l2tran ) then
                 work(6) = zero
                 work(7) = zero
              end if
              iwork(1) = 0
              iwork(2) = 0
              iwork(3) = 0
              return
           end if
           ! issue warning if denormalized column norms detected. override the
           ! high relative accuracy request. issue licence to kill columns
           ! (set them to zero) whose norm is less than sigma_max / big (roughly).
       ! #:(
           warning = 0
           if ( aaqq <= sfmin ) then
              l2rank = .true.
              l2kill = .true.
              warning = 1
           end if
           ! quick return for one-column matrix
       ! #:)
           if ( n == 1 ) then
              if ( lsvec ) then
                 call stdlib_${ri}$lascl( 'G',0,0,sva(1),scalem, m,1,a(1,1),lda,ierr )
                 call stdlib_${ri}$lacpy( 'A', m, 1, a, lda, u, ldu )
                 ! computing all m left singular vectors of the m x 1 matrix
                 if ( n1 /= n  ) then
                    call stdlib_${ri}$geqrf( m, n, u,ldu, work, work(n+1),lwork-n,ierr )
                    call stdlib_${ri}$orgqr( m,n1,1, u,ldu,work,work(n+1),lwork-n,ierr )
                    call stdlib_${ri}$copy( m, a(1,1), 1, u(1,1), 1 )
                 end if
              end if
              if ( rsvec ) then
                  v(1,1) = one
              end if
              if ( sva(1) < (big*scalem) ) then
                 sva(1)  = sva(1) / scalem
                 scalem  = one
              end if
              work(1) = one / scalem
              work(2) = one
              if ( sva(1) /= zero ) then
                 iwork(1) = 1
                 if ( ( sva(1) / scalem) >= sfmin ) then
                    iwork(2) = 1
                 else
                    iwork(2) = 0
                 end if
              else
                 iwork(1) = 0
                 iwork(2) = 0
              end if
              iwork(3) = 0
              if ( errest ) work(3) = one
              if ( lsvec .and. rsvec ) then
                 work(4) = one
                 work(5) = one
              end if
              if ( l2tran ) then
                 work(6) = zero
                 work(7) = zero
              end if
              return
           end if
           transp = .false.
           l2tran = l2tran .and. ( m == n )
           aatmax = -one
           aatmin =  big
           if ( rowpiv .or. l2tran ) then
           ! compute the row norms, needed to determine row pivoting sequence
           ! (in the case of heavily row weighted a, row pivoting is strongly
           ! advised) and to collect information needed to compare the
           ! structures of a * a^t and a^t * a (in the case l2tran==.true.).
              if ( l2tran ) then
                 do p = 1, m
                    xsc   = zero
                    temp1 = one
                    call stdlib_${ri}$lassq( n, a(p,1), lda, xsc, temp1 )
                    ! stdlib_${ri}$lassq gets both the ell_2 and the ell_infinity norm
                    ! in one pass through the vector
                    work(m+n+p)  = xsc * scalem
                    work(n+p)    = xsc * (scalem*sqrt(temp1))
                    aatmax = max( aatmax, work(n+p) )
                    if (work(n+p) /= zero) aatmin = min(aatmin,work(n+p))
                 end do
              else
                 do p = 1, m
                    work(m+n+p) = scalem*abs( a(p,stdlib_i${ri}$amax(n,a(p,1),lda)) )
                    aatmax = max( aatmax, work(m+n+p) )
                    aatmin = min( aatmin, work(m+n+p) )
                 end do
              end if
           end if
           ! for square matrix a try to determine whether a^t  would be  better
           ! input for the preconditioned jacobi svd, with faster convergence.
           ! the decision is based on an o(n) function of the vector of column
           ! and row norms of a, based on the shannon entropy. this should give
           ! the right choice in most cases when the difference actually matters.
           ! it may fail and pick the slower converging side.
           entra  = zero
           entrat = zero
           if ( l2tran ) then
              xsc   = zero
              temp1 = one
              call stdlib_${ri}$lassq( n, sva, 1, xsc, temp1 )
              temp1 = one / temp1
              entra = zero
              do p = 1, n
                 big1  = ( ( sva(p) / xsc )**2 ) * temp1
                 if ( big1 /= zero ) entra = entra + big1 * log(big1)
              end do
              entra = - entra / log(real(n,KIND=${rk}$))
              ! now, sva().^2/trace(a^t * a) is a point in the probability simplex.
              ! it is derived from the diagonal of  a^t * a.  do the same with the
              ! diagonal of a * a^t, compute the entropy of the corresponding
              ! probability distribution. note that a * a^t and a^t * a have the
              ! same trace.
              entrat = zero
              do p = n+1, n+m
                 big1 = ( ( work(p) / xsc )**2 ) * temp1
                 if ( big1 /= zero ) entrat = entrat + big1 * log(big1)
              end do
              entrat = - entrat / log(real(m,KIND=${rk}$))
              ! analyze the entropies and decide a or a^t. smaller entropy
              ! usually means better input for the algorithm.
              transp = ( entrat < entra )
              ! if a^t is better than a, transpose a.
              if ( transp ) then
                 ! in an optimal implementation, this trivial transpose
                 ! should be replaced with faster transpose.
                 do p = 1, n - 1
                    do q = p + 1, n
                        temp1 = a(q,p)
                       a(q,p) = a(p,q)
                       a(p,q) = temp1
                    end do
                 end do
                 do p = 1, n
                    work(m+n+p) = sva(p)
                    sva(p)      = work(n+p)
                 end do
                 temp1  = aapp
                 aapp   = aatmax
                 aatmax = temp1
                 temp1  = aaqq
                 aaqq   = aatmin
                 aatmin = temp1
                 kill   = lsvec
                 lsvec  = rsvec
                 rsvec  = kill
                 if ( lsvec ) n1 = n
                 rowpiv = .true.
              end if
           end if
           ! end if l2tran
           ! scale the matrix so that its maximal singular value remains less
           ! than sqrt(big) -- the matrix is scaled so that its maximal column
           ! has euclidean norm equal to sqrt(big/n). the only reason to keep
           ! sqrt(big) instead of big is the fact that stdlib_${ri}$gejsv uses lapack and
           ! blas routines that, in some implementations, are not capable of
           ! working in the full interval [sfmin,big] and that they may provoke
           ! overflows in the intermediate results. if the singular values spread
           ! from sfmin to big, then stdlib_${ri}$gesvj will compute them. so, in that case,
           ! one should use stdlib_${ri}$gesvj instead of stdlib_${ri}$gejsv.
           big1   = sqrt( big )
           temp1  = sqrt( big / real(n,KIND=${rk}$) )
           call stdlib_${ri}$lascl( 'G', 0, 0, aapp, temp1, n, 1, sva, n, ierr )
           if ( aaqq > (aapp * sfmin) ) then
               aaqq = ( aaqq / aapp ) * temp1
           else
               aaqq = ( aaqq * temp1 ) / aapp
           end if
           temp1 = temp1 * scalem
           call stdlib_${ri}$lascl( 'G', 0, 0, aapp, temp1, m, n, a, lda, ierr )
           ! to undo scaling at the end of this procedure, multiply the
           ! computed singular values with uscal2 / uscal1.
           uscal1 = temp1
           uscal2 = aapp
           if ( l2kill ) then
              ! l2kill enforces computation of nonzero singular values in
              ! the restricted range of condition number of the initial a,
              ! sigma_max(a) / sigma_min(a) approx. sqrt(big)/sqrt(sfmin).
              xsc = sqrt( sfmin )
           else
              xsc = small
              ! now, if the condition number of a is too big,
              ! sigma_max(a) / sigma_min(a) > sqrt(big/n) * epsln / sfmin,
              ! as a precaution measure, the full svd is computed using stdlib_${ri}$gesvj
              ! with accumulated jacobi rotations. this provides numerically
              ! more robust computation, at the cost of slightly increased run
              ! time. depending on the concrete implementation of blas and lapack
              ! (i.e. how they behave in presence of extreme ill-conditioning) the
              ! implementor may decide to remove this switch.
              if ( ( aaqq<sqrt(sfmin) ) .and. lsvec .and. rsvec ) then
                 jracc = .true.
              end if
           end if
           if ( aaqq < xsc ) then
              do p = 1, n
                 if ( sva(p) < xsc ) then
                    call stdlib_${ri}$laset( 'A', m, 1, zero, zero, a(1,p), lda )
                    sva(p) = zero
                 end if
              end do
           end if
           ! preconditioning using qr factorization with pivoting
           if ( rowpiv ) then
              ! optional row permutation (bjoerck row pivoting):
              ! a result by cox and higham shows that the bjoerck's
              ! row pivoting combined with standard column pivoting
              ! has similar effect as powell-reid complete pivoting.
              ! the ell-infinity norms of a are made nonincreasing.
              do p = 1, m - 1
                 q = stdlib_i${ri}$amax( m-p+1, work(m+n+p), 1 ) + p - 1
                 iwork(2*n+p) = q
                 if ( p /= q ) then
                    temp1       = work(m+n+p)
                    work(m+n+p) = work(m+n+q)
                    work(m+n+q) = temp1
                 end if
              end do
              call stdlib_${ri}$laswp( n, a, lda, 1, m-1, iwork(2*n+1), 1 )
           end if
           ! end of the preparation phase (scaling, optional sorting and
           ! transposing, optional flushing of small columns).
           ! preconditioning
           ! if the full svd is needed, the right singular vectors are computed
           ! from a matrix equation, and for that we need theoretical analysis
           ! of the businger-golub pivoting. so we use stdlib_${ri}$geqp3 as the first rr qrf.
           ! in all other cases the first rr qrf can be chosen by other criteria
           ! (eg speed by replacing global with restricted window pivoting, such
           ! as in sgeqpx from toms # 782). good results will be obtained using
           ! sgeqpx with properly (!) chosen numerical parameters.
           ! any improvement of stdlib_${ri}$geqp3 improves overall performance of stdlib_${ri}$gejsv.
           ! a * p1 = q1 * [ r1^t 0]^t:
           do p = 1, n
              ! All Columns Are Free Columns
              iwork(p) = 0
           end do
           call stdlib_${ri}$geqp3( m,n,a,lda, iwork,work, work(n+1),lwork-n, ierr )
           ! the upper triangular matrix r1 from the first qrf is inspected for
           ! rank deficiency and possibilities for deflation, or possible
           ! ill-conditioning. depending on the user specified flag l2rank,
           ! the procedure explores possibilities to reduce the numerical
           ! rank by inspecting the computed upper triangular factor. if
           ! l2rank or l2aber are up, then stdlib_${ri}$gejsv will compute the svd of
           ! a + da, where ||da|| <= f(m,n)*epsln.
           nr = 1
           if ( l2aber ) then
              ! standard absolute error bound suffices. all sigma_i with
              ! sigma_i < n*epsln*||a|| are flushed to zero. this is an
              ! aggressive enforcement of lower numerical rank by introducing a
              ! backward error of the order of n*epsln*||a||.
              temp1 = sqrt(real(n,KIND=${rk}$))*epsln
              do p = 2, n
                 if ( abs(a(p,p)) >= (temp1*abs(a(1,1))) ) then
                    nr = nr + 1
                 else
                    go to 3002
                 end if
              end do
              3002 continue
           else if ( l2rank ) then
              ! .. similarly as above, only slightly more gentle (less aggressive).
              ! sudden drop on the diagonal of r1 is used as the criterion for
              ! close-to-rank-deficient.
              temp1 = sqrt(sfmin)
              do p = 2, n
                 if ( ( abs(a(p,p)) < (epsln*abs(a(p-1,p-1))) ) .or.( abs(a(p,p)) < small ) .or.( &
                           l2kill .and. (abs(a(p,p)) < temp1) ) ) go to 3402
                 nr = nr + 1
              end do
              3402 continue
           else
              ! the goal is high relative accuracy. however, if the matrix
              ! has high scaled condition number the relative accuracy is in
              ! general not feasible. later on, a condition number estimator
              ! will be deployed to estimate the scaled condition number.
              ! here we just remove the underflowed part of the triangular
              ! factor. this prevents the situation in which the code is
              ! working hard to get the accuracy not warranted by the data.
              temp1  = sqrt(sfmin)
              do p = 2, n
                 if ( ( abs(a(p,p)) < small ) .or.( l2kill .and. (abs(a(p,p)) < temp1) ) ) go to &
                           3302
                 nr = nr + 1
              end do
              3302 continue
           end if
           almort = .false.
           if ( nr == n ) then
              maxprj = one
              do p = 2, n
                 temp1  = abs(a(p,p)) / sva(iwork(p))
                 maxprj = min( maxprj, temp1 )
              end do
              if ( maxprj**2 >= one - real(n,KIND=${rk}$)*epsln ) almort = .true.
           end if
           sconda = - one
           condr1 = - one
           condr2 = - one
           if ( errest ) then
              if ( n == nr ) then
                 if ( rsvec ) then
                    ! V Is Available As Workspace
                    call stdlib_${ri}$lacpy( 'U', n, n, a, lda, v, ldv )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_${ri}$scal( p, one/temp1, v(1,p), 1 )
                    end do
                    call stdlib_${ri}$pocon( 'U', n, v, ldv, one, temp1,work(n+1), iwork(2*n+m+1), &
                              ierr )
                 else if ( lsvec ) then
                    ! U Is Available As Workspace
                    call stdlib_${ri}$lacpy( 'U', n, n, a, lda, u, ldu )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_${ri}$scal( p, one/temp1, u(1,p), 1 )
                    end do
                    call stdlib_${ri}$pocon( 'U', n, u, ldu, one, temp1,work(n+1), iwork(2*n+m+1), &
                              ierr )
                 else
                    call stdlib_${ri}$lacpy( 'U', n, n, a, lda, work(n+1), n )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_${ri}$scal( p, one/temp1, work(n+(p-1)*n+1), 1 )
                    end do
                 ! The Columns Of R Are Scaled To Have Unit Euclidean Lengths
                    call stdlib_${ri}$pocon( 'U', n, work(n+1), n, one, temp1,work(n+n*n+1), iwork(2*n+&
                              m+1), ierr )
                 end if
                 sconda = one / sqrt(temp1)
                 ! sconda is an estimate of sqrt(||(r^t * r)^(-1)||_1).
                 ! n^(-1/4) * sconda <= ||r^(-1)||_2 <= n^(1/4) * sconda
              else
                 sconda = - one
              end if
           end if
           l2pert = l2pert .and. ( abs( a(1,1)/a(nr,nr) ) > sqrt(big1) )
           ! if there is no violent scaling, artificial perturbation is not needed.
           ! phase 3:
           if ( .not. ( rsvec .or. lsvec ) ) then
               ! singular values only
               ! .. transpose a(1:nr,1:n)
              do p = 1, min( n-1, nr )
                 call stdlib_${ri}$copy( n-p, a(p,p+1), lda, a(p+1,p), 1 )
              end do
              ! the following two do-loops introduce small relative perturbation
              ! into the strict upper triangle of the lower triangular matrix.
              ! small entries below the main diagonal are also changed.
              ! this modification is useful if the computing environment does not
              ! provide/allow flush to zero underflow, for it prevents many
              ! annoying denormalized numbers in case of strongly scaled matrices.
              ! the perturbation is structured so that it does not introduce any
              ! new perturbation of the singular values, and it does not destroy
              ! the job done by the preconditioner.
              ! the licence for this perturbation is in the variable l2pert, which
              ! should be .false. if flush to zero underflow is active.
              if ( .not. almort ) then
                 if ( l2pert ) then
                    ! xsc = sqrt(small)
                    xsc = epsln / real(n,KIND=${rk}$)
                    do q = 1, nr
                       temp1 = xsc*abs(a(q,q))
                       do p = 1, n
                          if ( ( (p>q) .and. (abs(a(p,q))<=temp1) ).or. ( p < q ) )a(p,q) = sign( &
                                    temp1, a(p,q) )
                       end do
                    end do
                 else
                    call stdlib_${ri}$laset( 'U', nr-1,nr-1, zero,zero, a(1,2),lda )
                 end if
                  ! Second Preconditioning Using The Qr Factorization
                 call stdlib_${ri}$geqrf( n,nr, a,lda, work, work(n+1),lwork-n, ierr )
                 ! And Transpose Upper To Lower Triangular
                 do p = 1, nr - 1
                    call stdlib_${ri}$copy( nr-p, a(p,p+1), lda, a(p+1,p), 1 )
                 end do
              end if
                 ! row-cyclic jacobi svd algorithm with column pivoting
                 ! .. again some perturbation (a "background noise") is added
                 ! to drown denormals
                 if ( l2pert ) then
                    ! xsc = sqrt(small)
                    xsc = epsln / real(n,KIND=${rk}$)
                    do q = 1, nr
                       temp1 = xsc*abs(a(q,q))
                       do p = 1, nr
                          if ( ( (p>q) .and. (abs(a(p,q))<=temp1) ).or. ( p < q ) )a(p,q) = sign( &
                                    temp1, a(p,q) )
                       end do
                    end do
                 else
                    call stdlib_${ri}$laset( 'U', nr-1, nr-1, zero, zero, a(1,2), lda )
                 end if
                 ! .. and one-sided jacobi rotations are started on a lower
                 ! triangular matrix (plus perturbation which is ignored in
                 ! the part which destroys triangular form (confusing?!))
                 call stdlib_${ri}$gesvj( 'L', 'NOU', 'NOV', nr, nr, a, lda, sva,n, v, ldv, work, &
                           lwork, info )
                 scalem  = work(1)
                 numrank = nint(work(2),KIND=ilp)
           else if ( rsvec .and. ( .not. lsvec ) ) then
              ! -> singular values and right singular vectors <-
              if ( almort ) then
                 ! In This Case Nr Equals N
                 do p = 1, nr
                    call stdlib_${ri}$copy( n-p+1, a(p,p), lda, v(p,p), 1 )
                 end do
                 call stdlib_${ri}$laset( 'UPPER', nr-1, nr-1, zero, zero, v(1,2), ldv )
                 call stdlib_${ri}$gesvj( 'L','U','N', n, nr, v,ldv, sva, nr, a,lda,work, lwork, info )
                           
                 scalem  = work(1)
                 numrank = nint(work(2),KIND=ilp)
              else
              ! .. two more qr factorizations ( one qrf is not enough, two require
              ! accumulated product of jacobi rotations, three are perfect )
                 call stdlib_${ri}$laset( 'LOWER', nr-1, nr-1, zero, zero, a(2,1), lda )
                 call stdlib_${ri}$gelqf( nr, n, a, lda, work, work(n+1), lwork-n, ierr)
                 call stdlib_${ri}$lacpy( 'LOWER', nr, nr, a, lda, v, ldv )
                 call stdlib_${ri}$laset( 'UPPER', nr-1, nr-1, zero, zero, v(1,2), ldv )
                 call stdlib_${ri}$geqrf( nr, nr, v, ldv, work(n+1), work(2*n+1),lwork-2*n, ierr )
                           
                 do p = 1, nr
                    call stdlib_${ri}$copy( nr-p+1, v(p,p), ldv, v(p,p), 1 )
                 end do
                 call stdlib_${ri}$laset( 'UPPER', nr-1, nr-1, zero, zero, v(1,2), ldv )
                 call stdlib_${ri}$gesvj( 'LOWER', 'U','N', nr, nr, v,ldv, sva, nr, u,ldu, work(n+1), &
                           lwork, info )
                 scalem  = work(n+1)
                 numrank = nint(work(n+2),KIND=ilp)
                 if ( nr < n ) then
                    call stdlib_${ri}$laset( 'A',n-nr, nr, zero,zero, v(nr+1,1),   ldv )
                    call stdlib_${ri}$laset( 'A',nr, n-nr, zero,zero, v(1,nr+1),   ldv )
                    call stdlib_${ri}$laset( 'A',n-nr,n-nr,zero,one, v(nr+1,nr+1), ldv )
                 end if
              call stdlib_${ri}$ormlq( 'LEFT', 'TRANSPOSE', n, n, nr, a, lda, work,v, ldv, work(n+1), &
                        lwork-n, ierr )
              end if
              do p = 1, n
                 call stdlib_${ri}$copy( n, v(p,1), ldv, a(iwork(p),1), lda )
              end do
              call stdlib_${ri}$lacpy( 'ALL', n, n, a, lda, v, ldv )
              if ( transp ) then
                 call stdlib_${ri}$lacpy( 'ALL', n, n, v, ldv, u, ldu )
              end if
           else if ( lsvec .and. ( .not. rsvec ) ) then
              ! Singular Values And Left Singular Vectors                 
              ! Second Preconditioning Step To Avoid Need To Accumulate
              ! jacobi rotations in the jacobi iterations.
              do p = 1, nr
                 call stdlib_${ri}$copy( n-p+1, a(p,p), lda, u(p,p), 1 )
              end do
              call stdlib_${ri}$laset( 'UPPER', nr-1, nr-1, zero, zero, u(1,2), ldu )
              call stdlib_${ri}$geqrf( n, nr, u, ldu, work(n+1), work(2*n+1),lwork-2*n, ierr )
              do p = 1, nr - 1
                 call stdlib_${ri}$copy( nr-p, u(p,p+1), ldu, u(p+1,p), 1 )
              end do
              call stdlib_${ri}$laset( 'UPPER', nr-1, nr-1, zero, zero, u(1,2), ldu )
              call stdlib_${ri}$gesvj( 'LOWER', 'U', 'N', nr,nr, u, ldu, sva, nr, a,lda, work(n+1), &
                        lwork-n, info )
              scalem  = work(n+1)
              numrank = nint(work(n+2),KIND=ilp)
              if ( nr < m ) then
                 call stdlib_${ri}$laset( 'A',  m-nr, nr,zero, zero, u(nr+1,1), ldu )
                 if ( nr < n1 ) then
                    call stdlib_${ri}$laset( 'A',nr, n1-nr, zero, zero, u(1,nr+1), ldu )
                    call stdlib_${ri}$laset( 'A',m-nr,n1-nr,zero,one,u(nr+1,nr+1), ldu )
                 end if
              end if
              call stdlib_${ri}$ormqr( 'LEFT', 'NO TR', m, n1, n, a, lda, work, u,ldu, work(n+1), &
                        lwork-n, ierr )
              if ( rowpiv )call stdlib_${ri}$laswp( n1, u, ldu, 1, m-1, iwork(2*n+1), -1 )
              do p = 1, n1
                 xsc = one / stdlib_${ri}$nrm2( m, u(1,p), 1 )
                 call stdlib_${ri}$scal( m, xsc, u(1,p), 1 )
              end do
              if ( transp ) then
                 call stdlib_${ri}$lacpy( 'ALL', n, n, u, ldu, v, ldv )
              end if
           else
              ! Full Svd 
              if ( .not. jracc ) then
              if ( .not. almort ) then
                 ! second preconditioning step (qrf [with pivoting])
                 ! note that the composition of transpose, qrf and transpose is
                 ! equivalent to an lqf call. since in many libraries the qrf
                 ! seems to be better optimized than the lqf, we do explicit
                 ! transpose and use the qrf. this is subject to changes in an
                 ! optimized implementation of stdlib_${ri}$gejsv.
                 do p = 1, nr
                    call stdlib_${ri}$copy( n-p+1, a(p,p), lda, v(p,p), 1 )
                 end do
                 ! The Following Two Loops Perturb Small Entries To Avoid
                 ! denormals in the second qr factorization, where they are
                 ! as good as zeros. this is done to avoid painfully slow
                 ! computation with denormals. the relative size of the perturbation
                 ! is a parameter that can be changed by the implementer.
                 ! this perturbation device will be obsolete on machines with
                 ! properly implemented arithmetic.
                 ! to switch it off, set l2pert=.false. to remove it from  the
                 ! code, remove the action under l2pert=.true., leave the else part.
                 ! the following two loops should be blocked and fused with the
                 ! transposed copy above.
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do q = 1, nr
                       temp1 = xsc*abs( v(q,q) )
                       do p = 1, n
                          if ( ( p > q ) .and. ( abs(v(p,q)) <= temp1 ).or. ( p < q ) )v(p,q) = &
                                    sign( temp1, v(p,q) )
                          if ( p < q ) v(p,q) = - v(p,q)
                       end do
                    end do
                 else
                    call stdlib_${ri}$laset( 'U', nr-1, nr-1, zero, zero, v(1,2), ldv )
                 end if
                 ! estimate the row scaled condition number of r1
                 ! (if r1 is rectangular, n > nr, then the condition number
                 ! of the leading nr x nr submatrix is estimated.)
                 call stdlib_${ri}$lacpy( 'L', nr, nr, v, ldv, work(2*n+1), nr )
                 do p = 1, nr
                    temp1 = stdlib_${ri}$nrm2(nr-p+1,work(2*n+(p-1)*nr+p),1)
                    call stdlib_${ri}$scal(nr-p+1,one/temp1,work(2*n+(p-1)*nr+p),1)
                 end do
                 call stdlib_${ri}$pocon('LOWER',nr,work(2*n+1),nr,one,temp1,work(2*n+nr*nr+1),iwork(m+&
                           2*n+1),ierr)
                 condr1 = one / sqrt(temp1)
                 ! Here Need A Second Opinion On The Condition Number
                 ! Then Assume Worst Case Scenario
                 ! r1 is ok for inverse <=> condr1 < real(n,KIND=${rk}$)
                 ! more conservative    <=> condr1 < sqrt(real(n,KIND=${rk}$))
                 cond_ok = sqrt(real(nr,KIND=${rk}$))
      ! [tp]       cond_ok is a tuning parameter.
                 if ( condr1 < cond_ok ) then
                    ! .. the second qrf without pivoting. note: in an optimized
                    ! implementation, this qrf should be implemented as the qrf
                    ! of a lower triangular matrix.
                    ! r1^t = q2 * r2
                    call stdlib_${ri}$geqrf( n, nr, v, ldv, work(n+1), work(2*n+1),lwork-2*n, ierr )
                              
                    if ( l2pert ) then
                       xsc = sqrt(small)/epsln
                       do p = 2, nr
                          do q = 1, p - 1
                             temp1 = xsc * min(abs(v(p,p)),abs(v(q,q)))
                             if ( abs(v(q,p)) <= temp1 )v(q,p) = sign( temp1, v(q,p) )
                          end do
                       end do
                    end if
                    if ( nr /= n )call stdlib_${ri}$lacpy( 'A', n, nr, v, ldv, work(2*n+1), n )
                    ! .. save ...
                 ! This Transposed Copy Should Be Better Than Naive
                    do p = 1, nr - 1
                       call stdlib_${ri}$copy( nr-p, v(p,p+1), ldv, v(p+1,p), 1 )
                    end do
                    condr2 = condr1
                 else
                    ! .. ill-conditioned case: second qrf with pivoting
                    ! note that windowed pivoting would be equally good
                    ! numerically, and more run-time efficient. so, in
                    ! an optimal implementation, the next call to stdlib_${ri}$geqp3
                    ! should be replaced with eg. call sgeqpx (acm toms #782)
                    ! with properly (carefully) chosen parameters.
                    ! r1^t * p2 = q2 * r2
                    do p = 1, nr
                       iwork(n+p) = 0
                    end do
                    call stdlib_${ri}$geqp3( n, nr, v, ldv, iwork(n+1), work(n+1),work(2*n+1), lwork-&
                              2*n, ierr )
      ! *               call stdlib_${ri}$geqrf( n, nr, v, ldv, work(n+1), work(2*n+1),
      ! *     $              lwork-2*n, ierr )
                    if ( l2pert ) then
                       xsc = sqrt(small)
                       do p = 2, nr
                          do q = 1, p - 1
                             temp1 = xsc * min(abs(v(p,p)),abs(v(q,q)))
                             if ( abs(v(q,p)) <= temp1 )v(q,p) = sign( temp1, v(q,p) )
                          end do
                       end do
                    end if
                    call stdlib_${ri}$lacpy( 'A', n, nr, v, ldv, work(2*n+1), n )
                    if ( l2pert ) then
                       xsc = sqrt(small)
                       do p = 2, nr
                          do q = 1, p - 1
                             temp1 = xsc * min(abs(v(p,p)),abs(v(q,q)))
                             v(p,q) = - sign( temp1, v(q,p) )
                          end do
                       end do
                    else
                       call stdlib_${ri}$laset( 'L',nr-1,nr-1,zero,zero,v(2,1),ldv )
                    end if
                    ! now, compute r2 = l3 * q3, the lq factorization.
                    call stdlib_${ri}$gelqf( nr, nr, v, ldv, work(2*n+n*nr+1),work(2*n+n*nr+nr+1), &
                              lwork-2*n-n*nr-nr, ierr )
                    ! And Estimate The Condition Number
                    call stdlib_${ri}$lacpy( 'L',nr,nr,v,ldv,work(2*n+n*nr+nr+1),nr )
                    do p = 1, nr
                       temp1 = stdlib_${ri}$nrm2( p, work(2*n+n*nr+nr+p), nr )
                       call stdlib_${ri}$scal( p, one/temp1, work(2*n+n*nr+nr+p), nr )
                    end do
                    call stdlib_${ri}$pocon( 'L',nr,work(2*n+n*nr+nr+1),nr,one,temp1,work(2*n+n*nr+nr+&
                              nr*nr+1),iwork(m+2*n+1),ierr )
                    condr2 = one / sqrt(temp1)
                    if ( condr2 >= cond_ok ) then
                       ! Save The Householder Vectors Used For Q3
                       ! (this overwrites the copy of r2, as it will not be
                       ! needed in this branch, but it does not overwritte the
                       ! huseholder vectors of q2.).
                       call stdlib_${ri}$lacpy( 'U', nr, nr, v, ldv, work(2*n+1), n )
                       ! And The Rest Of The Information On Q3 Is In
                       ! work(2*n+n*nr+1:2*n+n*nr+n)
                    end if
                 end if
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do q = 2, nr
                       temp1 = xsc * v(q,q)
                       do p = 1, q - 1
                          ! v(p,q) = - sign( temp1, v(q,p) )
                          v(p,q) = - sign( temp1, v(p,q) )
                       end do
                    end do
                 else
                    call stdlib_${ri}$laset( 'U', nr-1,nr-1, zero,zero, v(1,2), ldv )
                 end if
              ! second preconditioning finished; continue with jacobi svd
              ! the input matrix is lower trinagular.
              ! recover the right singular vectors as solution of a well
              ! conditioned triangular matrix equation.
                 if ( condr1 < cond_ok ) then
                    call stdlib_${ri}$gesvj( 'L','U','N',nr,nr,v,ldv,sva,nr,u,ldu,work(2*n+n*nr+nr+1),&
                              lwork-2*n-n*nr-nr,info )
                    scalem  = work(2*n+n*nr+nr+1)
                    numrank = nint(work(2*n+n*nr+nr+2),KIND=ilp)
                    do p = 1, nr
                       call stdlib_${ri}$copy( nr, v(1,p), 1, u(1,p), 1 )
                       call stdlib_${ri}$scal( nr, sva(p),    v(1,p), 1 )
                    end do
              ! Pick The Right Matrix Equation And Solve It
                    if ( nr == n ) then
       ! :))             .. best case, r1 is inverted. the solution of this matrix
                       ! equation is q2*v2 = the product of the jacobi rotations
                       ! used in stdlib_${ri}$gesvj, premultiplied with the orthogonal matrix
                       ! from the second qr factorization.
                       call stdlib_${ri}$trsm( 'L','U','N','N', nr,nr,one, a,lda, v,ldv )
                    else
                       ! .. r1 is well conditioned, but non-square. transpose(r2)
                       ! is inverted to get the product of the jacobi rotations
                       ! used in stdlib_${ri}$gesvj. the q-factor from the second qr
                       ! factorization is then built in explicitly.
                       call stdlib_${ri}$trsm('L','U','T','N',nr,nr,one,work(2*n+1),n,v,ldv)
                       if ( nr < n ) then
                         call stdlib_${ri}$laset('A',n-nr,nr,zero,zero,v(nr+1,1),ldv)
                         call stdlib_${ri}$laset('A',nr,n-nr,zero,zero,v(1,nr+1),ldv)
                         call stdlib_${ri}$laset('A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv)
                       end if
                       call stdlib_${ri}$ormqr('L','N',n,n,nr,work(2*n+1),n,work(n+1),v,ldv,work(2*n+&
                                 n*nr+nr+1),lwork-2*n-n*nr-nr,ierr)
                    end if
                 else if ( condr2 < cond_ok ) then
       ! :)           .. the input matrix a is very likely a relative of
                    ! the kahan matrix :)
                    ! the matrix r2 is inverted. the solution of the matrix equation
                    ! is q3^t*v3 = the product of the jacobi rotations (appplied to
                    ! the lower triangular l3 from the lq factorization of
                    ! r2=l3*q3), pre-multiplied with the transposed q3.
                    call stdlib_${ri}$gesvj( 'L', 'U', 'N', nr, nr, v, ldv, sva, nr, u,ldu, work(2*n+&
                              n*nr+nr+1), lwork-2*n-n*nr-nr, info )
                    scalem  = work(2*n+n*nr+nr+1)
                    numrank = nint(work(2*n+n*nr+nr+2),KIND=ilp)
                    do p = 1, nr
                       call stdlib_${ri}$copy( nr, v(1,p), 1, u(1,p), 1 )
                       call stdlib_${ri}$scal( nr, sva(p),    u(1,p), 1 )
                    end do
                    call stdlib_${ri}$trsm('L','U','N','N',nr,nr,one,work(2*n+1),n,u,ldu)
                    ! Apply The Permutation From The Second Qr Factorization
                    do q = 1, nr
                       do p = 1, nr
                          work(2*n+n*nr+nr+iwork(n+p)) = u(p,q)
                       end do
                       do p = 1, nr
                          u(p,q) = work(2*n+n*nr+nr+p)
                       end do
                    end do
                    if ( nr < n ) then
                       call stdlib_${ri}$laset( 'A',n-nr,nr,zero,zero,v(nr+1,1),ldv )
                       call stdlib_${ri}$laset( 'A',nr,n-nr,zero,zero,v(1,nr+1),ldv )
                       call stdlib_${ri}$laset( 'A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv )
                    end if
                    call stdlib_${ri}$ormqr( 'L','N',n,n,nr,work(2*n+1),n,work(n+1),v,ldv,work(2*n+&
                              n*nr+nr+1),lwork-2*n-n*nr-nr,ierr )
                 else
                    ! last line of defense.
       ! #:(          this is a rather pathological case: no scaled condition
                    ! improvement after two pivoted qr factorizations. other
                    ! possibility is that the rank revealing qr factorization
                    ! or the condition estimator has failed, or the cond_ok
                    ! is set very close to one (which is unnecessary). normally,
                    ! this branch should never be executed, but in rare cases of
                    ! failure of the rrqr or condition estimator, the last line of
                    ! defense ensures that stdlib_${ri}$gejsv completes the task.
                    ! compute the full svd of l3 using stdlib_${ri}$gesvj with explicit
                    ! accumulation of jacobi rotations.
                    call stdlib_${ri}$gesvj( 'L', 'U', 'V', nr, nr, v, ldv, sva, nr, u,ldu, work(2*n+&
                              n*nr+nr+1), lwork-2*n-n*nr-nr, info )
                    scalem  = work(2*n+n*nr+nr+1)
                    numrank = nint(work(2*n+n*nr+nr+2),KIND=ilp)
                    if ( nr < n ) then
                       call stdlib_${ri}$laset( 'A',n-nr,nr,zero,zero,v(nr+1,1),ldv )
                       call stdlib_${ri}$laset( 'A',nr,n-nr,zero,zero,v(1,nr+1),ldv )
                       call stdlib_${ri}$laset( 'A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv )
                    end if
                    call stdlib_${ri}$ormqr( 'L','N',n,n,nr,work(2*n+1),n,work(n+1),v,ldv,work(2*n+&
                              n*nr+nr+1),lwork-2*n-n*nr-nr,ierr )
                    call stdlib_${ri}$ormlq( 'L', 'T', nr, nr, nr, work(2*n+1), n,work(2*n+n*nr+1), u, &
                              ldu, work(2*n+n*nr+nr+1),lwork-2*n-n*nr-nr, ierr )
                    do q = 1, nr
                       do p = 1, nr
                          work(2*n+n*nr+nr+iwork(n+p)) = u(p,q)
                       end do
                       do p = 1, nr
                          u(p,q) = work(2*n+n*nr+nr+p)
                       end do
                    end do
                 end if
                 ! permute the rows of v using the (column) permutation from the
                 ! first qrf. also, scale the columns to make them unit in
                 ! euclidean norm. this applies to all cases.
                 temp1 = sqrt(real(n,KIND=${rk}$)) * epsln
                 do q = 1, n
                    do p = 1, n
                       work(2*n+n*nr+nr+iwork(p)) = v(p,q)
                    end do
                    do p = 1, n
                       v(p,q) = work(2*n+n*nr+nr+p)
                    end do
                    xsc = one / stdlib_${ri}$nrm2( n, v(1,q), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_${ri}$scal( n, xsc, &
                              v(1,q), 1 )
                 end do
                 ! at this moment, v contains the right singular vectors of a.
                 ! next, assemble the left singular vector matrix u (m x n).
                 if ( nr < m ) then
                    call stdlib_${ri}$laset( 'A', m-nr, nr, zero, zero, u(nr+1,1), ldu )
                    if ( nr < n1 ) then
                       call stdlib_${ri}$laset('A',nr,n1-nr,zero,zero,u(1,nr+1),ldu)
                       call stdlib_${ri}$laset('A',m-nr,n1-nr,zero,one,u(nr+1,nr+1),ldu)
                    end if
                 end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! matrix u. this applies to all cases.
                 call stdlib_${ri}$ormqr( 'LEFT', 'NO_TR', m, n1, n, a, lda, work, u,ldu, work(n+1), &
                           lwork-n, ierr )
                 ! the columns of u are normalized. the cost is o(m*n) flops.
                 temp1 = sqrt(real(m,KIND=${rk}$)) * epsln
                 do p = 1, nr
                    xsc = one / stdlib_${ri}$nrm2( m, u(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_${ri}$scal( m, xsc, &
                              u(1,p), 1 )
                 end do
                 ! if the initial qrf is computed with row pivoting, the left
                 ! singular vectors must be adjusted.
                 if ( rowpiv )call stdlib_${ri}$laswp( n1, u, ldu, 1, m-1, iwork(2*n+1), -1 )
              else
              ! The Initial Matrix A Has Almost Orthogonal Columns And
              ! the second qrf is not needed
                 call stdlib_${ri}$lacpy( 'UPPER', n, n, a, lda, work(n+1), n )
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do p = 2, n
                       temp1 = xsc * work( n + (p-1)*n + p )
                       do q = 1, p - 1
                          work(n+(q-1)*n+p)=-sign(temp1,work(n+(p-1)*n+q))
                       end do
                    end do
                 else
                    call stdlib_${ri}$laset( 'LOWER',n-1,n-1,zero,zero,work(n+2),n )
                 end if
                 call stdlib_${ri}$gesvj( 'UPPER', 'U', 'N', n, n, work(n+1), n, sva,n, u, ldu, work(n+&
                           n*n+1), lwork-n-n*n, info )
                 scalem  = work(n+n*n+1)
                 numrank = nint(work(n+n*n+2),KIND=ilp)
                 do p = 1, n
                    call stdlib_${ri}$copy( n, work(n+(p-1)*n+1), 1, u(1,p), 1 )
                    call stdlib_${ri}$scal( n, sva(p), work(n+(p-1)*n+1), 1 )
                 end do
                 call stdlib_${ri}$trsm( 'LEFT', 'UPPER', 'NOTRANS', 'NO UD', n, n,one, a, lda, work(n+&
                           1), n )
                 do p = 1, n
                    call stdlib_${ri}$copy( n, work(n+p), n, v(iwork(p),1), ldv )
                 end do
                 temp1 = sqrt(real(n,KIND=${rk}$))*epsln
                 do p = 1, n
                    xsc = one / stdlib_${ri}$nrm2( n, v(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_${ri}$scal( n, xsc, &
                              v(1,p), 1 )
                 end do
                 ! assemble the left singular vector matrix u (m x n).
                 if ( n < m ) then
                    call stdlib_${ri}$laset( 'A',  m-n, n, zero, zero, u(n+1,1), ldu )
                    if ( n < n1 ) then
                       call stdlib_${ri}$laset( 'A',n,  n1-n, zero, zero,  u(1,n+1),ldu )
                       call stdlib_${ri}$laset( 'A',m-n,n1-n, zero, one,u(n+1,n+1),ldu )
                    end if
                 end if
                 call stdlib_${ri}$ormqr( 'LEFT', 'NO TR', m, n1, n, a, lda, work, u,ldu, work(n+1), &
                           lwork-n, ierr )
                 temp1 = sqrt(real(m,KIND=${rk}$))*epsln
                 do p = 1, n1
                    xsc = one / stdlib_${ri}$nrm2( m, u(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_${ri}$scal( m, xsc, &
                              u(1,p), 1 )
                 end do
                 if ( rowpiv )call stdlib_${ri}$laswp( n1, u, ldu, 1, m-1, iwork(2*n+1), -1 )
              end if
              ! end of the  >> almost orthogonal case <<  in the full svd
              else
              ! this branch deploys a preconditioned jacobi svd with explicitly
              ! accumulated rotations. it is included as optional, mainly for
              ! experimental purposes. it does perform well, and can also be used.
              ! in this implementation, this branch will be automatically activated
              ! if the  condition number sigma_max(a) / sigma_min(a) is predicted
              ! to be greater than the overflow threshold. this is because the
              ! a posteriori computation of the singular vectors assumes robust
              ! implementation of blas and some lapack procedures, capable of working
              ! in presence of extreme values. since that is not always the case, ...
              do p = 1, nr
                 call stdlib_${ri}$copy( n-p+1, a(p,p), lda, v(p,p), 1 )
              end do
              if ( l2pert ) then
                 xsc = sqrt(small/epsln)
                 do q = 1, nr
                    temp1 = xsc*abs( v(q,q) )
                    do p = 1, n
                       if ( ( p > q ) .and. ( abs(v(p,q)) <= temp1 ).or. ( p < q ) )v(p,q) = sign(&
                                  temp1, v(p,q) )
                       if ( p < q ) v(p,q) = - v(p,q)
                    end do
                 end do
              else
                 call stdlib_${ri}$laset( 'U', nr-1, nr-1, zero, zero, v(1,2), ldv )
              end if
              call stdlib_${ri}$geqrf( n, nr, v, ldv, work(n+1), work(2*n+1),lwork-2*n, ierr )
              call stdlib_${ri}$lacpy( 'L', n, nr, v, ldv, work(2*n+1), n )
              do p = 1, nr
                 call stdlib_${ri}$copy( nr-p+1, v(p,p), ldv, u(p,p), 1 )
              end do
              if ( l2pert ) then
                 xsc = sqrt(small/epsln)
                 do q = 2, nr
                    do p = 1, q - 1
                       temp1 = xsc * min(abs(u(p,p)),abs(u(q,q)))
                       u(p,q) = - sign( temp1, u(q,p) )
                    end do
                 end do
              else
                 call stdlib_${ri}$laset('U', nr-1, nr-1, zero, zero, u(1,2), ldu )
              end if
              call stdlib_${ri}$gesvj( 'G', 'U', 'V', nr, nr, u, ldu, sva,n, v, ldv, work(2*n+n*nr+1), &
                        lwork-2*n-n*nr, info )
              scalem  = work(2*n+n*nr+1)
              numrank = nint(work(2*n+n*nr+2),KIND=ilp)
              if ( nr < n ) then
                 call stdlib_${ri}$laset( 'A',n-nr,nr,zero,zero,v(nr+1,1),ldv )
                 call stdlib_${ri}$laset( 'A',nr,n-nr,zero,zero,v(1,nr+1),ldv )
                 call stdlib_${ri}$laset( 'A',n-nr,n-nr,zero,one,v(nr+1,nr+1),ldv )
              end if
              call stdlib_${ri}$ormqr( 'L','N',n,n,nr,work(2*n+1),n,work(n+1),v,ldv,work(2*n+n*nr+nr+1)&
                        ,lwork-2*n-n*nr-nr,ierr )
                 ! permute the rows of v using the (column) permutation from the
                 ! first qrf. also, scale the columns to make them unit in
                 ! euclidean norm. this applies to all cases.
                 temp1 = sqrt(real(n,KIND=${rk}$)) * epsln
                 do q = 1, n
                    do p = 1, n
                       work(2*n+n*nr+nr+iwork(p)) = v(p,q)
                    end do
                    do p = 1, n
                       v(p,q) = work(2*n+n*nr+nr+p)
                    end do
                    xsc = one / stdlib_${ri}$nrm2( n, v(1,q), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_${ri}$scal( n, xsc, &
                              v(1,q), 1 )
                 end do
                 ! at this moment, v contains the right singular vectors of a.
                 ! next, assemble the left singular vector matrix u (m x n).
              if ( nr < m ) then
                 call stdlib_${ri}$laset( 'A',  m-nr, nr, zero, zero, u(nr+1,1), ldu )
                 if ( nr < n1 ) then
                    call stdlib_${ri}$laset( 'A',nr,  n1-nr, zero, zero,  u(1,nr+1),ldu )
                    call stdlib_${ri}$laset( 'A',m-nr,n1-nr, zero, one,u(nr+1,nr+1),ldu )
                 end if
              end if
              call stdlib_${ri}$ormqr( 'LEFT', 'NO TR', m, n1, n, a, lda, work, u,ldu, work(n+1), &
                        lwork-n, ierr )
                 if ( rowpiv )call stdlib_${ri}$laswp( n1, u, ldu, 1, m-1, iwork(2*n+1), -1 )
              end if
              if ( transp ) then
                 ! .. swap u and v because the procedure worked on a^t
                 do p = 1, n
                    call stdlib_${ri}$swap( n, u(1,p), 1, v(1,p), 1 )
                 end do
              end if
           end if
           ! end of the full svd
           ! undo scaling, if necessary (and possible)
           if ( uscal2 <= (big/sva(1))*uscal1 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, uscal1, uscal2, nr, 1, sva, n, ierr )
              uscal1 = one
              uscal2 = one
           end if
           if ( nr < n ) then
              do p = nr+1, n
                 sva(p) = zero
              end do
           end if
           work(1) = uscal2 * scalem
           work(2) = uscal1
           if ( errest ) work(3) = sconda
           if ( lsvec .and. rsvec ) then
              work(4) = condr1
              work(5) = condr2
           end if
           if ( l2tran ) then
              work(6) = entra
              work(7) = entrat
           end if
           iwork(1) = nr
           iwork(2) = numrank
           iwork(3) = warning
           return
     end subroutine stdlib_${ri}$gejsv

#:endif
#:endfor

     module pure subroutine stdlib_cgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, ldu, &
     !! CGEJSV computes the singular value decomposition (SVD) of a complex M-by-N
     !! matrix [A], where M >= N. The SVD of [A] is written as
     !! [A] = [U] * [SIGMA] * [V]^*,
     !! where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
     !! diagonal elements, [U] is an M-by-N (or M-by-M) unitary matrix, and
     !! [V] is an N-by-N unitary matrix. The diagonal elements of [SIGMA] are
     !! the singular values of [A]. The columns of [U] and [V] are the left and
     !! the right singular vectors of [A], respectively. The matrices [U] and [V]
     !! are computed and stored in the arrays U and V, respectively. The diagonal
     !! of [SIGMA] is computed and stored in the array SVA.
               v, ldv,cwork, lwork, rwork, lrwork, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldv, lwork, lrwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: u(ldu,*), v(ldv,*), cwork(lwork)
           real(sp), intent(out) :: sva(n), rwork(lrwork)
           integer(ilp), intent(out) :: iwork(*)
           character, intent(in) :: joba, jobp, jobr, jobt, jobu, jobv
        ! ===========================================================================
           
           
           ! Local Scalars 
           complex(sp) :: ctemp
           real(sp) :: aapp, aaqq, aatmax, aatmin, big, big1, cond_ok, condr1, condr2, entra, &
                     entrat, epsln, maxprj, scalem, sconda, sfmin, small, temp1, uscal1, uscal2, xsc
           integer(ilp) :: ierr, n1, nr, numrank, p, q, warning
           logical(lk) :: almort, defr, errest, goscal, jracc, kill, lquery, lsvec, l2aber, &
                     l2kill, l2pert, l2rank, l2tran, noscal, rowpiv, rsvec, transp
           integer(ilp) :: optwrk, minwrk, minrwrk, miniwrk
           integer(ilp) :: lwcon, lwlqf, lwqp3, lwqrf, lwunmlq, lwunmqr, lwunmqrm, lwsvdj, &
                     lwsvdjv, lrwqp3, lrwcon, lrwsvdj, iwoff
           integer(ilp) :: lwrk_cgelqf, lwrk_cgeqp3, lwrk_cgeqp3n, lwrk_cgeqrf, lwrk_cgesvj, &
                     lwrk_cgesvjv, lwrk_cgesvju, lwrk_cunmlq, lwrk_cunmqr, lwrk_cunmqrm
           ! Local Arrays
           complex(sp) :: cdummy(1)
           real(sp) :: rdummy(1)
           ! Intrinsic Functions 
           ! test the input arguments
           lsvec  = stdlib_lsame( jobu, 'U' ) .or. stdlib_lsame( jobu, 'F' )
           jracc  = stdlib_lsame( jobv, 'J' )
           rsvec  = stdlib_lsame( jobv, 'V' ) .or. jracc
           rowpiv = stdlib_lsame( joba, 'F' ) .or. stdlib_lsame( joba, 'G' )
           l2rank = stdlib_lsame( joba, 'R' )
           l2aber = stdlib_lsame( joba, 'A' )
           errest = stdlib_lsame( joba, 'E' ) .or. stdlib_lsame( joba, 'G' )
           l2tran = stdlib_lsame( jobt, 'T' ) .and. ( m == n )
           l2kill = stdlib_lsame( jobr, 'R' )
           defr   = stdlib_lsame( jobr, 'N' )
           l2pert = stdlib_lsame( jobp, 'P' )
           lquery = ( lwork == -1 ) .or. ( lrwork == -1 )
           if ( .not.(rowpiv .or. l2rank .or. l2aber .or.errest .or. stdlib_lsame( joba, 'C' ) )) &
                     then
              info = - 1
           else if ( .not.( lsvec .or. stdlib_lsame( jobu, 'N' ) .or.( stdlib_lsame( jobu, 'W' ) &
                     .and. rsvec .and. l2tran ) ) ) then
              info = - 2
           else if ( .not.( rsvec .or. stdlib_lsame( jobv, 'N' ) .or.( stdlib_lsame( jobv, 'W' ) &
                     .and. lsvec .and. l2tran ) ) ) then
              info = - 3
           else if ( .not. ( l2kill .or. defr ) )    then
              info = - 4
           else if ( .not. ( stdlib_lsame(jobt,'T') .or. stdlib_lsame(jobt,'N') ) ) then
              info = - 5
           else if ( .not. ( l2pert .or. stdlib_lsame( jobp, 'N' ) ) ) then
              info = - 6
           else if ( m < 0 ) then
              info = - 7
           else if ( ( n < 0 ) .or. ( n > m ) ) then
              info = - 8
           else if ( lda < m ) then
              info = - 10
           else if ( lsvec .and. ( ldu < m ) ) then
              info = - 13
           else if ( rsvec .and. ( ldv < n ) ) then
              info = - 15
           else
              ! #:)
              info = 0
           end if
           if ( info == 0 ) then
               ! Compute The Minimal And The Optimal Workspace Lengths
               ! [[the expressions for computing the minimal and the optimal
               ! values of lcwork, lrwork are written with a lot of redundancy and
               ! can be simplified. however, this verbose form is useful for
               ! maintenance and modifications of the code.]]
              ! .. minimal workspace length for stdlib_cgeqp3 of an m x n matrix,
               ! stdlib_cgeqrf of an n x n matrix, stdlib_cgelqf of an n x n matrix,
               ! stdlib_cunmlq for computing n x n matrix, stdlib_cunmqr for computing n x n
               ! matrix, stdlib_cunmqr for computing m x n matrix, respectively.
               lwqp3 = n+1
               lwqrf = max( 1, n )
               lwlqf = max( 1, n )
               lwunmlq  = max( 1, n )
               lwunmqr  = max( 1, n )
               lwunmqrm = max( 1, m )
              ! Minimal Workspace Length For Stdlib_Cpocon Of An N X N Matrix
               lwcon = 2 * n
              ! .. minimal workspace length for stdlib_cgesvj of an n x n matrix,
               ! without and with explicit accumulation of jacobi rotations
               lwsvdj  = max( 2 * n, 1 )
               lwsvdjv = max( 2 * n, 1 )
               ! .. minimal real workspace length for stdlib_cgeqp3, stdlib_cpocon, stdlib_cgesvj
               lrwqp3  = 2 * n
               lrwcon  = n
               lrwsvdj = n
               if ( lquery ) then
                   call stdlib_cgeqp3( m, n, a, lda, iwork, cdummy, cdummy, -1,rdummy, ierr )
                             
                   lwrk_cgeqp3 = real( cdummy(1),KIND=sp)
                   call stdlib_cgeqrf( n, n, a, lda, cdummy, cdummy,-1, ierr )
                   lwrk_cgeqrf = real( cdummy(1),KIND=sp)
                   call stdlib_cgelqf( n, n, a, lda, cdummy, cdummy,-1, ierr )
                   lwrk_cgelqf = real( cdummy(1),KIND=sp)
               end if
               minwrk  = 2
               optwrk  = 2
               miniwrk = n
               if ( .not. (lsvec .or. rsvec ) ) then
                   ! Minimal And Optimal Sizes Of The Complex Workspace If
                   ! only the singular values are requested
                   if ( errest ) then
                       minwrk = max( n+lwqp3, n**2+lwcon, n+lwqrf, lwsvdj )
                   else
                       minwrk = max( n+lwqp3, n+lwqrf, lwsvdj )
                   end if
                   if ( lquery ) then
                       call stdlib_cgesvj( 'L', 'N', 'N', n, n, a, lda, sva, n, v,ldv, cdummy, -1,&
                                  rdummy, -1, ierr )
                       lwrk_cgesvj = real( cdummy(1),KIND=sp)
                       if ( errest ) then
                           optwrk = max( n+lwrk_cgeqp3, n**2+lwcon,n+lwrk_cgeqrf, lwrk_cgesvj )
                                     
                       else
                           optwrk = max( n+lwrk_cgeqp3, n+lwrk_cgeqrf,lwrk_cgesvj )
                       end if
                   end if
                   if ( l2tran .or. rowpiv ) then
                       if ( errest ) then
                          minrwrk = max( 7, 2*m,  lrwqp3, lrwcon, lrwsvdj )
                       else
                          minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj )
                       end if
                   else
                       if ( errest ) then
                          minrwrk = max( 7, lrwqp3, lrwcon, lrwsvdj )
                       else
                          minrwrk = max( 7, lrwqp3, lrwsvdj )
                       end if
                   end if
                   if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
               else if ( rsvec .and. (.not.lsvec) ) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! singular values and the right singular vectors are requested
                  if ( errest ) then
                      minwrk = max( n+lwqp3, lwcon, lwsvdj, n+lwlqf,2*n+lwqrf, n+lwsvdj, n+&
                                lwunmlq )
                  else
                      minwrk = max( n+lwqp3, lwsvdj, n+lwlqf, 2*n+lwqrf,n+lwsvdj, n+lwunmlq )
                                
                  end if
                  if ( lquery ) then
                      call stdlib_cgesvj( 'L', 'U', 'N', n,n, u, ldu, sva, n, a,lda, cdummy, -1, &
                                rdummy, -1, ierr )
                      lwrk_cgesvj = real( cdummy(1),KIND=sp)
                      call stdlib_cunmlq( 'L', 'C', n, n, n, a, lda, cdummy,v, ldv, cdummy, -1, &
                                ierr )
                      lwrk_cunmlq = real( cdummy(1),KIND=sp)
                      if ( errest ) then
                      optwrk = max( n+lwrk_cgeqp3, lwcon, lwrk_cgesvj,n+lwrk_cgelqf, 2*n+&
                                lwrk_cgeqrf,n+lwrk_cgesvj,  n+lwrk_cunmlq )
                      else
                      optwrk = max( n+lwrk_cgeqp3, lwrk_cgesvj,n+lwrk_cgelqf,2*n+lwrk_cgeqrf, n+&
                                lwrk_cgesvj,n+lwrk_cunmlq )
                      end if
                  end if
                  if ( l2tran .or. rowpiv ) then
                       if ( errest ) then
                          minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj, lrwcon )
                       else
                          minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj )
                       end if
                  else
                       if ( errest ) then
                          minrwrk = max( 7, lrwqp3, lrwsvdj, lrwcon )
                       else
                          minrwrk = max( 7, lrwqp3, lrwsvdj )
                       end if
                  end if
                  if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
               else if ( lsvec .and. (.not.rsvec) ) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! singular values and the left singular vectors are requested
                  if ( errest ) then
                      minwrk = n + max( lwqp3,lwcon,n+lwqrf,lwsvdj,lwunmqrm )
                  else
                      minwrk = n + max( lwqp3, n+lwqrf, lwsvdj, lwunmqrm )
                  end if
                  if ( lquery ) then
                      call stdlib_cgesvj( 'L', 'U', 'N', n,n, u, ldu, sva, n, a,lda, cdummy, -1, &
                                rdummy, -1, ierr )
                      lwrk_cgesvj = real( cdummy(1),KIND=sp)
                      call stdlib_cunmqr( 'L', 'N', m, n, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_cunmqrm = real( cdummy(1),KIND=sp)
                      if ( errest ) then
                      optwrk = n + max( lwrk_cgeqp3, lwcon, n+lwrk_cgeqrf,lwrk_cgesvj, &
                                lwrk_cunmqrm )
                      else
                      optwrk = n + max( lwrk_cgeqp3, n+lwrk_cgeqrf,lwrk_cgesvj, lwrk_cunmqrm )
                                
                      end if
                  end if
                  if ( l2tran .or. rowpiv ) then
                      if ( errest ) then
                         minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj, lrwcon )
                      else
                         minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj )
                      end if
                  else
                      if ( errest ) then
                         minrwrk = max( 7, lrwqp3, lrwsvdj, lrwcon )
                      else
                         minrwrk = max( 7, lrwqp3, lrwsvdj )
                      end if
                  end if
                  if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
               else
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! full svd is requested
                  if ( .not. jracc ) then
                      if ( errest ) then
                         minwrk = max( n+lwqp3, n+lwcon,  2*n+n**2+lwcon,2*n+lwqrf,         2*n+&
                         lwqp3,2*n+n**2+n+lwlqf,  2*n+n**2+n+n**2+lwcon,2*n+n**2+n+lwsvdj, 2*n+&
                         n**2+n+lwsvdjv,2*n+n**2+n+lwunmqr,2*n+n**2+n+lwunmlq,n+n**2+lwsvdj,   n+&
                                   lwunmqrm )
                      else
                         minwrk = max( n+lwqp3,        2*n+n**2+lwcon,2*n+lwqrf,         2*n+&
                         lwqp3,2*n+n**2+n+lwlqf,  2*n+n**2+n+n**2+lwcon,2*n+n**2+n+lwsvdj, 2*n+&
                         n**2+n+lwsvdjv,2*n+n**2+n+lwunmqr,2*n+n**2+n+lwunmlq,n+n**2+lwsvdj,      &
                                   n+lwunmqrm )
                      end if
                      miniwrk = miniwrk + n
                      if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
                  else
                      if ( errest ) then
                         minwrk = max( n+lwqp3, n+lwcon, 2*n+lwqrf,2*n+n**2+lwsvdjv, 2*n+n**2+n+&
                                   lwunmqr,n+lwunmqrm )
                      else
                         minwrk = max( n+lwqp3, 2*n+lwqrf,2*n+n**2+lwsvdjv, 2*n+n**2+n+lwunmqr,n+&
                                   lwunmqrm )
                      end if
                      if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
                  end if
                  if ( lquery ) then
                      call stdlib_cunmqr( 'L', 'N', m, n, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_cunmqrm = real( cdummy(1),KIND=sp)
                      call stdlib_cunmqr( 'L', 'N', n, n, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_cunmqr = real( cdummy(1),KIND=sp)
                      if ( .not. jracc ) then
                          call stdlib_cgeqp3( n,n, a, lda, iwork, cdummy,cdummy, -1,rdummy, ierr )
                                    
                          lwrk_cgeqp3n = real( cdummy(1),KIND=sp)
                          call stdlib_cgesvj( 'L', 'U', 'N', n, n, u, ldu, sva,n, v, ldv, cdummy, &
                                    -1, rdummy, -1, ierr )
                          lwrk_cgesvj = real( cdummy(1),KIND=sp)
                          call stdlib_cgesvj( 'U', 'U', 'N', n, n, u, ldu, sva,n, v, ldv, cdummy, &
                                    -1, rdummy, -1, ierr )
                          lwrk_cgesvju = real( cdummy(1),KIND=sp)
                          call stdlib_cgesvj( 'L', 'U', 'V', n, n, u, ldu, sva,n, v, ldv, cdummy, &
                                    -1, rdummy, -1, ierr )
                          lwrk_cgesvjv = real( cdummy(1),KIND=sp)
                          call stdlib_cunmlq( 'L', 'C', n, n, n, a, lda, cdummy,v, ldv, cdummy, -&
                                    1, ierr )
                          lwrk_cunmlq = real( cdummy(1),KIND=sp)
                          if ( errest ) then
                            optwrk = max( n+lwrk_cgeqp3, n+lwcon,2*n+n**2+lwcon, 2*n+lwrk_cgeqrf,&
                            2*n+lwrk_cgeqp3n,2*n+n**2+n+lwrk_cgelqf,2*n+n**2+n+n**2+lwcon,2*n+&
                            n**2+n+lwrk_cgesvj,2*n+n**2+n+lwrk_cgesvjv,2*n+n**2+n+lwrk_cunmqr,2*n+&
                                      n**2+n+lwrk_cunmlq,n+n**2+lwrk_cgesvju,n+lwrk_cunmqrm )
                          else
                            optwrk = max( n+lwrk_cgeqp3,2*n+n**2+lwcon, 2*n+lwrk_cgeqrf,2*n+&
                            lwrk_cgeqp3n,2*n+n**2+n+lwrk_cgelqf,2*n+n**2+n+n**2+lwcon,2*n+n**2+n+&
                            lwrk_cgesvj,2*n+n**2+n+lwrk_cgesvjv,2*n+n**2+n+lwrk_cunmqr,2*n+n**2+n+&
                                      lwrk_cunmlq,n+n**2+lwrk_cgesvju,n+lwrk_cunmqrm )
                          end if
                      else
                          call stdlib_cgesvj( 'L', 'U', 'V', n, n, u, ldu, sva,n, v, ldv, cdummy, &
                                    -1, rdummy, -1, ierr )
                          lwrk_cgesvjv = real( cdummy(1),KIND=sp)
                          call stdlib_cunmqr( 'L', 'N', n, n, n, cdummy, n, cdummy,v, ldv, cdummy,&
                                     -1, ierr )
                          lwrk_cunmqr = real( cdummy(1),KIND=sp)
                          call stdlib_cunmqr( 'L', 'N', m, n, n, a, lda, cdummy, u,ldu, cdummy, -&
                                    1, ierr )
                          lwrk_cunmqrm = real( cdummy(1),KIND=sp)
                          if ( errest ) then
                             optwrk = max( n+lwrk_cgeqp3, n+lwcon,2*n+lwrk_cgeqrf, 2*n+n**2,2*n+&
                                       n**2+lwrk_cgesvjv,2*n+n**2+n+lwrk_cunmqr,n+lwrk_cunmqrm )
                          else
                             optwrk = max( n+lwrk_cgeqp3, 2*n+lwrk_cgeqrf,2*n+n**2, 2*n+n**2+&
                                       lwrk_cgesvjv,2*n+n**2+n+lwrk_cunmqr,n+lwrk_cunmqrm )
                          end if
                      end if
                  end if
                  if ( l2tran .or. rowpiv ) then
                      minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj, lrwcon )
                  else
                      minrwrk = max( 7, lrwqp3, lrwsvdj, lrwcon )
                  end if
               end if
               minwrk = max( 2, minwrk )
               optwrk = max( optwrk, minwrk )
               if ( lwork  < minwrk  .and. (.not.lquery) ) info = - 17
               if ( lrwork < minrwrk .and. (.not.lquery) ) info = - 19
           end if
           if ( info /= 0 ) then
             ! #:(
              call stdlib_xerbla( 'CGEJSV', - info )
              return
           else if ( lquery ) then
               cwork(1) = optwrk
               cwork(2) = minwrk
               rwork(1) = minrwrk
               iwork(1) = max( 4, miniwrk )
               return
           end if
           ! quick return for void matrix (y3k safe)
       ! #:)
           if ( ( m == 0 ) .or. ( n == 0 ) ) then
              iwork(1:4) = 0
              rwork(1:7) = 0
              return
           endif
           ! determine whether the matrix u should be m x n or m x m
           if ( lsvec ) then
              n1 = n
              if ( stdlib_lsame( jobu, 'F' ) ) n1 = m
           end if
           ! set numerical parameters
      ! !    note: make sure stdlib_slamch() does not fail on the target architecture.
           epsln = stdlib_slamch('EPSILON')
           sfmin = stdlib_slamch('SAFEMINIMUM')
           small = sfmin / epsln
           big   = stdlib_slamch('O')
           ! big   = one / sfmin
           ! initialize sva(1:n) = diag( ||a e_i||_2 )_1^n
      ! (!)  if necessary, scale sva() to protect the largest norm from
           ! overflow. it is possible that this scaling pushes the smallest
           ! column norm left from the underflow threshold (extreme case).
           scalem  = one / sqrt(real(m,KIND=sp)*real(n,KIND=sp))
           noscal  = .true.
           goscal  = .true.
           do p = 1, n
              aapp = zero
              aaqq = one
              call stdlib_classq( m, a(1,p), 1, aapp, aaqq )
              if ( aapp > big ) then
                 info = - 9
                 call stdlib_xerbla( 'CGEJSV', -info )
                 return
              end if
              aaqq = sqrt(aaqq)
              if ( ( aapp < (big / aaqq) ) .and. noscal  ) then
                 sva(p)  = aapp * aaqq
              else
                 noscal  = .false.
                 sva(p)  = aapp * ( aaqq * scalem )
                 if ( goscal ) then
                    goscal = .false.
                    call stdlib_sscal( p-1, scalem, sva, 1 )
                 end if
              end if
           end do
           if ( noscal ) scalem = one
           aapp = zero
           aaqq = big
           do p = 1, n
              aapp = max( aapp, sva(p) )
              if ( sva(p) /= zero ) aaqq = min( aaqq, sva(p) )
           end do
           ! quick return for zero m x n matrix
       ! #:)
           if ( aapp == zero ) then
              if ( lsvec ) call stdlib_claset( 'G', m, n1, czero, cone, u, ldu )
              if ( rsvec ) call stdlib_claset( 'G', n, n,  czero, cone, v, ldv )
              rwork(1) = one
              rwork(2) = one
              if ( errest ) rwork(3) = one
              if ( lsvec .and. rsvec ) then
                 rwork(4) = one
                 rwork(5) = one
              end if
              if ( l2tran ) then
                 rwork(6) = zero
                 rwork(7) = zero
              end if
              iwork(1) = 0
              iwork(2) = 0
              iwork(3) = 0
              iwork(4) = -1
              return
           end if
           ! issue warning if denormalized column norms detected. override the
           ! high relative accuracy request. issue licence to kill nonzero columns
           ! (set them to zero) whose norm is less than sigma_max / big (roughly).
       ! #:(
           warning = 0
           if ( aaqq <= sfmin ) then
              l2rank = .true.
              l2kill = .true.
              warning = 1
           end if
           ! quick return for one-column matrix
       ! #:)
           if ( n == 1 ) then
              if ( lsvec ) then
                 call stdlib_clascl( 'G',0,0,sva(1),scalem, m,1,a(1,1),lda,ierr )
                 call stdlib_clacpy( 'A', m, 1, a, lda, u, ldu )
                 ! computing all m left singular vectors of the m x 1 matrix
                 if ( n1 /= n  ) then
                   call stdlib_cgeqrf( m, n, u,ldu, cwork, cwork(n+1),lwork-n,ierr )
                   call stdlib_cungqr( m,n1,1, u,ldu,cwork,cwork(n+1),lwork-n,ierr )
                   call stdlib_ccopy( m, a(1,1), 1, u(1,1), 1 )
                 end if
              end if
              if ( rsvec ) then
                  v(1,1) = cone
              end if
              if ( sva(1) < (big*scalem) ) then
                 sva(1)  = sva(1) / scalem
                 scalem  = one
              end if
              rwork(1) = one / scalem
              rwork(2) = one
              if ( sva(1) /= zero ) then
                 iwork(1) = 1
                 if ( ( sva(1) / scalem) >= sfmin ) then
                    iwork(2) = 1
                 else
                    iwork(2) = 0
                 end if
              else
                 iwork(1) = 0
                 iwork(2) = 0
              end if
              iwork(3) = 0
              iwork(4) = -1
              if ( errest ) rwork(3) = one
              if ( lsvec .and. rsvec ) then
                 rwork(4) = one
                 rwork(5) = one
              end if
              if ( l2tran ) then
                 rwork(6) = zero
                 rwork(7) = zero
              end if
              return
           end if
           transp = .false.
           aatmax = -one
           aatmin =  big
           if ( rowpiv .or. l2tran ) then
           ! compute the row norms, needed to determine row pivoting sequence
           ! (in the case of heavily row weighted a, row pivoting is strongly
           ! advised) and to collect information needed to compare the
           ! structures of a * a^* and a^* * a (in the case l2tran==.true.).
              if ( l2tran ) then
                 do p = 1, m
                    xsc   = zero
                    temp1 = one
                    call stdlib_classq( n, a(p,1), lda, xsc, temp1 )
                    ! stdlib_classq gets both the ell_2 and the ell_infinity norm
                    ! in one pass through the vector
                    rwork(m+p)  = xsc * scalem
                    rwork(p)    = xsc * (scalem*sqrt(temp1))
                    aatmax = max( aatmax, rwork(p) )
                    if (rwork(p) /= zero)aatmin = min(aatmin,rwork(p))
                 end do
              else
                 do p = 1, m
                    rwork(m+p) = scalem*abs( a(p,stdlib_icamax(n,a(p,1),lda)) )
                    aatmax = max( aatmax, rwork(m+p) )
                    aatmin = min( aatmin, rwork(m+p) )
                 end do
              end if
           end if
           ! for square matrix a try to determine whether a^*  would be better
           ! input for the preconditioned jacobi svd, with faster convergence.
           ! the decision is based on an o(n) function of the vector of column
           ! and row norms of a, based on the shannon entropy. this should give
           ! the right choice in most cases when the difference actually matters.
           ! it may fail and pick the slower converging side.
           entra  = zero
           entrat = zero
           if ( l2tran ) then
              xsc   = zero
              temp1 = one
              call stdlib_slassq( n, sva, 1, xsc, temp1 )
              temp1 = one / temp1
              entra = zero
              do p = 1, n
                 big1  = ( ( sva(p) / xsc )**2 ) * temp1
                 if ( big1 /= zero ) entra = entra + big1 * log(big1)
              end do
              entra = - entra / log(real(n,KIND=sp))
              ! now, sva().^2/trace(a^* * a) is a point in the probability simplex.
              ! it is derived from the diagonal of  a^* * a.  do the same with the
              ! diagonal of a * a^*, compute the entropy of the corresponding
              ! probability distribution. note that a * a^* and a^* * a have the
              ! same trace.
              entrat = zero
              do p = 1, m
                 big1 = ( ( rwork(p) / xsc )**2 ) * temp1
                 if ( big1 /= zero ) entrat = entrat + big1 * log(big1)
              end do
              entrat = - entrat / log(real(m,KIND=sp))
              ! analyze the entropies and decide a or a^*. smaller entropy
              ! usually means better input for the algorithm.
              transp = ( entrat < entra )
              ! if a^* is better than a, take the adjoint of a. this is allowed
              ! only for square matrices, m=n.
              if ( transp ) then
                 ! in an optimal implementation, this trivial transpose
                 ! should be replaced with faster transpose.
                 do p = 1, n - 1
                    a(p,p) = conjg(a(p,p))
                    do q = p + 1, n
                        ctemp = conjg(a(q,p))
                       a(q,p) = conjg(a(p,q))
                       a(p,q) = ctemp
                    end do
                 end do
                 a(n,n) = conjg(a(n,n))
                 do p = 1, n
                    rwork(m+p) = sva(p)
                    sva(p) = rwork(p)
                    ! previously computed row 2-norms are now column 2-norms
                    ! of the transposed matrix
                 end do
                 temp1  = aapp
                 aapp   = aatmax
                 aatmax = temp1
                 temp1  = aaqq
                 aaqq   = aatmin
                 aatmin = temp1
                 kill   = lsvec
                 lsvec  = rsvec
                 rsvec  = kill
                 if ( lsvec ) n1 = n
                 rowpiv = .true.
              end if
           end if
           ! end if l2tran
           ! scale the matrix so that its maximal singular value remains less
           ! than sqrt(big) -- the matrix is scaled so that its maximal column
           ! has euclidean norm equal to sqrt(big/n). the only reason to keep
           ! sqrt(big) instead of big is the fact that stdlib_cgejsv uses lapack and
           ! blas routines that, in some implementations, are not capable of
           ! working in the full interval [sfmin,big] and that they may provoke
           ! overflows in the intermediate results. if the singular values spread
           ! from sfmin to big, then stdlib_cgesvj will compute them. so, in that case,
           ! one should use stdlib_cgesvj instead of stdlib_cgejsv.
           big1   = sqrt( big )
           temp1  = sqrt( big / real(n,KIND=sp) )
           ! >> for future updates: allow bigger range, i.e. the largest column
           ! will be allowed up to big/n and stdlib_cgesvj will do the rest. however, for
           ! this all other (lapack) components must allow such a range.
           ! temp1  = big/real(n,KIND=sp)
           ! temp1  = big * epsln  this should 'almost' work with current lapack components
           call stdlib_slascl( 'G', 0, 0, aapp, temp1, n, 1, sva, n, ierr )
           if ( aaqq > (aapp * sfmin) ) then
               aaqq = ( aaqq / aapp ) * temp1
           else
               aaqq = ( aaqq * temp1 ) / aapp
           end if
           temp1 = temp1 * scalem
           call stdlib_clascl( 'G', 0, 0, aapp, temp1, m, n, a, lda, ierr )
           ! to undo scaling at the end of this procedure, multiply the
           ! computed singular values with uscal2 / uscal1.
           uscal1 = temp1
           uscal2 = aapp
           if ( l2kill ) then
              ! l2kill enforces computation of nonzero singular values in
              ! the restricted range of condition number of the initial a,
              ! sigma_max(a) / sigma_min(a) approx. sqrt(big)/sqrt(sfmin).
              xsc = sqrt( sfmin )
           else
              xsc = small
              ! now, if the condition number of a is too big,
              ! sigma_max(a) / sigma_min(a) > sqrt(big/n) * epsln / sfmin,
              ! as a precaution measure, the full svd is computed using stdlib_cgesvj
              ! with accumulated jacobi rotations. this provides numerically
              ! more robust computation, at the cost of slightly increased run
              ! time. depending on the concrete implementation of blas and lapack
              ! (i.e. how they behave in presence of extreme ill-conditioning) the
              ! implementor may decide to remove this switch.
              if ( ( aaqq<sqrt(sfmin) ) .and. lsvec .and. rsvec ) then
                 jracc = .true.
              end if
           end if
           if ( aaqq < xsc ) then
              do p = 1, n
                 if ( sva(p) < xsc ) then
                    call stdlib_claset( 'A', m, 1, czero, czero, a(1,p), lda )
                    sva(p) = zero
                 end if
              end do
           end if
           ! preconditioning using qr factorization with pivoting
           if ( rowpiv ) then
              ! optional row permutation (bjoerck row pivoting):
              ! a result by cox and higham shows that the bjoerck's
              ! row pivoting combined with standard column pivoting
              ! has similar effect as powell-reid complete pivoting.
              ! the ell-infinity norms of a are made nonincreasing.
              if ( ( lsvec .and. rsvec ) .and. .not.( jracc ) ) then
                   iwoff = 2*n
              else
                   iwoff = n
              end if
              do p = 1, m - 1
                 q = stdlib_isamax( m-p+1, rwork(m+p), 1 ) + p - 1
                 iwork(iwoff+p) = q
                 if ( p /= q ) then
                    temp1      = rwork(m+p)
                    rwork(m+p) = rwork(m+q)
                    rwork(m+q) = temp1
                 end if
              end do
              call stdlib_claswp( n, a, lda, 1, m-1, iwork(iwoff+1), 1 )
           end if
           ! end of the preparation phase (scaling, optional sorting and
           ! transposing, optional flushing of small columns).
           ! preconditioning
           ! if the full svd is needed, the right singular vectors are computed
           ! from a matrix equation, and for that we need theoretical analysis
           ! of the businger-golub pivoting. so we use stdlib_cgeqp3 as the first rr qrf.
           ! in all other cases the first rr qrf can be chosen by other criteria
           ! (eg speed by replacing global with restricted window pivoting, such
           ! as in xgeqpx from toms # 782). good results will be obtained using
           ! xgeqpx with properly (!) chosen numerical parameters.
           ! any improvement of stdlib_cgeqp3 improves overall performance of stdlib_cgejsv.
           ! a * p1 = q1 * [ r1^* 0]^*:
           do p = 1, n
              ! All Columns Are Free Columns
              iwork(p) = 0
           end do
           call stdlib_cgeqp3( m, n, a, lda, iwork, cwork, cwork(n+1), lwork-n,rwork, ierr )
                     
           ! the upper triangular matrix r1 from the first qrf is inspected for
           ! rank deficiency and possibilities for deflation, or possible
           ! ill-conditioning. depending on the user specified flag l2rank,
           ! the procedure explores possibilities to reduce the numerical
           ! rank by inspecting the computed upper triangular factor. if
           ! l2rank or l2aber are up, then stdlib_cgejsv will compute the svd of
           ! a + da, where ||da|| <= f(m,n)*epsln.
           nr = 1
           if ( l2aber ) then
              ! standard absolute error bound suffices. all sigma_i with
              ! sigma_i < n*epsln*||a|| are flushed to zero. this is an
              ! aggressive enforcement of lower numerical rank by introducing a
              ! backward error of the order of n*epsln*||a||.
              temp1 = sqrt(real(n,KIND=sp))*epsln
              do p = 2, n
                 if ( abs(a(p,p)) >= (temp1*abs(a(1,1))) ) then
                    nr = nr + 1
                 else
                    go to 3002
                 end if
              end do
              3002 continue
           else if ( l2rank ) then
              ! .. similarly as above, only slightly more gentle (less aggressive).
              ! sudden drop on the diagonal of r1 is used as the criterion for
              ! close-to-rank-deficient.
              temp1 = sqrt(sfmin)
              do p = 2, n
                 if ( ( abs(a(p,p)) < (epsln*abs(a(p-1,p-1))) ) .or.( abs(a(p,p)) < small ) .or.( &
                           l2kill .and. (abs(a(p,p)) < temp1) ) ) go to 3402
                 nr = nr + 1
              end do
              3402 continue
           else
              ! the goal is high relative accuracy. however, if the matrix
              ! has high scaled condition number the relative accuracy is in
              ! general not feasible. later on, a condition number estimator
              ! will be deployed to estimate the scaled condition number.
              ! here we just remove the underflowed part of the triangular
              ! factor. this prevents the situation in which the code is
              ! working hard to get the accuracy not warranted by the data.
              temp1  = sqrt(sfmin)
              do p = 2, n
                 if ( ( abs(a(p,p)) < small ) .or.( l2kill .and. (abs(a(p,p)) < temp1) ) ) go to &
                           3302
                 nr = nr + 1
              end do
              3302 continue
           end if
           almort = .false.
           if ( nr == n ) then
              maxprj = one
              do p = 2, n
                 temp1  = abs(a(p,p)) / sva(iwork(p))
                 maxprj = min( maxprj, temp1 )
              end do
              if ( maxprj**2 >= one - real(n,KIND=sp)*epsln ) almort = .true.
           end if
           sconda = - one
           condr1 = - one
           condr2 = - one
           if ( errest ) then
              if ( n == nr ) then
                 if ( rsvec ) then
                    ! V Is Available As Workspace
                    call stdlib_clacpy( 'U', n, n, a, lda, v, ldv )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_csscal( p, one/temp1, v(1,p), 1 )
                    end do
                    if ( lsvec )then
                        call stdlib_cpocon( 'U', n, v, ldv, one, temp1,cwork(n+1), rwork, ierr )
                                  
                    else
                        call stdlib_cpocon( 'U', n, v, ldv, one, temp1,cwork, rwork, ierr )
                                  
                    end if
                 else if ( lsvec ) then
                    ! U Is Available As Workspace
                    call stdlib_clacpy( 'U', n, n, a, lda, u, ldu )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_csscal( p, one/temp1, u(1,p), 1 )
                    end do
                    call stdlib_cpocon( 'U', n, u, ldu, one, temp1,cwork(n+1), rwork, ierr )
                              
                 else
                    call stdlib_clacpy( 'U', n, n, a, lda, cwork, n )
      ! []            call stdlib_clacpy( 'u', n, n, a, lda, cwork(n+1), n )
                    ! change: here index shifted by n to the left, cwork(1:n)
                    ! not needed for sigma only computation
                    do p = 1, n
                       temp1 = sva(iwork(p))
      ! []               call stdlib_csscal( p, one/temp1, cwork(n+(p-1)*n+1), 1 )
                       call stdlib_csscal( p, one/temp1, cwork((p-1)*n+1), 1 )
                    end do
                 ! The Columns Of R Are Scaled To Have Unit Euclidean Lengths
      ! []               call stdlib_cpocon( 'u', n, cwork(n+1), n, one, temp1,
      ! []     $              cwork(n+n*n+1), rwork, ierr )
                    call stdlib_cpocon( 'U', n, cwork, n, one, temp1,cwork(n*n+1), rwork, ierr )
                              
                 end if
                 if ( temp1 /= zero ) then
                    sconda = one / sqrt(temp1)
                 else
                    sconda = - one
                 end if
                 ! sconda is an estimate of sqrt(||(r^* * r)^(-1)||_1).
                 ! n^(-1/4) * sconda <= ||r^(-1)||_2 <= n^(1/4) * sconda
              else
                 sconda = - one
              end if
           end if
           l2pert = l2pert .and. ( abs( a(1,1)/a(nr,nr) ) > sqrt(big1) )
           ! if there is no violent scaling, artificial perturbation is not needed.
           ! phase 3:
           if ( .not. ( rsvec .or. lsvec ) ) then
               ! singular values only
               ! .. transpose a(1:nr,1:n)
              do p = 1, min( n-1, nr )
                 call stdlib_ccopy( n-p, a(p,p+1), lda, a(p+1,p), 1 )
                 call stdlib_clacgv( n-p+1, a(p,p), 1 )
              end do
              if ( nr == n ) a(n,n) = conjg(a(n,n))
              ! the following two do-loops introduce small relative perturbation
              ! into the strict upper triangle of the lower triangular matrix.
              ! small entries below the main diagonal are also changed.
              ! this modification is useful if the computing environment does not
              ! provide/allow flush to zero underflow, for it prevents many
              ! annoying denormalized numbers in case of strongly scaled matrices.
              ! the perturbation is structured so that it does not introduce any
              ! new perturbation of the singular values, and it does not destroy
              ! the job done by the preconditioner.
              ! the licence for this perturbation is in the variable l2pert, which
              ! should be .false. if flush to zero underflow is active.
              if ( .not. almort ) then
                 if ( l2pert ) then
                    ! xsc = sqrt(small)
                    xsc = epsln / real(n,KIND=sp)
                    do q = 1, nr
                       ctemp = cmplx(xsc*abs(a(q,q)),zero,KIND=sp)
                       do p = 1, n
                          if ( ( (p>q) .and. (abs(a(p,q))<=temp1) ).or. ( p < q ) )a(p,q) = &
                                    ctemp
           ! $                     a(p,q) = temp1 * ( a(p,q) / abs(a(p,q)) )
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_claset( 'U', nr-1,nr-1, czero,czero, a(1,2),lda )
                 end if
                  ! Second Preconditioning Using The Qr Factorization
                 call stdlib_cgeqrf( n,nr, a,lda, cwork, cwork(n+1),lwork-n, ierr )
                 ! And Transpose Upper To Lower Triangular
                 do p = 1, nr - 1
                    call stdlib_ccopy( nr-p, a(p,p+1), lda, a(p+1,p), 1 )
                    call stdlib_clacgv( nr-p+1, a(p,p), 1 )
                 end do
              end if
                 ! row-cyclic jacobi svd algorithm with column pivoting
                 ! .. again some perturbation (a "background noise") is added
                 ! to drown denormals
                 if ( l2pert ) then
                    ! xsc = sqrt(small)
                    xsc = epsln / real(n,KIND=sp)
                    do q = 1, nr
                       ctemp = cmplx(xsc*abs(a(q,q)),zero,KIND=sp)
                       do p = 1, nr
                          if ( ( (p>q) .and. (abs(a(p,q))<=temp1) ).or. ( p < q ) )a(p,q) = &
                                    ctemp
           ! $                   a(p,q) = temp1 * ( a(p,q) / abs(a(p,q)) )
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_claset( 'U', nr-1, nr-1, czero, czero, a(1,2), lda )
                 end if
                 ! .. and one-sided jacobi rotations are started on a lower
                 ! triangular matrix (plus perturbation which is ignored in
                 ! the part which destroys triangular form (confusing?!))
                 call stdlib_cgesvj( 'L', 'N', 'N', nr, nr, a, lda, sva,n, v, ldv, cwork, lwork, &
                           rwork, lrwork, info )
                 scalem  = rwork(1)
                 numrank = nint(rwork(2),KIND=ilp)
           else if ( ( rsvec .and. ( .not. lsvec ) .and. ( .not. jracc ) ).or.( jracc .and. ( &
                     .not. lsvec ) .and. ( nr /= n ) ) ) then
              ! -> singular values and right singular vectors <-
              if ( almort ) then
                 ! In This Case Nr Equals N
                 do p = 1, nr
                    call stdlib_ccopy( n-p+1, a(p,p), lda, v(p,p), 1 )
                    call stdlib_clacgv( n-p+1, v(p,p), 1 )
                 end do
                 if (nr>1) call stdlib_claset( 'U', nr-1,nr-1, czero, czero, v(1,2), ldv )
                 call stdlib_cgesvj( 'L','U','N', n, nr, v, ldv, sva, nr, a, lda,cwork, lwork, &
                           rwork, lrwork, info )
                 scalem  = rwork(1)
                 numrank = nint(rwork(2),KIND=ilp)
              else
              ! .. two more qr factorizations ( one qrf is not enough, two require
              ! accumulated product of jacobi rotations, three are perfect )
                 if (nr>1) call stdlib_claset( 'L', nr-1,nr-1, czero, czero, a(2,1), lda )
                 call stdlib_cgelqf( nr,n, a, lda, cwork, cwork(n+1), lwork-n, ierr)
                 call stdlib_clacpy( 'L', nr, nr, a, lda, v, ldv )
                 if (nr>1) call stdlib_claset( 'U', nr-1,nr-1, czero, czero, v(1,2), ldv )
                 call stdlib_cgeqrf( nr, nr, v, ldv, cwork(n+1), cwork(2*n+1),lwork-2*n, ierr )
                           
                 do p = 1, nr
                    call stdlib_ccopy( nr-p+1, v(p,p), ldv, v(p,p), 1 )
                    call stdlib_clacgv( nr-p+1, v(p,p), 1 )
                 end do
                 if (nr>1) call stdlib_claset('U', nr-1, nr-1, czero, czero, v(1,2), ldv)
                 call stdlib_cgesvj( 'L', 'U','N', nr, nr, v,ldv, sva, nr, u,ldu, cwork(n+1), &
                           lwork-n, rwork, lrwork, info )
                 scalem  = rwork(1)
                 numrank = nint(rwork(2),KIND=ilp)
                 if ( nr < n ) then
                    call stdlib_claset( 'A',n-nr, nr, czero,czero, v(nr+1,1),  ldv )
                    call stdlib_claset( 'A',nr, n-nr, czero,czero, v(1,nr+1),  ldv )
                    call stdlib_claset( 'A',n-nr,n-nr,czero,cone, v(nr+1,nr+1),ldv )
                 end if
              call stdlib_cunmlq( 'L', 'C', n, n, nr, a, lda, cwork,v, ldv, cwork(n+1), lwork-n, &
                        ierr )
              end if
               ! Permute The Rows Of V
               ! do 8991 p = 1, n
                  ! call stdlib_ccopy( n, v(p,1), ldv, a(iwork(p),1), lda )
                  8991 continue
               ! call stdlib_clacpy( 'all', n, n, a, lda, v, ldv )
              call stdlib_clapmr( .false., n, n, v, ldv, iwork )
               if ( transp ) then
                 call stdlib_clacpy( 'A', n, n, v, ldv, u, ldu )
               end if
           else if ( jracc .and. (.not. lsvec) .and. ( nr== n ) ) then
              if (n>1) call stdlib_claset( 'L', n-1,n-1, czero, czero, a(2,1), lda )
              call stdlib_cgesvj( 'U','N','V', n, n, a, lda, sva, n, v, ldv,cwork, lwork, rwork, &
                        lrwork, info )
               scalem  = rwork(1)
               numrank = nint(rwork(2),KIND=ilp)
               call stdlib_clapmr( .false., n, n, v, ldv, iwork )
           else if ( lsvec .and. ( .not. rsvec ) ) then
              ! Singular Values And Left Singular Vectors                 
              ! Second Preconditioning Step To Avoid Need To Accumulate
              ! jacobi rotations in the jacobi iterations.
              do p = 1, nr
                 call stdlib_ccopy( n-p+1, a(p,p), lda, u(p,p), 1 )
                 call stdlib_clacgv( n-p+1, u(p,p), 1 )
              end do
              if (nr>1) call stdlib_claset( 'U', nr-1, nr-1, czero, czero, u(1,2), ldu )
              call stdlib_cgeqrf( n, nr, u, ldu, cwork(n+1), cwork(2*n+1),lwork-2*n, ierr )
                        
              do p = 1, nr - 1
                 call stdlib_ccopy( nr-p, u(p,p+1), ldu, u(p+1,p), 1 )
                 call stdlib_clacgv( n-p+1, u(p,p), 1 )
              end do
              if (nr>1) call stdlib_claset( 'U', nr-1, nr-1, czero, czero, u(1,2), ldu )
              call stdlib_cgesvj( 'L', 'U', 'N', nr,nr, u, ldu, sva, nr, a,lda, cwork(n+1), lwork-&
                        n, rwork, lrwork, info )
              scalem  = rwork(1)
              numrank = nint(rwork(2),KIND=ilp)
              if ( nr < m ) then
                 call stdlib_claset( 'A',  m-nr, nr,czero, czero, u(nr+1,1), ldu )
                 if ( nr < n1 ) then
                    call stdlib_claset( 'A',nr, n1-nr, czero, czero, u(1,nr+1),ldu )
                    call stdlib_claset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1),ldu )
                 end if
              end if
              call stdlib_cunmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, cwork(n+1), lwork-n, &
                        ierr )
              if ( rowpiv )call stdlib_claswp( n1, u, ldu, 1, m-1, iwork(iwoff+1), -1 )
              do p = 1, n1
                 xsc = one / stdlib_scnrm2( m, u(1,p), 1 )
                 call stdlib_csscal( m, xsc, u(1,p), 1 )
              end do
              if ( transp ) then
                 call stdlib_clacpy( 'A', n, n, u, ldu, v, ldv )
              end if
           else
              ! Full Svd 
              if ( .not. jracc ) then
              if ( .not. almort ) then
                 ! second preconditioning step (qrf [with pivoting])
                 ! note that the composition of transpose, qrf and transpose is
                 ! equivalent to an lqf call. since in many libraries the qrf
                 ! seems to be better optimized than the lqf, we do explicit
                 ! transpose and use the qrf. this is subject to changes in an
                 ! optimized implementation of stdlib_cgejsv.
                 do p = 1, nr
                    call stdlib_ccopy( n-p+1, a(p,p), lda, v(p,p), 1 )
                    call stdlib_clacgv( n-p+1, v(p,p), 1 )
                 end do
                 ! The Following Two Loops Perturb Small Entries To Avoid
                 ! denormals in the second qr factorization, where they are
                 ! as good as zeros. this is done to avoid painfully slow
                 ! computation with denormals. the relative size of the perturbation
                 ! is a parameter that can be changed by the implementer.
                 ! this perturbation device will be obsolete on machines with
                 ! properly implemented arithmetic.
                 ! to switch it off, set l2pert=.false. to remove it from  the
                 ! code, remove the action under l2pert=.true., leave the else part.
                 ! the following two loops should be blocked and fused with the
                 ! transposed copy above.
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do q = 1, nr
                       ctemp = cmplx(xsc*abs( v(q,q) ),zero,KIND=sp)
                       do p = 1, n
                          if ( ( p > q ) .and. ( abs(v(p,q)) <= temp1 ).or. ( p < q ) )v(p,q) = &
                                    ctemp
           ! $                   v(p,q) = temp1 * ( v(p,q) / abs(v(p,q)) )
                          if ( p < q ) v(p,q) = - v(p,q)
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_claset( 'U', nr-1, nr-1, czero, czero, v(1,2), ldv )
                 end if
                 ! estimate the row scaled condition number of r1
                 ! (if r1 is rectangular, n > nr, then the condition number
                 ! of the leading nr x nr submatrix is estimated.)
                 call stdlib_clacpy( 'L', nr, nr, v, ldv, cwork(2*n+1), nr )
                 do p = 1, nr
                    temp1 = stdlib_scnrm2(nr-p+1,cwork(2*n+(p-1)*nr+p),1)
                    call stdlib_csscal(nr-p+1,one/temp1,cwork(2*n+(p-1)*nr+p),1)
                 end do
                 call stdlib_cpocon('L',nr,cwork(2*n+1),nr,one,temp1,cwork(2*n+nr*nr+1),rwork,&
                           ierr)
                 condr1 = one / sqrt(temp1)
                 ! Here Need A Second Opinion On The Condition Number
                 ! Then Assume Worst Case Scenario
                 ! r1 is ok for inverse <=> condr1 < real(n,KIND=sp)
                 ! more conservative    <=> condr1 < sqrt(real(n,KIND=sp))
                 cond_ok = sqrt(sqrt(real(nr,KIND=sp)))
      ! [tp]       cond_ok is a tuning parameter.
                 if ( condr1 < cond_ok ) then
                    ! .. the second qrf without pivoting. note: in an optimized
                    ! implementation, this qrf should be implemented as the qrf
                    ! of a lower triangular matrix.
                    ! r1^* = q2 * r2
                    call stdlib_cgeqrf( n, nr, v, ldv, cwork(n+1), cwork(2*n+1),lwork-2*n, ierr )
                              
                    if ( l2pert ) then
                       xsc = sqrt(small)/epsln
                       do p = 2, nr
                          do q = 1, p - 1
                             ctemp=cmplx(xsc*min(abs(v(p,p)),abs(v(q,q))),zero,KIND=sp)
                             if ( abs(v(q,p)) <= temp1 )v(q,p) = ctemp
           ! $                     v(q,p) = temp1 * ( v(q,p) / abs(v(q,p)) )
                          end do
                       end do
                    end if
                    if ( nr /= n )call stdlib_clacpy( 'A', n, nr, v, ldv, cwork(2*n+1), n )
                              
                    ! .. save ...
                 ! This Transposed Copy Should Be Better Than Naive
                    do p = 1, nr - 1
                       call stdlib_ccopy( nr-p, v(p,p+1), ldv, v(p+1,p), 1 )
                       call stdlib_clacgv(nr-p+1, v(p,p), 1 )
                    end do
                    v(nr,nr)=conjg(v(nr,nr))
                    condr2 = condr1
                 else
                    ! .. ill-conditioned case: second qrf with pivoting
                    ! note that windowed pivoting would be equally good
                    ! numerically, and more run-time efficient. so, in
                    ! an optimal implementation, the next call to stdlib_cgeqp3
                    ! should be replaced with eg. call cgeqpx (acm toms #782)
                    ! with properly (carefully) chosen parameters.
                    ! r1^* * p2 = q2 * r2
                    do p = 1, nr
                       iwork(n+p) = 0
                    end do
                    call stdlib_cgeqp3( n, nr, v, ldv, iwork(n+1), cwork(n+1),cwork(2*n+1), lwork-&
                              2*n, rwork, ierr )
      ! *               call stdlib_cgeqrf( n, nr, v, ldv, cwork(n+1), cwork(2*n+1),
      ! *     $              lwork-2*n, ierr )
                    if ( l2pert ) then
                       xsc = sqrt(small)
                       do p = 2, nr
                          do q = 1, p - 1
                             ctemp=cmplx(xsc*min(abs(v(p,p)),abs(v(q,q))),zero,KIND=sp)
                             if ( abs(v(q,p)) <= temp1 )v(q,p) = ctemp
           ! $                     v(q,p) = temp1 * ( v(q,p) / abs(v(q,p)) )
                          end do
                       end do
                    end if
                    call stdlib_clacpy( 'A', n, nr, v, ldv, cwork(2*n+1), n )
                    if ( l2pert ) then
                       xsc = sqrt(small)
                       do p = 2, nr
                          do q = 1, p - 1
                             ctemp=cmplx(xsc*min(abs(v(p,p)),abs(v(q,q))),zero,KIND=sp)
                              ! v(p,q) = - temp1*( v(q,p) / abs(v(q,p)) )
                             v(p,q) = - ctemp
                          end do
                       end do
                    else
                       if (nr>1) call stdlib_claset( 'L',nr-1,nr-1,czero,czero,v(2,1),ldv )
                    end if
                    ! now, compute r2 = l3 * q3, the lq factorization.
                    call stdlib_cgelqf( nr, nr, v, ldv, cwork(2*n+n*nr+1),cwork(2*n+n*nr+nr+1), &
                              lwork-2*n-n*nr-nr, ierr )
                    ! And Estimate The Condition Number
                    call stdlib_clacpy( 'L',nr,nr,v,ldv,cwork(2*n+n*nr+nr+1),nr )
                    do p = 1, nr
                       temp1 = stdlib_scnrm2( p, cwork(2*n+n*nr+nr+p), nr )
                       call stdlib_csscal( p, one/temp1, cwork(2*n+n*nr+nr+p), nr )
                    end do
                    call stdlib_cpocon( 'L',nr,cwork(2*n+n*nr+nr+1),nr,one,temp1,cwork(2*n+n*nr+&
                              nr+nr*nr+1),rwork,ierr )
                    condr2 = one / sqrt(temp1)
                    if ( condr2 >= cond_ok ) then
                       ! Save The Householder Vectors Used For Q3
                       ! (this overwrites the copy of r2, as it will not be
                       ! needed in this branch, but it does not overwritte the
                       ! huseholder vectors of q2.).
                       call stdlib_clacpy( 'U', nr, nr, v, ldv, cwork(2*n+1), n )
                       ! And The Rest Of The Information On Q3 Is In
                       ! work(2*n+n*nr+1:2*n+n*nr+n)
                    end if
                 end if
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do q = 2, nr
                       ctemp = xsc * v(q,q)
                       do p = 1, q - 1
                           ! v(p,q) = - temp1*( v(p,q) / abs(v(p,q)) )
                          v(p,q) = - ctemp
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_claset( 'U', nr-1,nr-1, czero,czero, v(1,2), ldv )
                 end if
              ! second preconditioning finished; continue with jacobi svd
              ! the input matrix is lower trinagular.
              ! recover the right singular vectors as solution of a well
              ! conditioned triangular matrix equation.
                 if ( condr1 < cond_ok ) then
                    call stdlib_cgesvj( 'L','U','N',nr,nr,v,ldv,sva,nr,u, ldu,cwork(2*n+n*nr+nr+1)&
                              ,lwork-2*n-n*nr-nr,rwork,lrwork, info )
                    scalem  = rwork(1)
                    numrank = nint(rwork(2),KIND=ilp)
                    do p = 1, nr
                       call stdlib_ccopy(  nr, v(1,p), 1, u(1,p), 1 )
                       call stdlib_csscal( nr, sva(p),    v(1,p), 1 )
                    end do
              ! Pick The Right Matrix Equation And Solve It
                    if ( nr == n ) then
       ! :))             .. best case, r1 is inverted. the solution of this matrix
                       ! equation is q2*v2 = the product of the jacobi rotations
                       ! used in stdlib_cgesvj, premultiplied with the orthogonal matrix
                       ! from the second qr factorization.
                       call stdlib_ctrsm('L','U','N','N', nr,nr,cone, a,lda, v,ldv)
                    else
                       ! .. r1 is well conditioned, but non-square. adjoint of r2
                       ! is inverted to get the product of the jacobi rotations
                       ! used in stdlib_cgesvj. the q-factor from the second qr
                       ! factorization is then built in explicitly.
                       call stdlib_ctrsm('L','U','C','N',nr,nr,cone,cwork(2*n+1),n,v,ldv)
                       if ( nr < n ) then
                       call stdlib_claset('A',n-nr,nr,czero,czero,v(nr+1,1),ldv)
                       call stdlib_claset('A',nr,n-nr,czero,czero,v(1,nr+1),ldv)
                       call stdlib_claset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                       end if
                       call stdlib_cunmqr('L','N',n,n,nr,cwork(2*n+1),n,cwork(n+1),v,ldv,cwork(&
                                 2*n+n*nr+nr+1),lwork-2*n-n*nr-nr,ierr)
                    end if
                 else if ( condr2 < cond_ok ) then
                    ! the matrix r2 is inverted. the solution of the matrix equation
                    ! is q3^* * v3 = the product of the jacobi rotations (appplied to
                    ! the lower triangular l3 from the lq factorization of
                    ! r2=l3*q3), pre-multiplied with the transposed q3.
                    call stdlib_cgesvj( 'L', 'U', 'N', nr, nr, v, ldv, sva, nr, u,ldu, cwork(2*n+&
                              n*nr+nr+1), lwork-2*n-n*nr-nr,rwork, lrwork, info )
                    scalem  = rwork(1)
                    numrank = nint(rwork(2),KIND=ilp)
                    do p = 1, nr
                       call stdlib_ccopy( nr, v(1,p), 1, u(1,p), 1 )
                       call stdlib_csscal( nr, sva(p),    u(1,p), 1 )
                    end do
                    call stdlib_ctrsm('L','U','N','N',nr,nr,cone,cwork(2*n+1),n,u,ldu)
                    ! Apply The Permutation From The Second Qr Factorization
                    do q = 1, nr
                       do p = 1, nr
                          cwork(2*n+n*nr+nr+iwork(n+p)) = u(p,q)
                       end do
                       do p = 1, nr
                          u(p,q) = cwork(2*n+n*nr+nr+p)
                       end do
                    end do
                    if ( nr < n ) then
                       call stdlib_claset( 'A',n-nr,nr,czero,czero,v(nr+1,1),ldv )
                       call stdlib_claset( 'A',nr,n-nr,czero,czero,v(1,nr+1),ldv )
                       call stdlib_claset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                    end if
                    call stdlib_cunmqr( 'L','N',n,n,nr,cwork(2*n+1),n,cwork(n+1),v,ldv,cwork(2*n+&
                              n*nr+nr+1),lwork-2*n-n*nr-nr,ierr )
                 else
                    ! last line of defense.
       ! #:(          this is a rather pathological case: no scaled condition
                    ! improvement after two pivoted qr factorizations. other
                    ! possibility is that the rank revealing qr factorization
                    ! or the condition estimator has failed, or the cond_ok
                    ! is set very close to one (which is unnecessary). normally,
                    ! this branch should never be executed, but in rare cases of
                    ! failure of the rrqr or condition estimator, the last line of
                    ! defense ensures that stdlib_cgejsv completes the task.
                    ! compute the full svd of l3 using stdlib_cgesvj with explicit
                    ! accumulation of jacobi rotations.
                    call stdlib_cgesvj( 'L', 'U', 'V', nr, nr, v, ldv, sva, nr, u,ldu, cwork(2*n+&
                              n*nr+nr+1), lwork-2*n-n*nr-nr,rwork, lrwork, info )
                    scalem  = rwork(1)
                    numrank = nint(rwork(2),KIND=ilp)
                    if ( nr < n ) then
                       call stdlib_claset( 'A',n-nr,nr,czero,czero,v(nr+1,1),ldv )
                       call stdlib_claset( 'A',nr,n-nr,czero,czero,v(1,nr+1),ldv )
                       call stdlib_claset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                    end if
                    call stdlib_cunmqr( 'L','N',n,n,nr,cwork(2*n+1),n,cwork(n+1),v,ldv,cwork(2*n+&
                              n*nr+nr+1),lwork-2*n-n*nr-nr,ierr )
                    call stdlib_cunmlq( 'L', 'C', nr, nr, nr, cwork(2*n+1), n,cwork(2*n+n*nr+1), &
                              u, ldu, cwork(2*n+n*nr+nr+1),lwork-2*n-n*nr-nr, ierr )
                    do q = 1, nr
                       do p = 1, nr
                          cwork(2*n+n*nr+nr+iwork(n+p)) = u(p,q)
                       end do
                       do p = 1, nr
                          u(p,q) = cwork(2*n+n*nr+nr+p)
                       end do
                    end do
                 end if
                 ! permute the rows of v using the (column) permutation from the
                 ! first qrf. also, scale the columns to make them unit in
                 ! euclidean norm. this applies to all cases.
                 temp1 = sqrt(real(n,KIND=sp)) * epsln
                 do q = 1, n
                    do p = 1, n
                       cwork(2*n+n*nr+nr+iwork(p)) = v(p,q)
                    end do
                    do p = 1, n
                       v(p,q) = cwork(2*n+n*nr+nr+p)
                    end do
                    xsc = one / stdlib_scnrm2( n, v(1,q), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_csscal( n, xsc,&
                               v(1,q), 1 )
                 end do
                 ! at this moment, v contains the right singular vectors of a.
                 ! next, assemble the left singular vector matrix u (m x n).
                 if ( nr < m ) then
                    call stdlib_claset('A', m-nr, nr, czero, czero, u(nr+1,1), ldu)
                    if ( nr < n1 ) then
                       call stdlib_claset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                       call stdlib_claset('A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1),ldu)
                    end if
                 end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! matrix u. this applies to all cases.
                 call stdlib_cunmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, cwork(n+1), lwork-&
                           n, ierr )
                 ! the columns of u are normalized. the cost is o(m*n) flops.
                 temp1 = sqrt(real(m,KIND=sp)) * epsln
                 do p = 1, nr
                    xsc = one / stdlib_scnrm2( m, u(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_csscal( m, xsc,&
                               u(1,p), 1 )
                 end do
                 ! if the initial qrf is computed with row pivoting, the left
                 ! singular vectors must be adjusted.
                 if ( rowpiv )call stdlib_claswp( n1, u, ldu, 1, m-1, iwork(iwoff+1), -1 )
              else
              ! The Initial Matrix A Has Almost Orthogonal Columns And
              ! the second qrf is not needed
                 call stdlib_clacpy( 'U', n, n, a, lda, cwork(n+1), n )
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do p = 2, n
                       ctemp = xsc * cwork( n + (p-1)*n + p )
                       do q = 1, p - 1
                           ! cwork(n+(q-1)*n+p)=-temp1 * ( cwork(n+(p-1)*n+q) /
           ! $                                        abs(cwork(n+(p-1)*n+q)) )
                          cwork(n+(q-1)*n+p)=-ctemp
                       end do
                    end do
                 else
                    call stdlib_claset( 'L',n-1,n-1,czero,czero,cwork(n+2),n )
                 end if
                 call stdlib_cgesvj( 'U', 'U', 'N', n, n, cwork(n+1), n, sva,n, u, ldu, cwork(n+&
                           n*n+1), lwork-n-n*n, rwork, lrwork,info )
                 scalem  = rwork(1)
                 numrank = nint(rwork(2),KIND=ilp)
                 do p = 1, n
                    call stdlib_ccopy( n, cwork(n+(p-1)*n+1), 1, u(1,p), 1 )
                    call stdlib_csscal( n, sva(p), cwork(n+(p-1)*n+1), 1 )
                 end do
                 call stdlib_ctrsm( 'L', 'U', 'N', 'N', n, n,cone, a, lda, cwork(n+1), n )
                 do p = 1, n
                    call stdlib_ccopy( n, cwork(n+p), n, v(iwork(p),1), ldv )
                 end do
                 temp1 = sqrt(real(n,KIND=sp))*epsln
                 do p = 1, n
                    xsc = one / stdlib_scnrm2( n, v(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_csscal( n, xsc,&
                               v(1,p), 1 )
                 end do
                 ! assemble the left singular vector matrix u (m x n).
                 if ( n < m ) then
                    call stdlib_claset( 'A',  m-n, n, czero, czero, u(n+1,1), ldu )
                    if ( n < n1 ) then
                       call stdlib_claset('A',n,  n1-n, czero, czero,  u(1,n+1),ldu)
                       call stdlib_claset( 'A',m-n,n1-n, czero, cone,u(n+1,n+1),ldu)
                    end if
                 end if
                 call stdlib_cunmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, cwork(n+1), lwork-&
                           n, ierr )
                 temp1 = sqrt(real(m,KIND=sp))*epsln
                 do p = 1, n1
                    xsc = one / stdlib_scnrm2( m, u(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_csscal( m, xsc,&
                               u(1,p), 1 )
                 end do
                 if ( rowpiv )call stdlib_claswp( n1, u, ldu, 1, m-1, iwork(iwoff+1), -1 )
              end if
              ! end of the  >> almost orthogonal case <<  in the full svd
              else
              ! this branch deploys a preconditioned jacobi svd with explicitly
              ! accumulated rotations. it is included as optional, mainly for
              ! experimental purposes. it does perform well, and can also be used.
              ! in this implementation, this branch will be automatically activated
              ! if the  condition number sigma_max(a) / sigma_min(a) is predicted
              ! to be greater than the overflow threshold. this is because the
              ! a posteriori computation of the singular vectors assumes robust
              ! implementation of blas and some lapack procedures, capable of working
              ! in presence of extreme values, e.g. when the singular values spread from
              ! the underflow to the overflow threshold.
              do p = 1, nr
                 call stdlib_ccopy( n-p+1, a(p,p), lda, v(p,p), 1 )
                 call stdlib_clacgv( n-p+1, v(p,p), 1 )
              end do
              if ( l2pert ) then
                 xsc = sqrt(small/epsln)
                 do q = 1, nr
                    ctemp = cmplx(xsc*abs( v(q,q) ),zero,KIND=sp)
                    do p = 1, n
                       if ( ( p > q ) .and. ( abs(v(p,q)) <= temp1 ).or. ( p < q ) )v(p,q) = &
                                 ctemp
           ! $                v(p,q) = temp1 * ( v(p,q) / abs(v(p,q)) )
                       if ( p < q ) v(p,q) = - v(p,q)
                    end do
                 end do
              else
                 if (nr>1) call stdlib_claset( 'U', nr-1, nr-1, czero, czero, v(1,2), ldv )
              end if
              call stdlib_cgeqrf( n, nr, v, ldv, cwork(n+1), cwork(2*n+1),lwork-2*n, ierr )
                        
              call stdlib_clacpy( 'L', n, nr, v, ldv, cwork(2*n+1), n )
              do p = 1, nr
                 call stdlib_ccopy( nr-p+1, v(p,p), ldv, u(p,p), 1 )
                 call stdlib_clacgv( nr-p+1, u(p,p), 1 )
              end do
              if ( l2pert ) then
                 xsc = sqrt(small/epsln)
                 do q = 2, nr
                    do p = 1, q - 1
                       ctemp = cmplx(xsc * min(abs(u(p,p)),abs(u(q,q))),zero,KIND=sp)
                        ! u(p,q) = - temp1 * ( u(q,p) / abs(u(q,p)) )
                       u(p,q) = - ctemp
                    end do
                 end do
              else
                 if (nr>1) call stdlib_claset('U', nr-1, nr-1, czero, czero, u(1,2), ldu )
              end if
              call stdlib_cgesvj( 'L', 'U', 'V', nr, nr, u, ldu, sva,n, v, ldv, cwork(2*n+n*nr+1),&
                         lwork-2*n-n*nr,rwork, lrwork, info )
              scalem  = rwork(1)
              numrank = nint(rwork(2),KIND=ilp)
              if ( nr < n ) then
                 call stdlib_claset( 'A',n-nr,nr,czero,czero,v(nr+1,1),ldv )
                 call stdlib_claset( 'A',nr,n-nr,czero,czero,v(1,nr+1),ldv )
                 call stdlib_claset( 'A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv )
              end if
              call stdlib_cunmqr( 'L','N',n,n,nr,cwork(2*n+1),n,cwork(n+1),v,ldv,cwork(2*n+n*nr+&
                        nr+1),lwork-2*n-n*nr-nr,ierr )
                 ! permute the rows of v using the (column) permutation from the
                 ! first qrf. also, scale the columns to make them unit in
                 ! euclidean norm. this applies to all cases.
                 temp1 = sqrt(real(n,KIND=sp)) * epsln
                 do q = 1, n
                    do p = 1, n
                       cwork(2*n+n*nr+nr+iwork(p)) = v(p,q)
                    end do
                    do p = 1, n
                       v(p,q) = cwork(2*n+n*nr+nr+p)
                    end do
                    xsc = one / stdlib_scnrm2( n, v(1,q), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_csscal( n, xsc,&
                               v(1,q), 1 )
                 end do
                 ! at this moment, v contains the right singular vectors of a.
                 ! next, assemble the left singular vector matrix u (m x n).
              if ( nr < m ) then
                 call stdlib_claset( 'A',  m-nr, nr, czero, czero, u(nr+1,1), ldu )
                 if ( nr < n1 ) then
                    call stdlib_claset('A',nr,  n1-nr, czero, czero,  u(1,nr+1),ldu)
                    call stdlib_claset('A',m-nr,n1-nr, czero, cone,u(nr+1,nr+1),ldu)
                 end if
              end if
              call stdlib_cunmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, cwork(n+1), lwork-n, &
                        ierr )
                 if ( rowpiv )call stdlib_claswp( n1, u, ldu, 1, m-1, iwork(iwoff+1), -1 )
              end if
              if ( transp ) then
                 ! .. swap u and v because the procedure worked on a^*
                 do p = 1, n
                    call stdlib_cswap( n, u(1,p), 1, v(1,p), 1 )
                 end do
              end if
           end if
           ! end of the full svd
           ! undo scaling, if necessary (and possible)
           if ( uscal2 <= (big/sva(1))*uscal1 ) then
              call stdlib_slascl( 'G', 0, 0, uscal1, uscal2, nr, 1, sva, n, ierr )
              uscal1 = one
              uscal2 = one
           end if
           if ( nr < n ) then
              do p = nr+1, n
                 sva(p) = zero
              end do
           end if
           rwork(1) = uscal2 * scalem
           rwork(2) = uscal1
           if ( errest ) rwork(3) = sconda
           if ( lsvec .and. rsvec ) then
              rwork(4) = condr1
              rwork(5) = condr2
           end if
           if ( l2tran ) then
              rwork(6) = entra
              rwork(7) = entrat
           end if
           iwork(1) = nr
           iwork(2) = numrank
           iwork(3) = warning
           if ( transp ) then
               iwork(4) =  1
           else
               iwork(4) = -1
           end if
           return
     end subroutine stdlib_cgejsv

     module pure subroutine stdlib_zgejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, ldu, &
     !! ZGEJSV computes the singular value decomposition (SVD) of a complex M-by-N
     !! matrix [A], where M >= N. The SVD of [A] is written as
     !! [A] = [U] * [SIGMA] * [V]^*,
     !! where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
     !! diagonal elements, [U] is an M-by-N (or M-by-M) unitary matrix, and
     !! [V] is an N-by-N unitary matrix. The diagonal elements of [SIGMA] are
     !! the singular values of [A]. The columns of [U] and [V] are the left and
     !! the right singular vectors of [A], respectively. The matrices [U] and [V]
     !! are computed and stored in the arrays U and V, respectively. The diagonal
     !! of [SIGMA] is computed and stored in the array SVA.
               v, ldv,cwork, lwork, rwork, lrwork, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldv, lwork, lrwork, m, n
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: u(ldu,*), v(ldv,*), cwork(lwork)
           real(dp), intent(out) :: sva(n), rwork(lrwork)
           integer(ilp), intent(out) :: iwork(*)
           character, intent(in) :: joba, jobp, jobr, jobt, jobu, jobv
        ! ===========================================================================
           
           
           ! Local Scalars 
           complex(dp) :: ctemp
           real(dp) :: aapp, aaqq, aatmax, aatmin, big, big1, cond_ok, condr1, condr2, entra, &
                     entrat, epsln, maxprj, scalem, sconda, sfmin, small, temp1, uscal1, uscal2, xsc
           integer(ilp) :: ierr, n1, nr, numrank, p, q, warning
           logical(lk) :: almort, defr, errest, goscal, jracc, kill, lquery, lsvec, l2aber, &
                     l2kill, l2pert, l2rank, l2tran, noscal, rowpiv, rsvec, transp
           integer(ilp) :: optwrk, minwrk, minrwrk, miniwrk
           integer(ilp) :: lwcon, lwlqf, lwqp3, lwqrf, lwunmlq, lwunmqr, lwunmqrm, lwsvdj, &
                     lwsvdjv, lrwqp3, lrwcon, lrwsvdj, iwoff
           integer(ilp) :: lwrk_zgelqf, lwrk_zgeqp3, lwrk_zgeqp3n, lwrk_zgeqrf, lwrk_zgesvj, &
                     lwrk_zgesvjv, lwrk_zgesvju, lwrk_zunmlq, lwrk_zunmqr, lwrk_zunmqrm
           ! Local Arrays
           complex(dp) :: cdummy(1)
           real(dp) :: rdummy(1)
           ! Intrinsic Functions 
           ! test the input arguments
           lsvec  = stdlib_lsame( jobu, 'U' ) .or. stdlib_lsame( jobu, 'F' )
           jracc  = stdlib_lsame( jobv, 'J' )
           rsvec  = stdlib_lsame( jobv, 'V' ) .or. jracc
           rowpiv = stdlib_lsame( joba, 'F' ) .or. stdlib_lsame( joba, 'G' )
           l2rank = stdlib_lsame( joba, 'R' )
           l2aber = stdlib_lsame( joba, 'A' )
           errest = stdlib_lsame( joba, 'E' ) .or. stdlib_lsame( joba, 'G' )
           l2tran = stdlib_lsame( jobt, 'T' ) .and. ( m == n )
           l2kill = stdlib_lsame( jobr, 'R' )
           defr   = stdlib_lsame( jobr, 'N' )
           l2pert = stdlib_lsame( jobp, 'P' )
           lquery = ( lwork == -1 ) .or. ( lrwork == -1 )
           if ( .not.(rowpiv .or. l2rank .or. l2aber .or.errest .or. stdlib_lsame( joba, 'C' ) )) &
                     then
              info = - 1
           else if ( .not.( lsvec .or. stdlib_lsame( jobu, 'N' ) .or.( stdlib_lsame( jobu, 'W' ) &
                     .and. rsvec .and. l2tran ) ) ) then
              info = - 2
           else if ( .not.( rsvec .or. stdlib_lsame( jobv, 'N' ) .or.( stdlib_lsame( jobv, 'W' ) &
                     .and. lsvec .and. l2tran ) ) ) then
              info = - 3
           else if ( .not. ( l2kill .or. defr ) )    then
              info = - 4
           else if ( .not. ( stdlib_lsame(jobt,'T') .or. stdlib_lsame(jobt,'N') ) ) then
              info = - 5
           else if ( .not. ( l2pert .or. stdlib_lsame( jobp, 'N' ) ) ) then
              info = - 6
           else if ( m < 0 ) then
              info = - 7
           else if ( ( n < 0 ) .or. ( n > m ) ) then
              info = - 8
           else if ( lda < m ) then
              info = - 10
           else if ( lsvec .and. ( ldu < m ) ) then
              info = - 13
           else if ( rsvec .and. ( ldv < n ) ) then
              info = - 15
           else
              ! #:)
              info = 0
           end if
           if ( info == 0 ) then
               ! Compute The Minimal And The Optimal Workspace Lengths
               ! [[the expressions for computing the minimal and the optimal
               ! values of lcwork, lrwork are written with a lot of redundancy and
               ! can be simplified. however, this verbose form is useful for
               ! maintenance and modifications of the code.]]
              ! .. minimal workspace length for stdlib_zgeqp3 of an m x n matrix,
               ! stdlib_zgeqrf of an n x n matrix, stdlib_zgelqf of an n x n matrix,
               ! stdlib_zunmlq for computing n x n matrix, stdlib_zunmqr for computing n x n
               ! matrix, stdlib_zunmqr for computing m x n matrix, respectively.
               lwqp3 = n+1
               lwqrf = max( 1, n )
               lwlqf = max( 1, n )
               lwunmlq  = max( 1, n )
               lwunmqr  = max( 1, n )
               lwunmqrm = max( 1, m )
              ! Minimal Workspace Length For Stdlib_Zpocon Of An N X N Matrix
               lwcon = 2 * n
              ! .. minimal workspace length for stdlib_zgesvj of an n x n matrix,
               ! without and with explicit accumulation of jacobi rotations
               lwsvdj  = max( 2 * n, 1 )
               lwsvdjv = max( 2 * n, 1 )
               ! .. minimal real workspace length for stdlib_zgeqp3, stdlib_zpocon, stdlib_zgesvj
               lrwqp3  = 2 * n
               lrwcon  = n
               lrwsvdj = n
               if ( lquery ) then
                   call stdlib_zgeqp3( m, n, a, lda, iwork, cdummy, cdummy, -1,rdummy, ierr )
                             
                   lwrk_zgeqp3 = real( cdummy(1),KIND=dp)
                   call stdlib_zgeqrf( n, n, a, lda, cdummy, cdummy,-1, ierr )
                   lwrk_zgeqrf = real( cdummy(1),KIND=dp)
                   call stdlib_zgelqf( n, n, a, lda, cdummy, cdummy,-1, ierr )
                   lwrk_zgelqf = real( cdummy(1),KIND=dp)
               end if
               minwrk  = 2
               optwrk  = 2
               miniwrk = n
               if ( .not. (lsvec .or. rsvec ) ) then
                   ! Minimal And Optimal Sizes Of The Complex Workspace If
                   ! only the singular values are requested
                   if ( errest ) then
                       minwrk = max( n+lwqp3, n**2+lwcon, n+lwqrf, lwsvdj )
                   else
                       minwrk = max( n+lwqp3, n+lwqrf, lwsvdj )
                   end if
                   if ( lquery ) then
                       call stdlib_zgesvj( 'L', 'N', 'N', n, n, a, lda, sva, n, v,ldv, cdummy, -1,&
                                  rdummy, -1, ierr )
                       lwrk_zgesvj = real( cdummy(1),KIND=dp)
                       if ( errest ) then
                           optwrk = max( n+lwrk_zgeqp3, n**2+lwcon,n+lwrk_zgeqrf, lwrk_zgesvj )
                                     
                       else
                           optwrk = max( n+lwrk_zgeqp3, n+lwrk_zgeqrf,lwrk_zgesvj )
                       end if
                   end if
                   if ( l2tran .or. rowpiv ) then
                       if ( errest ) then
                          minrwrk = max( 7, 2*m,  lrwqp3, lrwcon, lrwsvdj )
                       else
                          minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj )
                       end if
                   else
                       if ( errest ) then
                          minrwrk = max( 7, lrwqp3, lrwcon, lrwsvdj )
                       else
                          minrwrk = max( 7, lrwqp3, lrwsvdj )
                       end if
                   end if
                   if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
               else if ( rsvec .and. (.not.lsvec) ) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! singular values and the right singular vectors are requested
                  if ( errest ) then
                      minwrk = max( n+lwqp3, lwcon, lwsvdj, n+lwlqf,2*n+lwqrf, n+lwsvdj, n+&
                                lwunmlq )
                  else
                      minwrk = max( n+lwqp3, lwsvdj, n+lwlqf, 2*n+lwqrf,n+lwsvdj, n+lwunmlq )
                                
                  end if
                  if ( lquery ) then
                      call stdlib_zgesvj( 'L', 'U', 'N', n,n, u, ldu, sva, n, a,lda, cdummy, -1, &
                                rdummy, -1, ierr )
                      lwrk_zgesvj = real( cdummy(1),KIND=dp)
                      call stdlib_zunmlq( 'L', 'C', n, n, n, a, lda, cdummy,v, ldv, cdummy, -1, &
                                ierr )
                      lwrk_zunmlq = real( cdummy(1),KIND=dp)
                      if ( errest ) then
                      optwrk = max( n+lwrk_zgeqp3, lwcon, lwrk_zgesvj,n+lwrk_zgelqf, 2*n+&
                                lwrk_zgeqrf,n+lwrk_zgesvj,  n+lwrk_zunmlq )
                      else
                      optwrk = max( n+lwrk_zgeqp3, lwrk_zgesvj,n+lwrk_zgelqf,2*n+lwrk_zgeqrf, n+&
                                lwrk_zgesvj,n+lwrk_zunmlq )
                      end if
                  end if
                  if ( l2tran .or. rowpiv ) then
                       if ( errest ) then
                          minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj, lrwcon )
                       else
                          minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj )
                       end if
                  else
                       if ( errest ) then
                          minrwrk = max( 7, lrwqp3, lrwsvdj, lrwcon )
                       else
                          minrwrk = max( 7, lrwqp3, lrwsvdj )
                       end if
                  end if
                  if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
               else if ( lsvec .and. (.not.rsvec) ) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! singular values and the left singular vectors are requested
                  if ( errest ) then
                      minwrk = n + max( lwqp3,lwcon,n+lwqrf,lwsvdj,lwunmqrm )
                  else
                      minwrk = n + max( lwqp3, n+lwqrf, lwsvdj, lwunmqrm )
                  end if
                  if ( lquery ) then
                      call stdlib_zgesvj( 'L', 'U', 'N', n,n, u, ldu, sva, n, a,lda, cdummy, -1, &
                                rdummy, -1, ierr )
                      lwrk_zgesvj = real( cdummy(1),KIND=dp)
                      call stdlib_zunmqr( 'L', 'N', m, n, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_zunmqrm = real( cdummy(1),KIND=dp)
                      if ( errest ) then
                      optwrk = n + max( lwrk_zgeqp3, lwcon, n+lwrk_zgeqrf,lwrk_zgesvj, &
                                lwrk_zunmqrm )
                      else
                      optwrk = n + max( lwrk_zgeqp3, n+lwrk_zgeqrf,lwrk_zgesvj, lwrk_zunmqrm )
                                
                      end if
                  end if
                  if ( l2tran .or. rowpiv ) then
                      if ( errest ) then
                         minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj, lrwcon )
                      else
                         minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj )
                      end if
                  else
                      if ( errest ) then
                         minrwrk = max( 7, lrwqp3, lrwsvdj, lrwcon )
                      else
                         minrwrk = max( 7, lrwqp3, lrwsvdj )
                      end if
                  end if
                  if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
               else
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! full svd is requested
                  if ( .not. jracc ) then
                      if ( errest ) then
                         minwrk = max( n+lwqp3, n+lwcon,  2*n+n**2+lwcon,2*n+lwqrf,         2*n+&
                         lwqp3,2*n+n**2+n+lwlqf,  2*n+n**2+n+n**2+lwcon,2*n+n**2+n+lwsvdj, 2*n+&
                         n**2+n+lwsvdjv,2*n+n**2+n+lwunmqr,2*n+n**2+n+lwunmlq,n+n**2+lwsvdj,   n+&
                                   lwunmqrm )
                      else
                         minwrk = max( n+lwqp3,        2*n+n**2+lwcon,2*n+lwqrf,         2*n+&
                         lwqp3,2*n+n**2+n+lwlqf,  2*n+n**2+n+n**2+lwcon,2*n+n**2+n+lwsvdj, 2*n+&
                         n**2+n+lwsvdjv,2*n+n**2+n+lwunmqr,2*n+n**2+n+lwunmlq,n+n**2+lwsvdj,      &
                                   n+lwunmqrm )
                      end if
                      miniwrk = miniwrk + n
                      if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
                  else
                      if ( errest ) then
                         minwrk = max( n+lwqp3, n+lwcon, 2*n+lwqrf,2*n+n**2+lwsvdjv, 2*n+n**2+n+&
                                   lwunmqr,n+lwunmqrm )
                      else
                         minwrk = max( n+lwqp3, 2*n+lwqrf,2*n+n**2+lwsvdjv, 2*n+n**2+n+lwunmqr,n+&
                                   lwunmqrm )
                      end if
                      if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
                  end if
                  if ( lquery ) then
                      call stdlib_zunmqr( 'L', 'N', m, n, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_zunmqrm = real( cdummy(1),KIND=dp)
                      call stdlib_zunmqr( 'L', 'N', n, n, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_zunmqr = real( cdummy(1),KIND=dp)
                      if ( .not. jracc ) then
                          call stdlib_zgeqp3( n,n, a, lda, iwork, cdummy,cdummy, -1,rdummy, ierr )
                                    
                          lwrk_zgeqp3n = real( cdummy(1),KIND=dp)
                          call stdlib_zgesvj( 'L', 'U', 'N', n, n, u, ldu, sva,n, v, ldv, cdummy, &
                                    -1, rdummy, -1, ierr )
                          lwrk_zgesvj = real( cdummy(1),KIND=dp)
                          call stdlib_zgesvj( 'U', 'U', 'N', n, n, u, ldu, sva,n, v, ldv, cdummy, &
                                    -1, rdummy, -1, ierr )
                          lwrk_zgesvju = real( cdummy(1),KIND=dp)
                          call stdlib_zgesvj( 'L', 'U', 'V', n, n, u, ldu, sva,n, v, ldv, cdummy, &
                                    -1, rdummy, -1, ierr )
                          lwrk_zgesvjv = real( cdummy(1),KIND=dp)
                          call stdlib_zunmlq( 'L', 'C', n, n, n, a, lda, cdummy,v, ldv, cdummy, -&
                                    1, ierr )
                          lwrk_zunmlq = real( cdummy(1),KIND=dp)
                          if ( errest ) then
                            optwrk = max( n+lwrk_zgeqp3, n+lwcon,2*n+n**2+lwcon, 2*n+lwrk_zgeqrf,&
                            2*n+lwrk_zgeqp3n,2*n+n**2+n+lwrk_zgelqf,2*n+n**2+n+n**2+lwcon,2*n+&
                            n**2+n+lwrk_zgesvj,2*n+n**2+n+lwrk_zgesvjv,2*n+n**2+n+lwrk_zunmqr,2*n+&
                                      n**2+n+lwrk_zunmlq,n+n**2+lwrk_zgesvju,n+lwrk_zunmqrm )
                          else
                            optwrk = max( n+lwrk_zgeqp3,2*n+n**2+lwcon, 2*n+lwrk_zgeqrf,2*n+&
                            lwrk_zgeqp3n,2*n+n**2+n+lwrk_zgelqf,2*n+n**2+n+n**2+lwcon,2*n+n**2+n+&
                            lwrk_zgesvj,2*n+n**2+n+lwrk_zgesvjv,2*n+n**2+n+lwrk_zunmqr,2*n+n**2+n+&
                                      lwrk_zunmlq,n+n**2+lwrk_zgesvju,n+lwrk_zunmqrm )
                          end if
                      else
                          call stdlib_zgesvj( 'L', 'U', 'V', n, n, u, ldu, sva,n, v, ldv, cdummy, &
                                    -1, rdummy, -1, ierr )
                          lwrk_zgesvjv = real( cdummy(1),KIND=dp)
                          call stdlib_zunmqr( 'L', 'N', n, n, n, cdummy, n, cdummy,v, ldv, cdummy,&
                                     -1, ierr )
                          lwrk_zunmqr = real( cdummy(1),KIND=dp)
                          call stdlib_zunmqr( 'L', 'N', m, n, n, a, lda, cdummy, u,ldu, cdummy, -&
                                    1, ierr )
                          lwrk_zunmqrm = real( cdummy(1),KIND=dp)
                          if ( errest ) then
                             optwrk = max( n+lwrk_zgeqp3, n+lwcon,2*n+lwrk_zgeqrf, 2*n+n**2,2*n+&
                                       n**2+lwrk_zgesvjv,2*n+n**2+n+lwrk_zunmqr,n+lwrk_zunmqrm )
                          else
                             optwrk = max( n+lwrk_zgeqp3, 2*n+lwrk_zgeqrf,2*n+n**2, 2*n+n**2+&
                                       lwrk_zgesvjv,2*n+n**2+n+lwrk_zunmqr,n+lwrk_zunmqrm )
                          end if
                      end if
                  end if
                  if ( l2tran .or. rowpiv ) then
                      minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj, lrwcon )
                  else
                      minrwrk = max( 7, lrwqp3, lrwsvdj, lrwcon )
                  end if
               end if
               minwrk = max( 2, minwrk )
               optwrk = max( minwrk, optwrk )
               if ( lwork  < minwrk  .and. (.not.lquery) ) info = - 17
               if ( lrwork < minrwrk .and. (.not.lquery) ) info = - 19
           end if
           if ( info /= 0 ) then
             ! #:(
              call stdlib_xerbla( 'ZGEJSV', - info )
              return
           else if ( lquery ) then
               cwork(1) = optwrk
               cwork(2) = minwrk
               rwork(1) = minrwrk
               iwork(1) = max( 4, miniwrk )
               return
           end if
           ! quick return for void matrix (y3k safe)
       ! #:)
           if ( ( m == 0 ) .or. ( n == 0 ) ) then
              iwork(1:4) = 0
              rwork(1:7) = 0
              return
           endif
           ! determine whether the matrix u should be m x n or m x m
           if ( lsvec ) then
              n1 = n
              if ( stdlib_lsame( jobu, 'F' ) ) n1 = m
           end if
           ! set numerical parameters
      ! !    note: make sure stdlib_dlamch() does not fail on the target architecture.
           epsln = stdlib_dlamch('EPSILON')
           sfmin = stdlib_dlamch('SAFEMINIMUM')
           small = sfmin / epsln
           big   = stdlib_dlamch('O')
           ! big   = one / sfmin
           ! initialize sva(1:n) = diag( ||a e_i||_2 )_1^n
      ! (!)  if necessary, scale sva() to protect the largest norm from
           ! overflow. it is possible that this scaling pushes the smallest
           ! column norm left from the underflow threshold (extreme case).
           scalem  = one / sqrt(real(m,KIND=dp)*real(n,KIND=dp))
           noscal  = .true.
           goscal  = .true.
           do p = 1, n
              aapp = zero
              aaqq = one
              call stdlib_zlassq( m, a(1,p), 1, aapp, aaqq )
              if ( aapp > big ) then
                 info = - 9
                 call stdlib_xerbla( 'ZGEJSV', -info )
                 return
              end if
              aaqq = sqrt(aaqq)
              if ( ( aapp < (big / aaqq) ) .and. noscal  ) then
                 sva(p)  = aapp * aaqq
              else
                 noscal  = .false.
                 sva(p)  = aapp * ( aaqq * scalem )
                 if ( goscal ) then
                    goscal = .false.
                    call stdlib_dscal( p-1, scalem, sva, 1 )
                 end if
              end if
           end do
           if ( noscal ) scalem = one
           aapp = zero
           aaqq = big
           do p = 1, n
              aapp = max( aapp, sva(p) )
              if ( sva(p) /= zero ) aaqq = min( aaqq, sva(p) )
           end do
           ! quick return for zero m x n matrix
       ! #:)
           if ( aapp == zero ) then
              if ( lsvec ) call stdlib_zlaset( 'G', m, n1, czero, cone, u, ldu )
              if ( rsvec ) call stdlib_zlaset( 'G', n, n,  czero, cone, v, ldv )
              rwork(1) = one
              rwork(2) = one
              if ( errest ) rwork(3) = one
              if ( lsvec .and. rsvec ) then
                 rwork(4) = one
                 rwork(5) = one
              end if
              if ( l2tran ) then
                 rwork(6) = zero
                 rwork(7) = zero
              end if
              iwork(1) = 0
              iwork(2) = 0
              iwork(3) = 0
              iwork(4) = -1
              return
           end if
           ! issue warning if denormalized column norms detected. override the
           ! high relative accuracy request. issue licence to kill nonzero columns
           ! (set them to zero) whose norm is less than sigma_max / big (roughly).
       ! #:(
           warning = 0
           if ( aaqq <= sfmin ) then
              l2rank = .true.
              l2kill = .true.
              warning = 1
           end if
           ! quick return for one-column matrix
       ! #:)
           if ( n == 1 ) then
              if ( lsvec ) then
                 call stdlib_zlascl( 'G',0,0,sva(1),scalem, m,1,a(1,1),lda,ierr )
                 call stdlib_zlacpy( 'A', m, 1, a, lda, u, ldu )
                 ! computing all m left singular vectors of the m x 1 matrix
                 if ( n1 /= n  ) then
                   call stdlib_zgeqrf( m, n, u,ldu, cwork, cwork(n+1),lwork-n,ierr )
                   call stdlib_zungqr( m,n1,1, u,ldu,cwork,cwork(n+1),lwork-n,ierr )
                   call stdlib_zcopy( m, a(1,1), 1, u(1,1), 1 )
                 end if
              end if
              if ( rsvec ) then
                  v(1,1) = cone
              end if
              if ( sva(1) < (big*scalem) ) then
                 sva(1)  = sva(1) / scalem
                 scalem  = one
              end if
              rwork(1) = one / scalem
              rwork(2) = one
              if ( sva(1) /= zero ) then
                 iwork(1) = 1
                 if ( ( sva(1) / scalem) >= sfmin ) then
                    iwork(2) = 1
                 else
                    iwork(2) = 0
                 end if
              else
                 iwork(1) = 0
                 iwork(2) = 0
              end if
              iwork(3) = 0
              iwork(4) = -1
              if ( errest ) rwork(3) = one
              if ( lsvec .and. rsvec ) then
                 rwork(4) = one
                 rwork(5) = one
              end if
              if ( l2tran ) then
                 rwork(6) = zero
                 rwork(7) = zero
              end if
              return
           end if
           transp = .false.
           aatmax = -one
           aatmin =  big
           if ( rowpiv .or. l2tran ) then
           ! compute the row norms, needed to determine row pivoting sequence
           ! (in the case of heavily row weighted a, row pivoting is strongly
           ! advised) and to collect information needed to compare the
           ! structures of a * a^* and a^* * a (in the case l2tran==.true.).
              if ( l2tran ) then
                 do p = 1, m
                    xsc   = zero
                    temp1 = one
                    call stdlib_zlassq( n, a(p,1), lda, xsc, temp1 )
                    ! stdlib_zlassq gets both the ell_2 and the ell_infinity norm
                    ! in one pass through the vector
                    rwork(m+p)  = xsc * scalem
                    rwork(p)    = xsc * (scalem*sqrt(temp1))
                    aatmax = max( aatmax, rwork(p) )
                    if (rwork(p) /= zero)aatmin = min(aatmin,rwork(p))
                 end do
              else
                 do p = 1, m
                    rwork(m+p) = scalem*abs( a(p,stdlib_izamax(n,a(p,1),lda)) )
                    aatmax = max( aatmax, rwork(m+p) )
                    aatmin = min( aatmin, rwork(m+p) )
                 end do
              end if
           end if
           ! for square matrix a try to determine whether a^*  would be better
           ! input for the preconditioned jacobi svd, with faster convergence.
           ! the decision is based on an o(n) function of the vector of column
           ! and row norms of a, based on the shannon entropy. this should give
           ! the right choice in most cases when the difference actually matters.
           ! it may fail and pick the slower converging side.
           entra  = zero
           entrat = zero
           if ( l2tran ) then
              xsc   = zero
              temp1 = one
              call stdlib_dlassq( n, sva, 1, xsc, temp1 )
              temp1 = one / temp1
              entra = zero
              do p = 1, n
                 big1  = ( ( sva(p) / xsc )**2 ) * temp1
                 if ( big1 /= zero ) entra = entra + big1 * log(big1)
              end do
              entra = - entra / log(real(n,KIND=dp))
              ! now, sva().^2/trace(a^* * a) is a point in the probability simplex.
              ! it is derived from the diagonal of  a^* * a.  do the same with the
              ! diagonal of a * a^*, compute the entropy of the corresponding
              ! probability distribution. note that a * a^* and a^* * a have the
              ! same trace.
              entrat = zero
              do p = 1, m
                 big1 = ( ( rwork(p) / xsc )**2 ) * temp1
                 if ( big1 /= zero ) entrat = entrat + big1 * log(big1)
              end do
              entrat = - entrat / log(real(m,KIND=dp))
              ! analyze the entropies and decide a or a^*. smaller entropy
              ! usually means better input for the algorithm.
              transp = ( entrat < entra )
              ! if a^* is better than a, take the adjoint of a. this is allowed
              ! only for square matrices, m=n.
              if ( transp ) then
                 ! in an optimal implementation, this trivial transpose
                 ! should be replaced with faster transpose.
                 do p = 1, n - 1
                    a(p,p) = conjg(a(p,p))
                    do q = p + 1, n
                        ctemp = conjg(a(q,p))
                       a(q,p) = conjg(a(p,q))
                       a(p,q) = ctemp
                    end do
                 end do
                 a(n,n) = conjg(a(n,n))
                 do p = 1, n
                    rwork(m+p) = sva(p)
                    sva(p)     = rwork(p)
                    ! previously computed row 2-norms are now column 2-norms
                    ! of the transposed matrix
                 end do
                 temp1  = aapp
                 aapp   = aatmax
                 aatmax = temp1
                 temp1  = aaqq
                 aaqq   = aatmin
                 aatmin = temp1
                 kill   = lsvec
                 lsvec  = rsvec
                 rsvec  = kill
                 if ( lsvec ) n1 = n
                 rowpiv = .true.
              end if
           end if
           ! end if l2tran
           ! scale the matrix so that its maximal singular value remains less
           ! than sqrt(big) -- the matrix is scaled so that its maximal column
           ! has euclidean norm equal to sqrt(big/n). the only reason to keep
           ! sqrt(big) instead of big is the fact that stdlib_zgejsv uses lapack and
           ! blas routines that, in some implementations, are not capable of
           ! working in the full interval [sfmin,big] and that they may provoke
           ! overflows in the intermediate results. if the singular values spread
           ! from sfmin to big, then stdlib_zgesvj will compute them. so, in that case,
           ! one should use stdlib_zgesvj instead of stdlib_zgejsv.
           ! >> change in the april 2016 update: allow bigger range, i.e. the
           ! largest column is allowed up to big/n and stdlib_zgesvj will do the rest.
           big1   = sqrt( big )
           temp1  = sqrt( big / real(n,KIND=dp) )
            ! temp1  = big/real(n,KIND=dp)
           call stdlib_dlascl( 'G', 0, 0, aapp, temp1, n, 1, sva, n, ierr )
           if ( aaqq > (aapp * sfmin) ) then
               aaqq = ( aaqq / aapp ) * temp1
           else
               aaqq = ( aaqq * temp1 ) / aapp
           end if
           temp1 = temp1 * scalem
           call stdlib_zlascl( 'G', 0, 0, aapp, temp1, m, n, a, lda, ierr )
           ! to undo scaling at the end of this procedure, multiply the
           ! computed singular values with uscal2 / uscal1.
           uscal1 = temp1
           uscal2 = aapp
           if ( l2kill ) then
              ! l2kill enforces computation of nonzero singular values in
              ! the restricted range of condition number of the initial a,
              ! sigma_max(a) / sigma_min(a) approx. sqrt(big)/sqrt(sfmin).
              xsc = sqrt( sfmin )
           else
              xsc = small
              ! now, if the condition number of a is too big,
              ! sigma_max(a) / sigma_min(a) > sqrt(big/n) * epsln / sfmin,
              ! as a precaution measure, the full svd is computed using stdlib_zgesvj
              ! with accumulated jacobi rotations. this provides numerically
              ! more robust computation, at the cost of slightly increased run
              ! time. depending on the concrete implementation of blas and lapack
              ! (i.e. how they behave in presence of extreme ill-conditioning) the
              ! implementor may decide to remove this switch.
              if ( ( aaqq<sqrt(sfmin) ) .and. lsvec .and. rsvec ) then
                 jracc = .true.
              end if
           end if
           if ( aaqq < xsc ) then
              do p = 1, n
                 if ( sva(p) < xsc ) then
                    call stdlib_zlaset( 'A', m, 1, czero, czero, a(1,p), lda )
                    sva(p) = zero
                 end if
              end do
           end if
           ! preconditioning using qr factorization with pivoting
           if ( rowpiv ) then
              ! optional row permutation (bjoerck row pivoting):
              ! a result by cox and higham shows that the bjoerck's
              ! row pivoting combined with standard column pivoting
              ! has similar effect as powell-reid complete pivoting.
              ! the ell-infinity norms of a are made nonincreasing.
              if ( ( lsvec .and. rsvec ) .and. .not.( jracc ) ) then
                   iwoff = 2*n
              else
                   iwoff = n
              end if
              do p = 1, m - 1
                 q = stdlib_idamax( m-p+1, rwork(m+p), 1 ) + p - 1
                 iwork(iwoff+p) = q
                 if ( p /= q ) then
                    temp1      = rwork(m+p)
                    rwork(m+p) = rwork(m+q)
                    rwork(m+q) = temp1
                 end if
              end do
              call stdlib_zlaswp( n, a, lda, 1, m-1, iwork(iwoff+1), 1 )
           end if
           ! end of the preparation phase (scaling, optional sorting and
           ! transposing, optional flushing of small columns).
           ! preconditioning
           ! if the full svd is needed, the right singular vectors are computed
           ! from a matrix equation, and for that we need theoretical analysis
           ! of the businger-golub pivoting. so we use stdlib_zgeqp3 as the first rr qrf.
           ! in all other cases the first rr qrf can be chosen by other criteria
           ! (eg speed by replacing global with restricted window pivoting, such
           ! as in xgeqpx from toms # 782). good results will be obtained using
           ! xgeqpx with properly (!) chosen numerical parameters.
           ! any improvement of stdlib_zgeqp3 improves overall performance of stdlib_zgejsv.
           ! a * p1 = q1 * [ r1^* 0]^*:
           do p = 1, n
              ! All Columns Are Free Columns
              iwork(p) = 0
           end do
           call stdlib_zgeqp3( m, n, a, lda, iwork, cwork, cwork(n+1), lwork-n,rwork, ierr )
                     
           ! the upper triangular matrix r1 from the first qrf is inspected for
           ! rank deficiency and possibilities for deflation, or possible
           ! ill-conditioning. depending on the user specified flag l2rank,
           ! the procedure explores possibilities to reduce the numerical
           ! rank by inspecting the computed upper triangular factor. if
           ! l2rank or l2aber are up, then stdlib_zgejsv will compute the svd of
           ! a + da, where ||da|| <= f(m,n)*epsln.
           nr = 1
           if ( l2aber ) then
              ! standard absolute error bound suffices. all sigma_i with
              ! sigma_i < n*epsln*||a|| are flushed to zero. this is an
              ! aggressive enforcement of lower numerical rank by introducing a
              ! backward error of the order of n*epsln*||a||.
              temp1 = sqrt(real(n,KIND=dp))*epsln
              do p = 2, n
                 if ( abs(a(p,p)) >= (temp1*abs(a(1,1))) ) then
                    nr = nr + 1
                 else
                    go to 3002
                 end if
              end do
              3002 continue
           else if ( l2rank ) then
              ! .. similarly as above, only slightly more gentle (less aggressive).
              ! sudden drop on the diagonal of r1 is used as the criterion for
              ! close-to-rank-deficient.
              temp1 = sqrt(sfmin)
              do p = 2, n
                 if ( ( abs(a(p,p)) < (epsln*abs(a(p-1,p-1))) ) .or.( abs(a(p,p)) < small ) .or.( &
                           l2kill .and. (abs(a(p,p)) < temp1) ) ) go to 3402
                 nr = nr + 1
              end do
              3402 continue
           else
              ! the goal is high relative accuracy. however, if the matrix
              ! has high scaled condition number the relative accuracy is in
              ! general not feasible. later on, a condition number estimator
              ! will be deployed to estimate the scaled condition number.
              ! here we just remove the underflowed part of the triangular
              ! factor. this prevents the situation in which the code is
              ! working hard to get the accuracy not warranted by the data.
              temp1  = sqrt(sfmin)
              do p = 2, n
                 if ( ( abs(a(p,p)) < small ) .or.( l2kill .and. (abs(a(p,p)) < temp1) ) ) go to &
                           3302
                 nr = nr + 1
              end do
              3302 continue
           end if
           almort = .false.
           if ( nr == n ) then
              maxprj = one
              do p = 2, n
                 temp1  = abs(a(p,p)) / sva(iwork(p))
                 maxprj = min( maxprj, temp1 )
              end do
              if ( maxprj**2 >= one - real(n,KIND=dp)*epsln ) almort = .true.
           end if
           sconda = - one
           condr1 = - one
           condr2 = - one
           if ( errest ) then
              if ( n == nr ) then
                 if ( rsvec ) then
                    ! V Is Available As Workspace
                    call stdlib_zlacpy( 'U', n, n, a, lda, v, ldv )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_zdscal( p, one/temp1, v(1,p), 1 )
                    end do
                    if ( lsvec )then
                        call stdlib_zpocon( 'U', n, v, ldv, one, temp1,cwork(n+1), rwork, ierr )
                                  
                    else
                        call stdlib_zpocon( 'U', n, v, ldv, one, temp1,cwork, rwork, ierr )
                                  
                    end if
                 else if ( lsvec ) then
                    ! U Is Available As Workspace
                    call stdlib_zlacpy( 'U', n, n, a, lda, u, ldu )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_zdscal( p, one/temp1, u(1,p), 1 )
                    end do
                    call stdlib_zpocon( 'U', n, u, ldu, one, temp1,cwork(n+1), rwork, ierr )
                              
                 else
                    call stdlib_zlacpy( 'U', n, n, a, lda, cwork, n )
      ! []            call stdlib_zlacpy( 'u', n, n, a, lda, cwork(n+1), n )
                    ! change: here index shifted by n to the left, cwork(1:n)
                    ! not needed for sigma only computation
                    do p = 1, n
                       temp1 = sva(iwork(p))
      ! []               call stdlib_zdscal( p, one/temp1, cwork(n+(p-1)*n+1), 1 )
                       call stdlib_zdscal( p, one/temp1, cwork((p-1)*n+1), 1 )
                    end do
                 ! The Columns Of R Are Scaled To Have Unit Euclidean Lengths
      ! []               call stdlib_zpocon( 'u', n, cwork(n+1), n, one, temp1,
      ! []     $              cwork(n+n*n+1), rwork, ierr )
                    call stdlib_zpocon( 'U', n, cwork, n, one, temp1,cwork(n*n+1), rwork, ierr )
                              
                 end if
                 if ( temp1 /= zero ) then
                    sconda = one / sqrt(temp1)
                 else
                    sconda = - one
                 end if
                 ! sconda is an estimate of sqrt(||(r^* * r)^(-1)||_1).
                 ! n^(-1/4) * sconda <= ||r^(-1)||_2 <= n^(1/4) * sconda
              else
                 sconda = - one
              end if
           end if
           l2pert = l2pert .and. ( abs( a(1,1)/a(nr,nr) ) > sqrt(big1) )
           ! if there is no violent scaling, artificial perturbation is not needed.
           ! phase 3:
           if ( .not. ( rsvec .or. lsvec ) ) then
               ! singular values only
               ! .. transpose a(1:nr,1:n)
              do p = 1, min( n-1, nr )
                 call stdlib_zcopy( n-p, a(p,p+1), lda, a(p+1,p), 1 )
                 call stdlib_zlacgv( n-p+1, a(p,p), 1 )
              end do
              if ( nr == n ) a(n,n) = conjg(a(n,n))
              ! the following two do-loops introduce small relative perturbation
              ! into the strict upper triangle of the lower triangular matrix.
              ! small entries below the main diagonal are also changed.
              ! this modification is useful if the computing environment does not
              ! provide/allow flush to zero underflow, for it prevents many
              ! annoying denormalized numbers in case of strongly scaled matrices.
              ! the perturbation is structured so that it does not introduce any
              ! new perturbation of the singular values, and it does not destroy
              ! the job done by the preconditioner.
              ! the licence for this perturbation is in the variable l2pert, which
              ! should be .false. if flush to zero underflow is active.
              if ( .not. almort ) then
                 if ( l2pert ) then
                    ! xsc = sqrt(small)
                    xsc = epsln / real(n,KIND=dp)
                    do q = 1, nr
                       ctemp = cmplx(xsc*abs(a(q,q)),zero,KIND=dp)
                       do p = 1, n
                          if ( ( (p>q) .and. (abs(a(p,q))<=temp1) ).or. ( p < q ) )a(p,q) = &
                                    ctemp
           ! $                     a(p,q) = temp1 * ( a(p,q) / abs(a(p,q)) )
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_zlaset( 'U', nr-1,nr-1, czero,czero, a(1,2),lda )
                 end if
                  ! Second Preconditioning Using The Qr Factorization
                 call stdlib_zgeqrf( n,nr, a,lda, cwork, cwork(n+1),lwork-n, ierr )
                 ! And Transpose Upper To Lower Triangular
                 do p = 1, nr - 1
                    call stdlib_zcopy( nr-p, a(p,p+1), lda, a(p+1,p), 1 )
                    call stdlib_zlacgv( nr-p+1, a(p,p), 1 )
                 end do
           end if
                 ! row-cyclic jacobi svd algorithm with column pivoting
                 ! .. again some perturbation (a "background noise") is added
                 ! to drown denormals
                 if ( l2pert ) then
                    ! xsc = sqrt(small)
                    xsc = epsln / real(n,KIND=dp)
                    do q = 1, nr
                       ctemp = cmplx(xsc*abs(a(q,q)),zero,KIND=dp)
                       do p = 1, nr
                          if ( ( (p>q) .and. (abs(a(p,q))<=temp1) ).or. ( p < q ) )a(p,q) = &
                                    ctemp
           ! $                   a(p,q) = temp1 * ( a(p,q) / abs(a(p,q)) )
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_zlaset( 'U', nr-1, nr-1, czero, czero, a(1,2), lda )
                 end if
                 ! .. and one-sided jacobi rotations are started on a lower
                 ! triangular matrix (plus perturbation which is ignored in
                 ! the part which destroys triangular form (confusing?!))
                 call stdlib_zgesvj( 'L', 'N', 'N', nr, nr, a, lda, sva,n, v, ldv, cwork, lwork, &
                           rwork, lrwork, info )
                 scalem  = rwork(1)
                 numrank = nint(rwork(2),KIND=ilp)
           else if ( ( rsvec .and. ( .not. lsvec ) .and. ( .not. jracc ) ).or.( jracc .and. ( &
                     .not. lsvec ) .and. ( nr /= n ) ) ) then
              ! -> singular values and right singular vectors <-
              if ( almort ) then
                 ! In This Case Nr Equals N
                 do p = 1, nr
                    call stdlib_zcopy( n-p+1, a(p,p), lda, v(p,p), 1 )
                    call stdlib_zlacgv( n-p+1, v(p,p), 1 )
                 end do
                 if (nr>1) call stdlib_zlaset( 'U', nr-1,nr-1, czero, czero, v(1,2), ldv )
                 call stdlib_zgesvj( 'L','U','N', n, nr, v, ldv, sva, nr, a, lda,cwork, lwork, &
                           rwork, lrwork, info )
                 scalem  = rwork(1)
                 numrank = nint(rwork(2),KIND=ilp)
              else
              ! .. two more qr factorizations ( one qrf is not enough, two require
              ! accumulated product of jacobi rotations, three are perfect )
                 if (nr>1) call stdlib_zlaset( 'L', nr-1,nr-1, czero, czero, a(2,1), lda )
                 call stdlib_zgelqf( nr,n, a, lda, cwork, cwork(n+1), lwork-n, ierr)
                 call stdlib_zlacpy( 'L', nr, nr, a, lda, v, ldv )
                 if (nr>1) call stdlib_zlaset( 'U', nr-1,nr-1, czero, czero, v(1,2), ldv )
                 call stdlib_zgeqrf( nr, nr, v, ldv, cwork(n+1), cwork(2*n+1),lwork-2*n, ierr )
                           
                 do p = 1, nr
                    call stdlib_zcopy( nr-p+1, v(p,p), ldv, v(p,p), 1 )
                    call stdlib_zlacgv( nr-p+1, v(p,p), 1 )
                 end do
                 if (nr>1) call stdlib_zlaset('U', nr-1, nr-1, czero, czero, v(1,2), ldv)
                 call stdlib_zgesvj( 'L', 'U','N', nr, nr, v,ldv, sva, nr, u,ldu, cwork(n+1), &
                           lwork-n, rwork, lrwork, info )
                 scalem  = rwork(1)
                 numrank = nint(rwork(2),KIND=ilp)
                 if ( nr < n ) then
                    call stdlib_zlaset( 'A',n-nr, nr, czero,czero, v(nr+1,1),  ldv )
                    call stdlib_zlaset( 'A',nr, n-nr, czero,czero, v(1,nr+1),  ldv )
                    call stdlib_zlaset( 'A',n-nr,n-nr,czero,cone, v(nr+1,nr+1),ldv )
                 end if
              call stdlib_zunmlq( 'L', 'C', n, n, nr, a, lda, cwork,v, ldv, cwork(n+1), lwork-n, &
                        ierr )
              end if
               ! Permute The Rows Of V
               ! do 8991 p = 1, n
                  ! call stdlib_zcopy( n, v(p,1), ldv, a(iwork(p),1), lda )
                  8991 continue
               ! call stdlib_zlacpy( 'all', n, n, a, lda, v, ldv )
              call stdlib_zlapmr( .false., n, n, v, ldv, iwork )
               if ( transp ) then
                 call stdlib_zlacpy( 'A', n, n, v, ldv, u, ldu )
               end if
           else if ( jracc .and. (.not. lsvec) .and. ( nr== n ) ) then
              if (n>1) call stdlib_zlaset( 'L', n-1,n-1, czero, czero, a(2,1), lda )
              call stdlib_zgesvj( 'U','N','V', n, n, a, lda, sva, n, v, ldv,cwork, lwork, rwork, &
                        lrwork, info )
               scalem  = rwork(1)
               numrank = nint(rwork(2),KIND=ilp)
               call stdlib_zlapmr( .false., n, n, v, ldv, iwork )
           else if ( lsvec .and. ( .not. rsvec ) ) then
              ! Singular Values And Left Singular Vectors                 
              ! Second Preconditioning Step To Avoid Need To Accumulate
              ! jacobi rotations in the jacobi iterations.
              do p = 1, nr
                 call stdlib_zcopy( n-p+1, a(p,p), lda, u(p,p), 1 )
                 call stdlib_zlacgv( n-p+1, u(p,p), 1 )
              end do
              if (nr>1) call stdlib_zlaset( 'U', nr-1, nr-1, czero, czero, u(1,2), ldu )
              call stdlib_zgeqrf( n, nr, u, ldu, cwork(n+1), cwork(2*n+1),lwork-2*n, ierr )
                        
              do p = 1, nr - 1
                 call stdlib_zcopy( nr-p, u(p,p+1), ldu, u(p+1,p), 1 )
                 call stdlib_zlacgv( n-p+1, u(p,p), 1 )
              end do
              if (nr>1) call stdlib_zlaset( 'U', nr-1, nr-1, czero, czero, u(1,2), ldu )
              call stdlib_zgesvj( 'L', 'U', 'N', nr,nr, u, ldu, sva, nr, a,lda, cwork(n+1), lwork-&
                        n, rwork, lrwork, info )
              scalem  = rwork(1)
              numrank = nint(rwork(2),KIND=ilp)
              if ( nr < m ) then
                 call stdlib_zlaset( 'A',  m-nr, nr,czero, czero, u(nr+1,1), ldu )
                 if ( nr < n1 ) then
                    call stdlib_zlaset( 'A',nr, n1-nr, czero, czero, u(1,nr+1),ldu )
                    call stdlib_zlaset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1),ldu )
                 end if
              end if
              call stdlib_zunmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, cwork(n+1), lwork-n, &
                        ierr )
              if ( rowpiv )call stdlib_zlaswp( n1, u, ldu, 1, m-1, iwork(iwoff+1), -1 )
              do p = 1, n1
                 xsc = one / stdlib_dznrm2( m, u(1,p), 1 )
                 call stdlib_zdscal( m, xsc, u(1,p), 1 )
              end do
              if ( transp ) then
                 call stdlib_zlacpy( 'A', n, n, u, ldu, v, ldv )
              end if
           else
              ! Full Svd 
              if ( .not. jracc ) then
              if ( .not. almort ) then
                 ! second preconditioning step (qrf [with pivoting])
                 ! note that the composition of transpose, qrf and transpose is
                 ! equivalent to an lqf call. since in many libraries the qrf
                 ! seems to be better optimized than the lqf, we do explicit
                 ! transpose and use the qrf. this is subject to changes in an
                 ! optimized implementation of stdlib_zgejsv.
                 do p = 1, nr
                    call stdlib_zcopy( n-p+1, a(p,p), lda, v(p,p), 1 )
                    call stdlib_zlacgv( n-p+1, v(p,p), 1 )
                 end do
                 ! The Following Two Loops Perturb Small Entries To Avoid
                 ! denormals in the second qr factorization, where they are
                 ! as good as zeros. this is done to avoid painfully slow
                 ! computation with denormals. the relative size of the perturbation
                 ! is a parameter that can be changed by the implementer.
                 ! this perturbation device will be obsolete on machines with
                 ! properly implemented arithmetic.
                 ! to switch it off, set l2pert=.false. to remove it from  the
                 ! code, remove the action under l2pert=.true., leave the else part.
                 ! the following two loops should be blocked and fused with the
                 ! transposed copy above.
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do q = 1, nr
                       ctemp = cmplx(xsc*abs( v(q,q) ),zero,KIND=dp)
                       do p = 1, n
                          if ( ( p > q ) .and. ( abs(v(p,q)) <= temp1 ).or. ( p < q ) )v(p,q) = &
                                    ctemp
           ! $                   v(p,q) = temp1 * ( v(p,q) / abs(v(p,q)) )
                          if ( p < q ) v(p,q) = - v(p,q)
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_zlaset( 'U', nr-1, nr-1, czero, czero, v(1,2), ldv )
                 end if
                 ! estimate the row scaled condition number of r1
                 ! (if r1 is rectangular, n > nr, then the condition number
                 ! of the leading nr x nr submatrix is estimated.)
                 call stdlib_zlacpy( 'L', nr, nr, v, ldv, cwork(2*n+1), nr )
                 do p = 1, nr
                    temp1 = stdlib_dznrm2(nr-p+1,cwork(2*n+(p-1)*nr+p),1)
                    call stdlib_zdscal(nr-p+1,one/temp1,cwork(2*n+(p-1)*nr+p),1)
                 end do
                 call stdlib_zpocon('L',nr,cwork(2*n+1),nr,one,temp1,cwork(2*n+nr*nr+1),rwork,&
                           ierr)
                 condr1 = one / sqrt(temp1)
                 ! Here Need A Second Opinion On The Condition Number
                 ! Then Assume Worst Case Scenario
                 ! r1 is ok for inverse <=> condr1 < real(n,KIND=dp)
                 ! more conservative    <=> condr1 < sqrt(real(n,KIND=dp))
                 cond_ok = sqrt(sqrt(real(nr,KIND=dp)))
      ! [tp]       cond_ok is a tuning parameter.
                 if ( condr1 < cond_ok ) then
                    ! .. the second qrf without pivoting. note: in an optimized
                    ! implementation, this qrf should be implemented as the qrf
                    ! of a lower triangular matrix.
                    ! r1^* = q2 * r2
                    call stdlib_zgeqrf( n, nr, v, ldv, cwork(n+1), cwork(2*n+1),lwork-2*n, ierr )
                              
                    if ( l2pert ) then
                       xsc = sqrt(small)/epsln
                       do p = 2, nr
                          do q = 1, p - 1
                             ctemp=cmplx(xsc*min(abs(v(p,p)),abs(v(q,q))),zero,KIND=dp)
                             if ( abs(v(q,p)) <= temp1 )v(q,p) = ctemp
           ! $                     v(q,p) = temp1 * ( v(q,p) / abs(v(q,p)) )
                          end do
                       end do
                    end if
                    if ( nr /= n )call stdlib_zlacpy( 'A', n, nr, v, ldv, cwork(2*n+1), n )
                              
                    ! .. save ...
                 ! This Transposed Copy Should Be Better Than Naive
                    do p = 1, nr - 1
                       call stdlib_zcopy( nr-p, v(p,p+1), ldv, v(p+1,p), 1 )
                       call stdlib_zlacgv(nr-p+1, v(p,p), 1 )
                    end do
                    v(nr,nr)=conjg(v(nr,nr))
                    condr2 = condr1
                 else
                    ! .. ill-conditioned case: second qrf with pivoting
                    ! note that windowed pivoting would be equally good
                    ! numerically, and more run-time efficient. so, in
                    ! an optimal implementation, the next call to stdlib_zgeqp3
                    ! should be replaced with eg. call zgeqpx (acm toms #782)
                    ! with properly (carefully) chosen parameters.
                    ! r1^* * p2 = q2 * r2
                    do p = 1, nr
                       iwork(n+p) = 0
                    end do
                    call stdlib_zgeqp3( n, nr, v, ldv, iwork(n+1), cwork(n+1),cwork(2*n+1), lwork-&
                              2*n, rwork, ierr )
      ! *               call stdlib_zgeqrf( n, nr, v, ldv, cwork(n+1), cwork(2*n+1),
      ! *     $              lwork-2*n, ierr )
                    if ( l2pert ) then
                       xsc = sqrt(small)
                       do p = 2, nr
                          do q = 1, p - 1
                             ctemp=cmplx(xsc*min(abs(v(p,p)),abs(v(q,q))),zero,KIND=dp)
                             if ( abs(v(q,p)) <= temp1 )v(q,p) = ctemp
           ! $                     v(q,p) = temp1 * ( v(q,p) / abs(v(q,p)) )
                          end do
                       end do
                    end if
                    call stdlib_zlacpy( 'A', n, nr, v, ldv, cwork(2*n+1), n )
                    if ( l2pert ) then
                       xsc = sqrt(small)
                       do p = 2, nr
                          do q = 1, p - 1
                             ctemp=cmplx(xsc*min(abs(v(p,p)),abs(v(q,q))),zero,KIND=dp)
                              ! v(p,q) = - temp1*( v(q,p) / abs(v(q,p)) )
                             v(p,q) = - ctemp
                          end do
                       end do
                    else
                       if (nr>1) call stdlib_zlaset( 'L',nr-1,nr-1,czero,czero,v(2,1),ldv )
                    end if
                    ! now, compute r2 = l3 * q3, the lq factorization.
                    call stdlib_zgelqf( nr, nr, v, ldv, cwork(2*n+n*nr+1),cwork(2*n+n*nr+nr+1), &
                              lwork-2*n-n*nr-nr, ierr )
                    ! And Estimate The Condition Number
                    call stdlib_zlacpy( 'L',nr,nr,v,ldv,cwork(2*n+n*nr+nr+1),nr )
                    do p = 1, nr
                       temp1 = stdlib_dznrm2( p, cwork(2*n+n*nr+nr+p), nr )
                       call stdlib_zdscal( p, one/temp1, cwork(2*n+n*nr+nr+p), nr )
                    end do
                    call stdlib_zpocon( 'L',nr,cwork(2*n+n*nr+nr+1),nr,one,temp1,cwork(2*n+n*nr+&
                              nr+nr*nr+1),rwork,ierr )
                    condr2 = one / sqrt(temp1)
                    if ( condr2 >= cond_ok ) then
                       ! Save The Householder Vectors Used For Q3
                       ! (this overwrites the copy of r2, as it will not be
                       ! needed in this branch, but it does not overwritte the
                       ! huseholder vectors of q2.).
                       call stdlib_zlacpy( 'U', nr, nr, v, ldv, cwork(2*n+1), n )
                       ! And The Rest Of The Information On Q3 Is In
                       ! work(2*n+n*nr+1:2*n+n*nr+n)
                    end if
                 end if
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do q = 2, nr
                       ctemp = xsc * v(q,q)
                       do p = 1, q - 1
                           ! v(p,q) = - temp1*( v(p,q) / abs(v(p,q)) )
                          v(p,q) = - ctemp
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_zlaset( 'U', nr-1,nr-1, czero,czero, v(1,2), ldv )
                 end if
              ! second preconditioning finished; continue with jacobi svd
              ! the input matrix is lower trinagular.
              ! recover the right singular vectors as solution of a well
              ! conditioned triangular matrix equation.
                 if ( condr1 < cond_ok ) then
                    call stdlib_zgesvj( 'L','U','N',nr,nr,v,ldv,sva,nr,u, ldu,cwork(2*n+n*nr+nr+1)&
                              ,lwork-2*n-n*nr-nr,rwork,lrwork, info )
                    scalem  = rwork(1)
                    numrank = nint(rwork(2),KIND=ilp)
                    do p = 1, nr
                       call stdlib_zcopy(  nr, v(1,p), 1, u(1,p), 1 )
                       call stdlib_zdscal( nr, sva(p),    v(1,p), 1 )
                    end do
              ! Pick The Right Matrix Equation And Solve It
                    if ( nr == n ) then
       ! :))             .. best case, r1 is inverted. the solution of this matrix
                       ! equation is q2*v2 = the product of the jacobi rotations
                       ! used in stdlib_zgesvj, premultiplied with the orthogonal matrix
                       ! from the second qr factorization.
                       call stdlib_ztrsm('L','U','N','N', nr,nr,cone, a,lda, v,ldv)
                    else
                       ! .. r1 is well conditioned, but non-square. adjoint of r2
                       ! is inverted to get the product of the jacobi rotations
                       ! used in stdlib_zgesvj. the q-factor from the second qr
                       ! factorization is then built in explicitly.
                       call stdlib_ztrsm('L','U','C','N',nr,nr,cone,cwork(2*n+1),n,v,ldv)
                       if ( nr < n ) then
                       call stdlib_zlaset('A',n-nr,nr,czero,czero,v(nr+1,1),ldv)
                       call stdlib_zlaset('A',nr,n-nr,czero,czero,v(1,nr+1),ldv)
                       call stdlib_zlaset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                       end if
                       call stdlib_zunmqr('L','N',n,n,nr,cwork(2*n+1),n,cwork(n+1),v,ldv,cwork(&
                                 2*n+n*nr+nr+1),lwork-2*n-n*nr-nr,ierr)
                    end if
                 else if ( condr2 < cond_ok ) then
                    ! the matrix r2 is inverted. the solution of the matrix equation
                    ! is q3^* * v3 = the product of the jacobi rotations (appplied to
                    ! the lower triangular l3 from the lq factorization of
                    ! r2=l3*q3), pre-multiplied with the transposed q3.
                    call stdlib_zgesvj( 'L', 'U', 'N', nr, nr, v, ldv, sva, nr, u,ldu, cwork(2*n+&
                              n*nr+nr+1), lwork-2*n-n*nr-nr,rwork, lrwork, info )
                    scalem  = rwork(1)
                    numrank = nint(rwork(2),KIND=ilp)
                    do p = 1, nr
                       call stdlib_zcopy( nr, v(1,p), 1, u(1,p), 1 )
                       call stdlib_zdscal( nr, sva(p),    u(1,p), 1 )
                    end do
                    call stdlib_ztrsm('L','U','N','N',nr,nr,cone,cwork(2*n+1),n,u,ldu)
                    ! Apply The Permutation From The Second Qr Factorization
                    do q = 1, nr
                       do p = 1, nr
                          cwork(2*n+n*nr+nr+iwork(n+p)) = u(p,q)
                       end do
                       do p = 1, nr
                          u(p,q) = cwork(2*n+n*nr+nr+p)
                       end do
                    end do
                    if ( nr < n ) then
                       call stdlib_zlaset( 'A',n-nr,nr,czero,czero,v(nr+1,1),ldv )
                       call stdlib_zlaset( 'A',nr,n-nr,czero,czero,v(1,nr+1),ldv )
                       call stdlib_zlaset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                    end if
                    call stdlib_zunmqr( 'L','N',n,n,nr,cwork(2*n+1),n,cwork(n+1),v,ldv,cwork(2*n+&
                              n*nr+nr+1),lwork-2*n-n*nr-nr,ierr )
                 else
                    ! last line of defense.
       ! #:(          this is a rather pathological case: no scaled condition
                    ! improvement after two pivoted qr factorizations. other
                    ! possibility is that the rank revealing qr factorization
                    ! or the condition estimator has failed, or the cond_ok
                    ! is set very close to one (which is unnecessary). normally,
                    ! this branch should never be executed, but in rare cases of
                    ! failure of the rrqr or condition estimator, the last line of
                    ! defense ensures that stdlib_zgejsv completes the task.
                    ! compute the full svd of l3 using stdlib_zgesvj with explicit
                    ! accumulation of jacobi rotations.
                    call stdlib_zgesvj( 'L', 'U', 'V', nr, nr, v, ldv, sva, nr, u,ldu, cwork(2*n+&
                              n*nr+nr+1), lwork-2*n-n*nr-nr,rwork, lrwork, info )
                    scalem  = rwork(1)
                    numrank = nint(rwork(2),KIND=ilp)
                    if ( nr < n ) then
                       call stdlib_zlaset( 'A',n-nr,nr,czero,czero,v(nr+1,1),ldv )
                       call stdlib_zlaset( 'A',nr,n-nr,czero,czero,v(1,nr+1),ldv )
                       call stdlib_zlaset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                    end if
                    call stdlib_zunmqr( 'L','N',n,n,nr,cwork(2*n+1),n,cwork(n+1),v,ldv,cwork(2*n+&
                              n*nr+nr+1),lwork-2*n-n*nr-nr,ierr )
                    call stdlib_zunmlq( 'L', 'C', nr, nr, nr, cwork(2*n+1), n,cwork(2*n+n*nr+1), &
                              u, ldu, cwork(2*n+n*nr+nr+1),lwork-2*n-n*nr-nr, ierr )
                    do q = 1, nr
                       do p = 1, nr
                          cwork(2*n+n*nr+nr+iwork(n+p)) = u(p,q)
                       end do
                       do p = 1, nr
                          u(p,q) = cwork(2*n+n*nr+nr+p)
                       end do
                    end do
                 end if
                 ! permute the rows of v using the (column) permutation from the
                 ! first qrf. also, scale the columns to make them unit in
                 ! euclidean norm. this applies to all cases.
                 temp1 = sqrt(real(n,KIND=dp)) * epsln
                 do q = 1, n
                    do p = 1, n
                       cwork(2*n+n*nr+nr+iwork(p)) = v(p,q)
                    end do
                    do p = 1, n
                       v(p,q) = cwork(2*n+n*nr+nr+p)
                    end do
                    xsc = one / stdlib_dznrm2( n, v(1,q), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_zdscal( n, xsc,&
                               v(1,q), 1 )
                 end do
                 ! at this moment, v contains the right singular vectors of a.
                 ! next, assemble the left singular vector matrix u (m x n).
                 if ( nr < m ) then
                    call stdlib_zlaset('A', m-nr, nr, czero, czero, u(nr+1,1), ldu)
                    if ( nr < n1 ) then
                       call stdlib_zlaset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                       call stdlib_zlaset('A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1),ldu)
                    end if
                 end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! matrix u. this applies to all cases.
                 call stdlib_zunmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, cwork(n+1), lwork-&
                           n, ierr )
                 ! the columns of u are normalized. the cost is o(m*n) flops.
                 temp1 = sqrt(real(m,KIND=dp)) * epsln
                 do p = 1, nr
                    xsc = one / stdlib_dznrm2( m, u(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_zdscal( m, xsc,&
                               u(1,p), 1 )
                 end do
                 ! if the initial qrf is computed with row pivoting, the left
                 ! singular vectors must be adjusted.
                 if ( rowpiv )call stdlib_zlaswp( n1, u, ldu, 1, m-1, iwork(iwoff+1), -1 )
              else
              ! The Initial Matrix A Has Almost Orthogonal Columns And
              ! the second qrf is not needed
                 call stdlib_zlacpy( 'U', n, n, a, lda, cwork(n+1), n )
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do p = 2, n
                       ctemp = xsc * cwork( n + (p-1)*n + p )
                       do q = 1, p - 1
                           ! cwork(n+(q-1)*n+p)=-temp1 * ( cwork(n+(p-1)*n+q) /
           ! $                                        abs(cwork(n+(p-1)*n+q)) )
                          cwork(n+(q-1)*n+p)=-ctemp
                       end do
                    end do
                 else
                    call stdlib_zlaset( 'L',n-1,n-1,czero,czero,cwork(n+2),n )
                 end if
                 call stdlib_zgesvj( 'U', 'U', 'N', n, n, cwork(n+1), n, sva,n, u, ldu, cwork(n+&
                           n*n+1), lwork-n-n*n, rwork, lrwork,info )
                 scalem  = rwork(1)
                 numrank = nint(rwork(2),KIND=ilp)
                 do p = 1, n
                    call stdlib_zcopy( n, cwork(n+(p-1)*n+1), 1, u(1,p), 1 )
                    call stdlib_zdscal( n, sva(p), cwork(n+(p-1)*n+1), 1 )
                 end do
                 call stdlib_ztrsm( 'L', 'U', 'N', 'N', n, n,cone, a, lda, cwork(n+1), n )
                 do p = 1, n
                    call stdlib_zcopy( n, cwork(n+p), n, v(iwork(p),1), ldv )
                 end do
                 temp1 = sqrt(real(n,KIND=dp))*epsln
                 do p = 1, n
                    xsc = one / stdlib_dznrm2( n, v(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_zdscal( n, xsc,&
                               v(1,p), 1 )
                 end do
                 ! assemble the left singular vector matrix u (m x n).
                 if ( n < m ) then
                    call stdlib_zlaset( 'A',  m-n, n, czero, czero, u(n+1,1), ldu )
                    if ( n < n1 ) then
                       call stdlib_zlaset('A',n,  n1-n, czero, czero,  u(1,n+1),ldu)
                       call stdlib_zlaset( 'A',m-n,n1-n, czero, cone,u(n+1,n+1),ldu)
                    end if
                 end if
                 call stdlib_zunmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, cwork(n+1), lwork-&
                           n, ierr )
                 temp1 = sqrt(real(m,KIND=dp))*epsln
                 do p = 1, n1
                    xsc = one / stdlib_dznrm2( m, u(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_zdscal( m, xsc,&
                               u(1,p), 1 )
                 end do
                 if ( rowpiv )call stdlib_zlaswp( n1, u, ldu, 1, m-1, iwork(iwoff+1), -1 )
              end if
              ! end of the  >> almost orthogonal case <<  in the full svd
              else
              ! this branch deploys a preconditioned jacobi svd with explicitly
              ! accumulated rotations. it is included as optional, mainly for
              ! experimental purposes. it does perform well, and can also be used.
              ! in this implementation, this branch will be automatically activated
              ! if the  condition number sigma_max(a) / sigma_min(a) is predicted
              ! to be greater than the overflow threshold. this is because the
              ! a posteriori computation of the singular vectors assumes robust
              ! implementation of blas and some lapack procedures, capable of working
              ! in presence of extreme values, e.g. when the singular values spread from
              ! the underflow to the overflow threshold.
              do p = 1, nr
                 call stdlib_zcopy( n-p+1, a(p,p), lda, v(p,p), 1 )
                 call stdlib_zlacgv( n-p+1, v(p,p), 1 )
              end do
              if ( l2pert ) then
                 xsc = sqrt(small/epsln)
                 do q = 1, nr
                    ctemp = cmplx(xsc*abs( v(q,q) ),zero,KIND=dp)
                    do p = 1, n
                       if ( ( p > q ) .and. ( abs(v(p,q)) <= temp1 ).or. ( p < q ) )v(p,q) = &
                                 ctemp
           ! $                v(p,q) = temp1 * ( v(p,q) / abs(v(p,q)) )
                       if ( p < q ) v(p,q) = - v(p,q)
                    end do
                 end do
              else
                 if (nr>1) call stdlib_zlaset( 'U', nr-1, nr-1, czero, czero, v(1,2), ldv )
              end if
              call stdlib_zgeqrf( n, nr, v, ldv, cwork(n+1), cwork(2*n+1),lwork-2*n, ierr )
                        
              call stdlib_zlacpy( 'L', n, nr, v, ldv, cwork(2*n+1), n )
              do p = 1, nr
                 call stdlib_zcopy( nr-p+1, v(p,p), ldv, u(p,p), 1 )
                 call stdlib_zlacgv( nr-p+1, u(p,p), 1 )
              end do
              if ( l2pert ) then
                 xsc = sqrt(small/epsln)
                 do q = 2, nr
                    do p = 1, q - 1
                       ctemp = cmplx(xsc * min(abs(u(p,p)),abs(u(q,q))),zero,KIND=dp)
                        ! u(p,q) = - temp1 * ( u(q,p) / abs(u(q,p)) )
                       u(p,q) = - ctemp
                    end do
                 end do
              else
                 if (nr>1) call stdlib_zlaset('U', nr-1, nr-1, czero, czero, u(1,2), ldu )
              end if
              call stdlib_zgesvj( 'L', 'U', 'V', nr, nr, u, ldu, sva,n, v, ldv, cwork(2*n+n*nr+1),&
                         lwork-2*n-n*nr,rwork, lrwork, info )
              scalem  = rwork(1)
              numrank = nint(rwork(2),KIND=ilp)
              if ( nr < n ) then
                 call stdlib_zlaset( 'A',n-nr,nr,czero,czero,v(nr+1,1),ldv )
                 call stdlib_zlaset( 'A',nr,n-nr,czero,czero,v(1,nr+1),ldv )
                 call stdlib_zlaset( 'A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv )
              end if
              call stdlib_zunmqr( 'L','N',n,n,nr,cwork(2*n+1),n,cwork(n+1),v,ldv,cwork(2*n+n*nr+&
                        nr+1),lwork-2*n-n*nr-nr,ierr )
                 ! permute the rows of v using the (column) permutation from the
                 ! first qrf. also, scale the columns to make them unit in
                 ! euclidean norm. this applies to all cases.
                 temp1 = sqrt(real(n,KIND=dp)) * epsln
                 do q = 1, n
                    do p = 1, n
                       cwork(2*n+n*nr+nr+iwork(p)) = v(p,q)
                    end do
                    do p = 1, n
                       v(p,q) = cwork(2*n+n*nr+nr+p)
                    end do
                    xsc = one / stdlib_dznrm2( n, v(1,q), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_zdscal( n, xsc,&
                               v(1,q), 1 )
                 end do
                 ! at this moment, v contains the right singular vectors of a.
                 ! next, assemble the left singular vector matrix u (m x n).
              if ( nr < m ) then
                 call stdlib_zlaset( 'A',  m-nr, nr, czero, czero, u(nr+1,1), ldu )
                 if ( nr < n1 ) then
                    call stdlib_zlaset('A',nr,  n1-nr, czero, czero,  u(1,nr+1),ldu)
                    call stdlib_zlaset('A',m-nr,n1-nr, czero, cone,u(nr+1,nr+1),ldu)
                 end if
              end if
              call stdlib_zunmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, cwork(n+1), lwork-n, &
                        ierr )
                 if ( rowpiv )call stdlib_zlaswp( n1, u, ldu, 1, m-1, iwork(iwoff+1), -1 )
              end if
              if ( transp ) then
                 ! .. swap u and v because the procedure worked on a^*
                 do p = 1, n
                    call stdlib_zswap( n, u(1,p), 1, v(1,p), 1 )
                 end do
              end if
           end if
           ! end of the full svd
           ! undo scaling, if necessary (and possible)
           if ( uscal2 <= (big/sva(1))*uscal1 ) then
              call stdlib_dlascl( 'G', 0, 0, uscal1, uscal2, nr, 1, sva, n, ierr )
              uscal1 = one
              uscal2 = one
           end if
           if ( nr < n ) then
              do p = nr+1, n
                 sva(p) = zero
              end do
           end if
           rwork(1) = uscal2 * scalem
           rwork(2) = uscal1
           if ( errest ) rwork(3) = sconda
           if ( lsvec .and. rsvec ) then
              rwork(4) = condr1
              rwork(5) = condr2
           end if
           if ( l2tran ) then
              rwork(6) = entra
              rwork(7) = entrat
           end if
           iwork(1) = nr
           iwork(2) = numrank
           iwork(3) = warning
           if ( transp ) then
               iwork(4) =  1
           else
               iwork(4) = -1
           end if
           return
     end subroutine stdlib_zgejsv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$gejsv( joba, jobu, jobv, jobr, jobt, jobp,m, n, a, lda, sva, u, ldu, &
     !! ZGEJSV: computes the singular value decomposition (SVD) of a complex M-by-N
     !! matrix [A], where M >= N. The SVD of [A] is written as
     !! [A] = [U] * [SIGMA] * [V]^*,
     !! where [SIGMA] is an N-by-N (M-by-N) matrix which is zero except for its N
     !! diagonal elements, [U] is an M-by-N (or M-by-M) unitary matrix, and
     !! [V] is an N-by-N unitary matrix. The diagonal elements of [SIGMA] are
     !! the singular values of [A]. The columns of [U] and [V] are the left and
     !! the right singular vectors of [A], respectively. The matrices [U] and [V]
     !! are computed and stored in the arrays U and V, respectively. The diagonal
     !! of [SIGMA] is computed and stored in the array SVA.
               v, ldv,cwork, lwork, rwork, lrwork, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldu, ldv, lwork, lrwork, m, n
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: u(ldu,*), v(ldv,*), cwork(lwork)
           real(${ck}$), intent(out) :: sva(n), rwork(lrwork)
           integer(ilp), intent(out) :: iwork(*)
           character, intent(in) :: joba, jobp, jobr, jobt, jobu, jobv
        ! ===========================================================================
           
           
           ! Local Scalars 
           complex(${ck}$) :: ctemp
           real(${ck}$) :: aapp, aaqq, aatmax, aatmin, big, big1, cond_ok, condr1, condr2, entra, &
                     entrat, epsln, maxprj, scalem, sconda, sfmin, small, temp1, uscal1, uscal2, xsc
           integer(ilp) :: ierr, n1, nr, numrank, p, q, warning
           logical(lk) :: almort, defr, errest, goscal, jracc, kill, lquery, lsvec, l2aber, &
                     l2kill, l2pert, l2rank, l2tran, noscal, rowpiv, rsvec, transp
           integer(ilp) :: optwrk, minwrk, minrwrk, miniwrk
           integer(ilp) :: lwcon, lwlqf, lwqp3, lwqrf, lwunmlq, lwunmqr, lwunmqrm, lwsvdj, &
                     lwsvdjv, lrwqp3, lrwcon, lrwsvdj, iwoff
           integer(ilp) :: lwrk_wgelqf, lwrk_wgeqp3, lwrk_wgeqp3n, lwrk_wgeqrf, lwrk_wgesvj, &
                     lwrk_wgesvjv, lwrk_wgesvju, lwrk_wunmlq, lwrk_wunmqr, lwrk_wunmqrm
           ! Local Arrays
           complex(${ck}$) :: cdummy(1)
           real(${ck}$) :: rdummy(1)
           ! Intrinsic Functions 
           ! test the input arguments
           lsvec  = stdlib_lsame( jobu, 'U' ) .or. stdlib_lsame( jobu, 'F' )
           jracc  = stdlib_lsame( jobv, 'J' )
           rsvec  = stdlib_lsame( jobv, 'V' ) .or. jracc
           rowpiv = stdlib_lsame( joba, 'F' ) .or. stdlib_lsame( joba, 'G' )
           l2rank = stdlib_lsame( joba, 'R' )
           l2aber = stdlib_lsame( joba, 'A' )
           errest = stdlib_lsame( joba, 'E' ) .or. stdlib_lsame( joba, 'G' )
           l2tran = stdlib_lsame( jobt, 'T' ) .and. ( m == n )
           l2kill = stdlib_lsame( jobr, 'R' )
           defr   = stdlib_lsame( jobr, 'N' )
           l2pert = stdlib_lsame( jobp, 'P' )
           lquery = ( lwork == -1 ) .or. ( lrwork == -1 )
           if ( .not.(rowpiv .or. l2rank .or. l2aber .or.errest .or. stdlib_lsame( joba, 'C' ) )) &
                     then
              info = - 1
           else if ( .not.( lsvec .or. stdlib_lsame( jobu, 'N' ) .or.( stdlib_lsame( jobu, 'W' ) &
                     .and. rsvec .and. l2tran ) ) ) then
              info = - 2
           else if ( .not.( rsvec .or. stdlib_lsame( jobv, 'N' ) .or.( stdlib_lsame( jobv, 'W' ) &
                     .and. lsvec .and. l2tran ) ) ) then
              info = - 3
           else if ( .not. ( l2kill .or. defr ) )    then
              info = - 4
           else if ( .not. ( stdlib_lsame(jobt,'T') .or. stdlib_lsame(jobt,'N') ) ) then
              info = - 5
           else if ( .not. ( l2pert .or. stdlib_lsame( jobp, 'N' ) ) ) then
              info = - 6
           else if ( m < 0 ) then
              info = - 7
           else if ( ( n < 0 ) .or. ( n > m ) ) then
              info = - 8
           else if ( lda < m ) then
              info = - 10
           else if ( lsvec .and. ( ldu < m ) ) then
              info = - 13
           else if ( rsvec .and. ( ldv < n ) ) then
              info = - 15
           else
              ! #:)
              info = 0
           end if
           if ( info == 0 ) then
               ! Compute The Minimal And The Optimal Workspace Lengths
               ! [[the expressions for computing the minimal and the optimal
               ! values of lcwork, lrwork are written with a lot of redundancy and
               ! can be simplified. however, this verbose form is useful for
               ! maintenance and modifications of the code.]]
              ! .. minimal workspace length for stdlib_${ci}$geqp3 of an m x n matrix,
               ! stdlib_${ci}$geqrf of an n x n matrix, stdlib_${ci}$gelqf of an n x n matrix,
               ! stdlib_${ci}$unmlq for computing n x n matrix, stdlib_${ci}$unmqr for computing n x n
               ! matrix, stdlib_${ci}$unmqr for computing m x n matrix, respectively.
               lwqp3 = n+1
               lwqrf = max( 1, n )
               lwlqf = max( 1, n )
               lwunmlq  = max( 1, n )
               lwunmqr  = max( 1, n )
               lwunmqrm = max( 1, m )
              ! Minimal Workspace Length For Stdlib_Zpocon Of An N X N Matrix
               lwcon = 2 * n
              ! .. minimal workspace length for stdlib_${ci}$gesvj of an n x n matrix,
               ! without and with explicit accumulation of jacobi rotations
               lwsvdj  = max( 2 * n, 1 )
               lwsvdjv = max( 2 * n, 1 )
               ! .. minimal real workspace length for stdlib_${ci}$geqp3, stdlib_${ci}$pocon, stdlib_${ci}$gesvj
               lrwqp3  = 2 * n
               lrwcon  = n
               lrwsvdj = n
               if ( lquery ) then
                   call stdlib_${ci}$geqp3( m, n, a, lda, iwork, cdummy, cdummy, -1,rdummy, ierr )
                             
                   lwrk_wgeqp3 = real( cdummy(1),KIND=${ck}$)
                   call stdlib_${ci}$geqrf( n, n, a, lda, cdummy, cdummy,-1, ierr )
                   lwrk_wgeqrf = real( cdummy(1),KIND=${ck}$)
                   call stdlib_${ci}$gelqf( n, n, a, lda, cdummy, cdummy,-1, ierr )
                   lwrk_wgelqf = real( cdummy(1),KIND=${ck}$)
               end if
               minwrk  = 2
               optwrk  = 2
               miniwrk = n
               if ( .not. (lsvec .or. rsvec ) ) then
                   ! Minimal And Optimal Sizes Of The Complex Workspace If
                   ! only the singular values are requested
                   if ( errest ) then
                       minwrk = max( n+lwqp3, n**2+lwcon, n+lwqrf, lwsvdj )
                   else
                       minwrk = max( n+lwqp3, n+lwqrf, lwsvdj )
                   end if
                   if ( lquery ) then
                       call stdlib_${ci}$gesvj( 'L', 'N', 'N', n, n, a, lda, sva, n, v,ldv, cdummy, -1,&
                                  rdummy, -1, ierr )
                       lwrk_wgesvj = real( cdummy(1),KIND=${ck}$)
                       if ( errest ) then
                           optwrk = max( n+lwrk_wgeqp3, n**2+lwcon,n+lwrk_wgeqrf, lwrk_wgesvj )
                                     
                       else
                           optwrk = max( n+lwrk_wgeqp3, n+lwrk_wgeqrf,lwrk_wgesvj )
                       end if
                   end if
                   if ( l2tran .or. rowpiv ) then
                       if ( errest ) then
                          minrwrk = max( 7, 2*m,  lrwqp3, lrwcon, lrwsvdj )
                       else
                          minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj )
                       end if
                   else
                       if ( errest ) then
                          minrwrk = max( 7, lrwqp3, lrwcon, lrwsvdj )
                       else
                          minrwrk = max( 7, lrwqp3, lrwsvdj )
                       end if
                   end if
                   if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
               else if ( rsvec .and. (.not.lsvec) ) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! singular values and the right singular vectors are requested
                  if ( errest ) then
                      minwrk = max( n+lwqp3, lwcon, lwsvdj, n+lwlqf,2*n+lwqrf, n+lwsvdj, n+&
                                lwunmlq )
                  else
                      minwrk = max( n+lwqp3, lwsvdj, n+lwlqf, 2*n+lwqrf,n+lwsvdj, n+lwunmlq )
                                
                  end if
                  if ( lquery ) then
                      call stdlib_${ci}$gesvj( 'L', 'U', 'N', n,n, u, ldu, sva, n, a,lda, cdummy, -1, &
                                rdummy, -1, ierr )
                      lwrk_wgesvj = real( cdummy(1),KIND=${ck}$)
                      call stdlib_${ci}$unmlq( 'L', 'C', n, n, n, a, lda, cdummy,v, ldv, cdummy, -1, &
                                ierr )
                      lwrk_wunmlq = real( cdummy(1),KIND=${ck}$)
                      if ( errest ) then
                      optwrk = max( n+lwrk_wgeqp3, lwcon, lwrk_wgesvj,n+lwrk_wgelqf, 2*n+&
                                lwrk_wgeqrf,n+lwrk_wgesvj,  n+lwrk_wunmlq )
                      else
                      optwrk = max( n+lwrk_wgeqp3, lwrk_wgesvj,n+lwrk_wgelqf,2*n+lwrk_wgeqrf, n+&
                                lwrk_wgesvj,n+lwrk_wunmlq )
                      end if
                  end if
                  if ( l2tran .or. rowpiv ) then
                       if ( errest ) then
                          minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj, lrwcon )
                       else
                          minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj )
                       end if
                  else
                       if ( errest ) then
                          minrwrk = max( 7, lrwqp3, lrwsvdj, lrwcon )
                       else
                          minrwrk = max( 7, lrwqp3, lrwsvdj )
                       end if
                  end if
                  if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
               else if ( lsvec .and. (.not.rsvec) ) then
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! singular values and the left singular vectors are requested
                  if ( errest ) then
                      minwrk = n + max( lwqp3,lwcon,n+lwqrf,lwsvdj,lwunmqrm )
                  else
                      minwrk = n + max( lwqp3, n+lwqrf, lwsvdj, lwunmqrm )
                  end if
                  if ( lquery ) then
                      call stdlib_${ci}$gesvj( 'L', 'U', 'N', n,n, u, ldu, sva, n, a,lda, cdummy, -1, &
                                rdummy, -1, ierr )
                      lwrk_wgesvj = real( cdummy(1),KIND=${ck}$)
                      call stdlib_${ci}$unmqr( 'L', 'N', m, n, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_wunmqrm = real( cdummy(1),KIND=${ck}$)
                      if ( errest ) then
                      optwrk = n + max( lwrk_wgeqp3, lwcon, n+lwrk_wgeqrf,lwrk_wgesvj, &
                                lwrk_wunmqrm )
                      else
                      optwrk = n + max( lwrk_wgeqp3, n+lwrk_wgeqrf,lwrk_wgesvj, lwrk_wunmqrm )
                                
                      end if
                  end if
                  if ( l2tran .or. rowpiv ) then
                      if ( errest ) then
                         minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj, lrwcon )
                      else
                         minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj )
                      end if
                  else
                      if ( errest ) then
                         minrwrk = max( 7, lrwqp3, lrwsvdj, lrwcon )
                      else
                         minrwrk = max( 7, lrwqp3, lrwsvdj )
                      end if
                  end if
                  if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
               else
                  ! Minimal And Optimal Sizes Of The Complex Workspace If The
                  ! full svd is requested
                  if ( .not. jracc ) then
                      if ( errest ) then
                         minwrk = max( n+lwqp3, n+lwcon,  2*n+n**2+lwcon,2*n+lwqrf,         2*n+&
                         lwqp3,2*n+n**2+n+lwlqf,  2*n+n**2+n+n**2+lwcon,2*n+n**2+n+lwsvdj, 2*n+&
                         n**2+n+lwsvdjv,2*n+n**2+n+lwunmqr,2*n+n**2+n+lwunmlq,n+n**2+lwsvdj,   n+&
                                   lwunmqrm )
                      else
                         minwrk = max( n+lwqp3,        2*n+n**2+lwcon,2*n+lwqrf,         2*n+&
                         lwqp3,2*n+n**2+n+lwlqf,  2*n+n**2+n+n**2+lwcon,2*n+n**2+n+lwsvdj, 2*n+&
                         n**2+n+lwsvdjv,2*n+n**2+n+lwunmqr,2*n+n**2+n+lwunmlq,n+n**2+lwsvdj,      &
                                   n+lwunmqrm )
                      end if
                      miniwrk = miniwrk + n
                      if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
                  else
                      if ( errest ) then
                         minwrk = max( n+lwqp3, n+lwcon, 2*n+lwqrf,2*n+n**2+lwsvdjv, 2*n+n**2+n+&
                                   lwunmqr,n+lwunmqrm )
                      else
                         minwrk = max( n+lwqp3, 2*n+lwqrf,2*n+n**2+lwsvdjv, 2*n+n**2+n+lwunmqr,n+&
                                   lwunmqrm )
                      end if
                      if ( rowpiv .or. l2tran ) miniwrk = miniwrk + m
                  end if
                  if ( lquery ) then
                      call stdlib_${ci}$unmqr( 'L', 'N', m, n, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_wunmqrm = real( cdummy(1),KIND=${ck}$)
                      call stdlib_${ci}$unmqr( 'L', 'N', n, n, n, a, lda, cdummy, u,ldu, cdummy, -1, &
                                ierr )
                      lwrk_wunmqr = real( cdummy(1),KIND=${ck}$)
                      if ( .not. jracc ) then
                          call stdlib_${ci}$geqp3( n,n, a, lda, iwork, cdummy,cdummy, -1,rdummy, ierr )
                                    
                          lwrk_wgeqp3n = real( cdummy(1),KIND=${ck}$)
                          call stdlib_${ci}$gesvj( 'L', 'U', 'N', n, n, u, ldu, sva,n, v, ldv, cdummy, &
                                    -1, rdummy, -1, ierr )
                          lwrk_wgesvj = real( cdummy(1),KIND=${ck}$)
                          call stdlib_${ci}$gesvj( 'U', 'U', 'N', n, n, u, ldu, sva,n, v, ldv, cdummy, &
                                    -1, rdummy, -1, ierr )
                          lwrk_wgesvju = real( cdummy(1),KIND=${ck}$)
                          call stdlib_${ci}$gesvj( 'L', 'U', 'V', n, n, u, ldu, sva,n, v, ldv, cdummy, &
                                    -1, rdummy, -1, ierr )
                          lwrk_wgesvjv = real( cdummy(1),KIND=${ck}$)
                          call stdlib_${ci}$unmlq( 'L', 'C', n, n, n, a, lda, cdummy,v, ldv, cdummy, -&
                                    1, ierr )
                          lwrk_wunmlq = real( cdummy(1),KIND=${ck}$)
                          if ( errest ) then
                            optwrk = max( n+lwrk_wgeqp3, n+lwcon,2*n+n**2+lwcon, 2*n+lwrk_wgeqrf,&
                            2*n+lwrk_wgeqp3n,2*n+n**2+n+lwrk_wgelqf,2*n+n**2+n+n**2+lwcon,2*n+&
                            n**2+n+lwrk_wgesvj,2*n+n**2+n+lwrk_wgesvjv,2*n+n**2+n+lwrk_wunmqr,2*n+&
                                      n**2+n+lwrk_wunmlq,n+n**2+lwrk_wgesvju,n+lwrk_wunmqrm )
                          else
                            optwrk = max( n+lwrk_wgeqp3,2*n+n**2+lwcon, 2*n+lwrk_wgeqrf,2*n+&
                            lwrk_wgeqp3n,2*n+n**2+n+lwrk_wgelqf,2*n+n**2+n+n**2+lwcon,2*n+n**2+n+&
                            lwrk_wgesvj,2*n+n**2+n+lwrk_wgesvjv,2*n+n**2+n+lwrk_wunmqr,2*n+n**2+n+&
                                      lwrk_wunmlq,n+n**2+lwrk_wgesvju,n+lwrk_wunmqrm )
                          end if
                      else
                          call stdlib_${ci}$gesvj( 'L', 'U', 'V', n, n, u, ldu, sva,n, v, ldv, cdummy, &
                                    -1, rdummy, -1, ierr )
                          lwrk_wgesvjv = real( cdummy(1),KIND=${ck}$)
                          call stdlib_${ci}$unmqr( 'L', 'N', n, n, n, cdummy, n, cdummy,v, ldv, cdummy,&
                                     -1, ierr )
                          lwrk_wunmqr = real( cdummy(1),KIND=${ck}$)
                          call stdlib_${ci}$unmqr( 'L', 'N', m, n, n, a, lda, cdummy, u,ldu, cdummy, -&
                                    1, ierr )
                          lwrk_wunmqrm = real( cdummy(1),KIND=${ck}$)
                          if ( errest ) then
                             optwrk = max( n+lwrk_wgeqp3, n+lwcon,2*n+lwrk_wgeqrf, 2*n+n**2,2*n+&
                                       n**2+lwrk_wgesvjv,2*n+n**2+n+lwrk_wunmqr,n+lwrk_wunmqrm )
                          else
                             optwrk = max( n+lwrk_wgeqp3, 2*n+lwrk_wgeqrf,2*n+n**2, 2*n+n**2+&
                                       lwrk_wgesvjv,2*n+n**2+n+lwrk_wunmqr,n+lwrk_wunmqrm )
                          end if
                      end if
                  end if
                  if ( l2tran .or. rowpiv ) then
                      minrwrk = max( 7, 2*m,  lrwqp3, lrwsvdj, lrwcon )
                  else
                      minrwrk = max( 7, lrwqp3, lrwsvdj, lrwcon )
                  end if
               end if
               minwrk = max( 2, minwrk )
               optwrk = max( minwrk, optwrk )
               if ( lwork  < minwrk  .and. (.not.lquery) ) info = - 17
               if ( lrwork < minrwrk .and. (.not.lquery) ) info = - 19
           end if
           if ( info /= 0 ) then
             ! #:(
              call stdlib_xerbla( 'ZGEJSV', - info )
              return
           else if ( lquery ) then
               cwork(1) = optwrk
               cwork(2) = minwrk
               rwork(1) = minrwrk
               iwork(1) = max( 4, miniwrk )
               return
           end if
           ! quick return for void matrix (y3k safe)
       ! #:)
           if ( ( m == 0 ) .or. ( n == 0 ) ) then
              iwork(1:4) = 0
              rwork(1:7) = 0
              return
           endif
           ! determine whether the matrix u should be m x n or m x m
           if ( lsvec ) then
              n1 = n
              if ( stdlib_lsame( jobu, 'F' ) ) n1 = m
           end if
           ! set numerical parameters
      ! !    note: make sure stdlib_${c2ri(ci)}$lamch() does not fail on the target architecture.
           epsln = stdlib_${c2ri(ci)}$lamch('EPSILON')
           sfmin = stdlib_${c2ri(ci)}$lamch('SAFEMINIMUM')
           small = sfmin / epsln
           big   = stdlib_${c2ri(ci)}$lamch('O')
           ! big   = one / sfmin
           ! initialize sva(1:n) = diag( ||a e_i||_2 )_1^n
      ! (!)  if necessary, scale sva() to protect the largest norm from
           ! overflow. it is possible that this scaling pushes the smallest
           ! column norm left from the underflow threshold (extreme case).
           scalem  = one / sqrt(real(m,KIND=${ck}$)*real(n,KIND=${ck}$))
           noscal  = .true.
           goscal  = .true.
           do p = 1, n
              aapp = zero
              aaqq = one
              call stdlib_${ci}$lassq( m, a(1,p), 1, aapp, aaqq )
              if ( aapp > big ) then
                 info = - 9
                 call stdlib_xerbla( 'ZGEJSV', -info )
                 return
              end if
              aaqq = sqrt(aaqq)
              if ( ( aapp < (big / aaqq) ) .and. noscal  ) then
                 sva(p)  = aapp * aaqq
              else
                 noscal  = .false.
                 sva(p)  = aapp * ( aaqq * scalem )
                 if ( goscal ) then
                    goscal = .false.
                    call stdlib_${c2ri(ci)}$scal( p-1, scalem, sva, 1 )
                 end if
              end if
           end do
           if ( noscal ) scalem = one
           aapp = zero
           aaqq = big
           do p = 1, n
              aapp = max( aapp, sva(p) )
              if ( sva(p) /= zero ) aaqq = min( aaqq, sva(p) )
           end do
           ! quick return for zero m x n matrix
       ! #:)
           if ( aapp == zero ) then
              if ( lsvec ) call stdlib_${ci}$laset( 'G', m, n1, czero, cone, u, ldu )
              if ( rsvec ) call stdlib_${ci}$laset( 'G', n, n,  czero, cone, v, ldv )
              rwork(1) = one
              rwork(2) = one
              if ( errest ) rwork(3) = one
              if ( lsvec .and. rsvec ) then
                 rwork(4) = one
                 rwork(5) = one
              end if
              if ( l2tran ) then
                 rwork(6) = zero
                 rwork(7) = zero
              end if
              iwork(1) = 0
              iwork(2) = 0
              iwork(3) = 0
              iwork(4) = -1
              return
           end if
           ! issue warning if denormalized column norms detected. override the
           ! high relative accuracy request. issue licence to kill nonzero columns
           ! (set them to zero) whose norm is less than sigma_max / big (roughly).
       ! #:(
           warning = 0
           if ( aaqq <= sfmin ) then
              l2rank = .true.
              l2kill = .true.
              warning = 1
           end if
           ! quick return for one-column matrix
       ! #:)
           if ( n == 1 ) then
              if ( lsvec ) then
                 call stdlib_${ci}$lascl( 'G',0,0,sva(1),scalem, m,1,a(1,1),lda,ierr )
                 call stdlib_${ci}$lacpy( 'A', m, 1, a, lda, u, ldu )
                 ! computing all m left singular vectors of the m x 1 matrix
                 if ( n1 /= n  ) then
                   call stdlib_${ci}$geqrf( m, n, u,ldu, cwork, cwork(n+1),lwork-n,ierr )
                   call stdlib_${ci}$ungqr( m,n1,1, u,ldu,cwork,cwork(n+1),lwork-n,ierr )
                   call stdlib_${ci}$copy( m, a(1,1), 1, u(1,1), 1 )
                 end if
              end if
              if ( rsvec ) then
                  v(1,1) = cone
              end if
              if ( sva(1) < (big*scalem) ) then
                 sva(1)  = sva(1) / scalem
                 scalem  = one
              end if
              rwork(1) = one / scalem
              rwork(2) = one
              if ( sva(1) /= zero ) then
                 iwork(1) = 1
                 if ( ( sva(1) / scalem) >= sfmin ) then
                    iwork(2) = 1
                 else
                    iwork(2) = 0
                 end if
              else
                 iwork(1) = 0
                 iwork(2) = 0
              end if
              iwork(3) = 0
              iwork(4) = -1
              if ( errest ) rwork(3) = one
              if ( lsvec .and. rsvec ) then
                 rwork(4) = one
                 rwork(5) = one
              end if
              if ( l2tran ) then
                 rwork(6) = zero
                 rwork(7) = zero
              end if
              return
           end if
           transp = .false.
           aatmax = -one
           aatmin =  big
           if ( rowpiv .or. l2tran ) then
           ! compute the row norms, needed to determine row pivoting sequence
           ! (in the case of heavily row weighted a, row pivoting is strongly
           ! advised) and to collect information needed to compare the
           ! structures of a * a^* and a^* * a (in the case l2tran==.true.).
              if ( l2tran ) then
                 do p = 1, m
                    xsc   = zero
                    temp1 = one
                    call stdlib_${ci}$lassq( n, a(p,1), lda, xsc, temp1 )
                    ! stdlib_${ci}$lassq gets both the ell_2 and the ell_infinity norm
                    ! in one pass through the vector
                    rwork(m+p)  = xsc * scalem
                    rwork(p)    = xsc * (scalem*sqrt(temp1))
                    aatmax = max( aatmax, rwork(p) )
                    if (rwork(p) /= zero)aatmin = min(aatmin,rwork(p))
                 end do
              else
                 do p = 1, m
                    rwork(m+p) = scalem*abs( a(p,stdlib_i${ci}$amax(n,a(p,1),lda)) )
                    aatmax = max( aatmax, rwork(m+p) )
                    aatmin = min( aatmin, rwork(m+p) )
                 end do
              end if
           end if
           ! for square matrix a try to determine whether a^*  would be better
           ! input for the preconditioned jacobi svd, with faster convergence.
           ! the decision is based on an o(n) function of the vector of column
           ! and row norms of a, based on the shannon entropy. this should give
           ! the right choice in most cases when the difference actually matters.
           ! it may fail and pick the slower converging side.
           entra  = zero
           entrat = zero
           if ( l2tran ) then
              xsc   = zero
              temp1 = one
              call stdlib_${c2ri(ci)}$lassq( n, sva, 1, xsc, temp1 )
              temp1 = one / temp1
              entra = zero
              do p = 1, n
                 big1  = ( ( sva(p) / xsc )**2 ) * temp1
                 if ( big1 /= zero ) entra = entra + big1 * log(big1)
              end do
              entra = - entra / log(real(n,KIND=${ck}$))
              ! now, sva().^2/trace(a^* * a) is a point in the probability simplex.
              ! it is derived from the diagonal of  a^* * a.  do the same with the
              ! diagonal of a * a^*, compute the entropy of the corresponding
              ! probability distribution. note that a * a^* and a^* * a have the
              ! same trace.
              entrat = zero
              do p = 1, m
                 big1 = ( ( rwork(p) / xsc )**2 ) * temp1
                 if ( big1 /= zero ) entrat = entrat + big1 * log(big1)
              end do
              entrat = - entrat / log(real(m,KIND=${ck}$))
              ! analyze the entropies and decide a or a^*. smaller entropy
              ! usually means better input for the algorithm.
              transp = ( entrat < entra )
              ! if a^* is better than a, take the adjoint of a. this is allowed
              ! only for square matrices, m=n.
              if ( transp ) then
                 ! in an optimal implementation, this trivial transpose
                 ! should be replaced with faster transpose.
                 do p = 1, n - 1
                    a(p,p) = conjg(a(p,p))
                    do q = p + 1, n
                        ctemp = conjg(a(q,p))
                       a(q,p) = conjg(a(p,q))
                       a(p,q) = ctemp
                    end do
                 end do
                 a(n,n) = conjg(a(n,n))
                 do p = 1, n
                    rwork(m+p) = sva(p)
                    sva(p)     = rwork(p)
                    ! previously computed row 2-norms are now column 2-norms
                    ! of the transposed matrix
                 end do
                 temp1  = aapp
                 aapp   = aatmax
                 aatmax = temp1
                 temp1  = aaqq
                 aaqq   = aatmin
                 aatmin = temp1
                 kill   = lsvec
                 lsvec  = rsvec
                 rsvec  = kill
                 if ( lsvec ) n1 = n
                 rowpiv = .true.
              end if
           end if
           ! end if l2tran
           ! scale the matrix so that its maximal singular value remains less
           ! than sqrt(big) -- the matrix is scaled so that its maximal column
           ! has euclidean norm equal to sqrt(big/n). the only reason to keep
           ! sqrt(big) instead of big is the fact that stdlib_${ci}$gejsv uses lapack and
           ! blas routines that, in some implementations, are not capable of
           ! working in the full interval [sfmin,big] and that they may provoke
           ! overflows in the intermediate results. if the singular values spread
           ! from sfmin to big, then stdlib_${ci}$gesvj will compute them. so, in that case,
           ! one should use stdlib_${ci}$gesvj instead of stdlib_${ci}$gejsv.
           ! >> change in the april 2016 update: allow bigger range, i.e. the
           ! largest column is allowed up to big/n and stdlib_${ci}$gesvj will do the rest.
           big1   = sqrt( big )
           temp1  = sqrt( big / real(n,KIND=${ck}$) )
            ! temp1  = big/real(n,KIND=${ck}$)
           call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, aapp, temp1, n, 1, sva, n, ierr )
           if ( aaqq > (aapp * sfmin) ) then
               aaqq = ( aaqq / aapp ) * temp1
           else
               aaqq = ( aaqq * temp1 ) / aapp
           end if
           temp1 = temp1 * scalem
           call stdlib_${ci}$lascl( 'G', 0, 0, aapp, temp1, m, n, a, lda, ierr )
           ! to undo scaling at the end of this procedure, multiply the
           ! computed singular values with uscal2 / uscal1.
           uscal1 = temp1
           uscal2 = aapp
           if ( l2kill ) then
              ! l2kill enforces computation of nonzero singular values in
              ! the restricted range of condition number of the initial a,
              ! sigma_max(a) / sigma_min(a) approx. sqrt(big)/sqrt(sfmin).
              xsc = sqrt( sfmin )
           else
              xsc = small
              ! now, if the condition number of a is too big,
              ! sigma_max(a) / sigma_min(a) > sqrt(big/n) * epsln / sfmin,
              ! as a precaution measure, the full svd is computed using stdlib_${ci}$gesvj
              ! with accumulated jacobi rotations. this provides numerically
              ! more robust computation, at the cost of slightly increased run
              ! time. depending on the concrete implementation of blas and lapack
              ! (i.e. how they behave in presence of extreme ill-conditioning) the
              ! implementor may decide to remove this switch.
              if ( ( aaqq<sqrt(sfmin) ) .and. lsvec .and. rsvec ) then
                 jracc = .true.
              end if
           end if
           if ( aaqq < xsc ) then
              do p = 1, n
                 if ( sva(p) < xsc ) then
                    call stdlib_${ci}$laset( 'A', m, 1, czero, czero, a(1,p), lda )
                    sva(p) = zero
                 end if
              end do
           end if
           ! preconditioning using qr factorization with pivoting
           if ( rowpiv ) then
              ! optional row permutation (bjoerck row pivoting):
              ! a result by cox and higham shows that the bjoerck's
              ! row pivoting combined with standard column pivoting
              ! has similar effect as powell-reid complete pivoting.
              ! the ell-infinity norms of a are made nonincreasing.
              if ( ( lsvec .and. rsvec ) .and. .not.( jracc ) ) then
                   iwoff = 2*n
              else
                   iwoff = n
              end if
              do p = 1, m - 1
                 q = stdlib_i${c2ri(ci)}$amax( m-p+1, rwork(m+p), 1 ) + p - 1
                 iwork(iwoff+p) = q
                 if ( p /= q ) then
                    temp1      = rwork(m+p)
                    rwork(m+p) = rwork(m+q)
                    rwork(m+q) = temp1
                 end if
              end do
              call stdlib_${ci}$laswp( n, a, lda, 1, m-1, iwork(iwoff+1), 1 )
           end if
           ! end of the preparation phase (scaling, optional sorting and
           ! transposing, optional flushing of small columns).
           ! preconditioning
           ! if the full svd is needed, the right singular vectors are computed
           ! from a matrix equation, and for that we need theoretical analysis
           ! of the businger-golub pivoting. so we use stdlib_${ci}$geqp3 as the first rr qrf.
           ! in all other cases the first rr qrf can be chosen by other criteria
           ! (eg speed by replacing global with restricted window pivoting, such
           ! as in xgeqpx from toms # 782). good results will be obtained using
           ! xgeqpx with properly (!) chosen numerical parameters.
           ! any improvement of stdlib_${ci}$geqp3 improves overall performance of stdlib_${ci}$gejsv.
           ! a * p1 = q1 * [ r1^* 0]^*:
           do p = 1, n
              ! All Columns Are Free Columns
              iwork(p) = 0
           end do
           call stdlib_${ci}$geqp3( m, n, a, lda, iwork, cwork, cwork(n+1), lwork-n,rwork, ierr )
                     
           ! the upper triangular matrix r1 from the first qrf is inspected for
           ! rank deficiency and possibilities for deflation, or possible
           ! ill-conditioning. depending on the user specified flag l2rank,
           ! the procedure explores possibilities to reduce the numerical
           ! rank by inspecting the computed upper triangular factor. if
           ! l2rank or l2aber are up, then stdlib_${ci}$gejsv will compute the svd of
           ! a + da, where ||da|| <= f(m,n)*epsln.
           nr = 1
           if ( l2aber ) then
              ! standard absolute error bound suffices. all sigma_i with
              ! sigma_i < n*epsln*||a|| are flushed to zero. this is an
              ! aggressive enforcement of lower numerical rank by introducing a
              ! backward error of the order of n*epsln*||a||.
              temp1 = sqrt(real(n,KIND=${ck}$))*epsln
              do p = 2, n
                 if ( abs(a(p,p)) >= (temp1*abs(a(1,1))) ) then
                    nr = nr + 1
                 else
                    go to 3002
                 end if
              end do
              3002 continue
           else if ( l2rank ) then
              ! .. similarly as above, only slightly more gentle (less aggressive).
              ! sudden drop on the diagonal of r1 is used as the criterion for
              ! close-to-rank-deficient.
              temp1 = sqrt(sfmin)
              do p = 2, n
                 if ( ( abs(a(p,p)) < (epsln*abs(a(p-1,p-1))) ) .or.( abs(a(p,p)) < small ) .or.( &
                           l2kill .and. (abs(a(p,p)) < temp1) ) ) go to 3402
                 nr = nr + 1
              end do
              3402 continue
           else
              ! the goal is high relative accuracy. however, if the matrix
              ! has high scaled condition number the relative accuracy is in
              ! general not feasible. later on, a condition number estimator
              ! will be deployed to estimate the scaled condition number.
              ! here we just remove the underflowed part of the triangular
              ! factor. this prevents the situation in which the code is
              ! working hard to get the accuracy not warranted by the data.
              temp1  = sqrt(sfmin)
              do p = 2, n
                 if ( ( abs(a(p,p)) < small ) .or.( l2kill .and. (abs(a(p,p)) < temp1) ) ) go to &
                           3302
                 nr = nr + 1
              end do
              3302 continue
           end if
           almort = .false.
           if ( nr == n ) then
              maxprj = one
              do p = 2, n
                 temp1  = abs(a(p,p)) / sva(iwork(p))
                 maxprj = min( maxprj, temp1 )
              end do
              if ( maxprj**2 >= one - real(n,KIND=${ck}$)*epsln ) almort = .true.
           end if
           sconda = - one
           condr1 = - one
           condr2 = - one
           if ( errest ) then
              if ( n == nr ) then
                 if ( rsvec ) then
                    ! V Is Available As Workspace
                    call stdlib_${ci}$lacpy( 'U', n, n, a, lda, v, ldv )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_${ci}$dscal( p, one/temp1, v(1,p), 1 )
                    end do
                    if ( lsvec )then
                        call stdlib_${ci}$pocon( 'U', n, v, ldv, one, temp1,cwork(n+1), rwork, ierr )
                                  
                    else
                        call stdlib_${ci}$pocon( 'U', n, v, ldv, one, temp1,cwork, rwork, ierr )
                                  
                    end if
                 else if ( lsvec ) then
                    ! U Is Available As Workspace
                    call stdlib_${ci}$lacpy( 'U', n, n, a, lda, u, ldu )
                    do p = 1, n
                       temp1 = sva(iwork(p))
                       call stdlib_${ci}$dscal( p, one/temp1, u(1,p), 1 )
                    end do
                    call stdlib_${ci}$pocon( 'U', n, u, ldu, one, temp1,cwork(n+1), rwork, ierr )
                              
                 else
                    call stdlib_${ci}$lacpy( 'U', n, n, a, lda, cwork, n )
      ! []            call stdlib_${ci}$lacpy( 'u', n, n, a, lda, cwork(n+1), n )
                    ! change: here index shifted by n to the left, cwork(1:n)
                    ! not needed for sigma only computation
                    do p = 1, n
                       temp1 = sva(iwork(p))
      ! []               call stdlib_${ci}$dscal( p, one/temp1, cwork(n+(p-1)*n+1), 1 )
                       call stdlib_${ci}$dscal( p, one/temp1, cwork((p-1)*n+1), 1 )
                    end do
                 ! The Columns Of R Are Scaled To Have Unit Euclidean Lengths
      ! []               call stdlib_${ci}$pocon( 'u', n, cwork(n+1), n, one, temp1,
      ! []     $              cwork(n+n*n+1), rwork, ierr )
                    call stdlib_${ci}$pocon( 'U', n, cwork, n, one, temp1,cwork(n*n+1), rwork, ierr )
                              
                 end if
                 if ( temp1 /= zero ) then
                    sconda = one / sqrt(temp1)
                 else
                    sconda = - one
                 end if
                 ! sconda is an estimate of sqrt(||(r^* * r)^(-1)||_1).
                 ! n^(-1/4) * sconda <= ||r^(-1)||_2 <= n^(1/4) * sconda
              else
                 sconda = - one
              end if
           end if
           l2pert = l2pert .and. ( abs( a(1,1)/a(nr,nr) ) > sqrt(big1) )
           ! if there is no violent scaling, artificial perturbation is not needed.
           ! phase 3:
           if ( .not. ( rsvec .or. lsvec ) ) then
               ! singular values only
               ! .. transpose a(1:nr,1:n)
              do p = 1, min( n-1, nr )
                 call stdlib_${ci}$copy( n-p, a(p,p+1), lda, a(p+1,p), 1 )
                 call stdlib_${ci}$lacgv( n-p+1, a(p,p), 1 )
              end do
              if ( nr == n ) a(n,n) = conjg(a(n,n))
              ! the following two do-loops introduce small relative perturbation
              ! into the strict upper triangle of the lower triangular matrix.
              ! small entries below the main diagonal are also changed.
              ! this modification is useful if the computing environment does not
              ! provide/allow flush to zero underflow, for it prevents many
              ! annoying denormalized numbers in case of strongly scaled matrices.
              ! the perturbation is structured so that it does not introduce any
              ! new perturbation of the singular values, and it does not destroy
              ! the job done by the preconditioner.
              ! the licence for this perturbation is in the variable l2pert, which
              ! should be .false. if flush to zero underflow is active.
              if ( .not. almort ) then
                 if ( l2pert ) then
                    ! xsc = sqrt(small)
                    xsc = epsln / real(n,KIND=${ck}$)
                    do q = 1, nr
                       ctemp = cmplx(xsc*abs(a(q,q)),zero,KIND=${ck}$)
                       do p = 1, n
                          if ( ( (p>q) .and. (abs(a(p,q))<=temp1) ).or. ( p < q ) )a(p,q) = &
                                    ctemp
           ! $                     a(p,q) = temp1 * ( a(p,q) / abs(a(p,q)) )
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_${ci}$laset( 'U', nr-1,nr-1, czero,czero, a(1,2),lda )
                 end if
                  ! Second Preconditioning Using The Qr Factorization
                 call stdlib_${ci}$geqrf( n,nr, a,lda, cwork, cwork(n+1),lwork-n, ierr )
                 ! And Transpose Upper To Lower Triangular
                 do p = 1, nr - 1
                    call stdlib_${ci}$copy( nr-p, a(p,p+1), lda, a(p+1,p), 1 )
                    call stdlib_${ci}$lacgv( nr-p+1, a(p,p), 1 )
                 end do
           end if
                 ! row-cyclic jacobi svd algorithm with column pivoting
                 ! .. again some perturbation (a "background noise") is added
                 ! to drown denormals
                 if ( l2pert ) then
                    ! xsc = sqrt(small)
                    xsc = epsln / real(n,KIND=${ck}$)
                    do q = 1, nr
                       ctemp = cmplx(xsc*abs(a(q,q)),zero,KIND=${ck}$)
                       do p = 1, nr
                          if ( ( (p>q) .and. (abs(a(p,q))<=temp1) ).or. ( p < q ) )a(p,q) = &
                                    ctemp
           ! $                   a(p,q) = temp1 * ( a(p,q) / abs(a(p,q)) )
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_${ci}$laset( 'U', nr-1, nr-1, czero, czero, a(1,2), lda )
                 end if
                 ! .. and one-sided jacobi rotations are started on a lower
                 ! triangular matrix (plus perturbation which is ignored in
                 ! the part which destroys triangular form (confusing?!))
                 call stdlib_${ci}$gesvj( 'L', 'N', 'N', nr, nr, a, lda, sva,n, v, ldv, cwork, lwork, &
                           rwork, lrwork, info )
                 scalem  = rwork(1)
                 numrank = nint(rwork(2),KIND=ilp)
           else if ( ( rsvec .and. ( .not. lsvec ) .and. ( .not. jracc ) ).or.( jracc .and. ( &
                     .not. lsvec ) .and. ( nr /= n ) ) ) then
              ! -> singular values and right singular vectors <-
              if ( almort ) then
                 ! In This Case Nr Equals N
                 do p = 1, nr
                    call stdlib_${ci}$copy( n-p+1, a(p,p), lda, v(p,p), 1 )
                    call stdlib_${ci}$lacgv( n-p+1, v(p,p), 1 )
                 end do
                 if (nr>1) call stdlib_${ci}$laset( 'U', nr-1,nr-1, czero, czero, v(1,2), ldv )
                 call stdlib_${ci}$gesvj( 'L','U','N', n, nr, v, ldv, sva, nr, a, lda,cwork, lwork, &
                           rwork, lrwork, info )
                 scalem  = rwork(1)
                 numrank = nint(rwork(2),KIND=ilp)
              else
              ! .. two more qr factorizations ( one qrf is not enough, two require
              ! accumulated product of jacobi rotations, three are perfect )
                 if (nr>1) call stdlib_${ci}$laset( 'L', nr-1,nr-1, czero, czero, a(2,1), lda )
                 call stdlib_${ci}$gelqf( nr,n, a, lda, cwork, cwork(n+1), lwork-n, ierr)
                 call stdlib_${ci}$lacpy( 'L', nr, nr, a, lda, v, ldv )
                 if (nr>1) call stdlib_${ci}$laset( 'U', nr-1,nr-1, czero, czero, v(1,2), ldv )
                 call stdlib_${ci}$geqrf( nr, nr, v, ldv, cwork(n+1), cwork(2*n+1),lwork-2*n, ierr )
                           
                 do p = 1, nr
                    call stdlib_${ci}$copy( nr-p+1, v(p,p), ldv, v(p,p), 1 )
                    call stdlib_${ci}$lacgv( nr-p+1, v(p,p), 1 )
                 end do
                 if (nr>1) call stdlib_${ci}$laset('U', nr-1, nr-1, czero, czero, v(1,2), ldv)
                 call stdlib_${ci}$gesvj( 'L', 'U','N', nr, nr, v,ldv, sva, nr, u,ldu, cwork(n+1), &
                           lwork-n, rwork, lrwork, info )
                 scalem  = rwork(1)
                 numrank = nint(rwork(2),KIND=ilp)
                 if ( nr < n ) then
                    call stdlib_${ci}$laset( 'A',n-nr, nr, czero,czero, v(nr+1,1),  ldv )
                    call stdlib_${ci}$laset( 'A',nr, n-nr, czero,czero, v(1,nr+1),  ldv )
                    call stdlib_${ci}$laset( 'A',n-nr,n-nr,czero,cone, v(nr+1,nr+1),ldv )
                 end if
              call stdlib_${ci}$unmlq( 'L', 'C', n, n, nr, a, lda, cwork,v, ldv, cwork(n+1), lwork-n, &
                        ierr )
              end if
               ! Permute The Rows Of V
               ! do 8991 p = 1, n
                  ! call stdlib_${ci}$copy( n, v(p,1), ldv, a(iwork(p),1), lda )
                  8991 continue
               ! call stdlib_${ci}$lacpy( 'all', n, n, a, lda, v, ldv )
              call stdlib_${ci}$lapmr( .false., n, n, v, ldv, iwork )
               if ( transp ) then
                 call stdlib_${ci}$lacpy( 'A', n, n, v, ldv, u, ldu )
               end if
           else if ( jracc .and. (.not. lsvec) .and. ( nr== n ) ) then
              if (n>1) call stdlib_${ci}$laset( 'L', n-1,n-1, czero, czero, a(2,1), lda )
              call stdlib_${ci}$gesvj( 'U','N','V', n, n, a, lda, sva, n, v, ldv,cwork, lwork, rwork, &
                        lrwork, info )
               scalem  = rwork(1)
               numrank = nint(rwork(2),KIND=ilp)
               call stdlib_${ci}$lapmr( .false., n, n, v, ldv, iwork )
           else if ( lsvec .and. ( .not. rsvec ) ) then
              ! Singular Values And Left Singular Vectors                 
              ! Second Preconditioning Step To Avoid Need To Accumulate
              ! jacobi rotations in the jacobi iterations.
              do p = 1, nr
                 call stdlib_${ci}$copy( n-p+1, a(p,p), lda, u(p,p), 1 )
                 call stdlib_${ci}$lacgv( n-p+1, u(p,p), 1 )
              end do
              if (nr>1) call stdlib_${ci}$laset( 'U', nr-1, nr-1, czero, czero, u(1,2), ldu )
              call stdlib_${ci}$geqrf( n, nr, u, ldu, cwork(n+1), cwork(2*n+1),lwork-2*n, ierr )
                        
              do p = 1, nr - 1
                 call stdlib_${ci}$copy( nr-p, u(p,p+1), ldu, u(p+1,p), 1 )
                 call stdlib_${ci}$lacgv( n-p+1, u(p,p), 1 )
              end do
              if (nr>1) call stdlib_${ci}$laset( 'U', nr-1, nr-1, czero, czero, u(1,2), ldu )
              call stdlib_${ci}$gesvj( 'L', 'U', 'N', nr,nr, u, ldu, sva, nr, a,lda, cwork(n+1), lwork-&
                        n, rwork, lrwork, info )
              scalem  = rwork(1)
              numrank = nint(rwork(2),KIND=ilp)
              if ( nr < m ) then
                 call stdlib_${ci}$laset( 'A',  m-nr, nr,czero, czero, u(nr+1,1), ldu )
                 if ( nr < n1 ) then
                    call stdlib_${ci}$laset( 'A',nr, n1-nr, czero, czero, u(1,nr+1),ldu )
                    call stdlib_${ci}$laset( 'A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1),ldu )
                 end if
              end if
              call stdlib_${ci}$unmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, cwork(n+1), lwork-n, &
                        ierr )
              if ( rowpiv )call stdlib_${ci}$laswp( n1, u, ldu, 1, m-1, iwork(iwoff+1), -1 )
              do p = 1, n1
                 xsc = one / stdlib_${c2ri(ci)}$znrm2( m, u(1,p), 1 )
                 call stdlib_${ci}$dscal( m, xsc, u(1,p), 1 )
              end do
              if ( transp ) then
                 call stdlib_${ci}$lacpy( 'A', n, n, u, ldu, v, ldv )
              end if
           else
              ! Full Svd 
              if ( .not. jracc ) then
              if ( .not. almort ) then
                 ! second preconditioning step (qrf [with pivoting])
                 ! note that the composition of transpose, qrf and transpose is
                 ! equivalent to an lqf call. since in many libraries the qrf
                 ! seems to be better optimized than the lqf, we do explicit
                 ! transpose and use the qrf. this is subject to changes in an
                 ! optimized implementation of stdlib_${ci}$gejsv.
                 do p = 1, nr
                    call stdlib_${ci}$copy( n-p+1, a(p,p), lda, v(p,p), 1 )
                    call stdlib_${ci}$lacgv( n-p+1, v(p,p), 1 )
                 end do
                 ! The Following Two Loops Perturb Small Entries To Avoid
                 ! denormals in the second qr factorization, where they are
                 ! as good as zeros. this is done to avoid painfully slow
                 ! computation with denormals. the relative size of the perturbation
                 ! is a parameter that can be changed by the implementer.
                 ! this perturbation device will be obsolete on machines with
                 ! properly implemented arithmetic.
                 ! to switch it off, set l2pert=.false. to remove it from  the
                 ! code, remove the action under l2pert=.true., leave the else part.
                 ! the following two loops should be blocked and fused with the
                 ! transposed copy above.
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do q = 1, nr
                       ctemp = cmplx(xsc*abs( v(q,q) ),zero,KIND=${ck}$)
                       do p = 1, n
                          if ( ( p > q ) .and. ( abs(v(p,q)) <= temp1 ).or. ( p < q ) )v(p,q) = &
                                    ctemp
           ! $                   v(p,q) = temp1 * ( v(p,q) / abs(v(p,q)) )
                          if ( p < q ) v(p,q) = - v(p,q)
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_${ci}$laset( 'U', nr-1, nr-1, czero, czero, v(1,2), ldv )
                 end if
                 ! estimate the row scaled condition number of r1
                 ! (if r1 is rectangular, n > nr, then the condition number
                 ! of the leading nr x nr submatrix is estimated.)
                 call stdlib_${ci}$lacpy( 'L', nr, nr, v, ldv, cwork(2*n+1), nr )
                 do p = 1, nr
                    temp1 = stdlib_${c2ri(ci)}$znrm2(nr-p+1,cwork(2*n+(p-1)*nr+p),1)
                    call stdlib_${ci}$dscal(nr-p+1,one/temp1,cwork(2*n+(p-1)*nr+p),1)
                 end do
                 call stdlib_${ci}$pocon('L',nr,cwork(2*n+1),nr,one,temp1,cwork(2*n+nr*nr+1),rwork,&
                           ierr)
                 condr1 = one / sqrt(temp1)
                 ! Here Need A Second Opinion On The Condition Number
                 ! Then Assume Worst Case Scenario
                 ! r1 is ok for inverse <=> condr1 < real(n,KIND=${ck}$)
                 ! more conservative    <=> condr1 < sqrt(real(n,KIND=${ck}$))
                 cond_ok = sqrt(sqrt(real(nr,KIND=${ck}$)))
      ! [tp]       cond_ok is a tuning parameter.
                 if ( condr1 < cond_ok ) then
                    ! .. the second qrf without pivoting. note: in an optimized
                    ! implementation, this qrf should be implemented as the qrf
                    ! of a lower triangular matrix.
                    ! r1^* = q2 * r2
                    call stdlib_${ci}$geqrf( n, nr, v, ldv, cwork(n+1), cwork(2*n+1),lwork-2*n, ierr )
                              
                    if ( l2pert ) then
                       xsc = sqrt(small)/epsln
                       do p = 2, nr
                          do q = 1, p - 1
                             ctemp=cmplx(xsc*min(abs(v(p,p)),abs(v(q,q))),zero,KIND=${ck}$)
                             if ( abs(v(q,p)) <= temp1 )v(q,p) = ctemp
           ! $                     v(q,p) = temp1 * ( v(q,p) / abs(v(q,p)) )
                          end do
                       end do
                    end if
                    if ( nr /= n )call stdlib_${ci}$lacpy( 'A', n, nr, v, ldv, cwork(2*n+1), n )
                              
                    ! .. save ...
                 ! This Transposed Copy Should Be Better Than Naive
                    do p = 1, nr - 1
                       call stdlib_${ci}$copy( nr-p, v(p,p+1), ldv, v(p+1,p), 1 )
                       call stdlib_${ci}$lacgv(nr-p+1, v(p,p), 1 )
                    end do
                    v(nr,nr)=conjg(v(nr,nr))
                    condr2 = condr1
                 else
                    ! .. ill-conditioned case: second qrf with pivoting
                    ! note that windowed pivoting would be equally good
                    ! numerically, and more run-time efficient. so, in
                    ! an optimal implementation, the next call to stdlib_${ci}$geqp3
                    ! should be replaced with eg. call zgeqpx (acm toms #782)
                    ! with properly (carefully) chosen parameters.
                    ! r1^* * p2 = q2 * r2
                    do p = 1, nr
                       iwork(n+p) = 0
                    end do
                    call stdlib_${ci}$geqp3( n, nr, v, ldv, iwork(n+1), cwork(n+1),cwork(2*n+1), lwork-&
                              2*n, rwork, ierr )
      ! *               call stdlib_${ci}$geqrf( n, nr, v, ldv, cwork(n+1), cwork(2*n+1),
      ! *     $              lwork-2*n, ierr )
                    if ( l2pert ) then
                       xsc = sqrt(small)
                       do p = 2, nr
                          do q = 1, p - 1
                             ctemp=cmplx(xsc*min(abs(v(p,p)),abs(v(q,q))),zero,KIND=${ck}$)
                             if ( abs(v(q,p)) <= temp1 )v(q,p) = ctemp
           ! $                     v(q,p) = temp1 * ( v(q,p) / abs(v(q,p)) )
                          end do
                       end do
                    end if
                    call stdlib_${ci}$lacpy( 'A', n, nr, v, ldv, cwork(2*n+1), n )
                    if ( l2pert ) then
                       xsc = sqrt(small)
                       do p = 2, nr
                          do q = 1, p - 1
                             ctemp=cmplx(xsc*min(abs(v(p,p)),abs(v(q,q))),zero,KIND=${ck}$)
                              ! v(p,q) = - temp1*( v(q,p) / abs(v(q,p)) )
                             v(p,q) = - ctemp
                          end do
                       end do
                    else
                       if (nr>1) call stdlib_${ci}$laset( 'L',nr-1,nr-1,czero,czero,v(2,1),ldv )
                    end if
                    ! now, compute r2 = l3 * q3, the lq factorization.
                    call stdlib_${ci}$gelqf( nr, nr, v, ldv, cwork(2*n+n*nr+1),cwork(2*n+n*nr+nr+1), &
                              lwork-2*n-n*nr-nr, ierr )
                    ! And Estimate The Condition Number
                    call stdlib_${ci}$lacpy( 'L',nr,nr,v,ldv,cwork(2*n+n*nr+nr+1),nr )
                    do p = 1, nr
                       temp1 = stdlib_${c2ri(ci)}$znrm2( p, cwork(2*n+n*nr+nr+p), nr )
                       call stdlib_${ci}$dscal( p, one/temp1, cwork(2*n+n*nr+nr+p), nr )
                    end do
                    call stdlib_${ci}$pocon( 'L',nr,cwork(2*n+n*nr+nr+1),nr,one,temp1,cwork(2*n+n*nr+&
                              nr+nr*nr+1),rwork,ierr )
                    condr2 = one / sqrt(temp1)
                    if ( condr2 >= cond_ok ) then
                       ! Save The Householder Vectors Used For Q3
                       ! (this overwrites the copy of r2, as it will not be
                       ! needed in this branch, but it does not overwritte the
                       ! huseholder vectors of q2.).
                       call stdlib_${ci}$lacpy( 'U', nr, nr, v, ldv, cwork(2*n+1), n )
                       ! And The Rest Of The Information On Q3 Is In
                       ! work(2*n+n*nr+1:2*n+n*nr+n)
                    end if
                 end if
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do q = 2, nr
                       ctemp = xsc * v(q,q)
                       do p = 1, q - 1
                           ! v(p,q) = - temp1*( v(p,q) / abs(v(p,q)) )
                          v(p,q) = - ctemp
                       end do
                    end do
                 else
                    if (nr>1) call stdlib_${ci}$laset( 'U', nr-1,nr-1, czero,czero, v(1,2), ldv )
                 end if
              ! second preconditioning finished; continue with jacobi svd
              ! the input matrix is lower trinagular.
              ! recover the right singular vectors as solution of a well
              ! conditioned triangular matrix equation.
                 if ( condr1 < cond_ok ) then
                    call stdlib_${ci}$gesvj( 'L','U','N',nr,nr,v,ldv,sva,nr,u, ldu,cwork(2*n+n*nr+nr+1)&
                              ,lwork-2*n-n*nr-nr,rwork,lrwork, info )
                    scalem  = rwork(1)
                    numrank = nint(rwork(2),KIND=ilp)
                    do p = 1, nr
                       call stdlib_${ci}$copy(  nr, v(1,p), 1, u(1,p), 1 )
                       call stdlib_${ci}$dscal( nr, sva(p),    v(1,p), 1 )
                    end do
              ! Pick The Right Matrix Equation And Solve It
                    if ( nr == n ) then
       ! :))             .. best case, r1 is inverted. the solution of this matrix
                       ! equation is q2*v2 = the product of the jacobi rotations
                       ! used in stdlib_${ci}$gesvj, premultiplied with the orthogonal matrix
                       ! from the second qr factorization.
                       call stdlib_${ci}$trsm('L','U','N','N', nr,nr,cone, a,lda, v,ldv)
                    else
                       ! .. r1 is well conditioned, but non-square. adjoint of r2
                       ! is inverted to get the product of the jacobi rotations
                       ! used in stdlib_${ci}$gesvj. the q-factor from the second qr
                       ! factorization is then built in explicitly.
                       call stdlib_${ci}$trsm('L','U','C','N',nr,nr,cone,cwork(2*n+1),n,v,ldv)
                       if ( nr < n ) then
                       call stdlib_${ci}$laset('A',n-nr,nr,czero,czero,v(nr+1,1),ldv)
                       call stdlib_${ci}$laset('A',nr,n-nr,czero,czero,v(1,nr+1),ldv)
                       call stdlib_${ci}$laset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                       end if
                       call stdlib_${ci}$unmqr('L','N',n,n,nr,cwork(2*n+1),n,cwork(n+1),v,ldv,cwork(&
                                 2*n+n*nr+nr+1),lwork-2*n-n*nr-nr,ierr)
                    end if
                 else if ( condr2 < cond_ok ) then
                    ! the matrix r2 is inverted. the solution of the matrix equation
                    ! is q3^* * v3 = the product of the jacobi rotations (appplied to
                    ! the lower triangular l3 from the lq factorization of
                    ! r2=l3*q3), pre-multiplied with the transposed q3.
                    call stdlib_${ci}$gesvj( 'L', 'U', 'N', nr, nr, v, ldv, sva, nr, u,ldu, cwork(2*n+&
                              n*nr+nr+1), lwork-2*n-n*nr-nr,rwork, lrwork, info )
                    scalem  = rwork(1)
                    numrank = nint(rwork(2),KIND=ilp)
                    do p = 1, nr
                       call stdlib_${ci}$copy( nr, v(1,p), 1, u(1,p), 1 )
                       call stdlib_${ci}$dscal( nr, sva(p),    u(1,p), 1 )
                    end do
                    call stdlib_${ci}$trsm('L','U','N','N',nr,nr,cone,cwork(2*n+1),n,u,ldu)
                    ! Apply The Permutation From The Second Qr Factorization
                    do q = 1, nr
                       do p = 1, nr
                          cwork(2*n+n*nr+nr+iwork(n+p)) = u(p,q)
                       end do
                       do p = 1, nr
                          u(p,q) = cwork(2*n+n*nr+nr+p)
                       end do
                    end do
                    if ( nr < n ) then
                       call stdlib_${ci}$laset( 'A',n-nr,nr,czero,czero,v(nr+1,1),ldv )
                       call stdlib_${ci}$laset( 'A',nr,n-nr,czero,czero,v(1,nr+1),ldv )
                       call stdlib_${ci}$laset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                    end if
                    call stdlib_${ci}$unmqr( 'L','N',n,n,nr,cwork(2*n+1),n,cwork(n+1),v,ldv,cwork(2*n+&
                              n*nr+nr+1),lwork-2*n-n*nr-nr,ierr )
                 else
                    ! last line of defense.
       ! #:(          this is a rather pathological case: no scaled condition
                    ! improvement after two pivoted qr factorizations. other
                    ! possibility is that the rank revealing qr factorization
                    ! or the condition estimator has failed, or the cond_ok
                    ! is set very close to one (which is unnecessary). normally,
                    ! this branch should never be executed, but in rare cases of
                    ! failure of the rrqr or condition estimator, the last line of
                    ! defense ensures that stdlib_${ci}$gejsv completes the task.
                    ! compute the full svd of l3 using stdlib_${ci}$gesvj with explicit
                    ! accumulation of jacobi rotations.
                    call stdlib_${ci}$gesvj( 'L', 'U', 'V', nr, nr, v, ldv, sva, nr, u,ldu, cwork(2*n+&
                              n*nr+nr+1), lwork-2*n-n*nr-nr,rwork, lrwork, info )
                    scalem  = rwork(1)
                    numrank = nint(rwork(2),KIND=ilp)
                    if ( nr < n ) then
                       call stdlib_${ci}$laset( 'A',n-nr,nr,czero,czero,v(nr+1,1),ldv )
                       call stdlib_${ci}$laset( 'A',nr,n-nr,czero,czero,v(1,nr+1),ldv )
                       call stdlib_${ci}$laset('A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv)
                    end if
                    call stdlib_${ci}$unmqr( 'L','N',n,n,nr,cwork(2*n+1),n,cwork(n+1),v,ldv,cwork(2*n+&
                              n*nr+nr+1),lwork-2*n-n*nr-nr,ierr )
                    call stdlib_${ci}$unmlq( 'L', 'C', nr, nr, nr, cwork(2*n+1), n,cwork(2*n+n*nr+1), &
                              u, ldu, cwork(2*n+n*nr+nr+1),lwork-2*n-n*nr-nr, ierr )
                    do q = 1, nr
                       do p = 1, nr
                          cwork(2*n+n*nr+nr+iwork(n+p)) = u(p,q)
                       end do
                       do p = 1, nr
                          u(p,q) = cwork(2*n+n*nr+nr+p)
                       end do
                    end do
                 end if
                 ! permute the rows of v using the (column) permutation from the
                 ! first qrf. also, scale the columns to make them unit in
                 ! euclidean norm. this applies to all cases.
                 temp1 = sqrt(real(n,KIND=${ck}$)) * epsln
                 do q = 1, n
                    do p = 1, n
                       cwork(2*n+n*nr+nr+iwork(p)) = v(p,q)
                    end do
                    do p = 1, n
                       v(p,q) = cwork(2*n+n*nr+nr+p)
                    end do
                    xsc = one / stdlib_${c2ri(ci)}$znrm2( n, v(1,q), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_${ci}$dscal( n, xsc,&
                               v(1,q), 1 )
                 end do
                 ! at this moment, v contains the right singular vectors of a.
                 ! next, assemble the left singular vector matrix u (m x n).
                 if ( nr < m ) then
                    call stdlib_${ci}$laset('A', m-nr, nr, czero, czero, u(nr+1,1), ldu)
                    if ( nr < n1 ) then
                       call stdlib_${ci}$laset('A',nr,n1-nr,czero,czero,u(1,nr+1),ldu)
                       call stdlib_${ci}$laset('A',m-nr,n1-nr,czero,cone,u(nr+1,nr+1),ldu)
                    end if
                 end if
                 ! the q matrix from the first qrf is built into the left singular
                 ! matrix u. this applies to all cases.
                 call stdlib_${ci}$unmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, cwork(n+1), lwork-&
                           n, ierr )
                 ! the columns of u are normalized. the cost is o(m*n) flops.
                 temp1 = sqrt(real(m,KIND=${ck}$)) * epsln
                 do p = 1, nr
                    xsc = one / stdlib_${c2ri(ci)}$znrm2( m, u(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_${ci}$dscal( m, xsc,&
                               u(1,p), 1 )
                 end do
                 ! if the initial qrf is computed with row pivoting, the left
                 ! singular vectors must be adjusted.
                 if ( rowpiv )call stdlib_${ci}$laswp( n1, u, ldu, 1, m-1, iwork(iwoff+1), -1 )
              else
              ! The Initial Matrix A Has Almost Orthogonal Columns And
              ! the second qrf is not needed
                 call stdlib_${ci}$lacpy( 'U', n, n, a, lda, cwork(n+1), n )
                 if ( l2pert ) then
                    xsc = sqrt(small)
                    do p = 2, n
                       ctemp = xsc * cwork( n + (p-1)*n + p )
                       do q = 1, p - 1
                           ! cwork(n+(q-1)*n+p)=-temp1 * ( cwork(n+(p-1)*n+q) /
           ! $                                        abs(cwork(n+(p-1)*n+q)) )
                          cwork(n+(q-1)*n+p)=-ctemp
                       end do
                    end do
                 else
                    call stdlib_${ci}$laset( 'L',n-1,n-1,czero,czero,cwork(n+2),n )
                 end if
                 call stdlib_${ci}$gesvj( 'U', 'U', 'N', n, n, cwork(n+1), n, sva,n, u, ldu, cwork(n+&
                           n*n+1), lwork-n-n*n, rwork, lrwork,info )
                 scalem  = rwork(1)
                 numrank = nint(rwork(2),KIND=ilp)
                 do p = 1, n
                    call stdlib_${ci}$copy( n, cwork(n+(p-1)*n+1), 1, u(1,p), 1 )
                    call stdlib_${ci}$dscal( n, sva(p), cwork(n+(p-1)*n+1), 1 )
                 end do
                 call stdlib_${ci}$trsm( 'L', 'U', 'N', 'N', n, n,cone, a, lda, cwork(n+1), n )
                 do p = 1, n
                    call stdlib_${ci}$copy( n, cwork(n+p), n, v(iwork(p),1), ldv )
                 end do
                 temp1 = sqrt(real(n,KIND=${ck}$))*epsln
                 do p = 1, n
                    xsc = one / stdlib_${c2ri(ci)}$znrm2( n, v(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_${ci}$dscal( n, xsc,&
                               v(1,p), 1 )
                 end do
                 ! assemble the left singular vector matrix u (m x n).
                 if ( n < m ) then
                    call stdlib_${ci}$laset( 'A',  m-n, n, czero, czero, u(n+1,1), ldu )
                    if ( n < n1 ) then
                       call stdlib_${ci}$laset('A',n,  n1-n, czero, czero,  u(1,n+1),ldu)
                       call stdlib_${ci}$laset( 'A',m-n,n1-n, czero, cone,u(n+1,n+1),ldu)
                    end if
                 end if
                 call stdlib_${ci}$unmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, cwork(n+1), lwork-&
                           n, ierr )
                 temp1 = sqrt(real(m,KIND=${ck}$))*epsln
                 do p = 1, n1
                    xsc = one / stdlib_${c2ri(ci)}$znrm2( m, u(1,p), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_${ci}$dscal( m, xsc,&
                               u(1,p), 1 )
                 end do
                 if ( rowpiv )call stdlib_${ci}$laswp( n1, u, ldu, 1, m-1, iwork(iwoff+1), -1 )
              end if
              ! end of the  >> almost orthogonal case <<  in the full svd
              else
              ! this branch deploys a preconditioned jacobi svd with explicitly
              ! accumulated rotations. it is included as optional, mainly for
              ! experimental purposes. it does perform well, and can also be used.
              ! in this implementation, this branch will be automatically activated
              ! if the  condition number sigma_max(a) / sigma_min(a) is predicted
              ! to be greater than the overflow threshold. this is because the
              ! a posteriori computation of the singular vectors assumes robust
              ! implementation of blas and some lapack procedures, capable of working
              ! in presence of extreme values, e.g. when the singular values spread from
              ! the underflow to the overflow threshold.
              do p = 1, nr
                 call stdlib_${ci}$copy( n-p+1, a(p,p), lda, v(p,p), 1 )
                 call stdlib_${ci}$lacgv( n-p+1, v(p,p), 1 )
              end do
              if ( l2pert ) then
                 xsc = sqrt(small/epsln)
                 do q = 1, nr
                    ctemp = cmplx(xsc*abs( v(q,q) ),zero,KIND=${ck}$)
                    do p = 1, n
                       if ( ( p > q ) .and. ( abs(v(p,q)) <= temp1 ).or. ( p < q ) )v(p,q) = &
                                 ctemp
           ! $                v(p,q) = temp1 * ( v(p,q) / abs(v(p,q)) )
                       if ( p < q ) v(p,q) = - v(p,q)
                    end do
                 end do
              else
                 if (nr>1) call stdlib_${ci}$laset( 'U', nr-1, nr-1, czero, czero, v(1,2), ldv )
              end if
              call stdlib_${ci}$geqrf( n, nr, v, ldv, cwork(n+1), cwork(2*n+1),lwork-2*n, ierr )
                        
              call stdlib_${ci}$lacpy( 'L', n, nr, v, ldv, cwork(2*n+1), n )
              do p = 1, nr
                 call stdlib_${ci}$copy( nr-p+1, v(p,p), ldv, u(p,p), 1 )
                 call stdlib_${ci}$lacgv( nr-p+1, u(p,p), 1 )
              end do
              if ( l2pert ) then
                 xsc = sqrt(small/epsln)
                 do q = 2, nr
                    do p = 1, q - 1
                       ctemp = cmplx(xsc * min(abs(u(p,p)),abs(u(q,q))),zero,KIND=${ck}$)
                        ! u(p,q) = - temp1 * ( u(q,p) / abs(u(q,p)) )
                       u(p,q) = - ctemp
                    end do
                 end do
              else
                 if (nr>1) call stdlib_${ci}$laset('U', nr-1, nr-1, czero, czero, u(1,2), ldu )
              end if
              call stdlib_${ci}$gesvj( 'L', 'U', 'V', nr, nr, u, ldu, sva,n, v, ldv, cwork(2*n+n*nr+1),&
                         lwork-2*n-n*nr,rwork, lrwork, info )
              scalem  = rwork(1)
              numrank = nint(rwork(2),KIND=ilp)
              if ( nr < n ) then
                 call stdlib_${ci}$laset( 'A',n-nr,nr,czero,czero,v(nr+1,1),ldv )
                 call stdlib_${ci}$laset( 'A',nr,n-nr,czero,czero,v(1,nr+1),ldv )
                 call stdlib_${ci}$laset( 'A',n-nr,n-nr,czero,cone,v(nr+1,nr+1),ldv )
              end if
              call stdlib_${ci}$unmqr( 'L','N',n,n,nr,cwork(2*n+1),n,cwork(n+1),v,ldv,cwork(2*n+n*nr+&
                        nr+1),lwork-2*n-n*nr-nr,ierr )
                 ! permute the rows of v using the (column) permutation from the
                 ! first qrf. also, scale the columns to make them unit in
                 ! euclidean norm. this applies to all cases.
                 temp1 = sqrt(real(n,KIND=${ck}$)) * epsln
                 do q = 1, n
                    do p = 1, n
                       cwork(2*n+n*nr+nr+iwork(p)) = v(p,q)
                    end do
                    do p = 1, n
                       v(p,q) = cwork(2*n+n*nr+nr+p)
                    end do
                    xsc = one / stdlib_${c2ri(ci)}$znrm2( n, v(1,q), 1 )
                    if ( (xsc < (one-temp1)) .or. (xsc > (one+temp1)) )call stdlib_${ci}$dscal( n, xsc,&
                               v(1,q), 1 )
                 end do
                 ! at this moment, v contains the right singular vectors of a.
                 ! next, assemble the left singular vector matrix u (m x n).
              if ( nr < m ) then
                 call stdlib_${ci}$laset( 'A',  m-nr, nr, czero, czero, u(nr+1,1), ldu )
                 if ( nr < n1 ) then
                    call stdlib_${ci}$laset('A',nr,  n1-nr, czero, czero,  u(1,nr+1),ldu)
                    call stdlib_${ci}$laset('A',m-nr,n1-nr, czero, cone,u(nr+1,nr+1),ldu)
                 end if
              end if
              call stdlib_${ci}$unmqr( 'L', 'N', m, n1, n, a, lda, cwork, u,ldu, cwork(n+1), lwork-n, &
                        ierr )
                 if ( rowpiv )call stdlib_${ci}$laswp( n1, u, ldu, 1, m-1, iwork(iwoff+1), -1 )
              end if
              if ( transp ) then
                 ! .. swap u and v because the procedure worked on a^*
                 do p = 1, n
                    call stdlib_${ci}$swap( n, u(1,p), 1, v(1,p), 1 )
                 end do
              end if
           end if
           ! end of the full svd
           ! undo scaling, if necessary (and possible)
           if ( uscal2 <= (big/sva(1))*uscal1 ) then
              call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, uscal1, uscal2, nr, 1, sva, n, ierr )
              uscal1 = one
              uscal2 = one
           end if
           if ( nr < n ) then
              do p = nr+1, n
                 sva(p) = zero
              end do
           end if
           rwork(1) = uscal2 * scalem
           rwork(2) = uscal1
           if ( errest ) rwork(3) = sconda
           if ( lsvec .and. rsvec ) then
              rwork(4) = condr1
              rwork(5) = condr2
           end if
           if ( l2tran ) then
              rwork(6) = entra
              rwork(7) = entrat
           end if
           iwork(1) = nr
           iwork(2) = numrank
           iwork(3) = warning
           if ( transp ) then
               iwork(4) =  1
           else
               iwork(4) = -1
           end if
           return
     end subroutine stdlib_${ci}$gejsv

#:endif
#:endfor


end submodule stdlib_lapack_eigv_svd_drivers
