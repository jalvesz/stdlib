#:include "common.fypp" 
submodule(stdlib_lapack) stdlib_lapack_lsq_constrained
  implicit none(type,external)


  contains

     pure module subroutine stdlib_sgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )
     !! SGGLSE solves the linear equality-constrained least squares (LSE)
     !! problem:
     !! minimize || c - A*x ||_2   subject to   B*x = d
     !! where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
     !! M-vector, and d is a given P-vector. It is assumed that
     !! P <= N <= M+P, and
     !! rank(B) = P and  rank( (A) ) = N.
     !! ( (B) )
     !! These conditions ensure that the LSE problem has a unique solution,
     !! which is obtained using a generalized RQ factorization of the
     !! matrices (B, A) given by
     !! B = (0 R)*Q,   A = Z*T*Q.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), c(*), d(*)
           real(sp), intent(out) :: work(*), x(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lopt, lwkmin, lwkopt, mn, nb, nb1, nb2, nb3, nb4, nr
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           mn = min( m, n )
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( p<0 .or. p>n .or. p<n-m ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldb<max( 1, p ) ) then
              info = -7
           end if
           ! calculate workspace
           if( info==0) then
              if( n==0 ) then
                 lwkmin = 1
                 lwkopt = 1
              else
                 nb1 = stdlib_ilaenv( 1, 'SGEQRF', ' ', m, n, -1, -1 )
                 nb2 = stdlib_ilaenv( 1, 'SGERQF', ' ', m, n, -1, -1 )
                 nb3 = stdlib_ilaenv( 1, 'SORMQR', ' ', m, n, p, -1 )
                 nb4 = stdlib_ilaenv( 1, 'SORMRQ', ' ', m, n, p, -1 )
                 nb = max( nb1, nb2, nb3, nb4 )
                 lwkmin = m + n + p
                 lwkopt = p + mn + max( m, n )*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGGLSE', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! compute the grq factorization of matrices b and a:
                  ! b*q**t = (  0  t12 ) p   z**t*a*q**t = ( r11 r12 ) n-p
                              ! n-p  p                     (  0  r22 ) m+p-n
                                                            ! n-p  p
           ! where t12 and r11 are upper triangular, and q and z are
           ! orthogonal.
           call stdlib_sggrqf( p, m, n, b, ldb, work, a, lda, work( p+1 ),work( p+mn+1 ), lwork-p-&
                     mn, info )
           lopt = work( p+mn+1 )
           ! update c = z**t *c = ( c1 ) n-p
                                ! ( c2 ) m+p-n
           call stdlib_sormqr( 'LEFT', 'TRANSPOSE', m, 1, mn, a, lda, work( p+1 ),c, max( 1, m ), &
                     work( p+mn+1 ), lwork-p-mn, info )
           lopt = max( lopt, int( work( p+mn+1 ),KIND=ilp) )
           ! solve t12*x2 = d for x2
           if( p>0 ) then
              call stdlib_strtrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', p, 1,b( 1, n-p+1 ), ldb, d,&
                         p, info )
              if( info>0 ) then
                 info = 1
                 return
              end if
              ! put the solution in x
              call stdlib_scopy( p, d, 1, x( n-p+1 ), 1 )
              ! update c1
              call stdlib_sgemv( 'NO TRANSPOSE', n-p, p, -one, a( 1, n-p+1 ), lda,d, 1, one, c, 1 &
                        )
           end if
           ! solve r11*x1 = c1 for x1
           if( n>p ) then
              call stdlib_strtrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n-p, 1,a, lda, c, n-p, &
                        info )
              if( info>0 ) then
                 info = 2
                 return
              end if
              ! put the solutions in x
              call stdlib_scopy( n-p, c, 1, x, 1 )
           end if
           ! compute the residual vector:
           if( m<n ) then
              nr = m + p - n
              if( nr>0 )call stdlib_sgemv( 'NO TRANSPOSE', nr, n-m, -one, a( n-p+1, m+1 ),lda, d( &
                        nr+1 ), 1, one, c( n-p+1 ), 1 )
           else
              nr = p
           end if
           if( nr>0 ) then
              call stdlib_strmv( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', nr,a( n-p+1, n-p+1 ), lda, &
                        d, 1 )
              call stdlib_saxpy( nr, -one, d, 1, c( n-p+1 ), 1 )
           end if
           ! backward transformation x = q**t*x
           call stdlib_sormrq( 'LEFT', 'TRANSPOSE', n, 1, p, b, ldb, work( 1 ), x,n, work( p+mn+1 &
                     ), lwork-p-mn, info )
           work( 1 ) = p + mn + max( lopt, int( work( p+mn+1 ),KIND=ilp) )
           return
     end subroutine stdlib_sgglse

     pure module subroutine stdlib_dgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )
     !! DGGLSE solves the linear equality-constrained least squares (LSE)
     !! problem:
     !! minimize || c - A*x ||_2   subject to   B*x = d
     !! where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
     !! M-vector, and d is a given P-vector. It is assumed that
     !! P <= N <= M+P, and
     !! rank(B) = P and  rank( (A) ) = N.
     !! ( (B) )
     !! These conditions ensure that the LSE problem has a unique solution,
     !! which is obtained using a generalized RQ factorization of the
     !! matrices (B, A) given by
     !! B = (0 R)*Q,   A = Z*T*Q.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), c(*), d(*)
           real(dp), intent(out) :: work(*), x(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lopt, lwkmin, lwkopt, mn, nb, nb1, nb2, nb3, nb4, nr
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           mn = min( m, n )
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( p<0 .or. p>n .or. p<n-m ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldb<max( 1, p ) ) then
              info = -7
           end if
           ! calculate workspace
           if( info==0) then
              if( n==0 ) then
                 lwkmin = 1
                 lwkopt = 1
              else
                 nb1 = stdlib_ilaenv( 1, 'DGEQRF', ' ', m, n, -1, -1 )
                 nb2 = stdlib_ilaenv( 1, 'DGERQF', ' ', m, n, -1, -1 )
                 nb3 = stdlib_ilaenv( 1, 'DORMQR', ' ', m, n, p, -1 )
                 nb4 = stdlib_ilaenv( 1, 'DORMRQ', ' ', m, n, p, -1 )
                 nb = max( nb1, nb2, nb3, nb4 )
                 lwkmin = m + n + p
                 lwkopt = p + mn + max( m, n )*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGLSE', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! compute the grq factorization of matrices b and a:
                  ! b*q**t = (  0  t12 ) p   z**t*a*q**t = ( r11 r12 ) n-p
                              ! n-p  p                     (  0  r22 ) m+p-n
                                                            ! n-p  p
           ! where t12 and r11 are upper triangular, and q and z are
           ! orthogonal.
           call stdlib_dggrqf( p, m, n, b, ldb, work, a, lda, work( p+1 ),work( p+mn+1 ), lwork-p-&
                     mn, info )
           lopt = work( p+mn+1 )
           ! update c = z**t *c = ( c1 ) n-p
                                ! ( c2 ) m+p-n
           call stdlib_dormqr( 'LEFT', 'TRANSPOSE', m, 1, mn, a, lda, work( p+1 ),c, max( 1, m ), &
                     work( p+mn+1 ), lwork-p-mn, info )
           lopt = max( lopt, int( work( p+mn+1 ),KIND=ilp) )
           ! solve t12*x2 = d for x2
           if( p>0 ) then
              call stdlib_dtrtrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', p, 1,b( 1, n-p+1 ), ldb, d,&
                         p, info )
              if( info>0 ) then
                 info = 1
                 return
              end if
              ! put the solution in x
              call stdlib_dcopy( p, d, 1, x( n-p+1 ), 1 )
              ! update c1
              call stdlib_dgemv( 'NO TRANSPOSE', n-p, p, -one, a( 1, n-p+1 ), lda,d, 1, one, c, 1 &
                        )
           end if
           ! solve r11*x1 = c1 for x1
           if( n>p ) then
              call stdlib_dtrtrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n-p, 1,a, lda, c, n-p, &
                        info )
              if( info>0 ) then
                 info = 2
                 return
              end if
              ! put the solutions in x
              call stdlib_dcopy( n-p, c, 1, x, 1 )
           end if
           ! compute the residual vector:
           if( m<n ) then
              nr = m + p - n
              if( nr>0 )call stdlib_dgemv( 'NO TRANSPOSE', nr, n-m, -one, a( n-p+1, m+1 ),lda, d( &
                        nr+1 ), 1, one, c( n-p+1 ), 1 )
           else
              nr = p
           end if
           if( nr>0 ) then
              call stdlib_dtrmv( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', nr,a( n-p+1, n-p+1 ), lda, &
                        d, 1 )
              call stdlib_daxpy( nr, -one, d, 1, c( n-p+1 ), 1 )
           end if
           ! backward transformation x = q**t*x
           call stdlib_dormrq( 'LEFT', 'TRANSPOSE', n, 1, p, b, ldb, work( 1 ), x,n, work( p+mn+1 &
                     ), lwork-p-mn, info )
           work( 1 ) = p + mn + max( lopt, int( work( p+mn+1 ),KIND=ilp) )
           return
     end subroutine stdlib_dgglse

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib_${ri}$gglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )
     !! DGGLSE: solves the linear equality-constrained least squares (LSE)
     !! problem:
     !! minimize || c - A*x ||_2   subject to   B*x = d
     !! where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
     !! M-vector, and d is a given P-vector. It is assumed that
     !! P <= N <= M+P, and
     !! rank(B) = P and  rank( (A) ) = N.
     !! ( (B) )
     !! These conditions ensure that the LSE problem has a unique solution,
     !! which is obtained using a generalized RQ factorization of the
     !! matrices (B, A) given by
     !! B = (0 R)*Q,   A = Z*T*Q.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), c(*), d(*)
           real(${rk}$), intent(out) :: work(*), x(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lopt, lwkmin, lwkopt, mn, nb, nb1, nb2, nb3, nb4, nr
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           mn = min( m, n )
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( p<0 .or. p>n .or. p<n-m ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldb<max( 1, p ) ) then
              info = -7
           end if
           ! calculate workspace
           if( info==0) then
              if( n==0 ) then
                 lwkmin = 1
                 lwkopt = 1
              else
                 nb1 = stdlib_ilaenv( 1, 'DGEQRF', ' ', m, n, -1, -1 )
                 nb2 = stdlib_ilaenv( 1, 'DGERQF', ' ', m, n, -1, -1 )
                 nb3 = stdlib_ilaenv( 1, 'DORMQR', ' ', m, n, p, -1 )
                 nb4 = stdlib_ilaenv( 1, 'DORMRQ', ' ', m, n, p, -1 )
                 nb = max( nb1, nb2, nb3, nb4 )
                 lwkmin = m + n + p
                 lwkopt = p + mn + max( m, n )*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGLSE', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! compute the grq factorization of matrices b and a:
                  ! b*q**t = (  0  t12 ) p   z**t*a*q**t = ( r11 r12 ) n-p
                              ! n-p  p                     (  0  r22 ) m+p-n
                                                            ! n-p  p
           ! where t12 and r11 are upper triangular, and q and z are
           ! orthogonal.
           call stdlib_${ri}$ggrqf( p, m, n, b, ldb, work, a, lda, work( p+1 ),work( p+mn+1 ), lwork-p-&
                     mn, info )
           lopt = work( p+mn+1 )
           ! update c = z**t *c = ( c1 ) n-p
                                ! ( c2 ) m+p-n
           call stdlib_${ri}$ormqr( 'LEFT', 'TRANSPOSE', m, 1, mn, a, lda, work( p+1 ),c, max( 1, m ), &
                     work( p+mn+1 ), lwork-p-mn, info )
           lopt = max( lopt, int( work( p+mn+1 ),KIND=ilp) )
           ! solve t12*x2 = d for x2
           if( p>0 ) then
              call stdlib_${ri}$trtrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', p, 1,b( 1, n-p+1 ), ldb, d,&
                         p, info )
              if( info>0 ) then
                 info = 1
                 return
              end if
              ! put the solution in x
              call stdlib_${ri}$copy( p, d, 1, x( n-p+1 ), 1 )
              ! update c1
              call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-p, p, -one, a( 1, n-p+1 ), lda,d, 1, one, c, 1 &
                        )
           end if
           ! solve r11*x1 = c1 for x1
           if( n>p ) then
              call stdlib_${ri}$trtrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n-p, 1,a, lda, c, n-p, &
                        info )
              if( info>0 ) then
                 info = 2
                 return
              end if
              ! put the solutions in x
              call stdlib_${ri}$copy( n-p, c, 1, x, 1 )
           end if
           ! compute the residual vector:
           if( m<n ) then
              nr = m + p - n
              if( nr>0 )call stdlib_${ri}$gemv( 'NO TRANSPOSE', nr, n-m, -one, a( n-p+1, m+1 ),lda, d( &
                        nr+1 ), 1, one, c( n-p+1 ), 1 )
           else
              nr = p
           end if
           if( nr>0 ) then
              call stdlib_${ri}$trmv( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', nr,a( n-p+1, n-p+1 ), lda, &
                        d, 1 )
              call stdlib_${ri}$axpy( nr, -one, d, 1, c( n-p+1 ), 1 )
           end if
           ! backward transformation x = q**t*x
           call stdlib_${ri}$ormrq( 'LEFT', 'TRANSPOSE', n, 1, p, b, ldb, work( 1 ), x,n, work( p+mn+1 &
                     ), lwork-p-mn, info )
           work( 1 ) = p + mn + max( lopt, int( work( p+mn+1 ),KIND=ilp) )
           return
     end subroutine stdlib_${ri}$gglse

#:endif
#:endfor

     pure module subroutine stdlib_cgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )
     !! CGGLSE solves the linear equality-constrained least squares (LSE)
     !! problem:
     !! minimize || c - A*x ||_2   subject to   B*x = d
     !! where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
     !! M-vector, and d is a given P-vector. It is assumed that
     !! P <= N <= M+P, and
     !! rank(B) = P and  rank( (A) ) = N.
     !! ( (B) )
     !! These conditions ensure that the LSE problem has a unique solution,
     !! which is obtained using a generalized RQ factorization of the
     !! matrices (B, A) given by
     !! B = (0 R)*Q,   A = Z*T*Q.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), c(*), d(*)
           complex(sp), intent(out) :: work(*), x(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lopt, lwkmin, lwkopt, mn, nb, nb1, nb2, nb3, nb4, nr
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           mn = min( m, n )
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( p<0 .or. p>n .or. p<n-m ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldb<max( 1, p ) ) then
              info = -7
           end if
           ! calculate workspace
           if( info==0) then
              if( n==0 ) then
                 lwkmin = 1
                 lwkopt = 1
              else
                 nb1 = stdlib_ilaenv( 1, 'CGEQRF', ' ', m, n, -1, -1 )
                 nb2 = stdlib_ilaenv( 1, 'CGERQF', ' ', m, n, -1, -1 )
                 nb3 = stdlib_ilaenv( 1, 'CUNMQR', ' ', m, n, p, -1 )
                 nb4 = stdlib_ilaenv( 1, 'CUNMRQ', ' ', m, n, p, -1 )
                 nb = max( nb1, nb2, nb3, nb4 )
                 lwkmin = m + n + p
                 lwkopt = p + mn + max( m, n )*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGLSE', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! compute the grq factorization of matrices b and a:
                  ! b*q**h = (  0  t12 ) p   z**h*a*q**h = ( r11 r12 ) n-p
                              ! n-p  p                     (  0  r22 ) m+p-n
                                                            ! n-p  p
           ! where t12 and r11 are upper triangular, and q and z are
           ! unitary.
           call stdlib_cggrqf( p, m, n, b, ldb, work, a, lda, work( p+1 ),work( p+mn+1 ), lwork-p-&
                     mn, info )
           lopt = real( work( p+mn+1 ),KIND=sp)
           ! update c = z**h *c = ( c1 ) n-p
                             ! ( c2 ) m+p-n
           call stdlib_cunmqr( 'LEFT', 'CONJUGATE TRANSPOSE', m, 1, mn, a, lda,work( p+1 ), c, &
                     max( 1, m ), work( p+mn+1 ),lwork-p-mn, info )
           lopt = max( lopt, int( work( p+mn+1 ),KIND=ilp) )
           ! solve t12*x2 = d for x2
           if( p>0 ) then
              call stdlib_ctrtrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', p, 1,b( 1, n-p+1 ), ldb, d,&
                         p, info )
              if( info>0 ) then
                 info = 1
                 return
              end if
              ! put the solution in x
           call stdlib_ccopy( p, d, 1, x( n-p+1 ), 1 )
              ! update c1
              call stdlib_cgemv( 'NO TRANSPOSE', n-p, p, -cone, a( 1, n-p+1 ), lda,d, 1, cone, c, &
                        1 )
           end if
           ! solve r11*x1 = c1 for x1
           if( n>p ) then
              call stdlib_ctrtrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n-p, 1,a, lda, c, n-p, &
                        info )
              if( info>0 ) then
                 info = 2
                 return
              end if
              ! put the solutions in x
              call stdlib_ccopy( n-p, c, 1, x, 1 )
           end if
           ! compute the residual vector:
           if( m<n ) then
              nr = m + p - n
              if( nr>0 )call stdlib_cgemv( 'NO TRANSPOSE', nr, n-m, -cone, a( n-p+1, m+1 ),lda, d(&
                         nr+1 ), 1, cone, c( n-p+1 ), 1 )
           else
              nr = p
           end if
           if( nr>0 ) then
              call stdlib_ctrmv( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', nr,a( n-p+1, n-p+1 ), lda, &
                        d, 1 )
              call stdlib_caxpy( nr, -cone, d, 1, c( n-p+1 ), 1 )
           end if
           ! backward transformation x = q**h*x
           call stdlib_cunmrq( 'LEFT', 'CONJUGATE TRANSPOSE', n, 1, p, b, ldb,work( 1 ), x, n, &
                     work( p+mn+1 ), lwork-p-mn, info )
           work( 1 ) = p + mn + max( lopt, int( work( p+mn+1 ),KIND=ilp) )
           return
     end subroutine stdlib_cgglse

     pure module subroutine stdlib_zgglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )
     !! ZGGLSE solves the linear equality-constrained least squares (LSE)
     !! problem:
     !! minimize || c - A*x ||_2   subject to   B*x = d
     !! where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
     !! M-vector, and d is a given P-vector. It is assumed that
     !! P <= N <= M+P, and
     !! rank(B) = P and  rank( (A) ) = N.
     !! ( (B) )
     !! These conditions ensure that the LSE problem has a unique solution,
     !! which is obtained using a generalized RQ factorization of the
     !! matrices (B, A) given by
     !! B = (0 R)*Q,   A = Z*T*Q.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), c(*), d(*)
           complex(dp), intent(out) :: work(*), x(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lopt, lwkmin, lwkopt, mn, nb, nb1, nb2, nb3, nb4, nr
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           mn = min( m, n )
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( p<0 .or. p>n .or. p<n-m ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldb<max( 1, p ) ) then
              info = -7
           end if
           ! calculate workspace
           if( info==0) then
              if( n==0 ) then
                 lwkmin = 1
                 lwkopt = 1
              else
                 nb1 = stdlib_ilaenv( 1, 'ZGEQRF', ' ', m, n, -1, -1 )
                 nb2 = stdlib_ilaenv( 1, 'ZGERQF', ' ', m, n, -1, -1 )
                 nb3 = stdlib_ilaenv( 1, 'ZUNMQR', ' ', m, n, p, -1 )
                 nb4 = stdlib_ilaenv( 1, 'ZUNMRQ', ' ', m, n, p, -1 )
                 nb = max( nb1, nb2, nb3, nb4 )
                 lwkmin = m + n + p
                 lwkopt = p + mn + max( m, n )*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGLSE', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! compute the grq factorization of matrices b and a:
                  ! b*q**h = (  0  t12 ) p   z**h*a*q**h = ( r11 r12 ) n-p
                              ! n-p  p                     (  0  r22 ) m+p-n
                                                            ! n-p  p
           ! where t12 and r11 are upper triangular, and q and z are
           ! unitary.
           call stdlib_zggrqf( p, m, n, b, ldb, work, a, lda, work( p+1 ),work( p+mn+1 ), lwork-p-&
                     mn, info )
           lopt = real( work( p+mn+1 ),KIND=dp)
           ! update c = z**h *c = ( c1 ) n-p
                             ! ( c2 ) m+p-n
           call stdlib_zunmqr( 'LEFT', 'CONJUGATE TRANSPOSE', m, 1, mn, a, lda,work( p+1 ), c, &
                     max( 1, m ), work( p+mn+1 ),lwork-p-mn, info )
           lopt = max( lopt, int( work( p+mn+1 ),KIND=ilp) )
           ! solve t12*x2 = d for x2
           if( p>0 ) then
              call stdlib_ztrtrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', p, 1,b( 1, n-p+1 ), ldb, d,&
                         p, info )
              if( info>0 ) then
                 info = 1
                 return
              end if
              ! put the solution in x
              call stdlib_zcopy( p, d, 1, x( n-p+1 ), 1 )
              ! update c1
              call stdlib_zgemv( 'NO TRANSPOSE', n-p, p, -cone, a( 1, n-p+1 ), lda,d, 1, cone, c, &
                        1 )
           end if
           ! solve r11*x1 = c1 for x1
           if( n>p ) then
              call stdlib_ztrtrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n-p, 1,a, lda, c, n-p, &
                        info )
              if( info>0 ) then
                 info = 2
                 return
              end if
              ! put the solutions in x
              call stdlib_zcopy( n-p, c, 1, x, 1 )
           end if
           ! compute the residual vector:
           if( m<n ) then
              nr = m + p - n
              if( nr>0 )call stdlib_zgemv( 'NO TRANSPOSE', nr, n-m, -cone, a( n-p+1, m+1 ),lda, d(&
                         nr+1 ), 1, cone, c( n-p+1 ), 1 )
           else
              nr = p
           end if
           if( nr>0 ) then
              call stdlib_ztrmv( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', nr,a( n-p+1, n-p+1 ), lda, &
                        d, 1 )
              call stdlib_zaxpy( nr, -cone, d, 1, c( n-p+1 ), 1 )
           end if
           ! backward transformation x = q**h*x
           call stdlib_zunmrq( 'LEFT', 'CONJUGATE TRANSPOSE', n, 1, p, b, ldb,work( 1 ), x, n, &
                     work( p+mn+1 ), lwork-p-mn, info )
           work( 1 ) = p + mn + max( lopt, int( work( p+mn+1 ),KIND=ilp) )
           return
     end subroutine stdlib_zgglse

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib_${ci}$gglse( m, n, p, a, lda, b, ldb, c, d, x, work, lwork,info )
     !! ZGGLSE: solves the linear equality-constrained least squares (LSE)
     !! problem:
     !! minimize || c - A*x ||_2   subject to   B*x = d
     !! where A is an M-by-N matrix, B is a P-by-N matrix, c is a given
     !! M-vector, and d is a given P-vector. It is assumed that
     !! P <= N <= M+P, and
     !! rank(B) = P and  rank( (A) ) = N.
     !! ( (B) )
     !! These conditions ensure that the LSE problem has a unique solution,
     !! which is obtained using a generalized RQ factorization of the
     !! matrices (B, A) given by
     !! B = (0 R)*Q,   A = Z*T*Q.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), c(*), d(*)
           complex(${ck}$), intent(out) :: work(*), x(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lopt, lwkmin, lwkopt, mn, nb, nb1, nb2, nb3, nb4, nr
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           mn = min( m, n )
           lquery = ( lwork==-1 )
           if( m<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( p<0 .or. p>n .or. p<n-m ) then
              info = -3
           else if( lda<max( 1, m ) ) then
              info = -5
           else if( ldb<max( 1, p ) ) then
              info = -7
           end if
           ! calculate workspace
           if( info==0) then
              if( n==0 ) then
                 lwkmin = 1
                 lwkopt = 1
              else
                 nb1 = stdlib_ilaenv( 1, 'ZGEQRF', ' ', m, n, -1, -1 )
                 nb2 = stdlib_ilaenv( 1, 'ZGERQF', ' ', m, n, -1, -1 )
                 nb3 = stdlib_ilaenv( 1, 'ZUNMQR', ' ', m, n, p, -1 )
                 nb4 = stdlib_ilaenv( 1, 'ZUNMRQ', ' ', m, n, p, -1 )
                 nb = max( nb1, nb2, nb3, nb4 )
                 lwkmin = m + n + p
                 lwkopt = p + mn + max( m, n )*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGLSE', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! compute the grq factorization of matrices b and a:
                  ! b*q**h = (  0  t12 ) p   z**h*a*q**h = ( r11 r12 ) n-p
                              ! n-p  p                     (  0  r22 ) m+p-n
                                                            ! n-p  p
           ! where t12 and r11 are upper triangular, and q and z are
           ! unitary.
           call stdlib_${ci}$ggrqf( p, m, n, b, ldb, work, a, lda, work( p+1 ),work( p+mn+1 ), lwork-p-&
                     mn, info )
           lopt = real( work( p+mn+1 ),KIND=${ck}$)
           ! update c = z**h *c = ( c1 ) n-p
                             ! ( c2 ) m+p-n
           call stdlib_${ci}$unmqr( 'LEFT', 'CONJUGATE TRANSPOSE', m, 1, mn, a, lda,work( p+1 ), c, &
                     max( 1, m ), work( p+mn+1 ),lwork-p-mn, info )
           lopt = max( lopt, int( work( p+mn+1 ),KIND=ilp) )
           ! solve t12*x2 = d for x2
           if( p>0 ) then
              call stdlib_${ci}$trtrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', p, 1,b( 1, n-p+1 ), ldb, d,&
                         p, info )
              if( info>0 ) then
                 info = 1
                 return
              end if
              ! put the solution in x
              call stdlib_${ci}$copy( p, d, 1, x( n-p+1 ), 1 )
              ! update c1
              call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-p, p, -cone, a( 1, n-p+1 ), lda,d, 1, cone, c, &
                        1 )
           end if
           ! solve r11*x1 = c1 for x1
           if( n>p ) then
              call stdlib_${ci}$trtrs( 'UPPER', 'NO TRANSPOSE', 'NON-UNIT', n-p, 1,a, lda, c, n-p, &
                        info )
              if( info>0 ) then
                 info = 2
                 return
              end if
              ! put the solutions in x
              call stdlib_${ci}$copy( n-p, c, 1, x, 1 )
           end if
           ! compute the residual vector:
           if( m<n ) then
              nr = m + p - n
              if( nr>0 )call stdlib_${ci}$gemv( 'NO TRANSPOSE', nr, n-m, -cone, a( n-p+1, m+1 ),lda, d(&
                         nr+1 ), 1, cone, c( n-p+1 ), 1 )
           else
              nr = p
           end if
           if( nr>0 ) then
              call stdlib_${ci}$trmv( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', nr,a( n-p+1, n-p+1 ), lda, &
                        d, 1 )
              call stdlib_${ci}$axpy( nr, -cone, d, 1, c( n-p+1 ), 1 )
           end if
           ! backward transformation x = q**h*x
           call stdlib_${ci}$unmrq( 'LEFT', 'CONJUGATE TRANSPOSE', n, 1, p, b, ldb,work( 1 ), x, n, &
                     work( p+mn+1 ), lwork-p-mn, info )
           work( 1 ) = p + mn + max( lopt, int( work( p+mn+1 ),KIND=ilp) )
           return
     end subroutine stdlib_${ci}$gglse

#:endif
#:endfor



     pure module subroutine stdlib_sggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )
     !! SGGGLM solves a general Gauss-Markov linear model (GLM) problem:
     !! minimize || y ||_2   subject to   d = A*x + B*y
     !! x
     !! where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
     !! given N-vector. It is assumed that M <= N <= M+P, and
     !! rank(A) = M    and    rank( A B ) = N.
     !! Under these assumptions, the constrained equation is always
     !! consistent, and there is a unique solution x and a minimal 2-norm
     !! solution y, which is obtained using a generalized QR factorization
     !! of the matrices (A, B) given by
     !! A = Q*(R),   B = Q*T*Z.
     !! (0)
     !! In particular, if matrix B is square nonsingular, then the problem
     !! GLM is equivalent to the following weighted linear least squares
     !! problem
     !! minimize || inv(B)*(d-A*x) ||_2
     !! x
     !! where inv(B) denotes the inverse of B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), d(*)
           real(sp), intent(out) :: work(*), x(*), y(*)
        ! ===================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, lopt, lwkmin, lwkopt, nb, nb1, nb2, nb3, nb4, np
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           np = min( n, p )
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( m<0 .or. m>n ) then
              info = -2
           else if( p<0 .or. p<n-m ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           ! calculate workspace
           if( info==0) then
              if( n==0 ) then
                 lwkmin = 1
                 lwkopt = 1
              else
                 nb1 = stdlib_ilaenv( 1, 'SGEQRF', ' ', n, m, -1, -1 )
                 nb2 = stdlib_ilaenv( 1, 'SGERQF', ' ', n, m, -1, -1 )
                 nb3 = stdlib_ilaenv( 1, 'SORMQR', ' ', n, m, p, -1 )
                 nb4 = stdlib_ilaenv( 1, 'SORMRQ', ' ', n, m, p, -1 )
                 nb = max( nb1, nb2, nb3, nb4 )
                 lwkmin = m + n + p
                 lwkopt = m + np + max( n, p )*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGGGLM', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              do i = 1, m
                 x(i) = zero
              end do
              do i = 1, p
                 y(i) = zero
              end do
              return
           end if
           ! compute the gqr factorization of matrices a and b:
                ! q**t*a = ( r11 ) m,    q**t*b*z**t = ( t11   t12 ) m
                         ! (  0  ) n-m                 (  0    t22 ) n-m
                            ! m                         m+p-n  n-m
           ! where r11 and t22 are upper triangular, and q and z are
           ! orthogonal.
           call stdlib_sggqrf( n, m, p, a, lda, work, b, ldb, work( m+1 ),work( m+np+1 ), lwork-m-&
                     np, info )
           lopt = work( m+np+1 )
           ! update left-hand-side vector d = q**t*d = ( d1 ) m
                                                     ! ( d2 ) n-m
           call stdlib_sormqr( 'LEFT', 'TRANSPOSE', n, 1, m, a, lda, work, d,max( 1, n ), work( m+&
                     np+1 ), lwork-m-np, info )
           lopt = max( lopt, int( work( m+np+1 ),KIND=ilp) )
           ! solve t22*y2 = d2 for y2
           if( n>m ) then
              call stdlib_strtrs( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', n-m, 1,b( m+1, m+p-n+1 ), &
                        ldb, d( m+1 ), n-m, info )
              if( info>0 ) then
                 info = 1
                 return
              end if
              call stdlib_scopy( n-m, d( m+1 ), 1, y( m+p-n+1 ), 1 )
           end if
           ! set y1 = 0
           do i = 1, m + p - n
              y( i ) = zero
           end do
           ! update d1 = d1 - t12*y2
           call stdlib_sgemv( 'NO TRANSPOSE', m, n-m, -one, b( 1, m+p-n+1 ), ldb,y( m+p-n+1 ), 1, &
                     one, d, 1 )
           ! solve triangular system: r11*x = d1
           if( m>0 ) then
              call stdlib_strtrs( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', m, 1, a, lda,d, m, info )
                        
              if( info>0 ) then
                 info = 2
                 return
              end if
              ! copy d to x
              call stdlib_scopy( m, d, 1, x, 1 )
           end if
           ! backward transformation y = z**t *y
           call stdlib_sormrq( 'LEFT', 'TRANSPOSE', p, 1, np,b( max( 1, n-p+1 ), 1 ), ldb, work( &
                     m+1 ), y,max( 1, p ), work( m+np+1 ), lwork-m-np, info )
           work( 1 ) = m + np + max( lopt, int( work( m+np+1 ),KIND=ilp) )
           return
     end subroutine stdlib_sggglm

     pure module subroutine stdlib_dggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )
     !! DGGGLM solves a general Gauss-Markov linear model (GLM) problem:
     !! minimize || y ||_2   subject to   d = A*x + B*y
     !! x
     !! where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
     !! given N-vector. It is assumed that M <= N <= M+P, and
     !! rank(A) = M    and    rank( A B ) = N.
     !! Under these assumptions, the constrained equation is always
     !! consistent, and there is a unique solution x and a minimal 2-norm
     !! solution y, which is obtained using a generalized QR factorization
     !! of the matrices (A, B) given by
     !! A = Q*(R),   B = Q*T*Z.
     !! (0)
     !! In particular, if matrix B is square nonsingular, then the problem
     !! GLM is equivalent to the following weighted linear least squares
     !! problem
     !! minimize || inv(B)*(d-A*x) ||_2
     !! x
     !! where inv(B) denotes the inverse of B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), d(*)
           real(dp), intent(out) :: work(*), x(*), y(*)
        ! ===================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, lopt, lwkmin, lwkopt, nb, nb1, nb2, nb3, nb4, np
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           np = min( n, p )
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( m<0 .or. m>n ) then
              info = -2
           else if( p<0 .or. p<n-m ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           ! calculate workspace
           if( info==0) then
              if( n==0 ) then
                 lwkmin = 1
                 lwkopt = 1
              else
                 nb1 = stdlib_ilaenv( 1, 'DGEQRF', ' ', n, m, -1, -1 )
                 nb2 = stdlib_ilaenv( 1, 'DGERQF', ' ', n, m, -1, -1 )
                 nb3 = stdlib_ilaenv( 1, 'DORMQR', ' ', n, m, p, -1 )
                 nb4 = stdlib_ilaenv( 1, 'DORMRQ', ' ', n, m, p, -1 )
                 nb = max( nb1, nb2, nb3, nb4 )
                 lwkmin = m + n + p
                 lwkopt = m + np + max( n, p )*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGGLM', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              do i = 1, m
                 x(i) = zero
              end do
              do i = 1, p
                 y(i) = zero
              end do
              return
           end if
           ! compute the gqr factorization of matrices a and b:
                ! q**t*a = ( r11 ) m,    q**t*b*z**t = ( t11   t12 ) m
                         ! (  0  ) n-m                 (  0    t22 ) n-m
                            ! m                         m+p-n  n-m
           ! where r11 and t22 are upper triangular, and q and z are
           ! orthogonal.
           call stdlib_dggqrf( n, m, p, a, lda, work, b, ldb, work( m+1 ),work( m+np+1 ), lwork-m-&
                     np, info )
           lopt = work( m+np+1 )
           ! update left-hand-side vector d = q**t*d = ( d1 ) m
                                                     ! ( d2 ) n-m
           call stdlib_dormqr( 'LEFT', 'TRANSPOSE', n, 1, m, a, lda, work, d,max( 1, n ), work( m+&
                     np+1 ), lwork-m-np, info )
           lopt = max( lopt, int( work( m+np+1 ),KIND=ilp) )
           ! solve t22*y2 = d2 for y2
           if( n>m ) then
              call stdlib_dtrtrs( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', n-m, 1,b( m+1, m+p-n+1 ), &
                        ldb, d( m+1 ), n-m, info )
              if( info>0 ) then
                 info = 1
                 return
              end if
              call stdlib_dcopy( n-m, d( m+1 ), 1, y( m+p-n+1 ), 1 )
           end if
           ! set y1 = 0
           do i = 1, m + p - n
              y( i ) = zero
           end do
           ! update d1 = d1 - t12*y2
           call stdlib_dgemv( 'NO TRANSPOSE', m, n-m, -one, b( 1, m+p-n+1 ), ldb,y( m+p-n+1 ), 1, &
                     one, d, 1 )
           ! solve triangular system: r11*x = d1
           if( m>0 ) then
              call stdlib_dtrtrs( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', m, 1, a, lda,d, m, info )
                        
              if( info>0 ) then
                 info = 2
                 return
              end if
              ! copy d to x
              call stdlib_dcopy( m, d, 1, x, 1 )
           end if
           ! backward transformation y = z**t *y
           call stdlib_dormrq( 'LEFT', 'TRANSPOSE', p, 1, np,b( max( 1, n-p+1 ), 1 ), ldb, work( &
                     m+1 ), y,max( 1, p ), work( m+np+1 ), lwork-m-np, info )
           work( 1 ) = m + np + max( lopt, int( work( m+np+1 ),KIND=ilp) )
           return
     end subroutine stdlib_dggglm

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib_${ri}$ggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )
     !! DGGGLM: solves a general Gauss-Markov linear model (GLM) problem:
     !! minimize || y ||_2   subject to   d = A*x + B*y
     !! x
     !! where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
     !! given N-vector. It is assumed that M <= N <= M+P, and
     !! rank(A) = M    and    rank( A B ) = N.
     !! Under these assumptions, the constrained equation is always
     !! consistent, and there is a unique solution x and a minimal 2-norm
     !! solution y, which is obtained using a generalized QR factorization
     !! of the matrices (A, B) given by
     !! A = Q*(R),   B = Q*T*Z.
     !! (0)
     !! In particular, if matrix B is square nonsingular, then the problem
     !! GLM is equivalent to the following weighted linear least squares
     !! problem
     !! minimize || inv(B)*(d-A*x) ||_2
     !! x
     !! where inv(B) denotes the inverse of B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), d(*)
           real(${rk}$), intent(out) :: work(*), x(*), y(*)
        ! ===================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, lopt, lwkmin, lwkopt, nb, nb1, nb2, nb3, nb4, np
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           np = min( n, p )
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( m<0 .or. m>n ) then
              info = -2
           else if( p<0 .or. p<n-m ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           ! calculate workspace
           if( info==0) then
              if( n==0 ) then
                 lwkmin = 1
                 lwkopt = 1
              else
                 nb1 = stdlib_ilaenv( 1, 'DGEQRF', ' ', n, m, -1, -1 )
                 nb2 = stdlib_ilaenv( 1, 'DGERQF', ' ', n, m, -1, -1 )
                 nb3 = stdlib_ilaenv( 1, 'DORMQR', ' ', n, m, p, -1 )
                 nb4 = stdlib_ilaenv( 1, 'DORMRQ', ' ', n, m, p, -1 )
                 nb = max( nb1, nb2, nb3, nb4 )
                 lwkmin = m + n + p
                 lwkopt = m + np + max( n, p )*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGGLM', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              do i = 1, m
                 x(i) = zero
              end do
              do i = 1, p
                 y(i) = zero
              end do
              return
           end if
           ! compute the gqr factorization of matrices a and b:
                ! q**t*a = ( r11 ) m,    q**t*b*z**t = ( t11   t12 ) m
                         ! (  0  ) n-m                 (  0    t22 ) n-m
                            ! m                         m+p-n  n-m
           ! where r11 and t22 are upper triangular, and q and z are
           ! orthogonal.
           call stdlib_${ri}$ggqrf( n, m, p, a, lda, work, b, ldb, work( m+1 ),work( m+np+1 ), lwork-m-&
                     np, info )
           lopt = work( m+np+1 )
           ! update left-hand-side vector d = q**t*d = ( d1 ) m
                                                     ! ( d2 ) n-m
           call stdlib_${ri}$ormqr( 'LEFT', 'TRANSPOSE', n, 1, m, a, lda, work, d,max( 1, n ), work( m+&
                     np+1 ), lwork-m-np, info )
           lopt = max( lopt, int( work( m+np+1 ),KIND=ilp) )
           ! solve t22*y2 = d2 for y2
           if( n>m ) then
              call stdlib_${ri}$trtrs( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', n-m, 1,b( m+1, m+p-n+1 ), &
                        ldb, d( m+1 ), n-m, info )
              if( info>0 ) then
                 info = 1
                 return
              end if
              call stdlib_${ri}$copy( n-m, d( m+1 ), 1, y( m+p-n+1 ), 1 )
           end if
           ! set y1 = 0
           do i = 1, m + p - n
              y( i ) = zero
           end do
           ! update d1 = d1 - t12*y2
           call stdlib_${ri}$gemv( 'NO TRANSPOSE', m, n-m, -one, b( 1, m+p-n+1 ), ldb,y( m+p-n+1 ), 1, &
                     one, d, 1 )
           ! solve triangular system: r11*x = d1
           if( m>0 ) then
              call stdlib_${ri}$trtrs( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', m, 1, a, lda,d, m, info )
                        
              if( info>0 ) then
                 info = 2
                 return
              end if
              ! copy d to x
              call stdlib_${ri}$copy( m, d, 1, x, 1 )
           end if
           ! backward transformation y = z**t *y
           call stdlib_${ri}$ormrq( 'LEFT', 'TRANSPOSE', p, 1, np,b( max( 1, n-p+1 ), 1 ), ldb, work( &
                     m+1 ), y,max( 1, p ), work( m+np+1 ), lwork-m-np, info )
           work( 1 ) = m + np + max( lopt, int( work( m+np+1 ),KIND=ilp) )
           return
     end subroutine stdlib_${ri}$ggglm

#:endif
#:endfor

     pure module subroutine stdlib_cggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )
     !! CGGGLM solves a general Gauss-Markov linear model (GLM) problem:
     !! minimize || y ||_2   subject to   d = A*x + B*y
     !! x
     !! where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
     !! given N-vector. It is assumed that M <= N <= M+P, and
     !! rank(A) = M    and    rank( A B ) = N.
     !! Under these assumptions, the constrained equation is always
     !! consistent, and there is a unique solution x and a minimal 2-norm
     !! solution y, which is obtained using a generalized QR factorization
     !! of the matrices (A, B) given by
     !! A = Q*(R),   B = Q*T*Z.
     !! (0)
     !! In particular, if matrix B is square nonsingular, then the problem
     !! GLM is equivalent to the following weighted linear least squares
     !! problem
     !! minimize || inv(B)*(d-A*x) ||_2
     !! x
     !! where inv(B) denotes the inverse of B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), d(*)
           complex(sp), intent(out) :: work(*), x(*), y(*)
        ! ===================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, lopt, lwkmin, lwkopt, nb, nb1, nb2, nb3, nb4, np
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           np = min( n, p )
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( m<0 .or. m>n ) then
              info = -2
           else if( p<0 .or. p<n-m ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           ! calculate workspace
           if( info==0) then
              if( n==0 ) then
                 lwkmin = 1
                 lwkopt = 1
              else
                 nb1 = stdlib_ilaenv( 1, 'CGEQRF', ' ', n, m, -1, -1 )
                 nb2 = stdlib_ilaenv( 1, 'CGERQF', ' ', n, m, -1, -1 )
                 nb3 = stdlib_ilaenv( 1, 'CUNMQR', ' ', n, m, p, -1 )
                 nb4 = stdlib_ilaenv( 1, 'CUNMRQ', ' ', n, m, p, -1 )
                 nb = max( nb1, nb2, nb3, nb4 )
                 lwkmin = m + n + p
                 lwkopt = m + np + max( n, p )*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGGLM', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              do i = 1, m
                 x(i) = czero
              end do
              do i = 1, p
                 y(i) = czero
              end do
              return
           end if
           ! compute the gqr factorization of matrices a and b:
                ! q**h*a = ( r11 ) m,    q**h*b*z**h = ( t11   t12 ) m
                         ! (  0  ) n-m                 (  0    t22 ) n-m
                            ! m                         m+p-n  n-m
           ! where r11 and t22 are upper triangular, and q and z are
           ! unitary.
           call stdlib_cggqrf( n, m, p, a, lda, work, b, ldb, work( m+1 ),work( m+np+1 ), lwork-m-&
                     np, info )
           lopt = real( work( m+np+1 ),KIND=sp)
           ! update left-hand-side vector d = q**h*d = ( d1 ) m
                                                     ! ( d2 ) n-m
           call stdlib_cunmqr( 'LEFT', 'CONJUGATE TRANSPOSE', n, 1, m, a, lda, work,d, max( 1, n )&
                     , work( m+np+1 ), lwork-m-np, info )
           lopt = max( lopt, int( work( m+np+1 ),KIND=ilp) )
           ! solve t22*y2 = d2 for y2
           if( n>m ) then
              call stdlib_ctrtrs( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', n-m, 1,b( m+1, m+p-n+1 ), &
                        ldb, d( m+1 ), n-m, info )
              if( info>0 ) then
                 info = 1
                 return
              end if
              call stdlib_ccopy( n-m, d( m+1 ), 1, y( m+p-n+1 ), 1 )
           end if
           ! set y1 = 0
           do i = 1, m + p - n
              y( i ) = czero
           end do
           ! update d1 = d1 - t12*y2
           call stdlib_cgemv( 'NO TRANSPOSE', m, n-m, -cone, b( 1, m+p-n+1 ), ldb,y( m+p-n+1 ), 1,&
                      cone, d, 1 )
           ! solve triangular system: r11*x = d1
           if( m>0 ) then
              call stdlib_ctrtrs( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', m, 1, a, lda,d, m, info )
                        
              if( info>0 ) then
                 info = 2
                 return
              end if
              ! copy d to x
              call stdlib_ccopy( m, d, 1, x, 1 )
           end if
           ! backward transformation y = z**h *y
           call stdlib_cunmrq( 'LEFT', 'CONJUGATE TRANSPOSE', p, 1, np,b( max( 1, n-p+1 ), 1 ), &
                     ldb, work( m+1 ), y,max( 1, p ), work( m+np+1 ), lwork-m-np, info )
           work( 1 ) = m + np + max( lopt, int( work( m+np+1 ),KIND=ilp) )
           return
     end subroutine stdlib_cggglm

     pure module subroutine stdlib_zggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )
     !! ZGGGLM solves a general Gauss-Markov linear model (GLM) problem:
     !! minimize || y ||_2   subject to   d = A*x + B*y
     !! x
     !! where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
     !! given N-vector. It is assumed that M <= N <= M+P, and
     !! rank(A) = M    and    rank( A B ) = N.
     !! Under these assumptions, the constrained equation is always
     !! consistent, and there is a unique solution x and a minimal 2-norm
     !! solution y, which is obtained using a generalized QR factorization
     !! of the matrices (A, B) given by
     !! A = Q*(R),   B = Q*T*Z.
     !! (0)
     !! In particular, if matrix B is square nonsingular, then the problem
     !! GLM is equivalent to the following weighted linear least squares
     !! problem
     !! minimize || inv(B)*(d-A*x) ||_2
     !! x
     !! where inv(B) denotes the inverse of B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), d(*)
           complex(dp), intent(out) :: work(*), x(*), y(*)
        ! ===================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, lopt, lwkmin, lwkopt, nb, nb1, nb2, nb3, nb4, np
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           np = min( n, p )
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( m<0 .or. m>n ) then
              info = -2
           else if( p<0 .or. p<n-m ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           ! calculate workspace
           if( info==0) then
              if( n==0 ) then
                 lwkmin = 1
                 lwkopt = 1
              else
                 nb1 = stdlib_ilaenv( 1, 'ZGEQRF', ' ', n, m, -1, -1 )
                 nb2 = stdlib_ilaenv( 1, 'ZGERQF', ' ', n, m, -1, -1 )
                 nb3 = stdlib_ilaenv( 1, 'ZUNMQR', ' ', n, m, p, -1 )
                 nb4 = stdlib_ilaenv( 1, 'ZUNMRQ', ' ', n, m, p, -1 )
                 nb = max( nb1, nb2, nb3, nb4 )
                 lwkmin = m + n + p
                 lwkopt = m + np + max( n, p )*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGGLM', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              do i = 1, m
                 x(i) = czero
              end do
              do i = 1, p
                 y(i) = czero
              end do
              return
           end if
           ! compute the gqr factorization of matrices a and b:
                ! q**h*a = ( r11 ) m,    q**h*b*z**h = ( t11   t12 ) m
                         ! (  0  ) n-m                 (  0    t22 ) n-m
                            ! m                         m+p-n  n-m
           ! where r11 and t22 are upper triangular, and q and z are
           ! unitary.
           call stdlib_zggqrf( n, m, p, a, lda, work, b, ldb, work( m+1 ),work( m+np+1 ), lwork-m-&
                     np, info )
           lopt = real( work( m+np+1 ),KIND=dp)
           ! update left-hand-side vector d = q**h*d = ( d1 ) m
                                                     ! ( d2 ) n-m
           call stdlib_zunmqr( 'LEFT', 'CONJUGATE TRANSPOSE', n, 1, m, a, lda, work,d, max( 1, n )&
                     , work( m+np+1 ), lwork-m-np, info )
           lopt = max( lopt, int( work( m+np+1 ),KIND=ilp) )
           ! solve t22*y2 = d2 for y2
           if( n>m ) then
              call stdlib_ztrtrs( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', n-m, 1,b( m+1, m+p-n+1 ), &
                        ldb, d( m+1 ), n-m, info )
              if( info>0 ) then
                 info = 1
                 return
              end if
              call stdlib_zcopy( n-m, d( m+1 ), 1, y( m+p-n+1 ), 1 )
           end if
           ! set y1 = 0
           do i = 1, m + p - n
              y( i ) = czero
           end do
           ! update d1 = d1 - t12*y2
           call stdlib_zgemv( 'NO TRANSPOSE', m, n-m, -cone, b( 1, m+p-n+1 ), ldb,y( m+p-n+1 ), 1,&
                      cone, d, 1 )
           ! solve triangular system: r11*x = d1
           if( m>0 ) then
              call stdlib_ztrtrs( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', m, 1, a, lda,d, m, info )
                        
              if( info>0 ) then
                 info = 2
                 return
              end if
              ! copy d to x
              call stdlib_zcopy( m, d, 1, x, 1 )
           end if
           ! backward transformation y = z**h *y
           call stdlib_zunmrq( 'LEFT', 'CONJUGATE TRANSPOSE', p, 1, np,b( max( 1, n-p+1 ), 1 ), &
                     ldb, work( m+1 ), y,max( 1, p ), work( m+np+1 ), lwork-m-np, info )
           work( 1 ) = m + np + max( lopt, int( work( m+np+1 ),KIND=ilp) )
           return
     end subroutine stdlib_zggglm

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib_${ci}$ggglm( n, m, p, a, lda, b, ldb, d, x, y, work, lwork,info )
     !! ZGGGLM: solves a general Gauss-Markov linear model (GLM) problem:
     !! minimize || y ||_2   subject to   d = A*x + B*y
     !! x
     !! where A is an N-by-M matrix, B is an N-by-P matrix, and d is a
     !! given N-vector. It is assumed that M <= N <= M+P, and
     !! rank(A) = M    and    rank( A B ) = N.
     !! Under these assumptions, the constrained equation is always
     !! consistent, and there is a unique solution x and a minimal 2-norm
     !! solution y, which is obtained using a generalized QR factorization
     !! of the matrices (A, B) given by
     !! A = Q*(R),   B = Q*T*Z.
     !! (0)
     !! In particular, if matrix B is square nonsingular, then the problem
     !! GLM is equivalent to the following weighted linear least squares
     !! problem
     !! minimize || inv(B)*(d-A*x) ||_2
     !! x
     !! where inv(B) denotes the inverse of B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, m, n, p
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), d(*)
           complex(${ck}$), intent(out) :: work(*), x(*), y(*)
        ! ===================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: i, lopt, lwkmin, lwkopt, nb, nb1, nb2, nb3, nb4, np
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           np = min( n, p )
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -1
           else if( m<0 .or. m>n ) then
              info = -2
           else if( p<0 .or. p<n-m ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           ! calculate workspace
           if( info==0) then
              if( n==0 ) then
                 lwkmin = 1
                 lwkopt = 1
              else
                 nb1 = stdlib_ilaenv( 1, 'ZGEQRF', ' ', n, m, -1, -1 )
                 nb2 = stdlib_ilaenv( 1, 'ZGERQF', ' ', n, m, -1, -1 )
                 nb3 = stdlib_ilaenv( 1, 'ZUNMQR', ' ', n, m, p, -1 )
                 nb4 = stdlib_ilaenv( 1, 'ZUNMRQ', ' ', n, m, p, -1 )
                 nb = max( nb1, nb2, nb3, nb4 )
                 lwkmin = m + n + p
                 lwkopt = m + np + max( n, p )*nb
              end if
              work( 1 ) = lwkopt
              if( lwork<lwkmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGGLM', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              do i = 1, m
                 x(i) = czero
              end do
              do i = 1, p
                 y(i) = czero
              end do
              return
           end if
           ! compute the gqr factorization of matrices a and b:
                ! q**h*a = ( r11 ) m,    q**h*b*z**h = ( t11   t12 ) m
                         ! (  0  ) n-m                 (  0    t22 ) n-m
                            ! m                         m+p-n  n-m
           ! where r11 and t22 are upper triangular, and q and z are
           ! unitary.
           call stdlib_${ci}$ggqrf( n, m, p, a, lda, work, b, ldb, work( m+1 ),work( m+np+1 ), lwork-m-&
                     np, info )
           lopt = real( work( m+np+1 ),KIND=${ck}$)
           ! update left-hand-side vector d = q**h*d = ( d1 ) m
                                                     ! ( d2 ) n-m
           call stdlib_${ci}$unmqr( 'LEFT', 'CONJUGATE TRANSPOSE', n, 1, m, a, lda, work,d, max( 1, n )&
                     , work( m+np+1 ), lwork-m-np, info )
           lopt = max( lopt, int( work( m+np+1 ),KIND=ilp) )
           ! solve t22*y2 = d2 for y2
           if( n>m ) then
              call stdlib_${ci}$trtrs( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', n-m, 1,b( m+1, m+p-n+1 ), &
                        ldb, d( m+1 ), n-m, info )
              if( info>0 ) then
                 info = 1
                 return
              end if
              call stdlib_${ci}$copy( n-m, d( m+1 ), 1, y( m+p-n+1 ), 1 )
           end if
           ! set y1 = 0
           do i = 1, m + p - n
              y( i ) = czero
           end do
           ! update d1 = d1 - t12*y2
           call stdlib_${ci}$gemv( 'NO TRANSPOSE', m, n-m, -cone, b( 1, m+p-n+1 ), ldb,y( m+p-n+1 ), 1,&
                      cone, d, 1 )
           ! solve triangular system: r11*x = d1
           if( m>0 ) then
              call stdlib_${ci}$trtrs( 'UPPER', 'NO TRANSPOSE', 'NON UNIT', m, 1, a, lda,d, m, info )
                        
              if( info>0 ) then
                 info = 2
                 return
              end if
              ! copy d to x
              call stdlib_${ci}$copy( m, d, 1, x, 1 )
           end if
           ! backward transformation y = z**h *y
           call stdlib_${ci}$unmrq( 'LEFT', 'CONJUGATE TRANSPOSE', p, 1, np,b( max( 1, n-p+1 ), 1 ), &
                     ldb, work( m+1 ), y,max( 1, p ), work( m+np+1 ), lwork-m-np, info )
           work( 1 ) = m + np + max( lopt, int( work( m+np+1 ),KIND=ilp) )
           return
     end subroutine stdlib_${ci}$ggglm

#:endif
#:endfor


end submodule stdlib_lapack_lsq_constrained
