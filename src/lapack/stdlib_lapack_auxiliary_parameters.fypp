#:include "common.fypp" 
submodule(stdlib_lapack_base) stdlib_lapack_auxiliary_parameters
  implicit none(type,external)


  contains

     pure real(sp) module function stdlib_slamch( cmach )
     !! SLAMCH determines single precision machine parameters.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: zero, one, eps
           ! Scalar Arguments 
           character, intent(in) :: cmach
       ! =====================================================================
           
           ! Local Scalars 
           real(sp) :: sfmin, small, rmach
           ! Intrinsic Functions 
           ! Executable Statements 
           ! assume rounding, not chopping. always.
           if( stdlib_lsame( cmach, 'E' ) ) then
              rmach = eps
           else if( stdlib_lsame( cmach, 'S' ) ) then
              sfmin = tiny(zero)
              small = one / huge(zero)
              if( small>=sfmin ) then
                 ! use small plus a bit, to avoid the possibility of rounding
                 ! causing overflow when computing  1/sfmin.
                 sfmin = small*( one+eps )
              end if
              rmach = sfmin
           else if( stdlib_lsame( cmach, 'B' ) ) then
              rmach = radix(zero)
           else if( stdlib_lsame( cmach, 'P' ) ) then
              rmach = eps * radix(zero)
           else if( stdlib_lsame( cmach, 'N' ) ) then
              rmach = digits(zero)
           else if( stdlib_lsame( cmach, 'R' ) ) then
              rmach = one
           else if( stdlib_lsame( cmach, 'M' ) ) then
              rmach = minexponent(zero)
           else if( stdlib_lsame( cmach, 'U' ) ) then
              rmach = tiny(zero)
           else if( stdlib_lsame( cmach, 'L' ) ) then
              rmach = maxexponent(zero)
           else if( stdlib_lsame( cmach, 'O' ) ) then
              rmach = huge(zero)
           else
              rmach = zero
           end if
           stdlib_slamch = rmach
           return
     end function stdlib_slamch

     pure real(dp) module function stdlib_dlamch( cmach )
     !! DLAMCH determines double precision machine parameters.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: zero, one, eps
           ! Scalar Arguments 
           character, intent(in) :: cmach
       ! =====================================================================
           
           ! Local Scalars 
           real(dp) :: sfmin, small, rmach
           ! Intrinsic Functions 
           ! Executable Statements 
           ! assume rounding, not chopping. always.
           if( stdlib_lsame( cmach, 'E' ) ) then
              rmach = eps
           else if( stdlib_lsame( cmach, 'S' ) ) then
              sfmin = tiny(zero)
              small = one / huge(zero)
              if( small>=sfmin ) then
                 ! use small plus a bit, to avoid the possibility of rounding
                 ! causing overflow when computing  1/sfmin.
                 sfmin = small*( one+eps )
              end if
              rmach = sfmin
           else if( stdlib_lsame( cmach, 'B' ) ) then
              rmach = radix(zero)
           else if( stdlib_lsame( cmach, 'P' ) ) then
              rmach = eps * radix(zero)
           else if( stdlib_lsame( cmach, 'N' ) ) then
              rmach = digits(zero)
           else if( stdlib_lsame( cmach, 'R' ) ) then
              rmach = one
           else if( stdlib_lsame( cmach, 'M' ) ) then
              rmach = minexponent(zero)
           else if( stdlib_lsame( cmach, 'U' ) ) then
              rmach = tiny(zero)
           else if( stdlib_lsame( cmach, 'L' ) ) then
              rmach = maxexponent(zero)
           else if( stdlib_lsame( cmach, 'O' ) ) then
              rmach = huge(zero)
           else
              rmach = zero
           end if
           stdlib_dlamch = rmach
           return
     end function stdlib_dlamch

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure real(${rk}$) module function stdlib_${ri}$lamch( cmach )
     !! DLAMCH: determines quad precision machine parameters.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: zero, one, eps
           ! Scalar Arguments 
           character, intent(in) :: cmach
       ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: sfmin, small, rmach
           ! Intrinsic Functions 
           ! Executable Statements 
           ! assume rounding, not chopping. always.
           if( stdlib_lsame( cmach, 'E' ) ) then
              rmach = eps
           else if( stdlib_lsame( cmach, 'S' ) ) then
              sfmin = tiny(zero)
              small = one / huge(zero)
              if( small>=sfmin ) then
                 ! use small plus a bit, to avoid the possibility of rounding
                 ! causing overflow when computing  1/sfmin.
                 sfmin = small*( one+eps )
              end if
              rmach = sfmin
           else if( stdlib_lsame( cmach, 'B' ) ) then
              rmach = radix(zero)
           else if( stdlib_lsame( cmach, 'P' ) ) then
              rmach = eps * radix(zero)
           else if( stdlib_lsame( cmach, 'N' ) ) then
              rmach = digits(zero)
           else if( stdlib_lsame( cmach, 'R' ) ) then
              rmach = one
           else if( stdlib_lsame( cmach, 'M' ) ) then
              rmach = minexponent(zero)
           else if( stdlib_lsame( cmach, 'U' ) ) then
              rmach = tiny(zero)
           else if( stdlib_lsame( cmach, 'L' ) ) then
              rmach = maxexponent(zero)
           else if( stdlib_lsame( cmach, 'O' ) ) then
              rmach = huge(zero)
           else
              rmach = zero
           end if
           stdlib_${ri}$lamch = rmach
           return
     end function stdlib_${ri}$lamch

#:endif
#:endfor







     pure real(sp) module function stdlib_slamc3( a, b )
        ! -- lapack auxiliary routine --
           ! univ. of tennessee, univ. of california berkeley and nag ltd..
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(sp), intent(in) :: a, b
       ! =====================================================================
           ! Executable Statements 
           stdlib_slamc3 = a + b
           return
     end function stdlib_slamc3

     pure real(dp) module function stdlib_dlamc3( a, b )
        ! -- lapack auxiliary routine --
           ! univ. of tennessee, univ. of california berkeley and nag ltd..
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(dp), intent(in) :: a, b
       ! =====================================================================
           ! Executable Statements 
           stdlib_dlamc3 = a + b
           return
     end function stdlib_dlamc3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure real(${rk}$) module function stdlib_${ri}$lamc3( a, b )
        ! -- lapack auxiliary routine --
           ! univ. of tennessee, univ. of california berkeley and nag ltd..
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: a, b
       ! =====================================================================
           ! Executable Statements 
           stdlib_${ri}$lamc3 = a + b
           return
     end function stdlib_${ri}$lamc3

#:endif
#:endfor







     pure module subroutine stdlib_slabad( small, large )
     !! SLABAD takes as input the values computed by SLAMCH for underflow and
     !! overflow, and returns the square root of each of these values if the
     !! log of LARGE is sufficiently large.  This subroutine is intended to
     !! identify machines with a large exponent range, such as the Crays, and
     !! redefine the underflow and overflow limits to be the square roots of
     !! the values computed by SLAMCH.  This subroutine is needed because
     !! SLAMCH does not compensate for poor arithmetic in the upper half of
     !! the exponent range, as is found on a Cray.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(sp), intent(inout) :: large, small
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! if it looks like we're on a cray, take the square root of
           ! small and large to avoid overflow and underflow problems.
           if( log10( large )>2000. ) then
              small = sqrt( small )
              large = sqrt( large )
           end if
           return
     end subroutine stdlib_slabad

     pure module subroutine stdlib_dlabad( small, large )
     !! DLABAD takes as input the values computed by DLAMCH for underflow and
     !! overflow, and returns the square root of each of these values if the
     !! log of LARGE is sufficiently large.  This subroutine is intended to
     !! identify machines with a large exponent range, such as the Crays, and
     !! redefine the underflow and overflow limits to be the square roots of
     !! the values computed by DLAMCH.  This subroutine is needed because
     !! DLAMCH does not compensate for poor arithmetic in the upper half of
     !! the exponent range, as is found on a Cray.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(dp), intent(inout) :: large, small
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! if it looks like we're on a cray, take the square root of
           ! small and large to avoid overflow and underflow problems.
           if( log10( large )>2000._dp ) then
              small = sqrt( small )
              large = sqrt( large )
           end if
           return
     end subroutine stdlib_dlabad

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib_${ri}$labad( small, large )
     !! DLABAD: takes as input the values computed by DLAMCH for underflow and
     !! overflow, and returns the square root of each of these values if the
     !! log of LARGE is sufficiently large.  This subroutine is intended to
     !! identify machines with a large exponent range, such as the Crays, and
     !! redefine the underflow and overflow limits to be the square roots of
     !! the values computed by DLAMCH.  This subroutine is needed because
     !! DLAMCH does not compensate for poor arithmetic in the upper half of
     !! the exponent range, as is found on a Cray.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(${rk}$), intent(inout) :: large, small
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! if it looks like we're on a cray, take the square root of
           ! small and large to avoid overflow and underflow problems.
           if( log10( large )>2000._${rk}$ ) then
              small = sqrt( small )
              large = sqrt( large )
           end if
           return
     end subroutine stdlib_${ri}$labad

#:endif
#:endfor





     pure real(sp) module function stdlib_scsum1( n, cx, incx )
     !! SCSUM1 takes the sum of the absolute values of a complex
     !! vector and returns a single precision result.
     !! Based on SCASUM from the Level 1 BLAS.
     !! The change is to use the 'genuine' absolute value.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx, n
           ! Array Arguments 
           complex(sp), intent(in) :: cx(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, nincx
           real(sp) :: stemp
           ! Intrinsic Functions 
           ! Executable Statements 
           stdlib_scsum1 = zero
           stemp = zero
           if( n<=0 )return
           if( incx==1 )go to 20
           ! code for increment not equal to 1
           nincx = n*incx
           do i = 1, nincx, incx
              ! next line modified.
              stemp = stemp + abs( cx( i ) )
           end do
           stdlib_scsum1 = stemp
           return
           ! code for increment equal to 1
           20 continue
           do i = 1, n
              ! next line modified.
              stemp = stemp + abs( cx( i ) )
           end do
           stdlib_scsum1 = stemp
           return
     end function stdlib_scsum1



     pure real(dp) module function stdlib_dzsum1( n, cx, incx )
     !! DZSUM1 takes the sum of the absolute values of a complex
     !! vector and returns a double precision result.
     !! Based on DZASUM from the Level 1 BLAS.
     !! The change is to use the 'genuine' absolute value.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx, n
           ! Array Arguments 
           complex(dp), intent(in) :: cx(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, nincx
           real(dp) :: stemp
           ! Intrinsic Functions 
           ! Executable Statements 
           stdlib_dzsum1 = zero
           stemp = zero
           if( n<=0 )return
           if( incx==1 )go to 20
           ! code for increment not equal to 1
           nincx = n*incx
           do i = 1, nincx, incx
              ! next line modified.
              stemp = stemp + abs( cx( i ) )
           end do
           stdlib_dzsum1 = stemp
           return
           ! code for increment equal to 1
           20 continue
           do i = 1, n
              ! next line modified.
              stemp = stemp + abs( cx( i ) )
           end do
           stdlib_dzsum1 = stemp
           return
     end function stdlib_dzsum1

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure real(${rk}$) module function stdlib_${ri}$zsum1( n, cx, incx )
     !! DZSUM1: takes the sum of the absolute values of a complex
     !! vector and returns a quad precision result.
     !! Based on DZASUM from the Level 1 BLAS.
     !! The change is to use the 'genuine' absolute value.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx, n
           ! Array Arguments 
           complex(${rk}$), intent(in) :: cx(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, nincx
           real(${rk}$) :: stemp
           ! Intrinsic Functions 
           ! Executable Statements 
           stdlib_${ri}$zsum1 = zero
           stemp = zero
           if( n<=0 )return
           if( incx==1 )go to 20
           ! code for increment not equal to 1
           nincx = n*incx
           do i = 1, nincx, incx
              ! next line modified.
              stemp = stemp + abs( cx( i ) )
           end do
           stdlib_${ri}$zsum1 = stemp
           return
           ! code for increment equal to 1
           20 continue
           do i = 1, n
              ! next line modified.
              stemp = stemp + abs( cx( i ) )
           end do
           stdlib_${ri}$zsum1 = stemp
           return
     end function stdlib_${ri}$zsum1

#:endif
#:endfor



     pure module subroutine stdlib_slaqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
     !! SLAQSB equilibrates a symmetric band matrix A using the scaling
     !! factors in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: kd, ldab, n
           real(sp), intent(in) :: amax, scond
           ! Array Arguments 
           real(sp), intent(inout) :: ab(ldab,*)
           real(sp), intent(in) :: s(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: thresh = 0.1e+0_sp
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: cj, large, small
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_slamch( 'SAFE MINIMUM' ) / stdlib_slamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored in band format.
                 do j = 1, n
                    cj = s( j )
                    do i = max( 1, j-kd ), j
                       ab( kd+1+i-j, j ) = cj*s( i )*ab( kd+1+i-j, j )
                    end do
                 end do
              else
                 ! lower triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = j, min( n, j+kd )
                       ab( 1+i-j, j ) = cj*s( i )*ab( 1+i-j, j )
                    end do
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_slaqsb

     pure module subroutine stdlib_dlaqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
     !! DLAQSB equilibrates a symmetric band matrix A using the scaling
     !! factors in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: kd, ldab, n
           real(dp), intent(in) :: amax, scond
           ! Array Arguments 
           real(dp), intent(inout) :: ab(ldab,*)
           real(dp), intent(in) :: s(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: thresh = 0.1e+0_dp
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(dp) :: cj, large, small
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_dlamch( 'SAFE MINIMUM' ) / stdlib_dlamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored in band format.
                 do j = 1, n
                    cj = s( j )
                    do i = max( 1, j-kd ), j
                       ab( kd+1+i-j, j ) = cj*s( i )*ab( kd+1+i-j, j )
                    end do
                 end do
              else
                 ! lower triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = j, min( n, j+kd )
                       ab( 1+i-j, j ) = cj*s( i )*ab( 1+i-j, j )
                    end do
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_dlaqsb

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure module subroutine stdlib_${ri}$laqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
     !! DLAQSB: equilibrates a symmetric band matrix A using the scaling
     !! factors in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: kd, ldab, n
           real(${rk}$), intent(in) :: amax, scond
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ab(ldab,*)
           real(${rk}$), intent(in) :: s(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: thresh = 0.1e+0_${rk}$
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: cj, large, small
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_${ri}$lamch( 'SAFE MINIMUM' ) / stdlib_${ri}$lamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored in band format.
                 do j = 1, n
                    cj = s( j )
                    do i = max( 1, j-kd ), j
                       ab( kd+1+i-j, j ) = cj*s( i )*ab( kd+1+i-j, j )
                    end do
                 end do
              else
                 ! lower triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = j, min( n, j+kd )
                       ab( 1+i-j, j ) = cj*s( i )*ab( 1+i-j, j )
                    end do
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_${ri}$laqsb

#:endif
#:endfor

     pure module subroutine stdlib_claqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
     !! CLAQSB equilibrates a symmetric band matrix A using the scaling
     !! factors in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: kd, ldab, n
           real(sp), intent(in) :: amax, scond
           ! Array Arguments 
           real(sp), intent(in) :: s(*)
           complex(sp), intent(inout) :: ab(ldab,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: thresh = 0.1e+0_sp
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: cj, large, small
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_slamch( 'SAFE MINIMUM' ) / stdlib_slamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored in band format.
                 do j = 1, n
                    cj = s( j )
                    do i = max( 1, j-kd ), j
                       ab( kd+1+i-j, j ) = cj*s( i )*ab( kd+1+i-j, j )
                    end do
                 end do
              else
                 ! lower triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = j, min( n, j+kd )
                       ab( 1+i-j, j ) = cj*s( i )*ab( 1+i-j, j )
                    end do
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_claqsb

     pure module subroutine stdlib_zlaqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
     !! ZLAQSB equilibrates a symmetric band matrix A using the scaling
     !! factors in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: kd, ldab, n
           real(dp), intent(in) :: amax, scond
           ! Array Arguments 
           real(dp), intent(in) :: s(*)
           complex(dp), intent(inout) :: ab(ldab,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: thresh = 0.1e+0_dp
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(dp) :: cj, large, small
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_dlamch( 'SAFE MINIMUM' ) / stdlib_dlamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored in band format.
                 do j = 1, n
                    cj = s( j )
                    do i = max( 1, j-kd ), j
                       ab( kd+1+i-j, j ) = cj*s( i )*ab( kd+1+i-j, j )
                    end do
                 end do
              else
                 ! lower triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = j, min( n, j+kd )
                       ab( 1+i-j, j ) = cj*s( i )*ab( 1+i-j, j )
                    end do
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_zlaqsb

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure module subroutine stdlib_${ci}$laqsb( uplo, n, kd, ab, ldab, s, scond, amax, equed )
     !! ZLAQSB: equilibrates a symmetric band matrix A using the scaling
     !! factors in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: kd, ldab, n
           real(${ck}$), intent(in) :: amax, scond
           ! Array Arguments 
           real(${ck}$), intent(in) :: s(*)
           complex(${ck}$), intent(inout) :: ab(ldab,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: thresh = 0.1e+0_${ck}$
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${ck}$) :: cj, large, small
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' ) / stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored in band format.
                 do j = 1, n
                    cj = s( j )
                    do i = max( 1, j-kd ), j
                       ab( kd+1+i-j, j ) = cj*s( i )*ab( kd+1+i-j, j )
                    end do
                 end do
              else
                 ! lower triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = j, min( n, j+kd )
                       ab( 1+i-j, j ) = cj*s( i )*ab( 1+i-j, j )
                    end do
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_${ci}$laqsb

#:endif
#:endfor


end submodule stdlib_lapack_auxiliary_parameters
