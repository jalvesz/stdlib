#:include "common.fypp" 
submodule(stdlib_lapack) stdlib_lapack_solve_ldl_comp
  implicit none(type,external)


  contains

     module pure subroutine stdlib_slasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
     !! SLASYF_RK computes a partial factorization of a real symmetric
     !! matrix A using the bounded Bunch-Kaufman (rook) diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L',
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! SLASYF_RK is an auxiliary routine called by SSYTRF_RK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: e(*), w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, j, jb, jj, jmax, k, kk, kw, kkw, kp, kstep, p, ii
           real(sp) :: absakk, alpha, colmax, d11, d12, d21, d22, stemp, r1, rowmax, t, &
                     sfmin
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = zero
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              call stdlib_scopy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_sgemv( 'NO TRANSPOSE', k, n-k, -one, a( 1, k+1 ),lda, w( k, kw+&
                        1 ), ldw, one, w( 1, kw ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_isamax( k-1, w( 1, kw ), 1 )
                 colmax = abs( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_scopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = zero
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       call stdlib_scopy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                       call stdlib_scopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       if( k<n )call stdlib_sgemv( 'NO TRANSPOSE', k, n-k, -one,a( 1, k+1 ), lda, &
                                 w( imax, kw+1 ), ldw,one, w( 1, kw-1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_isamax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = abs( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_isamax( imax-1, w( 1, kw-1 ), 1 )
                          stemp = abs( w( itemp, kw-1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! abs( w( imax, kw-1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.(abs( w( imax, kw-1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_scopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_scopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! ============================================================
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_scopy( k-p, a( p+1, k ), 1, a( p, p+1 ), lda )
                    call stdlib_scopy( p, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in last n-k+1 columns of a
                    ! and last n-k+2 columns of w
                    call stdlib_sswap( n-k+1, a( k, k ), lda, a( p, k ), lda )
                    call stdlib_sswap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ), ldw )
                 end if
                 ! updated column kp is already stored in column kkw of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_scopy( k-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_scopy( kp, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last n-kk+1 columns
                    ! of a and w
                    call stdlib_sswap( n-kk+1, a( kk, kk ), lda, a( kp, kk ), lda )
                    call stdlib_sswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! store u(k) in column k of a
                    call stdlib_scopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       if( abs( a( k, k ) )>=sfmin ) then
                          r1 = one / a( k, k )
                          call stdlib_sscal( k-1, r1, a( 1, k ), 1 )
                       else if( a( k, k )/=zero ) then
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = zero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now
                    ! hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    if( k>2 ) then
                       ! store u(k) and u(k-1) in columns k and k-1 of a
                       d12 = w( k-1, kw )
                       d11 = w( k, kw ) / d12
                       d22 = w( k-1, kw-1 ) / d12
                       t = one / ( d11*d22-one )
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( (d11*w( j, kw-1 )-w( j, kw ) ) /d12 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /d12 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy superdiagonal element of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = zero
                    a( k, k ) = w( k, kw )
                    e( k ) = w( k-1, kw )
                    e( k-1 ) = zero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_sgemv( 'NO TRANSPOSE', jj-j+1, n-k, -one,a( j, k+1 ), lda, w( jj, &
                              kw+1 ), ldw, one,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_sgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb,n-k, -one, a( &
                           1, k+1 ), lda, w( j, kw+1 ),ldw, one, a( 1, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = zero
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update it
              call stdlib_scopy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              if( k>1 )call stdlib_sgemv( 'NO TRANSPOSE', n-k+1, k-1, -one, a( k, 1 ),lda, w( k, &
                        1 ), ldw, one, w( k, k ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_isamax( n-k, w( k+1, k ), 1 )
                 colmax = abs( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_scopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                 ! set e( k ) to zero
                 if( k<n )e( k ) = zero
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_scopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_scopy( n-imax+1, a( imax, imax ), 1,w( imax, k+1 ), 1 )
                       if( k>1 )call stdlib_sgemv( 'NO TRANSPOSE', n-k+1, k-1, -one,a( k, 1 ), &
                                 lda, w( imax, 1 ), ldw,one, w( k, k+1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_isamax( imax-k, w( k, k+1 ), 1 )
                          rowmax = abs( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_isamax( n-imax, w( imax+1, k+1 ), 1)
                          stemp = abs( w( itemp, k+1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! abs( w( imax, k+1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( w( imax, k+1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_scopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_scopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 72
                 end if
                 ! ============================================================
                 kk = k + kstep - 1
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_scopy( p-k, a( k, k ), 1, a( p, k ), lda )
                    call stdlib_scopy( n-p+1, a( p, k ), 1, a( p, p ), 1 )
                    ! interchange rows k and p in first k columns of a
                    ! and first k+1 columns of w
                    call stdlib_sswap( k, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_sswap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! updated column kp is already stored in column kk of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_scopy( kp-k-1, a( k+1, kk ), 1, a( kp, k+1 ), lda )
                    call stdlib_scopy( n-kp+1, a( kp, kk ), 1, a( kp, kp ), 1 )
                    ! interchange rows kk and kp in first kk columns of a and w
                    call stdlib_sswap( kk, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_sswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    ! store l(k) in column k of a
                    call stdlib_scopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       if( abs( a( k, k ) )>=sfmin ) then
                          r1 = one / a( k, k )
                          call stdlib_sscal( n-k, r1, a( k+1, k ), 1 )
                       else if( a( k, k )/=zero ) then
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = zero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! store l(k) and l(k+1) in columns k and k+1 of a
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = one / ( d11*d22-one )
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /d21 )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy subdiagonal element of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = zero
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    e( k ) = w( k+1, k )
                    e( k+1 ) = zero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_sgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -one,a( jj, 1 ), lda, w( jj, &
                              1 ), ldw, one,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_sgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           one, a( j+jb, 1 ), lda, w( j, 1 ),ldw, one, a( j+jb, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_slasyf_rk

     module pure subroutine stdlib_dlasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
     !! DLASYF_RK computes a partial factorization of a real symmetric
     !! matrix A using the bounded Bunch-Kaufman (rook) diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L',
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! DLASYF_RK is an auxiliary routine called by DSYTRF_RK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: e(*), w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, j, jb, jj, jmax, k, kk, kw, kkw, kp, kstep, p, ii
           real(dp) :: absakk, alpha, colmax, d11, d12, d21, d22, dtemp, r1, rowmax, t, &
                     sfmin
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_dlamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = zero
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              call stdlib_dcopy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_dgemv( 'NO TRANSPOSE', k, n-k, -one, a( 1, k+1 ),lda, w( k, kw+&
                        1 ), ldw, one, w( 1, kw ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_idamax( k-1, w( 1, kw ), 1 )
                 colmax = abs( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_dcopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = zero
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       call stdlib_dcopy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                       call stdlib_dcopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       if( k<n )call stdlib_dgemv( 'NO TRANSPOSE', k, n-k, -one,a( 1, k+1 ), lda, &
                                 w( imax, kw+1 ), ldw,one, w( 1, kw-1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_idamax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = abs( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_idamax( imax-1, w( 1, kw-1 ), 1 )
                          dtemp = abs( w( itemp, kw-1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! abs( w( imax, kw-1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.(abs( w( imax, kw-1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_dcopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_dcopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! ============================================================
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_dcopy( k-p, a( p+1, k ), 1, a( p, p+1 ), lda )
                    call stdlib_dcopy( p, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in last n-k+1 columns of a
                    ! and last n-k+2 columns of w
                    call stdlib_dswap( n-k+1, a( k, k ), lda, a( p, k ), lda )
                    call stdlib_dswap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ), ldw )
                 end if
                 ! updated column kp is already stored in column kkw of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_dcopy( k-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_dcopy( kp, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last n-kk+1 columns
                    ! of a and w
                    call stdlib_dswap( n-kk+1, a( kk, kk ), lda, a( kp, kk ), lda )
                    call stdlib_dswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! store u(k) in column k of a
                    call stdlib_dcopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       if( abs( a( k, k ) )>=sfmin ) then
                          r1 = one / a( k, k )
                          call stdlib_dscal( k-1, r1, a( 1, k ), 1 )
                       else if( a( k, k )/=zero ) then
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = zero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now
                    ! hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    if( k>2 ) then
                       ! store u(k) and u(k-1) in columns k and k-1 of a
                       d12 = w( k-1, kw )
                       d11 = w( k, kw ) / d12
                       d22 = w( k-1, kw-1 ) / d12
                       t = one / ( d11*d22-one )
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( (d11*w( j, kw-1 )-w( j, kw ) ) /d12 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /d12 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy superdiagonal element of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = zero
                    a( k, k ) = w( k, kw )
                    e( k ) = w( k-1, kw )
                    e( k-1 ) = zero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_dgemv( 'NO TRANSPOSE', jj-j+1, n-k, -one,a( j, k+1 ), lda, w( jj, &
                              kw+1 ), ldw, one,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_dgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb,n-k, -one, a( &
                           1, k+1 ), lda, w( j, kw+1 ),ldw, one, a( 1, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = zero
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update it
              call stdlib_dcopy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              if( k>1 )call stdlib_dgemv( 'NO TRANSPOSE', n-k+1, k-1, -one, a( k, 1 ),lda, w( k, &
                        1 ), ldw, one, w( k, k ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_idamax( n-k, w( k+1, k ), 1 )
                 colmax = abs( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_dcopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                 ! set e( k ) to zero
                 if( k<n )e( k ) = zero
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_dcopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_dcopy( n-imax+1, a( imax, imax ), 1,w( imax, k+1 ), 1 )
                       if( k>1 )call stdlib_dgemv( 'NO TRANSPOSE', n-k+1, k-1, -one,a( k, 1 ), &
                                 lda, w( imax, 1 ), ldw,one, w( k, k+1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_idamax( imax-k, w( k, k+1 ), 1 )
                          rowmax = abs( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_idamax( n-imax, w( imax+1, k+1 ), 1)
                          dtemp = abs( w( itemp, k+1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! abs( w( imax, k+1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( w( imax, k+1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_dcopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_dcopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 72
                 end if
                 ! ============================================================
                 kk = k + kstep - 1
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_dcopy( p-k, a( k, k ), 1, a( p, k ), lda )
                    call stdlib_dcopy( n-p+1, a( p, k ), 1, a( p, p ), 1 )
                    ! interchange rows k and p in first k columns of a
                    ! and first k+1 columns of w
                    call stdlib_dswap( k, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_dswap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! updated column kp is already stored in column kk of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_dcopy( kp-k-1, a( k+1, kk ), 1, a( kp, k+1 ), lda )
                    call stdlib_dcopy( n-kp+1, a( kp, kk ), 1, a( kp, kp ), 1 )
                    ! interchange rows kk and kp in first kk columns of a and w
                    call stdlib_dswap( kk, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_dswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    ! store l(k) in column k of a
                    call stdlib_dcopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       if( abs( a( k, k ) )>=sfmin ) then
                          r1 = one / a( k, k )
                          call stdlib_dscal( n-k, r1, a( k+1, k ), 1 )
                       else if( a( k, k )/=zero ) then
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = zero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! store l(k) and l(k+1) in columns k and k+1 of a
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = one / ( d11*d22-one )
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /d21 )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy subdiagonal element of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = zero
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    e( k ) = w( k+1, k )
                    e( k+1 ) = zero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_dgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -one,a( jj, 1 ), lda, w( jj, &
                              1 ), ldw, one,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_dgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           one, a( j+jb, 1 ), lda, w( j, 1 ),ldw, one, a( j+jb, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_dlasyf_rk

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$lasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
     !! DLASYF_RK: computes a partial factorization of a real symmetric
     !! matrix A using the bounded Bunch-Kaufman (rook) diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L',
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! DLASYF_RK is an auxiliary routine called by DSYTRF_RK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: e(*), w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sevten = 17.0e+0_${rk}$
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, j, jb, jj, jmax, k, kk, kw, kkw, kp, kstep, p, ii
           real(${rk}$) :: absakk, alpha, colmax, d11, d12, d21, d22, dtemp, r1, rowmax, t, &
                     sfmin
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_${ri}$lamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = zero
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              call stdlib_${ri}$copy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_${ri}$gemv( 'NO TRANSPOSE', k, n-k, -one, a( 1, k+1 ),lda, w( k, kw+&
                        1 ), ldw, one, w( 1, kw ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ri}$amax( k-1, w( 1, kw ), 1 )
                 colmax = abs( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_${ri}$copy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = zero
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       call stdlib_${ri}$copy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                       call stdlib_${ri}$copy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       if( k<n )call stdlib_${ri}$gemv( 'NO TRANSPOSE', k, n-k, -one,a( 1, k+1 ), lda, &
                                 w( imax, kw+1 ), ldw,one, w( 1, kw-1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_i${ri}$amax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = abs( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_i${ri}$amax( imax-1, w( 1, kw-1 ), 1 )
                          dtemp = abs( w( itemp, kw-1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! abs( w( imax, kw-1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.(abs( w( imax, kw-1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_${ri}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_${ri}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! ============================================================
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_${ri}$copy( k-p, a( p+1, k ), 1, a( p, p+1 ), lda )
                    call stdlib_${ri}$copy( p, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in last n-k+1 columns of a
                    ! and last n-k+2 columns of w
                    call stdlib_${ri}$swap( n-k+1, a( k, k ), lda, a( p, k ), lda )
                    call stdlib_${ri}$swap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ), ldw )
                 end if
                 ! updated column kp is already stored in column kkw of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_${ri}$copy( k-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_${ri}$copy( kp, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last n-kk+1 columns
                    ! of a and w
                    call stdlib_${ri}$swap( n-kk+1, a( kk, kk ), lda, a( kp, kk ), lda )
                    call stdlib_${ri}$swap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! store u(k) in column k of a
                    call stdlib_${ri}$copy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       if( abs( a( k, k ) )>=sfmin ) then
                          r1 = one / a( k, k )
                          call stdlib_${ri}$scal( k-1, r1, a( 1, k ), 1 )
                       else if( a( k, k )/=zero ) then
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = zero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now
                    ! hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    if( k>2 ) then
                       ! store u(k) and u(k-1) in columns k and k-1 of a
                       d12 = w( k-1, kw )
                       d11 = w( k, kw ) / d12
                       d22 = w( k-1, kw-1 ) / d12
                       t = one / ( d11*d22-one )
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( (d11*w( j, kw-1 )-w( j, kw ) ) /d12 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /d12 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy superdiagonal element of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = zero
                    a( k, k ) = w( k, kw )
                    e( k ) = w( k-1, kw )
                    e( k-1 ) = zero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', jj-j+1, n-k, -one,a( j, k+1 ), lda, w( jj, &
                              kw+1 ), ldw, one,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb,n-k, -one, a( &
                           1, k+1 ), lda, w( j, kw+1 ),ldw, one, a( 1, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = zero
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update it
              call stdlib_${ri}$copy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              if( k>1 )call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -one, a( k, 1 ),lda, w( k, &
                        1 ), ldw, one, w( k, k ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ri}$amax( n-k, w( k+1, k ), 1 )
                 colmax = abs( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_${ri}$copy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                 ! set e( k ) to zero
                 if( k<n )e( k ) = zero
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_${ri}$copy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_${ri}$copy( n-imax+1, a( imax, imax ), 1,w( imax, k+1 ), 1 )
                       if( k>1 )call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -one,a( k, 1 ), &
                                 lda, w( imax, 1 ), ldw,one, w( k, k+1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_i${ri}$amax( imax-k, w( k, k+1 ), 1 )
                          rowmax = abs( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_i${ri}$amax( n-imax, w( imax+1, k+1 ), 1)
                          dtemp = abs( w( itemp, k+1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! abs( w( imax, k+1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( w( imax, k+1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_${ri}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_${ri}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 72
                 end if
                 ! ============================================================
                 kk = k + kstep - 1
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_${ri}$copy( p-k, a( k, k ), 1, a( p, k ), lda )
                    call stdlib_${ri}$copy( n-p+1, a( p, k ), 1, a( p, p ), 1 )
                    ! interchange rows k and p in first k columns of a
                    ! and first k+1 columns of w
                    call stdlib_${ri}$swap( k, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_${ri}$swap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! updated column kp is already stored in column kk of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_${ri}$copy( kp-k-1, a( k+1, kk ), 1, a( kp, k+1 ), lda )
                    call stdlib_${ri}$copy( n-kp+1, a( kp, kk ), 1, a( kp, kp ), 1 )
                    ! interchange rows kk and kp in first kk columns of a and w
                    call stdlib_${ri}$swap( kk, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_${ri}$swap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    ! store l(k) in column k of a
                    call stdlib_${ri}$copy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       if( abs( a( k, k ) )>=sfmin ) then
                          r1 = one / a( k, k )
                          call stdlib_${ri}$scal( n-k, r1, a( k+1, k ), 1 )
                       else if( a( k, k )/=zero ) then
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = zero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! store l(k) and l(k+1) in columns k and k+1 of a
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = one / ( d11*d22-one )
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /d21 )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy subdiagonal element of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = zero
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    e( k ) = w( k+1, k )
                    e( k+1 ) = zero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', j+jb-jj, k-1, -one,a( jj, 1 ), lda, w( jj, &
                              1 ), ldw, one,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           one, a( j+jb, 1 ), lda, w( j, 1 ),ldw, one, a( j+jb, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_${ri}$lasyf_rk

#:endif
#:endfor

     module pure subroutine stdlib_clasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
     !! CLASYF_RK computes a partial factorization of a complex symmetric
     !! matrix A using the bounded Bunch-Kaufman (rook) diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L',
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! CLASYF_RK is an auxiliary routine called by CSYTRF_RK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: e(*), w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, j, jb, jj, jmax, k, kk, kw, kkw, kp, kstep, p, ii
           real(sp) :: absakk, alpha, colmax, rowmax, sfmin, stemp
           complex(sp) :: d11, d12, d21, d22, r1, t, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = czero
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              call stdlib_ccopy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ),lda, w( k, &
                        kw+1 ), ldw, cone, w( 1, kw ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_ccopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = czero
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       call stdlib_ccopy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                       call stdlib_ccopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       if( k<n )call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda,&
                                  w( imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_icamax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = cabs1( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_icamax( imax-1, w( 1, kw-1 ), 1 )
                          stemp = cabs1( w( itemp, kw-1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! cabs1( w( imax, kw-1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.(cabs1( w( imax, kw-1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! ============================================================
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_ccopy( k-p, a( p+1, k ), 1, a( p, p+1 ), lda )
                    call stdlib_ccopy( p, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in last n-k+1 columns of a
                    ! and last n-k+2 columns of w
                    call stdlib_cswap( n-k+1, a( k, k ), lda, a( p, k ), lda )
                    call stdlib_cswap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ), ldw )
                 end if
                 ! updated column kp is already stored in column kkw of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_ccopy( k-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_ccopy( kp, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last n-kk+1 columns
                    ! of a and w
                    call stdlib_cswap( n-kk+1, a( kk, kk ), lda, a( kp, kk ), lda )
                    call stdlib_cswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! store u(k) in column k of a
                    call stdlib_ccopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          r1 = cone / a( k, k )
                          call stdlib_cscal( k-1, r1, a( 1, k ), 1 )
                       else if( a( k, k )/=czero ) then
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now
                    ! hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    if( k>2 ) then
                       ! store u(k) and u(k-1) in columns k and k-1 of a
                       d12 = w( k-1, kw )
                       d11 = w( k, kw ) / d12
                       d22 = w( k-1, kw-1 ) / d12
                       t = cone / ( d11*d22-cone )
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( (d11*w( j, kw-1 )-w( j, kw ) ) /d12 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /d12 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy superdiagonal element of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = czero
                    a( k, k ) = w( k, kw )
                    e( k ) = w( k-1, kw )
                    e( k-1 ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_cgemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb,n-k, -cone, a( &
                           1, k+1 ), lda, w( j, kw+1 ),ldw, cone, a( 1, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = czero
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update it
              call stdlib_ccopy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              if( k>1 )call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( k, &
                        1 ), ldw, cone, w( k, k ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_ccopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                 ! set e( k ) to zero
                 if( k<n )e( k ) = czero
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_ccopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_ccopy( n-imax+1, a( imax, imax ), 1,w( imax, k+1 ), 1 )
                       if( k>1 )call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone,a( k, 1 ), &
                                 lda, w( imax, 1 ), ldw,cone, w( k, k+1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_icamax( imax-k, w( k, k+1 ), 1 )
                          rowmax = cabs1( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_icamax( n-imax, w( imax+1, k+1 ), 1)
                          stemp = cabs1( w( itemp, k+1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! cabs1( w( imax, k+1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( cabs1( w( imax, k+1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 72
                 end if
                 ! ============================================================
                 kk = k + kstep - 1
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_ccopy( p-k, a( k, k ), 1, a( p, k ), lda )
                    call stdlib_ccopy( n-p+1, a( p, k ), 1, a( p, p ), 1 )
                    ! interchange rows k and p in first k columns of a
                    ! and first k+1 columns of w
                    call stdlib_cswap( k, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_cswap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! updated column kp is already stored in column kk of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_ccopy( kp-k-1, a( k+1, kk ), 1, a( kp, k+1 ), lda )
                    call stdlib_ccopy( n-kp+1, a( kp, kk ), 1, a( kp, kp ), 1 )
                    ! interchange rows kk and kp in first kk columns of a and w
                    call stdlib_cswap( kk, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_cswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    ! store l(k) in column k of a
                    call stdlib_ccopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          r1 = cone / a( k, k )
                          call stdlib_cscal( n-k, r1, a( k+1, k ), 1 )
                       else if( a( k, k )/=czero ) then
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! store l(k) and l(k+1) in columns k and k+1 of a
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /d21 )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy subdiagonal element of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = czero
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    e( k ) = w( k+1, k )
                    e( k+1 ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_cgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_clasyf_rk

     module pure subroutine stdlib_zlasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
     !! ZLASYF_RK computes a partial factorization of a complex symmetric
     !! matrix A using the bounded Bunch-Kaufman (rook) diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L',
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! ZLASYF_RK is an auxiliary routine called by ZSYTRF_RK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: e(*), w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, j, jb, jj, jmax, k, kk, kw, kkw, kp, kstep, p, ii
           real(dp) :: absakk, alpha, colmax, rowmax, sfmin, dtemp
           complex(dp) :: d11, d12, d21, d22, r1, t, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=dp) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_dlamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = czero
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              call stdlib_zcopy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_zgemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ),lda, w( k, &
                        kw+1 ), ldw, cone, w( 1, kw ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_izamax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_zcopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = czero
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       call stdlib_zcopy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                       call stdlib_zcopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       if( k<n )call stdlib_zgemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda,&
                                  w( imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_izamax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = cabs1( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_izamax( imax-1, w( 1, kw-1 ), 1 )
                          dtemp = cabs1( w( itemp, kw-1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! cabs1( w( imax, kw-1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.(cabs1( w( imax, kw-1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_zcopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_zcopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! ============================================================
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_zcopy( k-p, a( p+1, k ), 1, a( p, p+1 ), lda )
                    call stdlib_zcopy( p, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in last n-k+1 columns of a
                    ! and last n-k+2 columns of w
                    call stdlib_zswap( n-k+1, a( k, k ), lda, a( p, k ), lda )
                    call stdlib_zswap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ), ldw )
                 end if
                 ! updated column kp is already stored in column kkw of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_zcopy( k-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_zcopy( kp, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last n-kk+1 columns
                    ! of a and w
                    call stdlib_zswap( n-kk+1, a( kk, kk ), lda, a( kp, kk ), lda )
                    call stdlib_zswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! store u(k) in column k of a
                    call stdlib_zcopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          r1 = cone / a( k, k )
                          call stdlib_zscal( k-1, r1, a( 1, k ), 1 )
                       else if( a( k, k )/=czero ) then
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now
                    ! hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    if( k>2 ) then
                       ! store u(k) and u(k-1) in columns k and k-1 of a
                       d12 = w( k-1, kw )
                       d11 = w( k, kw ) / d12
                       d22 = w( k-1, kw-1 ) / d12
                       t = cone / ( d11*d22-cone )
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( (d11*w( j, kw-1 )-w( j, kw ) ) /d12 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /d12 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy superdiagonal element of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = czero
                    a( k, k ) = w( k, kw )
                    e( k ) = w( k-1, kw )
                    e( k-1 ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_zgemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_zgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb,n-k, -cone, a( &
                           1, k+1 ), lda, w( j, kw+1 ),ldw, cone, a( 1, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = czero
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update it
              call stdlib_zcopy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              if( k>1 )call stdlib_zgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( k, &
                        1 ), ldw, cone, w( k, k ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_izamax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_zcopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                 ! set e( k ) to zero
                 if( k<n )e( k ) = czero
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_zcopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_zcopy( n-imax+1, a( imax, imax ), 1,w( imax, k+1 ), 1 )
                       if( k>1 )call stdlib_zgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone,a( k, 1 ), &
                                 lda, w( imax, 1 ), ldw,cone, w( k, k+1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_izamax( imax-k, w( k, k+1 ), 1 )
                          rowmax = cabs1( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_izamax( n-imax, w( imax+1, k+1 ), 1)
                          dtemp = cabs1( w( itemp, k+1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! cabs1( w( imax, k+1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( cabs1( w( imax, k+1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_zcopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_zcopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 72
                 end if
                 ! ============================================================
                 kk = k + kstep - 1
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_zcopy( p-k, a( k, k ), 1, a( p, k ), lda )
                    call stdlib_zcopy( n-p+1, a( p, k ), 1, a( p, p ), 1 )
                    ! interchange rows k and p in first k columns of a
                    ! and first k+1 columns of w
                    call stdlib_zswap( k, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_zswap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! updated column kp is already stored in column kk of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_zcopy( kp-k-1, a( k+1, kk ), 1, a( kp, k+1 ), lda )
                    call stdlib_zcopy( n-kp+1, a( kp, kk ), 1, a( kp, kp ), 1 )
                    ! interchange rows kk and kp in first kk columns of a and w
                    call stdlib_zswap( kk, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_zswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    ! store l(k) in column k of a
                    call stdlib_zcopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          r1 = cone / a( k, k )
                          call stdlib_zscal( n-k, r1, a( k+1, k ), 1 )
                       else if( a( k, k )/=czero ) then
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! store l(k) and l(k+1) in columns k and k+1 of a
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /d21 )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy subdiagonal element of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = czero
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    e( k ) = w( k+1, k )
                    e( k+1 ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_zgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_zgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_zlasyf_rk

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$lasyf_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
     !! ZLASYF_RK: computes a partial factorization of a complex symmetric
     !! matrix A using the bounded Bunch-Kaufman (rook) diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L',
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! ZLASYF_RK is an auxiliary routine called by ZSYTRF_RK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: e(*), w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: sevten = 17.0e+0_${ck}$
           
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, j, jb, jj, jmax, k, kk, kw, kkw, kp, kstep, p, ii
           real(${ck}$) :: absakk, alpha, colmax, rowmax, sfmin, dtemp
           complex(${ck}$) :: d11, d12, d21, d22, r1, t, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=${ck}$) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_${c2ri(ci)}$lamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = czero
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              call stdlib_${ci}$copy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_${ci}$gemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ),lda, w( k, &
                        kw+1 ), ldw, cone, w( 1, kw ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ci}$amax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_${ci}$copy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = czero
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       call stdlib_${ci}$copy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                       call stdlib_${ci}$copy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       if( k<n )call stdlib_${ci}$gemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda,&
                                  w( imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_i${ci}$amax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = cabs1( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_i${ci}$amax( imax-1, w( 1, kw-1 ), 1 )
                          dtemp = cabs1( w( itemp, kw-1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! cabs1( w( imax, kw-1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.(cabs1( w( imax, kw-1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_${ci}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_${ci}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! ============================================================
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_${ci}$copy( k-p, a( p+1, k ), 1, a( p, p+1 ), lda )
                    call stdlib_${ci}$copy( p, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in last n-k+1 columns of a
                    ! and last n-k+2 columns of w
                    call stdlib_${ci}$swap( n-k+1, a( k, k ), lda, a( p, k ), lda )
                    call stdlib_${ci}$swap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ), ldw )
                 end if
                 ! updated column kp is already stored in column kkw of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_${ci}$copy( k-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_${ci}$copy( kp, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last n-kk+1 columns
                    ! of a and w
                    call stdlib_${ci}$swap( n-kk+1, a( kk, kk ), lda, a( kp, kk ), lda )
                    call stdlib_${ci}$swap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! store u(k) in column k of a
                    call stdlib_${ci}$copy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          r1 = cone / a( k, k )
                          call stdlib_${ci}$scal( k-1, r1, a( 1, k ), 1 )
                       else if( a( k, k )/=czero ) then
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now
                    ! hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    if( k>2 ) then
                       ! store u(k) and u(k-1) in columns k and k-1 of a
                       d12 = w( k-1, kw )
                       d11 = w( k, kw ) / d12
                       d22 = w( k-1, kw-1 ) / d12
                       t = cone / ( d11*d22-cone )
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( (d11*w( j, kw-1 )-w( j, kw ) ) /d12 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /d12 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy superdiagonal element of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = czero
                    a( k, k ) = w( k, kw )
                    e( k ) = w( k-1, kw )
                    e( k-1 ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_${ci}$gemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb,n-k, -cone, a( &
                           1, k+1 ), lda, w( j, kw+1 ),ldw, cone, a( 1, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = czero
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update it
              call stdlib_${ci}$copy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              if( k>1 )call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( k, &
                        1 ), ldw, cone, w( k, k ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ci}$amax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_${ci}$copy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                 ! set e( k ) to zero
                 if( k<n )e( k ) = czero
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_${ci}$copy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_${ci}$copy( n-imax+1, a( imax, imax ), 1,w( imax, k+1 ), 1 )
                       if( k>1 )call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -cone,a( k, 1 ), &
                                 lda, w( imax, 1 ), ldw,cone, w( k, k+1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_i${ci}$amax( imax-k, w( k, k+1 ), 1 )
                          rowmax = cabs1( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_i${ci}$amax( n-imax, w( imax+1, k+1 ), 1)
                          dtemp = cabs1( w( itemp, k+1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! cabs1( w( imax, k+1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( cabs1( w( imax, k+1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_${ci}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_${ci}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 72
                 end if
                 ! ============================================================
                 kk = k + kstep - 1
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_${ci}$copy( p-k, a( k, k ), 1, a( p, k ), lda )
                    call stdlib_${ci}$copy( n-p+1, a( p, k ), 1, a( p, p ), 1 )
                    ! interchange rows k and p in first k columns of a
                    ! and first k+1 columns of w
                    call stdlib_${ci}$swap( k, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_${ci}$swap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! updated column kp is already stored in column kk of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_${ci}$copy( kp-k-1, a( k+1, kk ), 1, a( kp, k+1 ), lda )
                    call stdlib_${ci}$copy( n-kp+1, a( kp, kk ), 1, a( kp, kp ), 1 )
                    ! interchange rows kk and kp in first kk columns of a and w
                    call stdlib_${ci}$swap( kk, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_${ci}$swap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    ! store l(k) in column k of a
                    call stdlib_${ci}$copy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          r1 = cone / a( k, k )
                          call stdlib_${ci}$scal( n-k, r1, a( k+1, k ), 1 )
                       else if( a( k, k )/=czero ) then
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! store l(k) and l(k+1) in columns k and k+1 of a
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /d21 )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy subdiagonal element of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = czero
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    e( k ) = w( k+1, k )
                    e( k+1 ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_${ci}$gemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_${ci}$lasyf_rk

#:endif
#:endfor



     module pure subroutine stdlib_ssytri( uplo, n, a, lda, ipiv, work, info )
     !! SSYTRI computes the inverse of a real symmetric indefinite matrix
     !! A using the factorization A = U*D*U**T or A = L*D*L**T computed by
     !! SSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k, kp, kstep
           real(sp) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==zero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 40
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / a( k, k )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_scopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_ssymv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_sdot( k-1, work, 1, a( 1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k+1 ) )
                 ak = a( k, k ) / t
                 akp1 = a( k+1, k+1 ) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-one )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_scopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_ssymv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_sdot( k-1, work, 1, a( 1, k ),1 )
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_sdot( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_scopy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_ssymv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -stdlib_sdot( k-1, work, 1, a( 1, k+1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 call stdlib_sswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                 call stdlib_sswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
              end if
              k = k + kstep
              go to 30
              40 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              50 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 60
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / a( k, k )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_scopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_ssymv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_sdot( n-k, work, 1, a( k+1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k-1 ) )
                 ak = a( k-1, k-1 ) / t
                 akp1 = a( k, k ) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-one )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_scopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_ssymv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_sdot( n-k, work, 1, a( k+1, k ),1 )
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_sdot( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 )
                              
                    call stdlib_scopy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_ssymv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -stdlib_sdot( n-k, work, 1, a( k+1, k-1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 if( kp<n )call stdlib_sswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                 call stdlib_sswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
              end if
              k = k - kstep
              go to 50
              60 continue
           end if
           return
     end subroutine stdlib_ssytri

     module pure subroutine stdlib_dsytri( uplo, n, a, lda, ipiv, work, info )
     !! DSYTRI computes the inverse of a real symmetric indefinite matrix
     !! A using the factorization A = U*D*U**T or A = L*D*L**T computed by
     !! DSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k, kp, kstep
           real(dp) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==zero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 40
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / a( k, k )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_dcopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_dsymv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_ddot( k-1, work, 1, a( 1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k+1 ) )
                 ak = a( k, k ) / t
                 akp1 = a( k+1, k+1 ) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-one )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_dcopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_dsymv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_ddot( k-1, work, 1, a( 1, k ),1 )
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_ddot( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_dcopy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_dsymv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -stdlib_ddot( k-1, work, 1, a( 1, k+1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 call stdlib_dswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                 call stdlib_dswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
              end if
              k = k + kstep
              go to 30
              40 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              50 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 60
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / a( k, k )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_dcopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_dsymv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_ddot( n-k, work, 1, a( k+1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k-1 ) )
                 ak = a( k-1, k-1 ) / t
                 akp1 = a( k, k ) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-one )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_dcopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_dsymv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_ddot( n-k, work, 1, a( k+1, k ),1 )
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_ddot( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 )
                              
                    call stdlib_dcopy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_dsymv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -stdlib_ddot( n-k, work, 1, a( k+1, k-1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 if( kp<n )call stdlib_dswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                 call stdlib_dswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
              end if
              k = k - kstep
              go to 50
              60 continue
           end if
           return
     end subroutine stdlib_dsytri

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sytri( uplo, n, a, lda, ipiv, work, info )
     !! DSYTRI: computes the inverse of a real symmetric indefinite matrix
     !! A using the factorization A = U*D*U**T or A = L*D*L**T computed by
     !! DSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k, kp, kstep
           real(${rk}$) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==zero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 40
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / a( k, k )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_${ri}$copy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_${ri}$dot( k-1, work, 1, a( 1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k+1 ) )
                 ak = a( k, k ) / t
                 akp1 = a( k+1, k+1 ) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-one )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_${ri}$copy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_${ri}$dot( k-1, work, 1, a( 1, k ),1 )
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_${ri}$dot( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_${ri}$copy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -stdlib_${ri}$dot( k-1, work, 1, a( 1, k+1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 call stdlib_${ri}$swap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                 call stdlib_${ri}$swap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
              end if
              k = k + kstep
              go to 30
              40 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              50 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 60
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / a( k, k )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_${ri}$copy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_${ri}$dot( n-k, work, 1, a( k+1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k-1 ) )
                 ak = a( k-1, k-1 ) / t
                 akp1 = a( k, k ) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-one )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_${ri}$copy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_${ri}$dot( n-k, work, 1, a( k+1, k ),1 )
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_${ri}$dot( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 )
                              
                    call stdlib_${ri}$copy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -stdlib_${ri}$dot( n-k, work, 1, a( k+1, k-1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 if( kp<n )call stdlib_${ri}$swap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                 call stdlib_${ri}$swap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
              end if
              k = k - kstep
              go to 50
              60 continue
           end if
           return
     end subroutine stdlib_${ri}$sytri

#:endif
#:endfor

     module pure subroutine stdlib_csytri( uplo, n, a, lda, ipiv, work, info )
     !! CSYTRI computes the inverse of a complex symmetric indefinite matrix
     !! A using the factorization A = U*D*U**T or A = L*D*L**T computed by
     !! CSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k, kp, kstep
           complex(sp) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 40
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = cone / a( k, k )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_csymv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_cdotu( k-1, work, 1, a( 1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = a( k, k+1 )
                 ak = a( k, k ) / t
                 akp1 = a( k+1, k+1 ) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-cone )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_csymv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_cdotu( k-1, work, 1, a( 1, k ),1 )
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_cdotu( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_ccopy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_csymv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -stdlib_cdotu( k-1, work, 1, a( 1, k+1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 call stdlib_cswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                 call stdlib_cswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
              end if
              k = k + kstep
              go to 30
              40 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              50 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 60
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = cone / a( k, k )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_csymv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_cdotu( n-k, work, 1, a( k+1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = a( k, k-1 )
                 ak = a( k-1, k-1 ) / t
                 akp1 = a( k, k ) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-cone )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_csymv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_cdotu( n-k, work, 1, a( k+1, k ),1 )
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_cdotu( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 &
                              )
                    call stdlib_ccopy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_csymv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+&
                              1, k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -stdlib_cdotu( n-k, work, 1, a( k+1, k-1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 if( kp<n )call stdlib_cswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                 call stdlib_cswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
              end if
              k = k - kstep
              go to 50
              60 continue
           end if
           return
     end subroutine stdlib_csytri

     module pure subroutine stdlib_zsytri( uplo, n, a, lda, ipiv, work, info )
     !! ZSYTRI computes the inverse of a complex symmetric indefinite matrix
     !! A using the factorization A = U*D*U**T or A = L*D*L**T computed by
     !! ZSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k, kp, kstep
           complex(dp) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 40
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = cone / a( k, k )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_zcopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_zsymv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_zdotu( k-1, work, 1, a( 1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = a( k, k+1 )
                 ak = a( k, k ) / t
                 akp1 = a( k+1, k+1 ) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-cone )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_zcopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_zsymv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_zdotu( k-1, work, 1, a( 1, k ),1 )
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_zdotu( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_zcopy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_zsymv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -stdlib_zdotu( k-1, work, 1, a( 1, k+1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 call stdlib_zswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                 call stdlib_zswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
              end if
              k = k + kstep
              go to 30
              40 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              50 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 60
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = cone / a( k, k )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_zcopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_zsymv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_zdotu( n-k, work, 1, a( k+1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = a( k, k-1 )
                 ak = a( k-1, k-1 ) / t
                 akp1 = a( k, k ) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-cone )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_zcopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_zsymv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_zdotu( n-k, work, 1, a( k+1, k ),1 )
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_zdotu( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 &
                              )
                    call stdlib_zcopy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_zsymv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+&
                              1, k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -stdlib_zdotu( n-k, work, 1, a( k+1, k-1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 if( kp<n )call stdlib_zswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                 call stdlib_zswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
              end if
              k = k - kstep
              go to 50
              60 continue
           end if
           return
     end subroutine stdlib_zsytri

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sytri( uplo, n, a, lda, ipiv, work, info )
     !! ZSYTRI: computes the inverse of a complex symmetric indefinite matrix
     !! A using the factorization A = U*D*U**T or A = L*D*L**T computed by
     !! ZSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k, kp, kstep
           complex(${ck}$) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 40
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = cone / a( k, k )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_${ci}$copy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_${ci}$symv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_${ci}$dotu( k-1, work, 1, a( 1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = a( k, k+1 )
                 ak = a( k, k ) / t
                 akp1 = a( k+1, k+1 ) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-cone )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_${ci}$copy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_${ci}$symv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_${ci}$dotu( k-1, work, 1, a( 1, k ),1 )
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_${ci}$dotu( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_${ci}$copy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_${ci}$symv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -stdlib_${ci}$dotu( k-1, work, 1, a( 1, k+1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 call stdlib_${ci}$swap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                 call stdlib_${ci}$swap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
              end if
              k = k + kstep
              go to 30
              40 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              50 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 60
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = cone / a( k, k )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_${ci}$copy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_${ci}$symv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_${ci}$dotu( n-k, work, 1, a( k+1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = a( k, k-1 )
                 ak = a( k-1, k-1 ) / t
                 akp1 = a( k, k ) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-cone )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_${ci}$copy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_${ci}$symv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_${ci}$dotu( n-k, work, 1, a( k+1, k ),1 )
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_${ci}$dotu( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 &
                              )
                    call stdlib_${ci}$copy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_${ci}$symv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+&
                              1, k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -stdlib_${ci}$dotu( n-k, work, 1, a( k+1, k-1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 if( kp<n )call stdlib_${ci}$swap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                 call stdlib_${ci}$swap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
              end if
              k = k - kstep
              go to 50
              60 continue
           end if
           return
     end subroutine stdlib_${ci}$sytri

#:endif
#:endfor





     module pure subroutine stdlib_ssytri_rook( uplo, n, a, lda, ipiv, work, info )
     !! SSYTRI_ROOK computes the inverse of a real symmetric
     !! matrix A using the factorization A = U*D*U**T or A = L*D*L**T
     !! computed by SSYTRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k, kp, kstep
           real(sp) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYTRI_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==zero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 40
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / a( k, k )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_scopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_ssymv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_sdot( k-1, work, 1, a( 1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k+1 ) )
                 ak = a( k, k ) / t
                 akp1 = a( k+1, k+1 ) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-one )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_scopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_ssymv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_sdot( k-1, work, 1, a( 1, k ),1 )
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_sdot( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_scopy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_ssymv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -stdlib_sdot( k-1, work, 1, a( 1, k+1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_sswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_sswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k+1 with -ipiv(k) and
                 ! -ipiv(k+1)in the leading submatrix a(1:k+1,1:k+1)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_sswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_sswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
                 k = k + 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_sswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_sswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k + 1
              go to 30
              40 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              50 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 60
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / a( k, k )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_scopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_ssymv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_sdot( n-k, work, 1, a( k+1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k-1 ) )
                 ak = a( k-1, k-1 ) / t
                 akp1 = a( k, k ) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-one )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_scopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_ssymv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_sdot( n-k, work, 1, a( k+1, k ),1 )
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_sdot( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 )
                              
                    call stdlib_scopy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_ssymv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -stdlib_sdot( n-k, work, 1, a( k+1, k-1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_sswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_sswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k-1 with -ipiv(k) and
                 ! -ipiv(k-1) in the trailing submatrix a(k-1:n,k-1:n)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_sswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_sswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
                 k = k - 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_sswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_sswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k - 1
              go to 50
              60 continue
           end if
           return
     end subroutine stdlib_ssytri_rook

     module pure subroutine stdlib_dsytri_rook( uplo, n, a, lda, ipiv, work, info )
     !! DSYTRI_ROOK computes the inverse of a real symmetric
     !! matrix A using the factorization A = U*D*U**T or A = L*D*L**T
     !! computed by DSYTRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k, kp, kstep
           real(dp) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRI_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==zero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 40
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / a( k, k )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_dcopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_dsymv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_ddot( k-1, work, 1, a( 1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k+1 ) )
                 ak = a( k, k ) / t
                 akp1 = a( k+1, k+1 ) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-one )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_dcopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_dsymv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_ddot( k-1, work, 1, a( 1, k ),1 )
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_ddot( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_dcopy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_dsymv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -stdlib_ddot( k-1, work, 1, a( 1, k+1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_dswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_dswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k+1 with -ipiv(k) and
                 ! -ipiv(k+1)in the leading submatrix a(1:k+1,1:k+1)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_dswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_dswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
                 k = k + 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_dswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_dswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k + 1
              go to 30
              40 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              50 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 60
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / a( k, k )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_dcopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_dsymv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_ddot( n-k, work, 1, a( k+1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k-1 ) )
                 ak = a( k-1, k-1 ) / t
                 akp1 = a( k, k ) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-one )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_dcopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_dsymv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_ddot( n-k, work, 1, a( k+1, k ),1 )
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_ddot( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 )
                              
                    call stdlib_dcopy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_dsymv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -stdlib_ddot( n-k, work, 1, a( k+1, k-1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_dswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_dswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k-1 with -ipiv(k) and
                 ! -ipiv(k-1) in the trailing submatrix a(k-1:n,k-1:n)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_dswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_dswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
                 k = k - 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_dswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_dswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k - 1
              go to 50
              60 continue
           end if
           return
     end subroutine stdlib_dsytri_rook

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sytri_rook( uplo, n, a, lda, ipiv, work, info )
     !! DSYTRI_ROOK: computes the inverse of a real symmetric
     !! matrix A using the factorization A = U*D*U**T or A = L*D*L**T
     !! computed by DSYTRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k, kp, kstep
           real(${rk}$) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRI_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==zero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 40
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / a( k, k )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_${ri}$copy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_${ri}$dot( k-1, work, 1, a( 1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k+1 ) )
                 ak = a( k, k ) / t
                 akp1 = a( k+1, k+1 ) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-one )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_${ri}$copy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_${ri}$dot( k-1, work, 1, a( 1, k ),1 )
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_${ri}$dot( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_${ri}$copy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, k-1, -one, a, lda, work, 1, zero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -stdlib_${ri}$dot( k-1, work, 1, a( 1, k+1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_${ri}$swap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_${ri}$swap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k+1 with -ipiv(k) and
                 ! -ipiv(k+1)in the leading submatrix a(1:k+1,1:k+1)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_${ri}$swap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_${ri}$swap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
                 k = k + 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_${ri}$swap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_${ri}$swap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k + 1
              go to 30
              40 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              50 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 60
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / a( k, k )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_${ri}$copy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_${ri}$dot( n-k, work, 1, a( k+1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k-1 ) )
                 ak = a( k-1, k-1 ) / t
                 akp1 = a( k, k ) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-one )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_${ri}$copy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_${ri}$dot( n-k, work, 1, a( k+1, k ),1 )
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_${ri}$dot( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 )
                              
                    call stdlib_${ri}$copy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_${ri}$symv( uplo, n-k, -one, a( k+1, k+1 ), lda, work, 1,zero, a( k+1, &
                              k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -stdlib_${ri}$dot( n-k, work, 1, a( k+1, k-1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_${ri}$swap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_${ri}$swap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k-1 with -ipiv(k) and
                 ! -ipiv(k-1) in the trailing submatrix a(k-1:n,k-1:n)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_${ri}$swap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_${ri}$swap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
                 k = k - 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_${ri}$swap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_${ri}$swap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k - 1
              go to 50
              60 continue
           end if
           return
     end subroutine stdlib_${ri}$sytri_rook

#:endif
#:endfor

     module pure subroutine stdlib_csytri_rook( uplo, n, a, lda, ipiv, work, info )
     !! CSYTRI_ROOK computes the inverse of a complex symmetric
     !! matrix A using the factorization A = U*D*U**T or A = L*D*L**T
     !! computed by CSYTRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k, kp, kstep
           complex(sp) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRI_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 40
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = cone / a( k, k )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_csymv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_cdotu( k-1, work, 1, a( 1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = a( k, k+1 )
                 ak = a( k, k ) / t
                 akp1 = a( k+1, k+1 ) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-cone )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_csymv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_cdotu( k-1, work, 1, a( 1, k ),1 )
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_cdotu( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_ccopy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_csymv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -stdlib_cdotu( k-1, work, 1, a( 1, k+1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_cswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k+1 with -ipiv(k) and
                 ! -ipiv(k+1)in the leading submatrix a(1:k+1,1:k+1)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_cswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
                 k = k + 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_cswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k + 1
              go to 30
              40 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              50 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 60
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = cone / a( k, k )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_csymv( uplo, n-k,-cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+1,&
                               k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_cdotu( n-k, work, 1, a( k+1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = a( k, k-1 )
                 ak = a( k-1, k-1 ) / t
                 akp1 = a( k, k ) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-cone )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_csymv( uplo, n-k,-cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+1,&
                               k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_cdotu( n-k, work, 1, a( k+1, k ),1 )
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_cdotu( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 &
                              )
                    call stdlib_ccopy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_csymv( uplo, n-k,-cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+1,&
                               k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -stdlib_cdotu( n-k, work, 1, a( k+1, k-1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_cswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k-1 with -ipiv(k) and
                 ! -ipiv(k-1) in the trailing submatrix a(k-1:n,k-1:n)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_cswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
                 k = k - 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_cswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k - 1
              go to 50
              60 continue
           end if
           return
     end subroutine stdlib_csytri_rook

     module pure subroutine stdlib_zsytri_rook( uplo, n, a, lda, ipiv, work, info )
     !! ZSYTRI_ROOK computes the inverse of a complex symmetric
     !! matrix A using the factorization A = U*D*U**T or A = L*D*L**T
     !! computed by ZSYTRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k, kp, kstep
           complex(dp) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRI_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 40
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = cone / a( k, k )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_zcopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_zsymv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_zdotu( k-1, work, 1, a( 1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = a( k, k+1 )
                 ak = a( k, k ) / t
                 akp1 = a( k+1, k+1 ) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-cone )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_zcopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_zsymv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_zdotu( k-1, work, 1, a( 1, k ),1 )
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_zdotu( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_zcopy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_zsymv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -stdlib_zdotu( k-1, work, 1, a( 1, k+1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_zswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_zswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k+1 with -ipiv(k) and
                 ! -ipiv(k+1)in the leading submatrix a(1:k+1,1:k+1)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_zswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_zswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
                 k = k + 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_zswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_zswap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k + 1
              go to 30
              40 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              50 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 60
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = cone / a( k, k )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_zcopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_zsymv( uplo, n-k,-cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+1,&
                               k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_zdotu( n-k, work, 1, a( k+1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = a( k, k-1 )
                 ak = a( k-1, k-1 ) / t
                 akp1 = a( k, k ) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-cone )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_zcopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_zsymv( uplo, n-k,-cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+1,&
                               k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_zdotu( n-k, work, 1, a( k+1, k ),1 )
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_zdotu( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 &
                              )
                    call stdlib_zcopy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_zsymv( uplo, n-k,-cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+1,&
                               k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -stdlib_zdotu( n-k, work, 1, a( k+1, k-1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_zswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_zswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k-1 with -ipiv(k) and
                 ! -ipiv(k-1) in the trailing submatrix a(k-1:n,k-1:n)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_zswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_zswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
                 k = k - 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_zswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_zswap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k - 1
              go to 50
              60 continue
           end if
           return
     end subroutine stdlib_zsytri_rook

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sytri_rook( uplo, n, a, lda, ipiv, work, info )
     !! ZSYTRI_ROOK: computes the inverse of a complex symmetric
     !! matrix A using the factorization A = U*D*U**T or A = L*D*L**T
     !! computed by ZSYTRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: k, kp, kstep
           complex(${ck}$) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRI_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 40
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = cone / a( k, k )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_${ci}$copy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_${ci}$symv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_${ci}$dotu( k-1, work, 1, a( 1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = a( k, k+1 )
                 ak = a( k, k ) / t
                 akp1 = a( k+1, k+1 ) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-cone )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_${ci}$copy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_${ci}$symv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - stdlib_${ci}$dotu( k-1, work, 1, a( 1, k ),1 )
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_${ci}$dotu( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_${ci}$copy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_${ci}$symv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -stdlib_${ci}$dotu( k-1, work, 1, a( 1, k+1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_${ci}$swap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_${ci}$swap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k+1 with -ipiv(k) and
                 ! -ipiv(k+1)in the leading submatrix a(1:k+1,1:k+1)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_${ci}$swap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_${ci}$swap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
                 k = k + 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_${ci}$swap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    call stdlib_${ci}$swap( k-kp-1, a( kp+1, k ), 1, a( kp, kp+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k + 1
              go to 30
              40 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              50 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 60
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = cone / a( k, k )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_${ci}$copy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_${ci}$symv( uplo, n-k,-cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+1,&
                               k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_${ci}$dotu( n-k, work, 1, a( k+1, k ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = a( k, k-1 )
                 ak = a( k-1, k-1 ) / t
                 akp1 = a( k, k ) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-cone )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_${ci}$copy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_${ci}$symv( uplo, n-k,-cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+1,&
                               k ), 1 )
                    a( k, k ) = a( k, k ) - stdlib_${ci}$dotu( n-k, work, 1, a( k+1, k ),1 )
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_${ci}$dotu( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 &
                              )
                    call stdlib_${ci}$copy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_${ci}$symv( uplo, n-k,-cone, a( k+1, k+1 ), lda, work, 1,czero, a( k+1,&
                               k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -stdlib_${ci}$dotu( n-k, work, 1, a( k+1, k-1 ), 1 )
                              
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_${ci}$swap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_${ci}$swap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k-1 with -ipiv(k) and
                 ! -ipiv(k-1) in the trailing submatrix a(k-1:n,k-1:n)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_${ci}$swap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_${ci}$swap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
                 k = k - 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_${ci}$swap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    call stdlib_${ci}$swap( kp-k-1, a( k+1, k ), 1, a( kp, k+1 ), lda )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k - 1
              go to 50
              60 continue
           end if
           return
     end subroutine stdlib_${ci}$sytri_rook

#:endif
#:endfor



     module pure subroutine stdlib_slasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
     !! DLATRF_AA factorizes a panel of a real symmetric matrix A using
     !! the Aasen's algorithm. The panel consists of a set of NB rows of A
     !! when UPLO is U, or a set of NB columns when UPLO is L.
     !! In order to factorize the panel, the Aasen's algorithm requires the
     !! last row, or column, of the previous panel. The first row, or column,
     !! of A is set to be the first row, or column, of an identity matrix,
     !! which is used to factorize the first panel.
     !! The resulting J-th row of U, or J-th column of L, is stored in the
     !! (J-1)-th row, or column, of A (without the unit diagonals), while
     !! the diagonal and subdiagonal of A are overwritten by those of T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: m, nb, j1, lda, ldh
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*), h(ldh,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j, k, k1, i1, i2, mj
           real(sp) :: piv, alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           j = 1
           ! k1 is the first column of the panel to be factorized
           ! i.e.,  k1 is 2 for the first block column, and 1 for the rest of the blocks
           k1 = (2-j1)+1
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              10 continue
              if ( j>min(m, nb) )go to 20
              ! k is the column to be factorized
               ! when being called from stdlib_ssytrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:m, j) := a(j, j:m) - h(j:m, 1:(j-1)) * l(j1:(j-1), j),
               ! where h(j:m, j) has been initialized to be a(j, j:m)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_sgemv( 'NO TRANSPOSE', mj, j-k1,-one, h( j, k1 ), ldh,a( 1, j ), 1,&
                           one, h( j, j ), 1 )
              end if
              ! copy h(i:m, i) into work
              call stdlib_scopy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j-1, j:m) * t(j-1,j),
                  ! where a(j-1, j) stores t(j-1, j) and a(j-2, j:m) stores u(j-1, j:m)
                 alpha = -a( k-1, j )
                 call stdlib_saxpy( mj, alpha, a( k-2, j ), lda, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( k, j ) = work( 1 )
              if( j<m ) then
                 ! compute work(2:m) = t(j, j) l(j, (j+1):m)
                  ! where a(j, j) stores t(j, j) and a(j-1, (j+1):m) stores u(j, (j+1):m)
                 if( k>1 ) then
                    alpha = -a( k, j )
                    call stdlib_saxpy( m-j, alpha, a( k-1, j+1 ), lda,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:m)|)
                 i2 = stdlib_isamax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply symmetric pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1, i1+1:m) with a(i1+1:m, i2)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_sswap( i2-i1-1, a( j1+i1-1, i1+1 ), lda,a( j1+i1, i2 ), 1 )
                              
                    ! swap a(i1, i2+1:m) with a(i2, i2+1:m)
                    if( i2<m )call stdlib_sswap( m-i2, a( j1+i1-1, i2+1 ), lda,a( j1+i2-1, i2+1 ),&
                               lda )
                    ! swap a(i1, i1) with a(i2,i2)
                    piv = a( i1+j1-1, i1 )
                    a( j1+i1-1, i1 ) = a( j1+i2-1, i2 )
                    a( j1+i2-1, i2 ) = piv
                    ! swap h(i1, 1:j1) with h(i2, 1:j1)
                    call stdlib_sswap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_sswap( i1-k1+1, a( 1, i1 ), 1,a( 1, i2 ), 1 )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j, j+1) = t(j, j+1)
                 a( k, j+1 ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:m, j+1) into h(j:m, j),
                    call stdlib_scopy( m-j, a( k+1, j+1 ), lda,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:m ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:m, j) = l(j+2:m, j+1)
                 if( j<(m-1) ) then
                    if( a( k, j+1 )/=zero ) then
                       alpha = one / a( k, j+1 )
                       call stdlib_scopy( m-j-1, work( 3 ), 1, a( k, j+2 ), lda )
                       call stdlib_sscal( m-j-1, alpha, a( k, j+2 ), lda )
                    else
                       call stdlib_slaset( 'FULL', 1, m-j-1, zero, zero,a( k, j+2 ), lda)
                    end if
                 end if
              end if
              j = j + 1
              go to 10
              20 continue
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              30 continue
              if( j>min( m, nb ) )go to 40
              ! k is the column to be factorized
               ! when being called from stdlib_ssytrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:m, j) := a(j:m, j) - h(j:m, 1:(j-1)) * l(j, j1:(j-1))^t,
               ! where h(j:m, j) has been initialized to be a(j:m, j)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_sgemv( 'NO TRANSPOSE', mj, j-k1,-one, h( j, k1 ), ldh,a( j, 1 ), lda,&
                           one, h( j, j ), 1 )
              end if
              ! copy h(j:m, j) into work
              call stdlib_scopy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j:m, j-1) * t(j-1,j),
                  ! where a(j-1, j) = t(j-1, j) and a(j, j-2) = l(j, j-1)
                 alpha = -a( j, k-1 )
                 call stdlib_saxpy( mj, alpha, a( j, k-2 ), 1, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( j, k ) = work( 1 )
              if( j<m ) then
                 ! compute work(2:m) = t(j, j) l((j+1):m, j)
                  ! where a(j, j) = t(j, j) and a((j+1):m, j-1) = l((j+1):m, j)
                 if( k>1 ) then
                    alpha = -a( j, k )
                    call stdlib_saxpy( m-j, alpha, a( j+1, k-1 ), 1,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:m)|)
                 i2 = stdlib_isamax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply symmetric pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1+1:m, i1) with a(i2, i1+1:m)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_sswap( i2-i1-1, a( i1+1, j1+i1-1 ), 1,a( i2, j1+i1 ), lda )
                              
                    ! swap a(i2+1:m, i1) with a(i2+1:m, i2)
                    if( i2<m )call stdlib_sswap( m-i2, a( i2+1, j1+i1-1 ), 1,a( i2+1, j1+i2-1 ), &
                              1 )
                    ! swap a(i1, i1) with a(i2, i2)
                    piv = a( i1, j1+i1-1 )
                    a( i1, j1+i1-1 ) = a( i2, j1+i2-1 )
                    a( i2, j1+i2-1 ) = piv
                    ! swap h(i1, i1:j1) with h(i2, i2:j1)
                    call stdlib_sswap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_sswap( i1-k1+1, a( i1, 1 ), lda,a( i2, 1 ), lda )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j+1, j) = t(j+1, j)
                 a( j+1, k ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:m, j+1) into h(j+1:m, j),
                    call stdlib_scopy( m-j, a( j+1, k+1 ), 1,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:m ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:m, j) = l(j+2:m, j+1)
                 if( j<(m-1) ) then
                    if( a( j+1, k )/=zero ) then
                       alpha = one / a( j+1, k )
                       call stdlib_scopy( m-j-1, work( 3 ), 1, a( j+2, k ), 1 )
                       call stdlib_sscal( m-j-1, alpha, a( j+2, k ), 1 )
                    else
                       call stdlib_slaset( 'FULL', m-j-1, 1, zero, zero,a( j+2, k ), lda )
                    end if
                 end if
              end if
              j = j + 1
              go to 30
              40 continue
           end if
           return
     end subroutine stdlib_slasyf_aa

     module pure subroutine stdlib_dlasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
     !! DLATRF_AA factorizes a panel of a real symmetric matrix A using
     !! the Aasen's algorithm. The panel consists of a set of NB rows of A
     !! when UPLO is U, or a set of NB columns when UPLO is L.
     !! In order to factorize the panel, the Aasen's algorithm requires the
     !! last row, or column, of the previous panel. The first row, or column,
     !! of A is set to be the first row, or column, of an identity matrix,
     !! which is used to factorize the first panel.
     !! The resulting J-th row of U, or J-th column of L, is stored in the
     !! (J-1)-th row, or column, of A (without the unit diagonals), while
     !! the diagonal and subdiagonal of A are overwritten by those of T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: m, nb, j1, lda, ldh
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*), h(ldh,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j, k, k1, i1, i2, mj
           real(dp) :: piv, alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           j = 1
           ! k1 is the first column of the panel to be factorized
           ! i.e.,  k1 is 2 for the first block column, and 1 for the rest of the blocks
           k1 = (2-j1)+1
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              10 continue
              if ( j>min(m, nb) )go to 20
              ! k is the column to be factorized
               ! when being called from stdlib_dsytrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:m, j) := a(j, j:m) - h(j:m, 1:(j-1)) * l(j1:(j-1), j),
               ! where h(j:m, j) has been initialized to be a(j, j:m)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_dgemv( 'NO TRANSPOSE', mj, j-k1,-one, h( j, k1 ), ldh,a( 1, j ), 1,&
                           one, h( j, j ), 1 )
              end if
              ! copy h(i:m, i) into work
              call stdlib_dcopy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j-1, j:m) * t(j-1,j),
                  ! where a(j-1, j) stores t(j-1, j) and a(j-2, j:m) stores u(j-1, j:m)
                 alpha = -a( k-1, j )
                 call stdlib_daxpy( mj, alpha, a( k-2, j ), lda, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( k, j ) = work( 1 )
              if( j<m ) then
                 ! compute work(2:m) = t(j, j) l(j, (j+1):m)
                  ! where a(j, j) stores t(j, j) and a(j-1, (j+1):m) stores u(j, (j+1):m)
                 if( k>1 ) then
                    alpha = -a( k, j )
                    call stdlib_daxpy( m-j, alpha, a( k-1, j+1 ), lda,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:m)|)
                 i2 = stdlib_idamax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply symmetric pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1, i1+1:m) with a(i1+1:m, i2)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_dswap( i2-i1-1, a( j1+i1-1, i1+1 ), lda,a( j1+i1, i2 ), 1 )
                              
                    ! swap a(i1, i2+1:m) with a(i2, i2+1:m)
                    if( i2<m )call stdlib_dswap( m-i2, a( j1+i1-1, i2+1 ), lda,a( j1+i2-1, i2+1 ),&
                               lda )
                    ! swap a(i1, i1) with a(i2,i2)
                    piv = a( i1+j1-1, i1 )
                    a( j1+i1-1, i1 ) = a( j1+i2-1, i2 )
                    a( j1+i2-1, i2 ) = piv
                    ! swap h(i1, 1:j1) with h(i2, 1:j1)
                    call stdlib_dswap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_dswap( i1-k1+1, a( 1, i1 ), 1,a( 1, i2 ), 1 )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j, j+1) = t(j, j+1)
                 a( k, j+1 ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:m, j+1) into h(j:m, j),
                    call stdlib_dcopy( m-j, a( k+1, j+1 ), lda,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:m ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:m, j) = l(j+2:m, j+1)
                 if( j<(m-1) ) then
                    if( a( k, j+1 )/=zero ) then
                       alpha = one / a( k, j+1 )
                       call stdlib_dcopy( m-j-1, work( 3 ), 1, a( k, j+2 ), lda )
                       call stdlib_dscal( m-j-1, alpha, a( k, j+2 ), lda )
                    else
                       call stdlib_dlaset( 'FULL', 1, m-j-1, zero, zero,a( k, j+2 ), lda)
                    end if
                 end if
              end if
              j = j + 1
              go to 10
              20 continue
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              30 continue
              if( j>min( m, nb ) )go to 40
              ! k is the column to be factorized
               ! when being called from stdlib_dsytrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:m, j) := a(j:m, j) - h(j:m, 1:(j-1)) * l(j, j1:(j-1))^t,
               ! where h(j:m, j) has been initialized to be a(j:m, j)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_dgemv( 'NO TRANSPOSE', mj, j-k1,-one, h( j, k1 ), ldh,a( j, 1 ), lda,&
                           one, h( j, j ), 1 )
              end if
              ! copy h(j:m, j) into work
              call stdlib_dcopy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j:m, j-1) * t(j-1,j),
                  ! where a(j-1, j) = t(j-1, j) and a(j, j-2) = l(j, j-1)
                 alpha = -a( j, k-1 )
                 call stdlib_daxpy( mj, alpha, a( j, k-2 ), 1, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( j, k ) = work( 1 )
              if( j<m ) then
                 ! compute work(2:m) = t(j, j) l((j+1):m, j)
                  ! where a(j, j) = t(j, j) and a((j+1):m, j-1) = l((j+1):m, j)
                 if( k>1 ) then
                    alpha = -a( j, k )
                    call stdlib_daxpy( m-j, alpha, a( j+1, k-1 ), 1,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:m)|)
                 i2 = stdlib_idamax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply symmetric pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1+1:m, i1) with a(i2, i1+1:m)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_dswap( i2-i1-1, a( i1+1, j1+i1-1 ), 1,a( i2, j1+i1 ), lda )
                              
                    ! swap a(i2+1:m, i1) with a(i2+1:m, i2)
                    if( i2<m )call stdlib_dswap( m-i2, a( i2+1, j1+i1-1 ), 1,a( i2+1, j1+i2-1 ), &
                              1 )
                    ! swap a(i1, i1) with a(i2, i2)
                    piv = a( i1, j1+i1-1 )
                    a( i1, j1+i1-1 ) = a( i2, j1+i2-1 )
                    a( i2, j1+i2-1 ) = piv
                    ! swap h(i1, i1:j1) with h(i2, i2:j1)
                    call stdlib_dswap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_dswap( i1-k1+1, a( i1, 1 ), lda,a( i2, 1 ), lda )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j+1, j) = t(j+1, j)
                 a( j+1, k ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:m, j+1) into h(j+1:m, j),
                    call stdlib_dcopy( m-j, a( j+1, k+1 ), 1,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:m ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:m, j) = l(j+2:m, j+1)
                 if( j<(m-1) ) then
                    if( a( j+1, k )/=zero ) then
                       alpha = one / a( j+1, k )
                       call stdlib_dcopy( m-j-1, work( 3 ), 1, a( j+2, k ), 1 )
                       call stdlib_dscal( m-j-1, alpha, a( j+2, k ), 1 )
                    else
                       call stdlib_dlaset( 'FULL', m-j-1, 1, zero, zero,a( j+2, k ), lda )
                    end if
                 end if
              end if
              j = j + 1
              go to 30
              40 continue
           end if
           return
     end subroutine stdlib_dlasyf_aa

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$lasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
     !! DLATRF_AA factorizes a panel of a real symmetric matrix A using
     !! the Aasen's algorithm. The panel consists of a set of NB rows of A
     !! when UPLO is U, or a set of NB columns when UPLO is L.
     !! In order to factorize the panel, the Aasen's algorithm requires the
     !! last row, or column, of the previous panel. The first row, or column,
     !! of A is set to be the first row, or column, of an identity matrix,
     !! which is used to factorize the first panel.
     !! The resulting J-th row of U, or J-th column of L, is stored in the
     !! (J-1)-th row, or column, of A (without the unit diagonals), while
     !! the diagonal and subdiagonal of A are overwritten by those of T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: m, nb, j1, lda, ldh
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), h(ldh,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j, k, k1, i1, i2, mj
           real(${rk}$) :: piv, alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           j = 1
           ! k1 is the first column of the panel to be factorized
           ! i.e.,  k1 is 2 for the first block column, and 1 for the rest of the blocks
           k1 = (2-j1)+1
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              10 continue
              if ( j>min(m, nb) )go to 20
              ! k is the column to be factorized
               ! when being called from stdlib_${ri}$sytrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:m, j) := a(j, j:m) - h(j:m, 1:(j-1)) * l(j1:(j-1), j),
               ! where h(j:m, j) has been initialized to be a(j, j:m)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', mj, j-k1,-one, h( j, k1 ), ldh,a( 1, j ), 1,&
                           one, h( j, j ), 1 )
              end if
              ! copy h(i:m, i) into work
              call stdlib_${ri}$copy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j-1, j:m) * t(j-1,j),
                  ! where a(j-1, j) stores t(j-1, j) and a(j-2, j:m) stores u(j-1, j:m)
                 alpha = -a( k-1, j )
                 call stdlib_${ri}$axpy( mj, alpha, a( k-2, j ), lda, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( k, j ) = work( 1 )
              if( j<m ) then
                 ! compute work(2:m) = t(j, j) l(j, (j+1):m)
                  ! where a(j, j) stores t(j, j) and a(j-1, (j+1):m) stores u(j, (j+1):m)
                 if( k>1 ) then
                    alpha = -a( k, j )
                    call stdlib_${ri}$axpy( m-j, alpha, a( k-1, j+1 ), lda,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:m)|)
                 i2 = stdlib_i${ri}$amax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply symmetric pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1, i1+1:m) with a(i1+1:m, i2)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_${ri}$swap( i2-i1-1, a( j1+i1-1, i1+1 ), lda,a( j1+i1, i2 ), 1 )
                              
                    ! swap a(i1, i2+1:m) with a(i2, i2+1:m)
                    if( i2<m )call stdlib_${ri}$swap( m-i2, a( j1+i1-1, i2+1 ), lda,a( j1+i2-1, i2+1 ),&
                               lda )
                    ! swap a(i1, i1) with a(i2,i2)
                    piv = a( i1+j1-1, i1 )
                    a( j1+i1-1, i1 ) = a( j1+i2-1, i2 )
                    a( j1+i2-1, i2 ) = piv
                    ! swap h(i1, 1:j1) with h(i2, 1:j1)
                    call stdlib_${ri}$swap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_${ri}$swap( i1-k1+1, a( 1, i1 ), 1,a( 1, i2 ), 1 )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j, j+1) = t(j, j+1)
                 a( k, j+1 ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:m, j+1) into h(j:m, j),
                    call stdlib_${ri}$copy( m-j, a( k+1, j+1 ), lda,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:m ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:m, j) = l(j+2:m, j+1)
                 if( j<(m-1) ) then
                    if( a( k, j+1 )/=zero ) then
                       alpha = one / a( k, j+1 )
                       call stdlib_${ri}$copy( m-j-1, work( 3 ), 1, a( k, j+2 ), lda )
                       call stdlib_${ri}$scal( m-j-1, alpha, a( k, j+2 ), lda )
                    else
                       call stdlib_${ri}$laset( 'FULL', 1, m-j-1, zero, zero,a( k, j+2 ), lda)
                    end if
                 end if
              end if
              j = j + 1
              go to 10
              20 continue
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              30 continue
              if( j>min( m, nb ) )go to 40
              ! k is the column to be factorized
               ! when being called from stdlib_${ri}$sytrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:m, j) := a(j:m, j) - h(j:m, 1:(j-1)) * l(j, j1:(j-1))^t,
               ! where h(j:m, j) has been initialized to be a(j:m, j)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', mj, j-k1,-one, h( j, k1 ), ldh,a( j, 1 ), lda,&
                           one, h( j, j ), 1 )
              end if
              ! copy h(j:m, j) into work
              call stdlib_${ri}$copy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j:m, j-1) * t(j-1,j),
                  ! where a(j-1, j) = t(j-1, j) and a(j, j-2) = l(j, j-1)
                 alpha = -a( j, k-1 )
                 call stdlib_${ri}$axpy( mj, alpha, a( j, k-2 ), 1, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( j, k ) = work( 1 )
              if( j<m ) then
                 ! compute work(2:m) = t(j, j) l((j+1):m, j)
                  ! where a(j, j) = t(j, j) and a((j+1):m, j-1) = l((j+1):m, j)
                 if( k>1 ) then
                    alpha = -a( j, k )
                    call stdlib_${ri}$axpy( m-j, alpha, a( j+1, k-1 ), 1,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:m)|)
                 i2 = stdlib_i${ri}$amax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply symmetric pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1+1:m, i1) with a(i2, i1+1:m)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_${ri}$swap( i2-i1-1, a( i1+1, j1+i1-1 ), 1,a( i2, j1+i1 ), lda )
                              
                    ! swap a(i2+1:m, i1) with a(i2+1:m, i2)
                    if( i2<m )call stdlib_${ri}$swap( m-i2, a( i2+1, j1+i1-1 ), 1,a( i2+1, j1+i2-1 ), &
                              1 )
                    ! swap a(i1, i1) with a(i2, i2)
                    piv = a( i1, j1+i1-1 )
                    a( i1, j1+i1-1 ) = a( i2, j1+i2-1 )
                    a( i2, j1+i2-1 ) = piv
                    ! swap h(i1, i1:j1) with h(i2, i2:j1)
                    call stdlib_${ri}$swap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_${ri}$swap( i1-k1+1, a( i1, 1 ), lda,a( i2, 1 ), lda )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j+1, j) = t(j+1, j)
                 a( j+1, k ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:m, j+1) into h(j+1:m, j),
                    call stdlib_${ri}$copy( m-j, a( j+1, k+1 ), 1,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:m ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:m, j) = l(j+2:m, j+1)
                 if( j<(m-1) ) then
                    if( a( j+1, k )/=zero ) then
                       alpha = one / a( j+1, k )
                       call stdlib_${ri}$copy( m-j-1, work( 3 ), 1, a( j+2, k ), 1 )
                       call stdlib_${ri}$scal( m-j-1, alpha, a( j+2, k ), 1 )
                    else
                       call stdlib_${ri}$laset( 'FULL', m-j-1, 1, zero, zero,a( j+2, k ), lda )
                    end if
                 end if
              end if
              j = j + 1
              go to 30
              40 continue
           end if
           return
     end subroutine stdlib_${ri}$lasyf_aa

#:endif
#:endfor

     module pure subroutine stdlib_clasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
     !! DLATRF_AA factorizes a panel of a complex symmetric matrix A using
     !! the Aasen's algorithm. The panel consists of a set of NB rows of A
     !! when UPLO is U, or a set of NB columns when UPLO is L.
     !! In order to factorize the panel, the Aasen's algorithm requires the
     !! last row, or column, of the previous panel. The first row, or column,
     !! of A is set to be the first row, or column, of an identity matrix,
     !! which is used to factorize the first panel.
     !! The resulting J-th row of U, or J-th column of L, is stored in the
     !! (J-1)-th row, or column, of A (without the unit diagonals), while
     !! the diagonal and subdiagonal of A are overwritten by those of T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: m, nb, j1, lda, ldh
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), h(ldh,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j, k, k1, i1, i2, mj
           complex(sp) :: piv, alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           j = 1
           ! k1 is the first column of the panel to be factorized
           ! i.e.,  k1 is 2 for the first block column, and 1 for the rest of the blocks
           k1 = (2-j1)+1
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              10 continue
              if ( j>min(m, nb) )go to 20
              ! k is the column to be factorized
               ! when being called from stdlib_csytrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:m, j) := a(j, j:m) - h(j:m, 1:(j-1)) * l(j1:(j-1), j),
               ! where h(j:m, j) has been initialized to be a(j, j:m)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_cgemv( 'NO TRANSPOSE', mj, j-k1,-cone, h( j, k1 ), ldh,a( 1, j ), 1,&
                           cone, h( j, j ), 1 )
              end if
              ! copy h(i:m, i) into work
              call stdlib_ccopy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j-1, j:m) * t(j-1,j),
                  ! where a(j-1, j) stores t(j-1, j) and a(j-2, j:m) stores u(j-1, j:m)
                 alpha = -a( k-1, j )
                 call stdlib_caxpy( mj, alpha, a( k-2, j ), lda, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( k, j ) = work( 1 )
              if( j<m ) then
                 ! compute work(2:m) = t(j, j) l(j, (j+1):m)
                  ! where a(j, j) stores t(j, j) and a(j-1, (j+1):m) stores u(j, (j+1):m)
                 if( k>1 ) then
                    alpha = -a( k, j )
                    call stdlib_caxpy( m-j, alpha, a( k-1, j+1 ), lda,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:m)|)
                 i2 = stdlib_icamax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply symmetric pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1, i1+1:m) with a(i1+1:m, i2)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_cswap( i2-i1-1, a( j1+i1-1, i1+1 ), lda,a( j1+i1, i2 ), 1 )
                              
                    ! swap a(i1, i2+1:m) with a(i2, i2+1:m)
                    if( i2<m )call stdlib_cswap( m-i2, a( j1+i1-1, i2+1 ), lda,a( j1+i2-1, i2+1 ),&
                               lda )
                    ! swap a(i1, i1) with a(i2,i2)
                    piv = a( i1+j1-1, i1 )
                    a( j1+i1-1, i1 ) = a( j1+i2-1, i2 )
                    a( j1+i2-1, i2 ) = piv
                    ! swap h(i1, 1:j1) with h(i2, 1:j1)
                    call stdlib_cswap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_cswap( i1-k1+1, a( 1, i1 ), 1,a( 1, i2 ), 1 )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j, j+1) = t(j, j+1)
                 a( k, j+1 ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:m, j+1) into h(j:m, j),
                    call stdlib_ccopy( m-j, a( k+1, j+1 ), lda,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:m ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:m, j) = l(j+2:m, j+1)
                 if( j<(m-1) ) then
                    if( a( k, j+1 )/=czero ) then
                       alpha = cone / a( k, j+1 )
                       call stdlib_ccopy( m-j-1, work( 3 ), 1, a( k, j+2 ), lda )
                       call stdlib_cscal( m-j-1, alpha, a( k, j+2 ), lda )
                    else
                       call stdlib_claset( 'FULL', 1, m-j-1, czero, czero,a( k, j+2 ), lda)
                                 
                    end if
                 end if
              end if
              j = j + 1
              go to 10
              20 continue
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              30 continue
              if( j>min( m, nb ) )go to 40
              ! k is the column to be factorized
               ! when being called from stdlib_csytrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:m, j) := a(j:m, j) - h(j:m, 1:(j-1)) * l(j, j1:(j-1))^t,
               ! where h(j:m, j) has been initialized to be a(j:m, j)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_cgemv( 'NO TRANSPOSE', mj, j-k1,-cone, h( j, k1 ), ldh,a( j, 1 ), &
                           lda,cone, h( j, j ), 1 )
              end if
              ! copy h(j:m, j) into work
              call stdlib_ccopy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j:m, j-1) * t(j-1,j),
                  ! where a(j-1, j) = t(j-1, j) and a(j, j-2) = l(j, j-1)
                 alpha = -a( j, k-1 )
                 call stdlib_caxpy( mj, alpha, a( j, k-2 ), 1, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( j, k ) = work( 1 )
              if( j<m ) then
                 ! compute work(2:m) = t(j, j) l((j+1):m, j)
                  ! where a(j, j) = t(j, j) and a((j+1):m, j-1) = l((j+1):m, j)
                 if( k>1 ) then
                    alpha = -a( j, k )
                    call stdlib_caxpy( m-j, alpha, a( j+1, k-1 ), 1,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:m)|)
                 i2 = stdlib_icamax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply symmetric pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1+1:m, i1) with a(i2, i1+1:m)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_cswap( i2-i1-1, a( i1+1, j1+i1-1 ), 1,a( i2, j1+i1 ), lda )
                              
                    ! swap a(i2+1:m, i1) with a(i2+1:m, i2)
                    if( i2<m )call stdlib_cswap( m-i2, a( i2+1, j1+i1-1 ), 1,a( i2+1, j1+i2-1 ), &
                              1 )
                    ! swap a(i1, i1) with a(i2, i2)
                    piv = a( i1, j1+i1-1 )
                    a( i1, j1+i1-1 ) = a( i2, j1+i2-1 )
                    a( i2, j1+i2-1 ) = piv
                    ! swap h(i1, i1:j1) with h(i2, i2:j1)
                    call stdlib_cswap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_cswap( i1-k1+1, a( i1, 1 ), lda,a( i2, 1 ), lda )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j+1, j) = t(j+1, j)
                 a( j+1, k ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:m, j+1) into h(j+1:m, j),
                    call stdlib_ccopy( m-j, a( j+1, k+1 ), 1,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:m ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:m, j) = l(j+2:m, j+1)
                 if( j<(m-1) ) then
                    if( a( j+1, k )/=czero ) then
                       alpha = cone / a( j+1, k )
                       call stdlib_ccopy( m-j-1, work( 3 ), 1, a( j+2, k ), 1 )
                       call stdlib_cscal( m-j-1, alpha, a( j+2, k ), 1 )
                    else
                       call stdlib_claset( 'FULL', m-j-1, 1, czero, czero,a( j+2, k ), lda )
                                 
                    end if
                 end if
              end if
              j = j + 1
              go to 30
              40 continue
           end if
           return
     end subroutine stdlib_clasyf_aa

     module pure subroutine stdlib_zlasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
     !! DLATRF_AA factorizes a panel of a complex symmetric matrix A using
     !! the Aasen's algorithm. The panel consists of a set of NB rows of A
     !! when UPLO is U, or a set of NB columns when UPLO is L.
     !! In order to factorize the panel, the Aasen's algorithm requires the
     !! last row, or column, of the previous panel. The first row, or column,
     !! of A is set to be the first row, or column, of an identity matrix,
     !! which is used to factorize the first panel.
     !! The resulting J-th row of U, or J-th column of L, is stored in the
     !! (J-1)-th row, or column, of A (without the unit diagonals), while
     !! the diagonal and subdiagonal of A are overwritten by those of T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: m, nb, j1, lda, ldh
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), h(ldh,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j, k, k1, i1, i2, mj
           complex(dp) :: piv, alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           j = 1
           ! k1 is the first column of the panel to be factorized
           ! i.e.,  k1 is 2 for the first block column, and 1 for the rest of the blocks
           k1 = (2-j1)+1
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              10 continue
              if ( j>min(m, nb) )go to 20
              ! k is the column to be factorized
               ! when being called from stdlib_zsytrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:m, j) := a(j, j:m) - h(j:m, 1:(j-1)) * l(j1:(j-1), j),
               ! where h(j:m, j) has been initialized to be a(j, j:m)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_zgemv( 'NO TRANSPOSE', mj, j-k1,-cone, h( j, k1 ), ldh,a( 1, j ), 1,&
                           cone, h( j, j ), 1 )
              end if
              ! copy h(i:m, i) into work
              call stdlib_zcopy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j-1, j:m) * t(j-1,j),
                  ! where a(j-1, j) stores t(j-1, j) and a(j-2, j:m) stores u(j-1, j:m)
                 alpha = -a( k-1, j )
                 call stdlib_zaxpy( mj, alpha, a( k-2, j ), lda, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( k, j ) = work( 1 )
              if( j<m ) then
                 ! compute work(2:m) = t(j, j) l(j, (j+1):m)
                  ! where a(j, j) stores t(j, j) and a(j-1, (j+1):m) stores u(j, (j+1):m)
                 if( k>1 ) then
                    alpha = -a( k, j )
                    call stdlib_zaxpy( m-j, alpha, a( k-1, j+1 ), lda,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:m)|)
                 i2 = stdlib_izamax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply symmetric pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1, i1+1:m) with a(i1+1:m, i2)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_zswap( i2-i1-1, a( j1+i1-1, i1+1 ), lda,a( j1+i1, i2 ), 1 )
                              
                    ! swap a(i1, i2+1:m) with a(i2, i2+1:m)
                    if( i2<m )call stdlib_zswap( m-i2, a( j1+i1-1, i2+1 ), lda,a( j1+i2-1, i2+1 ),&
                               lda )
                    ! swap a(i1, i1) with a(i2,i2)
                    piv = a( i1+j1-1, i1 )
                    a( j1+i1-1, i1 ) = a( j1+i2-1, i2 )
                    a( j1+i2-1, i2 ) = piv
                    ! swap h(i1, 1:j1) with h(i2, 1:j1)
                    call stdlib_zswap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_zswap( i1-k1+1, a( 1, i1 ), 1,a( 1, i2 ), 1 )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j, j+1) = t(j, j+1)
                 a( k, j+1 ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:m, j+1) into h(j:m, j),
                    call stdlib_zcopy( m-j, a( k+1, j+1 ), lda,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:m ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:m, j) = l(j+2:m, j+1)
                 if( j<(m-1) ) then
                    if( a( k, j+1 )/=czero ) then
                       alpha = cone / a( k, j+1 )
                       call stdlib_zcopy( m-j-1, work( 3 ), 1, a( k, j+2 ), lda )
                       call stdlib_zscal( m-j-1, alpha, a( k, j+2 ), lda )
                    else
                       call stdlib_zlaset( 'FULL', 1, m-j-1, czero, czero,a( k, j+2 ), lda)
                                 
                    end if
                 end if
              end if
              j = j + 1
              go to 10
              20 continue
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              30 continue
              if( j>min( m, nb ) )go to 40
              ! k is the column to be factorized
               ! when being called from stdlib_zsytrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:m, j) := a(j:m, j) - h(j:m, 1:(j-1)) * l(j, j1:(j-1))^t,
               ! where h(j:m, j) has been initialized to be a(j:m, j)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_zgemv( 'NO TRANSPOSE', mj, j-k1,-cone, h( j, k1 ), ldh,a( j, 1 ), &
                           lda,cone, h( j, j ), 1 )
              end if
              ! copy h(j:m, j) into work
              call stdlib_zcopy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j:m, j-1) * t(j-1,j),
                  ! where a(j-1, j) = t(j-1, j) and a(j, j-2) = l(j, j-1)
                 alpha = -a( j, k-1 )
                 call stdlib_zaxpy( mj, alpha, a( j, k-2 ), 1, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( j, k ) = work( 1 )
              if( j<m ) then
                 ! compute work(2:m) = t(j, j) l((j+1):m, j)
                  ! where a(j, j) = t(j, j) and a((j+1):m, j-1) = l((j+1):m, j)
                 if( k>1 ) then
                    alpha = -a( j, k )
                    call stdlib_zaxpy( m-j, alpha, a( j+1, k-1 ), 1,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:m)|)
                 i2 = stdlib_izamax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply symmetric pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1+1:m, i1) with a(i2, i1+1:m)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_zswap( i2-i1-1, a( i1+1, j1+i1-1 ), 1,a( i2, j1+i1 ), lda )
                              
                    ! swap a(i2+1:m, i1) with a(i2+1:m, i2)
                    if( i2<m )call stdlib_zswap( m-i2, a( i2+1, j1+i1-1 ), 1,a( i2+1, j1+i2-1 ), &
                              1 )
                    ! swap a(i1, i1) with a(i2, i2)
                    piv = a( i1, j1+i1-1 )
                    a( i1, j1+i1-1 ) = a( i2, j1+i2-1 )
                    a( i2, j1+i2-1 ) = piv
                    ! swap h(i1, i1:j1) with h(i2, i2:j1)
                    call stdlib_zswap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_zswap( i1-k1+1, a( i1, 1 ), lda,a( i2, 1 ), lda )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j+1, j) = t(j+1, j)
                 a( j+1, k ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:m, j+1) into h(j+1:m, j),
                    call stdlib_zcopy( m-j, a( j+1, k+1 ), 1,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:m ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:m, j) = l(j+2:m, j+1)
                 if( j<(m-1) ) then
                    if( a( j+1, k )/=czero ) then
                       alpha = cone / a( j+1, k )
                       call stdlib_zcopy( m-j-1, work( 3 ), 1, a( j+2, k ), 1 )
                       call stdlib_zscal( m-j-1, alpha, a( j+2, k ), 1 )
                    else
                       call stdlib_zlaset( 'FULL', m-j-1, 1, czero, czero,a( j+2, k ), lda )
                                 
                    end if
                 end if
              end if
              j = j + 1
              go to 30
              40 continue
           end if
           return
     end subroutine stdlib_zlasyf_aa

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$lasyf_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
     !! DLATRF_AA factorizes a panel of a complex symmetric matrix A using
     !! the Aasen's algorithm. The panel consists of a set of NB rows of A
     !! when UPLO is U, or a set of NB columns when UPLO is L.
     !! In order to factorize the panel, the Aasen's algorithm requires the
     !! last row, or column, of the previous panel. The first row, or column,
     !! of A is set to be the first row, or column, of an identity matrix,
     !! which is used to factorize the first panel.
     !! The resulting J-th row of U, or J-th column of L, is stored in the
     !! (J-1)-th row, or column, of A (without the unit diagonals), while
     !! the diagonal and subdiagonal of A are overwritten by those of T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: m, nb, j1, lda, ldh
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), h(ldh,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j, k, k1, i1, i2, mj
           complex(${ck}$) :: piv, alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           j = 1
           ! k1 is the first column of the panel to be factorized
           ! i.e.,  k1 is 2 for the first block column, and 1 for the rest of the blocks
           k1 = (2-j1)+1
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              10 continue
              if ( j>min(m, nb) )go to 20
              ! k is the column to be factorized
               ! when being called from stdlib_${ci}$sytrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:m, j) := a(j, j:m) - h(j:m, 1:(j-1)) * l(j1:(j-1), j),
               ! where h(j:m, j) has been initialized to be a(j, j:m)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_${ci}$gemv( 'NO TRANSPOSE', mj, j-k1,-cone, h( j, k1 ), ldh,a( 1, j ), 1,&
                           cone, h( j, j ), 1 )
              end if
              ! copy h(i:m, i) into work
              call stdlib_${ci}$copy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j-1, j:m) * t(j-1,j),
                  ! where a(j-1, j) stores t(j-1, j) and a(j-2, j:m) stores u(j-1, j:m)
                 alpha = -a( k-1, j )
                 call stdlib_${ci}$axpy( mj, alpha, a( k-2, j ), lda, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( k, j ) = work( 1 )
              if( j<m ) then
                 ! compute work(2:m) = t(j, j) l(j, (j+1):m)
                  ! where a(j, j) stores t(j, j) and a(j-1, (j+1):m) stores u(j, (j+1):m)
                 if( k>1 ) then
                    alpha = -a( k, j )
                    call stdlib_${ci}$axpy( m-j, alpha, a( k-1, j+1 ), lda,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:m)|)
                 i2 = stdlib_i${ci}$amax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply symmetric pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1, i1+1:m) with a(i1+1:m, i2)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_${ci}$swap( i2-i1-1, a( j1+i1-1, i1+1 ), lda,a( j1+i1, i2 ), 1 )
                              
                    ! swap a(i1, i2+1:m) with a(i2, i2+1:m)
                    if( i2<m )call stdlib_${ci}$swap( m-i2, a( j1+i1-1, i2+1 ), lda,a( j1+i2-1, i2+1 ),&
                               lda )
                    ! swap a(i1, i1) with a(i2,i2)
                    piv = a( i1+j1-1, i1 )
                    a( j1+i1-1, i1 ) = a( j1+i2-1, i2 )
                    a( j1+i2-1, i2 ) = piv
                    ! swap h(i1, 1:j1) with h(i2, 1:j1)
                    call stdlib_${ci}$swap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_${ci}$swap( i1-k1+1, a( 1, i1 ), 1,a( 1, i2 ), 1 )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j, j+1) = t(j, j+1)
                 a( k, j+1 ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:m, j+1) into h(j:m, j),
                    call stdlib_${ci}$copy( m-j, a( k+1, j+1 ), lda,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:m ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:m, j) = l(j+2:m, j+1)
                 if( j<(m-1) ) then
                    if( a( k, j+1 )/=czero ) then
                       alpha = cone / a( k, j+1 )
                       call stdlib_${ci}$copy( m-j-1, work( 3 ), 1, a( k, j+2 ), lda )
                       call stdlib_${ci}$scal( m-j-1, alpha, a( k, j+2 ), lda )
                    else
                       call stdlib_${ci}$laset( 'FULL', 1, m-j-1, czero, czero,a( k, j+2 ), lda)
                                 
                    end if
                 end if
              end if
              j = j + 1
              go to 10
              20 continue
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              30 continue
              if( j>min( m, nb ) )go to 40
              ! k is the column to be factorized
               ! when being called from stdlib_${ci}$sytrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:m, j) := a(j:m, j) - h(j:m, 1:(j-1)) * l(j, j1:(j-1))^t,
               ! where h(j:m, j) has been initialized to be a(j:m, j)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_${ci}$gemv( 'NO TRANSPOSE', mj, j-k1,-cone, h( j, k1 ), ldh,a( j, 1 ), &
                           lda,cone, h( j, j ), 1 )
              end if
              ! copy h(j:m, j) into work
              call stdlib_${ci}$copy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j:m, j-1) * t(j-1,j),
                  ! where a(j-1, j) = t(j-1, j) and a(j, j-2) = l(j, j-1)
                 alpha = -a( j, k-1 )
                 call stdlib_${ci}$axpy( mj, alpha, a( j, k-2 ), 1, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( j, k ) = work( 1 )
              if( j<m ) then
                 ! compute work(2:m) = t(j, j) l((j+1):m, j)
                  ! where a(j, j) = t(j, j) and a((j+1):m, j-1) = l((j+1):m, j)
                 if( k>1 ) then
                    alpha = -a( j, k )
                    call stdlib_${ci}$axpy( m-j, alpha, a( j+1, k-1 ), 1,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:m)|)
                 i2 = stdlib_i${ci}$amax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply symmetric pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1+1:m, i1) with a(i2, i1+1:m)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_${ci}$swap( i2-i1-1, a( i1+1, j1+i1-1 ), 1,a( i2, j1+i1 ), lda )
                              
                    ! swap a(i2+1:m, i1) with a(i2+1:m, i2)
                    if( i2<m )call stdlib_${ci}$swap( m-i2, a( i2+1, j1+i1-1 ), 1,a( i2+1, j1+i2-1 ), &
                              1 )
                    ! swap a(i1, i1) with a(i2, i2)
                    piv = a( i1, j1+i1-1 )
                    a( i1, j1+i1-1 ) = a( i2, j1+i2-1 )
                    a( i2, j1+i2-1 ) = piv
                    ! swap h(i1, i1:j1) with h(i2, i2:j1)
                    call stdlib_${ci}$swap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_${ci}$swap( i1-k1+1, a( i1, 1 ), lda,a( i2, 1 ), lda )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j+1, j) = t(j+1, j)
                 a( j+1, k ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:m, j+1) into h(j+1:m, j),
                    call stdlib_${ci}$copy( m-j, a( j+1, k+1 ), 1,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:m ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:m, j) = l(j+2:m, j+1)
                 if( j<(m-1) ) then
                    if( a( j+1, k )/=czero ) then
                       alpha = cone / a( j+1, k )
                       call stdlib_${ci}$copy( m-j-1, work( 3 ), 1, a( j+2, k ), 1 )
                       call stdlib_${ci}$scal( m-j-1, alpha, a( j+2, k ), 1 )
                    else
                       call stdlib_${ci}$laset( 'FULL', m-j-1, 1, czero, czero,a( j+2, k ), lda )
                                 
                    end if
                 end if
              end if
              j = j + 1
              go to 30
              40 continue
           end if
           return
     end subroutine stdlib_${ci}$lasyf_aa

#:endif
#:endfor







     module pure subroutine stdlib_ssytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
     !! SSYTRS_ROOK solves a system of linear equations A*X = B with
     !! a real symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by SSYTRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(in) :: a(lda,*)
           real(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           real(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYTRS_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_sger( k-1, nrhs, -one, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_sscal( nrhs, one / a( k, k ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k) then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_sswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k>2 ) then
                    call stdlib_sger( k-2, nrhs, -one, a( 1, k ), 1, b( k, 1 ),ldb, b( 1, 1 ), &
                              ldb )
                    call stdlib_sger( k-2, nrhs, -one, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ),&
                               ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 )call stdlib_sgemv( 'TRANSPOSE', k-1, nrhs, -one, b,ldb, a( 1, k ), 1, &
                           one, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_sgemv( 'TRANSPOSE', k-1, nrhs, -one, b,ldb, a( 1, k ), 1, one, b( &
                              k, 1 ), ldb )
                    call stdlib_sgemv( 'TRANSPOSE', k-1, nrhs, -one, b,ldb, a( 1, k+1 ), 1, one, &
                              b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k) then k+1 and -ipiv(k+1).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_sswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_sger( n-k, nrhs, -one, a( k+1, k ), 1, b( k, 1 ),ldb, b( k+&
                           1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_sscal( nrhs, one / a( k, k ), b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k) then k+1 and -ipiv(k+1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_sswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_sger( n-k-1, nrhs, -one, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, 1 &
                              ), ldb )
                    call stdlib_sger( n-k-1, nrhs, -one, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( k+&
                              2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / akm1k
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_sgemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+&
                           1, k ), 1, one, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_sgemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+1, k ),&
                               1, one, b( k, 1 ), ldb )
                    call stdlib_sgemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+1, k-1 &
                              ), 1, one, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k) then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_sswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_ssytrs_rook

     module pure subroutine stdlib_dsytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
     !! DSYTRS_ROOK solves a system of linear equations A*X = B with
     !! a real symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by DSYTRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(dp), intent(in) :: a(lda,*)
           real(dp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           real(dp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRS_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_dger( k-1, nrhs, -one, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_dscal( nrhs, one / a( k, k ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k) then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_dswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k>2 ) then
                    call stdlib_dger( k-2, nrhs, -one, a( 1, k ), 1, b( k, 1 ),ldb, b( 1, 1 ), &
                              ldb )
                    call stdlib_dger( k-2, nrhs, -one, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ),&
                               ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 )call stdlib_dgemv( 'TRANSPOSE', k-1, nrhs, -one, b,ldb, a( 1, k ), 1, &
                           one, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_dgemv( 'TRANSPOSE', k-1, nrhs, -one, b,ldb, a( 1, k ), 1, one, b( &
                              k, 1 ), ldb )
                    call stdlib_dgemv( 'TRANSPOSE', k-1, nrhs, -one, b,ldb, a( 1, k+1 ), 1, one, &
                              b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k) then k+1 and -ipiv(k+1).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_dswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_dger( n-k, nrhs, -one, a( k+1, k ), 1, b( k, 1 ),ldb, b( k+&
                           1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_dscal( nrhs, one / a( k, k ), b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k) then k+1 and -ipiv(k+1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_dswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_dger( n-k-1, nrhs, -one, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, 1 &
                              ), ldb )
                    call stdlib_dger( n-k-1, nrhs, -one, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( k+&
                              2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / akm1k
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_dgemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+&
                           1, k ), 1, one, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_dgemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+1, k ),&
                               1, one, b( k, 1 ), ldb )
                    call stdlib_dgemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+1, k-1 &
                              ), 1, one, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k) then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_dswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_dsytrs_rook

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
     !! DSYTRS_ROOK: solves a system of linear equations A*X = B with
     !! a real symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by DSYTRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           real(${rk}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRS_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_${ri}$ger( k-1, nrhs, -one, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_${ri}$scal( nrhs, one / a( k, k ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k) then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_${ri}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k>2 ) then
                    call stdlib_${ri}$ger( k-2, nrhs, -one, a( 1, k ), 1, b( k, 1 ),ldb, b( 1, 1 ), &
                              ldb )
                    call stdlib_${ri}$ger( k-2, nrhs, -one, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ),&
                               ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 )call stdlib_${ri}$gemv( 'TRANSPOSE', k-1, nrhs, -one, b,ldb, a( 1, k ), 1, &
                           one, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_${ri}$gemv( 'TRANSPOSE', k-1, nrhs, -one, b,ldb, a( 1, k ), 1, one, b( &
                              k, 1 ), ldb )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', k-1, nrhs, -one, b,ldb, a( 1, k+1 ), 1, one, &
                              b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k) then k+1 and -ipiv(k+1).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_${ri}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ri}$ger( n-k, nrhs, -one, a( k+1, k ), 1, b( k, 1 ),ldb, b( k+&
                           1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_${ri}$scal( nrhs, one / a( k, k ), b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k) then k+1 and -ipiv(k+1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_${ri}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_${ri}$ger( n-k-1, nrhs, -one, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, 1 &
                              ), ldb )
                    call stdlib_${ri}$ger( n-k-1, nrhs, -one, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( k+&
                              2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / akm1k
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ri}$gemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+&
                           1, k ), 1, one, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+1, k ),&
                               1, one, b( k, 1 ), ldb )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+1, k-1 &
                              ), 1, one, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k) then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_${ri}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_${ri}$sytrs_rook

#:endif
#:endfor

     module pure subroutine stdlib_csytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
     !! CSYTRS_ROOK solves a system of linear equations A*X = B with
     !! a complex symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by CSYTRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRS_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_cgeru( k-1, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_cscal( nrhs, cone / a( k, k ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k) then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k>2 ) then
                    call stdlib_cgeru( k-2, nrhs,-cone, a( 1, k ), 1, b( k, 1 ),ldb, b( 1, 1 ), &
                              ldb )
                    call stdlib_cgeru( k-2, nrhs,-cone, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 )&
                              , ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 )call stdlib_cgemv( 'TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), 1, &
                           cone, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_cgemv( 'TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), 1, cone, &
                              b( k, 1 ), ldb )
                    call stdlib_cgemv( 'TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k+1 ), 1, cone,&
                               b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k) then k+1 and -ipiv(k+1).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_cgeru( n-k, nrhs, -cone, a( k+1, k ), 1, b( k, 1 ),ldb, b( &
                           k+1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_cscal( nrhs, cone / a( k, k ), b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k) then k+1 and -ipiv(k+1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_cgeru( n-k-1, nrhs,-cone, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_cgeru( n-k-1, nrhs,-cone, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( k+&
                              2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / akm1k
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_cgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+&
                           1, k ), 1, cone, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_cgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+1, k )&
                              , 1, cone, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+1, k-&
                              1 ), 1, cone, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k) then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_csytrs_rook

     module pure subroutine stdlib_zsytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
     !! ZSYTRS_ROOK solves a system of linear equations A*X = B with
     !! a complex symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by ZSYTRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           complex(dp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRS_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_zgeru( k-1, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_zscal( nrhs, cone / a( k, k ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k) then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_zswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k>2 ) then
                    call stdlib_zgeru( k-2, nrhs,-cone, a( 1, k ), 1, b( k, 1 ),ldb, b( 1, 1 ), &
                              ldb )
                    call stdlib_zgeru( k-2, nrhs,-cone, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 )&
                              , ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 )call stdlib_zgemv( 'TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), 1, &
                           cone, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_zgemv( 'TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), 1, cone, &
                              b( k, 1 ), ldb )
                    call stdlib_zgemv( 'TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k+1 ), 1, cone,&
                               b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k) then k+1 and -ipiv(k+1).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_zswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_zgeru( n-k, nrhs, -cone, a( k+1, k ), 1, b( k, 1 ),ldb, b( &
                           k+1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_zscal( nrhs, cone / a( k, k ), b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k) then k+1 and -ipiv(k+1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_zswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_zgeru( n-k-1, nrhs,-cone, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_zgeru( n-k-1, nrhs,-cone, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( k+&
                              2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / akm1k
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_zgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+&
                           1, k ), 1, cone, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_zgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+1, k )&
                              , 1, cone, b( k, 1 ), ldb )
                    call stdlib_zgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+1, k-&
                              1 ), 1, cone, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k) then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_zswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_zsytrs_rook

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
     !! ZSYTRS_ROOK: solves a system of linear equations A*X = B with
     !! a complex symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by ZSYTRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           complex(${ck}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRS_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_${ci}$geru( k-1, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_${ci}$scal( nrhs, cone / a( k, k ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k) then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_${ci}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k>2 ) then
                    call stdlib_${ci}$geru( k-2, nrhs,-cone, a( 1, k ), 1, b( k, 1 ),ldb, b( 1, 1 ), &
                              ldb )
                    call stdlib_${ci}$geru( k-2, nrhs,-cone, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 )&
                              , ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 )call stdlib_${ci}$gemv( 'TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), 1, &
                           cone, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_${ci}$gemv( 'TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), 1, cone, &
                              b( k, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k+1 ), 1, cone,&
                               b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k) then k+1 and -ipiv(k+1).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_${ci}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ci}$geru( n-k, nrhs, -cone, a( k+1, k ), 1, b( k, 1 ),ldb, b( &
                           k+1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_${ci}$scal( nrhs, cone / a( k, k ), b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k) then k+1 and -ipiv(k+1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_${ci}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_${ci}$geru( n-k-1, nrhs,-cone, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_${ci}$geru( n-k-1, nrhs,-cone, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( k+&
                              2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / akm1k
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ci}$gemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+&
                           1, k ), 1, cone, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_${ci}$gemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+1, k )&
                              , 1, cone, b( k, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+1, k-&
                              1 ), 1, cone, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k) then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_${ci}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_${ci}$sytrs_rook

#:endif
#:endfor



     module pure subroutine stdlib_clahef_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
     !! CLAHEF_AA factorizes a panel of a complex hermitian matrix A using
     !! the Aasen's algorithm. The panel consists of a set of NB rows of A
     !! when UPLO is U, or a set of NB columns when UPLO is L.
     !! In order to factorize the panel, the Aasen's algorithm requires the
     !! last row, or column, of the previous panel. The first row, or column,
     !! of A is set to be the first row, or column, of an identity matrix,
     !! which is used to factorize the first panel.
     !! The resulting J-th row of U, or J-th column of L, is stored in the
     !! (J-1)-th row, or column, of A (without the unit diagonals), while
     !! the diagonal and subdiagonal of A are overwritten by those of T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: m, nb, j1, lda, ldh
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), h(ldh,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j, k, k1, i1, i2, mj
           complex(sp) :: piv, alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           j = 1
           ! k1 is the first column of the panel to be factorized
           ! i.e.,  k1 is 2 for the first block column, and 1 for the rest of the blocks
           k1 = (2-j1)+1
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              10 continue
              if ( j>min(m, nb) )go to 20
              ! k is the column to be factorized
               ! when being called from stdlib_chetrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:n, j) := a(j, j:n) - h(j:n, 1:(j-1)) * l(j1:(j-1), j),
               ! where h(j:n, j) has been initialized to be a(j, j:n)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_clacgv( j-k1, a( 1, j ), 1 )
                 call stdlib_cgemv( 'NO TRANSPOSE', mj, j-k1,-cone, h( j, k1 ), ldh,a( 1, j ), 1,&
                           cone, h( j, j ), 1 )
                 call stdlib_clacgv( j-k1, a( 1, j ), 1 )
              end if
              ! copy h(i:n, i) into work
              call stdlib_ccopy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j-1, j:n) * t(j-1,j),
                  ! where a(j-1, j) stores t(j-1, j) and a(j-2, j:n) stores u(j-1, j:n)
                 alpha = -conjg( a( k-1, j ) )
                 call stdlib_caxpy( mj, alpha, a( k-2, j ), lda, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( k, j ) = real( work( 1 ),KIND=sp)
              if( j<m ) then
                 ! compute work(2:n) = t(j, j) l(j, (j+1):n)
                  ! where a(j, j) stores t(j, j) and a(j-1, (j+1):n) stores u(j, (j+1):n)
                 if( k>1 ) then
                    alpha = -a( k, j )
                    call stdlib_caxpy( m-j, alpha, a( k-1, j+1 ), lda,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:n)|)
                 i2 = stdlib_icamax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply hermitian pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1, i1+1:n) with a(i1+1:n, i2)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_cswap( i2-i1-1, a( j1+i1-1, i1+1 ), lda,a( j1+i1, i2 ), 1 )
                              
                    call stdlib_clacgv( i2-i1, a( j1+i1-1, i1+1 ), lda )
                    call stdlib_clacgv( i2-i1-1, a( j1+i1, i2 ), 1 )
                    ! swap a(i1, i2+1:n) with a(i2, i2+1:n)
                    if( i2<m )call stdlib_cswap( m-i2, a( j1+i1-1, i2+1 ), lda,a( j1+i2-1, i2+1 ),&
                               lda )
                    ! swap a(i1, i1) with a(i2,i2)
                    piv = a( i1+j1-1, i1 )
                    a( j1+i1-1, i1 ) = a( j1+i2-1, i2 )
                    a( j1+i2-1, i2 ) = piv
                    ! swap h(i1, 1:j1) with h(i2, 1:j1)
                    call stdlib_cswap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_cswap( i1-k1+1, a( 1, i1 ), 1,a( 1, i2 ), 1 )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j, j+1) = t(j, j+1)
                 a( k, j+1 ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:n, j+1) into h(j:n, j),
                    call stdlib_ccopy( m-j, a( k+1, j+1 ), lda,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:n ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:n, j) = l(j+2:n, j+1)
                 if( j<(m-1) ) then
                    if( a( k, j+1 )/=czero ) then
                       alpha = cone / a( k, j+1 )
                       call stdlib_ccopy( m-j-1, work( 3 ), 1, a( k, j+2 ), lda )
                       call stdlib_cscal( m-j-1, alpha, a( k, j+2 ), lda )
                    else
                       call stdlib_claset( 'FULL', 1, m-j-1, czero, czero,a( k, j+2 ), lda)
                                 
                    end if
                 end if
              end if
              j = j + 1
              go to 10
              20 continue
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              30 continue
              if( j>min( m, nb ) )go to 40
              ! k is the column to be factorized
               ! when being called from stdlib_chetrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:n, j) := a(j:n, j) - h(j:n, 1:(j-1)) * l(j, j1:(j-1))^t,
               ! where h(j:n, j) has been initialized to be a(j:n, j)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_clacgv( j-k1, a( j, 1 ), lda )
                 call stdlib_cgemv( 'NO TRANSPOSE', mj, j-k1,-cone, h( j, k1 ), ldh,a( j, 1 ), &
                           lda,cone, h( j, j ), 1 )
                 call stdlib_clacgv( j-k1, a( j, 1 ), lda )
              end if
              ! copy h(j:n, j) into work
              call stdlib_ccopy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j:n, j-1) * t(j-1,j),
                  ! where a(j-1, j) = t(j-1, j) and a(j, j-2) = l(j, j-1)
                 alpha = -conjg( a( j, k-1 ) )
                 call stdlib_caxpy( mj, alpha, a( j, k-2 ), 1, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( j, k ) = real( work( 1 ),KIND=sp)
              if( j<m ) then
                 ! compute work(2:n) = t(j, j) l((j+1):n, j)
                  ! where a(j, j) = t(j, j) and a((j+1):n, j-1) = l((j+1):n, j)
                 if( k>1 ) then
                    alpha = -a( j, k )
                    call stdlib_caxpy( m-j, alpha, a( j+1, k-1 ), 1,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:n)|)
                 i2 = stdlib_icamax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply hermitian pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1+1:n, i1) with a(i2, i1+1:n)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_cswap( i2-i1-1, a( i1+1, j1+i1-1 ), 1,a( i2, j1+i1 ), lda )
                              
                    call stdlib_clacgv( i2-i1, a( i1+1, j1+i1-1 ), 1 )
                    call stdlib_clacgv( i2-i1-1, a( i2, j1+i1 ), lda )
                    ! swap a(i2+1:n, i1) with a(i2+1:n, i2)
                    if( i2<m )call stdlib_cswap( m-i2, a( i2+1, j1+i1-1 ), 1,a( i2+1, j1+i2-1 ), &
                              1 )
                    ! swap a(i1, i1) with a(i2, i2)
                    piv = a( i1, j1+i1-1 )
                    a( i1, j1+i1-1 ) = a( i2, j1+i2-1 )
                    a( i2, j1+i2-1 ) = piv
                    ! swap h(i1, i1:j1) with h(i2, i2:j1)
                    call stdlib_cswap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_cswap( i1-k1+1, a( i1, 1 ), lda,a( i2, 1 ), lda )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j+1, j) = t(j+1, j)
                 a( j+1, k ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:n, j+1) into h(j+1:n, j),
                    call stdlib_ccopy( m-j, a( j+1, k+1 ), 1,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:n ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:n, j) = l(j+2:n, j+1)
                 if( j<(m-1) ) then
                    if( a( j+1, k )/=czero ) then
                       alpha = cone / a( j+1, k )
                       call stdlib_ccopy( m-j-1, work( 3 ), 1, a( j+2, k ), 1 )
                       call stdlib_cscal( m-j-1, alpha, a( j+2, k ), 1 )
                    else
                       call stdlib_claset( 'FULL', m-j-1, 1, czero, czero,a( j+2, k ), lda )
                                 
                    end if
                 end if
              end if
              j = j + 1
              go to 30
              40 continue
           end if
           return
     end subroutine stdlib_clahef_aa

     module pure subroutine stdlib_zlahef_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
     !! DLAHEF_AA factorizes a panel of a complex hermitian matrix A using
     !! the Aasen's algorithm. The panel consists of a set of NB rows of A
     !! when UPLO is U, or a set of NB columns when UPLO is L.
     !! In order to factorize the panel, the Aasen's algorithm requires the
     !! last row, or column, of the previous panel. The first row, or column,
     !! of A is set to be the first row, or column, of an identity matrix,
     !! which is used to factorize the first panel.
     !! The resulting J-th row of U, or J-th column of L, is stored in the
     !! (J-1)-th row, or column, of A (without the unit diagonals), while
     !! the diagonal and subdiagonal of A are overwritten by those of T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: m, nb, j1, lda, ldh
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), h(ldh,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j, k, k1, i1, i2, mj
           complex(dp) :: piv, alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           j = 1
           ! k1 is the first column of the panel to be factorized
           ! i.e.,  k1 is 2 for the first block column, and 1 for the rest of the blocks
           k1 = (2-j1)+1
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              10 continue
              if ( j>min(m, nb) )go to 20
              ! k is the column to be factorized
               ! when being called from stdlib_zhetrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:n, j) := a(j, j:n) - h(j:n, 1:(j-1)) * l(j1:(j-1), j),
               ! where h(j:n, j) has been initialized to be a(j, j:n)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_zlacgv( j-k1, a( 1, j ), 1 )
                 call stdlib_zgemv( 'NO TRANSPOSE', mj, j-k1,-cone, h( j, k1 ), ldh,a( 1, j ), 1,&
                           cone, h( j, j ), 1 )
                 call stdlib_zlacgv( j-k1, a( 1, j ), 1 )
              end if
              ! copy h(i:n, i) into work
              call stdlib_zcopy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j-1, j:n) * t(j-1,j),
                  ! where a(j-1, j) stores t(j-1, j) and a(j-2, j:n) stores u(j-1, j:n)
                 alpha = -conjg( a( k-1, j ) )
                 call stdlib_zaxpy( mj, alpha, a( k-2, j ), lda, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( k, j ) = real( work( 1 ),KIND=dp)
              if( j<m ) then
                 ! compute work(2:n) = t(j, j) l(j, (j+1):n)
                  ! where a(j, j) stores t(j, j) and a(j-1, (j+1):n) stores u(j, (j+1):n)
                 if( k>1 ) then
                    alpha = -a( k, j )
                    call stdlib_zaxpy( m-j, alpha, a( k-1, j+1 ), lda,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:n)|)
                 i2 = stdlib_izamax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply hermitian pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1, i1+1:n) with a(i1+1:n, i2)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_zswap( i2-i1-1, a( j1+i1-1, i1+1 ), lda,a( j1+i1, i2 ), 1 )
                              
                    call stdlib_zlacgv( i2-i1, a( j1+i1-1, i1+1 ), lda )
                    call stdlib_zlacgv( i2-i1-1, a( j1+i1, i2 ), 1 )
                    ! swap a(i1, i2+1:n) with a(i2, i2+1:n)
                    if( i2<m )call stdlib_zswap( m-i2, a( j1+i1-1, i2+1 ), lda,a( j1+i2-1, i2+1 ),&
                               lda )
                    ! swap a(i1, i1) with a(i2,i2)
                    piv = a( i1+j1-1, i1 )
                    a( j1+i1-1, i1 ) = a( j1+i2-1, i2 )
                    a( j1+i2-1, i2 ) = piv
                    ! swap h(i1, 1:j1) with h(i2, 1:j1)
                    call stdlib_zswap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_zswap( i1-k1+1, a( 1, i1 ), 1,a( 1, i2 ), 1 )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j, j+1) = t(j, j+1)
                 a( k, j+1 ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:n, j+1) into h(j:n, j),
                    call stdlib_zcopy( m-j, a( k+1, j+1 ), lda,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:n ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:n, j) = l(j+2:n, j+1)
                 if( j<(m-1) ) then
                    if( a( k, j+1 )/=czero ) then
                       alpha = cone / a( k, j+1 )
                       call stdlib_zcopy( m-j-1, work( 3 ), 1, a( k, j+2 ), lda )
                       call stdlib_zscal( m-j-1, alpha, a( k, j+2 ), lda )
                    else
                       call stdlib_zlaset( 'FULL', 1, m-j-1, czero, czero,a( k, j+2 ), lda)
                                 
                    end if
                 end if
              end if
              j = j + 1
              go to 10
              20 continue
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              30 continue
              if( j>min( m, nb ) )go to 40
              ! k is the column to be factorized
               ! when being called from stdlib_zhetrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:n, j) := a(j:n, j) - h(j:n, 1:(j-1)) * l(j, j1:(j-1))^t,
               ! where h(j:n, j) has been initialized to be a(j:n, j)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_zlacgv( j-k1, a( j, 1 ), lda )
                 call stdlib_zgemv( 'NO TRANSPOSE', mj, j-k1,-cone, h( j, k1 ), ldh,a( j, 1 ), &
                           lda,cone, h( j, j ), 1 )
                 call stdlib_zlacgv( j-k1, a( j, 1 ), lda )
              end if
              ! copy h(j:n, j) into work
              call stdlib_zcopy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j:n, j-1) * t(j-1,j),
                  ! where a(j-1, j) = t(j-1, j) and a(j, j-2) = l(j, j-1)
                 alpha = -conjg( a( j, k-1 ) )
                 call stdlib_zaxpy( mj, alpha, a( j, k-2 ), 1, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( j, k ) = real( work( 1 ),KIND=dp)
              if( j<m ) then
                 ! compute work(2:n) = t(j, j) l((j+1):n, j)
                  ! where a(j, j) = t(j, j) and a((j+1):n, j-1) = l((j+1):n, j)
                 if( k>1 ) then
                    alpha = -a( j, k )
                    call stdlib_zaxpy( m-j, alpha, a( j+1, k-1 ), 1,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:n)|)
                 i2 = stdlib_izamax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply hermitian pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1+1:n, i1) with a(i2, i1+1:n)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_zswap( i2-i1-1, a( i1+1, j1+i1-1 ), 1,a( i2, j1+i1 ), lda )
                              
                    call stdlib_zlacgv( i2-i1, a( i1+1, j1+i1-1 ), 1 )
                    call stdlib_zlacgv( i2-i1-1, a( i2, j1+i1 ), lda )
                    ! swap a(i2+1:n, i1) with a(i2+1:n, i2)
                    if( i2<m )call stdlib_zswap( m-i2, a( i2+1, j1+i1-1 ), 1,a( i2+1, j1+i2-1 ), &
                              1 )
                    ! swap a(i1, i1) with a(i2, i2)
                    piv = a( i1, j1+i1-1 )
                    a( i1, j1+i1-1 ) = a( i2, j1+i2-1 )
                    a( i2, j1+i2-1 ) = piv
                    ! swap h(i1, i1:j1) with h(i2, i2:j1)
                    call stdlib_zswap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_zswap( i1-k1+1, a( i1, 1 ), lda,a( i2, 1 ), lda )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j+1, j) = t(j+1, j)
                 a( j+1, k ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:n, j+1) into h(j+1:n, j),
                    call stdlib_zcopy( m-j, a( j+1, k+1 ), 1,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:n ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:n, j) = l(j+2:n, j+1)
                 if( j<(m-1) ) then
                    if( a( j+1, k )/=czero ) then
                       alpha = cone / a( j+1, k )
                       call stdlib_zcopy( m-j-1, work( 3 ), 1, a( j+2, k ), 1 )
                       call stdlib_zscal( m-j-1, alpha, a( j+2, k ), 1 )
                    else
                       call stdlib_zlaset( 'FULL', m-j-1, 1, czero, czero,a( j+2, k ), lda )
                                 
                    end if
                 end if
              end if
              j = j + 1
              go to 30
              40 continue
           end if
           return
     end subroutine stdlib_zlahef_aa

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$lahef_aa( uplo, j1, m, nb, a, lda, ipiv,h, ldh, work )
     !! DLAHEF_AA factorizes a panel of a complex hermitian matrix A using
     !! the Aasen's algorithm. The panel consists of a set of NB rows of A
     !! when UPLO is U, or a set of NB columns when UPLO is L.
     !! In order to factorize the panel, the Aasen's algorithm requires the
     !! last row, or column, of the previous panel. The first row, or column,
     !! of A is set to be the first row, or column, of an identity matrix,
     !! which is used to factorize the first panel.
     !! The resulting J-th row of U, or J-th column of L, is stored in the
     !! (J-1)-th row, or column, of A (without the unit diagonals), while
     !! the diagonal and subdiagonal of A are overwritten by those of T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: m, nb, j1, lda, ldh
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), h(ldh,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: j, k, k1, i1, i2, mj
           complex(${ck}$) :: piv, alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           j = 1
           ! k1 is the first column of the panel to be factorized
           ! i.e.,  k1 is 2 for the first block column, and 1 for the rest of the blocks
           k1 = (2-j1)+1
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              10 continue
              if ( j>min(m, nb) )go to 20
              ! k is the column to be factorized
               ! when being called from stdlib_${ci}$hetrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:n, j) := a(j, j:n) - h(j:n, 1:(j-1)) * l(j1:(j-1), j),
               ! where h(j:n, j) has been initialized to be a(j, j:n)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_${ci}$lacgv( j-k1, a( 1, j ), 1 )
                 call stdlib_${ci}$gemv( 'NO TRANSPOSE', mj, j-k1,-cone, h( j, k1 ), ldh,a( 1, j ), 1,&
                           cone, h( j, j ), 1 )
                 call stdlib_${ci}$lacgv( j-k1, a( 1, j ), 1 )
              end if
              ! copy h(i:n, i) into work
              call stdlib_${ci}$copy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j-1, j:n) * t(j-1,j),
                  ! where a(j-1, j) stores t(j-1, j) and a(j-2, j:n) stores u(j-1, j:n)
                 alpha = -conjg( a( k-1, j ) )
                 call stdlib_${ci}$axpy( mj, alpha, a( k-2, j ), lda, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( k, j ) = real( work( 1 ),KIND=${ck}$)
              if( j<m ) then
                 ! compute work(2:n) = t(j, j) l(j, (j+1):n)
                  ! where a(j, j) stores t(j, j) and a(j-1, (j+1):n) stores u(j, (j+1):n)
                 if( k>1 ) then
                    alpha = -a( k, j )
                    call stdlib_${ci}$axpy( m-j, alpha, a( k-1, j+1 ), lda,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:n)|)
                 i2 = stdlib_i${ci}$amax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply hermitian pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1, i1+1:n) with a(i1+1:n, i2)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_${ci}$swap( i2-i1-1, a( j1+i1-1, i1+1 ), lda,a( j1+i1, i2 ), 1 )
                              
                    call stdlib_${ci}$lacgv( i2-i1, a( j1+i1-1, i1+1 ), lda )
                    call stdlib_${ci}$lacgv( i2-i1-1, a( j1+i1, i2 ), 1 )
                    ! swap a(i1, i2+1:n) with a(i2, i2+1:n)
                    if( i2<m )call stdlib_${ci}$swap( m-i2, a( j1+i1-1, i2+1 ), lda,a( j1+i2-1, i2+1 ),&
                               lda )
                    ! swap a(i1, i1) with a(i2,i2)
                    piv = a( i1+j1-1, i1 )
                    a( j1+i1-1, i1 ) = a( j1+i2-1, i2 )
                    a( j1+i2-1, i2 ) = piv
                    ! swap h(i1, 1:j1) with h(i2, 1:j1)
                    call stdlib_${ci}$swap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_${ci}$swap( i1-k1+1, a( 1, i1 ), 1,a( 1, i2 ), 1 )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j, j+1) = t(j, j+1)
                 a( k, j+1 ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:n, j+1) into h(j:n, j),
                    call stdlib_${ci}$copy( m-j, a( k+1, j+1 ), lda,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:n ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:n, j) = l(j+2:n, j+1)
                 if( j<(m-1) ) then
                    if( a( k, j+1 )/=czero ) then
                       alpha = cone / a( k, j+1 )
                       call stdlib_${ci}$copy( m-j-1, work( 3 ), 1, a( k, j+2 ), lda )
                       call stdlib_${ci}$scal( m-j-1, alpha, a( k, j+2 ), lda )
                    else
                       call stdlib_${ci}$laset( 'FULL', 1, m-j-1, czero, czero,a( k, j+2 ), lda)
                                 
                    end if
                 end if
              end if
              j = j + 1
              go to 10
              20 continue
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              30 continue
              if( j>min( m, nb ) )go to 40
              ! k is the column to be factorized
               ! when being called from stdlib_${ci}$hetrf_aa,
               ! > for the first block column, j1 is 1, hence j1+j-1 is j,
               ! > for the rest of the columns, j1 is 2, and j1+j-1 is j+1,
              k = j1+j-1
              if( j==m ) then
                  ! only need to compute t(j, j)
                  mj = 1
              else
                  mj = m-j+1
              end if
              ! h(j:n, j) := a(j:n, j) - h(j:n, 1:(j-1)) * l(j, j1:(j-1))^t,
               ! where h(j:n, j) has been initialized to be a(j:n, j)
              if( k>2 ) then
              ! k is the column to be factorized
               ! > for the first block column, k is j, skipping the first two
                 ! columns
               ! > for the rest of the columns, k is j+1, skipping only the
                 ! first column
                 call stdlib_${ci}$lacgv( j-k1, a( j, 1 ), lda )
                 call stdlib_${ci}$gemv( 'NO TRANSPOSE', mj, j-k1,-cone, h( j, k1 ), ldh,a( j, 1 ), &
                           lda,cone, h( j, j ), 1 )
                 call stdlib_${ci}$lacgv( j-k1, a( j, 1 ), lda )
              end if
              ! copy h(j:n, j) into work
              call stdlib_${ci}$copy( mj, h( j, j ), 1, work( 1 ), 1 )
              if( j>k1 ) then
                 ! compute work := work - l(j:n, j-1) * t(j-1,j),
                  ! where a(j-1, j) = t(j-1, j) and a(j, j-2) = l(j, j-1)
                 alpha = -conjg( a( j, k-1 ) )
                 call stdlib_${ci}$axpy( mj, alpha, a( j, k-2 ), 1, work( 1 ), 1 )
              end if
              ! set a(j, j) = t(j, j)
              a( j, k ) = real( work( 1 ),KIND=${ck}$)
              if( j<m ) then
                 ! compute work(2:n) = t(j, j) l((j+1):n, j)
                  ! where a(j, j) = t(j, j) and a((j+1):n, j-1) = l((j+1):n, j)
                 if( k>1 ) then
                    alpha = -a( j, k )
                    call stdlib_${ci}$axpy( m-j, alpha, a( j+1, k-1 ), 1,work( 2 ), 1 )
                 endif
                 ! find max(|work(2:n)|)
                 i2 = stdlib_i${ci}$amax( m-j, work( 2 ), 1 ) + 1
                 piv = work( i2 )
                 ! apply hermitian pivot
                 if( (i2/=2) .and. (piv/=0) ) then
                    ! swap work(i1) and work(i2)
                    i1 = 2
                    work( i2 ) = work( i1 )
                    work( i1 ) = piv
                    ! swap a(i1+1:n, i1) with a(i2, i1+1:n)
                    i1 = i1+j-1
                    i2 = i2+j-1
                    call stdlib_${ci}$swap( i2-i1-1, a( i1+1, j1+i1-1 ), 1,a( i2, j1+i1 ), lda )
                              
                    call stdlib_${ci}$lacgv( i2-i1, a( i1+1, j1+i1-1 ), 1 )
                    call stdlib_${ci}$lacgv( i2-i1-1, a( i2, j1+i1 ), lda )
                    ! swap a(i2+1:n, i1) with a(i2+1:n, i2)
                    if( i2<m )call stdlib_${ci}$swap( m-i2, a( i2+1, j1+i1-1 ), 1,a( i2+1, j1+i2-1 ), &
                              1 )
                    ! swap a(i1, i1) with a(i2, i2)
                    piv = a( i1, j1+i1-1 )
                    a( i1, j1+i1-1 ) = a( i2, j1+i2-1 )
                    a( i2, j1+i2-1 ) = piv
                    ! swap h(i1, i1:j1) with h(i2, i2:j1)
                    call stdlib_${ci}$swap( i1-1, h( i1, 1 ), ldh, h( i2, 1 ), ldh )
                    ipiv( i1 ) = i2
                    if( i1>(k1-1) ) then
                       ! swap l(1:i1-1, i1) with l(1:i1-1, i2),
                        ! skipping the first column
                       call stdlib_${ci}$swap( i1-k1+1, a( i1, 1 ), lda,a( i2, 1 ), lda )
                    end if
                 else
                    ipiv( j+1 ) = j+1
                 endif
                 ! set a(j+1, j) = t(j+1, j)
                 a( j+1, k ) = work( 2 )
                 if( j<nb ) then
                    ! copy a(j+1:n, j+1) into h(j+1:n, j),
                    call stdlib_${ci}$copy( m-j, a( j+1, k+1 ), 1,h( j+1, j+1 ), 1 )
                 end if
                 ! compute l(j+2, j+1) = work( 3:n ) / t(j, j+1),
                  ! where a(j, j+1) = t(j, j+1) and a(j+2:n, j) = l(j+2:n, j+1)
                 if( j<(m-1) ) then
                    if( a( j+1, k )/=czero ) then
                       alpha = cone / a( j+1, k )
                       call stdlib_${ci}$copy( m-j-1, work( 3 ), 1, a( j+2, k ), 1 )
                       call stdlib_${ci}$scal( m-j-1, alpha, a( j+2, k ), 1 )
                    else
                       call stdlib_${ci}$laset( 'FULL', m-j-1, 1, czero, czero,a( j+2, k ), lda )
                                 
                    end if
                 end if
              end if
              j = j + 1
              go to 30
              40 continue
           end if
           return
     end subroutine stdlib_${ci}$lahef_aa

#:endif
#:endfor







     module pure subroutine stdlib_chetri_rook( uplo, n, a, lda, ipiv, work, info )
     !! CHETRI_ROOK computes the inverse of a complex Hermitian indefinite matrix
     !! A using the factorization A = U*D*U**H or A = L*D*L**H computed by
     !! CHETRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp, kstep
           real(sp) :: ak, akp1, d, t
           complex(sp) :: akkp1, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRI_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 70
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / real( a( k, k ),KIND=sp)
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_chemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - real( stdlib_cdotc( k-1, work, 1, a( 1,k ), 1 ),&
                              KIND=sp)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k+1 ) )
                 ak = real( a( k, k ),KIND=sp) / t
                 akp1 = real( a( k+1, k+1 ),KIND=sp) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-one )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_chemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - real( stdlib_cdotc( k-1, work, 1, a( 1,k ), 1 ),&
                              KIND=sp)
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_cdotc( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_ccopy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_chemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -real( stdlib_cdotc( k-1, work, 1, a( 1, k+1 ),&
                              1 ),KIND=sp)
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the leading
                 ! submatrix a(1:k,1:k)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    do j = kp + 1, k - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k+1 with -ipiv(k) and
                 ! -ipiv(k+1) in the leading submatrix a(k+1:n,k+1:n)
                 ! (1) interchange rows and columns k and -ipiv(k)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    do j = kp + 1, k - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
                 ! (2) interchange rows and columns k+1 and -ipiv(k+1)
                 k = k + 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    do j = kp + 1, k - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k + 1
              go to 30
              70 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**h.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              80 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 120
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / real( a( k, k ),KIND=sp)
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_chemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - real( stdlib_cdotc( n-k, work, 1,a( k+1, k ), 1 ),&
                              KIND=sp)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k-1 ) )
                 ak = real( a( k-1, k-1 ),KIND=sp) / t
                 akp1 = real( a( k, k ),KIND=sp) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-one )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_chemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - real( stdlib_cdotc( n-k, work, 1,a( k+1, k ), 1 ),&
                              KIND=sp)
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_cdotc( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 &
                              )
                    call stdlib_ccopy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_chemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -real( stdlib_cdotc( n-k, work, 1, a( k+1, k-1 )&
                              ,1 ),KIND=sp)
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the trailing
                 ! submatrix a(k:n,k:n)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    do j = k + 1, kp - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k-1 with -ipiv(k) and
                 ! -ipiv(k-1) in the trailing submatrix a(k-1:n,k-1:n)
                 ! (1) interchange rows and columns k and -ipiv(k)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    do j = k + 1, kp - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
                 ! (2) interchange rows and columns k-1 and -ipiv(k-1)
                 k = k - 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    do j = k + 1, kp - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k - 1
              go to 80
              120 continue
           end if
           return
     end subroutine stdlib_chetri_rook

     module pure subroutine stdlib_zhetri_rook( uplo, n, a, lda, ipiv, work, info )
     !! ZHETRI_ROOK computes the inverse of a complex Hermitian indefinite matrix
     !! A using the factorization A = U*D*U**H or A = L*D*L**H computed by
     !! ZHETRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp, kstep
           real(dp) :: ak, akp1, d, t
           complex(dp) :: akkp1, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRI_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 70
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / real( a( k, k ),KIND=dp)
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_zcopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_zhemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - real( stdlib_zdotc( k-1, work, 1, a( 1,k ), 1 ),&
                              KIND=dp)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k+1 ) )
                 ak = real( a( k, k ),KIND=dp) / t
                 akp1 = real( a( k+1, k+1 ),KIND=dp) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-one )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_zcopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_zhemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - real( stdlib_zdotc( k-1, work, 1, a( 1,k ), 1 ),&
                              KIND=dp)
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_zdotc( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_zcopy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_zhemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -real( stdlib_zdotc( k-1, work, 1, a( 1, k+1 ),&
                              1 ),KIND=dp)
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the leading
                 ! submatrix a(1:k,1:k)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_zswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    do j = kp + 1, k - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k+1 with -ipiv(k) and
                 ! -ipiv(k+1) in the leading submatrix a(k+1:n,k+1:n)
                 ! (1) interchange rows and columns k and -ipiv(k)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_zswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    do j = kp + 1, k - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
                 ! (2) interchange rows and columns k+1 and -ipiv(k+1)
                 k = k + 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_zswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    do j = kp + 1, k - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k + 1
              go to 30
              70 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**h.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              80 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 120
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / real( a( k, k ),KIND=dp)
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_zcopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_zhemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - real( stdlib_zdotc( n-k, work, 1,a( k+1, k ), 1 ),&
                              KIND=dp)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k-1 ) )
                 ak = real( a( k-1, k-1 ),KIND=dp) / t
                 akp1 = real( a( k, k ),KIND=dp) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-one )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_zcopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_zhemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - real( stdlib_zdotc( n-k, work, 1,a( k+1, k ), 1 ),&
                              KIND=dp)
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_zdotc( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 &
                              )
                    call stdlib_zcopy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_zhemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -real( stdlib_zdotc( n-k, work, 1, a( k+1, k-1 )&
                              ,1 ),KIND=dp)
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the trailing
                 ! submatrix a(k:n,k:n)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_zswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    do j = k + 1, kp - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k-1 with -ipiv(k) and
                 ! -ipiv(k-1) in the trailing submatrix a(k-1:n,k-1:n)
                 ! (1) interchange rows and columns k and -ipiv(k)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_zswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    do j = k + 1, kp - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
                 ! (2) interchange rows and columns k-1 and -ipiv(k-1)
                 k = k - 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_zswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    do j = k + 1, kp - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k - 1
              go to 80
              120 continue
           end if
           return
     end subroutine stdlib_zhetri_rook

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hetri_rook( uplo, n, a, lda, ipiv, work, info )
     !! ZHETRI_ROOK: computes the inverse of a complex Hermitian indefinite matrix
     !! A using the factorization A = U*D*U**H or A = L*D*L**H computed by
     !! ZHETRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp, kstep
           real(${ck}$) :: ak, akp1, d, t
           complex(${ck}$) :: akkp1, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRI_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 70
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / real( a( k, k ),KIND=${ck}$)
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_${ci}$copy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_${ci}$hemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - real( stdlib_${ci}$dotc( k-1, work, 1, a( 1,k ), 1 ),&
                              KIND=${ck}$)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k+1 ) )
                 ak = real( a( k, k ),KIND=${ck}$) / t
                 akp1 = real( a( k+1, k+1 ),KIND=${ck}$) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-one )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_${ci}$copy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_${ci}$hemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - real( stdlib_${ci}$dotc( k-1, work, 1, a( 1,k ), 1 ),&
                              KIND=${ck}$)
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_${ci}$dotc( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_${ci}$copy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_${ci}$hemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -real( stdlib_${ci}$dotc( k-1, work, 1, a( 1, k+1 ),&
                              1 ),KIND=${ck}$)
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the leading
                 ! submatrix a(1:k,1:k)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_${ci}$swap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    do j = kp + 1, k - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k+1 with -ipiv(k) and
                 ! -ipiv(k+1) in the leading submatrix a(k+1:n,k+1:n)
                 ! (1) interchange rows and columns k and -ipiv(k)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_${ci}$swap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    do j = kp + 1, k - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
                 ! (2) interchange rows and columns k+1 and -ipiv(k+1)
                 k = k + 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp>1 )call stdlib_${ci}$swap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                    do j = kp + 1, k - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k + 1
              go to 30
              70 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**h.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              80 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 120
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / real( a( k, k ),KIND=${ck}$)
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_${ci}$copy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_${ci}$hemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - real( stdlib_${ci}$dotc( n-k, work, 1,a( k+1, k ), 1 ),&
                              KIND=${ck}$)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k-1 ) )
                 ak = real( a( k-1, k-1 ),KIND=${ck}$) / t
                 akp1 = real( a( k, k ),KIND=${ck}$) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-one )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_${ci}$copy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_${ci}$hemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - real( stdlib_${ci}$dotc( n-k, work, 1,a( k+1, k ), 1 ),&
                              KIND=${ck}$)
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_${ci}$dotc( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 &
                              )
                    call stdlib_${ci}$copy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_${ci}$hemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -real( stdlib_${ci}$dotc( n-k, work, 1, a( k+1, k-1 )&
                              ,1 ),KIND=${ck}$)
                 end if
                 kstep = 2
              end if
              if( kstep==1 ) then
                 ! interchange rows and columns k and ipiv(k) in the trailing
                 ! submatrix a(k:n,k:n)
                 kp = ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_${ci}$swap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    do j = k + 1, kp - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              else
                 ! interchange rows and columns k and k-1 with -ipiv(k) and
                 ! -ipiv(k-1) in the trailing submatrix a(k-1:n,k-1:n)
                 ! (1) interchange rows and columns k and -ipiv(k)
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_${ci}$swap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    do j = k + 1, kp - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
                 ! (2) interchange rows and columns k-1 and -ipiv(k-1)
                 k = k - 1
                 kp = -ipiv( k )
                 if( kp/=k ) then
                    if( kp<n )call stdlib_${ci}$swap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                    do j = k + 1, kp - 1
                       temp = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( kp, j ) )
                       a( kp, j ) = temp
                    end do
                    a( kp, k ) = conjg( a( kp, k ) )
                    temp = a( k, k )
                    a( k, k ) = a( kp, kp )
                    a( kp, kp ) = temp
                 end if
              end if
              k = k - 1
              go to 80
              120 continue
           end if
           return
     end subroutine stdlib_${ci}$hetri_rook

#:endif
#:endfor



     module pure subroutine stdlib_cherfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr, &
     !! CHERFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is Hermitian indefinite, and
     !! provides error bounds and backward error estimates for the solution.
               berr, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, j, k, kase, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldaf<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldx<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHERFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_ccopy( n, b( 1, j ), 1, work, 1 )
              call stdlib_chemv( uplo, n, -cone, a, lda, x( 1, j ), 1, cone, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    do i = 1, k - 1
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + abs( real( a( k, k ),KIND=sp) )*xk + s
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + abs( real( a( k, k ),KIND=sp) )*xk
                    do i = k + 1, n
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_chetrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                 call stdlib_caxpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_clacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_clacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**h).
                    call stdlib_chetrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_chetrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_cherfs

     module pure subroutine stdlib_zherfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr, &
     !! ZHERFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is Hermitian indefinite, and
     !! provides error bounds and backward error estimates for the solution.
               berr, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(dp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(dp), intent(in) :: a(lda,*), af(ldaf,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
           complex(dp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, j, k, kase, nz
           real(dp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(dp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=dp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldaf<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldx<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHERFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_dlamch( 'EPSILON' )
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_zcopy( n, b( 1, j ), 1, work, 1 )
              call stdlib_zhemv( uplo, n, -cone, a, lda, x( 1, j ), 1, cone, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    do i = 1, k - 1
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + abs( real( a( k, k ),KIND=dp) )*xk + s
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + abs( real( a( k, k ),KIND=dp) )*xk
                    do i = k + 1, n
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_zhetrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                 call stdlib_zaxpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_zlacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_zlacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**h).
                    call stdlib_zhetrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_zhetrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_zherfs

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$herfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr, &
     !! ZHERFS: improves the computed solution to a system of linear
     !! equations when the coefficient matrix is Hermitian indefinite, and
     !! provides error bounds and backward error estimates for the solution.
               berr, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${ck}$), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(${ck}$), intent(in) :: a(lda,*), af(ldaf,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, j, k, kase, nz
           real(${ck}$) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(${ck}$) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=${ck}$) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldaf<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldx<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHERFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_${c2ri(ci)}$lamch( 'EPSILON' )
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_${ci}$copy( n, b( 1, j ), 1, work, 1 )
              call stdlib_${ci}$hemv( uplo, n, -cone, a, lda, x( 1, j ), 1, cone, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    do i = 1, k - 1
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + abs( real( a( k, k ),KIND=${ck}$) )*xk + s
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + abs( real( a( k, k ),KIND=${ck}$) )*xk
                    do i = k + 1, n
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_${ci}$hetrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                 call stdlib_${ci}$axpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_${ci}$lacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_${ci}$lacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**h).
                    call stdlib_${ci}$hetrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_${ci}$hetrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_${ci}$herfs

#:endif
#:endfor



     module pure subroutine stdlib_ssytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
     !! SSYTRF_ROOK computes the factorization of a real symmetric matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
     !! The form of the factorization is
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'SSYTRF_ROOK', uplo, n, -1, -1, -1 )
              lwkopt = max( 1, n*nb )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYTRF_ROOK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'SSYTRF_ROOK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_slasyf_rook;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_slasyf_rook( uplo, k, nb, kb, a, lda,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_ssytf2_rook( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_slasyf_rook;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_slasyf_rook( uplo, n-k+1, nb, kb, a( k, k ), lda,ipiv( k ), work, &
                           ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_ssytf2_rook( uplo, n-k+1, a( k, k ), lda, ipiv( k ),iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_ssytrf_rook

     module pure subroutine stdlib_dsytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
     !! DSYTRF_ROOK computes the factorization of a real symmetric matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
     !! The form of the factorization is
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'DSYTRF_ROOK', uplo, n, -1, -1, -1 )
              lwkopt = max( 1, n*nb )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRF_ROOK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'DSYTRF_ROOK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_dlasyf_rook;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_dlasyf_rook( uplo, k, nb, kb, a, lda,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_dsytf2_rook( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_dlasyf_rook;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_dlasyf_rook( uplo, n-k+1, nb, kb, a( k, k ), lda,ipiv( k ), work, &
                           ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_dsytf2_rook( uplo, n-k+1, a( k, k ), lda, ipiv( k ),iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dsytrf_rook

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
     !! DSYTRF_ROOK: computes the factorization of a real symmetric matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
     !! The form of the factorization is
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'DSYTRF_ROOK', uplo, n, -1, -1, -1 )
              lwkopt = max( 1, n*nb )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRF_ROOK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'DSYTRF_ROOK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ri}$lasyf_rook;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_${ri}$lasyf_rook( uplo, k, nb, kb, a, lda,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_${ri}$sytf2_rook( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ri}$lasyf_rook;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_${ri}$lasyf_rook( uplo, n-k+1, nb, kb, a( k, k ), lda,ipiv( k ), work, &
                           ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_${ri}$sytf2_rook( uplo, n-k+1, a( k, k ), lda, ipiv( k ),iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sytrf_rook

#:endif
#:endfor

     module pure subroutine stdlib_csytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
     !! CSYTRF_ROOK computes the factorization of a complex symmetric matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
     !! The form of the factorization is
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'CSYTRF_ROOK', uplo, n, -1, -1, -1 )
              lwkopt = max( 1, n*nb )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRF_ROOK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'CSYTRF_ROOK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clasyf_rook;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_clasyf_rook( uplo, k, nb, kb, a, lda,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_csytf2_rook( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clasyf_rook;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_clasyf_rook( uplo, n-k+1, nb, kb, a( k, k ), lda,ipiv( k ), work, &
                           ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_csytf2_rook( uplo, n-k+1, a( k, k ), lda, ipiv( k ),iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csytrf_rook

     module pure subroutine stdlib_zsytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
     !! ZSYTRF_ROOK computes the factorization of a complex symmetric matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
     !! The form of the factorization is
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'ZSYTRF_ROOK', uplo, n, -1, -1, -1 )
              lwkopt = max( 1, n*nb )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRF_ROOK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'ZSYTRF_ROOK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_zlasyf_rook;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_zlasyf_rook( uplo, k, nb, kb, a, lda,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_zsytf2_rook( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_zlasyf_rook;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_zlasyf_rook( uplo, n-k+1, nb, kb, a( k, k ), lda,ipiv( k ), work, &
                           ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_zsytf2_rook( uplo, n-k+1, a( k, k ), lda, ipiv( k ),iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zsytrf_rook

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
     !! ZSYTRF_ROOK: computes the factorization of a complex symmetric matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
     !! The form of the factorization is
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'ZSYTRF_ROOK', uplo, n, -1, -1, -1 )
              lwkopt = max( 1, n*nb )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRF_ROOK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'ZSYTRF_ROOK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ci}$lasyf_rook;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_${ci}$lasyf_rook( uplo, k, nb, kb, a, lda,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_${ci}$sytf2_rook( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ci}$lasyf_rook;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_${ci}$lasyf_rook( uplo, n-k+1, nb, kb, a( k, k ), lda,ipiv( k ), work, &
                           ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_${ci}$sytf2_rook( uplo, n-k+1, a( k, k ), lda, ipiv( k ),iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$sytrf_rook

#:endif
#:endfor



     module pure subroutine stdlib_clahef( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
     !! CLAHEF computes a partial factorization of a complex Hermitian
     !! matrix A using the Bunch-Kaufman diagonal pivoting method. The
     !! partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0      I     )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! Note that U**H denotes the conjugate transpose of U.
     !! CLAHEF is an auxiliary routine called by CHETRF. It uses blocked code
     !! (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
     !! A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           integer(ilp) :: imax, j, jb, jj, jmax, jp, k, kk, kkw, kp, kstep, kw
           real(sp) :: absakk, alpha, colmax, r1, rowmax, t
           complex(sp) :: d11, d21, d22, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11 (note that conjg(w) is actually stored)
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              ! copy column k of a to column kw of w and update it
              call stdlib_ccopy( k-1, a( 1, k ), 1, w( 1, kw ), 1 )
              w( k, kw ) = real( a( k, k ),KIND=sp)
              if( k<n ) then
                 call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ), lda,w( k, kw+1 ), &
                           ldw, cone, w( 1, kw ), 1 )
                 w( k, kw ) = real( w( k, kw ),KIND=sp)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, kw ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=sp)
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! begin pivot search along imax row
                    ! copy column imax to column kw-1 of w and update it
                    call stdlib_ccopy( imax-1, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                    w( imax, kw-1 ) = real( a( imax, imax ),KIND=sp)
                    call stdlib_ccopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                              
                    call stdlib_clacgv( k-imax, w( imax+1, kw-1 ), 1 )
                    if( k<n ) then
                       call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda, w( imax,&
                                  kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                       w( imax, kw-1 ) = real( w( imax, kw-1 ),KIND=sp)
                    end if
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value.
                    ! determine only rowmax.
                    jmax = imax + stdlib_icamax( k-imax, w( imax+1, kw-1 ), 1 )
                    rowmax = cabs1( w( jmax, kw-1 ) )
                    if( imax>1 ) then
                       jmax = stdlib_icamax( imax-1, w( 1, kw-1 ), 1 )
                       rowmax = max( rowmax, cabs1( w( jmax, kw-1 ) ) )
                    end if
                    ! case(2)
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    ! case(3)
                    else if( abs( real( w( imax, kw-1 ),KIND=sp) )>=alpha*rowmax )then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column kw-1 of w to column kw of w
                       call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                    ! case(4)
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                    ! end pivot search along imax row
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=sp)
                    call stdlib_ccopy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_clacgv( kk-1-kp, a( kp, kp+1 ), lda )
                    if( kp>1 )call stdlib_ccopy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_cswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_cswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! (1) store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element u(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=sp) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_ccopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(4))
                       r1 = one / real( a( k, k ),KIND=sp)
                       call stdlib_csscal( k-1, r1, a( 1, k ), 1 )
                       ! (2) conjugate column w(kw)
                       call stdlib_clacgv( k-1, w( 1, kw ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! (1) store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! (note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored)
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! = ( conj(d21)*( d11 ) d21*(  -1 ) )
                         ! (           (  -1 )     ( d22 ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = t/d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0, since in 2x2 pivot case(4)
                            ! |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / conjg( d21 )
                       d22 = w( k-1, kw-1 ) / d21
                       t = one / ( real( d11*d22,KIND=sp)-one )
                       d21 = t / d21
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       do j = 1, k - 2
                          a( j, k-1 ) = d21*( d11*w( j, kw-1 )-w( j, kw ) )
                          a( j, k ) = conjg( d21 )*( d22*w( j, kw )-w( j, kw-1 ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                    ! (2) conjugate columns w(kw) and w(kw-1)
                    call stdlib_clacgv( k-1, w( 1, kw ), 1 )
                    call stdlib_clacgv( k-2, w( 1, kw-1 ), 1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**h = a11 - u12*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                    call stdlib_cgemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                 end do
                 ! update the rectangular superdiagonal block
                 call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k,-cone, a( 1, k+1 ), &
                           lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in of rows in columns k+1:n looping backwards from k+1 to n
              j = k + 1
              60 continue
                 ! undo the interchanges (if any) of rows j and jp
                 ! at each step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j + 1
                 end if
                 ! (note: here, j is used to determine row length. length n-j+1
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j + 1
                 if( jp/=jj .and. j<=n )call stdlib_cswap( n-j+1, a( jp, j ), lda, a( jj, j ), &
                           lda )
              if( j<=n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22 (note that conjg(w) is actually stored)
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              ! copy column k of a to column k of w and update it
              w( k, k ) = real( a( k, k ),KIND=sp)
              if( k<n )call stdlib_ccopy( n-k, a( k+1, k ), 1, w( k+1, k ), 1 )
              call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ), lda,w( k, 1 ), ldw,&
                         cone, w( k, k ), 1 )
              w( k, k ) = real( w( k, k ),KIND=sp)
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, k ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=sp)
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! begin pivot search along imax row
                    ! copy column imax to column k+1 of w and update it
                    call stdlib_ccopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1 )
                    call stdlib_clacgv( imax-k, w( k, k+1 ), 1 )
                    w( imax, k+1 ) = real( a( imax, imax ),KIND=sp)
                    if( imax<n )call stdlib_ccopy( n-imax, a( imax+1, imax ), 1,w( imax+1, k+1 ), &
                              1 )
                    call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( imax, &
                              1 ), ldw, cone, w( k, k+1 ),1 )
                    w( imax, k+1 ) = real( w( imax, k+1 ),KIND=sp)
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value.
                    ! determine only rowmax.
                    jmax = k - 1 + stdlib_icamax( imax-k, w( k, k+1 ), 1 )
                    rowmax = cabs1( w( jmax, k+1 ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_icamax( n-imax, w( imax+1, k+1 ), 1 )
                       rowmax = max( rowmax, cabs1( w( jmax, k+1 ) ) )
                    end if
                    ! case(2)
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    ! case(3)
                    else if( abs( real( w( imax, k+1 ),KIND=sp) )>=alpha*rowmax )then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column k+1 of w to column k of w
                       call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                    ! case(4)
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                    ! end pivot search along imax row
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=sp)
                    call stdlib_ccopy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    call stdlib_clacgv( kp-kk-1, a( kp, kk+1 ), lda )
                    if( kp<n )call stdlib_ccopy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (columns k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_cswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_cswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! (1) store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=sp) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_ccopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(4))
                       r1 = one / real( a( k, k ),KIND=sp)
                       call stdlib_csscal( n-k, r1, a( k+1, k ), 1 )
                       ! (2) conjugate column w(k)
                       call stdlib_clacgv( n-k, w( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! (1) store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! (note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored)
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! = ( conj(d21)*( d11 ) d21*(  -1 ) )
                         ! (           (  -1 )     ( d22 ) )
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = t/d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0, since in 2x2 pivot case(4)
                            ! |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / conjg( d21 )
                       t = one / ( real( d11*d22,KIND=sp)-one )
                       d21 = t / d21
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = conjg( d21 )*( d11*w( j, k )-w( j, k+1 ) )
                          a( j, k+1 ) = d21*( d22*w( j, k+1 )-w( j, k ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    ! (2) conjugate columns w(k) and w(k+1)
                    call stdlib_clacgv( n-k, w( k+1, k ), 1 )
                    call stdlib_clacgv( n-k-1, w( k+2, k+1 ), 1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**h = a22 - l21*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                    call stdlib_cgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! of rows in columns 1:k-1 looping backwards from k-1 to 1
              j = k - 1
              120 continue
                 ! undo the interchanges (if any) of rows j and jp
                 ! at each step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j - 1
                 end if
                 ! (note: here, j is used to determine row length. length j
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j - 1
                 if( jp/=jj .and. j>=1 )call stdlib_cswap( j, a( jp, 1 ), lda, a( jj, 1 ), lda )
                           
              if( j>=1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_clahef

     module pure subroutine stdlib_zlahef( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
     !! ZLAHEF computes a partial factorization of a complex Hermitian
     !! matrix A using the Bunch-Kaufman diagonal pivoting method. The
     !! partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0      I     )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! Note that U**H denotes the conjugate transpose of U.
     !! ZLAHEF is an auxiliary routine called by ZHETRF. It uses blocked code
     !! (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
     !! A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           
           ! Local Scalars 
           integer(ilp) :: imax, j, jb, jj, jmax, jp, k, kk, kkw, kp, kstep, kw
           real(dp) :: absakk, alpha, colmax, r1, rowmax, t
           complex(dp) :: d11, d21, d22, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=dp) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11 (note that conjg(w) is actually stored)
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              ! kw is the column of w which corresponds to column k of a
              k = n
              10 continue
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              ! copy column k of a to column kw of w and update it
              call stdlib_zcopy( k-1, a( 1, k ), 1, w( 1, kw ), 1 )
              w( k, kw ) = real( a( k, k ),KIND=dp)
              if( k<n ) then
                 call stdlib_zgemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ), lda,w( k, kw+1 ), &
                           ldw, cone, w( 1, kw ), 1 )
                 w( k, kw ) = real( w( k, kw ),KIND=dp)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, kw ),KIND=dp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_izamax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=dp)
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! begin pivot search along imax row
                    ! copy column imax to column kw-1 of w and update it
                    call stdlib_zcopy( imax-1, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                    w( imax, kw-1 ) = real( a( imax, imax ),KIND=dp)
                    call stdlib_zcopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                              
                    call stdlib_zlacgv( k-imax, w( imax+1, kw-1 ), 1 )
                    if( k<n ) then
                       call stdlib_zgemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda, w( imax,&
                                  kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                       w( imax, kw-1 ) = real( w( imax, kw-1 ),KIND=dp)
                    end if
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value.
                    ! determine only rowmax.
                    jmax = imax + stdlib_izamax( k-imax, w( imax+1, kw-1 ), 1 )
                    rowmax = cabs1( w( jmax, kw-1 ) )
                    if( imax>1 ) then
                       jmax = stdlib_izamax( imax-1, w( 1, kw-1 ), 1 )
                       rowmax = max( rowmax, cabs1( w( jmax, kw-1 ) ) )
                    end if
                    ! case(2)
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    ! case(3)
                    else if( abs( real( w( imax, kw-1 ),KIND=dp) )>=alpha*rowmax )then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column kw-1 of w to column kw of w
                       call stdlib_zcopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                    ! case(4)
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                    ! end pivot search along imax row
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=dp)
                    call stdlib_zcopy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_zlacgv( kk-1-kp, a( kp, kp+1 ), lda )
                    if( kp>1 )call stdlib_zcopy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_zswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_zswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! (1) store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element u(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=dp) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_zcopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(4))
                       r1 = one / real( a( k, k ),KIND=dp)
                       call stdlib_zdscal( k-1, r1, a( 1, k ), 1 )
                       ! (2) conjugate column w(kw)
                       call stdlib_zlacgv( k-1, w( 1, kw ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! (1) store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! (note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored)
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! = ( conj(d21)*( d11 ) d21*(  -1 ) )
                         ! (           (  -1 )     ( d22 ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = t/d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0, since in 2x2 pivot case(4)
                            ! |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / conjg( d21 )
                       d22 = w( k-1, kw-1 ) / d21
                       t = one / ( real( d11*d22,KIND=dp)-one )
                       d21 = t / d21
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       do j = 1, k - 2
                          a( j, k-1 ) = d21*( d11*w( j, kw-1 )-w( j, kw ) )
                          a( j, k ) = conjg( d21 )*( d22*w( j, kw )-w( j, kw-1 ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                    ! (2) conjugate columns w(kw) and w(kw-1)
                    call stdlib_zlacgv( k-1, w( 1, kw ), 1 )
                    call stdlib_zlacgv( k-2, w( 1, kw-1 ), 1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**h = a11 - u12*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=dp)
                    call stdlib_zgemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=dp)
                 end do
                 ! update the rectangular superdiagonal block
                 call stdlib_zgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k,-cone, a( 1, k+1 ), &
                           lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in columns k+1:n looping backwards from k+1 to n
              j = k + 1
              60 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j + 1
                 end if
                 ! (note: here, j is used to determine row length. length n-j+1
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j + 1
                 if( jp/=jj .and. j<=n )call stdlib_zswap( n-j+1, a( jp, j ), lda, a( jj, j ), &
                           lda )
              if( j<n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22 (note that conjg(w) is actually stored)
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              ! copy column k of a to column k of w and update it
              w( k, k ) = real( a( k, k ),KIND=dp)
              if( k<n )call stdlib_zcopy( n-k, a( k+1, k ), 1, w( k+1, k ), 1 )
              call stdlib_zgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ), lda,w( k, 1 ), ldw,&
                         cone, w( k, k ), 1 )
              w( k, k ) = real( w( k, k ),KIND=dp)
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, k ),KIND=dp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_izamax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=dp)
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! begin pivot search along imax row
                    ! copy column imax to column k+1 of w and update it
                    call stdlib_zcopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1 )
                    call stdlib_zlacgv( imax-k, w( k, k+1 ), 1 )
                    w( imax, k+1 ) = real( a( imax, imax ),KIND=dp)
                    if( imax<n )call stdlib_zcopy( n-imax, a( imax+1, imax ), 1,w( imax+1, k+1 ), &
                              1 )
                    call stdlib_zgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( imax, &
                              1 ), ldw, cone, w( k, k+1 ),1 )
                    w( imax, k+1 ) = real( w( imax, k+1 ),KIND=dp)
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value.
                    ! determine only rowmax.
                    jmax = k - 1 + stdlib_izamax( imax-k, w( k, k+1 ), 1 )
                    rowmax = cabs1( w( jmax, k+1 ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_izamax( n-imax, w( imax+1, k+1 ), 1 )
                       rowmax = max( rowmax, cabs1( w( jmax, k+1 ) ) )
                    end if
                    ! case(2)
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    ! case(3)
                    else if( abs( real( w( imax, k+1 ),KIND=dp) )>=alpha*rowmax )then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column k+1 of w to column k of w
                       call stdlib_zcopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                    ! case(4)
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                    ! end pivot search along imax row
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=dp)
                    call stdlib_zcopy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    call stdlib_zlacgv( kp-kk-1, a( kp, kk+1 ), lda )
                    if( kp<n )call stdlib_zcopy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (columns k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_zswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_zswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! (1) store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=dp) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_zcopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(4))
                       r1 = one / real( a( k, k ),KIND=dp)
                       call stdlib_zdscal( n-k, r1, a( k+1, k ), 1 )
                       ! (2) conjugate column w(k)
                       call stdlib_zlacgv( n-k, w( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! (1) store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! (note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored)
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! = ( conj(d21)*( d11 ) d21*(  -1 ) )
                         ! (           (  -1 )     ( d22 ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = t/d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0, since in 2x2 pivot case(4)
                            ! |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / conjg( d21 )
                       t = one / ( real( d11*d22,KIND=dp)-one )
                       d21 = t / d21
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = conjg( d21 )*( d11*w( j, k )-w( j, k+1 ) )
                          a( j, k+1 ) = d21*( d22*w( j, k+1 )-w( j, k ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    ! (2) conjugate columns w(k) and w(k+1)
                    call stdlib_zlacgv( n-k, w( k+1, k ), 1 )
                    call stdlib_zlacgv( n-k-1, w( k+2, k+1 ), 1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**h = a22 - l21*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=dp)
                    call stdlib_zgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=dp)
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_zgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! of rows in columns 1:k-1 looping backwards from k-1 to 1
              j = k - 1
              120 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j - 1
                 end if
                 ! (note: here, j is used to determine row length. length j
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j - 1
                 if( jp/=jj .and. j>=1 )call stdlib_zswap( j, a( jp, 1 ), lda, a( jj, 1 ), lda )
                           
              if( j>1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_zlahef

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$lahef( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
     !! ZLAHEF: computes a partial factorization of a complex Hermitian
     !! matrix A using the Bunch-Kaufman diagonal pivoting method. The
     !! partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0      I     )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! Note that U**H denotes the conjugate transpose of U.
     !! ZLAHEF is an auxiliary routine called by ZHETRF. It uses blocked code
     !! (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
     !! A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: sevten = 17.0e+0_${ck}$
           
           
           
           ! Local Scalars 
           integer(ilp) :: imax, j, jb, jj, jmax, jp, k, kk, kkw, kp, kstep, kw
           real(${ck}$) :: absakk, alpha, colmax, r1, rowmax, t
           complex(${ck}$) :: d11, d21, d22, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=${ck}$) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11 (note that conjg(w) is actually stored)
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              ! kw is the column of w which corresponds to column k of a
              k = n
              10 continue
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              ! copy column k of a to column kw of w and update it
              call stdlib_${ci}$copy( k-1, a( 1, k ), 1, w( 1, kw ), 1 )
              w( k, kw ) = real( a( k, k ),KIND=${ck}$)
              if( k<n ) then
                 call stdlib_${ci}$gemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ), lda,w( k, kw+1 ), &
                           ldw, cone, w( 1, kw ), 1 )
                 w( k, kw ) = real( w( k, kw ),KIND=${ck}$)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, kw ),KIND=${ck}$) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ci}$amax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=${ck}$)
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! begin pivot search along imax row
                    ! copy column imax to column kw-1 of w and update it
                    call stdlib_${ci}$copy( imax-1, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                    w( imax, kw-1 ) = real( a( imax, imax ),KIND=${ck}$)
                    call stdlib_${ci}$copy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                              
                    call stdlib_${ci}$lacgv( k-imax, w( imax+1, kw-1 ), 1 )
                    if( k<n ) then
                       call stdlib_${ci}$gemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda, w( imax,&
                                  kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                       w( imax, kw-1 ) = real( w( imax, kw-1 ),KIND=${ck}$)
                    end if
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value.
                    ! determine only rowmax.
                    jmax = imax + stdlib_i${ci}$amax( k-imax, w( imax+1, kw-1 ), 1 )
                    rowmax = cabs1( w( jmax, kw-1 ) )
                    if( imax>1 ) then
                       jmax = stdlib_i${ci}$amax( imax-1, w( 1, kw-1 ), 1 )
                       rowmax = max( rowmax, cabs1( w( jmax, kw-1 ) ) )
                    end if
                    ! case(2)
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    ! case(3)
                    else if( abs( real( w( imax, kw-1 ),KIND=${ck}$) )>=alpha*rowmax )then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column kw-1 of w to column kw of w
                       call stdlib_${ci}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                    ! case(4)
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                    ! end pivot search along imax row
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=${ck}$)
                    call stdlib_${ci}$copy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_${ci}$lacgv( kk-1-kp, a( kp, kp+1 ), lda )
                    if( kp>1 )call stdlib_${ci}$copy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_${ci}$swap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_${ci}$swap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! (1) store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element u(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=${ck}$) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_${ci}$copy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(4))
                       r1 = one / real( a( k, k ),KIND=${ck}$)
                       call stdlib_${ci}$dscal( k-1, r1, a( 1, k ), 1 )
                       ! (2) conjugate column w(kw)
                       call stdlib_${ci}$lacgv( k-1, w( 1, kw ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! (1) store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! (note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored)
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! = ( conj(d21)*( d11 ) d21*(  -1 ) )
                         ! (           (  -1 )     ( d22 ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = t/d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0, since in 2x2 pivot case(4)
                            ! |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / conjg( d21 )
                       d22 = w( k-1, kw-1 ) / d21
                       t = one / ( real( d11*d22,KIND=${ck}$)-one )
                       d21 = t / d21
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       do j = 1, k - 2
                          a( j, k-1 ) = d21*( d11*w( j, kw-1 )-w( j, kw ) )
                          a( j, k ) = conjg( d21 )*( d22*w( j, kw )-w( j, kw-1 ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                    ! (2) conjugate columns w(kw) and w(kw-1)
                    call stdlib_${ci}$lacgv( k-1, w( 1, kw ), 1 )
                    call stdlib_${ci}$lacgv( k-2, w( 1, kw-1 ), 1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**h = a11 - u12*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=${ck}$)
                    call stdlib_${ci}$gemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=${ck}$)
                 end do
                 ! update the rectangular superdiagonal block
                 call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k,-cone, a( 1, k+1 ), &
                           lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in columns k+1:n looping backwards from k+1 to n
              j = k + 1
              60 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j + 1
                 end if
                 ! (note: here, j is used to determine row length. length n-j+1
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j + 1
                 if( jp/=jj .and. j<=n )call stdlib_${ci}$swap( n-j+1, a( jp, j ), lda, a( jj, j ), &
                           lda )
              if( j<n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22 (note that conjg(w) is actually stored)
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              ! copy column k of a to column k of w and update it
              w( k, k ) = real( a( k, k ),KIND=${ck}$)
              if( k<n )call stdlib_${ci}$copy( n-k, a( k+1, k ), 1, w( k+1, k ), 1 )
              call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ), lda,w( k, 1 ), ldw,&
                         cone, w( k, k ), 1 )
              w( k, k ) = real( w( k, k ),KIND=${ck}$)
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, k ),KIND=${ck}$) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ci}$amax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=${ck}$)
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! begin pivot search along imax row
                    ! copy column imax to column k+1 of w and update it
                    call stdlib_${ci}$copy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1 )
                    call stdlib_${ci}$lacgv( imax-k, w( k, k+1 ), 1 )
                    w( imax, k+1 ) = real( a( imax, imax ),KIND=${ck}$)
                    if( imax<n )call stdlib_${ci}$copy( n-imax, a( imax+1, imax ), 1,w( imax+1, k+1 ), &
                              1 )
                    call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( imax, &
                              1 ), ldw, cone, w( k, k+1 ),1 )
                    w( imax, k+1 ) = real( w( imax, k+1 ),KIND=${ck}$)
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value.
                    ! determine only rowmax.
                    jmax = k - 1 + stdlib_i${ci}$amax( imax-k, w( k, k+1 ), 1 )
                    rowmax = cabs1( w( jmax, k+1 ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_i${ci}$amax( n-imax, w( imax+1, k+1 ), 1 )
                       rowmax = max( rowmax, cabs1( w( jmax, k+1 ) ) )
                    end if
                    ! case(2)
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    ! case(3)
                    else if( abs( real( w( imax, k+1 ),KIND=${ck}$) )>=alpha*rowmax )then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column k+1 of w to column k of w
                       call stdlib_${ci}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                    ! case(4)
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                    ! end pivot search along imax row
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=${ck}$)
                    call stdlib_${ci}$copy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    call stdlib_${ci}$lacgv( kp-kk-1, a( kp, kk+1 ), lda )
                    if( kp<n )call stdlib_${ci}$copy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (columns k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_${ci}$swap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_${ci}$swap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! (1) store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=${ck}$) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_${ci}$copy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(4))
                       r1 = one / real( a( k, k ),KIND=${ck}$)
                       call stdlib_${ci}$dscal( n-k, r1, a( k+1, k ), 1 )
                       ! (2) conjugate column w(k)
                       call stdlib_${ci}$lacgv( n-k, w( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! (1) store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! (note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored)
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! = ( conj(d21)*( d11 ) d21*(  -1 ) )
                         ! (           (  -1 )     ( d22 ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = t/d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0, since in 2x2 pivot case(4)
                            ! |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / conjg( d21 )
                       t = one / ( real( d11*d22,KIND=${ck}$)-one )
                       d21 = t / d21
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = conjg( d21 )*( d11*w( j, k )-w( j, k+1 ) )
                          a( j, k+1 ) = d21*( d22*w( j, k+1 )-w( j, k ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    ! (2) conjugate columns w(k) and w(k+1)
                    call stdlib_${ci}$lacgv( n-k, w( k+1, k ), 1 )
                    call stdlib_${ci}$lacgv( n-k-1, w( k+2, k+1 ), 1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**h = a22 - l21*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=${ck}$)
                    call stdlib_${ci}$gemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=${ck}$)
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! of rows in columns 1:k-1 looping backwards from k-1 to 1
              j = k - 1
              120 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j - 1
                 end if
                 ! (note: here, j is used to determine row length. length j
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j - 1
                 if( jp/=jj .and. j>=1 )call stdlib_${ci}$swap( j, a( jp, 1 ), lda, a( jj, 1 ), lda )
                           
              if( j>1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_${ci}$lahef

#:endif
#:endfor



     module pure subroutine stdlib_chetrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
     !! CHETRF_RK computes the factorization of a complex Hermitian matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, ip, iws, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'CHETRF_RK', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRF_RK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'CHETRF_RK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clahef_rk;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 15
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_clahef_rk( uplo, k, nb, kb, a, lda, e,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_chetf2_rk( uplo, k, a, lda, e, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k-kb+1:k and apply row permutations to the
              ! last k+1 colunms k+1:n after that block
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k<n ) then
                 do i = k, ( k - kb + 1 ), -1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_cswap( n-k, a( i, k+1 ), lda,a( ip, k+1 ), lda )
                    end if
                 end do
              end if
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
              ! this label is the exit from main loop over k decreasing
              ! from n to 1 in steps of kb
              15 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clahef_rk;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 35
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_clahef_rk( uplo, n-k+1, nb, kb, a( k, k ), lda, e( k ),ipiv( k ), &
                           work, ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_chetf2_rk( uplo, n-k+1, a( k, k ), lda, e( k ),ipiv( k ), iinfo )
                           
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do i = k, k + kb - 1
                 if( ipiv( i )>0 ) then
                    ipiv( i ) = ipiv( i ) + k - 1
                 else
                    ipiv( i ) = ipiv( i ) - k + 1
                 end if
              end do
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k:k+kb-1 and apply row permutations to the
              ! first k-1 colunms 1:k-1 before that block
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k>1 ) then
                 do i = k, ( k + kb - 1 ), 1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_cswap( k-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                    end if
                 end do
              end if
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
              ! this label is the exit from main loop over k increasing
              ! from 1 to n in steps of kb
              35 continue
           ! end lower
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chetrf_rk

     module pure subroutine stdlib_zhetrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
     !! ZHETRF_RK computes the factorization of a complex Hermitian matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, ip, iws, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'ZHETRF_RK', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRF_RK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'ZHETRF_RK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_zlahef_rk;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 15
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_zlahef_rk( uplo, k, nb, kb, a, lda, e,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_zhetf2_rk( uplo, k, a, lda, e, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k-kb+1:k and apply row permutations to the
              ! last k+1 colunms k+1:n after that block
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k<n ) then
                 do i = k, ( k - kb + 1 ), -1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_zswap( n-k, a( i, k+1 ), lda,a( ip, k+1 ), lda )
                    end if
                 end do
              end if
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
              ! this label is the exit from main loop over k decreasing
              ! from n to 1 in steps of kb
              15 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_zlahef_rk;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 35
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_zlahef_rk( uplo, n-k+1, nb, kb, a( k, k ), lda, e( k ),ipiv( k ), &
                           work, ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_zhetf2_rk( uplo, n-k+1, a( k, k ), lda, e( k ),ipiv( k ), iinfo )
                           
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do i = k, k + kb - 1
                 if( ipiv( i )>0 ) then
                    ipiv( i ) = ipiv( i ) + k - 1
                 else
                    ipiv( i ) = ipiv( i ) - k + 1
                 end if
              end do
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k:k+kb-1 and apply row permutations to the
              ! first k-1 colunms 1:k-1 before that block
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k>1 ) then
                 do i = k, ( k + kb - 1 ), 1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_zswap( k-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                    end if
                 end do
              end if
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
              ! this label is the exit from main loop over k increasing
              ! from 1 to n in steps of kb
              35 continue
           ! end lower
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zhetrf_rk

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hetrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
     !! ZHETRF_RK: computes the factorization of a complex Hermitian matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, ip, iws, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'ZHETRF_RK', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRF_RK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'ZHETRF_RK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ci}$lahef_rk;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 15
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_${ci}$lahef_rk( uplo, k, nb, kb, a, lda, e,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_${ci}$hetf2_rk( uplo, k, a, lda, e, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k-kb+1:k and apply row permutations to the
              ! last k+1 colunms k+1:n after that block
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k<n ) then
                 do i = k, ( k - kb + 1 ), -1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_${ci}$swap( n-k, a( i, k+1 ), lda,a( ip, k+1 ), lda )
                    end if
                 end do
              end if
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
              ! this label is the exit from main loop over k decreasing
              ! from n to 1 in steps of kb
              15 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ci}$lahef_rk;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 35
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_${ci}$lahef_rk( uplo, n-k+1, nb, kb, a( k, k ), lda, e( k ),ipiv( k ), &
                           work, ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_${ci}$hetf2_rk( uplo, n-k+1, a( k, k ), lda, e( k ),ipiv( k ), iinfo )
                           
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do i = k, k + kb - 1
                 if( ipiv( i )>0 ) then
                    ipiv( i ) = ipiv( i ) + k - 1
                 else
                    ipiv( i ) = ipiv( i ) - k + 1
                 end if
              end do
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k:k+kb-1 and apply row permutations to the
              ! first k-1 colunms 1:k-1 before that block
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k>1 ) then
                 do i = k, ( k + kb - 1 ), 1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_${ci}$swap( k-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                    end if
                 end do
              end if
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
              ! this label is the exit from main loop over k increasing
              ! from 1 to n in steps of kb
              35 continue
           ! end lower
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$hetrf_rk

#:endif
#:endfor



     module pure subroutine stdlib_ssycon( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info )
     !! SSYCON estimates the reciprocal of the condition number (in the
     !! 1-norm) of a real symmetric matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by SSYTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(in) :: a(lda,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(sp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_slacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_ssytrs( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_ssycon

     module pure subroutine stdlib_dsycon( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info )
     !! DSYCON estimates the reciprocal of the condition number (in the
     !! 1-norm) of a real symmetric matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by DSYTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(dp), intent(in) :: anorm
           real(dp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(in) :: a(lda,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(dp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_dlacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_dsytrs( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_dsycon

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sycon( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info )
     !! DSYCON: estimates the reciprocal of the condition number (in the
     !! 1-norm) of a real symmetric matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by DSYTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(${rk}$), intent(in) :: anorm
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(${rk}$) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_${ri}$sytrs( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_${ri}$sycon

#:endif
#:endfor

     module pure subroutine stdlib_csycon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
     !! CSYCON estimates the reciprocal of the condition number (in the
     !! 1-norm) of a complex symmetric matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by CSYTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(sp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_csytrs( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_csycon

     module pure subroutine stdlib_zsycon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
     !! ZSYCON estimates the reciprocal of the condition number (in the
     !! 1-norm) of a complex symmetric matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by ZSYTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(dp), intent(in) :: anorm
           real(dp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(dp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_zlacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_zsytrs( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_zsycon

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sycon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
     !! ZSYCON: estimates the reciprocal of the condition number (in the
     !! 1-norm) of a complex symmetric matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by ZSYTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(${ck}$), intent(in) :: anorm
           real(${ck}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(${ck}$) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_${ci}$lacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_${ci}$sytrs( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_${ci}$sycon

#:endif
#:endfor





     module pure subroutine stdlib_ssprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, work,&
     !! SSPRFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric indefinite
     !! and packed, and provides error bounds and backward error estimates
     !! for the solution.
                iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(in) :: afp(*), ap(*), b(ldb,*)
           real(sp), intent(out) :: berr(*), ferr(*), work(*)
           real(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, ik, j, k, kase, kk, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin, xk
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( ldx<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSPRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_scopy( n, b( 1, j ), 1, work( n+1 ), 1 )
              call stdlib_sspmv( uplo, n, -one, ap, x( 1, j ), 1, one, work( n+1 ),1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 work( i ) = abs( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              kk = 1
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    ik = kk
                    do i = 1, k - 1
                       work( i ) = work( i ) + abs( ap( ik ) )*xk
                       s = s + abs( ap( ik ) )*abs( x( i, j ) )
                       ik = ik + 1
                    end do
                    work( k ) = work( k ) + abs( ap( kk+k-1 ) )*xk + s
                    kk = kk + k
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    work( k ) = work( k ) + abs( ap( kk ) )*xk
                    ik = kk + 1
                    do i = k + 1, n
                       work( i ) = work( i ) + abs( ap( ik ) )*xk
                       s = s + abs( ap( ik ) )*abs( x( i, j ) )
                       ik = ik + 1
                    end do
                    work( k ) = work( k ) + s
                    kk = kk + ( n-k+1 )
                 end do
              end if
              s = zero
              do i = 1, n
                 if( work( i )>safe2 ) then
                    s = max( s, abs( work( n+i ) ) / work( i ) )
                 else
                    s = max( s, ( abs( work( n+i ) )+safe1 ) /( work( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_ssptrs( uplo, n, 1, afp, ipiv, work( n+1 ), n, info )
                 call stdlib_saxpy( n, one, work( n+1 ), 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_slacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( work( i )>safe2 ) then
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i )
                 else
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i ) + safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_slacn2( n, work( 2*n+1 ), work( n+1 ), iwork, ferr( j ),kase, isave )
                        
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_ssptrs( uplo, n, 1, afp, ipiv, work( n+1 ), n,info )
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                    call stdlib_ssptrs( uplo, n, 1, afp, ipiv, work( n+1 ), n,info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_ssprfs

     module pure subroutine stdlib_dsprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, work,&
     !! DSPRFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric indefinite
     !! and packed, and provides error bounds and backward error estimates
     !! for the solution.
                iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(in) :: afp(*), ap(*), b(ldb,*)
           real(dp), intent(out) :: berr(*), ferr(*), work(*)
           real(dp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, ik, j, k, kase, kk, nz
           real(dp) :: eps, lstres, s, safe1, safe2, safmin, xk
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( ldx<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_dlamch( 'EPSILON' )
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_dcopy( n, b( 1, j ), 1, work( n+1 ), 1 )
              call stdlib_dspmv( uplo, n, -one, ap, x( 1, j ), 1, one, work( n+1 ),1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 work( i ) = abs( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              kk = 1
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    ik = kk
                    do i = 1, k - 1
                       work( i ) = work( i ) + abs( ap( ik ) )*xk
                       s = s + abs( ap( ik ) )*abs( x( i, j ) )
                       ik = ik + 1
                    end do
                    work( k ) = work( k ) + abs( ap( kk+k-1 ) )*xk + s
                    kk = kk + k
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    work( k ) = work( k ) + abs( ap( kk ) )*xk
                    ik = kk + 1
                    do i = k + 1, n
                       work( i ) = work( i ) + abs( ap( ik ) )*xk
                       s = s + abs( ap( ik ) )*abs( x( i, j ) )
                       ik = ik + 1
                    end do
                    work( k ) = work( k ) + s
                    kk = kk + ( n-k+1 )
                 end do
              end if
              s = zero
              do i = 1, n
                 if( work( i )>safe2 ) then
                    s = max( s, abs( work( n+i ) ) / work( i ) )
                 else
                    s = max( s, ( abs( work( n+i ) )+safe1 ) /( work( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_dsptrs( uplo, n, 1, afp, ipiv, work( n+1 ), n, info )
                 call stdlib_daxpy( n, one, work( n+1 ), 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_dlacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( work( i )>safe2 ) then
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i )
                 else
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i ) + safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_dlacn2( n, work( 2*n+1 ), work( n+1 ), iwork, ferr( j ),kase, isave )
                        
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_dsptrs( uplo, n, 1, afp, ipiv, work( n+1 ), n,info )
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                    call stdlib_dsptrs( uplo, n, 1, afp, ipiv, work( n+1 ), n,info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_dsprfs

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, work,&
     !! DSPRFS: improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric indefinite
     !! and packed, and provides error bounds and backward error estimates
     !! for the solution.
                iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: afp(*), ap(*), b(ldb,*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*)
           real(${rk}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, ik, j, k, kase, kk, nz
           real(${rk}$) :: eps, lstres, s, safe1, safe2, safmin, xk
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( ldx<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_${ri}$copy( n, b( 1, j ), 1, work( n+1 ), 1 )
              call stdlib_${ri}$spmv( uplo, n, -one, ap, x( 1, j ), 1, one, work( n+1 ),1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 work( i ) = abs( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              kk = 1
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    ik = kk
                    do i = 1, k - 1
                       work( i ) = work( i ) + abs( ap( ik ) )*xk
                       s = s + abs( ap( ik ) )*abs( x( i, j ) )
                       ik = ik + 1
                    end do
                    work( k ) = work( k ) + abs( ap( kk+k-1 ) )*xk + s
                    kk = kk + k
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    work( k ) = work( k ) + abs( ap( kk ) )*xk
                    ik = kk + 1
                    do i = k + 1, n
                       work( i ) = work( i ) + abs( ap( ik ) )*xk
                       s = s + abs( ap( ik ) )*abs( x( i, j ) )
                       ik = ik + 1
                    end do
                    work( k ) = work( k ) + s
                    kk = kk + ( n-k+1 )
                 end do
              end if
              s = zero
              do i = 1, n
                 if( work( i )>safe2 ) then
                    s = max( s, abs( work( n+i ) ) / work( i ) )
                 else
                    s = max( s, ( abs( work( n+i ) )+safe1 ) /( work( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_${ri}$sptrs( uplo, n, 1, afp, ipiv, work( n+1 ), n, info )
                 call stdlib_${ri}$axpy( n, one, work( n+1 ), 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_${ri}$lacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( work( i )>safe2 ) then
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i )
                 else
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i ) + safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_${ri}$lacn2( n, work( 2*n+1 ), work( n+1 ), iwork, ferr( j ),kase, isave )
                        
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_${ri}$sptrs( uplo, n, 1, afp, ipiv, work( n+1 ), n,info )
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                    call stdlib_${ri}$sptrs( uplo, n, 1, afp, ipiv, work( n+1 ), n,info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_${ri}$sprfs

#:endif
#:endfor

     module pure subroutine stdlib_csprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, work,&
     !! CSPRFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric indefinite
     !! and packed, and provides error bounds and backward error estimates
     !! for the solution.
                rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: afp(*), ap(*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, ik, j, k, kase, kk, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( ldx<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSPRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_ccopy( n, b( 1, j ), 1, work, 1 )
              call stdlib_cspmv( uplo, n, -cone, ap, x( 1, j ), 1, cone, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              kk = 1
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    ik = kk
                    do i = 1, k - 1
                       rwork( i ) = rwork( i ) + cabs1( ap( ik ) )*xk
                       s = s + cabs1( ap( ik ) )*cabs1( x( i, j ) )
                       ik = ik + 1
                    end do
                    rwork( k ) = rwork( k ) + cabs1( ap( kk+k-1 ) )*xk + s
                    kk = kk + k
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + cabs1( ap( kk ) )*xk
                    ik = kk + 1
                    do i = k + 1, n
                       rwork( i ) = rwork( i ) + cabs1( ap( ik ) )*xk
                       s = s + cabs1( ap( ik ) )*cabs1( x( i, j ) )
                       ik = ik + 1
                    end do
                    rwork( k ) = rwork( k ) + s
                    kk = kk + ( n-k+1 )
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_csptrs( uplo, n, 1, afp, ipiv, work, n, info )
                 call stdlib_caxpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_clacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_clacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_csptrs( uplo, n, 1, afp, ipiv, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_csptrs( uplo, n, 1, afp, ipiv, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_csprfs

     module pure subroutine stdlib_zsprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, work,&
     !! ZSPRFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric indefinite
     !! and packed, and provides error bounds and backward error estimates
     !! for the solution.
                rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(dp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(dp), intent(in) :: afp(*), ap(*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
           complex(dp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, ik, j, k, kase, kk, nz
           real(dp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(dp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=dp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( ldx<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSPRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_dlamch( 'EPSILON' )
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_zcopy( n, b( 1, j ), 1, work, 1 )
              call stdlib_zspmv( uplo, n, -cone, ap, x( 1, j ), 1, cone, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              kk = 1
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    ik = kk
                    do i = 1, k - 1
                       rwork( i ) = rwork( i ) + cabs1( ap( ik ) )*xk
                       s = s + cabs1( ap( ik ) )*cabs1( x( i, j ) )
                       ik = ik + 1
                    end do
                    rwork( k ) = rwork( k ) + cabs1( ap( kk+k-1 ) )*xk + s
                    kk = kk + k
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + cabs1( ap( kk ) )*xk
                    ik = kk + 1
                    do i = k + 1, n
                       rwork( i ) = rwork( i ) + cabs1( ap( ik ) )*xk
                       s = s + cabs1( ap( ik ) )*cabs1( x( i, j ) )
                       ik = ik + 1
                    end do
                    rwork( k ) = rwork( k ) + s
                    kk = kk + ( n-k+1 )
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_zsptrs( uplo, n, 1, afp, ipiv, work, n, info )
                 call stdlib_zaxpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_zlacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_zlacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_zsptrs( uplo, n, 1, afp, ipiv, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_zsptrs( uplo, n, 1, afp, ipiv, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_zsprfs

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, work,&
     !! ZSPRFS: improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric indefinite
     !! and packed, and provides error bounds and backward error estimates
     !! for the solution.
                rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${ck}$), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(${ck}$), intent(in) :: afp(*), ap(*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, ik, j, k, kase, kk, nz
           real(${ck}$) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(${ck}$) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=${ck}$) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( ldx<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSPRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_${c2ri(ci)}$lamch( 'EPSILON' )
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_${ci}$copy( n, b( 1, j ), 1, work, 1 )
              call stdlib_${ci}$spmv( uplo, n, -cone, ap, x( 1, j ), 1, cone, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              kk = 1
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    ik = kk
                    do i = 1, k - 1
                       rwork( i ) = rwork( i ) + cabs1( ap( ik ) )*xk
                       s = s + cabs1( ap( ik ) )*cabs1( x( i, j ) )
                       ik = ik + 1
                    end do
                    rwork( k ) = rwork( k ) + cabs1( ap( kk+k-1 ) )*xk + s
                    kk = kk + k
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + cabs1( ap( kk ) )*xk
                    ik = kk + 1
                    do i = k + 1, n
                       rwork( i ) = rwork( i ) + cabs1( ap( ik ) )*xk
                       s = s + cabs1( ap( ik ) )*cabs1( x( i, j ) )
                       ik = ik + 1
                    end do
                    rwork( k ) = rwork( k ) + s
                    kk = kk + ( n-k+1 )
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_${ci}$sptrs( uplo, n, 1, afp, ipiv, work, n, info )
                 call stdlib_${ci}$axpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_${ci}$lacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_${ci}$lacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_${ci}$sptrs( uplo, n, 1, afp, ipiv, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_${ci}$sptrs( uplo, n, 1, afp, ipiv, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_${ci}$sprfs

#:endif
#:endfor



     module pure subroutine stdlib_ssyequb( uplo, n, a, lda, s, scond, amax, work, info )
     !! SSYEQUB computes row and column scalings intended to equilibrate a
     !! symmetric matrix A (with respect to the Euclidean norm) and reduce
     !! its condition number. The scale factors S are computed by the BIN
     !! algorithm (see references) so that the scaled matrix B with elements
     !! B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
     !! the smallest possible condition number over all possible diagonal
     !! scalings.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(out) :: amax, scond
           character, intent(in) :: uplo
           ! Array Arguments 
           real(sp), intent(in) :: a(lda,*)
           real(sp), intent(out) :: s(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: max_iter = 100
           
           
           ! Local Scalars 
           integer(ilp) :: i, j, iter
           real(sp) :: avg, std, tol, c0, c1, c2, t, u, si, d, base, smin, smax, smlnum, bignum, &
                     scale, sumsq
           logical(lk) :: up
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if ( .not. ( stdlib_lsame( uplo, 'U' ) .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -1
           else if ( n < 0 ) then
              info = -2
           else if ( lda < max( 1, n ) ) then
              info = -4
           end if
           if ( info /= 0 ) then
              call stdlib_xerbla( 'SSYEQUB', -info )
              return
           end if
           up = stdlib_lsame( uplo, 'U' )
           amax = zero
           ! quick return if possible.
           if ( n == 0 ) then
              scond = one
              return
           end if
           do i = 1, n
              s( i ) = zero
           end do
           amax = zero
           if ( up ) then
              do j = 1, n
                 do i = 1, j-1
                    s( i ) = max( s( i ), abs( a( i, j ) ) )
                    s( j ) = max( s( j ), abs( a( i, j ) ) )
                    amax = max( amax, abs( a( i, j ) ) )
                 end do
                 s( j ) = max( s( j ), abs( a( j, j ) ) )
                 amax = max( amax, abs( a( j, j ) ) )
              end do
           else
              do j = 1, n
                 s( j ) = max( s( j ), abs( a( j, j ) ) )
                 amax = max( amax, abs( a( j, j ) ) )
                 do i = j+1, n
                    s( i ) = max( s( i ), abs( a( i, j ) ) )
                    s( j ) = max( s( j ), abs( a( i, j ) ) )
                    amax = max( amax, abs( a( i, j ) ) )
                 end do
              end do
           end if
           do j = 1, n
              s( j ) = 1.0_sp / s( j )
           end do
           tol = one / sqrt( 2.0_sp * n )
           do iter = 1, max_iter
              scale = zero
              sumsq = zero
              ! beta = |a|s
              do i = 1, n
                 work( i ) = zero
              end do
              if ( up ) then
                 do j = 1, n
                    do i = 1, j-1
                       work( i ) = work( i ) + abs( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + abs( a( i, j ) ) * s( i )
                    end do
                    work( j ) = work( j ) + abs( a( j, j ) ) * s( j )
                 end do
              else
                 do j = 1, n
                    work( j ) = work( j ) + abs( a( j, j ) ) * s( j )
                    do i = j+1, n
                       work( i ) = work( i ) + abs( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + abs( a( i, j ) ) * s( i )
                    end do
                 end do
              end if
              ! avg = s^t beta / n
              avg = zero
              do i = 1, n
                 avg = avg + s( i )*work( i )
              end do
              avg = avg / n
              std = zero
              do i = n+1, 2*n
                 work( i ) = s( i-n ) * work( i-n ) - avg
              end do
              call stdlib_slassq( n, work( n+1 ), 1, scale, sumsq )
              std = scale * sqrt( sumsq / n )
              if ( std < tol * avg ) goto 999
              do i = 1, n
                 t = abs( a( i, i ) )
                 si = s( i )
                 c2 = ( n-1 ) * t
                 c1 = ( n-2 ) * ( work( i ) - t*si )
                 c0 = -(t*si)*si + 2*work( i )*si - n*avg
                 d = c1*c1 - 4*c0*c2
                 if ( d <= 0 ) then
                    info = -1
                    return
                 end if
                 si = -2*c0 / ( c1 + sqrt( d ) )
                 d = si - s( i )
                 u = zero
                 if ( up ) then
                    do j = 1, i
                       t = abs( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = abs( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 else
                    do j = 1, i
                       t = abs( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = abs( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 end if
                 avg = avg + ( u + work( i ) ) * d / n
                 s( i ) = si
              end do
           end do
           999 continue
           smlnum = stdlib_slamch( 'SAFEMIN' )
           bignum = one / smlnum
           smin = bignum
           smax = zero
           t = one / sqrt( avg )
           base = stdlib_slamch( 'B' )
           u = one / log( base )
           do i = 1, n
              s( i ) = base ** int( u * log( s( i ) * t ),KIND=ilp)
              smin = min( smin, s( i ) )
              smax = max( smax, s( i ) )
           end do
           scond = max( smin, smlnum ) / min( smax, bignum )
     end subroutine stdlib_ssyequb

     module pure subroutine stdlib_dsyequb( uplo, n, a, lda, s, scond, amax, work, info )
     !! DSYEQUB computes row and column scalings intended to equilibrate a
     !! symmetric matrix A (with respect to the Euclidean norm) and reduce
     !! its condition number. The scale factors S are computed by the BIN
     !! algorithm (see references) so that the scaled matrix B with elements
     !! B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
     !! the smallest possible condition number over all possible diagonal
     !! scalings.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(dp), intent(out) :: amax, scond
           character, intent(in) :: uplo
           ! Array Arguments 
           real(dp), intent(in) :: a(lda,*)
           real(dp), intent(out) :: s(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: max_iter = 100
           
           
           ! Local Scalars 
           integer(ilp) :: i, j, iter
           real(dp) :: avg, std, tol, c0, c1, c2, t, u, si, d, base, smin, smax, smlnum, bignum, &
                     scale, sumsq
           logical(lk) :: up
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if ( .not. ( stdlib_lsame( uplo, 'U' ) .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -1
           else if ( n < 0 ) then
              info = -2
           else if ( lda < max( 1, n ) ) then
              info = -4
           end if
           if ( info /= 0 ) then
              call stdlib_xerbla( 'DSYEQUB', -info )
              return
           end if
           up = stdlib_lsame( uplo, 'U' )
           amax = zero
           ! quick return if possible.
           if ( n == 0 ) then
              scond = one
              return
           end if
           do i = 1, n
              s( i ) = zero
           end do
           amax = zero
           if ( up ) then
              do j = 1, n
                 do i = 1, j-1
                    s( i ) = max( s( i ), abs( a( i, j ) ) )
                    s( j ) = max( s( j ), abs( a( i, j ) ) )
                    amax = max( amax, abs( a( i, j ) ) )
                 end do
                 s( j ) = max( s( j ), abs( a( j, j ) ) )
                 amax = max( amax, abs( a( j, j ) ) )
              end do
           else
              do j = 1, n
                 s( j ) = max( s( j ), abs( a( j, j ) ) )
                 amax = max( amax, abs( a( j, j ) ) )
                 do i = j+1, n
                    s( i ) = max( s( i ), abs( a( i, j ) ) )
                    s( j ) = max( s( j ), abs( a( i, j ) ) )
                    amax = max( amax, abs( a( i, j ) ) )
                 end do
              end do
           end if
           do j = 1, n
              s( j ) = 1.0_dp / s( j )
           end do
           tol = one / sqrt( 2.0_dp * n )
           do iter = 1, max_iter
              scale = zero
              sumsq = zero
              ! beta = |a|s
              do i = 1, n
                 work( i ) = zero
              end do
              if ( up ) then
                 do j = 1, n
                    do i = 1, j-1
                       work( i ) = work( i ) + abs( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + abs( a( i, j ) ) * s( i )
                    end do
                    work( j ) = work( j ) + abs( a( j, j ) ) * s( j )
                 end do
              else
                 do j = 1, n
                    work( j ) = work( j ) + abs( a( j, j ) ) * s( j )
                    do i = j+1, n
                       work( i ) = work( i ) + abs( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + abs( a( i, j ) ) * s( i )
                    end do
                 end do
              end if
              ! avg = s^t beta / n
              avg = zero
              do i = 1, n
                 avg = avg + s( i )*work( i )
              end do
              avg = avg / n
              std = zero
              do i = n+1, 2*n
                 work( i ) = s( i-n ) * work( i-n ) - avg
              end do
              call stdlib_dlassq( n, work( n+1 ), 1, scale, sumsq )
              std = scale * sqrt( sumsq / n )
              if ( std < tol * avg ) goto 999
              do i = 1, n
                 t = abs( a( i, i ) )
                 si = s( i )
                 c2 = ( n-1 ) * t
                 c1 = ( n-2 ) * ( work( i ) - t*si )
                 c0 = -(t*si)*si + 2*work( i )*si - n*avg
                 d = c1*c1 - 4*c0*c2
                 if ( d <= 0 ) then
                    info = -1
                    return
                 end if
                 si = -2*c0 / ( c1 + sqrt( d ) )
                 d = si - s( i )
                 u = zero
                 if ( up ) then
                    do j = 1, i
                       t = abs( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = abs( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 else
                    do j = 1, i
                       t = abs( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = abs( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 end if
                 avg = avg + ( u + work( i ) ) * d / n
                 s( i ) = si
              end do
           end do
           999 continue
           smlnum = stdlib_dlamch( 'SAFEMIN' )
           bignum = one / smlnum
           smin = bignum
           smax = zero
           t = one / sqrt( avg )
           base = stdlib_dlamch( 'B' )
           u = one / log( base )
           do i = 1, n
              s( i ) = base ** int( u * log( s( i ) * t ),KIND=ilp)
              smin = min( smin, s( i ) )
              smax = max( smax, s( i ) )
           end do
           scond = max( smin, smlnum ) / min( smax, bignum )
     end subroutine stdlib_dsyequb

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$syequb( uplo, n, a, lda, s, scond, amax, work, info )
     !! DSYEQUB: computes row and column scalings intended to equilibrate a
     !! symmetric matrix A (with respect to the Euclidean norm) and reduce
     !! its condition number. The scale factors S are computed by the BIN
     !! algorithm (see references) so that the scaled matrix B with elements
     !! B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
     !! the smallest possible condition number over all possible diagonal
     !! scalings.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(${rk}$), intent(out) :: amax, scond
           character, intent(in) :: uplo
           ! Array Arguments 
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(out) :: s(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: max_iter = 100
           
           
           ! Local Scalars 
           integer(ilp) :: i, j, iter
           real(${rk}$) :: avg, std, tol, c0, c1, c2, t, u, si, d, base, smin, smax, smlnum, bignum, &
                     scale, sumsq
           logical(lk) :: up
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if ( .not. ( stdlib_lsame( uplo, 'U' ) .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -1
           else if ( n < 0 ) then
              info = -2
           else if ( lda < max( 1, n ) ) then
              info = -4
           end if
           if ( info /= 0 ) then
              call stdlib_xerbla( 'DSYEQUB', -info )
              return
           end if
           up = stdlib_lsame( uplo, 'U' )
           amax = zero
           ! quick return if possible.
           if ( n == 0 ) then
              scond = one
              return
           end if
           do i = 1, n
              s( i ) = zero
           end do
           amax = zero
           if ( up ) then
              do j = 1, n
                 do i = 1, j-1
                    s( i ) = max( s( i ), abs( a( i, j ) ) )
                    s( j ) = max( s( j ), abs( a( i, j ) ) )
                    amax = max( amax, abs( a( i, j ) ) )
                 end do
                 s( j ) = max( s( j ), abs( a( j, j ) ) )
                 amax = max( amax, abs( a( j, j ) ) )
              end do
           else
              do j = 1, n
                 s( j ) = max( s( j ), abs( a( j, j ) ) )
                 amax = max( amax, abs( a( j, j ) ) )
                 do i = j+1, n
                    s( i ) = max( s( i ), abs( a( i, j ) ) )
                    s( j ) = max( s( j ), abs( a( i, j ) ) )
                    amax = max( amax, abs( a( i, j ) ) )
                 end do
              end do
           end if
           do j = 1, n
              s( j ) = 1.0_${rk}$ / s( j )
           end do
           tol = one / sqrt( 2.0_${rk}$ * n )
           do iter = 1, max_iter
              scale = zero
              sumsq = zero
              ! beta = |a|s
              do i = 1, n
                 work( i ) = zero
              end do
              if ( up ) then
                 do j = 1, n
                    do i = 1, j-1
                       work( i ) = work( i ) + abs( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + abs( a( i, j ) ) * s( i )
                    end do
                    work( j ) = work( j ) + abs( a( j, j ) ) * s( j )
                 end do
              else
                 do j = 1, n
                    work( j ) = work( j ) + abs( a( j, j ) ) * s( j )
                    do i = j+1, n
                       work( i ) = work( i ) + abs( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + abs( a( i, j ) ) * s( i )
                    end do
                 end do
              end if
              ! avg = s^t beta / n
              avg = zero
              do i = 1, n
                 avg = avg + s( i )*work( i )
              end do
              avg = avg / n
              std = zero
              do i = n+1, 2*n
                 work( i ) = s( i-n ) * work( i-n ) - avg
              end do
              call stdlib_${ri}$lassq( n, work( n+1 ), 1, scale, sumsq )
              std = scale * sqrt( sumsq / n )
              if ( std < tol * avg ) goto 999
              do i = 1, n
                 t = abs( a( i, i ) )
                 si = s( i )
                 c2 = ( n-1 ) * t
                 c1 = ( n-2 ) * ( work( i ) - t*si )
                 c0 = -(t*si)*si + 2*work( i )*si - n*avg
                 d = c1*c1 - 4*c0*c2
                 if ( d <= 0 ) then
                    info = -1
                    return
                 end if
                 si = -2*c0 / ( c1 + sqrt( d ) )
                 d = si - s( i )
                 u = zero
                 if ( up ) then
                    do j = 1, i
                       t = abs( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = abs( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 else
                    do j = 1, i
                       t = abs( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = abs( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 end if
                 avg = avg + ( u + work( i ) ) * d / n
                 s( i ) = si
              end do
           end do
           999 continue
           smlnum = stdlib_${ri}$lamch( 'SAFEMIN' )
           bignum = one / smlnum
           smin = bignum
           smax = zero
           t = one / sqrt( avg )
           base = stdlib_${ri}$lamch( 'B' )
           u = one / log( base )
           do i = 1, n
              s( i ) = base ** int( u * log( s( i ) * t ),KIND=ilp)
              smin = min( smin, s( i ) )
              smax = max( smax, s( i ) )
           end do
           scond = max( smin, smlnum ) / min( smax, bignum )
     end subroutine stdlib_${ri}$syequb

#:endif
#:endfor

     module pure subroutine stdlib_csyequb( uplo, n, a, lda, s, scond, amax, work, info )
     !! CSYEQUB computes row and column scalings intended to equilibrate a
     !! symmetric matrix A (with respect to the Euclidean norm) and reduce
     !! its condition number. The scale factors S are computed by the BIN
     !! algorithm (see references) so that the scaled matrix B with elements
     !! B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
     !! the smallest possible condition number over all possible diagonal
     !! scalings.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(out) :: amax, scond
           character, intent(in) :: uplo
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
           real(sp), intent(out) :: s(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: max_iter = 100
           
           
           ! Local Scalars 
           integer(ilp) :: i, j, iter
           real(sp) :: avg, std, tol, c0, c1, c2, t, u, si, d, base, smin, smax, smlnum, bignum, &
                     scale, sumsq
           logical(lk) :: up
           complex(sp) :: zdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if ( .not. ( stdlib_lsame( uplo, 'U' ) .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -1
           else if ( n < 0 ) then
              info = -2
           else if ( lda < max( 1, n ) ) then
              info = -4
           end if
           if ( info /= 0 ) then
              call stdlib_xerbla( 'CSYEQUB', -info )
              return
           end if
           up = stdlib_lsame( uplo, 'U' )
           amax = zero
           ! quick return if possible.
           if ( n == 0 ) then
              scond = one
              return
           end if
           do i = 1, n
              s( i ) = zero
           end do
           amax = zero
           if ( up ) then
              do j = 1, n
                 do i = 1, j-1
                    s( i ) = max( s( i ), cabs1( a( i, j ) ) )
                    s( j ) = max( s( j ), cabs1( a( i, j ) ) )
                    amax = max( amax, cabs1( a( i, j ) ) )
                 end do
                 s( j ) = max( s( j ), cabs1( a( j, j ) ) )
                 amax = max( amax, cabs1( a( j, j ) ) )
              end do
           else
              do j = 1, n
                 s( j ) = max( s( j ), cabs1( a( j, j ) ) )
                 amax = max( amax, cabs1( a( j, j ) ) )
                 do i = j+1, n
                    s( i ) = max( s( i ), cabs1( a( i, j ) ) )
                    s( j ) = max( s( j ), cabs1( a( i, j ) ) )
                    amax = max( amax, cabs1( a( i, j ) ) )
                 end do
              end do
           end if
           do j = 1, n
              s( j ) = 1.0_sp / s( j )
           end do
           tol = one / sqrt( 2.0_sp * n )
           do iter = 1, max_iter
              scale = zero
              sumsq = zero
              ! beta = |a|s
              do i = 1, n
                  work( i ) = zero
              end do
              if ( up ) then
                 do j = 1, n
                    do i = 1, j-1
                       work( i ) = work( i ) + cabs1( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + cabs1( a( i, j ) ) * s( i )
                    end do
                    work( j ) = work( j ) + cabs1( a( j, j ) ) * s( j )
                 end do
              else
                 do j = 1, n
                    work( j ) = work( j ) + cabs1( a( j, j ) ) * s( j )
                    do i = j+1, n
                       work( i ) = work( i ) + cabs1( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + cabs1( a( i, j ) ) * s( i )
                    end do
                 end do
              end if
              ! avg = s^t beta / n
              avg = zero
              do i = 1, n
                 avg = avg + real( s( i )*work( i ),KIND=sp)
              end do
              avg = avg / n
              std = zero
              do i = n+1, 2*n
                 work( i ) = s( i-n ) * work( i-n ) - avg
              end do
              call stdlib_classq( n, work( n+1 ), 1, scale, sumsq )
              std = scale * sqrt( sumsq / n )
              if ( std < tol * avg ) goto 999
              do i = 1, n
                 t = cabs1( a( i, i ) )
                 si = s( i )
                 c2 = ( n-1 ) * t
                 c1 = real( n-2,KIND=sp) * ( real( work( i ),KIND=sp) - t*si )
                 c0 = -(t*si)*si + 2 * real( work( i ),KIND=sp) * si - n*avg
                 d = c1*c1 - 4*c0*c2
                 if ( d <= 0 ) then
                    info = -1
                    return
                 end if
                 si = -2*c0 / ( c1 + sqrt( d ) )
                 d = si - s( i )
                 u = zero
                 if ( up ) then
                    do j = 1, i
                       t = cabs1( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = cabs1( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 else
                    do j = 1, i
                       t = cabs1( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = cabs1( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 end if
                 avg = avg + ( u + real( work( i ),KIND=sp) ) * d / n
                 s( i ) = si
              end do
           end do
           999 continue
           smlnum = stdlib_slamch( 'SAFEMIN' )
           bignum = one / smlnum
           smin = bignum
           smax = zero
           t = one / sqrt( avg )
           base = stdlib_slamch( 'B' )
           u = one / log( base )
           do i = 1, n
              s( i ) = base ** int( u * log( s( i ) * t ),KIND=ilp)
              smin = min( smin, s( i ) )
              smax = max( smax, s( i ) )
           end do
           scond = max( smin, smlnum ) / min( smax, bignum )
     end subroutine stdlib_csyequb

     module pure subroutine stdlib_zsyequb( uplo, n, a, lda, s, scond, amax, work, info )
     !! ZSYEQUB computes row and column scalings intended to equilibrate a
     !! symmetric matrix A (with respect to the Euclidean norm) and reduce
     !! its condition number. The scale factors S are computed by the BIN
     !! algorithm (see references) so that the scaled matrix B with elements
     !! B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
     !! the smallest possible condition number over all possible diagonal
     !! scalings.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(dp), intent(out) :: amax, scond
           character, intent(in) :: uplo
           ! Array Arguments 
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(out) :: work(*)
           real(dp), intent(out) :: s(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: max_iter = 100
           
           
           ! Local Scalars 
           integer(ilp) :: i, j, iter
           real(dp) :: avg, std, tol, c0, c1, c2, t, u, si, d, base, smin, smax, smlnum, bignum, &
                     scale, sumsq
           logical(lk) :: up
           complex(dp) :: zdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=dp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if ( .not. ( stdlib_lsame( uplo, 'U' ) .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -1
           else if ( n < 0 ) then
              info = -2
           else if ( lda < max( 1, n ) ) then
              info = -4
           end if
           if ( info /= 0 ) then
              call stdlib_xerbla( 'ZSYEQUB', -info )
              return
           end if
           up = stdlib_lsame( uplo, 'U' )
           amax = zero
           ! quick return if possible.
           if ( n == 0 ) then
              scond = one
              return
           end if
           do i = 1, n
              s( i ) = zero
           end do
           amax = zero
           if ( up ) then
              do j = 1, n
                 do i = 1, j-1
                    s( i ) = max( s( i ), cabs1( a( i, j ) ) )
                    s( j ) = max( s( j ), cabs1( a( i, j ) ) )
                    amax = max( amax, cabs1( a( i, j ) ) )
                 end do
                 s( j ) = max( s( j ), cabs1( a( j, j ) ) )
                 amax = max( amax, cabs1( a( j, j ) ) )
              end do
           else
              do j = 1, n
                 s( j ) = max( s( j ), cabs1( a( j, j ) ) )
                 amax = max( amax, cabs1( a( j, j ) ) )
                 do i = j+1, n
                    s( i ) = max( s( i ), cabs1( a( i, j ) ) )
                    s( j ) = max( s( j ), cabs1( a( i, j ) ) )
                    amax = max( amax, cabs1( a( i, j ) ) )
                 end do
              end do
           end if
           do j = 1, n
              s( j ) = 1.0_dp / s( j )
           end do
           tol = one / sqrt( 2.0_dp * n )
           do iter = 1, max_iter
              scale = zero
              sumsq = zero
              ! beta = |a|s
              do i = 1, n
                 work( i ) = zero
              end do
              if ( up ) then
                 do j = 1, n
                    do i = 1, j-1
                       work( i ) = work( i ) + cabs1( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + cabs1( a( i, j ) ) * s( i )
                    end do
                    work( j ) = work( j ) + cabs1( a( j, j ) ) * s( j )
                 end do
              else
                 do j = 1, n
                    work( j ) = work( j ) + cabs1( a( j, j ) ) * s( j )
                    do i = j+1, n
                       work( i ) = work( i ) + cabs1( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + cabs1( a( i, j ) ) * s( i )
                    end do
                 end do
              end if
              ! avg = s^t beta / n
              avg = zero
              do i = 1, n
                 avg = avg + s( i ) * real( work( i ),KIND=dp)
              end do
              avg = avg / n
              std = zero
              do i = n+1, 2*n
                 work( i ) = s( i-n ) * work( i-n ) - avg
              end do
              call stdlib_zlassq( n, work( n+1 ), 1, scale, sumsq )
              std = scale * sqrt( sumsq / n )
              if ( std < tol * avg ) goto 999
              do i = 1, n
                 t = cabs1( a( i, i ) )
                 si = s( i )
                 c2 = ( n-1 ) * t
                 c1 = ( n-2 ) * ( real( work( i ),KIND=dp) - t*si )
                 c0 = -(t*si)*si + 2 * real( work( i ),KIND=dp) * si - n*avg
                 d = c1*c1 - 4*c0*c2
                 if ( d <= 0 ) then
                    info = -1
                    return
                 end if
                 si = -2*c0 / ( c1 + sqrt( d ) )
                 d = si - s( i )
                 u = zero
                 if ( up ) then
                    do j = 1, i
                       t = cabs1( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = cabs1( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 else
                    do j = 1, i
                       t = cabs1( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = cabs1( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 end if
                 avg = avg + ( u + real( work( i ),KIND=dp) ) * d / n
                 s( i ) = si
              end do
           end do
           999 continue
           smlnum = stdlib_dlamch( 'SAFEMIN' )
           bignum = one / smlnum
           smin = bignum
           smax = zero
           t = one / sqrt( avg )
           base = stdlib_dlamch( 'B' )
           u = one / log( base )
           do i = 1, n
              s( i ) = base ** int( u * log( s( i ) * t ),KIND=ilp)
              smin = min( smin, s( i ) )
              smax = max( smax, s( i ) )
           end do
           scond = max( smin, smlnum ) / min( smax, bignum )
     end subroutine stdlib_zsyequb

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$syequb( uplo, n, a, lda, s, scond, amax, work, info )
     !! ZSYEQUB: computes row and column scalings intended to equilibrate a
     !! symmetric matrix A (with respect to the Euclidean norm) and reduce
     !! its condition number. The scale factors S are computed by the BIN
     !! algorithm (see references) so that the scaled matrix B with elements
     !! B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
     !! the smallest possible condition number over all possible diagonal
     !! scalings.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(${ck}$), intent(out) :: amax, scond
           character, intent(in) :: uplo
           ! Array Arguments 
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*)
           real(${ck}$), intent(out) :: s(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: max_iter = 100
           
           
           ! Local Scalars 
           integer(ilp) :: i, j, iter
           real(${ck}$) :: avg, std, tol, c0, c1, c2, t, u, si, d, base, smin, smax, smlnum, bignum, &
                     scale, sumsq
           logical(lk) :: up
           complex(${ck}$) :: zdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=${ck}$) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if ( .not. ( stdlib_lsame( uplo, 'U' ) .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -1
           else if ( n < 0 ) then
              info = -2
           else if ( lda < max( 1, n ) ) then
              info = -4
           end if
           if ( info /= 0 ) then
              call stdlib_xerbla( 'ZSYEQUB', -info )
              return
           end if
           up = stdlib_lsame( uplo, 'U' )
           amax = zero
           ! quick return if possible.
           if ( n == 0 ) then
              scond = one
              return
           end if
           do i = 1, n
              s( i ) = zero
           end do
           amax = zero
           if ( up ) then
              do j = 1, n
                 do i = 1, j-1
                    s( i ) = max( s( i ), cabs1( a( i, j ) ) )
                    s( j ) = max( s( j ), cabs1( a( i, j ) ) )
                    amax = max( amax, cabs1( a( i, j ) ) )
                 end do
                 s( j ) = max( s( j ), cabs1( a( j, j ) ) )
                 amax = max( amax, cabs1( a( j, j ) ) )
              end do
           else
              do j = 1, n
                 s( j ) = max( s( j ), cabs1( a( j, j ) ) )
                 amax = max( amax, cabs1( a( j, j ) ) )
                 do i = j+1, n
                    s( i ) = max( s( i ), cabs1( a( i, j ) ) )
                    s( j ) = max( s( j ), cabs1( a( i, j ) ) )
                    amax = max( amax, cabs1( a( i, j ) ) )
                 end do
              end do
           end if
           do j = 1, n
              s( j ) = 1.0_${ck}$ / s( j )
           end do
           tol = one / sqrt( 2.0_${ck}$ * n )
           do iter = 1, max_iter
              scale = zero
              sumsq = zero
              ! beta = |a|s
              do i = 1, n
                 work( i ) = zero
              end do
              if ( up ) then
                 do j = 1, n
                    do i = 1, j-1
                       work( i ) = work( i ) + cabs1( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + cabs1( a( i, j ) ) * s( i )
                    end do
                    work( j ) = work( j ) + cabs1( a( j, j ) ) * s( j )
                 end do
              else
                 do j = 1, n
                    work( j ) = work( j ) + cabs1( a( j, j ) ) * s( j )
                    do i = j+1, n
                       work( i ) = work( i ) + cabs1( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + cabs1( a( i, j ) ) * s( i )
                    end do
                 end do
              end if
              ! avg = s^t beta / n
              avg = zero
              do i = 1, n
                 avg = avg + s( i ) * real( work( i ),KIND=${ck}$)
              end do
              avg = avg / n
              std = zero
              do i = n+1, 2*n
                 work( i ) = s( i-n ) * work( i-n ) - avg
              end do
              call stdlib_${ci}$lassq( n, work( n+1 ), 1, scale, sumsq )
              std = scale * sqrt( sumsq / n )
              if ( std < tol * avg ) goto 999
              do i = 1, n
                 t = cabs1( a( i, i ) )
                 si = s( i )
                 c2 = ( n-1 ) * t
                 c1 = ( n-2 ) * ( real( work( i ),KIND=${ck}$) - t*si )
                 c0 = -(t*si)*si + 2 * real( work( i ),KIND=${ck}$) * si - n*avg
                 d = c1*c1 - 4*c0*c2
                 if ( d <= 0 ) then
                    info = -1
                    return
                 end if
                 si = -2*c0 / ( c1 + sqrt( d ) )
                 d = si - s( i )
                 u = zero
                 if ( up ) then
                    do j = 1, i
                       t = cabs1( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = cabs1( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 else
                    do j = 1, i
                       t = cabs1( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = cabs1( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 end if
                 avg = avg + ( u + real( work( i ),KIND=${ck}$) ) * d / n
                 s( i ) = si
              end do
           end do
           999 continue
           smlnum = stdlib_${c2ri(ci)}$lamch( 'SAFEMIN' )
           bignum = one / smlnum
           smin = bignum
           smax = zero
           t = one / sqrt( avg )
           base = stdlib_${c2ri(ci)}$lamch( 'B' )
           u = one / log( base )
           do i = 1, n
              s( i ) = base ** int( u * log( s( i ) * t ),KIND=ilp)
              smin = min( smin, s( i ) )
              smax = max( smax, s( i ) )
           end do
           scond = max( smin, smlnum ) / min( smax, bignum )
     end subroutine stdlib_${ci}$syequb

#:endif
#:endfor



     module real(sp) function stdlib_cla_herpvgrw( uplo, n, info, a, lda, af, ldaf, ipiv,work )
     !! CLA_HERPVGRW computes the reciprocal pivot growth factor
     !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
     !! much less than 1, the stability of the LU factorization of the
     !! (equilibrated) matrix A could be poor. This also means that the
     !! solution X, estimated condition numbers, and error bounds could be
     !! unreliable.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, info, lda, ldaf
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: ncols, i, j, k, kp
           real(sp) :: amax, umax, rpvgrw, tmp
           logical(lk) :: upper
           complex(sp) :: zdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag ( zdum ) )
           ! Executable Statements 
           upper = stdlib_lsame( 'UPPER', uplo )
           if ( info==0 ) then
              if (upper) then
                 ncols = 1
              else
                 ncols = n
              end if
           else
              ncols = info
           end if
           rpvgrw = one
           do i = 1, 2*n
              work( i ) = zero
           end do
           ! find the max magnitude entry of each column of a.  compute the max
           ! for all n columns so we can apply the pivot permutation while
           ! looping below.  assume a full factorization is the common case.
           if ( upper ) then
              do j = 1, n
                 do i = 1, j
                    work( n+i ) = max( cabs1( a( i,j ) ), work( n+i ) )
                    work( n+j ) = max( cabs1( a( i,j ) ), work( n+j ) )
                 end do
              end do
           else
              do j = 1, n
                 do i = j, n
                    work( n+i ) = max( cabs1( a( i, j ) ), work( n+i ) )
                    work( n+j ) = max( cabs1( a( i, j ) ), work( n+j ) )
                 end do
              end do
           end if
           ! now find the max magnitude entry of each column of u or l.  also
           ! permute the magnitudes of a above so they're in the same order as
           ! the factor.
           ! the iteration orders and permutations were copied from stdlib_csytrs.
           ! calls to stdlib_sswap would be severe overkill.
           if ( upper ) then
              k = n
              do while ( k < ncols .and. k>0 )
                 if ( ipiv( k )>0 ) then
                    ! 1x1 pivot
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    do i = 1, k
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                    end do
                    k = k - 1
                 else
                    ! 2x2 pivot
                    kp = -ipiv( k )
                    tmp = work( n+k-1 )
                    work( n+k-1 ) = work( n+kp )
                    work( n+kp ) = tmp
                    do i = 1, k-1
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                       work( k-1 ) =max( cabs1( af( i, k-1 ) ), work( k-1 ) )
                    end do
                    work( k ) = max( cabs1( af( k, k ) ), work( k ) )
                    k = k - 2
                 end if
              end do
              k = ncols
              do while ( k <= n )
                 if ( ipiv( k )>0 ) then
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    k = k + 1
                 else
                    kp = -ipiv( k )
                    tmp = work( n+k )
                    work( n+k ) = work( n+kp )
                    work( n+kp ) = tmp
                    k = k + 2
                 end if
              end do
           else
              k = 1
              do while ( k <= ncols )
                 if ( ipiv( k )>0 ) then
                    ! 1x1 pivot
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    do i = k, n
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                    end do
                    k = k + 1
                 else
                    ! 2x2 pivot
                    kp = -ipiv( k )
                    tmp = work( n+k+1 )
                    work( n+k+1 ) = work( n+kp )
                    work( n+kp ) = tmp
                    do i = k+1, n
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                       work( k+1 ) =max( cabs1( af( i, k+1 ) ) , work( k+1 ) )
                    end do
                    work(k) = max( cabs1( af( k, k ) ), work( k ) )
                    k = k + 2
                 end if
              end do
              k = ncols
              do while ( k >= 1 )
                 if ( ipiv( k )>0 ) then
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    k = k - 1
                 else
                    kp = -ipiv( k )
                    tmp = work( n+k )
                    work( n+k ) = work( n+kp )
                    work( n+kp ) = tmp
                    k = k - 2
                 endif
              end do
           end if
           ! compute the *inverse* of the max element growth factor.  dividing
           ! by zero would imply the largest entry of the factor's column is
           ! zero.  than can happen when either the column of a is zero or
           ! massive pivots made the factor underflow to zero.  neither counts
           ! as growth in itself, so simply ignore terms with zero
           ! denominators.
           if ( upper ) then
              do i = ncols, n
                 umax = work( i )
                 amax = work( n+i )
                 if ( umax /= 0.0_sp ) then
                    rpvgrw = min( amax / umax, rpvgrw )
                 end if
              end do
           else
              do i = 1, ncols
                 umax = work( i )
                 amax = work( n+i )
                 if ( umax /= 0.0_sp ) then
                    rpvgrw = min( amax / umax, rpvgrw )
                 end if
              end do
           end if
           stdlib_cla_herpvgrw = rpvgrw
     end function stdlib_cla_herpvgrw

     module real(dp) function stdlib_zla_herpvgrw( uplo, n, info, a, lda, af,ldaf, ipiv, work )
     !! ZLA_HERPVGRW computes the reciprocal pivot growth factor
     !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
     !! much less than 1, the stability of the LU factorization of the
     !! (equilibrated) matrix A could be poor. This also means that the
     !! solution X, estimated condition numbers, and error bounds could be
     !! unreliable.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, info, lda, ldaf
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: a(lda,*), af(ldaf,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: ncols, i, j, k, kp
           real(dp) :: amax, umax, rpvgrw, tmp
           logical(lk) :: upper
           complex(dp) :: zdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=dp) ) + abs( aimag ( zdum ) )
           ! Executable Statements 
           upper = stdlib_lsame( 'UPPER', uplo )
           if ( info==0 ) then
              if (upper) then
                 ncols = 1
              else
                 ncols = n
              end if
           else
              ncols = info
           end if
           rpvgrw = one
           do i = 1, 2*n
              work( i ) = zero
           end do
           ! find the max magnitude entry of each column of a.  compute the max
           ! for all n columns so we can apply the pivot permutation while
           ! looping below.  assume a full factorization is the common case.
           if ( upper ) then
              do j = 1, n
                 do i = 1, j
                    work( n+i ) = max( cabs1( a( i,j ) ), work( n+i ) )
                    work( n+j ) = max( cabs1( a( i,j ) ), work( n+j ) )
                 end do
              end do
           else
              do j = 1, n
                 do i = j, n
                    work( n+i ) = max( cabs1( a( i, j ) ), work( n+i ) )
                    work( n+j ) = max( cabs1( a( i, j ) ), work( n+j ) )
                 end do
              end do
           end if
           ! now find the max magnitude entry of each column of u or l.  also
           ! permute the magnitudes of a above so they're in the same order as
           ! the factor.
           ! the iteration orders and permutations were copied from stdlib_zsytrs.
           ! calls to stdlib_sswap would be severe overkill.
           if ( upper ) then
              k = n
              do while ( k < ncols .and. k>0 )
                 if ( ipiv( k )>0 ) then
                    ! 1x1 pivot
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    do i = 1, k
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                    end do
                    k = k - 1
                 else
                    ! 2x2 pivot
                    kp = -ipiv( k )
                    tmp = work( n+k-1 )
                    work( n+k-1 ) = work( n+kp )
                    work( n+kp ) = tmp
                    do i = 1, k-1
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                       work( k-1 ) =max( cabs1( af( i, k-1 ) ), work( k-1 ) )
                    end do
                    work( k ) = max( cabs1( af( k, k ) ), work( k ) )
                    k = k - 2
                 end if
              end do
              k = ncols
              do while ( k <= n )
                 if ( ipiv( k )>0 ) then
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    k = k + 1
                 else
                    kp = -ipiv( k )
                    tmp = work( n+k )
                    work( n+k ) = work( n+kp )
                    work( n+kp ) = tmp
                    k = k + 2
                 end if
              end do
           else
              k = 1
              do while ( k <= ncols )
                 if ( ipiv( k )>0 ) then
                    ! 1x1 pivot
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    do i = k, n
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                    end do
                    k = k + 1
                 else
                    ! 2x2 pivot
                    kp = -ipiv( k )
                    tmp = work( n+k+1 )
                    work( n+k+1 ) = work( n+kp )
                    work( n+kp ) = tmp
                    do i = k+1, n
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                       work( k+1 ) =max( cabs1( af( i, k+1 ) ) , work( k+1 ) )
                    end do
                    work(k) = max( cabs1( af( k, k ) ), work( k ) )
                    k = k + 2
                 end if
              end do
              k = ncols
              do while ( k >= 1 )
                 if ( ipiv( k )>0 ) then
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    k = k - 1
                 else
                    kp = -ipiv( k )
                    tmp = work( n+k )
                    work( n+k ) = work( n+kp )
                    work( n+kp ) = tmp
                    k = k - 2
                 endif
              end do
           end if
           ! compute the *inverse* of the max element growth factor.  dividing
           ! by zero would imply the largest entry of the factor's column is
           ! zero.  than can happen when either the column of a is zero or
           ! massive pivots made the factor underflow to zero.  neither counts
           ! as growth in itself, so simply ignore terms with zero
           ! denominators.
           if ( upper ) then
              do i = ncols, n
                 umax = work( i )
                 amax = work( n+i )
                 if ( umax /= zero ) then
                    rpvgrw = min( amax / umax, rpvgrw )
                 end if
              end do
           else
              do i = 1, ncols
                 umax = work( i )
                 amax = work( n+i )
                 if ( umax /= zero ) then
                    rpvgrw = min( amax / umax, rpvgrw )
                 end if
              end do
           end if
           stdlib_zla_herpvgrw = rpvgrw
     end function stdlib_zla_herpvgrw

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module real(${ck}$) function stdlib_${ci}$la_herpvgrw( uplo, n, info, a, lda, af,ldaf, ipiv, work )
     !! ZLA_HERPVGRW: computes the reciprocal pivot growth factor
     !! norm(A)/norm(U). The "max absolute element" norm is used. If this is
     !! much less than 1, the stability of the LU factorization of the
     !! (equilibrated) matrix A could be poor. This also means that the
     !! solution X, estimated condition numbers, and error bounds could be
     !! unreliable.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, info, lda, ldaf
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: a(lda,*), af(ldaf,*)
           real(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: ncols, i, j, k, kp
           real(${ck}$) :: amax, umax, rpvgrw, tmp
           logical(lk) :: upper
           complex(${ck}$) :: zdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=${ck}$) ) + abs( aimag ( zdum ) )
           ! Executable Statements 
           upper = stdlib_lsame( 'UPPER', uplo )
           if ( info==0 ) then
              if (upper) then
                 ncols = 1
              else
                 ncols = n
              end if
           else
              ncols = info
           end if
           rpvgrw = one
           do i = 1, 2*n
              work( i ) = zero
           end do
           ! find the max magnitude entry of each column of a.  compute the max
           ! for all n columns so we can apply the pivot permutation while
           ! looping below.  assume a full factorization is the common case.
           if ( upper ) then
              do j = 1, n
                 do i = 1, j
                    work( n+i ) = max( cabs1( a( i,j ) ), work( n+i ) )
                    work( n+j ) = max( cabs1( a( i,j ) ), work( n+j ) )
                 end do
              end do
           else
              do j = 1, n
                 do i = j, n
                    work( n+i ) = max( cabs1( a( i, j ) ), work( n+i ) )
                    work( n+j ) = max( cabs1( a( i, j ) ), work( n+j ) )
                 end do
              end do
           end if
           ! now find the max magnitude entry of each column of u or l.  also
           ! permute the magnitudes of a above so they're in the same order as
           ! the factor.
           ! the iteration orders and permutations were copied from stdlib_${ci}$sytrs.
           ! calls to stdlib_dswap would be severe overkill.
           if ( upper ) then
              k = n
              do while ( k < ncols .and. k>0 )
                 if ( ipiv( k )>0 ) then
                    ! 1x1 pivot
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    do i = 1, k
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                    end do
                    k = k - 1
                 else
                    ! 2x2 pivot
                    kp = -ipiv( k )
                    tmp = work( n+k-1 )
                    work( n+k-1 ) = work( n+kp )
                    work( n+kp ) = tmp
                    do i = 1, k-1
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                       work( k-1 ) =max( cabs1( af( i, k-1 ) ), work( k-1 ) )
                    end do
                    work( k ) = max( cabs1( af( k, k ) ), work( k ) )
                    k = k - 2
                 end if
              end do
              k = ncols
              do while ( k <= n )
                 if ( ipiv( k )>0 ) then
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    k = k + 1
                 else
                    kp = -ipiv( k )
                    tmp = work( n+k )
                    work( n+k ) = work( n+kp )
                    work( n+kp ) = tmp
                    k = k + 2
                 end if
              end do
           else
              k = 1
              do while ( k <= ncols )
                 if ( ipiv( k )>0 ) then
                    ! 1x1 pivot
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    do i = k, n
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                    end do
                    k = k + 1
                 else
                    ! 2x2 pivot
                    kp = -ipiv( k )
                    tmp = work( n+k+1 )
                    work( n+k+1 ) = work( n+kp )
                    work( n+kp ) = tmp
                    do i = k+1, n
                       work( k ) = max( cabs1( af( i, k ) ), work( k ) )
                       work( k+1 ) =max( cabs1( af( i, k+1 ) ) , work( k+1 ) )
                    end do
                    work(k) = max( cabs1( af( k, k ) ), work( k ) )
                    k = k + 2
                 end if
              end do
              k = ncols
              do while ( k >= 1 )
                 if ( ipiv( k )>0 ) then
                    kp = ipiv( k )
                    if ( kp /= k ) then
                       tmp = work( n+k )
                       work( n+k ) = work( n+kp )
                       work( n+kp ) = tmp
                    end if
                    k = k - 1
                 else
                    kp = -ipiv( k )
                    tmp = work( n+k )
                    work( n+k ) = work( n+kp )
                    work( n+kp ) = tmp
                    k = k - 2
                 endif
              end do
           end if
           ! compute the *inverse* of the max element growth factor.  dividing
           ! by zero would imply the largest entry of the factor's column is
           ! zero.  than can happen when either the column of a is zero or
           ! massive pivots made the factor underflow to zero.  neither counts
           ! as growth in itself, so simply ignore terms with zero
           ! denominators.
           if ( upper ) then
              do i = ncols, n
                 umax = work( i )
                 amax = work( n+i )
                 if ( umax /= zero ) then
                    rpvgrw = min( amax / umax, rpvgrw )
                 end if
              end do
           else
              do i = 1, ncols
                 umax = work( i )
                 amax = work( n+i )
                 if ( umax /= zero ) then
                    rpvgrw = min( amax / umax, rpvgrw )
                 end if
              end do
           end if
           stdlib_${ci}$la_herpvgrw = rpvgrw
     end function stdlib_${ci}$la_herpvgrw

#:endif
#:endfor



     module pure subroutine stdlib_chetrf( uplo, n, a, lda, ipiv, work, lwork, info )
     !! CHETRF computes the factorization of a complex Hermitian matrix A
     !! using the Bunch-Kaufman diagonal pivoting method.  The form of the
     !! factorization is
     !! A = U*D*U**H  or  A = L*D*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'CHETRF', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRF', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'CHETRF', uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clahef;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_clahef( uplo, k, nb, kb, a, lda, ipiv, work, n, iinfo )
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_chetf2( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clahef;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_clahef( uplo, n-k+1, nb, kb, a( k, k ), lda, ipiv( k ),work, n, &
                           iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_chetf2( uplo, n-k+1, a( k, k ), lda, ipiv( k ), iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chetrf

     module pure subroutine stdlib_zhetrf( uplo, n, a, lda, ipiv, work, lwork, info )
     !! ZHETRF computes the factorization of a complex Hermitian matrix A
     !! using the Bunch-Kaufman diagonal pivoting method.  The form of the
     !! factorization is
     !! A = U*D*U**H  or  A = L*D*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'ZHETRF', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRF', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'ZHETRF', uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_zlahef;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_zlahef( uplo, k, nb, kb, a, lda, ipiv, work, n, iinfo )
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_zhetf2( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_zlahef;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_zlahef( uplo, n-k+1, nb, kb, a( k, k ), lda, ipiv( k ),work, n, &
                           iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_zhetf2( uplo, n-k+1, a( k, k ), lda, ipiv( k ), iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zhetrf

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hetrf( uplo, n, a, lda, ipiv, work, lwork, info )
     !! ZHETRF: computes the factorization of a complex Hermitian matrix A
     !! using the Bunch-Kaufman diagonal pivoting method.  The form of the
     !! factorization is
     !! A = U*D*U**H  or  A = L*D*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'ZHETRF', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRF', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'ZHETRF', uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ci}$lahef;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_${ci}$lahef( uplo, k, nb, kb, a, lda, ipiv, work, n, iinfo )
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_${ci}$hetf2( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ci}$lahef;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_${ci}$lahef( uplo, n-k+1, nb, kb, a( k, k ), lda, ipiv( k ),work, n, &
                           iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_${ci}$hetf2( uplo, n-k+1, a( k, k ), lda, ipiv( k ), iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$hetrf

#:endif
#:endfor



     module pure subroutine stdlib_chetf2( uplo, n, a, lda, ipiv, info )
     !! CHETF2 computes the factorization of a complex Hermitian matrix A
     !! using the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**H  or  A = L*D*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**H is the conjugate transpose of U, and D is
     !! Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kk, kp, kstep
           real(sp) :: absakk, alpha, colmax, d, d11, d22, r1, rowmax, tt
           complex(sp) :: d12, d21, t, wk, wkm1, wkp1, zdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETF2', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 90
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) .or. stdlib_sisnan(absakk) ) then
                 ! column k is or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=sp)
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = imax + stdlib_icamax( k-imax, a( imax, imax+1 ), lda )
                    rowmax = cabs1( a( imax, jmax ) )
                    if( imax>1 ) then
                       jmax = stdlib_icamax( imax-1, a( 1, imax ), 1 )
                       rowmax = max( rowmax, cabs1( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( real( a( imax, imax ),KIND=sp) )>=alpha*rowmax )then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_cswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    do j = kp + 1, kk - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    r1 = real( a( kk, kk ),KIND=sp)
                    a( kk, kk ) = real( a( kp, kp ),KIND=sp)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       a( k, k ) = real( a( k, k ),KIND=sp)
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 else
                    a( k, k ) = real( a( k, k ),KIND=sp)
                    if( kstep==2 )a( k-1, k-1 ) = real( a( k-1, k-1 ),KIND=sp)
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**h = a - w(k)*1/d(k)*w(k)**h
                    r1 = one / real( a( k, k ),KIND=sp)
                    call stdlib_cher( uplo, k-1, -r1, a( 1, k ), 1, a, lda )
                    ! store u(k) in column k
                    call stdlib_csscal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**h
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**h
                    if( k>2 ) then
                       d = stdlib_slapy2( real( a( k-1, k ),KIND=sp),aimag( a( k-1, k ) ) )
                                 
                       d22 = real( a( k-1, k-1 ),KIND=sp) / d
                       d11 = real( a( k, k ),KIND=sp) / d
                       tt = one / ( d11*d22-one )
                       d12 = a( k-1, k ) / d
                       d = tt / d
                       do j = k - 2, 1, -1
                          wkm1 = d*( d11*a( j, k-1 )-conjg( d12 )*a( j, k ) )
                          wk = d*( d22*a( j, k )-d12*a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - a( i, k )*conjg( wk ) -a( i, k-1 )*conjg( &
                                       wkm1 )
                          end do
                          a( j, k ) = wk
                          a( j, k-1 ) = wkm1
                          a( j, j ) = cmplx( real( a( j, j ),KIND=sp), zero,KIND=sp)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              50 continue
              ! if k > n, exit from loop
              if( k>n )go to 90
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) .or. stdlib_sisnan(absakk) ) then
                 ! column k is zero or underflow, contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=sp)
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = k - 1 + stdlib_icamax( imax-k, a( imax, k ), lda )
                    rowmax = cabs1( a( imax, jmax ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_icamax( n-imax, a( imax+1, imax ), 1 )
                       rowmax = max( rowmax, cabs1( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( real( a( imax, imax ),KIND=sp) )>=alpha*rowmax )then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    do j = kk + 1, kp - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    r1 = real( a( kk, kk ),KIND=sp)
                    a( kk, kk ) = real( a( kp, kp ),KIND=sp)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       a( k, k ) = real( a( k, k ),KIND=sp)
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 else
                    a( k, k ) = real( a( k, k ),KIND=sp)
                    if( kstep==2 )a( k+1, k+1 ) = real( a( k+1, k+1 ),KIND=sp)
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**h = a - w(k)*(1/d(k))*w(k)**h
                       r1 = one / real( a( k, k ),KIND=sp)
                       call stdlib_cher( uplo, n-k, -r1, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                 
                       ! store l(k) in column k
                       call stdlib_csscal( n-k, r1, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k)
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**h
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**h
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d = stdlib_slapy2( real( a( k+1, k ),KIND=sp),aimag( a( k+1, k ) ) )
                                 
                       d11 = real( a( k+1, k+1 ),KIND=sp) / d
                       d22 = real( a( k, k ),KIND=sp) / d
                       tt = one / ( d11*d22-one )
                       d21 = a( k+1, k ) / d
                       d =  tt / d
                       do j = k + 2, n
                          wk = d*( d11*a( j, k )-d21*a( j, k+1 ) )
                          wkp1 = d*( d22*a( j, k+1 )-conjg( d21 )*a( j, k ) )
                          do i = j, n
                             a( i, j ) = a( i, j ) - a( i, k )*conjg( wk ) -a( i, k+1 )*conjg( &
                                       wkp1 )
                          end do
                          a( j, k ) = wk
                          a( j, k+1 ) = wkp1
                          a( j, j ) = cmplx( real( a( j, j ),KIND=sp), zero,KIND=sp)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 50
           end if
           90 continue
           return
     end subroutine stdlib_chetf2

     module pure subroutine stdlib_zhetf2( uplo, n, a, lda, ipiv, info )
     !! ZHETF2 computes the factorization of a complex Hermitian matrix A
     !! using the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**H  or  A = L*D*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**H is the conjugate transpose of U, and D is
     !! Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kk, kp, kstep
           real(dp) :: absakk, alpha, colmax, d, d11, d22, r1, rowmax, tt
           complex(dp) :: d12, d21, t, wk, wkm1, wkp1, zdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=dp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETF2', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 90
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=dp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_izamax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) .or. stdlib_disnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=dp)
              else
                 ! ============================================================
                 ! test for interchange
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value.
                    ! determine only rowmax.
                    jmax = imax + stdlib_izamax( k-imax, a( imax, imax+1 ), lda )
                    rowmax = cabs1( a( imax, jmax ) )
                    if( imax>1 ) then
                       jmax = stdlib_izamax( imax-1, a( 1, imax ), 1 )
                       rowmax = max( rowmax, cabs1( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( real( a( imax, imax ),KIND=dp) )>=alpha*rowmax )then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_zswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    do j = kp + 1, kk - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    r1 = real( a( kk, kk ),KIND=dp)
                    a( kk, kk ) = real( a( kp, kp ),KIND=dp)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       a( k, k ) = real( a( k, k ),KIND=dp)
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 else
                    a( k, k ) = real( a( k, k ),KIND=dp)
                    if( kstep==2 )a( k-1, k-1 ) = real( a( k-1, k-1 ),KIND=dp)
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**h = a - w(k)*1/d(k)*w(k)**h
                    r1 = one / real( a( k, k ),KIND=dp)
                    call stdlib_zher( uplo, k-1, -r1, a( 1, k ), 1, a, lda )
                    ! store u(k) in column k
                    call stdlib_zdscal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**h
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**h
                    if( k>2 ) then
                       d = stdlib_dlapy2( real( a( k-1, k ),KIND=dp),aimag( a( k-1, k ) ) )
                                 
                       d22 = real( a( k-1, k-1 ),KIND=dp) / d
                       d11 = real( a( k, k ),KIND=dp) / d
                       tt = one / ( d11*d22-one )
                       d12 = a( k-1, k ) / d
                       d = tt / d
                       do j = k - 2, 1, -1
                          wkm1 = d*( d11*a( j, k-1 )-conjg( d12 )*a( j, k ) )
                          wk = d*( d22*a( j, k )-d12*a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - a( i, k )*conjg( wk ) -a( i, k-1 )*conjg( &
                                       wkm1 )
                          end do
                          a( j, k ) = wk
                          a( j, k-1 ) = wkm1
                          a( j, j ) = cmplx( real( a( j, j ),KIND=dp), zero,KIND=dp)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              50 continue
              ! if k > n, exit from loop
              if( k>n )go to 90
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=dp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_izamax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) .or. stdlib_disnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=dp)
              else
                 ! ============================================================
                 ! test for interchange
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value.
                    ! determine only rowmax.
                    jmax = k - 1 + stdlib_izamax( imax-k, a( imax, k ), lda )
                    rowmax = cabs1( a( imax, jmax ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_izamax( n-imax, a( imax+1, imax ), 1 )
                       rowmax = max( rowmax, cabs1( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( real( a( imax, imax ),KIND=dp) )>=alpha*rowmax )then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_zswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    do j = kk + 1, kp - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    r1 = real( a( kk, kk ),KIND=dp)
                    a( kk, kk ) = real( a( kp, kp ),KIND=dp)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       a( k, k ) = real( a( k, k ),KIND=dp)
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 else
                    a( k, k ) = real( a( k, k ),KIND=dp)
                    if( kstep==2 )a( k+1, k+1 ) = real( a( k+1, k+1 ),KIND=dp)
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**h = a - w(k)*(1/d(k))*w(k)**h
                       r1 = one / real( a( k, k ),KIND=dp)
                       call stdlib_zher( uplo, n-k, -r1, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                 
                       ! store l(k) in column k
                       call stdlib_zdscal( n-k, r1, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k)
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**h
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**h
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d = stdlib_dlapy2( real( a( k+1, k ),KIND=dp),aimag( a( k+1, k ) ) )
                                 
                       d11 = real( a( k+1, k+1 ),KIND=dp) / d
                       d22 = real( a( k, k ),KIND=dp) / d
                       tt = one / ( d11*d22-one )
                       d21 = a( k+1, k ) / d
                       d = tt / d
                       do j = k + 2, n
                          wk = d*( d11*a( j, k )-d21*a( j, k+1 ) )
                          wkp1 = d*( d22*a( j, k+1 )-conjg( d21 )*a( j, k ) )
                          do i = j, n
                             a( i, j ) = a( i, j ) - a( i, k )*conjg( wk ) -a( i, k+1 )*conjg( &
                                       wkp1 )
                          end do
                          a( j, k ) = wk
                          a( j, k+1 ) = wkp1
                          a( j, j ) = cmplx( real( a( j, j ),KIND=dp), zero,KIND=dp)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 50
           end if
           90 continue
           return
     end subroutine stdlib_zhetf2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hetf2( uplo, n, a, lda, ipiv, info )
     !! ZHETF2: computes the factorization of a complex Hermitian matrix A
     !! using the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**H  or  A = L*D*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**H is the conjugate transpose of U, and D is
     !! Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: sevten = 17.0e+0_${ck}$
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kk, kp, kstep
           real(${ck}$) :: absakk, alpha, colmax, d, d11, d22, r1, rowmax, tt
           complex(${ck}$) :: d12, d21, t, wk, wkm1, wkp1, zdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=${ck}$) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETF2', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 90
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=${ck}$) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ci}$amax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) .or. stdlib_${c2ri(ci)}$isnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=${ck}$)
              else
                 ! ============================================================
                 ! test for interchange
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value.
                    ! determine only rowmax.
                    jmax = imax + stdlib_i${ci}$amax( k-imax, a( imax, imax+1 ), lda )
                    rowmax = cabs1( a( imax, jmax ) )
                    if( imax>1 ) then
                       jmax = stdlib_i${ci}$amax( imax-1, a( 1, imax ), 1 )
                       rowmax = max( rowmax, cabs1( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( real( a( imax, imax ),KIND=${ck}$) )>=alpha*rowmax )then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_${ci}$swap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    do j = kp + 1, kk - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    r1 = real( a( kk, kk ),KIND=${ck}$)
                    a( kk, kk ) = real( a( kp, kp ),KIND=${ck}$)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       a( k, k ) = real( a( k, k ),KIND=${ck}$)
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 else
                    a( k, k ) = real( a( k, k ),KIND=${ck}$)
                    if( kstep==2 )a( k-1, k-1 ) = real( a( k-1, k-1 ),KIND=${ck}$)
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**h = a - w(k)*1/d(k)*w(k)**h
                    r1 = one / real( a( k, k ),KIND=${ck}$)
                    call stdlib_${ci}$her( uplo, k-1, -r1, a( 1, k ), 1, a, lda )
                    ! store u(k) in column k
                    call stdlib_${ci}$dscal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**h
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**h
                    if( k>2 ) then
                       d = stdlib_${c2ri(ci)}$lapy2( real( a( k-1, k ),KIND=${ck}$),aimag( a( k-1, k ) ) )
                                 
                       d22 = real( a( k-1, k-1 ),KIND=${ck}$) / d
                       d11 = real( a( k, k ),KIND=${ck}$) / d
                       tt = one / ( d11*d22-one )
                       d12 = a( k-1, k ) / d
                       d = tt / d
                       do j = k - 2, 1, -1
                          wkm1 = d*( d11*a( j, k-1 )-conjg( d12 )*a( j, k ) )
                          wk = d*( d22*a( j, k )-d12*a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - a( i, k )*conjg( wk ) -a( i, k-1 )*conjg( &
                                       wkm1 )
                          end do
                          a( j, k ) = wk
                          a( j, k-1 ) = wkm1
                          a( j, j ) = cmplx( real( a( j, j ),KIND=${ck}$), zero,KIND=${ck}$)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              50 continue
              ! if k > n, exit from loop
              if( k>n )go to 90
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=${ck}$) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ci}$amax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) .or. stdlib_${c2ri(ci)}$isnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=${ck}$)
              else
                 ! ============================================================
                 ! test for interchange
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value.
                    ! determine only rowmax.
                    jmax = k - 1 + stdlib_i${ci}$amax( imax-k, a( imax, k ), lda )
                    rowmax = cabs1( a( imax, jmax ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_i${ci}$amax( n-imax, a( imax+1, imax ), 1 )
                       rowmax = max( rowmax, cabs1( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( real( a( imax, imax ),KIND=${ck}$) )>=alpha*rowmax )then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_${ci}$swap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    do j = kk + 1, kp - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    r1 = real( a( kk, kk ),KIND=${ck}$)
                    a( kk, kk ) = real( a( kp, kp ),KIND=${ck}$)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       a( k, k ) = real( a( k, k ),KIND=${ck}$)
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 else
                    a( k, k ) = real( a( k, k ),KIND=${ck}$)
                    if( kstep==2 )a( k+1, k+1 ) = real( a( k+1, k+1 ),KIND=${ck}$)
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**h = a - w(k)*(1/d(k))*w(k)**h
                       r1 = one / real( a( k, k ),KIND=${ck}$)
                       call stdlib_${ci}$her( uplo, n-k, -r1, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                 
                       ! store l(k) in column k
                       call stdlib_${ci}$dscal( n-k, r1, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k)
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**h
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**h
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d = stdlib_${c2ri(ci)}$lapy2( real( a( k+1, k ),KIND=${ck}$),aimag( a( k+1, k ) ) )
                                 
                       d11 = real( a( k+1, k+1 ),KIND=${ck}$) / d
                       d22 = real( a( k, k ),KIND=${ck}$) / d
                       tt = one / ( d11*d22-one )
                       d21 = a( k+1, k ) / d
                       d = tt / d
                       do j = k + 2, n
                          wk = d*( d11*a( j, k )-d21*a( j, k+1 ) )
                          wkp1 = d*( d22*a( j, k+1 )-conjg( d21 )*a( j, k ) )
                          do i = j, n
                             a( i, j ) = a( i, j ) - a( i, k )*conjg( wk ) -a( i, k+1 )*conjg( &
                                       wkp1 )
                          end do
                          a( j, k ) = wk
                          a( j, k+1 ) = wkp1
                          a( j, j ) = cmplx( real( a( j, j ),KIND=${ck}$), zero,KIND=${ck}$)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 50
           end if
           90 continue
           return
     end subroutine stdlib_${ci}$hetf2

#:endif
#:endfor



     module pure subroutine stdlib_checon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
     !! CHECON estimates the reciprocal of the condition number of a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by CHETRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(sp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHECON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**h) or inv(u*d*u**h).
              call stdlib_chetrs( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_checon

     module pure subroutine stdlib_zhecon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
     !! ZHECON estimates the reciprocal of the condition number of a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by ZHETRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(dp), intent(in) :: anorm
           real(dp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(dp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHECON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_zlacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**h) or inv(u*d*u**h).
              call stdlib_zhetrs( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_zhecon

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hecon( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
     !! ZHECON: estimates the reciprocal of the condition number of a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by ZHETRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(${ck}$), intent(in) :: anorm
           real(${ck}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(${ck}$) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHECON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_${ci}$lacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**h) or inv(u*d*u**h).
              call stdlib_${ci}$hetrs( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_${ci}$hecon

#:endif
#:endfor



     module pure subroutine stdlib_chptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! CHPTRS solves a system of linear equations A*X = B with a complex
     !! Hermitian matrix A stored in packed format using the factorization
     !! A = U*D*U**H or A = L*D*L**H computed by CHPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: ap(*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kp
           real(sp) :: s
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**h.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              kc = kc - k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_cgeru( k-1, nrhs, -cone, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=sp) / real( ap( kc+k-1 ),KIND=sp)
                 call stdlib_csscal( nrhs, s, b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_cgeru( k-2, nrhs, -cone, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 call stdlib_cgeru( k-2, nrhs, -cone, ap( kc-( k-1 ) ), 1,b( k-1, 1 ), ldb, b( 1, &
                           1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+k-2 )
                 akm1 = ap( kc-1 ) / akm1k
                 ak = ap( kc+k-1 ) / conjg( akm1k )
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / conjg( akm1k )
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc - k + 1
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**h *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**h(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, ap( kc ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + k
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**h(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, ap( kc ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k+1, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, ap( kc+k ),&
                               1, cone, b( k+1, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + 2*k + 1
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**h.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_cgeru( n-k, nrhs, -cone, ap( kc+1 ), 1, b( k, 1 ),ldb, b( k+&
                           1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=sp) / real( ap( kc ),KIND=sp)
                 call stdlib_csscal( nrhs, s, b( k, 1 ), ldb )
                 kc = kc + n - k + 1
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_cgeru( n-k-1, nrhs, -cone, ap( kc+2 ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_cgeru( n-k-1, nrhs, -cone, ap( kc+n-k+2 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+1 )
                 akm1 = ap( kc ) / conjg( akm1k )
                 ak = ap( kc+n-k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / conjg( akm1k )
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc + 2*( n-k ) + 1
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**h *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              kc = kc - ( n-k+1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**h(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              ap( kc+1 ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**h(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              ap( kc+1 ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k-1, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              ap( kc-( n-k ) ), 1, cone,b( k-1, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k-1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc - ( n-k+2 )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_chptrs

     module pure subroutine stdlib_zhptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! ZHPTRS solves a system of linear equations A*X = B with a complex
     !! Hermitian matrix A stored in packed format using the factorization
     !! A = U*D*U**H or A = L*D*L**H computed by ZHPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: ap(*)
           complex(dp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kp
           real(dp) :: s
           complex(dp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHPTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**h.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              kc = kc - k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_zgeru( k-1, nrhs, -cone, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=dp) / real( ap( kc+k-1 ),KIND=dp)
                 call stdlib_zdscal( nrhs, s, b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_zswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_zgeru( k-2, nrhs, -cone, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 call stdlib_zgeru( k-2, nrhs, -cone, ap( kc-( k-1 ) ), 1,b( k-1, 1 ), ldb, b( 1, &
                           1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+k-2 )
                 akm1 = ap( kc-1 ) / akm1k
                 ak = ap( kc+k-1 ) / conjg( akm1k )
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / conjg( akm1k )
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc - k + 1
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**h *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**h(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 ) then
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, ap( kc ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + k
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**h(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, ap( kc ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k+1, 1 ), ldb )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, ap( kc+k ),&
                               1, cone, b( k+1, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + 2*k + 1
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**h.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_zgeru( n-k, nrhs, -cone, ap( kc+1 ), 1, b( k, 1 ),ldb, b( k+&
                           1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=dp) / real( ap( kc ),KIND=dp)
                 call stdlib_zdscal( nrhs, s, b( k, 1 ), ldb )
                 kc = kc + n - k + 1
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_zswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_zgeru( n-k-1, nrhs, -cone, ap( kc+2 ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_zgeru( n-k-1, nrhs, -cone, ap( kc+n-k+2 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+1 )
                 akm1 = ap( kc ) / conjg( akm1k )
                 ak = ap( kc+n-k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / conjg( akm1k )
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc + 2*( n-k ) + 1
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**h *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              kc = kc - ( n-k+1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**h(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n ) then
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              ap( kc+1 ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**h(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              ap( kc+1 ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k-1, 1 ), ldb )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              ap( kc-( n-k ) ), 1, cone,b( k-1, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k-1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc - ( n-k+2 )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_zhptrs

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! ZHPTRS: solves a system of linear equations A*X = B with a complex
     !! Hermitian matrix A stored in packed format using the factorization
     !! A = U*D*U**H or A = L*D*L**H computed by ZHPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: ap(*)
           complex(${ck}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kp
           real(${ck}$) :: s
           complex(${ck}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHPTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**h.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              kc = kc - k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_${ci}$geru( k-1, nrhs, -cone, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=${ck}$) / real( ap( kc+k-1 ),KIND=${ck}$)
                 call stdlib_${ci}$dscal( nrhs, s, b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_${ci}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_${ci}$geru( k-2, nrhs, -cone, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 call stdlib_${ci}$geru( k-2, nrhs, -cone, ap( kc-( k-1 ) ), 1,b( k-1, 1 ), ldb, b( 1, &
                           1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+k-2 )
                 akm1 = ap( kc-1 ) / akm1k
                 ak = ap( kc+k-1 ) / conjg( akm1k )
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / conjg( akm1k )
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc - k + 1
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**h *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**h(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 ) then
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, ap( kc ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + k
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**h(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, ap( kc ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k+1, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, ap( kc+k ),&
                               1, cone, b( k+1, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + 2*k + 1
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**h.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ci}$geru( n-k, nrhs, -cone, ap( kc+1 ), 1, b( k, 1 ),ldb, b( k+&
                           1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=${ck}$) / real( ap( kc ),KIND=${ck}$)
                 call stdlib_${ci}$dscal( nrhs, s, b( k, 1 ), ldb )
                 kc = kc + n - k + 1
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_${ci}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_${ci}$geru( n-k-1, nrhs, -cone, ap( kc+2 ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_${ci}$geru( n-k-1, nrhs, -cone, ap( kc+n-k+2 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+1 )
                 akm1 = ap( kc ) / conjg( akm1k )
                 ak = ap( kc+n-k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / conjg( akm1k )
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc + 2*( n-k ) + 1
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**h *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              kc = kc - ( n-k+1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**h(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n ) then
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              ap( kc+1 ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**h(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              ap( kc+1 ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k-1, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              ap( kc-( n-k ) ), 1, cone,b( k-1, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k-1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc - ( n-k+2 )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_${ci}$hptrs

#:endif
#:endfor



     module pure subroutine stdlib_ssytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
     !! SSYTRF_RK computes the factorization of a real symmetric matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, ip, iws, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'SSYTRF_RK', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYTRF_RK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'SSYTRF_RK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_slasyf_rk;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 15
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_slasyf_rk( uplo, k, nb, kb, a, lda, e,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_ssytf2_rk( uplo, k, a, lda, e, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k-kb+1:k and apply row permutations to the
              ! last k+1 colunms k+1:n after that block
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k<n ) then
                 do i = k, ( k - kb + 1 ), -1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_sswap( n-k, a( i, k+1 ), lda,a( ip, k+1 ), lda )
                    end if
                 end do
              end if
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
              ! this label is the exit from main loop over k decreasing
              ! from n to 1 in steps of kb
              15 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_slasyf_rk;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 35
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_slasyf_rk( uplo, n-k+1, nb, kb, a( k, k ), lda, e( k ),ipiv( k ), &
                           work, ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_ssytf2_rk( uplo, n-k+1, a( k, k ), lda, e( k ),ipiv( k ), iinfo )
                           
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do i = k, k + kb - 1
                 if( ipiv( i )>0 ) then
                    ipiv( i ) = ipiv( i ) + k - 1
                 else
                    ipiv( i ) = ipiv( i ) - k + 1
                 end if
              end do
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k:k+kb-1 and apply row permutations to the
              ! first k-1 colunms 1:k-1 before that block
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k>1 ) then
                 do i = k, ( k + kb - 1 ), 1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_sswap( k-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                    end if
                 end do
              end if
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
              ! this label is the exit from main loop over k increasing
              ! from 1 to n in steps of kb
              35 continue
           ! end lower
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_ssytrf_rk

     module pure subroutine stdlib_dsytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
     !! DSYTRF_RK computes the factorization of a real symmetric matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, ip, iws, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'DSYTRF_RK', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRF_RK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'DSYTRF_RK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_dlasyf_rk;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 15
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_dlasyf_rk( uplo, k, nb, kb, a, lda, e,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_dsytf2_rk( uplo, k, a, lda, e, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k-kb+1:k and apply row permutations to the
              ! last k+1 colunms k+1:n after that block
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k<n ) then
                 do i = k, ( k - kb + 1 ), -1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_dswap( n-k, a( i, k+1 ), lda,a( ip, k+1 ), lda )
                    end if
                 end do
              end if
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
              ! this label is the exit from main loop over k decreasing
              ! from n to 1 in steps of kb
              15 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_dlasyf_rk;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 35
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_dlasyf_rk( uplo, n-k+1, nb, kb, a( k, k ), lda, e( k ),ipiv( k ), &
                           work, ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_dsytf2_rk( uplo, n-k+1, a( k, k ), lda, e( k ),ipiv( k ), iinfo )
                           
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do i = k, k + kb - 1
                 if( ipiv( i )>0 ) then
                    ipiv( i ) = ipiv( i ) + k - 1
                 else
                    ipiv( i ) = ipiv( i ) - k + 1
                 end if
              end do
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k:k+kb-1 and apply row permutations to the
              ! first k-1 colunms 1:k-1 before that block
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k>1 ) then
                 do i = k, ( k + kb - 1 ), 1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_dswap( k-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                    end if
                 end do
              end if
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
              ! this label is the exit from main loop over k increasing
              ! from 1 to n in steps of kb
              35 continue
           ! end lower
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dsytrf_rk

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
     !! DSYTRF_RK: computes the factorization of a real symmetric matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, ip, iws, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'DSYTRF_RK', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRF_RK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'DSYTRF_RK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ri}$lasyf_rk;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 15
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_${ri}$lasyf_rk( uplo, k, nb, kb, a, lda, e,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_${ri}$sytf2_rk( uplo, k, a, lda, e, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k-kb+1:k and apply row permutations to the
              ! last k+1 colunms k+1:n after that block
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k<n ) then
                 do i = k, ( k - kb + 1 ), -1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_${ri}$swap( n-k, a( i, k+1 ), lda,a( ip, k+1 ), lda )
                    end if
                 end do
              end if
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
              ! this label is the exit from main loop over k decreasing
              ! from n to 1 in steps of kb
              15 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ri}$lasyf_rk;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 35
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_${ri}$lasyf_rk( uplo, n-k+1, nb, kb, a( k, k ), lda, e( k ),ipiv( k ), &
                           work, ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_${ri}$sytf2_rk( uplo, n-k+1, a( k, k ), lda, e( k ),ipiv( k ), iinfo )
                           
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do i = k, k + kb - 1
                 if( ipiv( i )>0 ) then
                    ipiv( i ) = ipiv( i ) + k - 1
                 else
                    ipiv( i ) = ipiv( i ) - k + 1
                 end if
              end do
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k:k+kb-1 and apply row permutations to the
              ! first k-1 colunms 1:k-1 before that block
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k>1 ) then
                 do i = k, ( k + kb - 1 ), 1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_${ri}$swap( k-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                    end if
                 end do
              end if
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
              ! this label is the exit from main loop over k increasing
              ! from 1 to n in steps of kb
              35 continue
           ! end lower
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sytrf_rk

#:endif
#:endfor

     module pure subroutine stdlib_csytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
     !! CSYTRF_RK computes the factorization of a complex symmetric matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, ip, iws, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'CSYTRF_RK', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRF_RK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'CSYTRF_RK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clasyf_rk;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 15
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_clasyf_rk( uplo, k, nb, kb, a, lda, e,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_csytf2_rk( uplo, k, a, lda, e, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k-kb+1:k and apply row permutations to the
              ! last k+1 colunms k+1:n after that block
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k<n ) then
                 do i = k, ( k - kb + 1 ), -1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_cswap( n-k, a( i, k+1 ), lda,a( ip, k+1 ), lda )
                    end if
                 end do
              end if
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
              ! this label is the exit from main loop over k decreasing
              ! from n to 1 in steps of kb
              15 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clasyf_rk;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 35
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_clasyf_rk( uplo, n-k+1, nb, kb, a( k, k ), lda, e( k ),ipiv( k ), &
                           work, ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_csytf2_rk( uplo, n-k+1, a( k, k ), lda, e( k ),ipiv( k ), iinfo )
                           
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do i = k, k + kb - 1
                 if( ipiv( i )>0 ) then
                    ipiv( i ) = ipiv( i ) + k - 1
                 else
                    ipiv( i ) = ipiv( i ) - k + 1
                 end if
              end do
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k:k+kb-1 and apply row permutations to the
              ! first k-1 colunms 1:k-1 before that block
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k>1 ) then
                 do i = k, ( k + kb - 1 ), 1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_cswap( k-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                    end if
                 end do
              end if
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
              ! this label is the exit from main loop over k increasing
              ! from 1 to n in steps of kb
              35 continue
           ! end lower
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csytrf_rk

     module pure subroutine stdlib_zsytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
     !! ZSYTRF_RK computes the factorization of a complex symmetric matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, ip, iws, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'ZSYTRF_RK', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRF_RK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'ZSYTRF_RK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_zlasyf_rk;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 15
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_zlasyf_rk( uplo, k, nb, kb, a, lda, e,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_zsytf2_rk( uplo, k, a, lda, e, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k-kb+1:k and apply row permutations to the
              ! last k+1 colunms k+1:n after that block
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k<n ) then
                 do i = k, ( k - kb + 1 ), -1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_zswap( n-k, a( i, k+1 ), lda,a( ip, k+1 ), lda )
                    end if
                 end do
              end if
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
              ! this label is the exit from main loop over k decreasing
              ! from n to 1 in steps of kb
              15 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_zlasyf_rk;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 35
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_zlasyf_rk( uplo, n-k+1, nb, kb, a( k, k ), lda, e( k ),ipiv( k ), &
                           work, ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_zsytf2_rk( uplo, n-k+1, a( k, k ), lda, e( k ),ipiv( k ), iinfo )
                           
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do i = k, k + kb - 1
                 if( ipiv( i )>0 ) then
                    ipiv( i ) = ipiv( i ) + k - 1
                 else
                    ipiv( i ) = ipiv( i ) - k + 1
                 end if
              end do
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k:k+kb-1 and apply row permutations to the
              ! first k-1 colunms 1:k-1 before that block
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k>1 ) then
                 do i = k, ( k + kb - 1 ), 1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_zswap( k-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                    end if
                 end do
              end if
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
              ! this label is the exit from main loop over k increasing
              ! from 1 to n in steps of kb
              35 continue
           ! end lower
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zsytrf_rk

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork,info )
     !! ZSYTRF_RK: computes the factorization of a complex symmetric matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, ip, iws, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -8
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'ZSYTRF_RK', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRF_RK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'ZSYTRF_RK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ci}$lasyf_rk;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 15
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_${ci}$lasyf_rk( uplo, k, nb, kb, a, lda, e,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_${ci}$sytf2_rk( uplo, k, a, lda, e, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k-kb+1:k and apply row permutations to the
              ! last k+1 colunms k+1:n after that block
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k<n ) then
                 do i = k, ( k - kb + 1 ), -1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_${ci}$swap( n-k, a( i, k+1 ), lda,a( ip, k+1 ), lda )
                    end if
                 end do
              end if
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
              ! this label is the exit from main loop over k decreasing
              ! from n to 1 in steps of kb
              15 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ci}$lasyf_rk;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 35
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_${ci}$lasyf_rk( uplo, n-k+1, nb, kb, a( k, k ), lda, e( k ),ipiv( k ), &
                           work, ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_${ci}$sytf2_rk( uplo, n-k+1, a( k, k ), lda, e( k ),ipiv( k ), iinfo )
                           
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do i = k, k + kb - 1
                 if( ipiv( i )>0 ) then
                    ipiv( i ) = ipiv( i ) + k - 1
                 else
                    ipiv( i ) = ipiv( i ) - k + 1
                 end if
              end do
              ! apply permutations to the leading panel 1:k-1
              ! read ipiv from the last block factored, i.e.
              ! indices  k:k+kb-1 and apply row permutations to the
              ! first k-1 colunms 1:k-1 before that block
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              if( k>1 ) then
                 do i = k, ( k + kb - 1 ), 1
                    ip = abs( ipiv( i ) )
                    if( ip/=i ) then
                       call stdlib_${ci}$swap( k-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                    end if
                 end do
              end if
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
              ! this label is the exit from main loop over k increasing
              ! from 1 to n in steps of kb
              35 continue
           ! end lower
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$sytrf_rk

#:endif
#:endfor





     module pure subroutine stdlib_slasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
     !! SLASYF computes a partial factorization of a real symmetric matrix A
     !! using the Bunch-Kaufman diagonal pivoting method. The partial
     !! factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! SLASYF is an auxiliary routine called by SSYTRF. It uses blocked code
     !! (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
     !! A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           ! Local Scalars 
           integer(ilp) :: imax, j, jb, jj, jmax, jp, k, kk, kkw, kp, kstep, kw
           real(sp) :: absakk, alpha, colmax, d11, d21, d22, r1, rowmax, t
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              ! kw is the column of w which corresponds to column k of a
              k = n
              10 continue
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              ! copy column k of a to column kw of w and update it
              call stdlib_scopy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_sgemv( 'NO TRANSPOSE', k, n-k, -one, a( 1, k+1 ), lda,w( k, kw+&
                        1 ), ldw, one, w( 1, kw ), 1 )
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_isamax( k-1, w( 1, kw ), 1 )
                 colmax = abs( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! copy column imax to column kw-1 of w and update it
                    call stdlib_scopy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                    call stdlib_scopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                              
                    if( k<n )call stdlib_sgemv( 'NO TRANSPOSE', k, n-k, -one, a( 1, k+1 ),lda, w( &
                              imax, kw+1 ), ldw, one,w( 1, kw-1 ), 1 )
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = imax + stdlib_isamax( k-imax, w( imax+1, kw-1 ), 1 )
                    rowmax = abs( w( jmax, kw-1 ) )
                    if( imax>1 ) then
                       jmax = stdlib_isamax( imax-1, w( 1, kw-1 ), 1 )
                       rowmax = max( rowmax, abs( w( jmax, kw-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( w( imax, kw-1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column kw-1 of w to column kw of w
                       call stdlib_scopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = a( kk, kk )
                    call stdlib_scopy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    if( kp>1 )call stdlib_scopy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_sswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_sswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! note: diagonal element u(k,k) is a unit element
                    ! and not stored.
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    call stdlib_scopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    r1 = one / a( k, k )
                    call stdlib_sscal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored.
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! compose the columns of the inverse of 2-by-2 pivot
                       ! block d in the following way to reduce the number
                       ! of flops when we myltiply panel ( w(kw-1) w(kw) ) by
                       ! this inverse
                       ! d**(-1) = ( d11 d21 )**(-1) =
                                 ! ( d21 d22 )
                       ! = 1/(d11*d22-d21**2) * ( ( d22 ) (-d21 ) ) =
                                              ! ( (-d21 ) ( d11 ) )
                       ! = 1/d21 * 1/((d11/d21)*(d22/d21)-1) *
                         ! * ( ( d22/d21 ) (      -1 ) ) =
                           ! ( (      -1 ) ( d11/d21 ) )
                       ! = 1/d21 * 1/(d22*d11-1) * ( ( d11 ) (  -1 ) ) =
                                                 ! ( ( -1  ) ( d22 ) )
                       ! = 1/d21 * t * ( ( d11 ) (  -1 ) )
                                     ! ( (  -1 ) ( d22 ) )
                       ! = d21 * ( ( d11 ) (  -1 ) )
                               ! ( (  -1 ) ( d22 ) )
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / d21
                       d22 = w( k-1, kw-1 ) / d21
                       t = one / ( d11*d22-one )
                       d21 = t / d21
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       do j = 1, k - 2
                          a( j, k-1 ) = d21*( d11*w( j, kw-1 )-w( j, kw ) )
                          a( j, k ) = d21*( d22*w( j, kw )-w( j, kw-1 ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_sgemv( 'NO TRANSPOSE', jj-j+1, n-k, -one,a( j, k+1 ), lda, w( jj, &
                              kw+1 ), ldw, one,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 call stdlib_sgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k, -one,a( 1, k+1 ), &
                           lda, w( j, kw+1 ), ldw, one,a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in columns k+1:n looping backwards from k+1 to n
              j = k + 1
              60 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j + 1
                 end if
                 ! (note: here, j is used to determine row length. length n-j+1
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j + 1
                 if( jp/=jj .and. j<=n )call stdlib_sswap( n-j+1, a( jp, j ), lda, a( jj, j ), &
                           lda )
              if( j<n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              ! copy column k of a to column k of w and update it
              call stdlib_scopy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              call stdlib_sgemv( 'NO TRANSPOSE', n-k+1, k-1, -one, a( k, 1 ), lda,w( k, 1 ), ldw, &
                        one, w( k, k ), 1 )
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_isamax( n-k, w( k+1, k ), 1 )
                 colmax = abs( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! copy column imax to column k+1 of w and update it
                    call stdlib_scopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1 )
                    call stdlib_scopy( n-imax+1, a( imax, imax ), 1, w( imax, k+1 ),1 )
                    call stdlib_sgemv( 'NO TRANSPOSE', n-k+1, k-1, -one, a( k, 1 ),lda, w( imax, &
                              1 ), ldw, one, w( k, k+1 ), 1 )
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = k - 1 + stdlib_isamax( imax-k, w( k, k+1 ), 1 )
                    rowmax = abs( w( jmax, k+1 ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_isamax( n-imax, w( imax+1, k+1 ), 1 )
                       rowmax = max( rowmax, abs( w( jmax, k+1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( w( imax, k+1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column k+1 of w to column k of w
                       call stdlib_scopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = a( kk, kk )
                    call stdlib_scopy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    if( kp<n )call stdlib_scopy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (columns k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_sswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_sswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    call stdlib_scopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       r1 = one / a( k, k )
                       call stdlib_sscal( n-k, r1, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! (note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored)
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! compose the columns of the inverse of 2-by-2 pivot
                       ! block d in the following way to reduce the number
                       ! of flops when we myltiply panel ( w(k) w(k+1) ) by
                       ! this inverse
                       ! d**(-1) = ( d11 d21 )**(-1) =
                                 ! ( d21 d22 )
                       ! = 1/(d11*d22-d21**2) * ( ( d22 ) (-d21 ) ) =
                                              ! ( (-d21 ) ( d11 ) )
                       ! = 1/d21 * 1/((d11/d21)*(d22/d21)-1) *
                         ! * ( ( d22/d21 ) (      -1 ) ) =
                           ! ( (      -1 ) ( d11/d21 ) )
                       ! = 1/d21 * 1/(d22*d11-1) * ( ( d11 ) (  -1 ) ) =
                                                 ! ( ( -1  ) ( d22 ) )
                       ! = 1/d21 * t * ( ( d11 ) (  -1 ) )
                                     ! ( (  -1 ) ( d22 ) )
                       ! = d21 * ( ( d11 ) (  -1 ) )
                               ! ( (  -1 ) ( d22 ) )
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = one / ( d11*d22-one )
                       d21 = t / d21
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = d21*( d11*w( j, k )-w( j, k+1 ) )
                          a( j, k+1 ) = d21*( d22*w( j, k+1 )-w( j, k ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_sgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -one,a( jj, 1 ), lda, w( jj, &
                              1 ), ldw, one,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_sgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           one, a( j+jb, 1 ), lda, w( j, 1 ), ldw,one, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! of rows in columns 1:k-1 looping backwards from k-1 to 1
              j = k - 1
              120 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j - 1
                 end if
                 ! (note: here, j is used to determine row length. length j
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j - 1
                 if( jp/=jj .and. j>=1 )call stdlib_sswap( j, a( jp, 1 ), lda, a( jj, 1 ), lda )
                           
              if( j>1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_slasyf

     module pure subroutine stdlib_dlasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
     !! DLASYF computes a partial factorization of a real symmetric matrix A
     !! using the Bunch-Kaufman diagonal pivoting method. The partial
     !! factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! DLASYF is an auxiliary routine called by DSYTRF. It uses blocked code
     !! (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
     !! A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           ! Local Scalars 
           integer(ilp) :: imax, j, jb, jj, jmax, jp, k, kk, kkw, kp, kstep, kw
           real(dp) :: absakk, alpha, colmax, d11, d21, d22, r1, rowmax, t
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              ! kw is the column of w which corresponds to column k of a
              k = n
              10 continue
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              ! copy column k of a to column kw of w and update it
              call stdlib_dcopy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_dgemv( 'NO TRANSPOSE', k, n-k, -one, a( 1, k+1 ), lda,w( k, kw+&
                        1 ), ldw, one, w( 1, kw ), 1 )
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_idamax( k-1, w( 1, kw ), 1 )
                 colmax = abs( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! copy column imax to column kw-1 of w and update it
                    call stdlib_dcopy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                    call stdlib_dcopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                              
                    if( k<n )call stdlib_dgemv( 'NO TRANSPOSE', k, n-k, -one, a( 1, k+1 ),lda, w( &
                              imax, kw+1 ), ldw, one,w( 1, kw-1 ), 1 )
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = imax + stdlib_idamax( k-imax, w( imax+1, kw-1 ), 1 )
                    rowmax = abs( w( jmax, kw-1 ) )
                    if( imax>1 ) then
                       jmax = stdlib_idamax( imax-1, w( 1, kw-1 ), 1 )
                       rowmax = max( rowmax, abs( w( jmax, kw-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( w( imax, kw-1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column kw-1 of w to column kw of w
                       call stdlib_dcopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = a( kk, kk )
                    call stdlib_dcopy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    if( kp>1 )call stdlib_dcopy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_dswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_dswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! note: diagonal element u(k,k) is a unit element
                    ! and not stored.
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    call stdlib_dcopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    r1 = one / a( k, k )
                    call stdlib_dscal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored.
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! compose the columns of the inverse of 2-by-2 pivot
                       ! block d in the following way to reduce the number
                       ! of flops when we myltiply panel ( w(kw-1) w(kw) ) by
                       ! this inverse
                       ! d**(-1) = ( d11 d21 )**(-1) =
                                 ! ( d21 d22 )
                       ! = 1/(d11*d22-d21**2) * ( ( d22 ) (-d21 ) ) =
                                              ! ( (-d21 ) ( d11 ) )
                       ! = 1/d21 * 1/((d11/d21)*(d22/d21)-1) *
                         ! * ( ( d22/d21 ) (      -1 ) ) =
                           ! ( (      -1 ) ( d11/d21 ) )
                       ! = 1/d21 * 1/(d22*d11-1) * ( ( d11 ) (  -1 ) ) =
                                                 ! ( ( -1  ) ( d22 ) )
                       ! = 1/d21 * t * ( ( d11 ) (  -1 ) )
                                     ! ( (  -1 ) ( d22 ) )
                       ! = d21 * ( ( d11 ) (  -1 ) )
                               ! ( (  -1 ) ( d22 ) )
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / d21
                       d22 = w( k-1, kw-1 ) / d21
                       t = one / ( d11*d22-one )
                       d21 = t / d21
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       do j = 1, k - 2
                          a( j, k-1 ) = d21*( d11*w( j, kw-1 )-w( j, kw ) )
                          a( j, k ) = d21*( d22*w( j, kw )-w( j, kw-1 ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_dgemv( 'NO TRANSPOSE', jj-j+1, n-k, -one,a( j, k+1 ), lda, w( jj, &
                              kw+1 ), ldw, one,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 call stdlib_dgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k, -one,a( 1, k+1 ), &
                           lda, w( j, kw+1 ), ldw, one,a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in columns k+1:n looping backwards from k+1 to n
              j = k + 1
              60 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j + 1
                 end if
                 ! (note: here, j is used to determine row length. length n-j+1
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j + 1
                 if( jp/=jj .and. j<=n )call stdlib_dswap( n-j+1, a( jp, j ), lda, a( jj, j ), &
                           lda )
              if( j<n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              ! copy column k of a to column k of w and update it
              call stdlib_dcopy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              call stdlib_dgemv( 'NO TRANSPOSE', n-k+1, k-1, -one, a( k, 1 ), lda,w( k, 1 ), ldw, &
                        one, w( k, k ), 1 )
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_idamax( n-k, w( k+1, k ), 1 )
                 colmax = abs( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! copy column imax to column k+1 of w and update it
                    call stdlib_dcopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1 )
                    call stdlib_dcopy( n-imax+1, a( imax, imax ), 1, w( imax, k+1 ),1 )
                    call stdlib_dgemv( 'NO TRANSPOSE', n-k+1, k-1, -one, a( k, 1 ),lda, w( imax, &
                              1 ), ldw, one, w( k, k+1 ), 1 )
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = k - 1 + stdlib_idamax( imax-k, w( k, k+1 ), 1 )
                    rowmax = abs( w( jmax, k+1 ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_idamax( n-imax, w( imax+1, k+1 ), 1 )
                       rowmax = max( rowmax, abs( w( jmax, k+1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( w( imax, k+1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column k+1 of w to column k of w
                       call stdlib_dcopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = a( kk, kk )
                    call stdlib_dcopy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    if( kp<n )call stdlib_dcopy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (columns k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_dswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_dswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    call stdlib_dcopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       r1 = one / a( k, k )
                       call stdlib_dscal( n-k, r1, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! (note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored)
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! compose the columns of the inverse of 2-by-2 pivot
                       ! block d in the following way to reduce the number
                       ! of flops when we myltiply panel ( w(k) w(k+1) ) by
                       ! this inverse
                       ! d**(-1) = ( d11 d21 )**(-1) =
                                 ! ( d21 d22 )
                       ! = 1/(d11*d22-d21**2) * ( ( d22 ) (-d21 ) ) =
                                              ! ( (-d21 ) ( d11 ) )
                       ! = 1/d21 * 1/((d11/d21)*(d22/d21)-1) *
                         ! * ( ( d22/d21 ) (      -1 ) ) =
                           ! ( (      -1 ) ( d11/d21 ) )
                       ! = 1/d21 * 1/(d22*d11-1) * ( ( d11 ) (  -1 ) ) =
                                                 ! ( ( -1  ) ( d22 ) )
                       ! = 1/d21 * t * ( ( d11 ) (  -1 ) )
                                     ! ( (  -1 ) ( d22 ) )
                       ! = d21 * ( ( d11 ) (  -1 ) )
                               ! ( (  -1 ) ( d22 ) )
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = one / ( d11*d22-one )
                       d21 = t / d21
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = d21*( d11*w( j, k )-w( j, k+1 ) )
                          a( j, k+1 ) = d21*( d22*w( j, k+1 )-w( j, k ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_dgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -one,a( jj, 1 ), lda, w( jj, &
                              1 ), ldw, one,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_dgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           one, a( j+jb, 1 ), lda, w( j, 1 ), ldw,one, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! of rows in columns 1:k-1 looping backwards from k-1 to 1
              j = k - 1
              120 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j - 1
                 end if
                 ! (note: here, j is used to determine row length. length j
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j - 1
                 if( jp/=jj .and. j>=1 )call stdlib_dswap( j, a( jp, 1 ), lda, a( jj, 1 ), lda )
                           
              if( j>1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_dlasyf

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$lasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
     !! DLASYF: computes a partial factorization of a real symmetric matrix A
     !! using the Bunch-Kaufman diagonal pivoting method. The partial
     !! factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! DLASYF is an auxiliary routine called by DSYTRF. It uses blocked code
     !! (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
     !! A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sevten = 17.0e+0_${rk}$
           
           
           ! Local Scalars 
           integer(ilp) :: imax, j, jb, jj, jmax, jp, k, kk, kkw, kp, kstep, kw
           real(${rk}$) :: absakk, alpha, colmax, d11, d21, d22, r1, rowmax, t
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              ! kw is the column of w which corresponds to column k of a
              k = n
              10 continue
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              ! copy column k of a to column kw of w and update it
              call stdlib_${ri}$copy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_${ri}$gemv( 'NO TRANSPOSE', k, n-k, -one, a( 1, k+1 ), lda,w( k, kw+&
                        1 ), ldw, one, w( 1, kw ), 1 )
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ri}$amax( k-1, w( 1, kw ), 1 )
                 colmax = abs( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! copy column imax to column kw-1 of w and update it
                    call stdlib_${ri}$copy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                    call stdlib_${ri}$copy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                              
                    if( k<n )call stdlib_${ri}$gemv( 'NO TRANSPOSE', k, n-k, -one, a( 1, k+1 ),lda, w( &
                              imax, kw+1 ), ldw, one,w( 1, kw-1 ), 1 )
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = imax + stdlib_i${ri}$amax( k-imax, w( imax+1, kw-1 ), 1 )
                    rowmax = abs( w( jmax, kw-1 ) )
                    if( imax>1 ) then
                       jmax = stdlib_i${ri}$amax( imax-1, w( 1, kw-1 ), 1 )
                       rowmax = max( rowmax, abs( w( jmax, kw-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( w( imax, kw-1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column kw-1 of w to column kw of w
                       call stdlib_${ri}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = a( kk, kk )
                    call stdlib_${ri}$copy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    if( kp>1 )call stdlib_${ri}$copy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_${ri}$swap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_${ri}$swap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! note: diagonal element u(k,k) is a unit element
                    ! and not stored.
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    call stdlib_${ri}$copy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    r1 = one / a( k, k )
                    call stdlib_${ri}$scal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored.
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! compose the columns of the inverse of 2-by-2 pivot
                       ! block d in the following way to reduce the number
                       ! of flops when we myltiply panel ( w(kw-1) w(kw) ) by
                       ! this inverse
                       ! d**(-1) = ( d11 d21 )**(-1) =
                                 ! ( d21 d22 )
                       ! = 1/(d11*d22-d21**2) * ( ( d22 ) (-d21 ) ) =
                                              ! ( (-d21 ) ( d11 ) )
                       ! = 1/d21 * 1/((d11/d21)*(d22/d21)-1) *
                         ! * ( ( d22/d21 ) (      -1 ) ) =
                           ! ( (      -1 ) ( d11/d21 ) )
                       ! = 1/d21 * 1/(d22*d11-1) * ( ( d11 ) (  -1 ) ) =
                                                 ! ( ( -1  ) ( d22 ) )
                       ! = 1/d21 * t * ( ( d11 ) (  -1 ) )
                                     ! ( (  -1 ) ( d22 ) )
                       ! = d21 * ( ( d11 ) (  -1 ) )
                               ! ( (  -1 ) ( d22 ) )
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / d21
                       d22 = w( k-1, kw-1 ) / d21
                       t = one / ( d11*d22-one )
                       d21 = t / d21
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       do j = 1, k - 2
                          a( j, k-1 ) = d21*( d11*w( j, kw-1 )-w( j, kw ) )
                          a( j, k ) = d21*( d22*w( j, kw )-w( j, kw-1 ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', jj-j+1, n-k, -one,a( j, k+1 ), lda, w( jj, &
                              kw+1 ), ldw, one,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k, -one,a( 1, k+1 ), &
                           lda, w( j, kw+1 ), ldw, one,a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in columns k+1:n looping backwards from k+1 to n
              j = k + 1
              60 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j + 1
                 end if
                 ! (note: here, j is used to determine row length. length n-j+1
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j + 1
                 if( jp/=jj .and. j<=n )call stdlib_${ri}$swap( n-j+1, a( jp, j ), lda, a( jj, j ), &
                           lda )
              if( j<n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              ! copy column k of a to column k of w and update it
              call stdlib_${ri}$copy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -one, a( k, 1 ), lda,w( k, 1 ), ldw, &
                        one, w( k, k ), 1 )
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ri}$amax( n-k, w( k+1, k ), 1 )
                 colmax = abs( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! copy column imax to column k+1 of w and update it
                    call stdlib_${ri}$copy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1 )
                    call stdlib_${ri}$copy( n-imax+1, a( imax, imax ), 1, w( imax, k+1 ),1 )
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -one, a( k, 1 ),lda, w( imax, &
                              1 ), ldw, one, w( k, k+1 ), 1 )
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = k - 1 + stdlib_i${ri}$amax( imax-k, w( k, k+1 ), 1 )
                    rowmax = abs( w( jmax, k+1 ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_i${ri}$amax( n-imax, w( imax+1, k+1 ), 1 )
                       rowmax = max( rowmax, abs( w( jmax, k+1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( w( imax, k+1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column k+1 of w to column k of w
                       call stdlib_${ri}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = a( kk, kk )
                    call stdlib_${ri}$copy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    if( kp<n )call stdlib_${ri}$copy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (columns k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_${ri}$swap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_${ri}$swap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    call stdlib_${ri}$copy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       r1 = one / a( k, k )
                       call stdlib_${ri}$scal( n-k, r1, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! (note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored)
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! compose the columns of the inverse of 2-by-2 pivot
                       ! block d in the following way to reduce the number
                       ! of flops when we myltiply panel ( w(k) w(k+1) ) by
                       ! this inverse
                       ! d**(-1) = ( d11 d21 )**(-1) =
                                 ! ( d21 d22 )
                       ! = 1/(d11*d22-d21**2) * ( ( d22 ) (-d21 ) ) =
                                              ! ( (-d21 ) ( d11 ) )
                       ! = 1/d21 * 1/((d11/d21)*(d22/d21)-1) *
                         ! * ( ( d22/d21 ) (      -1 ) ) =
                           ! ( (      -1 ) ( d11/d21 ) )
                       ! = 1/d21 * 1/(d22*d11-1) * ( ( d11 ) (  -1 ) ) =
                                                 ! ( ( -1  ) ( d22 ) )
                       ! = 1/d21 * t * ( ( d11 ) (  -1 ) )
                                     ! ( (  -1 ) ( d22 ) )
                       ! = d21 * ( ( d11 ) (  -1 ) )
                               ! ( (  -1 ) ( d22 ) )
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = one / ( d11*d22-one )
                       d21 = t / d21
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = d21*( d11*w( j, k )-w( j, k+1 ) )
                          a( j, k+1 ) = d21*( d22*w( j, k+1 )-w( j, k ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', j+jb-jj, k-1, -one,a( jj, 1 ), lda, w( jj, &
                              1 ), ldw, one,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           one, a( j+jb, 1 ), lda, w( j, 1 ), ldw,one, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! of rows in columns 1:k-1 looping backwards from k-1 to 1
              j = k - 1
              120 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j - 1
                 end if
                 ! (note: here, j is used to determine row length. length j
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j - 1
                 if( jp/=jj .and. j>=1 )call stdlib_${ri}$swap( j, a( jp, 1 ), lda, a( jj, 1 ), lda )
                           
              if( j>1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_${ri}$lasyf

#:endif
#:endfor

     module pure subroutine stdlib_clasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
     !! CLASYF computes a partial factorization of a complex symmetric matrix
     !! A using the Bunch-Kaufman diagonal pivoting method. The partial
     !! factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) ( D    0  ) ( L11**T L21**T )  if UPLO = 'L'
     !! ( L21  I ) ( 0   A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! Note that U**T denotes the transpose of U.
     !! CLASYF is an auxiliary routine called by CSYTRF. It uses blocked code
     !! (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
     !! A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           integer(ilp) :: imax, j, jb, jj, jmax, jp, k, kk, kkw, kp, kstep, kw
           real(sp) :: absakk, alpha, colmax, rowmax
           complex(sp) :: d11, d21, d22, r1, t, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              ! kw is the column of w which corresponds to column k of a
              k = n
              10 continue
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              ! copy column k of a to column kw of w and update it
              call stdlib_ccopy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ), lda,w( k, &
                        kw+1 ), ldw, cone, w( 1, kw ), 1 )
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! copy column imax to column kw-1 of w and update it
                    call stdlib_ccopy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                    call stdlib_ccopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                              
                    if( k<n )call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda, w(&
                               imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = imax + stdlib_icamax( k-imax, w( imax+1, kw-1 ), 1 )
                    rowmax = cabs1( w( jmax, kw-1 ) )
                    if( imax>1 ) then
                       jmax = stdlib_icamax( imax-1, w( 1, kw-1 ), 1 )
                       rowmax = max( rowmax, cabs1( w( jmax, kw-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( w( imax, kw-1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column kw-1 of w to column kw of w
                       call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = a( kk, kk )
                    call stdlib_ccopy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    if( kp>1 )call stdlib_ccopy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_cswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_cswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! note: diagonal element u(k,k) is a unit element
                    ! and not stored.
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    call stdlib_ccopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    r1 = cone / a( k, k )
                    call stdlib_cscal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored.
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! compose the columns of the inverse of 2-by-2 pivot
                       ! block d in the following way to reduce the number
                       ! of flops when we myltiply panel ( w(kw-1) w(kw) ) by
                       ! this inverse
                       ! d**(-1) = ( d11 d21 )**(-1) =
                                 ! ( d21 d22 )
                       ! = 1/(d11*d22-d21**2) * ( ( d22 ) (-d21 ) ) =
                                              ! ( (-d21 ) ( d11 ) )
                       ! = 1/d21 * 1/((d11/d21)*(d22/d21)-1) *
                         ! * ( ( d22/d21 ) (      -1 ) ) =
                           ! ( (      -1 ) ( d11/d21 ) )
                       ! = 1/d21 * 1/(d22*d11-1) * ( ( d11 ) (  -1 ) ) =
                                                 ! ( ( -1  ) ( d22 ) )
                       ! = 1/d21 * t * ( ( d11 ) (  -1 ) )
                                     ! ( (  -1 ) ( d22 ) )
                       ! = d21 * ( ( d11 ) (  -1 ) )
                               ! ( (  -1 ) ( d22 ) )
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / d21
                       d22 = w( k-1, kw-1 ) / d21
                       t = cone / ( d11*d22-cone )
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       d21 = t / d21
                       do j = 1, k - 2
                          a( j, k-1 ) = d21*( d11*w( j, kw-1 )-w( j, kw ) )
                          a( j, k ) = d21*( d22*w( j, kw )-w( j, kw-1 ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_cgemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k,-cone, a( 1, k+1 ), &
                           lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in columns k+1:n looping backwards from k+1 to n
              j = k + 1
              60 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j + 1
                 end if
                 ! (note: here, j is used to determine row length. length n-j+1
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j + 1
                 if( jp/=jj .and. j<=n )call stdlib_cswap( n-j+1, a( jp, j ), lda, a( jj, j ), &
                           lda )
              if( j<n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              ! copy column k of a to column k of w and update it
              call stdlib_ccopy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ), lda,w( k, 1 ), ldw,&
                         cone, w( k, k ), 1 )
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! copy column imax to column k+1 of w and update it
                    call stdlib_ccopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1 )
                    call stdlib_ccopy( n-imax+1, a( imax, imax ), 1, w( imax, k+1 ),1 )
                    call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( imax, &
                              1 ), ldw, cone, w( k, k+1 ),1 )
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = k - 1 + stdlib_icamax( imax-k, w( k, k+1 ), 1 )
                    rowmax = cabs1( w( jmax, k+1 ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_icamax( n-imax, w( imax+1, k+1 ), 1 )
                       rowmax = max( rowmax, cabs1( w( jmax, k+1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( w( imax, k+1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column k+1 of w to column k of w
                       call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = a( kk, kk )
                    call stdlib_ccopy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    if( kp<n )call stdlib_ccopy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (columns k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_cswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_cswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    call stdlib_ccopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       r1 = cone / a( k, k )
                       call stdlib_cscal( n-k, r1, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! (note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored)
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! compose the columns of the inverse of 2-by-2 pivot
                       ! block d in the following way to reduce the number
                       ! of flops when we myltiply panel ( w(k) w(k+1) ) by
                       ! this inverse
                       ! d**(-1) = ( d11 d21 )**(-1) =
                                 ! ( d21 d22 )
                       ! = 1/(d11*d22-d21**2) * ( ( d22 ) (-d21 ) ) =
                                              ! ( (-d21 ) ( d11 ) )
                       ! = 1/d21 * 1/((d11/d21)*(d22/d21)-1) *
                         ! * ( ( d22/d21 ) (      -1 ) ) =
                           ! ( (      -1 ) ( d11/d21 ) )
                       ! = 1/d21 * 1/(d22*d11-1) * ( ( d11 ) (  -1 ) ) =
                                                 ! ( ( -1  ) ( d22 ) )
                       ! = 1/d21 * t * ( ( d11 ) (  -1 ) )
                                     ! ( (  -1 ) ( d22 ) )
                       ! = d21 * ( ( d11 ) (  -1 ) )
                               ! ( (  -1 ) ( d22 ) )
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       d21 = t / d21
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = d21*( d11*w( j, k )-w( j, k+1 ) )
                          a( j, k+1 ) = d21*( d22*w( j, k+1 )-w( j, k ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_cgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! of rows in columns 1:k-1 looping backwards from k-1 to 1
              j = k - 1
              120 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j - 1
                 end if
                 ! (note: here, j is used to determine row length. length j
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j - 1
                 if( jp/=jj .and. j>=1 )call stdlib_cswap( j, a( jp, 1 ), lda, a( jj, 1 ), lda )
                           
              if( j>1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_clasyf

     module pure subroutine stdlib_zlasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
     !! ZLASYF computes a partial factorization of a complex symmetric matrix
     !! A using the Bunch-Kaufman diagonal pivoting method. The partial
     !! factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) ( D    0  ) ( L11**T L21**T )  if UPLO = 'L'
     !! ( L21  I ) ( 0   A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! Note that U**T denotes the transpose of U.
     !! ZLASYF is an auxiliary routine called by ZSYTRF. It uses blocked code
     !! (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
     !! A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           
           ! Local Scalars 
           integer(ilp) :: imax, j, jb, jj, jmax, jp, k, kk, kkw, kp, kstep, kw
           real(dp) :: absakk, alpha, colmax, rowmax
           complex(dp) :: d11, d21, d22, r1, t, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=dp) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              ! kw is the column of w which corresponds to column k of a
              k = n
              10 continue
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              ! copy column k of a to column kw of w and update it
              call stdlib_zcopy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_zgemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ), lda,w( k, &
                        kw+1 ), ldw, cone, w( 1, kw ), 1 )
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              if( k>1 ) then
                 imax = stdlib_izamax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! copy column imax to column kw-1 of w and update it
                    call stdlib_zcopy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                    call stdlib_zcopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                              
                    if( k<n )call stdlib_zgemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda, w(&
                               imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = imax + stdlib_izamax( k-imax, w( imax+1, kw-1 ), 1 )
                    rowmax = cabs1( w( jmax, kw-1 ) )
                    if( imax>1 ) then
                       jmax = stdlib_izamax( imax-1, w( 1, kw-1 ), 1 )
                       rowmax = max( rowmax, cabs1( w( jmax, kw-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( w( imax, kw-1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column kw-1 of w to column kw of w
                       call stdlib_zcopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = a( kk, kk )
                    call stdlib_zcopy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    if( kp>1 )call stdlib_zcopy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_zswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_zswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! note: diagonal element u(k,k) is a unit element
                    ! and not stored.
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    call stdlib_zcopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    r1 = cone / a( k, k )
                    call stdlib_zscal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored.
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! compose the columns of the inverse of 2-by-2 pivot
                       ! block d in the following way to reduce the number
                       ! of flops when we myltiply panel ( w(kw-1) w(kw) ) by
                       ! this inverse
                       ! d**(-1) = ( d11 d21 )**(-1) =
                                 ! ( d21 d22 )
                       ! = 1/(d11*d22-d21**2) * ( ( d22 ) (-d21 ) ) =
                                              ! ( (-d21 ) ( d11 ) )
                       ! = 1/d21 * 1/((d11/d21)*(d22/d21)-1) *
                         ! * ( ( d22/d21 ) (      -1 ) ) =
                           ! ( (      -1 ) ( d11/d21 ) )
                       ! = 1/d21 * 1/(d22*d11-1) * ( ( d11 ) (  -1 ) ) =
                                                 ! ( ( -1  ) ( d22 ) )
                       ! = 1/d21 * t * ( ( d11 ) (  -1 ) )
                                     ! ( (  -1 ) ( d22 ) )
                       ! = d21 * ( ( d11 ) (  -1 ) )
                               ! ( (  -1 ) ( d22 ) )
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / d21
                       d22 = w( k-1, kw-1 ) / d21
                       t = cone / ( d11*d22-cone )
                       d21 = t / d21
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       do j = 1, k - 2
                          a( j, k-1 ) = d21*( d11*w( j, kw-1 )-w( j, kw ) )
                          a( j, k ) = d21*( d22*w( j, kw )-w( j, kw-1 ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_zgemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 call stdlib_zgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k,-cone, a( 1, k+1 ), &
                           lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in columns k+1:n looping backwards from k+1 to n
              j = k + 1
              60 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j + 1
                 end if
                 ! (note: here, j is used to determine row length. length n-j+1
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j + 1
                 if( jp/=jj .and. j<=n )call stdlib_zswap( n-j+1, a( jp, j ), lda, a( jj, j ), &
                           lda )
              if( j<n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              ! copy column k of a to column k of w and update it
              call stdlib_zcopy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              call stdlib_zgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ), lda,w( k, 1 ), ldw,&
                         cone, w( k, k ), 1 )
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              if( k<n ) then
                 imax = k + stdlib_izamax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! copy column imax to column k+1 of w and update it
                    call stdlib_zcopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1 )
                    call stdlib_zcopy( n-imax+1, a( imax, imax ), 1, w( imax, k+1 ),1 )
                    call stdlib_zgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( imax, &
                              1 ), ldw, cone, w( k, k+1 ),1 )
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = k - 1 + stdlib_izamax( imax-k, w( k, k+1 ), 1 )
                    rowmax = cabs1( w( jmax, k+1 ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_izamax( n-imax, w( imax+1, k+1 ), 1 )
                       rowmax = max( rowmax, cabs1( w( jmax, k+1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( w( imax, k+1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column k+1 of w to column k of w
                       call stdlib_zcopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = a( kk, kk )
                    call stdlib_zcopy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    if( kp<n )call stdlib_zcopy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (columns k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_zswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_zswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    call stdlib_zcopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       r1 = cone / a( k, k )
                       call stdlib_zscal( n-k, r1, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! (note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored)
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! compose the columns of the inverse of 2-by-2 pivot
                       ! block d in the following way to reduce the number
                       ! of flops when we myltiply panel ( w(k) w(k+1) ) by
                       ! this inverse
                       ! d**(-1) = ( d11 d21 )**(-1) =
                                 ! ( d21 d22 )
                       ! = 1/(d11*d22-d21**2) * ( ( d22 ) (-d21 ) ) =
                                              ! ( (-d21 ) ( d11 ) )
                       ! = 1/d21 * 1/((d11/d21)*(d22/d21)-1) *
                         ! * ( ( d22/d21 ) (      -1 ) ) =
                           ! ( (      -1 ) ( d11/d21 ) )
                       ! = 1/d21 * 1/(d22*d11-1) * ( ( d11 ) (  -1 ) ) =
                                                 ! ( ( -1  ) ( d22 ) )
                       ! = 1/d21 * t * ( ( d11 ) (  -1 ) )
                                     ! ( (  -1 ) ( d22 ) )
                       ! = d21 * ( ( d11 ) (  -1 ) )
                               ! ( (  -1 ) ( d22 ) )
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       d21 = t / d21
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = d21*( d11*w( j, k )-w( j, k+1 ) )
                          a( j, k+1 ) = d21*( d22*w( j, k+1 )-w( j, k ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_zgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_zgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! of rows in columns 1:k-1 looping backwards from k-1 to 1
              j = k - 1
              120 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j - 1
                 end if
                 ! (note: here, j is used to determine row length. length j
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j - 1
                 if( jp/=jj .and. j>=1 )call stdlib_zswap( j, a( jp, 1 ), lda, a( jj, 1 ), lda )
                           
              if( j>1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_zlasyf

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$lasyf( uplo, n, nb, kb, a, lda, ipiv, w, ldw, info )
     !! ZLASYF: computes a partial factorization of a complex symmetric matrix
     !! A using the Bunch-Kaufman diagonal pivoting method. The partial
     !! factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) ( D    0  ) ( L11**T L21**T )  if UPLO = 'L'
     !! ( L21  I ) ( 0   A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! Note that U**T denotes the transpose of U.
     !! ZLASYF is an auxiliary routine called by ZSYTRF. It uses blocked code
     !! (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
     !! A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: sevten = 17.0e+0_${ck}$
           
           
           
           ! Local Scalars 
           integer(ilp) :: imax, j, jb, jj, jmax, jp, k, kk, kkw, kp, kstep, kw
           real(${ck}$) :: absakk, alpha, colmax, rowmax
           complex(${ck}$) :: d11, d21, d22, r1, t, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=${ck}$) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              ! kw is the column of w which corresponds to column k of a
              k = n
              10 continue
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              ! copy column k of a to column kw of w and update it
              call stdlib_${ci}$copy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_${ci}$gemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ), lda,w( k, &
                        kw+1 ), ldw, cone, w( 1, kw ), 1 )
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              if( k>1 ) then
                 imax = stdlib_i${ci}$amax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! copy column imax to column kw-1 of w and update it
                    call stdlib_${ci}$copy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                    call stdlib_${ci}$copy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                              
                    if( k<n )call stdlib_${ci}$gemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda, w(&
                               imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = imax + stdlib_i${ci}$amax( k-imax, w( imax+1, kw-1 ), 1 )
                    rowmax = cabs1( w( jmax, kw-1 ) )
                    if( imax>1 ) then
                       jmax = stdlib_i${ci}$amax( imax-1, w( 1, kw-1 ), 1 )
                       rowmax = max( rowmax, cabs1( w( jmax, kw-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( w( imax, kw-1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column kw-1 of w to column kw of w
                       call stdlib_${ci}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = a( kk, kk )
                    call stdlib_${ci}$copy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    if( kp>1 )call stdlib_${ci}$copy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_${ci}$swap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_${ci}$swap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! note: diagonal element u(k,k) is a unit element
                    ! and not stored.
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    call stdlib_${ci}$copy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    r1 = cone / a( k, k )
                    call stdlib_${ci}$scal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored.
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! compose the columns of the inverse of 2-by-2 pivot
                       ! block d in the following way to reduce the number
                       ! of flops when we myltiply panel ( w(kw-1) w(kw) ) by
                       ! this inverse
                       ! d**(-1) = ( d11 d21 )**(-1) =
                                 ! ( d21 d22 )
                       ! = 1/(d11*d22-d21**2) * ( ( d22 ) (-d21 ) ) =
                                              ! ( (-d21 ) ( d11 ) )
                       ! = 1/d21 * 1/((d11/d21)*(d22/d21)-1) *
                         ! * ( ( d22/d21 ) (      -1 ) ) =
                           ! ( (      -1 ) ( d11/d21 ) )
                       ! = 1/d21 * 1/(d22*d11-1) * ( ( d11 ) (  -1 ) ) =
                                                 ! ( ( -1  ) ( d22 ) )
                       ! = 1/d21 * t * ( ( d11 ) (  -1 ) )
                                     ! ( (  -1 ) ( d22 ) )
                       ! = d21 * ( ( d11 ) (  -1 ) )
                               ! ( (  -1 ) ( d22 ) )
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / d21
                       d22 = w( k-1, kw-1 ) / d21
                       t = cone / ( d11*d22-cone )
                       d21 = t / d21
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       do j = 1, k - 2
                          a( j, k-1 ) = d21*( d11*w( j, kw-1 )-w( j, kw ) )
                          a( j, k ) = d21*( d22*w( j, kw )-w( j, kw-1 ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_${ci}$gemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k,-cone, a( 1, k+1 ), &
                           lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in columns k+1:n looping backwards from k+1 to n
              j = k + 1
              60 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j + 1
                 end if
                 ! (note: here, j is used to determine row length. length n-j+1
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j + 1
                 if( jp/=jj .and. j<=n )call stdlib_${ci}$swap( n-j+1, a( jp, j ), lda, a( jj, j ), &
                           lda )
              if( j<n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              ! copy column k of a to column k of w and update it
              call stdlib_${ci}$copy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ), lda,w( k, 1 ), ldw,&
                         cone, w( k, k ), 1 )
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              if( k<n ) then
                 imax = k + stdlib_i${ci}$amax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! copy column imax to column k+1 of w and update it
                    call stdlib_${ci}$copy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1 )
                    call stdlib_${ci}$copy( n-imax+1, a( imax, imax ), 1, w( imax, k+1 ),1 )
                    call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( imax, &
                              1 ), ldw, cone, w( k, k+1 ),1 )
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = k - 1 + stdlib_i${ci}$amax( imax-k, w( k, k+1 ), 1 )
                    rowmax = cabs1( w( jmax, k+1 ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_i${ci}$amax( n-imax, w( imax+1, k+1 ), 1 )
                       rowmax = max( rowmax, cabs1( w( jmax, k+1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( w( imax, k+1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                       ! copy column k+1 of w to column k of w
                       call stdlib_${ci}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = a( kk, kk )
                    call stdlib_${ci}$copy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    if( kp<n )call stdlib_${ci}$copy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (columns k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_${ci}$swap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_${ci}$swap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    call stdlib_${ci}$copy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       r1 = cone / a( k, k )
                       call stdlib_${ci}$scal( n-k, r1, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! (note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored)
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! compose the columns of the inverse of 2-by-2 pivot
                       ! block d in the following way to reduce the number
                       ! of flops when we myltiply panel ( w(k) w(k+1) ) by
                       ! this inverse
                       ! d**(-1) = ( d11 d21 )**(-1) =
                                 ! ( d21 d22 )
                       ! = 1/(d11*d22-d21**2) * ( ( d22 ) (-d21 ) ) =
                                              ! ( (-d21 ) ( d11 ) )
                       ! = 1/d21 * 1/((d11/d21)*(d22/d21)-1) *
                         ! * ( ( d22/d21 ) (      -1 ) ) =
                           ! ( (      -1 ) ( d11/d21 ) )
                       ! = 1/d21 * 1/(d22*d11-1) * ( ( d11 ) (  -1 ) ) =
                                                 ! ( ( -1  ) ( d22 ) )
                       ! = 1/d21 * t * ( ( d11 ) (  -1 ) )
                                     ! ( (  -1 ) ( d22 ) )
                       ! = d21 * ( ( d11 ) (  -1 ) )
                               ! ( (  -1 ) ( d22 ) )
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       d21 = t / d21
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = d21*( d11*w( j, k )-w( j, k+1 ) )
                          a( j, k+1 ) = d21*( d22*w( j, k+1 )-w( j, k ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_${ci}$gemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! of rows in columns 1:k-1 looping backwards from k-1 to 1
              j = k - 1
              120 continue
                 ! undo the interchanges (if any) of rows jj and jp at each
                 ! step j
                 ! (here, j is a diagonal index)
                 jj = j
                 jp = ipiv( j )
                 if( jp<0 ) then
                    jp = -jp
                    ! (here, j is a diagonal index)
                    j = j - 1
                 end if
                 ! (note: here, j is used to determine row length. length j
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j - 1
                 if( jp/=jj .and. j>=1 )call stdlib_${ci}$swap( j, a( jp, 1 ), lda, a( jj, 1 ), lda )
                           
              if( j>1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_${ci}$lasyf

#:endif
#:endfor





     module pure subroutine stdlib_chetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
     !! CHETRS_ROOK solves a system of linear equations A*X = B with a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by CHETRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           real(sp) :: s
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRS_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**h.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_cgeru( k-1, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=sp) / real( a( k, k ),KIND=sp)
                 call stdlib_csscal( nrhs, s, b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k), then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1)
                 if( kp/=k-1 )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_cgeru( k-2, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 call stdlib_cgeru( k-2, nrhs, -cone, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ), &
                           ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / conjg( akm1k )
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / conjg( akm1k )
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**h *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**h(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**h(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k+1, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k+1 )&
                              , 1, cone, b( k+1, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k), then k+1 and -ipiv(k+1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**h.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_cgeru( n-k, nrhs, -cone, a( k+1, k ), 1, b( k, 1 ),ldb, b( &
                           k+1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=sp) / real( a( k, k ),KIND=sp)
                 call stdlib_csscal( nrhs, s, b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k), then k+1 and -ipiv(k+1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_cgeru( n-k-1, nrhs, -cone, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_cgeru( n-k-1, nrhs, -cone, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / conjg( akm1k )
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / conjg( akm1k )
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**h *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**h(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**h(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k-1, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k-1 ), 1, cone,b( k-1, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k-1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k), then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_chetrs_rook

     module pure subroutine stdlib_zhetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
     !! ZHETRS_ROOK solves a system of linear equations A*X = B with a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by ZHETRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           real(dp) :: s
           complex(dp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRS_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**h.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_zgeru( k-1, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=dp) / real( a( k, k ),KIND=dp)
                 call stdlib_zdscal( nrhs, s, b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k), then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1)
                 if( kp/=k-1 )call stdlib_zswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_zgeru( k-2, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 call stdlib_zgeru( k-2, nrhs, -cone, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ), &
                           ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / conjg( akm1k )
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / conjg( akm1k )
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**h *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**h(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 ) then
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**h(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k+1, 1 ), ldb )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k+1 )&
                              , 1, cone, b( k+1, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k), then k+1 and -ipiv(k+1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_zswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**h.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_zgeru( n-k, nrhs, -cone, a( k+1, k ), 1, b( k, 1 ),ldb, b( &
                           k+1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=dp) / real( a( k, k ),KIND=dp)
                 call stdlib_zdscal( nrhs, s, b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k), then k+1 and -ipiv(k+1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_zswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_zgeru( n-k-1, nrhs, -cone, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_zgeru( n-k-1, nrhs, -cone, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / conjg( akm1k )
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / conjg( akm1k )
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**h *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**h(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n ) then
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**h(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k-1, 1 ), ldb )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k-1 ), 1, cone,b( k-1, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k-1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k), then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_zswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_zhetrs_rook

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb,info )
     !! ZHETRS_ROOK: solves a system of linear equations A*X = B with a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by ZHETRF_ROOK.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           real(${ck}$) :: s
           complex(${ck}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRS_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**h.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_${ci}$geru( k-1, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=${ck}$) / real( a( k, k ),KIND=${ck}$)
                 call stdlib_${ci}$dscal( nrhs, s, b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k), then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1)
                 if( kp/=k-1 )call stdlib_${ci}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_${ci}$geru( k-2, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 call stdlib_${ci}$geru( k-2, nrhs, -cone, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ), &
                           ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / conjg( akm1k )
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / conjg( akm1k )
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**h *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**h(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 ) then
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**h(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k+1, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k+1 )&
                              , 1, cone, b( k+1, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k), then k+1 and -ipiv(k+1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_${ci}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**h.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ci}$geru( n-k, nrhs, -cone, a( k+1, k ), 1, b( k, 1 ),ldb, b( &
                           k+1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=${ck}$) / real( a( k, k ),KIND=${ck}$)
                 call stdlib_${ci}$dscal( nrhs, s, b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k), then k+1 and -ipiv(k+1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k+1 )
                 if( kp/=k+1 )call stdlib_${ci}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_${ci}$geru( n-k-1, nrhs, -cone, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_${ci}$geru( n-k-1, nrhs, -cone, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / conjg( akm1k )
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / conjg( akm1k )
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**h *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**h(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n ) then
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**h(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k-1, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k-1 ), 1, cone,b( k-1, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k-1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k), then k-1 and -ipiv(k-1)
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kp = -ipiv( k-1 )
                 if( kp/=k-1 )call stdlib_${ci}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_${ci}$hetrs_rook

#:endif
#:endfor



     module pure subroutine stdlib_chetf2_rk( uplo, n, a, lda, e, ipiv, info )
     !! CHETF2_RK computes the factorization of a complex Hermitian matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: e(*)
        ! ======================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: done, upper
           integer(ilp) :: i, ii, imax, itemp, j, jmax, k, kk, kp, kstep, p
           real(sp) :: absakk, alpha, colmax, d, d11, d22, r1, stemp, rowmax, tt, sfmin
           complex(sp) :: d12, d21, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETF2_RK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = czero
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 34
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=sp)
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = czero
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_icamax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_icamax( imax-1, a( 1, imax ), 1 )
                          stemp = cabs1( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=sp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( a( imax, imax ),KIND=sp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 12
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! for only a 2x2 pivot, interchange rows and columns k and p
                 ! in the leading submatrix a(1:k,1:k)
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! (1) swap columnar parts
                    if( p>1 )call stdlib_cswap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = p + 1, k - 1
                       t = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( p, j ) )
                       a( p, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( p, k ) = conjg( a( p, k ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( k, k ),KIND=sp)
                    a( k, k ) = real( a( p, p ),KIND=sp)
                    a( p, p ) = r1
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_cswap( n-k, a( k, k+1 ), lda, a( p, k+1 ), lda )
                 end if
                 ! for both 1x1 and 2x2 pivots, interchange rows and
                 ! columns kk and kp in the leading submatrix a(1:k,1:k)
                 if( kp/=kk ) then
                    ! (1) swap columnar parts
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = kp + 1, kk - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( kk, kk ),KIND=sp)
                    a( kk, kk ) = real( a( kp, kp ),KIND=sp)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       ! (*) make sure that diagonal element of pivot is real
                       a( k, k ) = real( a( k, k ),KIND=sp)
                       ! (5) swap row elements
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_cswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                 else
                    ! (*) make sure that diagonal element of pivot is real
                    a( k, k ) = real( a( k, k ),KIND=sp)
                    if( kstep==2 )a( k-1, k-1 ) = real( a( k-1, k-1 ),KIND=sp)
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( abs( real( a( k, k ),KIND=sp) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = one / real( a( k, k ),KIND=sp)
                          call stdlib_cher( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_csscal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = real( a( k, k ),KIND=sp)
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_cher( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       ! d = |a12|
                       d = stdlib_slapy2( real( a( k-1, k ),KIND=sp),aimag( a( k-1, k ) ) )
                                 
                       d11 = real( a( k, k ) / d,KIND=sp)
                       d22 = real( a( k-1, k-1 ) / d,KIND=sp)
                       d12 = a( k-1, k ) / d
                       tt = one / ( d11*d22-one )
                       do j = k - 2, 1, -1
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wkm1 = tt*( d11*a( j, k-1 )-conjg( d12 )*a( j, k ) )
                          wk = tt*( d22*a( j, k )-d12*a( j, k-1 ) )
                          ! perform a rank-2 update of a(1:k-2,1:k-2)
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) -( a( i, k ) / d )*conjg( wk ) -( a( i, k-1 ) &
                                       / d )*conjg( wkm1 )
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d
                          a( j, k-1 ) = wkm1 / d
                          ! (*) make sure that diagonal element of pivot is real
                          a( j, j ) = cmplx( real( a( j, j ),KIND=sp), zero,KIND=sp)
                       end do
                    end if
                    ! copy superdiagonal elements of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    e( k ) = a( k-1, k )
                    e( k-1 ) = czero
                    a( k-1, k ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              34 continue
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = czero
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 64
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=sp)
                 ! set e( k ) to zero
                 if( k<n )e( k ) = czero
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_icamax( imax-k, a( imax, k ), lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_icamax( n-imax, a( imax+1, imax ),1 )
                          stemp = cabs1( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=sp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( a( imax, imax ),KIND=sp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 42
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! for only a 2x2 pivot, interchange rows and columns k and p
                 ! in the trailing submatrix a(k:n,k:n)
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! (1) swap columnar parts
                    if( p<n )call stdlib_cswap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = k + 1, p - 1
                       t = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( p, j ) )
                       a( p, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( p, k ) = conjg( a( p, k ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( k, k ),KIND=sp)
                    a( k, k ) = real( a( p, p ),KIND=sp)
                    a( p, p ) = r1
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_cswap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                 end if
                 ! for both 1x1 and 2x2 pivots, interchange rows and
                 ! columns kk and kp in the trailing submatrix a(k:n,k:n)
                 if( kp/=kk ) then
                    ! (1) swap columnar parts
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! (2) swap and conjugate middle parts
                    do j = kk + 1, kp - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( kk, kk ),KIND=sp)
                    a( kk, kk ) = real( a( kp, kp ),KIND=sp)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       ! (*) make sure that diagonal element of pivot is real
                       a( k, k ) = real( a( k, k ),KIND=sp)
                       ! (5) swap row elements
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_cswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                 else
                    ! (*) make sure that diagonal element of pivot is real
                    a( k, k ) = real( a( k, k ),KIND=sp)
                    if( kstep==2 )a( k+1, k+1 ) = real( a( k+1, k+1 ),KIND=sp)
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of a now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) and
                       ! store l(k) in column k
                       ! handle division by a small number
                       if( abs( real( a( k, k ),KIND=sp) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = one / real( a( k, k ),KIND=sp)
                          call stdlib_cher( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_csscal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = real( a( k, k ),KIND=sp)
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_cher( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       ! d = |a21|
                       d = stdlib_slapy2( real( a( k+1, k ),KIND=sp),aimag( a( k+1, k ) ) )
                                 
                       d11 = real( a( k+1, k+1 ),KIND=sp) / d
                       d22 = real( a( k, k ),KIND=sp) / d
                       d21 = a( k+1, k ) / d
                       tt = one / ( d11*d22-one )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = tt*( d11*a( j, k )-d21*a( j, k+1 ) )
                          wkp1 = tt*( d22*a( j, k+1 )-conjg( d21 )*a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) -( a( i, k ) / d )*conjg( wk ) -( a( i, k+1 ) &
                                       / d )*conjg( wkp1 )
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d
                          a( j, k+1 ) = wkp1 / d
                          ! (*) make sure that diagonal element of pivot is real
                          a( j, j ) = cmplx( real( a( j, j ),KIND=sp), zero,KIND=sp)
                       end do
                    end if
                    ! copy subdiagonal elements of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    e( k ) = a( k+1, k )
                    e( k+1 ) = czero
                    a( k+1, k ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
              64 continue
           end if
           return
     end subroutine stdlib_chetf2_rk

     module pure subroutine stdlib_zhetf2_rk( uplo, n, a, lda, e, ipiv, info )
     !! ZHETF2_RK computes the factorization of a complex Hermitian matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: e(*)
        ! ======================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           
           ! Local Scalars 
           logical(lk) :: done, upper
           integer(ilp) :: i, ii, imax, itemp, j, jmax, k, kk, kp, kstep, p
           real(dp) :: absakk, alpha, colmax, d, d11, d22, r1, dtemp, rowmax, tt, sfmin
           complex(dp) :: d12, d21, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=dp) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETF2_RK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_dlamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = czero
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 34
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=dp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_izamax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=dp)
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = czero
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_izamax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_izamax( imax-1, a( 1, imax ), 1 )
                          dtemp = cabs1( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=dp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( a( imax, imax ),KIND=dp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 12
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! for only a 2x2 pivot, interchange rows and columns k and p
                 ! in the leading submatrix a(1:k,1:k)
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! (1) swap columnar parts
                    if( p>1 )call stdlib_zswap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = p + 1, k - 1
                       t = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( p, j ) )
                       a( p, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( p, k ) = conjg( a( p, k ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( k, k ),KIND=dp)
                    a( k, k ) = real( a( p, p ),KIND=dp)
                    a( p, p ) = r1
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_zswap( n-k, a( k, k+1 ), lda, a( p, k+1 ), lda )
                 end if
                 ! for both 1x1 and 2x2 pivots, interchange rows and
                 ! columns kk and kp in the leading submatrix a(1:k,1:k)
                 if( kp/=kk ) then
                    ! (1) swap columnar parts
                    if( kp>1 )call stdlib_zswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = kp + 1, kk - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( kk, kk ),KIND=dp)
                    a( kk, kk ) = real( a( kp, kp ),KIND=dp)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       ! (*) make sure that diagonal element of pivot is real
                       a( k, k ) = real( a( k, k ),KIND=dp)
                       ! (5) swap row elements
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_zswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                 else
                    ! (*) make sure that diagonal element of pivot is real
                    a( k, k ) = real( a( k, k ),KIND=dp)
                    if( kstep==2 )a( k-1, k-1 ) = real( a( k-1, k-1 ),KIND=dp)
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( abs( real( a( k, k ),KIND=dp) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = one / real( a( k, k ),KIND=dp)
                          call stdlib_zher( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_zdscal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = real( a( k, k ),KIND=dp)
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_zher( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       ! d = |a12|
                       d = stdlib_dlapy2( real( a( k-1, k ),KIND=dp),aimag( a( k-1, k ) ) )
                                 
                       d11 = real( a( k, k ) / d,KIND=dp)
                       d22 = real( a( k-1, k-1 ) / d,KIND=dp)
                       d12 = a( k-1, k ) / d
                       tt = one / ( d11*d22-one )
                       do j = k - 2, 1, -1
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wkm1 = tt*( d11*a( j, k-1 )-conjg( d12 )*a( j, k ) )
                          wk = tt*( d22*a( j, k )-d12*a( j, k-1 ) )
                          ! perform a rank-2 update of a(1:k-2,1:k-2)
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) -( a( i, k ) / d )*conjg( wk ) -( a( i, k-1 ) &
                                       / d )*conjg( wkm1 )
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d
                          a( j, k-1 ) = wkm1 / d
                          ! (*) make sure that diagonal element of pivot is real
                          a( j, j ) = cmplx( real( a( j, j ),KIND=dp), zero,KIND=dp)
                       end do
                    end if
                    ! copy superdiagonal elements of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    e( k ) = a( k-1, k )
                    e( k-1 ) = czero
                    a( k-1, k ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              34 continue
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = czero
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 64
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=dp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_izamax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=dp)
                 ! set e( k ) to zero
                 if( k<n )e( k ) = czero
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_izamax( imax-k, a( imax, k ), lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_izamax( n-imax, a( imax+1, imax ),1 )
                          dtemp = cabs1( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=dp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( a( imax, imax ),KIND=dp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 42
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! for only a 2x2 pivot, interchange rows and columns k and p
                 ! in the trailing submatrix a(k:n,k:n)
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! (1) swap columnar parts
                    if( p<n )call stdlib_zswap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = k + 1, p - 1
                       t = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( p, j ) )
                       a( p, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( p, k ) = conjg( a( p, k ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( k, k ),KIND=dp)
                    a( k, k ) = real( a( p, p ),KIND=dp)
                    a( p, p ) = r1
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_zswap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                 end if
                 ! for both 1x1 and 2x2 pivots, interchange rows and
                 ! columns kk and kp in the trailing submatrix a(k:n,k:n)
                 if( kp/=kk ) then
                    ! (1) swap columnar parts
                    if( kp<n )call stdlib_zswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! (2) swap and conjugate middle parts
                    do j = kk + 1, kp - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( kk, kk ),KIND=dp)
                    a( kk, kk ) = real( a( kp, kp ),KIND=dp)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       ! (*) make sure that diagonal element of pivot is real
                       a( k, k ) = real( a( k, k ),KIND=dp)
                       ! (5) swap row elements
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_zswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                 else
                    ! (*) make sure that diagonal element of pivot is real
                    a( k, k ) = real( a( k, k ),KIND=dp)
                    if( kstep==2 )a( k+1, k+1 ) = real( a( k+1, k+1 ),KIND=dp)
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of a now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) and
                       ! store l(k) in column k
                       ! handle division by a small number
                       if( abs( real( a( k, k ),KIND=dp) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = one / real( a( k, k ),KIND=dp)
                          call stdlib_zher( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_zdscal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = real( a( k, k ),KIND=dp)
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_zher( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       ! d = |a21|
                       d = stdlib_dlapy2( real( a( k+1, k ),KIND=dp),aimag( a( k+1, k ) ) )
                                 
                       d11 = real( a( k+1, k+1 ),KIND=dp) / d
                       d22 = real( a( k, k ),KIND=dp) / d
                       d21 = a( k+1, k ) / d
                       tt = one / ( d11*d22-one )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = tt*( d11*a( j, k )-d21*a( j, k+1 ) )
                          wkp1 = tt*( d22*a( j, k+1 )-conjg( d21 )*a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) -( a( i, k ) / d )*conjg( wk ) -( a( i, k+1 ) &
                                       / d )*conjg( wkp1 )
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d
                          a( j, k+1 ) = wkp1 / d
                          ! (*) make sure that diagonal element of pivot is real
                          a( j, j ) = cmplx( real( a( j, j ),KIND=dp), zero,KIND=dp)
                       end do
                    end if
                    ! copy subdiagonal elements of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    e( k ) = a( k+1, k )
                    e( k+1 ) = czero
                    a( k+1, k ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
              64 continue
           end if
           return
     end subroutine stdlib_zhetf2_rk

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hetf2_rk( uplo, n, a, lda, e, ipiv, info )
     !! ZHETF2_RK: computes the factorization of a complex Hermitian matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: e(*)
        ! ======================================================================
           ! Parameters 
           real(${ck}$), parameter :: sevten = 17.0e+0_${ck}$
           
           
           
           ! Local Scalars 
           logical(lk) :: done, upper
           integer(ilp) :: i, ii, imax, itemp, j, jmax, k, kk, kp, kstep, p
           real(${ck}$) :: absakk, alpha, colmax, d, d11, d22, r1, dtemp, rowmax, tt, sfmin
           complex(${ck}$) :: d12, d21, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=${ck}$) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETF2_RK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_${c2ri(ci)}$lamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = czero
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 34
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=${ck}$) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ci}$amax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=${ck}$)
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = czero
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_i${ci}$amax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_i${ci}$amax( imax-1, a( 1, imax ), 1 )
                          dtemp = cabs1( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=${ck}$) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( a( imax, imax ),KIND=${ck}$) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 12
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! for only a 2x2 pivot, interchange rows and columns k and p
                 ! in the leading submatrix a(1:k,1:k)
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! (1) swap columnar parts
                    if( p>1 )call stdlib_${ci}$swap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = p + 1, k - 1
                       t = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( p, j ) )
                       a( p, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( p, k ) = conjg( a( p, k ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( k, k ),KIND=${ck}$)
                    a( k, k ) = real( a( p, p ),KIND=${ck}$)
                    a( p, p ) = r1
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_${ci}$swap( n-k, a( k, k+1 ), lda, a( p, k+1 ), lda )
                 end if
                 ! for both 1x1 and 2x2 pivots, interchange rows and
                 ! columns kk and kp in the leading submatrix a(1:k,1:k)
                 if( kp/=kk ) then
                    ! (1) swap columnar parts
                    if( kp>1 )call stdlib_${ci}$swap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = kp + 1, kk - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( kk, kk ),KIND=${ck}$)
                    a( kk, kk ) = real( a( kp, kp ),KIND=${ck}$)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       ! (*) make sure that diagonal element of pivot is real
                       a( k, k ) = real( a( k, k ),KIND=${ck}$)
                       ! (5) swap row elements
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_${ci}$swap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                 else
                    ! (*) make sure that diagonal element of pivot is real
                    a( k, k ) = real( a( k, k ),KIND=${ck}$)
                    if( kstep==2 )a( k-1, k-1 ) = real( a( k-1, k-1 ),KIND=${ck}$)
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( abs( real( a( k, k ),KIND=${ck}$) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = one / real( a( k, k ),KIND=${ck}$)
                          call stdlib_${ci}$her( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_${ci}$dscal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = real( a( k, k ),KIND=${ck}$)
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_${ci}$her( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       ! d = |a12|
                       d = stdlib_${c2ri(ci)}$lapy2( real( a( k-1, k ),KIND=${ck}$),aimag( a( k-1, k ) ) )
                                 
                       d11 = real( a( k, k ) / d,KIND=${ck}$)
                       d22 = real( a( k-1, k-1 ) / d,KIND=${ck}$)
                       d12 = a( k-1, k ) / d
                       tt = one / ( d11*d22-one )
                       do j = k - 2, 1, -1
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wkm1 = tt*( d11*a( j, k-1 )-conjg( d12 )*a( j, k ) )
                          wk = tt*( d22*a( j, k )-d12*a( j, k-1 ) )
                          ! perform a rank-2 update of a(1:k-2,1:k-2)
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) -( a( i, k ) / d )*conjg( wk ) -( a( i, k-1 ) &
                                       / d )*conjg( wkm1 )
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d
                          a( j, k-1 ) = wkm1 / d
                          ! (*) make sure that diagonal element of pivot is real
                          a( j, j ) = cmplx( real( a( j, j ),KIND=${ck}$), zero,KIND=${ck}$)
                       end do
                    end if
                    ! copy superdiagonal elements of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    e( k ) = a( k-1, k )
                    e( k-1 ) = czero
                    a( k-1, k ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              34 continue
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = czero
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 64
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=${ck}$) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ci}$amax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=${ck}$)
                 ! set e( k ) to zero
                 if( k<n )e( k ) = czero
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_i${ci}$amax( imax-k, a( imax, k ), lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_i${ci}$amax( n-imax, a( imax+1, imax ),1 )
                          dtemp = cabs1( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=${ck}$) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( a( imax, imax ),KIND=${ck}$) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 42
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! for only a 2x2 pivot, interchange rows and columns k and p
                 ! in the trailing submatrix a(k:n,k:n)
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! (1) swap columnar parts
                    if( p<n )call stdlib_${ci}$swap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = k + 1, p - 1
                       t = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( p, j ) )
                       a( p, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( p, k ) = conjg( a( p, k ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( k, k ),KIND=${ck}$)
                    a( k, k ) = real( a( p, p ),KIND=${ck}$)
                    a( p, p ) = r1
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_${ci}$swap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                 end if
                 ! for both 1x1 and 2x2 pivots, interchange rows and
                 ! columns kk and kp in the trailing submatrix a(k:n,k:n)
                 if( kp/=kk ) then
                    ! (1) swap columnar parts
                    if( kp<n )call stdlib_${ci}$swap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! (2) swap and conjugate middle parts
                    do j = kk + 1, kp - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( kk, kk ),KIND=${ck}$)
                    a( kk, kk ) = real( a( kp, kp ),KIND=${ck}$)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       ! (*) make sure that diagonal element of pivot is real
                       a( k, k ) = real( a( k, k ),KIND=${ck}$)
                       ! (5) swap row elements
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_${ci}$swap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                 else
                    ! (*) make sure that diagonal element of pivot is real
                    a( k, k ) = real( a( k, k ),KIND=${ck}$)
                    if( kstep==2 )a( k+1, k+1 ) = real( a( k+1, k+1 ),KIND=${ck}$)
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of a now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) and
                       ! store l(k) in column k
                       ! handle division by a small number
                       if( abs( real( a( k, k ),KIND=${ck}$) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = one / real( a( k, k ),KIND=${ck}$)
                          call stdlib_${ci}$her( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_${ci}$dscal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = real( a( k, k ),KIND=${ck}$)
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_${ci}$her( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       ! d = |a21|
                       d = stdlib_${c2ri(ci)}$lapy2( real( a( k+1, k ),KIND=${ck}$),aimag( a( k+1, k ) ) )
                                 
                       d11 = real( a( k+1, k+1 ),KIND=${ck}$) / d
                       d22 = real( a( k, k ),KIND=${ck}$) / d
                       d21 = a( k+1, k ) / d
                       tt = one / ( d11*d22-one )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = tt*( d11*a( j, k )-d21*a( j, k+1 ) )
                          wkp1 = tt*( d22*a( j, k+1 )-conjg( d21 )*a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) -( a( i, k ) / d )*conjg( wk ) -( a( i, k+1 ) &
                                       / d )*conjg( wkp1 )
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d
                          a( j, k+1 ) = wkp1 / d
                          ! (*) make sure that diagonal element of pivot is real
                          a( j, j ) = cmplx( real( a( j, j ),KIND=${ck}$), zero,KIND=${ck}$)
                       end do
                    end if
                    ! copy subdiagonal elements of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    e( k ) = a( k+1, k )
                    e( k+1 ) = czero
                    a( k+1, k ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
              64 continue
           end if
           return
     end subroutine stdlib_${ci}$hetf2_rk

#:endif
#:endfor



     module pure subroutine stdlib_ssyconvf( uplo, way, n, a, lda, e, ipiv, info )
     !! If parameter WAY = 'C':
     !! SSYCONVF converts the factorization output format used in
     !! SSYTRF provided on entry in parameter A into the factorization
     !! output format used in SSYTRF_RK (or SSYTRF_BK) that is stored
     !! on exit in parameters A and E. It also converts in place details of
     !! the intechanges stored in IPIV from the format used in SSYTRF into
     !! the format used in SSYTRF_RK (or SSYTRF_BK).
     !! If parameter WAY = 'R':
     !! SSYCONVF performs the conversion in reverse direction, i.e.
     !! converts the factorization output format used in SSYTRF_RK
     !! (or SSYTRF_BK) provided on entry in parameters A and E into
     !! the factorization output format used in SSYTRF that is stored
     !! on exit in parameter A. It also converts in place details of
     !! the intechanges stored in IPIV from the format used in SSYTRF_RK
     !! (or SSYTRF_BK) into the format used in SSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*), e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYCONVF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! begin a is upper
              if ( convert ) then
                 ! convert a (a is upper)
                 ! convert value
                 ! assign superdiagonal entries of d to array e and zero out
                 ! corresponding entries in input storage a
                 i = n
                 e( 1 ) = zero
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       e( i ) = a( i-1, i )
                       e( i-1 ) = zero
                       a( i-1, i ) = zero
                       i = i - 1
                    else
                       e( i ) = zero
                    end if
                    i = i - 1
                 end do
                 ! convert permutations and ipiv
                 ! apply permutations to submatrices of upper part of a
                 ! in factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_sswap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i) in a(1:i,n-i:n)
                       ip = -ipiv( i )
                       if( i<n ) then
                          if( ip/=(i-1) ) then
                             call stdlib_sswap( n-i, a( i-1, i+1 ), lda,a( ip, i+1 ), lda )
                                       
                          end if
                       end if
                       ! convert ipiv
                       ! there is no interchnge of rows i and and ipiv(i),
                       ! so this should be reflected in ipiv format for
                       ! *sytrf_rk ( or *sytrf_bk)
                       ipiv( i ) = i
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              else
                 ! revert a (a is upper)
                 ! revert permutations and ipiv
                 ! apply permutations to submatrices of upper part of a
                 ! in reverse factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_sswap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i) in a(1:i,n-i:n)
                       i = i + 1
                       ip = -ipiv( i )
                       if( i<n ) then
                          if( ip/=(i-1) ) then
                             call stdlib_sswap( n-i, a( ip, i+1 ), lda,a( i-1, i+1 ), lda )
                                       
                          end if
                       end if
                       ! convert ipiv
                       ! there is one interchange of rows i-1 and ipiv(i-1),
                       ! so this should be recorded in two consecutive entries
                       ! in ipiv format for *sytrf
                       ipiv( i ) = ipiv( i-1 )
                    end if
                    i = i + 1
                 end do
                 ! revert value
                 ! assign superdiagonal entries of d from array e to
                 ! superdiagonal entries of a.
                 i = n
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       a( i-1, i ) = e( i )
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              ! end a is upper
              end if
           else
              ! begin a is lower
              if ( convert ) then
                 ! convert a (a is lower)
                 ! convert value
                 ! assign subdiagonal entries of d to array e and zero out
                 ! corresponding entries in input storage a
                 i = 1
                 e( n ) = zero
                 do while ( i<=n )
                    if( i<n .and. ipiv(i)<0 ) then
                       e( i ) = a( i+1, i )
                       e( i+1 ) = zero
                       a( i+1, i ) = zero
                       i = i + 1
                    else
                       e( i ) = zero
                    end if
                    i = i + 1
                 end do
                 ! convert permutations and ipiv
                 ! apply permutations to submatrices of lower part of a
                 ! in factorization order where k increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_sswap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i) in a(i:n,1:i-1)
                       ip = -ipiv( i )
                       if ( i>1 ) then
                          if( ip/=(i+1) ) then
                             call stdlib_sswap( i-1, a( i+1, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                       ! convert ipiv
                       ! there is no interchnge of rows i and and ipiv(i),
                       ! so this should be reflected in ipiv format for
                       ! *sytrf_rk ( or *sytrf_bk)
                       ipiv( i ) = i
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              else
                 ! revert a (a is lower)
                 ! revert permutations and ipiv
                 ! apply permutations to submatrices of lower part of a
                 ! in reverse factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_sswap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i) in a(i:n,1:i-1)
                       i = i - 1
                       ip = -ipiv( i )
                       if ( i>1 ) then
                          if( ip/=(i+1) ) then
                             call stdlib_sswap( i-1, a( ip, 1 ), lda,a( i+1, 1 ), lda )
                          end if
                       end if
                       ! convert ipiv
                       ! there is one interchange of rows i+1 and ipiv(i+1),
                       ! so this should be recorded in consecutive entries
                       ! in ipiv format for *sytrf
                       ipiv( i ) = ipiv( i+1 )
                    end if
                    i = i - 1
                 end do
                 ! revert value
                 ! assign subdiagonal entries of d from array e to
                 ! subgiagonal entries of a.
                 i = 1
                 do while ( i<=n-1 )
                    if( ipiv( i )<0 ) then
                       a( i + 1, i ) = e( i )
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              end if
              ! end a is lower
           end if
           return
     end subroutine stdlib_ssyconvf

     module pure subroutine stdlib_dsyconvf( uplo, way, n, a, lda, e, ipiv, info )
     !! If parameter WAY = 'C':
     !! DSYCONVF converts the factorization output format used in
     !! DSYTRF provided on entry in parameter A into the factorization
     !! output format used in DSYTRF_RK (or DSYTRF_BK) that is stored
     !! on exit in parameters A and E. It also converts in place details of
     !! the intechanges stored in IPIV from the format used in DSYTRF into
     !! the format used in DSYTRF_RK (or DSYTRF_BK).
     !! If parameter WAY = 'R':
     !! DSYCONVF performs the conversion in reverse direction, i.e.
     !! converts the factorization output format used in DSYTRF_RK
     !! (or DSYTRF_BK) provided on entry in parameters A and E into
     !! the factorization output format used in DSYTRF that is stored
     !! on exit in parameter A. It also converts in place details of
     !! the intechanges stored in IPIV from the format used in DSYTRF_RK
     !! (or DSYTRF_BK) into the format used in DSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*), e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYCONVF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! begin a is upper
              if ( convert ) then
                 ! convert a (a is upper)
                 ! convert value
                 ! assign superdiagonal entries of d to array e and zero out
                 ! corresponding entries in input storage a
                 i = n
                 e( 1 ) = zero
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       e( i ) = a( i-1, i )
                       e( i-1 ) = zero
                       a( i-1, i ) = zero
                       i = i - 1
                    else
                       e( i ) = zero
                    end if
                    i = i - 1
                 end do
                 ! convert permutations and ipiv
                 ! apply permutations to submatrices of upper part of a
                 ! in factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_dswap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i) in a(1:i,n-i:n)
                       ip = -ipiv( i )
                       if( i<n ) then
                          if( ip/=(i-1) ) then
                             call stdlib_dswap( n-i, a( i-1, i+1 ), lda,a( ip, i+1 ), lda )
                                       
                          end if
                       end if
                       ! convert ipiv
                       ! there is no interchnge of rows i and and ipiv(i),
                       ! so this should be reflected in ipiv format for
                       ! *sytrf_rk ( or *sytrf_bk)
                       ipiv( i ) = i
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              else
                 ! revert a (a is upper)
                 ! revert permutations and ipiv
                 ! apply permutations to submatrices of upper part of a
                 ! in reverse factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_dswap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i) in a(1:i,n-i:n)
                       i = i + 1
                       ip = -ipiv( i )
                       if( i<n ) then
                          if( ip/=(i-1) ) then
                             call stdlib_dswap( n-i, a( ip, i+1 ), lda,a( i-1, i+1 ), lda )
                                       
                          end if
                       end if
                       ! convert ipiv
                       ! there is one interchange of rows i-1 and ipiv(i-1),
                       ! so this should be recorded in two consecutive entries
                       ! in ipiv format for *sytrf
                       ipiv( i ) = ipiv( i-1 )
                    end if
                    i = i + 1
                 end do
                 ! revert value
                 ! assign superdiagonal entries of d from array e to
                 ! superdiagonal entries of a.
                 i = n
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       a( i-1, i ) = e( i )
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              ! end a is upper
              end if
           else
              ! begin a is lower
              if ( convert ) then
                 ! convert a (a is lower)
                 ! convert value
                 ! assign subdiagonal entries of d to array e and zero out
                 ! corresponding entries in input storage a
                 i = 1
                 e( n ) = zero
                 do while ( i<=n )
                    if( i<n .and. ipiv(i)<0 ) then
                       e( i ) = a( i+1, i )
                       e( i+1 ) = zero
                       a( i+1, i ) = zero
                       i = i + 1
                    else
                       e( i ) = zero
                    end if
                    i = i + 1
                 end do
                 ! convert permutations and ipiv
                 ! apply permutations to submatrices of lower part of a
                 ! in factorization order where k increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_dswap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i) in a(i:n,1:i-1)
                       ip = -ipiv( i )
                       if ( i>1 ) then
                          if( ip/=(i+1) ) then
                             call stdlib_dswap( i-1, a( i+1, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                       ! convert ipiv
                       ! there is no interchnge of rows i and and ipiv(i),
                       ! so this should be reflected in ipiv format for
                       ! *sytrf_rk ( or *sytrf_bk)
                       ipiv( i ) = i
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              else
                 ! revert a (a is lower)
                 ! revert permutations and ipiv
                 ! apply permutations to submatrices of lower part of a
                 ! in reverse factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_dswap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i) in a(i:n,1:i-1)
                       i = i - 1
                       ip = -ipiv( i )
                       if ( i>1 ) then
                          if( ip/=(i+1) ) then
                             call stdlib_dswap( i-1, a( ip, 1 ), lda,a( i+1, 1 ), lda )
                          end if
                       end if
                       ! convert ipiv
                       ! there is one interchange of rows i+1 and ipiv(i+1),
                       ! so this should be recorded in consecutive entries
                       ! in ipiv format for *sytrf
                       ipiv( i ) = ipiv( i+1 )
                    end if
                    i = i - 1
                 end do
                 ! revert value
                 ! assign subdiagonal entries of d from array e to
                 ! subgiagonal entries of a.
                 i = 1
                 do while ( i<=n-1 )
                    if( ipiv( i )<0 ) then
                       a( i + 1, i ) = e( i )
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              end if
              ! end a is lower
           end if
           return
     end subroutine stdlib_dsyconvf

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$syconvf( uplo, way, n, a, lda, e, ipiv, info )
     !! If parameter WAY = 'C':
     !! DSYCONVF: converts the factorization output format used in
     !! DSYTRF provided on entry in parameter A into the factorization
     !! output format used in DSYTRF_RK (or DSYTRF_BK) that is stored
     !! on exit in parameters A and E. It also converts in place details of
     !! the intechanges stored in IPIV from the format used in DSYTRF into
     !! the format used in DSYTRF_RK (or DSYTRF_BK).
     !! If parameter WAY = 'R':
     !! DSYCONVF performs the conversion in reverse direction, i.e.
     !! converts the factorization output format used in DSYTRF_RK
     !! (or DSYTRF_BK) provided on entry in parameters A and E into
     !! the factorization output format used in DSYTRF that is stored
     !! on exit in parameter A. It also converts in place details of
     !! the intechanges stored in IPIV from the format used in DSYTRF_RK
     !! (or DSYTRF_BK) into the format used in DSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYCONVF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! begin a is upper
              if ( convert ) then
                 ! convert a (a is upper)
                 ! convert value
                 ! assign superdiagonal entries of d to array e and zero out
                 ! corresponding entries in input storage a
                 i = n
                 e( 1 ) = zero
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       e( i ) = a( i-1, i )
                       e( i-1 ) = zero
                       a( i-1, i ) = zero
                       i = i - 1
                    else
                       e( i ) = zero
                    end if
                    i = i - 1
                 end do
                 ! convert permutations and ipiv
                 ! apply permutations to submatrices of upper part of a
                 ! in factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i) in a(1:i,n-i:n)
                       ip = -ipiv( i )
                       if( i<n ) then
                          if( ip/=(i-1) ) then
                             call stdlib_${ri}$swap( n-i, a( i-1, i+1 ), lda,a( ip, i+1 ), lda )
                                       
                          end if
                       end if
                       ! convert ipiv
                       ! there is no interchnge of rows i and and ipiv(i),
                       ! so this should be reflected in ipiv format for
                       ! *sytrf_rk ( or *sytrf_bk)
                       ipiv( i ) = i
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              else
                 ! revert a (a is upper)
                 ! revert permutations and ipiv
                 ! apply permutations to submatrices of upper part of a
                 ! in reverse factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i) in a(1:i,n-i:n)
                       i = i + 1
                       ip = -ipiv( i )
                       if( i<n ) then
                          if( ip/=(i-1) ) then
                             call stdlib_${ri}$swap( n-i, a( ip, i+1 ), lda,a( i-1, i+1 ), lda )
                                       
                          end if
                       end if
                       ! convert ipiv
                       ! there is one interchange of rows i-1 and ipiv(i-1),
                       ! so this should be recorded in two consecutive entries
                       ! in ipiv format for *sytrf
                       ipiv( i ) = ipiv( i-1 )
                    end if
                    i = i + 1
                 end do
                 ! revert value
                 ! assign superdiagonal entries of d from array e to
                 ! superdiagonal entries of a.
                 i = n
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       a( i-1, i ) = e( i )
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              ! end a is upper
              end if
           else
              ! begin a is lower
              if ( convert ) then
                 ! convert a (a is lower)
                 ! convert value
                 ! assign subdiagonal entries of d to array e and zero out
                 ! corresponding entries in input storage a
                 i = 1
                 e( n ) = zero
                 do while ( i<=n )
                    if( i<n .and. ipiv(i)<0 ) then
                       e( i ) = a( i+1, i )
                       e( i+1 ) = zero
                       a( i+1, i ) = zero
                       i = i + 1
                    else
                       e( i ) = zero
                    end if
                    i = i + 1
                 end do
                 ! convert permutations and ipiv
                 ! apply permutations to submatrices of lower part of a
                 ! in factorization order where k increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i) in a(i:n,1:i-1)
                       ip = -ipiv( i )
                       if ( i>1 ) then
                          if( ip/=(i+1) ) then
                             call stdlib_${ri}$swap( i-1, a( i+1, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                       ! convert ipiv
                       ! there is no interchnge of rows i and and ipiv(i),
                       ! so this should be reflected in ipiv format for
                       ! *sytrf_rk ( or *sytrf_bk)
                       ipiv( i ) = i
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              else
                 ! revert a (a is lower)
                 ! revert permutations and ipiv
                 ! apply permutations to submatrices of lower part of a
                 ! in reverse factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i) in a(i:n,1:i-1)
                       i = i - 1
                       ip = -ipiv( i )
                       if ( i>1 ) then
                          if( ip/=(i+1) ) then
                             call stdlib_${ri}$swap( i-1, a( ip, 1 ), lda,a( i+1, 1 ), lda )
                          end if
                       end if
                       ! convert ipiv
                       ! there is one interchange of rows i+1 and ipiv(i+1),
                       ! so this should be recorded in consecutive entries
                       ! in ipiv format for *sytrf
                       ipiv( i ) = ipiv( i+1 )
                    end if
                    i = i - 1
                 end do
                 ! revert value
                 ! assign subdiagonal entries of d from array e to
                 ! subgiagonal entries of a.
                 i = 1
                 do while ( i<=n-1 )
                    if( ipiv( i )<0 ) then
                       a( i + 1, i ) = e( i )
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              end if
              ! end a is lower
           end if
           return
     end subroutine stdlib_${ri}$syconvf

#:endif
#:endfor

     module pure subroutine stdlib_csyconvf( uplo, way, n, a, lda, e, ipiv, info )
     !! If parameter WAY = 'C':
     !! CSYCONVF converts the factorization output format used in
     !! CSYTRF provided on entry in parameter A into the factorization
     !! output format used in CSYTRF_RK (or CSYTRF_BK) that is stored
     !! on exit in parameters A and E. It also converts in place details of
     !! the intechanges stored in IPIV from the format used in CSYTRF into
     !! the format used in CSYTRF_RK (or CSYTRF_BK).
     !! If parameter WAY = 'R':
     !! CSYCONVF performs the conversion in reverse direction, i.e.
     !! converts the factorization output format used in CSYTRF_RK
     !! (or CSYTRF_BK) provided on entry in parameters A and E into
     !! the factorization output format used in CSYTRF that is stored
     !! on exit in parameter A. It also converts in place details of
     !! the intechanges stored in IPIV from the format used in CSYTRF_RK
     !! (or CSYTRF_BK) into the format used in CSYTRF.
     !! CSYCONVF can also convert in Hermitian matrix case, i.e. between
     !! formats used in CHETRF and CHETRF_RK (or CHETRF_BK).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYCONVF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! begin a is upper
              if ( convert ) then
                 ! convert a (a is upper)
                 ! convert value
                 ! assign superdiagonal entries of d to array e and czero out
                 ! corresponding entries in input storage a
                 i = n
                 e( 1 ) = czero
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       e( i ) = a( i-1, i )
                       e( i-1 ) = czero
                       a( i-1, i ) = czero
                       i = i - 1
                    else
                       e( i ) = czero
                    end if
                    i = i - 1
                 end do
                 ! convert permutations and ipiv
                 ! apply permutations to submatrices of upper part of a
                 ! in factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_cswap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i) in a(1:i,n-i:n)
                       ip = -ipiv( i )
                       if( i<n ) then
                          if( ip/=(i-1) ) then
                             call stdlib_cswap( n-i, a( i-1, i+1 ), lda,a( ip, i+1 ), lda )
                                       
                          end if
                       end if
                       ! convert ipiv
                       ! there is no interchnge of rows i and and ipiv(i),
                       ! so this should be reflected in ipiv format for
                       ! *sytrf_rk ( or *sytrf_bk)
                       ipiv( i ) = i
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              else
                 ! revert a (a is upper)
                 ! revert permutations and ipiv
                 ! apply permutations to submatrices of upper part of a
                 ! in reverse factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_cswap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i) in a(1:i,n-i:n)
                       i = i + 1
                       ip = -ipiv( i )
                       if( i<n ) then
                          if( ip/=(i-1) ) then
                             call stdlib_cswap( n-i, a( ip, i+1 ), lda,a( i-1, i+1 ), lda )
                                       
                          end if
                       end if
                       ! convert ipiv
                       ! there is cone interchange of rows i-1 and ipiv(i-1),
                       ! so this should be recorded in two consecutive entries
                       ! in ipiv format for *sytrf
                       ipiv( i ) = ipiv( i-1 )
                    end if
                    i = i + 1
                 end do
                 ! revert value
                 ! assign superdiagonal entries of d from array e to
                 ! superdiagonal entries of a.
                 i = n
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       a( i-1, i ) = e( i )
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              ! end a is upper
              end if
           else
              ! begin a is lower
              if ( convert ) then
                 ! convert a (a is lower)
                 ! convert value
                 ! assign subdiagonal entries of d to array e and czero out
                 ! corresponding entries in input storage a
                 i = 1
                 e( n ) = czero
                 do while ( i<=n )
                    if( i<n .and. ipiv(i)<0 ) then
                       e( i ) = a( i+1, i )
                       e( i+1 ) = czero
                       a( i+1, i ) = czero
                       i = i + 1
                    else
                       e( i ) = czero
                    end if
                    i = i + 1
                 end do
                 ! convert permutations and ipiv
                 ! apply permutations to submatrices of lower part of a
                 ! in factorization order where k increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_cswap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i) in a(i:n,1:i-1)
                       ip = -ipiv( i )
                       if ( i>1 ) then
                          if( ip/=(i+1) ) then
                             call stdlib_cswap( i-1, a( i+1, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                       ! convert ipiv
                       ! there is no interchnge of rows i and and ipiv(i),
                       ! so this should be reflected in ipiv format for
                       ! *sytrf_rk ( or *sytrf_bk)
                       ipiv( i ) = i
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              else
                 ! revert a (a is lower)
                 ! revert permutations and ipiv
                 ! apply permutations to submatrices of lower part of a
                 ! in reverse factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_cswap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i) in a(i:n,1:i-1)
                       i = i - 1
                       ip = -ipiv( i )
                       if ( i>1 ) then
                          if( ip/=(i+1) ) then
                             call stdlib_cswap( i-1, a( ip, 1 ), lda,a( i+1, 1 ), lda )
                          end if
                       end if
                       ! convert ipiv
                       ! there is cone interchange of rows i+1 and ipiv(i+1),
                       ! so this should be recorded in consecutive entries
                       ! in ipiv format for *sytrf
                       ipiv( i ) = ipiv( i+1 )
                    end if
                    i = i - 1
                 end do
                 ! revert value
                 ! assign subdiagonal entries of d from array e to
                 ! subgiagonal entries of a.
                 i = 1
                 do while ( i<=n-1 )
                    if( ipiv( i )<0 ) then
                       a( i + 1, i ) = e( i )
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              end if
              ! end a is lower
           end if
           return
     end subroutine stdlib_csyconvf

     module pure subroutine stdlib_zsyconvf( uplo, way, n, a, lda, e, ipiv, info )
     !! If parameter WAY = 'C':
     !! ZSYCONVF converts the factorization output format used in
     !! ZSYTRF provided on entry in parameter A into the factorization
     !! output format used in ZSYTRF_RK (or ZSYTRF_BK) that is stored
     !! on exit in parameters A and E. It also converts in place details of
     !! the intechanges stored in IPIV from the format used in ZSYTRF into
     !! the format used in ZSYTRF_RK (or ZSYTRF_BK).
     !! If parameter WAY = 'R':
     !! ZSYCONVF performs the conversion in reverse direction, i.e.
     !! converts the factorization output format used in ZSYTRF_RK
     !! (or ZSYTRF_BK) provided on entry in parameters A and E into
     !! the factorization output format used in ZSYTRF that is stored
     !! on exit in parameter A. It also converts in place details of
     !! the intechanges stored in IPIV from the format used in ZSYTRF_RK
     !! (or ZSYTRF_BK) into the format used in ZSYTRF.
     !! ZSYCONVF can also convert in Hermitian matrix case, i.e. between
     !! formats used in ZHETRF and ZHETRF_RK (or ZHETRF_BK).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYCONVF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! begin a is upper
              if ( convert ) then
                 ! convert a (a is upper)
                 ! convert value
                 ! assign superdiagonal entries of d to array e and czero out
                 ! corresponding entries in input storage a
                 i = n
                 e( 1 ) = czero
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       e( i ) = a( i-1, i )
                       e( i-1 ) = czero
                       a( i-1, i ) = czero
                       i = i - 1
                    else
                       e( i ) = czero
                    end if
                    i = i - 1
                 end do
                 ! convert permutations and ipiv
                 ! apply permutations to submatrices of upper part of a
                 ! in factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_zswap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i) in a(1:i,n-i:n)
                       ip = -ipiv( i )
                       if( i<n ) then
                          if( ip/=(i-1) ) then
                             call stdlib_zswap( n-i, a( i-1, i+1 ), lda,a( ip, i+1 ), lda )
                                       
                          end if
                       end if
                       ! convert ipiv
                       ! there is no interchnge of rows i and and ipiv(i),
                       ! so this should be reflected in ipiv format for
                       ! *sytrf_rk ( or *sytrf_bk)
                       ipiv( i ) = i
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              else
                 ! revert a (a is upper)
                 ! revert permutations and ipiv
                 ! apply permutations to submatrices of upper part of a
                 ! in reverse factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_zswap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i) in a(1:i,n-i:n)
                       i = i + 1
                       ip = -ipiv( i )
                       if( i<n ) then
                          if( ip/=(i-1) ) then
                             call stdlib_zswap( n-i, a( ip, i+1 ), lda,a( i-1, i+1 ), lda )
                                       
                          end if
                       end if
                       ! convert ipiv
                       ! there is cone interchange of rows i-1 and ipiv(i-1),
                       ! so this should be recorded in two consecutive entries
                       ! in ipiv format for *sytrf
                       ipiv( i ) = ipiv( i-1 )
                    end if
                    i = i + 1
                 end do
                 ! revert value
                 ! assign superdiagonal entries of d from array e to
                 ! superdiagonal entries of a.
                 i = n
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       a( i-1, i ) = e( i )
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              ! end a is upper
              end if
           else
              ! begin a is lower
              if ( convert ) then
                 ! convert a (a is lower)
                 ! convert value
                 ! assign subdiagonal entries of d to array e and czero out
                 ! corresponding entries in input storage a
                 i = 1
                 e( n ) = czero
                 do while ( i<=n )
                    if( i<n .and. ipiv(i)<0 ) then
                       e( i ) = a( i+1, i )
                       e( i+1 ) = czero
                       a( i+1, i ) = czero
                       i = i + 1
                    else
                       e( i ) = czero
                    end if
                    i = i + 1
                 end do
                 ! convert permutations and ipiv
                 ! apply permutations to submatrices of lower part of a
                 ! in factorization order where k increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_zswap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i) in a(i:n,1:i-1)
                       ip = -ipiv( i )
                       if ( i>1 ) then
                          if( ip/=(i+1) ) then
                             call stdlib_zswap( i-1, a( i+1, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                       ! convert ipiv
                       ! there is no interchnge of rows i and and ipiv(i),
                       ! so this should be reflected in ipiv format for
                       ! *sytrf_rk ( or *sytrf_bk)
                       ipiv( i ) = i
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              else
                 ! revert a (a is lower)
                 ! revert permutations and ipiv
                 ! apply permutations to submatrices of lower part of a
                 ! in reverse factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_zswap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i) in a(i:n,1:i-1)
                       i = i - 1
                       ip = -ipiv( i )
                       if ( i>1 ) then
                          if( ip/=(i+1) ) then
                             call stdlib_zswap( i-1, a( ip, 1 ), lda,a( i+1, 1 ), lda )
                          end if
                       end if
                       ! convert ipiv
                       ! there is cone interchange of rows i+1 and ipiv(i+1),
                       ! so this should be recorded in consecutive entries
                       ! in ipiv format for *sytrf
                       ipiv( i ) = ipiv( i+1 )
                    end if
                    i = i - 1
                 end do
                 ! revert value
                 ! assign subdiagonal entries of d from array e to
                 ! subgiagonal entries of a.
                 i = 1
                 do while ( i<=n-1 )
                    if( ipiv( i )<0 ) then
                       a( i + 1, i ) = e( i )
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              end if
              ! end a is lower
           end if
           return
     end subroutine stdlib_zsyconvf

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$syconvf( uplo, way, n, a, lda, e, ipiv, info )
     !! If parameter WAY = 'C':
     !! ZSYCONVF: converts the factorization output format used in
     !! ZSYTRF provided on entry in parameter A into the factorization
     !! output format used in ZSYTRF_RK (or ZSYTRF_BK) that is stored
     !! on exit in parameters A and E. It also converts in place details of
     !! the intechanges stored in IPIV from the format used in ZSYTRF into
     !! the format used in ZSYTRF_RK (or ZSYTRF_BK).
     !! If parameter WAY = 'R':
     !! ZSYCONVF performs the conversion in reverse direction, i.e.
     !! converts the factorization output format used in ZSYTRF_RK
     !! (or ZSYTRF_BK) provided on entry in parameters A and E into
     !! the factorization output format used in ZSYTRF that is stored
     !! on exit in parameter A. It also converts in place details of
     !! the intechanges stored in IPIV from the format used in ZSYTRF_RK
     !! (or ZSYTRF_BK) into the format used in ZSYTRF.
     !! ZSYCONVF can also convert in Hermitian matrix case, i.e. between
     !! formats used in ZHETRF and ZHETRF_RK (or ZHETRF_BK).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYCONVF', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! begin a is upper
              if ( convert ) then
                 ! convert a (a is upper)
                 ! convert value
                 ! assign superdiagonal entries of d to array e and czero out
                 ! corresponding entries in input storage a
                 i = n
                 e( 1 ) = czero
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       e( i ) = a( i-1, i )
                       e( i-1 ) = czero
                       a( i-1, i ) = czero
                       i = i - 1
                    else
                       e( i ) = czero
                    end if
                    i = i - 1
                 end do
                 ! convert permutations and ipiv
                 ! apply permutations to submatrices of upper part of a
                 ! in factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_${ci}$swap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i) in a(1:i,n-i:n)
                       ip = -ipiv( i )
                       if( i<n ) then
                          if( ip/=(i-1) ) then
                             call stdlib_${ci}$swap( n-i, a( i-1, i+1 ), lda,a( ip, i+1 ), lda )
                                       
                          end if
                       end if
                       ! convert ipiv
                       ! there is no interchnge of rows i and and ipiv(i),
                       ! so this should be reflected in ipiv format for
                       ! *sytrf_rk ( or *sytrf_bk)
                       ipiv( i ) = i
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              else
                 ! revert a (a is upper)
                 ! revert permutations and ipiv
                 ! apply permutations to submatrices of upper part of a
                 ! in reverse factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_${ci}$swap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i) in a(1:i,n-i:n)
                       i = i + 1
                       ip = -ipiv( i )
                       if( i<n ) then
                          if( ip/=(i-1) ) then
                             call stdlib_${ci}$swap( n-i, a( ip, i+1 ), lda,a( i-1, i+1 ), lda )
                                       
                          end if
                       end if
                       ! convert ipiv
                       ! there is cone interchange of rows i-1 and ipiv(i-1),
                       ! so this should be recorded in two consecutive entries
                       ! in ipiv format for *sytrf
                       ipiv( i ) = ipiv( i-1 )
                    end if
                    i = i + 1
                 end do
                 ! revert value
                 ! assign superdiagonal entries of d from array e to
                 ! superdiagonal entries of a.
                 i = n
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       a( i-1, i ) = e( i )
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              ! end a is upper
              end if
           else
              ! begin a is lower
              if ( convert ) then
                 ! convert a (a is lower)
                 ! convert value
                 ! assign subdiagonal entries of d to array e and czero out
                 ! corresponding entries in input storage a
                 i = 1
                 e( n ) = czero
                 do while ( i<=n )
                    if( i<n .and. ipiv(i)<0 ) then
                       e( i ) = a( i+1, i )
                       e( i+1 ) = czero
                       a( i+1, i ) = czero
                       i = i + 1
                    else
                       e( i ) = czero
                    end if
                    i = i + 1
                 end do
                 ! convert permutations and ipiv
                 ! apply permutations to submatrices of lower part of a
                 ! in factorization order where k increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_${ci}$swap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i) in a(i:n,1:i-1)
                       ip = -ipiv( i )
                       if ( i>1 ) then
                          if( ip/=(i+1) ) then
                             call stdlib_${ci}$swap( i-1, a( i+1, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                       ! convert ipiv
                       ! there is no interchnge of rows i and and ipiv(i),
                       ! so this should be reflected in ipiv format for
                       ! *sytrf_rk ( or *sytrf_bk)
                       ipiv( i ) = i
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              else
                 ! revert a (a is lower)
                 ! revert permutations and ipiv
                 ! apply permutations to submatrices of lower part of a
                 ! in reverse factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_${ci}$swap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i) in a(i:n,1:i-1)
                       i = i - 1
                       ip = -ipiv( i )
                       if ( i>1 ) then
                          if( ip/=(i+1) ) then
                             call stdlib_${ci}$swap( i-1, a( ip, 1 ), lda,a( i+1, 1 ), lda )
                          end if
                       end if
                       ! convert ipiv
                       ! there is cone interchange of rows i+1 and ipiv(i+1),
                       ! so this should be recorded in consecutive entries
                       ! in ipiv format for *sytrf
                       ipiv( i ) = ipiv( i+1 )
                    end if
                    i = i - 1
                 end do
                 ! revert value
                 ! assign subdiagonal entries of d from array e to
                 ! subgiagonal entries of a.
                 i = 1
                 do while ( i<=n-1 )
                    if( ipiv( i )<0 ) then
                       a( i + 1, i ) = e( i )
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              end if
              ! end a is lower
           end if
           return
     end subroutine stdlib_${ci}$syconvf

#:endif
#:endfor



     module pure subroutine stdlib_chetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
     !! CHETRF_ROOK computes the factorization of a complex Hermitian matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
     !! The form of the factorization is
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'CHETRF_ROOK', uplo, n, -1, -1, -1 )
              lwkopt = max( 1, n*nb )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRF_ROOK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'CHETRF_ROOK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clahef_rook;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_clahef_rook( uplo, k, nb, kb, a, lda,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_chetf2_rook( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clahef_rook;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_clahef_rook( uplo, n-k+1, nb, kb, a( k, k ), lda,ipiv( k ), work, &
                           ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_chetf2_rook( uplo, n-k+1, a( k, k ), lda, ipiv( k ),iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chetrf_rook

     module pure subroutine stdlib_zhetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
     !! ZHETRF_ROOK computes the factorization of a complex Hermitian matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
     !! The form of the factorization is
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'ZHETRF_ROOK', uplo, n, -1, -1, -1 )
              lwkopt = max( 1, n*nb )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRF_ROOK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'ZHETRF_ROOK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_zlahef_rook;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_zlahef_rook( uplo, k, nb, kb, a, lda,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_zhetf2_rook( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_zlahef_rook;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_zlahef_rook( uplo, n-k+1, nb, kb, a( k, k ), lda,ipiv( k ), work, &
                           ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_zhetf2_rook( uplo, n-k+1, a( k, k ), lda, ipiv( k ),iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zhetrf_rook

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
     !! ZHETRF_ROOK: computes the factorization of a complex Hermitian matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method.
     !! The form of the factorization is
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'ZHETRF_ROOK', uplo, n, -1, -1, -1 )
              lwkopt = max( 1, n*nb )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRF_ROOK', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'ZHETRF_ROOK',uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ci}$lahef_rook;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_${ci}$lahef_rook( uplo, k, nb, kb, a, lda,ipiv, work, ldwork, iinfo )
                           
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_${ci}$hetf2_rook( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! no need to adjust ipiv
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ci}$lahef_rook;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_${ci}$lahef_rook( uplo, n-k+1, nb, kb, a( k, k ), lda,ipiv( k ), work, &
                           ldwork, iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_${ci}$hetf2_rook( uplo, n-k+1, a( k, k ), lda, ipiv( k ),iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$hetrf_rook

#:endif
#:endfor





     module pure subroutine stdlib_ssyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr, &
     !! SSYRFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric indefinite, and
     !! provides error bounds and backward error estimates for the solution.
               berr, work, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(in) :: a(lda,*), af(ldaf,*), b(ldb,*)
           real(sp), intent(out) :: berr(*), ferr(*), work(*)
           real(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, j, k, kase, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin, xk
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldaf<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldx<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_scopy( n, b( 1, j ), 1, work( n+1 ), 1 )
              call stdlib_ssymv( uplo, n, -one, a, lda, x( 1, j ), 1, one,work( n+1 ), 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 work( i ) = abs( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    do i = 1, k - 1
                       work( i ) = work( i ) + abs( a( i, k ) )*xk
                       s = s + abs( a( i, k ) )*abs( x( i, j ) )
                    end do
                    work( k ) = work( k ) + abs( a( k, k ) )*xk + s
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    work( k ) = work( k ) + abs( a( k, k ) )*xk
                    do i = k + 1, n
                       work( i ) = work( i ) + abs( a( i, k ) )*xk
                       s = s + abs( a( i, k ) )*abs( x( i, j ) )
                    end do
                    work( k ) = work( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( work( i )>safe2 ) then
                    s = max( s, abs( work( n+i ) ) / work( i ) )
                 else
                    s = max( s, ( abs( work( n+i ) )+safe1 ) /( work( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_ssytrs( uplo, n, 1, af, ldaf, ipiv, work( n+1 ), n,info )
                 call stdlib_saxpy( n, one, work( n+1 ), 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_slacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( work( i )>safe2 ) then
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i )
                 else
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i ) + safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_slacn2( n, work( 2*n+1 ), work( n+1 ), iwork, ferr( j ),kase, isave )
                        
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_ssytrs( uplo, n, 1, af, ldaf, ipiv, work( n+1 ), n,info )
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                    call stdlib_ssytrs( uplo, n, 1, af, ldaf, ipiv, work( n+1 ), n,info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_ssyrfs

     module pure subroutine stdlib_dsyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr, &
     !! DSYRFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric indefinite, and
     !! provides error bounds and backward error estimates for the solution.
               berr, work, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(in) :: a(lda,*), af(ldaf,*), b(ldb,*)
           real(dp), intent(out) :: berr(*), ferr(*), work(*)
           real(dp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, j, k, kase, nz
           real(dp) :: eps, lstres, s, safe1, safe2, safmin, xk
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldaf<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldx<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_dlamch( 'EPSILON' )
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_dcopy( n, b( 1, j ), 1, work( n+1 ), 1 )
              call stdlib_dsymv( uplo, n, -one, a, lda, x( 1, j ), 1, one,work( n+1 ), 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 work( i ) = abs( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    do i = 1, k - 1
                       work( i ) = work( i ) + abs( a( i, k ) )*xk
                       s = s + abs( a( i, k ) )*abs( x( i, j ) )
                    end do
                    work( k ) = work( k ) + abs( a( k, k ) )*xk + s
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    work( k ) = work( k ) + abs( a( k, k ) )*xk
                    do i = k + 1, n
                       work( i ) = work( i ) + abs( a( i, k ) )*xk
                       s = s + abs( a( i, k ) )*abs( x( i, j ) )
                    end do
                    work( k ) = work( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( work( i )>safe2 ) then
                    s = max( s, abs( work( n+i ) ) / work( i ) )
                 else
                    s = max( s, ( abs( work( n+i ) )+safe1 ) /( work( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_dsytrs( uplo, n, 1, af, ldaf, ipiv, work( n+1 ), n,info )
                 call stdlib_daxpy( n, one, work( n+1 ), 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_dlacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( work( i )>safe2 ) then
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i )
                 else
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i ) + safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_dlacn2( n, work( 2*n+1 ), work( n+1 ), iwork, ferr( j ),kase, isave )
                        
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_dsytrs( uplo, n, 1, af, ldaf, ipiv, work( n+1 ), n,info )
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                    call stdlib_dsytrs( uplo, n, 1, af, ldaf, ipiv, work( n+1 ), n,info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_dsyrfs

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$syrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr, &
     !! DSYRFS: improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric indefinite, and
     !! provides error bounds and backward error estimates for the solution.
               berr, work, iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), af(ldaf,*), b(ldb,*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*)
           real(${rk}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, j, k, kase, nz
           real(${rk}$) :: eps, lstres, s, safe1, safe2, safmin, xk
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldaf<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldx<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_${ri}$copy( n, b( 1, j ), 1, work( n+1 ), 1 )
              call stdlib_${ri}$symv( uplo, n, -one, a, lda, x( 1, j ), 1, one,work( n+1 ), 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 work( i ) = abs( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    do i = 1, k - 1
                       work( i ) = work( i ) + abs( a( i, k ) )*xk
                       s = s + abs( a( i, k ) )*abs( x( i, j ) )
                    end do
                    work( k ) = work( k ) + abs( a( k, k ) )*xk + s
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = abs( x( k, j ) )
                    work( k ) = work( k ) + abs( a( k, k ) )*xk
                    do i = k + 1, n
                       work( i ) = work( i ) + abs( a( i, k ) )*xk
                       s = s + abs( a( i, k ) )*abs( x( i, j ) )
                    end do
                    work( k ) = work( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( work( i )>safe2 ) then
                    s = max( s, abs( work( n+i ) ) / work( i ) )
                 else
                    s = max( s, ( abs( work( n+i ) )+safe1 ) /( work( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_${ri}$sytrs( uplo, n, 1, af, ldaf, ipiv, work( n+1 ), n,info )
                 call stdlib_${ri}$axpy( n, one, work( n+1 ), 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_${ri}$lacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( work( i )>safe2 ) then
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i )
                 else
                    work( i ) = abs( work( n+i ) ) + nz*eps*work( i ) + safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_${ri}$lacn2( n, work( 2*n+1 ), work( n+1 ), iwork, ferr( j ),kase, isave )
                        
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_${ri}$sytrs( uplo, n, 1, af, ldaf, ipiv, work( n+1 ), n,info )
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( n+i ) = work( i )*work( n+i )
                    end do
                    call stdlib_${ri}$sytrs( uplo, n, 1, af, ldaf, ipiv, work( n+1 ), n,info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, abs( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_${ri}$syrfs

#:endif
#:endfor

     module pure subroutine stdlib_csyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr, &
     !! CSYRFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric indefinite, and
     !! provides error bounds and backward error estimates for the solution.
               berr, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, j, k, kase, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldaf<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldx<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_ccopy( n, b( 1, j ), 1, work, 1 )
              call stdlib_csymv( uplo, n, -cone, a, lda, x( 1, j ), 1, cone, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    do i = 1, k - 1
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + cabs1( a( k, k ) )*xk + s
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + cabs1( a( k, k ) )*xk
                    do i = k + 1, n
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_csytrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                 call stdlib_caxpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_clacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_clacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_csytrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_csytrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_csyrfs

     module pure subroutine stdlib_zsyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr, &
     !! ZSYRFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric indefinite, and
     !! provides error bounds and backward error estimates for the solution.
               berr, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(dp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(dp), intent(in) :: a(lda,*), af(ldaf,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
           complex(dp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, j, k, kase, nz
           real(dp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(dp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=dp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldaf<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldx<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_dlamch( 'EPSILON' )
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_zcopy( n, b( 1, j ), 1, work, 1 )
              call stdlib_zsymv( uplo, n, -cone, a, lda, x( 1, j ), 1, cone, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    do i = 1, k - 1
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + cabs1( a( k, k ) )*xk + s
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + cabs1( a( k, k ) )*xk
                    do i = k + 1, n
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_zsytrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                 call stdlib_zaxpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_zlacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_zlacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_zsytrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_zsytrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_zsyrfs

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$syrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb,x, ldx, ferr, &
     !! ZSYRFS: improves the computed solution to a system of linear
     !! equations when the coefficient matrix is symmetric indefinite, and
     !! provides error bounds and backward error estimates for the solution.
               berr, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${ck}$), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(${ck}$), intent(in) :: a(lda,*), af(ldaf,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, j, k, kase, nz
           real(${ck}$) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(${ck}$) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=${ck}$) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldaf<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -10
           else if( ldx<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_${c2ri(ci)}$lamch( 'EPSILON' )
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_${ci}$copy( n, b( 1, j ), 1, work, 1 )
              call stdlib_${ci}$symv( uplo, n, -cone, a, lda, x( 1, j ), 1, cone, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    do i = 1, k - 1
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + cabs1( a( k, k ) )*xk + s
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + cabs1( a( k, k ) )*xk
                    do i = k + 1, n
                       rwork( i ) = rwork( i ) + cabs1( a( i, k ) )*xk
                       s = s + cabs1( a( i, k ) )*cabs1( x( i, j ) )
                    end do
                    rwork( k ) = rwork( k ) + s
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_${ci}$sytrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                 call stdlib_${ci}$axpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_${ci}$lacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_${ci}$lacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**t).
                    call stdlib_${ci}$sytrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_${ci}$sytrs( uplo, n, 1, af, ldaf, ipiv, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_${ci}$syrfs

#:endif
#:endfor



     module pure subroutine stdlib_chetrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
     !! CHETRF_AA computes the factorization of a complex hermitian matrix A
     !! using the Aasen's algorithm.  The form of the factorization is
     !! A = U**H*T*U  or  A = L*T*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is a hermitian tridiagonal matrix.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, lda, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: j, lwkopt
           integer(ilp) :: nb, mj, nj, k1, k2, j1, j2, j3, jb
           complex(sp) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! determine the block size
           nb = stdlib_ilaenv( 1, 'CHETRF_AA', uplo, n, -1, -1, -1 )
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<( 2*n ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              lwkopt = (nb+1)*n
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRF_AA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return
           if ( n==0 ) then
               return
           endif
           ipiv( 1 ) = 1
           if ( n==1 ) then
              a( 1, 1 ) = real( a( 1, 1 ),KIND=sp)
              return
           end if
           ! adjust block size based on the workspace size
           if( lwork<((1+nb)*n) ) then
              nb = ( lwork-n ) / n
           end if
           if( upper ) then
              ! .....................................................
              ! factorize a as u**h*d*u using the upper triangle of a
              ! .....................................................
              ! copy first row a(1, 1:n) into h(1:n) (stored in work(1:n))
              call stdlib_ccopy( n, a( 1, 1 ), lda, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_clahef;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              10 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j + 1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_clahef_aa( uplo, 2-k1, n-j, jb,a( max(1, j), j+1 ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_cswap( j1-k1-2, a( 1, j2 ), 1,a( 1, ipiv(j2) ), 1 )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
               ! the row a(j1-1, j2-1:n) stores u(j1, j2+1:n) and
               ! work stores the current block of the auxiriarly matrix h
              if( j<n ) then
                ! if the first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = conjg( a( j, j+1 ) )
                    a( j, j+1 ) = cone
                    call stdlib_ccopy( n-j, a( j-1, j+1 ), lda,work( (j+1-j1+1)+jb*n ), 1 )
                              
                    call stdlib_cscal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=0 and k2=1 for the first panel,
                     ! and k1=1 and k2=0 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_cgemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_cgemm( 'CONJUGATE TRANSPOSE', 'TRANSPOSE',1, mj, jb+1,-cone,&
                           a( j1-k2, j3 ), lda,work( (j3-j1+1)+k1*n ), n,cone, a( j3, j3 ), lda )
                                     
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block of j2-th block row with stdlib_cgemm
                       call stdlib_cgemm( 'CONJUGATE TRANSPOSE', 'TRANSPOSE',nj, n-j3+1, jb+1,-&
                       cone, a( j1-k2, j2 ), lda,work( (j3-j1+1)+k1*n ), n,cone, a( j2, j3 ), lda &
                                 )
                    end do
                    ! recover t( j, j+1 )
                    a( j, j+1 ) = conjg( alpha )
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_ccopy( n-j, a( j+1, j+1 ), lda, work( 1 ), 1 )
              end if
              go to 10
           else
              ! .....................................................
              ! factorize a as l*d*l**h using the lower triangle of a
              ! .....................................................
              ! copy first column a(1:n, 1) into h(1:n, 1)
               ! (stored in work(1:n))
              call stdlib_ccopy( n, a( 1, 1 ), 1, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_clahef;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              11 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j+1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_clahef_aa( uplo, 2-k1, n-j, jb,a( j+1, max(1, j) ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_cswap( j1-k1-2, a( j2, 1 ), lda,a( ipiv(j2), 1 ), lda )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
                ! a(j2+1, j1-1) stores l(j2+1, j1) and
                ! work(j2+1, 1) stores h(j2+1, 1)
              if( j<n ) then
                ! if the first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = conjg( a( j+1, j ) )
                    a( j+1, j ) = cone
                    call stdlib_ccopy( n-j, a( j+1, j-1 ), 1,work( (j+1-j1+1)+jb*n ), 1 )
                    call stdlib_cscal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=0 and k2=1 for the first panel,
                     ! and k1=1 and k2=0 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_cgemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',mj, 1, jb+1,-&
                          cone, work( (j3-j1+1)+k1*n ), n,a( j3, j1-k2 ), lda,cone, a( j3, j3 ), &
                                    lda )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block of j2-th block column with stdlib_cgemm
                       call stdlib_cgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',n-j3+1, nj, jb+1,-&
                       cone, work( (j3-j1+1)+k1*n ), n,a( j2, j1-k2 ), lda,cone, a( j3, j2 ), lda &
                                 )
                    end do
                    ! recover t( j+1, j )
                    a( j+1, j ) = conjg( alpha )
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_ccopy( n-j, a( j+1, j+1 ), 1, work( 1 ), 1 )
              end if
              go to 11
           end if
           20 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chetrf_aa

     module pure subroutine stdlib_zhetrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
     !! ZHETRF_AA computes the factorization of a complex hermitian matrix A
     !! using the Aasen's algorithm.  The form of the factorization is
     !! A = U**H*T*U  or  A = L*T*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is a hermitian tridiagonal matrix.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, lda, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: j, lwkopt
           integer(ilp) :: nb, mj, nj, k1, k2, j1, j2, j3, jb
           complex(dp) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! determine the block size
           nb = stdlib_ilaenv( 1, 'ZHETRF_AA', uplo, n, -1, -1, -1 )
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              lwkopt = (nb+1)*n
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRF_AA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return
           if ( n==0 ) then
               return
           endif
           ipiv( 1 ) = 1
           if ( n==1 ) then
              a( 1, 1 ) = real( a( 1, 1 ),KIND=dp)
              return
           end if
           ! adjust block size based on the workspace size
           if( lwork<((1+nb)*n) ) then
              nb = ( lwork-n ) / n
           end if
           if( upper ) then
              ! .....................................................
              ! factorize a as u**h*d*u using the upper triangle of a
              ! .....................................................
              ! copy first row a(1, 1:n) into h(1:n) (stored in work(1:n))
              call stdlib_zcopy( n, a( 1, 1 ), lda, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_zlahef;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              10 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j + 1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_zlahef_aa( uplo, 2-k1, n-j, jb,a( max(1, j), j+1 ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_zswap( j1-k1-2, a( 1, j2 ), 1,a( 1, ipiv(j2) ), 1 )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
               ! the row a(j1-1, j2-1:n) stores u(j1, j2+1:n) and
               ! work stores the current block of the auxiriarly matrix h
              if( j<n ) then
                ! if the first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = conjg( a( j, j+1 ) )
                    a( j, j+1 ) = cone
                    call stdlib_zcopy( n-j, a( j-1, j+1 ), lda,work( (j+1-j1+1)+jb*n ), 1 )
                              
                    call stdlib_zscal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=0 and k2=1 for the first panel,
                     ! and k1=1 and k2=0 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_zgemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_zgemm( 'CONJUGATE TRANSPOSE', 'TRANSPOSE',1, mj, jb+1,-cone,&
                           a( j1-k2, j3 ), lda,work( (j3-j1+1)+k1*n ), n,cone, a( j3, j3 ), lda )
                                     
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block of j2-th block row with stdlib_zgemm
                       call stdlib_zgemm( 'CONJUGATE TRANSPOSE', 'TRANSPOSE',nj, n-j3+1, jb+1,-&
                       cone, a( j1-k2, j2 ), lda,work( (j3-j1+1)+k1*n ), n,cone, a( j2, j3 ), lda &
                                 )
                    end do
                    ! recover t( j, j+1 )
                    a( j, j+1 ) = conjg( alpha )
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_zcopy( n-j, a( j+1, j+1 ), lda, work( 1 ), 1 )
              end if
              go to 10
           else
              ! .....................................................
              ! factorize a as l*d*l**h using the lower triangle of a
              ! .....................................................
              ! copy first column a(1:n, 1) into h(1:n, 1)
               ! (stored in work(1:n))
              call stdlib_zcopy( n, a( 1, 1 ), 1, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_zlahef;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              11 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j+1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_zlahef_aa( uplo, 2-k1, n-j, jb,a( j+1, max(1, j) ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_zswap( j1-k1-2, a( j2, 1 ), lda,a( ipiv(j2), 1 ), lda )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
                ! a(j2+1, j1-1) stores l(j2+1, j1) and
                ! work(j2+1, 1) stores h(j2+1, 1)
              if( j<n ) then
                ! if the first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = conjg( a( j+1, j ) )
                    a( j+1, j ) = cone
                    call stdlib_zcopy( n-j, a( j+1, j-1 ), 1,work( (j+1-j1+1)+jb*n ), 1 )
                    call stdlib_zscal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=0 and k2=1 for the first panel,
                     ! and k1=1 and k2=0 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_zgemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_zgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',mj, 1, jb+1,-&
                          cone, work( (j3-j1+1)+k1*n ), n,a( j3, j1-k2 ), lda,cone, a( j3, j3 ), &
                                    lda )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block of j2-th block column with stdlib_zgemm
                       call stdlib_zgemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',n-j3+1, nj, jb+1,-&
                       cone, work( (j3-j1+1)+k1*n ), n,a( j2, j1-k2 ), lda,cone, a( j3, j2 ), lda &
                                 )
                    end do
                    ! recover t( j+1, j )
                    a( j+1, j ) = conjg( alpha )
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_zcopy( n-j, a( j+1, j+1 ), 1, work( 1 ), 1 )
              end if
              go to 11
           end if
           20 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zhetrf_aa

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hetrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
     !! ZHETRF_AA: computes the factorization of a complex hermitian matrix A
     !! using the Aasen's algorithm.  The form of the factorization is
     !! A = U**H*T*U  or  A = L*T*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is a hermitian tridiagonal matrix.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, lda, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: j, lwkopt
           integer(ilp) :: nb, mj, nj, k1, k2, j1, j2, j3, jb
           complex(${ck}$) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! determine the block size
           nb = stdlib_ilaenv( 1, 'ZHETRF_AA', uplo, n, -1, -1, -1 )
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              lwkopt = (nb+1)*n
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRF_AA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return
           if ( n==0 ) then
               return
           endif
           ipiv( 1 ) = 1
           if ( n==1 ) then
              a( 1, 1 ) = real( a( 1, 1 ),KIND=${ck}$)
              return
           end if
           ! adjust block size based on the workspace size
           if( lwork<((1+nb)*n) ) then
              nb = ( lwork-n ) / n
           end if
           if( upper ) then
              ! .....................................................
              ! factorize a as u**h*d*u using the upper triangle of a
              ! .....................................................
              ! copy first row a(1, 1:n) into h(1:n) (stored in work(1:n))
              call stdlib_${ci}$copy( n, a( 1, 1 ), lda, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_${ci}$lahef;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              10 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j + 1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_${ci}$lahef_aa( uplo, 2-k1, n-j, jb,a( max(1, j), j+1 ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_${ci}$swap( j1-k1-2, a( 1, j2 ), 1,a( 1, ipiv(j2) ), 1 )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
               ! the row a(j1-1, j2-1:n) stores u(j1, j2+1:n) and
               ! work stores the current block of the auxiriarly matrix h
              if( j<n ) then
                ! if the first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = conjg( a( j, j+1 ) )
                    a( j, j+1 ) = cone
                    call stdlib_${ci}$copy( n-j, a( j-1, j+1 ), lda,work( (j+1-j1+1)+jb*n ), 1 )
                              
                    call stdlib_${ci}$scal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=0 and k2=1 for the first panel,
                     ! and k1=1 and k2=0 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_${ci}$gemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_${ci}$gemm( 'CONJUGATE TRANSPOSE', 'TRANSPOSE',1, mj, jb+1,-cone,&
                           a( j1-k2, j3 ), lda,work( (j3-j1+1)+k1*n ), n,cone, a( j3, j3 ), lda )
                                     
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block of j2-th block row with stdlib_${ci}$gemm
                       call stdlib_${ci}$gemm( 'CONJUGATE TRANSPOSE', 'TRANSPOSE',nj, n-j3+1, jb+1,-&
                       cone, a( j1-k2, j2 ), lda,work( (j3-j1+1)+k1*n ), n,cone, a( j2, j3 ), lda &
                                 )
                    end do
                    ! recover t( j, j+1 )
                    a( j, j+1 ) = conjg( alpha )
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_${ci}$copy( n-j, a( j+1, j+1 ), lda, work( 1 ), 1 )
              end if
              go to 10
           else
              ! .....................................................
              ! factorize a as l*d*l**h using the lower triangle of a
              ! .....................................................
              ! copy first column a(1:n, 1) into h(1:n, 1)
               ! (stored in work(1:n))
              call stdlib_${ci}$copy( n, a( 1, 1 ), 1, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_${ci}$lahef;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              11 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j+1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_${ci}$lahef_aa( uplo, 2-k1, n-j, jb,a( j+1, max(1, j) ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_${ci}$swap( j1-k1-2, a( j2, 1 ), lda,a( ipiv(j2), 1 ), lda )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
                ! a(j2+1, j1-1) stores l(j2+1, j1) and
                ! work(j2+1, 1) stores h(j2+1, 1)
              if( j<n ) then
                ! if the first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = conjg( a( j+1, j ) )
                    a( j+1, j ) = cone
                    call stdlib_${ci}$copy( n-j, a( j+1, j-1 ), 1,work( (j+1-j1+1)+jb*n ), 1 )
                    call stdlib_${ci}$scal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=0 and k2=1 for the first panel,
                     ! and k1=1 and k2=0 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_${ci}$gemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',mj, 1, jb+1,-&
                          cone, work( (j3-j1+1)+k1*n ), n,a( j3, j1-k2 ), lda,cone, a( j3, j3 ), &
                                    lda )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block of j2-th block column with stdlib_${ci}$gemm
                       call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'CONJUGATE TRANSPOSE',n-j3+1, nj, jb+1,-&
                       cone, work( (j3-j1+1)+k1*n ), n,a( j2, j1-k2 ), lda,cone, a( j3, j2 ), lda &
                                 )
                    end do
                    ! recover t( j+1, j )
                    a( j+1, j ) = conjg( alpha )
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_${ci}$copy( n-j, a( j+1, j+1 ), 1, work( 1 ), 1 )
              end if
              go to 11
           end if
           20 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$hetrf_aa

#:endif
#:endfor



     module pure subroutine stdlib_cheequb( uplo, n, a, lda, s, scond, amax, work, info )
     !! CHEEQUB computes row and column scalings intended to equilibrate a
     !! Hermitian matrix A (with respect to the Euclidean norm) and reduce
     !! its condition number. The scale factors S are computed by the BIN
     !! algorithm (see references) so that the scaled matrix B with elements
     !! B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
     !! the smallest possible condition number over all possible diagonal
     !! scalings.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(out) :: amax, scond
           character, intent(in) :: uplo
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
           real(sp), intent(out) :: s(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: max_iter = 100
           
           
           ! Local Scalars 
           integer(ilp) :: i, j, iter
           real(sp) :: avg, std, tol, c0, c1, c2, t, u, si, d, base, smin, smax, smlnum, bignum, &
                     scale, sumsq
           logical(lk) :: up
           complex(sp) :: zdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if ( .not. ( stdlib_lsame( uplo, 'U' ) .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -1
           else if ( n < 0 ) then
              info = -2
           else if ( lda < max( 1, n ) ) then
              info = -4
           end if
           if ( info /= 0 ) then
              call stdlib_xerbla( 'CHEEQUB', -info )
              return
           end if
           up = stdlib_lsame( uplo, 'U' )
           amax = zero
           ! quick return if possible.
           if ( n == 0 ) then
              scond = one
              return
           end if
           do i = 1, n
              s( i ) = zero
           end do
           amax = zero
           if ( up ) then
              do j = 1, n
                 do i = 1, j-1
                    s( i ) = max( s( i ), cabs1( a( i, j ) ) )
                    s( j ) = max( s( j ), cabs1( a( i, j ) ) )
                    amax = max( amax, cabs1( a( i, j ) ) )
                 end do
                 s( j ) = max( s( j ), cabs1( a( j, j ) ) )
                 amax = max( amax, cabs1( a( j, j ) ) )
              end do
           else
              do j = 1, n
                 s( j ) = max( s( j ), cabs1( a( j, j ) ) )
                 amax = max( amax, cabs1( a( j, j ) ) )
                 do i = j+1, n
                    s( i ) = max( s( i ), cabs1( a( i, j ) ) )
                    s( j ) = max( s( j ), cabs1( a( i, j ) ) )
                    amax = max( amax, cabs1( a( i, j ) ) )
                 end do
              end do
           end if
           do j = 1, n
              s( j ) = 1.0_sp / s( j )
           end do
           tol = one / sqrt( 2.0_sp * n )
           do iter = 1, max_iter
              scale = zero
              sumsq = zero
              ! beta = |a|s
              do i = 1, n
                 work( i ) = zero
              end do
              if ( up ) then
                 do j = 1, n
                    do i = 1, j-1
                       work( i ) = work( i ) + cabs1( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + cabs1( a( i, j ) ) * s( i )
                    end do
                    work( j ) = work( j ) + cabs1( a( j, j ) ) * s( j )
                 end do
              else
                 do j = 1, n
                    work( j ) = work( j ) + cabs1( a( j, j ) ) * s( j )
                    do i = j+1, n
                       work( i ) = work( i ) + cabs1( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + cabs1( a( i, j ) ) * s( i )
                    end do
                 end do
              end if
              ! avg = s^t beta / n
              avg = zero
              do i = 1, n
                 avg = avg + real( s( i )*work( i ),KIND=sp)
              end do
              avg = avg / n
              std = zero
              do i = n+1, 2*n
                 work( i ) = s( i-n ) * work( i-n ) - avg
              end do
              call stdlib_classq( n, work( n+1 ), 1, scale, sumsq )
              std = scale * sqrt( sumsq / n )
              if ( std < tol * avg ) goto 999
              do i = 1, n
                 t = cabs1( a( i, i ) )
                 si = s( i )
                 c2 = ( n-1 ) * t
                 c1 = real( ( n-2 ) * ( work( i ) - t*si ),KIND=sp)
                 c0 = real( -(t*si)*si + 2*work( i )*si - n*avg,KIND=sp)
                 d = c1*c1 - 4*c0*c2
                 if ( d <= 0 ) then
                    info = -1
                    return
                 end if
                 si = -2*c0 / ( c1 + sqrt( d ) )
                 d = si - s( i )
                 u = zero
                 if ( up ) then
                    do j = 1, i
                       t = cabs1( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = cabs1( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 else
                    do j = 1, i
                       t = cabs1( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = cabs1( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 end if
                 avg = avg + real( ( u + work( i ) ) * d / n,KIND=sp)
                 s( i ) = si
              end do
           end do
           999 continue
           smlnum = stdlib_slamch( 'SAFEMIN' )
           bignum = one / smlnum
           smin = bignum
           smax = zero
           t = one / sqrt( avg )
           base = stdlib_slamch( 'B' )
           u = one / log( base )
           do i = 1, n
              s( i ) = base ** int( u * log( s( i ) * t ),KIND=ilp)
              smin = min( smin, s( i ) )
              smax = max( smax, s( i ) )
           end do
           scond = max( smin, smlnum ) / min( smax, bignum )
     end subroutine stdlib_cheequb

     module pure subroutine stdlib_zheequb( uplo, n, a, lda, s, scond, amax, work, info )
     !! ZHEEQUB computes row and column scalings intended to equilibrate a
     !! Hermitian matrix A (with respect to the Euclidean norm) and reduce
     !! its condition number. The scale factors S are computed by the BIN
     !! algorithm (see references) so that the scaled matrix B with elements
     !! B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
     !! the smallest possible condition number over all possible diagonal
     !! scalings.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(dp), intent(out) :: amax, scond
           character, intent(in) :: uplo
           ! Array Arguments 
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(out) :: work(*)
           real(dp), intent(out) :: s(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: max_iter = 100
           
           
           ! Local Scalars 
           integer(ilp) :: i, j, iter
           real(dp) :: avg, std, tol, c0, c1, c2, t, u, si, d, base, smin, smax, smlnum, bignum, &
                     scale, sumsq
           logical(lk) :: up
           complex(dp) :: zdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=dp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if ( .not. ( stdlib_lsame( uplo, 'U' ) .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -1
           else if ( n < 0 ) then
              info = -2
           else if ( lda < max( 1, n ) ) then
              info = -4
           end if
           if ( info /= 0 ) then
              call stdlib_xerbla( 'ZHEEQUB', -info )
              return
           end if
           up = stdlib_lsame( uplo, 'U' )
           amax = zero
           ! quick return if possible.
           if ( n == 0 ) then
              scond = one
              return
           end if
           do i = 1, n
              s( i ) = zero
           end do
           amax = zero
           if ( up ) then
              do j = 1, n
                 do i = 1, j-1
                    s( i ) = max( s( i ), cabs1( a( i, j ) ) )
                    s( j ) = max( s( j ), cabs1( a( i, j ) ) )
                    amax = max( amax, cabs1( a( i, j ) ) )
                 end do
                 s( j ) = max( s( j ), cabs1( a( j, j ) ) )
                 amax = max( amax, cabs1( a( j, j ) ) )
              end do
           else
              do j = 1, n
                 s( j ) = max( s( j ), cabs1( a( j, j ) ) )
                 amax = max( amax, cabs1( a( j, j ) ) )
                 do i = j+1, n
                    s( i ) = max( s( i ), cabs1( a( i, j ) ) )
                    s( j ) = max( s( j ), cabs1( a( i, j ) ) )
                    amax = max( amax, cabs1( a( i, j ) ) )
                 end do
              end do
           end if
           do j = 1, n
              s( j ) = 1.0_dp / s( j )
           end do
           tol = one / sqrt( 2.0_dp * n )
           do iter = 1, max_iter
              scale = zero
              sumsq = zero
              ! beta = |a|s
              do i = 1, n
                 work( i ) = zero
              end do
              if ( up ) then
                 do j = 1, n
                    do i = 1, j-1
                       work( i ) = work( i ) + cabs1( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + cabs1( a( i, j ) ) * s( i )
                    end do
                    work( j ) = work( j ) + cabs1( a( j, j ) ) * s( j )
                 end do
              else
                 do j = 1, n
                    work( j ) = work( j ) + cabs1( a( j, j ) ) * s( j )
                    do i = j+1, n
                       work( i ) = work( i ) + cabs1( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + cabs1( a( i, j ) ) * s( i )
                    end do
                 end do
              end if
              ! avg = s^t beta / n
              avg = zero
              do i = 1, n
                 avg = avg + real( s( i )*work( i ),KIND=dp)
              end do
              avg = avg / n
              std = zero
              do i = n+1, 2*n
                 work( i ) = s( i-n ) * work( i-n ) - avg
              end do
              call stdlib_zlassq( n, work( n+1 ), 1, scale, sumsq )
              std = scale * sqrt( sumsq / n )
              if ( std < tol * avg ) goto 999
              do i = 1, n
                 t = cabs1( a( i, i ) )
                 si = s( i )
                 c2 = ( n-1 ) * t
                 c1 = ( n-2 ) * ( real( work( i ),KIND=dp) - t*si )
                 c0 = -(t*si)*si + 2 * real( work( i ),KIND=dp) * si - n*avg
                 d = c1*c1 - 4*c0*c2
                 if ( d <= 0 ) then
                    info = -1
                    return
                 end if
                 si = -2*c0 / ( c1 + sqrt( d ) )
                 d = si - s( i )
                 u = zero
                 if ( up ) then
                    do j = 1, i
                       t = cabs1( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = cabs1( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 else
                    do j = 1, i
                       t = cabs1( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = cabs1( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 end if
                 avg = avg + ( u + real( work( i ),KIND=dp) ) * d / n
                 s( i ) = si
              end do
           end do
           999 continue
           smlnum = stdlib_dlamch( 'SAFEMIN' )
           bignum = one / smlnum
           smin = bignum
           smax = zero
           t = one / sqrt( avg )
           base = stdlib_dlamch( 'B' )
           u = one / log( base )
           do i = 1, n
              s( i ) = base ** int( u * log( s( i ) * t ),KIND=ilp)
              smin = min( smin, s( i ) )
              smax = max( smax, s( i ) )
           end do
           scond = max( smin, smlnum ) / min( smax, bignum )
     end subroutine stdlib_zheequb

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$heequb( uplo, n, a, lda, s, scond, amax, work, info )
     !! ZHEEQUB: computes row and column scalings intended to equilibrate a
     !! Hermitian matrix A (with respect to the Euclidean norm) and reduce
     !! its condition number. The scale factors S are computed by the BIN
     !! algorithm (see references) so that the scaled matrix B with elements
     !! B(i,j) = S(i)*A(i,j)*S(j) has a condition number within a factor N of
     !! the smallest possible condition number over all possible diagonal
     !! scalings.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(${ck}$), intent(out) :: amax, scond
           character, intent(in) :: uplo
           ! Array Arguments 
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*)
           real(${ck}$), intent(out) :: s(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: max_iter = 100
           
           
           ! Local Scalars 
           integer(ilp) :: i, j, iter
           real(${ck}$) :: avg, std, tol, c0, c1, c2, t, u, si, d, base, smin, smax, smlnum, bignum, &
                     scale, sumsq
           logical(lk) :: up
           complex(${ck}$) :: zdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=${ck}$) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if ( .not. ( stdlib_lsame( uplo, 'U' ) .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -1
           else if ( n < 0 ) then
              info = -2
           else if ( lda < max( 1, n ) ) then
              info = -4
           end if
           if ( info /= 0 ) then
              call stdlib_xerbla( 'ZHEEQUB', -info )
              return
           end if
           up = stdlib_lsame( uplo, 'U' )
           amax = zero
           ! quick return if possible.
           if ( n == 0 ) then
              scond = one
              return
           end if
           do i = 1, n
              s( i ) = zero
           end do
           amax = zero
           if ( up ) then
              do j = 1, n
                 do i = 1, j-1
                    s( i ) = max( s( i ), cabs1( a( i, j ) ) )
                    s( j ) = max( s( j ), cabs1( a( i, j ) ) )
                    amax = max( amax, cabs1( a( i, j ) ) )
                 end do
                 s( j ) = max( s( j ), cabs1( a( j, j ) ) )
                 amax = max( amax, cabs1( a( j, j ) ) )
              end do
           else
              do j = 1, n
                 s( j ) = max( s( j ), cabs1( a( j, j ) ) )
                 amax = max( amax, cabs1( a( j, j ) ) )
                 do i = j+1, n
                    s( i ) = max( s( i ), cabs1( a( i, j ) ) )
                    s( j ) = max( s( j ), cabs1( a( i, j ) ) )
                    amax = max( amax, cabs1( a( i, j ) ) )
                 end do
              end do
           end if
           do j = 1, n
              s( j ) = 1.0_${ck}$ / s( j )
           end do
           tol = one / sqrt( 2.0_${ck}$ * n )
           do iter = 1, max_iter
              scale = zero
              sumsq = zero
              ! beta = |a|s
              do i = 1, n
                 work( i ) = zero
              end do
              if ( up ) then
                 do j = 1, n
                    do i = 1, j-1
                       work( i ) = work( i ) + cabs1( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + cabs1( a( i, j ) ) * s( i )
                    end do
                    work( j ) = work( j ) + cabs1( a( j, j ) ) * s( j )
                 end do
              else
                 do j = 1, n
                    work( j ) = work( j ) + cabs1( a( j, j ) ) * s( j )
                    do i = j+1, n
                       work( i ) = work( i ) + cabs1( a( i, j ) ) * s( j )
                       work( j ) = work( j ) + cabs1( a( i, j ) ) * s( i )
                    end do
                 end do
              end if
              ! avg = s^t beta / n
              avg = zero
              do i = 1, n
                 avg = avg + real( s( i )*work( i ),KIND=${ck}$)
              end do
              avg = avg / n
              std = zero
              do i = n+1, 2*n
                 work( i ) = s( i-n ) * work( i-n ) - avg
              end do
              call stdlib_${ci}$lassq( n, work( n+1 ), 1, scale, sumsq )
              std = scale * sqrt( sumsq / n )
              if ( std < tol * avg ) goto 999
              do i = 1, n
                 t = cabs1( a( i, i ) )
                 si = s( i )
                 c2 = ( n-1 ) * t
                 c1 = ( n-2 ) * ( real( work( i ),KIND=${ck}$) - t*si )
                 c0 = -(t*si)*si + 2 * real( work( i ),KIND=${ck}$) * si - n*avg
                 d = c1*c1 - 4*c0*c2
                 if ( d <= 0 ) then
                    info = -1
                    return
                 end if
                 si = -2*c0 / ( c1 + sqrt( d ) )
                 d = si - s( i )
                 u = zero
                 if ( up ) then
                    do j = 1, i
                       t = cabs1( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = cabs1( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 else
                    do j = 1, i
                       t = cabs1( a( i, j ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                    do j = i+1,n
                       t = cabs1( a( j, i ) )
                       u = u + s( j )*t
                       work( j ) = work( j ) + d*t
                    end do
                 end if
                 avg = avg + ( u + real( work( i ),KIND=${ck}$) ) * d / n
                 s( i ) = si
              end do
           end do
           999 continue
           smlnum = stdlib_${c2ri(ci)}$lamch( 'SAFEMIN' )
           bignum = one / smlnum
           smin = bignum
           smax = zero
           t = one / sqrt( avg )
           base = stdlib_${c2ri(ci)}$lamch( 'B' )
           u = one / log( base )
           do i = 1, n
              s( i ) = base ** int( u * log( s( i ) * t ),KIND=ilp)
              smin = min( smin, s( i ) )
              smax = max( smax, s( i ) )
           end do
           scond = max( smin, smlnum ) / min( smax, bignum )
     end subroutine stdlib_${ci}$heequb

#:endif
#:endfor



     module pure subroutine stdlib_ssytf2_rook( uplo, n, a, lda, ipiv, info )
     !! SSYTF2_ROOK computes the factorization of a real symmetric matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**T is the transpose of U, and D is symmetric and
     !! block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           ! Local Scalars 
           logical(lk) :: upper, done
           integer(ilp) :: i, imax, j, jmax, itemp, k, kk, kp, kstep, p, ii
           real(sp) :: absakk, alpha, colmax, d11, d12, d21, d22, rowmax, stemp, t, wk, wkm1, &
                     wkp1, sfmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYTF2_ROOK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_isamax( k-1, a( 1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange,
                    ! use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_isamax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = abs( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_isamax( imax-1, a( 1, imax ), 1 )
                          stemp = abs( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( abs( a( imax, imax ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the leading
                    ! submatrix a(1:k,1:k) if we have a 2-by-2 pivot
                    if( p>1 )call stdlib_sswap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    if( p<(k-1) )call stdlib_sswap( k-p-1, a( p+1, k ), 1, a( p, p+1 ),lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                 end if
                 ! second swap
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    if( kp>1 )call stdlib_sswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    if( ( kk>1 ) .and. ( kp<(kk-1) ) )call stdlib_sswap( kk-kp-1, a( kp+1, kk ), &
                              1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( abs( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = one / a( k, k )
                          call stdlib_ssyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_sscal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_ssyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = one / ( d11*d22-one )
                       do j = k - 2, 1, -1
                          wkm1 = t*( d11*a( j, k-1 )-a( j, k ) )
                          wk = t*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - (a( i, k ) / d12 )*wk -( a( i, k-1 ) / d12 )&
                                       *wkm1
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d12
                          a( j, k-1 ) = wkm1 / d12
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_isamax( n-k, a( k+1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_isamax( imax-k, a( imax, k ), lda )
                          rowmax = abs( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_isamax( n-imax, a( imax+1, imax ),1 )
                          stemp = abs( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( abs( a( imax, imax ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 42
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the trailing
                    ! submatrix a(k:n,k:n) if we have a 2-by-2 pivot
                    if( p<n )call stdlib_sswap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    if( p>(k+1) )call stdlib_sswap( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                 end if
                 ! second swap
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_sswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    if( ( kk<n ) .and. ( kp>(kk+1) ) )call stdlib_sswap( kp-kk-1, a( kk+1, kk ), &
                              1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                    ! perform a rank-1 update of a(k+1:n,k+1:n) and
                    ! store l(k) in column k
                       if( abs( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = one / a( k, k )
                          call stdlib_ssyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_sscal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_ssyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = one / ( d11*d22-one )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = t*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = t*( d22*a( j, k+1 )-a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) - ( a( i, k ) / d21 )*wk -( a( i, k+1 ) / d21 )&
                                       *wkp1
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d21
                          a( j, k+1 ) = wkp1 / d21
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_ssytf2_rook

     module pure subroutine stdlib_dsytf2_rook( uplo, n, a, lda, ipiv, info )
     !! DSYTF2_ROOK computes the factorization of a real symmetric matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**T is the transpose of U, and D is symmetric and
     !! block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           ! Local Scalars 
           logical(lk) :: upper, done
           integer(ilp) :: i, imax, j, jmax, itemp, k, kk, kp, kstep, p, ii
           real(dp) :: absakk, alpha, colmax, d11, d12, d21, d22, rowmax, dtemp, t, wk, wkm1, &
                     wkp1, sfmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTF2_ROOK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_dlamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_idamax( k-1, a( 1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange,
                    ! use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_idamax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = abs( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_idamax( imax-1, a( 1, imax ), 1 )
                          dtemp = abs( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( abs( a( imax, imax ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the leading
                    ! submatrix a(1:k,1:k) if we have a 2-by-2 pivot
                    if( p>1 )call stdlib_dswap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    if( p<(k-1) )call stdlib_dswap( k-p-1, a( p+1, k ), 1, a( p, p+1 ),lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                 end if
                 ! second swap
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    if( kp>1 )call stdlib_dswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    if( ( kk>1 ) .and. ( kp<(kk-1) ) )call stdlib_dswap( kk-kp-1, a( kp+1, kk ), &
                              1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( abs( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = one / a( k, k )
                          call stdlib_dsyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_dscal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_dsyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = one / ( d11*d22-one )
                       do j = k - 2, 1, -1
                          wkm1 = t*( d11*a( j, k-1 )-a( j, k ) )
                          wk = t*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - (a( i, k ) / d12 )*wk -( a( i, k-1 ) / d12 )&
                                       *wkm1
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d12
                          a( j, k-1 ) = wkm1 / d12
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_idamax( n-k, a( k+1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_idamax( imax-k, a( imax, k ), lda )
                          rowmax = abs( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_idamax( n-imax, a( imax+1, imax ),1 )
                          dtemp = abs( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( abs( a( imax, imax ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 42
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the trailing
                    ! submatrix a(k:n,k:n) if we have a 2-by-2 pivot
                    if( p<n )call stdlib_dswap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    if( p>(k+1) )call stdlib_dswap( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                 end if
                 ! second swap
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_dswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    if( ( kk<n ) .and. ( kp>(kk+1) ) )call stdlib_dswap( kp-kk-1, a( kk+1, kk ), &
                              1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                    ! perform a rank-1 update of a(k+1:n,k+1:n) and
                    ! store l(k) in column k
                       if( abs( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = one / a( k, k )
                          call stdlib_dsyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_dscal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_dsyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = one / ( d11*d22-one )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = t*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = t*( d22*a( j, k+1 )-a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) - ( a( i, k ) / d21 )*wk -( a( i, k+1 ) / d21 )&
                                       *wkp1
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d21
                          a( j, k+1 ) = wkp1 / d21
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_dsytf2_rook

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sytf2_rook( uplo, n, a, lda, ipiv, info )
     !! DSYTF2_ROOK: computes the factorization of a real symmetric matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**T is the transpose of U, and D is symmetric and
     !! block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sevten = 17.0e+0_${rk}$
           
           
           ! Local Scalars 
           logical(lk) :: upper, done
           integer(ilp) :: i, imax, j, jmax, itemp, k, kk, kp, kstep, p, ii
           real(${rk}$) :: absakk, alpha, colmax, d11, d12, d21, d22, rowmax, dtemp, t, wk, wkm1, &
                     wkp1, sfmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTF2_ROOK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_${ri}$lamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ri}$amax( k-1, a( 1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange,
                    ! use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_i${ri}$amax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = abs( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_i${ri}$amax( imax-1, a( 1, imax ), 1 )
                          dtemp = abs( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( abs( a( imax, imax ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the leading
                    ! submatrix a(1:k,1:k) if we have a 2-by-2 pivot
                    if( p>1 )call stdlib_${ri}$swap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    if( p<(k-1) )call stdlib_${ri}$swap( k-p-1, a( p+1, k ), 1, a( p, p+1 ),lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                 end if
                 ! second swap
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    if( kp>1 )call stdlib_${ri}$swap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    if( ( kk>1 ) .and. ( kp<(kk-1) ) )call stdlib_${ri}$swap( kk-kp-1, a( kp+1, kk ), &
                              1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( abs( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = one / a( k, k )
                          call stdlib_${ri}$syr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_${ri}$scal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_${ri}$syr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = one / ( d11*d22-one )
                       do j = k - 2, 1, -1
                          wkm1 = t*( d11*a( j, k-1 )-a( j, k ) )
                          wk = t*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - (a( i, k ) / d12 )*wk -( a( i, k-1 ) / d12 )&
                                       *wkm1
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d12
                          a( j, k-1 ) = wkm1 / d12
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ri}$amax( n-k, a( k+1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_i${ri}$amax( imax-k, a( imax, k ), lda )
                          rowmax = abs( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_i${ri}$amax( n-imax, a( imax+1, imax ),1 )
                          dtemp = abs( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( abs( a( imax, imax ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 42
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the trailing
                    ! submatrix a(k:n,k:n) if we have a 2-by-2 pivot
                    if( p<n )call stdlib_${ri}$swap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    if( p>(k+1) )call stdlib_${ri}$swap( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                 end if
                 ! second swap
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_${ri}$swap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    if( ( kk<n ) .and. ( kp>(kk+1) ) )call stdlib_${ri}$swap( kp-kk-1, a( kk+1, kk ), &
                              1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                    ! perform a rank-1 update of a(k+1:n,k+1:n) and
                    ! store l(k) in column k
                       if( abs( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = one / a( k, k )
                          call stdlib_${ri}$syr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_${ri}$scal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_${ri}$syr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = one / ( d11*d22-one )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = t*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = t*( d22*a( j, k+1 )-a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) - ( a( i, k ) / d21 )*wk -( a( i, k+1 ) / d21 )&
                                       *wkp1
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d21
                          a( j, k+1 ) = wkp1 / d21
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_${ri}$sytf2_rook

#:endif
#:endfor

     module pure subroutine stdlib_csytf2_rook( uplo, n, a, lda, ipiv, info )
     !! CSYTF2_ROOK computes the factorization of a complex symmetric matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**T is the transpose of U, and D is symmetric and
     !! block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: upper, done
           integer(ilp) :: i, imax, j, jmax, itemp, k, kk, kp, kstep, p, ii
           real(sp) :: absakk, alpha, colmax, rowmax, stemp, sfmin
           complex(sp) :: d11, d12, d21, d22, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTF2_ROOK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange,
                    ! use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_icamax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_icamax( imax-1, a( 1, imax ), 1 )
                          stemp = cabs1( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! cabs1( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( cabs1(a( imax, imax ))<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the leading
                    ! submatrix a(1:k,1:k) if we have a 2-by-2 pivot
                    if( p>1 )call stdlib_cswap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    if( p<(k-1) )call stdlib_cswap( k-p-1, a( p+1, k ), 1, a( p, p+1 ),lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                 end if
                 ! second swap
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    if( ( kk>1 ) .and. ( kp<(kk-1) ) )call stdlib_cswap( kk-kp-1, a( kp+1, kk ), &
                              1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = cone / a( k, k )
                          call stdlib_csyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_cscal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_csyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = cone / ( d11*d22-cone )
                       do j = k - 2, 1, -1
                          wkm1 = t*( d11*a( j, k-1 )-a( j, k ) )
                          wk = t*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - (a( i, k ) / d12 )*wk -( a( i, k-1 ) / d12 )&
                                       *wkm1
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d12
                          a( j, k-1 ) = wkm1 / d12
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_icamax( imax-k, a( imax, k ), lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_icamax( n-imax, a( imax+1, imax ),1 )
                          stemp = cabs1( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! cabs1( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( cabs1(a( imax, imax ))<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 42
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the trailing
                    ! submatrix a(k:n,k:n) if we have a 2-by-2 pivot
                    if( p<n )call stdlib_cswap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    if( p>(k+1) )call stdlib_cswap( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                 end if
                 ! second swap
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    if( ( kk<n ) .and. ( kp>(kk+1) ) )call stdlib_cswap( kp-kk-1, a( kk+1, kk ), &
                              1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                    ! perform a rank-1 update of a(k+1:n,k+1:n) and
                    ! store l(k) in column k
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = cone / a( k, k )
                          call stdlib_csyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_cscal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_csyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = t*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = t*( d22*a( j, k+1 )-a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) - ( a( i, k ) / d21 )*wk -( a( i, k+1 ) / d21 )&
                                       *wkp1
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d21
                          a( j, k+1 ) = wkp1 / d21
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_csytf2_rook

     module pure subroutine stdlib_zsytf2_rook( uplo, n, a, lda, ipiv, info )
     !! ZSYTF2_ROOK computes the factorization of a complex symmetric matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**T is the transpose of U, and D is symmetric and
     !! block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           
           ! Local Scalars 
           logical(lk) :: upper, done
           integer(ilp) :: i, imax, j, jmax, itemp, k, kk, kp, kstep, p, ii
           real(dp) :: absakk, alpha, colmax, rowmax, dtemp, sfmin
           complex(dp) :: d11, d12, d21, d22, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=dp) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTF2_ROOK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_dlamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_izamax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange,
                    ! use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_izamax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_izamax( imax-1, a( 1, imax ), 1 )
                          dtemp = cabs1( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! cabs1( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( cabs1(a( imax, imax ))<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the leading
                    ! submatrix a(1:k,1:k) if we have a 2-by-2 pivot
                    if( p>1 )call stdlib_zswap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    if( p<(k-1) )call stdlib_zswap( k-p-1, a( p+1, k ), 1, a( p, p+1 ),lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                 end if
                 ! second swap
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    if( kp>1 )call stdlib_zswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    if( ( kk>1 ) .and. ( kp<(kk-1) ) )call stdlib_zswap( kk-kp-1, a( kp+1, kk ), &
                              1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = cone / a( k, k )
                          call stdlib_zsyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_zscal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_zsyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = cone / ( d11*d22-cone )
                       do j = k - 2, 1, -1
                          wkm1 = t*( d11*a( j, k-1 )-a( j, k ) )
                          wk = t*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - (a( i, k ) / d12 )*wk -( a( i, k-1 ) / d12 )&
                                       *wkm1
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d12
                          a( j, k-1 ) = wkm1 / d12
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_izamax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_izamax( imax-k, a( imax, k ), lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_izamax( n-imax, a( imax+1, imax ),1 )
                          dtemp = cabs1( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! cabs1( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( cabs1(a( imax, imax ))<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 42
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the trailing
                    ! submatrix a(k:n,k:n) if we have a 2-by-2 pivot
                    if( p<n )call stdlib_zswap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    if( p>(k+1) )call stdlib_zswap( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                 end if
                 ! second swap
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_zswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    if( ( kk<n ) .and. ( kp>(kk+1) ) )call stdlib_zswap( kp-kk-1, a( kk+1, kk ), &
                              1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                    ! perform a rank-1 update of a(k+1:n,k+1:n) and
                    ! store l(k) in column k
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = cone / a( k, k )
                          call stdlib_zsyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_zscal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_zsyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = t*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = t*( d22*a( j, k+1 )-a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) - ( a( i, k ) / d21 )*wk -( a( i, k+1 ) / d21 )&
                                       *wkp1
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d21
                          a( j, k+1 ) = wkp1 / d21
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_zsytf2_rook

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sytf2_rook( uplo, n, a, lda, ipiv, info )
     !! ZSYTF2_ROOK: computes the factorization of a complex symmetric matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**T is the transpose of U, and D is symmetric and
     !! block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: sevten = 17.0e+0_${ck}$
           
           
           
           ! Local Scalars 
           logical(lk) :: upper, done
           integer(ilp) :: i, imax, j, jmax, itemp, k, kk, kp, kstep, p, ii
           real(${ck}$) :: absakk, alpha, colmax, rowmax, dtemp, sfmin
           complex(${ck}$) :: d11, d12, d21, d22, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=${ck}$) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTF2_ROOK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_${c2ri(ci)}$lamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ci}$amax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange,
                    ! use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_i${ci}$amax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_i${ci}$amax( imax-1, a( 1, imax ), 1 )
                          dtemp = cabs1( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! cabs1( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( cabs1(a( imax, imax ))<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the leading
                    ! submatrix a(1:k,1:k) if we have a 2-by-2 pivot
                    if( p>1 )call stdlib_${ci}$swap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    if( p<(k-1) )call stdlib_${ci}$swap( k-p-1, a( p+1, k ), 1, a( p, p+1 ),lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                 end if
                 ! second swap
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    if( kp>1 )call stdlib_${ci}$swap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    if( ( kk>1 ) .and. ( kp<(kk-1) ) )call stdlib_${ci}$swap( kk-kp-1, a( kp+1, kk ), &
                              1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = cone / a( k, k )
                          call stdlib_${ci}$syr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_${ci}$scal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_${ci}$syr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = cone / ( d11*d22-cone )
                       do j = k - 2, 1, -1
                          wkm1 = t*( d11*a( j, k-1 )-a( j, k ) )
                          wk = t*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - (a( i, k ) / d12 )*wk -( a( i, k-1 ) / d12 )&
                                       *wkm1
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d12
                          a( j, k-1 ) = wkm1 / d12
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ci}$amax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_i${ci}$amax( imax-k, a( imax, k ), lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_i${ci}$amax( n-imax, a( imax+1, imax ),1 )
                          dtemp = cabs1( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! cabs1( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( cabs1(a( imax, imax ))<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 42
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the trailing
                    ! submatrix a(k:n,k:n) if we have a 2-by-2 pivot
                    if( p<n )call stdlib_${ci}$swap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    if( p>(k+1) )call stdlib_${ci}$swap( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                 end if
                 ! second swap
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_${ci}$swap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    if( ( kk<n ) .and. ( kp>(kk+1) ) )call stdlib_${ci}$swap( kp-kk-1, a( kk+1, kk ), &
                              1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                    ! perform a rank-1 update of a(k+1:n,k+1:n) and
                    ! store l(k) in column k
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = cone / a( k, k )
                          call stdlib_${ci}$syr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_${ci}$scal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_${ci}$syr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = t*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = t*( d22*a( j, k+1 )-a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) - ( a( i, k ) / d21 )*wk -( a( i, k+1 ) / d21 )&
                                       *wkp1
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d21
                          a( j, k+1 ) = wkp1 / d21
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_${ci}$sytf2_rook

#:endif
#:endfor



     module pure subroutine stdlib_checon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
     !! CHECON_ROOK estimates the reciprocal of the condition number of a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by CHETRF_ROOK.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(sp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHECON_ROOK', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**h) or inv(u*d*u**h).
              call stdlib_chetrs_rook( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_checon_rook

     module pure subroutine stdlib_zhecon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
     !! ZHECON_ROOK estimates the reciprocal of the condition number of a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by CHETRF_ROOK.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(dp), intent(in) :: anorm
           real(dp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(dp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHECON_ROOK', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_zlacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**h) or inv(u*d*u**h).
              call stdlib_zhetrs_rook( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_zhecon_rook

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hecon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
     !! ZHECON_ROOK: estimates the reciprocal of the condition number of a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by CHETRF_ROOK.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(${ck}$), intent(in) :: anorm
           real(${ck}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(${ck}$) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHECON_ROOK', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_${ci}$lacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**h) or inv(u*d*u**h).
              call stdlib_${ci}$hetrs_rook( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_${ci}$hecon_rook

#:endif
#:endfor



     module pure subroutine stdlib_ssptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! SSPTRS solves a system of linear equations A*X = B with a real
     !! symmetric matrix A stored in packed format using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by SSPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(in) :: ap(*)
           real(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kp
           real(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSPTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              kc = kc - k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_sger( k-1, nrhs, -one, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_sscal( nrhs, one / ap( kc+k-1 ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_sswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_sger( k-2, nrhs, -one, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 call stdlib_sger( k-2, nrhs, -one, ap( kc-( k-1 ) ), 1,b( k-1, 1 ), ldb, b( 1, 1 &
                           ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+k-2 )
                 akm1 = ap( kc-1 ) / akm1k
                 ak = ap( kc+k-1 ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc - k + 1
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_sgemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb, ap( kc ),1, one, b( k, &
                           1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + k
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 call stdlib_sgemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb, ap( kc ),1, one, b( k, &
                           1 ), ldb )
                 call stdlib_sgemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb,ap( kc+k ), 1, one, b( k+&
                           1, 1 ), ldb )
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + 2*k + 1
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_sger( n-k, nrhs, -one, ap( kc+1 ), 1, b( k, 1 ),ldb, b( k+1,&
                            1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_sscal( nrhs, one / ap( kc ), b( k, 1 ), ldb )
                 kc = kc + n - k + 1
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_sswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_sger( n-k-1, nrhs, -one, ap( kc+2 ), 1, b( k, 1 ),ldb, b( k+2, 1 )&
                              , ldb )
                    call stdlib_sger( n-k-1, nrhs, -one, ap( kc+n-k+2 ), 1,b( k+1, 1 ), ldb, b( k+&
                              2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+1 )
                 akm1 = ap( kc ) / akm1k
                 ak = ap( kc+n-k+1 ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc + 2*( n-k ) + 1
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              kc = kc - ( n-k+1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_sgemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, ap( &
                           kc+1 ), 1, one, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_sgemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, ap( kc+1 ), &
                              1, one, b( k, 1 ), ldb )
                    call stdlib_sgemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, ap( kc-( n-&
                              k ) ), 1, one, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc - ( n-k+2 )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_ssptrs

     module pure subroutine stdlib_dsptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! DSPTRS solves a system of linear equations A*X = B with a real
     !! symmetric matrix A stored in packed format using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by DSPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(dp), intent(in) :: ap(*)
           real(dp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kp
           real(dp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              kc = kc - k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_dger( k-1, nrhs, -one, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_dscal( nrhs, one / ap( kc+k-1 ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_dswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_dger( k-2, nrhs, -one, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 call stdlib_dger( k-2, nrhs, -one, ap( kc-( k-1 ) ), 1,b( k-1, 1 ), ldb, b( 1, 1 &
                           ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+k-2 )
                 akm1 = ap( kc-1 ) / akm1k
                 ak = ap( kc+k-1 ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc - k + 1
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_dgemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb, ap( kc ),1, one, b( k, &
                           1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + k
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 call stdlib_dgemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb, ap( kc ),1, one, b( k, &
                           1 ), ldb )
                 call stdlib_dgemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb,ap( kc+k ), 1, one, b( k+&
                           1, 1 ), ldb )
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + 2*k + 1
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_dger( n-k, nrhs, -one, ap( kc+1 ), 1, b( k, 1 ),ldb, b( k+1,&
                            1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_dscal( nrhs, one / ap( kc ), b( k, 1 ), ldb )
                 kc = kc + n - k + 1
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_dswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_dger( n-k-1, nrhs, -one, ap( kc+2 ), 1, b( k, 1 ),ldb, b( k+2, 1 )&
                              , ldb )
                    call stdlib_dger( n-k-1, nrhs, -one, ap( kc+n-k+2 ), 1,b( k+1, 1 ), ldb, b( k+&
                              2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+1 )
                 akm1 = ap( kc ) / akm1k
                 ak = ap( kc+n-k+1 ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc + 2*( n-k ) + 1
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              kc = kc - ( n-k+1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_dgemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, ap( &
                           kc+1 ), 1, one, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_dgemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, ap( kc+1 ), &
                              1, one, b( k, 1 ), ldb )
                    call stdlib_dgemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, ap( kc-( n-&
                              k ) ), 1, one, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc - ( n-k+2 )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_dsptrs

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! DSPTRS: solves a system of linear equations A*X = B with a real
     !! symmetric matrix A stored in packed format using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by DSPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(in) :: ap(*)
           real(${rk}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kp
           real(${rk}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              kc = kc - k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_${ri}$ger( k-1, nrhs, -one, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_${ri}$scal( nrhs, one / ap( kc+k-1 ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_${ri}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_${ri}$ger( k-2, nrhs, -one, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 call stdlib_${ri}$ger( k-2, nrhs, -one, ap( kc-( k-1 ) ), 1,b( k-1, 1 ), ldb, b( 1, 1 &
                           ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+k-2 )
                 akm1 = ap( kc-1 ) / akm1k
                 ak = ap( kc+k-1 ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc - k + 1
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_${ri}$gemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb, ap( kc ),1, one, b( k, &
                           1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + k
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 call stdlib_${ri}$gemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb, ap( kc ),1, one, b( k, &
                           1 ), ldb )
                 call stdlib_${ri}$gemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb,ap( kc+k ), 1, one, b( k+&
                           1, 1 ), ldb )
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + 2*k + 1
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ri}$ger( n-k, nrhs, -one, ap( kc+1 ), 1, b( k, 1 ),ldb, b( k+1,&
                            1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_${ri}$scal( nrhs, one / ap( kc ), b( k, 1 ), ldb )
                 kc = kc + n - k + 1
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_${ri}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_${ri}$ger( n-k-1, nrhs, -one, ap( kc+2 ), 1, b( k, 1 ),ldb, b( k+2, 1 )&
                              , ldb )
                    call stdlib_${ri}$ger( n-k-1, nrhs, -one, ap( kc+n-k+2 ), 1,b( k+1, 1 ), ldb, b( k+&
                              2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+1 )
                 akm1 = ap( kc ) / akm1k
                 ak = ap( kc+n-k+1 ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc + 2*( n-k ) + 1
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              kc = kc - ( n-k+1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ri}$gemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, ap( &
                           kc+1 ), 1, one, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, ap( kc+1 ), &
                              1, one, b( k, 1 ), ldb )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, ap( kc-( n-&
                              k ) ), 1, one, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc - ( n-k+2 )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_${ri}$sptrs

#:endif
#:endfor

     module pure subroutine stdlib_csptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! CSPTRS solves a system of linear equations A*X = B with a complex
     !! symmetric matrix A stored in packed format using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by CSPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: ap(*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kp
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSPTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              kc = kc - k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_cgeru( k-1, nrhs, -cone, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_cscal( nrhs, cone / ap( kc+k-1 ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_cgeru( k-2, nrhs, -cone, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 call stdlib_cgeru( k-2, nrhs, -cone, ap( kc-( k-1 ) ), 1,b( k-1, 1 ), ldb, b( 1, &
                           1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+k-2 )
                 akm1 = ap( kc-1 ) / akm1k
                 ak = ap( kc+k-1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc - k + 1
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_cgemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb, ap( kc ),1, cone, b( k,&
                            1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + k
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 call stdlib_cgemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb, ap( kc ),1, cone, b( k,&
                            1 ), ldb )
                 call stdlib_cgemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb,ap( kc+k ), 1, cone, b( &
                           k+1, 1 ), ldb )
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + 2*k + 1
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_cgeru( n-k, nrhs, -cone, ap( kc+1 ), 1, b( k, 1 ),ldb, b( k+&
                           1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_cscal( nrhs, cone / ap( kc ), b( k, 1 ), ldb )
                 kc = kc + n - k + 1
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_cgeru( n-k-1, nrhs, -cone, ap( kc+2 ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_cgeru( n-k-1, nrhs, -cone, ap( kc+n-k+2 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+1 )
                 akm1 = ap( kc ) / akm1k
                 ak = ap( kc+n-k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc + 2*( n-k ) + 1
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              kc = kc - ( n-k+1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_cgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, ap( &
                           kc+1 ), 1, cone, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_cgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, ap( kc+1 ),&
                               1, cone, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, ap( kc-( n-&
                              k ) ), 1, cone, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc - ( n-k+2 )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_csptrs

     module pure subroutine stdlib_zsptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! ZSPTRS solves a system of linear equations A*X = B with a complex
     !! symmetric matrix A stored in packed format using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by ZSPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: ap(*)
           complex(dp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kp
           complex(dp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSPTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              kc = kc - k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_zgeru( k-1, nrhs, -cone, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_zscal( nrhs, cone / ap( kc+k-1 ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_zswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_zgeru( k-2, nrhs, -cone, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 call stdlib_zgeru( k-2, nrhs, -cone, ap( kc-( k-1 ) ), 1,b( k-1, 1 ), ldb, b( 1, &
                           1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+k-2 )
                 akm1 = ap( kc-1 ) / akm1k
                 ak = ap( kc+k-1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc - k + 1
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_zgemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb, ap( kc ),1, cone, b( k,&
                            1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + k
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 call stdlib_zgemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb, ap( kc ),1, cone, b( k,&
                            1 ), ldb )
                 call stdlib_zgemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb,ap( kc+k ), 1, cone, b( &
                           k+1, 1 ), ldb )
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + 2*k + 1
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_zgeru( n-k, nrhs, -cone, ap( kc+1 ), 1, b( k, 1 ),ldb, b( k+&
                           1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_zscal( nrhs, cone / ap( kc ), b( k, 1 ), ldb )
                 kc = kc + n - k + 1
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_zswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_zgeru( n-k-1, nrhs, -cone, ap( kc+2 ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_zgeru( n-k-1, nrhs, -cone, ap( kc+n-k+2 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+1 )
                 akm1 = ap( kc ) / akm1k
                 ak = ap( kc+n-k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc + 2*( n-k ) + 1
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              kc = kc - ( n-k+1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_zgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, ap( &
                           kc+1 ), 1, cone, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_zgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, ap( kc+1 ),&
                               1, cone, b( k, 1 ), ldb )
                    call stdlib_zgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, ap( kc-( n-&
                              k ) ), 1, cone, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc - ( n-k+2 )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_zsptrs

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! ZSPTRS: solves a system of linear equations A*X = B with a complex
     !! symmetric matrix A stored in packed format using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by ZSPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: ap(*)
           complex(${ck}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kp
           complex(${ck}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSPTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              kc = kc - k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_${ci}$geru( k-1, nrhs, -cone, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_${ci}$scal( nrhs, cone / ap( kc+k-1 ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_${ci}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_${ci}$geru( k-2, nrhs, -cone, ap( kc ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 call stdlib_${ci}$geru( k-2, nrhs, -cone, ap( kc-( k-1 ) ), 1,b( k-1, 1 ), ldb, b( 1, &
                           1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+k-2 )
                 akm1 = ap( kc-1 ) / akm1k
                 ak = ap( kc+k-1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc - k + 1
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_${ci}$gemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb, ap( kc ),1, cone, b( k,&
                            1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + k
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 call stdlib_${ci}$gemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb, ap( kc ),1, cone, b( k,&
                            1 ), ldb )
                 call stdlib_${ci}$gemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb,ap( kc+k ), 1, cone, b( &
                           k+1, 1 ), ldb )
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc + 2*k + 1
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ci}$geru( n-k, nrhs, -cone, ap( kc+1 ), 1, b( k, 1 ),ldb, b( k+&
                           1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_${ci}$scal( nrhs, cone / ap( kc ), b( k, 1 ), ldb )
                 kc = kc + n - k + 1
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_${ci}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_${ci}$geru( n-k-1, nrhs, -cone, ap( kc+2 ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_${ci}$geru( n-k-1, nrhs, -cone, ap( kc+n-k+2 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = ap( kc+1 )
                 akm1 = ap( kc ) / akm1k
                 ak = ap( kc+n-k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 kc = kc + 2*( n-k ) + 1
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              kc = n*( n+1 ) / 2 + 1
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              kc = kc - ( n-k+1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ci}$gemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, ap( &
                           kc+1 ), 1, cone, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_${ci}$gemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, ap( kc+1 ),&
                               1, cone, b( k, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, ap( kc-( n-&
                              k ) ), 1, cone, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 kc = kc - ( n-k+2 )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_${ci}$sptrs

#:endif
#:endfor



     module pure subroutine stdlib_chptri( uplo, n, ap, ipiv, work, info )
     !! CHPTRI computes the inverse of a complex Hermitian indefinite matrix
     !! A in packed storage using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by CHPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: ap(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kcnext, kp, kpc, kstep, kx, npp
           real(sp) :: ak, akp1, d, t
           complex(sp) :: akkp1, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              kp = n*( n+1 ) / 2
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. ap( kp )==czero )return
                 kp = kp - info
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              kp = 1
              do info = 1, n
                 if( ipiv( info )>0 .and. ap( kp )==czero )return
                 kp = kp + n - info + 1
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              kcnext = kc + k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc+k-1 ) = one / real( ap( kc+k-1 ),KIND=sp)
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_chpmv( uplo, k-1, -cone, ap, work, 1, czero,ap( kc ), 1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -real( stdlib_cdotc( k-1, work, 1, ap( kc ), 1 ),&
                              KIND=sp)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( ap( kcnext+k-1 ) )
                 ak = real( ap( kc+k-1 ),KIND=sp) / t
                 akp1 = real( ap( kcnext+k ),KIND=sp) / t
                 akkp1 = ap( kcnext+k-1 ) / t
                 d = t*( ak*akp1-one )
                 ap( kc+k-1 ) = akp1 / d
                 ap( kcnext+k ) = ak / d
                 ap( kcnext+k-1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_chpmv( uplo, k-1, -cone, ap, work, 1, czero,ap( kc ), 1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -real( stdlib_cdotc( k-1, work, 1, ap( kc ), 1 ),&
                              KIND=sp)
                    ap( kcnext+k-1 ) = ap( kcnext+k-1 ) -stdlib_cdotc( k-1, ap( kc ), 1, ap( &
                              kcnext ),1 )
                    call stdlib_ccopy( k-1, ap( kcnext ), 1, work, 1 )
                    call stdlib_chpmv( uplo, k-1, -cone, ap, work, 1, czero,ap( kcnext ), 1 )
                              
                    ap( kcnext+k ) = ap( kcnext+k ) -real( stdlib_cdotc( k-1, work, 1, ap( kcnext &
                              ),1 ),KIND=sp)
                 end if
                 kstep = 2
                 kcnext = kcnext + k + 1
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kpc = ( kp-1 )*kp / 2 + 1
                 call stdlib_cswap( kp-1, ap( kc ), 1, ap( kpc ), 1 )
                 kx = kpc + kp - 1
                 do j = kp + 1, k - 1
                    kx = kx + j - 1
                    temp = conjg( ap( kc+j-1 ) )
                    ap( kc+j-1 ) = conjg( ap( kx ) )
                    ap( kx ) = temp
                 end do
                 ap( kc+kp-1 ) = conjg( ap( kc+kp-1 ) )
                 temp = ap( kc+k-1 )
                 ap( kc+k-1 ) = ap( kpc+kp-1 )
                 ap( kpc+kp-1 ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc+k+k-1 )
                    ap( kc+k+k-1 ) = ap( kc+k+kp-1 )
                    ap( kc+k+kp-1 ) = temp
                 end if
              end if
              k = k + kstep
              kc = kcnext
              go to 30
              50 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              npp = n*( n+1 ) / 2
              k = n
              kc = npp
              60 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 80
              kcnext = kc - ( n-k+2 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc ) = one / real( ap( kc ),KIND=sp)
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_chpmv( uplo, n-k, -cone, ap( kc+n-k+1 ), work, 1,czero, ap( kc+1 )&
                              , 1 )
                    ap( kc ) = ap( kc ) - real( stdlib_cdotc( n-k, work, 1,ap( kc+1 ), 1 ),&
                              KIND=sp)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( ap( kcnext+1 ) )
                 ak = real( ap( kcnext ),KIND=sp) / t
                 akp1 = real( ap( kc ),KIND=sp) / t
                 akkp1 = ap( kcnext+1 ) / t
                 d = t*( ak*akp1-one )
                 ap( kcnext ) = akp1 / d
                 ap( kc ) = ak / d
                 ap( kcnext+1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_chpmv( uplo, n-k, -cone, ap( kc+( n-k+1 ) ), work,1, czero, ap( &
                              kc+1 ), 1 )
                    ap( kc ) = ap( kc ) - real( stdlib_cdotc( n-k, work, 1,ap( kc+1 ), 1 ),&
                              KIND=sp)
                    ap( kcnext+1 ) = ap( kcnext+1 ) -stdlib_cdotc( n-k, ap( kc+1 ), 1,ap( kcnext+&
                              2 ), 1 )
                    call stdlib_ccopy( n-k, ap( kcnext+2 ), 1, work, 1 )
                    call stdlib_chpmv( uplo, n-k, -cone, ap( kc+( n-k+1 ) ), work,1, czero, ap( &
                              kcnext+2 ), 1 )
                    ap( kcnext ) = ap( kcnext ) -real( stdlib_cdotc( n-k, work, 1, ap( kcnext+2 ),&
                              1 ),KIND=sp)
                 end if
                 kstep = 2
                 kcnext = kcnext - ( n-k+3 )
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kpc = npp - ( n-kp+1 )*( n-kp+2 ) / 2 + 1
                 if( kp<n )call stdlib_cswap( n-kp, ap( kc+kp-k+1 ), 1, ap( kpc+1 ), 1 )
                 kx = kc + kp - k
                 do j = k + 1, kp - 1
                    kx = kx + n - j + 1
                    temp = conjg( ap( kc+j-k ) )
                    ap( kc+j-k ) = conjg( ap( kx ) )
                    ap( kx ) = temp
                 end do
                 ap( kc+kp-k ) = conjg( ap( kc+kp-k ) )
                 temp = ap( kc )
                 ap( kc ) = ap( kpc )
                 ap( kpc ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc-n+k-1 )
                    ap( kc-n+k-1 ) = ap( kc-n+kp-1 )
                    ap( kc-n+kp-1 ) = temp
                 end if
              end if
              k = k - kstep
              kc = kcnext
              go to 60
              80 continue
           end if
           return
     end subroutine stdlib_chptri

     module pure subroutine stdlib_zhptri( uplo, n, ap, ipiv, work, info )
     !! ZHPTRI computes the inverse of a complex Hermitian indefinite matrix
     !! A in packed storage using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by ZHPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(inout) :: ap(*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kcnext, kp, kpc, kstep, kx, npp
           real(dp) :: ak, akp1, d, t
           complex(dp) :: akkp1, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHPTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              kp = n*( n+1 ) / 2
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. ap( kp )==czero )return
                 kp = kp - info
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              kp = 1
              do info = 1, n
                 if( ipiv( info )>0 .and. ap( kp )==czero )return
                 kp = kp + n - info + 1
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              kcnext = kc + k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc+k-1 ) = one / real( ap( kc+k-1 ),KIND=dp)
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_zcopy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_zhpmv( uplo, k-1, -cone, ap, work, 1, czero,ap( kc ), 1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -real( stdlib_zdotc( k-1, work, 1, ap( kc ), 1 ),&
                              KIND=dp)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( ap( kcnext+k-1 ) )
                 ak = real( ap( kc+k-1 ),KIND=dp) / t
                 akp1 = real( ap( kcnext+k ),KIND=dp) / t
                 akkp1 = ap( kcnext+k-1 ) / t
                 d = t*( ak*akp1-one )
                 ap( kc+k-1 ) = akp1 / d
                 ap( kcnext+k ) = ak / d
                 ap( kcnext+k-1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_zcopy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_zhpmv( uplo, k-1, -cone, ap, work, 1, czero,ap( kc ), 1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -real( stdlib_zdotc( k-1, work, 1, ap( kc ), 1 ),&
                              KIND=dp)
                    ap( kcnext+k-1 ) = ap( kcnext+k-1 ) -stdlib_zdotc( k-1, ap( kc ), 1, ap( &
                              kcnext ),1 )
                    call stdlib_zcopy( k-1, ap( kcnext ), 1, work, 1 )
                    call stdlib_zhpmv( uplo, k-1, -cone, ap, work, 1, czero,ap( kcnext ), 1 )
                              
                    ap( kcnext+k ) = ap( kcnext+k ) -real( stdlib_zdotc( k-1, work, 1, ap( kcnext &
                              ),1 ),KIND=dp)
                 end if
                 kstep = 2
                 kcnext = kcnext + k + 1
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kpc = ( kp-1 )*kp / 2 + 1
                 call stdlib_zswap( kp-1, ap( kc ), 1, ap( kpc ), 1 )
                 kx = kpc + kp - 1
                 do j = kp + 1, k - 1
                    kx = kx + j - 1
                    temp = conjg( ap( kc+j-1 ) )
                    ap( kc+j-1 ) = conjg( ap( kx ) )
                    ap( kx ) = temp
                 end do
                 ap( kc+kp-1 ) = conjg( ap( kc+kp-1 ) )
                 temp = ap( kc+k-1 )
                 ap( kc+k-1 ) = ap( kpc+kp-1 )
                 ap( kpc+kp-1 ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc+k+k-1 )
                    ap( kc+k+k-1 ) = ap( kc+k+kp-1 )
                    ap( kc+k+kp-1 ) = temp
                 end if
              end if
              k = k + kstep
              kc = kcnext
              go to 30
              50 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              npp = n*( n+1 ) / 2
              k = n
              kc = npp
              60 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 80
              kcnext = kc - ( n-k+2 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc ) = one / real( ap( kc ),KIND=dp)
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_zcopy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_zhpmv( uplo, n-k, -cone, ap( kc+n-k+1 ), work, 1,czero, ap( kc+1 )&
                              , 1 )
                    ap( kc ) = ap( kc ) - real( stdlib_zdotc( n-k, work, 1,ap( kc+1 ), 1 ),&
                              KIND=dp)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( ap( kcnext+1 ) )
                 ak = real( ap( kcnext ),KIND=dp) / t
                 akp1 = real( ap( kc ),KIND=dp) / t
                 akkp1 = ap( kcnext+1 ) / t
                 d = t*( ak*akp1-one )
                 ap( kcnext ) = akp1 / d
                 ap( kc ) = ak / d
                 ap( kcnext+1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_zcopy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_zhpmv( uplo, n-k, -cone, ap( kc+( n-k+1 ) ), work,1, czero, ap( &
                              kc+1 ), 1 )
                    ap( kc ) = ap( kc ) - real( stdlib_zdotc( n-k, work, 1,ap( kc+1 ), 1 ),&
                              KIND=dp)
                    ap( kcnext+1 ) = ap( kcnext+1 ) -stdlib_zdotc( n-k, ap( kc+1 ), 1,ap( kcnext+&
                              2 ), 1 )
                    call stdlib_zcopy( n-k, ap( kcnext+2 ), 1, work, 1 )
                    call stdlib_zhpmv( uplo, n-k, -cone, ap( kc+( n-k+1 ) ), work,1, czero, ap( &
                              kcnext+2 ), 1 )
                    ap( kcnext ) = ap( kcnext ) -real( stdlib_zdotc( n-k, work, 1, ap( kcnext+2 ),&
                              1 ),KIND=dp)
                 end if
                 kstep = 2
                 kcnext = kcnext - ( n-k+3 )
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kpc = npp - ( n-kp+1 )*( n-kp+2 ) / 2 + 1
                 if( kp<n )call stdlib_zswap( n-kp, ap( kc+kp-k+1 ), 1, ap( kpc+1 ), 1 )
                 kx = kc + kp - k
                 do j = k + 1, kp - 1
                    kx = kx + n - j + 1
                    temp = conjg( ap( kc+j-k ) )
                    ap( kc+j-k ) = conjg( ap( kx ) )
                    ap( kx ) = temp
                 end do
                 ap( kc+kp-k ) = conjg( ap( kc+kp-k ) )
                 temp = ap( kc )
                 ap( kc ) = ap( kpc )
                 ap( kpc ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc-n+k-1 )
                    ap( kc-n+k-1 ) = ap( kc-n+kp-1 )
                    ap( kc-n+kp-1 ) = temp
                 end if
              end if
              k = k - kstep
              kc = kcnext
              go to 60
              80 continue
           end if
           return
     end subroutine stdlib_zhptri

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hptri( uplo, n, ap, ipiv, work, info )
     !! ZHPTRI: computes the inverse of a complex Hermitian indefinite matrix
     !! A in packed storage using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by ZHPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(inout) :: ap(*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kcnext, kp, kpc, kstep, kx, npp
           real(${ck}$) :: ak, akp1, d, t
           complex(${ck}$) :: akkp1, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHPTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              kp = n*( n+1 ) / 2
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. ap( kp )==czero )return
                 kp = kp - info
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              kp = 1
              do info = 1, n
                 if( ipiv( info )>0 .and. ap( kp )==czero )return
                 kp = kp + n - info + 1
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              kcnext = kc + k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc+k-1 ) = one / real( ap( kc+k-1 ),KIND=${ck}$)
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_${ci}$copy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_${ci}$hpmv( uplo, k-1, -cone, ap, work, 1, czero,ap( kc ), 1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -real( stdlib_${ci}$dotc( k-1, work, 1, ap( kc ), 1 ),&
                              KIND=${ck}$)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( ap( kcnext+k-1 ) )
                 ak = real( ap( kc+k-1 ),KIND=${ck}$) / t
                 akp1 = real( ap( kcnext+k ),KIND=${ck}$) / t
                 akkp1 = ap( kcnext+k-1 ) / t
                 d = t*( ak*akp1-one )
                 ap( kc+k-1 ) = akp1 / d
                 ap( kcnext+k ) = ak / d
                 ap( kcnext+k-1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_${ci}$copy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_${ci}$hpmv( uplo, k-1, -cone, ap, work, 1, czero,ap( kc ), 1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -real( stdlib_${ci}$dotc( k-1, work, 1, ap( kc ), 1 ),&
                              KIND=${ck}$)
                    ap( kcnext+k-1 ) = ap( kcnext+k-1 ) -stdlib_${ci}$dotc( k-1, ap( kc ), 1, ap( &
                              kcnext ),1 )
                    call stdlib_${ci}$copy( k-1, ap( kcnext ), 1, work, 1 )
                    call stdlib_${ci}$hpmv( uplo, k-1, -cone, ap, work, 1, czero,ap( kcnext ), 1 )
                              
                    ap( kcnext+k ) = ap( kcnext+k ) -real( stdlib_${ci}$dotc( k-1, work, 1, ap( kcnext &
                              ),1 ),KIND=${ck}$)
                 end if
                 kstep = 2
                 kcnext = kcnext + k + 1
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kpc = ( kp-1 )*kp / 2 + 1
                 call stdlib_${ci}$swap( kp-1, ap( kc ), 1, ap( kpc ), 1 )
                 kx = kpc + kp - 1
                 do j = kp + 1, k - 1
                    kx = kx + j - 1
                    temp = conjg( ap( kc+j-1 ) )
                    ap( kc+j-1 ) = conjg( ap( kx ) )
                    ap( kx ) = temp
                 end do
                 ap( kc+kp-1 ) = conjg( ap( kc+kp-1 ) )
                 temp = ap( kc+k-1 )
                 ap( kc+k-1 ) = ap( kpc+kp-1 )
                 ap( kpc+kp-1 ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc+k+k-1 )
                    ap( kc+k+k-1 ) = ap( kc+k+kp-1 )
                    ap( kc+k+kp-1 ) = temp
                 end if
              end if
              k = k + kstep
              kc = kcnext
              go to 30
              50 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              npp = n*( n+1 ) / 2
              k = n
              kc = npp
              60 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 80
              kcnext = kc - ( n-k+2 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc ) = one / real( ap( kc ),KIND=${ck}$)
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_${ci}$copy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_${ci}$hpmv( uplo, n-k, -cone, ap( kc+n-k+1 ), work, 1,czero, ap( kc+1 )&
                              , 1 )
                    ap( kc ) = ap( kc ) - real( stdlib_${ci}$dotc( n-k, work, 1,ap( kc+1 ), 1 ),&
                              KIND=${ck}$)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( ap( kcnext+1 ) )
                 ak = real( ap( kcnext ),KIND=${ck}$) / t
                 akp1 = real( ap( kc ),KIND=${ck}$) / t
                 akkp1 = ap( kcnext+1 ) / t
                 d = t*( ak*akp1-one )
                 ap( kcnext ) = akp1 / d
                 ap( kc ) = ak / d
                 ap( kcnext+1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_${ci}$copy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_${ci}$hpmv( uplo, n-k, -cone, ap( kc+( n-k+1 ) ), work,1, czero, ap( &
                              kc+1 ), 1 )
                    ap( kc ) = ap( kc ) - real( stdlib_${ci}$dotc( n-k, work, 1,ap( kc+1 ), 1 ),&
                              KIND=${ck}$)
                    ap( kcnext+1 ) = ap( kcnext+1 ) -stdlib_${ci}$dotc( n-k, ap( kc+1 ), 1,ap( kcnext+&
                              2 ), 1 )
                    call stdlib_${ci}$copy( n-k, ap( kcnext+2 ), 1, work, 1 )
                    call stdlib_${ci}$hpmv( uplo, n-k, -cone, ap( kc+( n-k+1 ) ), work,1, czero, ap( &
                              kcnext+2 ), 1 )
                    ap( kcnext ) = ap( kcnext ) -real( stdlib_${ci}$dotc( n-k, work, 1, ap( kcnext+2 ),&
                              1 ),KIND=${ck}$)
                 end if
                 kstep = 2
                 kcnext = kcnext - ( n-k+3 )
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kpc = npp - ( n-kp+1 )*( n-kp+2 ) / 2 + 1
                 if( kp<n )call stdlib_${ci}$swap( n-kp, ap( kc+kp-k+1 ), 1, ap( kpc+1 ), 1 )
                 kx = kc + kp - k
                 do j = k + 1, kp - 1
                    kx = kx + n - j + 1
                    temp = conjg( ap( kc+j-k ) )
                    ap( kc+j-k ) = conjg( ap( kx ) )
                    ap( kx ) = temp
                 end do
                 ap( kc+kp-k ) = conjg( ap( kc+kp-k ) )
                 temp = ap( kc )
                 ap( kc ) = ap( kpc )
                 ap( kpc ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc-n+k-1 )
                    ap( kc-n+k-1 ) = ap( kc-n+kp-1 )
                    ap( kc-n+kp-1 ) = temp
                 end if
              end if
              k = k - kstep
              kc = kcnext
              go to 60
              80 continue
           end if
           return
     end subroutine stdlib_${ci}$hptri

#:endif
#:endfor





     module pure subroutine stdlib_ssyswapr( uplo, n, a, lda, i1, i2)
     !! SSYSWAPR applies an elementary permutation on the rows and the columns of
     !! a symmetric matrix.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: i1, i2, lda, n
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,n)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           real(sp) :: tmp
           ! Executable Statements 
           upper = stdlib_lsame( uplo, 'U' )
           if (upper) then
               ! upper
               ! first swap
                ! - swap column i1 and i2 from i1 to i1-1
              call stdlib_sswap( i1-1, a(1,i1), 1, a(1,i2), 1 )
                ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap row i1 from i1+1 to i2-1 with col i2 from i1+1 to i2-1
              tmp=a(i1,i1)
              a(i1,i1)=a(i2,i2)
              a(i2,i2)=tmp
              do i=1,i2-i1-1
                 tmp=a(i1,i1+i)
                 a(i1,i1+i)=a(i1+i,i2)
                 a(i1+i,i2)=tmp
              end do
                ! third swap
                ! - swap row i1 and i2 from i2+1 to n
              do i=i2+1,n
                 tmp=a(i1,i)
                 a(i1,i)=a(i2,i)
                 a(i2,i)=tmp
              end do
             else
               ! lower
               ! first swap
                ! - swap row i1 and i2 from i1 to i1-1
              call stdlib_sswap( i1-1, a(i1,1), lda, a(i2,1), lda )
               ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap col i1 from i1+1 to i2-1 with row i2 from i1+1 to i2-1
               tmp=a(i1,i1)
               a(i1,i1)=a(i2,i2)
               a(i2,i2)=tmp
               do i=1,i2-i1-1
                  tmp=a(i1+i,i1)
                  a(i1+i,i1)=a(i2,i1+i)
                  a(i2,i1+i)=tmp
               end do
               ! third swap
                ! - swap col i1 and i2 from i2+1 to n
               do i=i2+1,n
                  tmp=a(i,i1)
                  a(i,i1)=a(i,i2)
                  a(i,i2)=tmp
               end do
           endif
     end subroutine stdlib_ssyswapr

     module pure subroutine stdlib_dsyswapr( uplo, n, a, lda, i1, i2)
     !! DSYSWAPR applies an elementary permutation on the rows and the columns of
     !! a symmetric matrix.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: i1, i2, lda, n
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,n)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           real(dp) :: tmp
           ! Executable Statements 
           upper = stdlib_lsame( uplo, 'U' )
           if (upper) then
               ! upper
               ! first swap
                ! - swap column i1 and i2 from i1 to i1-1
              call stdlib_dswap( i1-1, a(1,i1), 1, a(1,i2), 1 )
                ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap row i1 from i1+1 to i2-1 with col i2 from i1+1 to i2-1
              tmp=a(i1,i1)
              a(i1,i1)=a(i2,i2)
              a(i2,i2)=tmp
              do i=1,i2-i1-1
                 tmp=a(i1,i1+i)
                 a(i1,i1+i)=a(i1+i,i2)
                 a(i1+i,i2)=tmp
              end do
                ! third swap
                ! - swap row i1 and i2 from i2+1 to n
              do i=i2+1,n
                 tmp=a(i1,i)
                 a(i1,i)=a(i2,i)
                 a(i2,i)=tmp
              end do
             else
               ! lower
               ! first swap
                ! - swap row i1 and i2 from i1 to i1-1
              call stdlib_dswap( i1-1, a(i1,1), lda, a(i2,1), lda )
               ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap col i1 from i1+1 to i2-1 with row i2 from i1+1 to i2-1
               tmp=a(i1,i1)
               a(i1,i1)=a(i2,i2)
               a(i2,i2)=tmp
               do i=1,i2-i1-1
                  tmp=a(i1+i,i1)
                  a(i1+i,i1)=a(i2,i1+i)
                  a(i2,i1+i)=tmp
               end do
               ! third swap
                ! - swap col i1 and i2 from i2+1 to n
               do i=i2+1,n
                  tmp=a(i,i1)
                  a(i,i1)=a(i,i2)
                  a(i,i2)=tmp
               end do
           endif
     end subroutine stdlib_dsyswapr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$syswapr( uplo, n, a, lda, i1, i2)
     !! DSYSWAPR: applies an elementary permutation on the rows and the columns of
     !! a symmetric matrix.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: i1, i2, lda, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,n)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           real(${rk}$) :: tmp
           ! Executable Statements 
           upper = stdlib_lsame( uplo, 'U' )
           if (upper) then
               ! upper
               ! first swap
                ! - swap column i1 and i2 from i1 to i1-1
              call stdlib_${ri}$swap( i1-1, a(1,i1), 1, a(1,i2), 1 )
                ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap row i1 from i1+1 to i2-1 with col i2 from i1+1 to i2-1
              tmp=a(i1,i1)
              a(i1,i1)=a(i2,i2)
              a(i2,i2)=tmp
              do i=1,i2-i1-1
                 tmp=a(i1,i1+i)
                 a(i1,i1+i)=a(i1+i,i2)
                 a(i1+i,i2)=tmp
              end do
                ! third swap
                ! - swap row i1 and i2 from i2+1 to n
              do i=i2+1,n
                 tmp=a(i1,i)
                 a(i1,i)=a(i2,i)
                 a(i2,i)=tmp
              end do
             else
               ! lower
               ! first swap
                ! - swap row i1 and i2 from i1 to i1-1
              call stdlib_${ri}$swap( i1-1, a(i1,1), lda, a(i2,1), lda )
               ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap col i1 from i1+1 to i2-1 with row i2 from i1+1 to i2-1
               tmp=a(i1,i1)
               a(i1,i1)=a(i2,i2)
               a(i2,i2)=tmp
               do i=1,i2-i1-1
                  tmp=a(i1+i,i1)
                  a(i1+i,i1)=a(i2,i1+i)
                  a(i2,i1+i)=tmp
               end do
               ! third swap
                ! - swap col i1 and i2 from i2+1 to n
               do i=i2+1,n
                  tmp=a(i,i1)
                  a(i,i1)=a(i,i2)
                  a(i,i2)=tmp
               end do
           endif
     end subroutine stdlib_${ri}$syswapr

#:endif
#:endfor

     module pure subroutine stdlib_csyswapr( uplo, n, a, lda, i1, i2)
     !! CSYSWAPR applies an elementary permutation on the rows and the columns of
     !! a symmetric matrix.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: i1, i2, lda, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,n)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           complex(sp) :: tmp
           ! Executable Statements 
           upper = stdlib_lsame( uplo, 'U' )
           if (upper) then
               ! upper
               ! first swap
                ! - swap column i1 and i2 from i1 to i1-1
              call stdlib_cswap( i1-1, a(1,i1), 1, a(1,i2), 1 )
                ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap row i1 from i1+1 to i2-1 with col i2 from i1+1 to i2-1
              tmp=a(i1,i1)
              a(i1,i1)=a(i2,i2)
              a(i2,i2)=tmp
              do i=1,i2-i1-1
                 tmp=a(i1,i1+i)
                 a(i1,i1+i)=a(i1+i,i2)
                 a(i1+i,i2)=tmp
              end do
                ! third swap
                ! - swap row i1 and i2 from i2+1 to n
              do i=i2+1,n
                 tmp=a(i1,i)
                 a(i1,i)=a(i2,i)
                 a(i2,i)=tmp
              end do
             else
               ! lower
               ! first swap
                ! - swap row i1 and i2 from i1 to i1-1
              call stdlib_cswap ( i1-1, a(i1,1), lda, a(i2,1), lda )
               ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap col i1 from i1+1 to i2-1 with row i2 from i1+1 to i2-1
               tmp=a(i1,i1)
               a(i1,i1)=a(i2,i2)
               a(i2,i2)=tmp
               do i=1,i2-i1-1
                  tmp=a(i1+i,i1)
                  a(i1+i,i1)=a(i2,i1+i)
                  a(i2,i1+i)=tmp
               end do
               ! third swap
                ! - swap col i1 and i2 from i2+1 to n
               do i=i2+1,n
                  tmp=a(i,i1)
                  a(i,i1)=a(i,i2)
                  a(i,i2)=tmp
               end do
           endif
     end subroutine stdlib_csyswapr

     module pure subroutine stdlib_zsyswapr( uplo, n, a, lda, i1, i2)
     !! ZSYSWAPR applies an elementary permutation on the rows and the columns of
     !! a symmetric matrix.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: i1, i2, lda, n
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,n)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           complex(dp) :: tmp
           ! Executable Statements 
           upper = stdlib_lsame( uplo, 'U' )
           if (upper) then
               ! upper
               ! first swap
                ! - swap column i1 and i2 from i1 to i1-1
              call stdlib_zswap( i1-1, a(1,i1), 1, a(1,i2), 1 )
                ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap row i1 from i1+1 to i2-1 with col i2 from i1+1 to i2-1
              tmp=a(i1,i1)
              a(i1,i1)=a(i2,i2)
              a(i2,i2)=tmp
              do i=1,i2-i1-1
                 tmp=a(i1,i1+i)
                 a(i1,i1+i)=a(i1+i,i2)
                 a(i1+i,i2)=tmp
              end do
                ! third swap
                ! - swap row i1 and i2 from i2+1 to n
              do i=i2+1,n
                 tmp=a(i1,i)
                 a(i1,i)=a(i2,i)
                 a(i2,i)=tmp
              end do
             else
               ! lower
               ! first swap
                ! - swap row i1 and i2 from i1 to i1-1
              call stdlib_zswap( i1-1, a(i1,1), lda, a(i2,1), lda )
               ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap col i1 from i1+1 to i2-1 with row i2 from i1+1 to i2-1
               tmp=a(i1,i1)
               a(i1,i1)=a(i2,i2)
               a(i2,i2)=tmp
               do i=1,i2-i1-1
                  tmp=a(i1+i,i1)
                  a(i1+i,i1)=a(i2,i1+i)
                  a(i2,i1+i)=tmp
               end do
               ! third swap
                ! - swap col i1 and i2 from i2+1 to n
               do i=i2+1,n
                  tmp=a(i,i1)
                  a(i,i1)=a(i,i2)
                  a(i,i2)=tmp
               end do
           endif
     end subroutine stdlib_zsyswapr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$syswapr( uplo, n, a, lda, i1, i2)
     !! ZSYSWAPR: applies an elementary permutation on the rows and the columns of
     !! a symmetric matrix.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: i1, i2, lda, n
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,n)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           complex(${ck}$) :: tmp
           ! Executable Statements 
           upper = stdlib_lsame( uplo, 'U' )
           if (upper) then
               ! upper
               ! first swap
                ! - swap column i1 and i2 from i1 to i1-1
              call stdlib_${ci}$swap( i1-1, a(1,i1), 1, a(1,i2), 1 )
                ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap row i1 from i1+1 to i2-1 with col i2 from i1+1 to i2-1
              tmp=a(i1,i1)
              a(i1,i1)=a(i2,i2)
              a(i2,i2)=tmp
              do i=1,i2-i1-1
                 tmp=a(i1,i1+i)
                 a(i1,i1+i)=a(i1+i,i2)
                 a(i1+i,i2)=tmp
              end do
                ! third swap
                ! - swap row i1 and i2 from i2+1 to n
              do i=i2+1,n
                 tmp=a(i1,i)
                 a(i1,i)=a(i2,i)
                 a(i2,i)=tmp
              end do
             else
               ! lower
               ! first swap
                ! - swap row i1 and i2 from i1 to i1-1
              call stdlib_${ci}$swap( i1-1, a(i1,1), lda, a(i2,1), lda )
               ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap col i1 from i1+1 to i2-1 with row i2 from i1+1 to i2-1
               tmp=a(i1,i1)
               a(i1,i1)=a(i2,i2)
               a(i2,i2)=tmp
               do i=1,i2-i1-1
                  tmp=a(i1+i,i1)
                  a(i1+i,i1)=a(i2,i1+i)
                  a(i2,i1+i)=tmp
               end do
               ! third swap
                ! - swap col i1 and i2 from i2+1 to n
               do i=i2+1,n
                  tmp=a(i,i1)
                  a(i,i1)=a(i,i2)
                  a(i,i2)=tmp
               end do
           endif
     end subroutine stdlib_${ci}$syswapr

#:endif
#:endfor



     module pure subroutine stdlib_chetf2_rook( uplo, n, a, lda, ipiv, info )
     !! CHETF2_ROOK computes the factorization of a complex Hermitian matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:
     !! A = U*D*U**H  or  A = L*D*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**H is the conjugate transpose of U, and D is
     !! Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! ======================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           ! Local Scalars 
           logical(lk) :: done, upper
           integer(ilp) :: i, ii, imax, itemp, j, jmax, k, kk, kp, kstep, p
           real(sp) :: absakk, alpha, colmax, d, d11, d22, r1, stemp, rowmax, tt, sfmin
           complex(sp) :: d12, d21, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETF2_ROOK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=sp)
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_icamax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_icamax( imax-1, a( 1, imax ), 1 )
                          stemp = cabs1( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=sp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( a( imax, imax ),KIND=sp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 12
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! for only a 2x2 pivot, interchange rows and columns k and p
                 ! in the leading submatrix a(1:k,1:k)
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! (1) swap columnar parts
                    if( p>1 )call stdlib_cswap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = p + 1, k - 1
                       t = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( p, j ) )
                       a( p, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( p, k ) = conjg( a( p, k ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( k, k ),KIND=sp)
                    a( k, k ) = real( a( p, p ),KIND=sp)
                    a( p, p ) = r1
                 end if
                 ! for both 1x1 and 2x2 pivots, interchange rows and
                 ! columns kk and kp in the leading submatrix a(1:k,1:k)
                 if( kp/=kk ) then
                    ! (1) swap columnar parts
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = kp + 1, kk - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( kk, kk ),KIND=sp)
                    a( kk, kk ) = real( a( kp, kp ),KIND=sp)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       ! (*) make sure that diagonal element of pivot is real
                       a( k, k ) = real( a( k, k ),KIND=sp)
                       ! (5) swap row elements
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 else
                    ! (*) make sure that diagonal element of pivot is real
                    a( k, k ) = real( a( k, k ),KIND=sp)
                    if( kstep==2 )a( k-1, k-1 ) = real( a( k-1, k-1 ),KIND=sp)
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( abs( real( a( k, k ),KIND=sp) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = one / real( a( k, k ),KIND=sp)
                          call stdlib_cher( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_csscal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = real( a( k, k ),KIND=sp)
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_cher( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       ! d = |a12|
                       d = stdlib_slapy2( real( a( k-1, k ),KIND=sp),aimag( a( k-1, k ) ) )
                                 
                       d11 = real( a( k, k ) / d,KIND=sp)
                       d22 = real( a( k-1, k-1 ) / d,KIND=sp)
                       d12 = a( k-1, k ) / d
                       tt = one / ( d11*d22-one )
                       do j = k - 2, 1, -1
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wkm1 = tt*( d11*a( j, k-1 )-conjg( d12 )*a( j, k ) )
                          wk = tt*( d22*a( j, k )-d12*a( j, k-1 ) )
                          ! perform a rank-2 update of a(1:k-2,1:k-2)
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) -( a( i, k ) / d )*conjg( wk ) -( a( i, k-1 ) &
                                       / d )*conjg( wkm1 )
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d
                          a( j, k-1 ) = wkm1 / d
                          ! (*) make sure that diagonal element of pivot is real
                          a( j, j ) = cmplx( real( a( j, j ),KIND=sp), zero,KIND=sp)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=sp)
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_icamax( imax-k, a( imax, k ), lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_icamax( n-imax, a( imax+1, imax ),1 )
                          stemp = cabs1( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=sp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( a( imax, imax ),KIND=sp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 42
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! for only a 2x2 pivot, interchange rows and columns k and p
                 ! in the trailing submatrix a(k:n,k:n)
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! (1) swap columnar parts
                    if( p<n )call stdlib_cswap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = k + 1, p - 1
                       t = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( p, j ) )
                       a( p, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( p, k ) = conjg( a( p, k ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( k, k ),KIND=sp)
                    a( k, k ) = real( a( p, p ),KIND=sp)
                    a( p, p ) = r1
                 end if
                 ! for both 1x1 and 2x2 pivots, interchange rows and
                 ! columns kk and kp in the trailing submatrix a(k:n,k:n)
                 if( kp/=kk ) then
                    ! (1) swap columnar parts
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! (2) swap and conjugate middle parts
                    do j = kk + 1, kp - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( kk, kk ),KIND=sp)
                    a( kk, kk ) = real( a( kp, kp ),KIND=sp)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       ! (*) make sure that diagonal element of pivot is real
                       a( k, k ) = real( a( k, k ),KIND=sp)
                       ! (5) swap row elements
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 else
                    ! (*) make sure that diagonal element of pivot is real
                    a( k, k ) = real( a( k, k ),KIND=sp)
                    if( kstep==2 )a( k+1, k+1 ) = real( a( k+1, k+1 ),KIND=sp)
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of a now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) and
                       ! store l(k) in column k
                       ! handle division by a small number
                       if( abs( real( a( k, k ),KIND=sp) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = one / real( a( k, k ),KIND=sp)
                          call stdlib_cher( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_csscal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = real( a( k, k ),KIND=sp)
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_cher( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       ! d = |a21|
                       d = stdlib_slapy2( real( a( k+1, k ),KIND=sp),aimag( a( k+1, k ) ) )
                                 
                       d11 = real( a( k+1, k+1 ),KIND=sp) / d
                       d22 = real( a( k, k ),KIND=sp) / d
                       d21 = a( k+1, k ) / d
                       tt = one / ( d11*d22-one )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = tt*( d11*a( j, k )-d21*a( j, k+1 ) )
                          wkp1 = tt*( d22*a( j, k+1 )-conjg( d21 )*a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) -( a( i, k ) / d )*conjg( wk ) -( a( i, k+1 ) &
                                       / d )*conjg( wkp1 )
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d
                          a( j, k+1 ) = wkp1 / d
                          ! (*) make sure that diagonal element of pivot is real
                          a( j, j ) = cmplx( real( a( j, j ),KIND=sp), zero,KIND=sp)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_chetf2_rook

     module pure subroutine stdlib_zhetf2_rook( uplo, n, a, lda, ipiv, info )
     !! ZHETF2_ROOK computes the factorization of a complex Hermitian matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:
     !! A = U*D*U**H  or  A = L*D*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**H is the conjugate transpose of U, and D is
     !! Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
        ! ======================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           ! Local Scalars 
           logical(lk) :: done, upper
           integer(ilp) :: i, ii, imax, itemp, j, jmax, k, kk, kp, kstep, p
           real(dp) :: absakk, alpha, colmax, d, d11, d22, r1, dtemp, rowmax, tt, sfmin
           complex(dp) :: d12, d21, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=dp) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETF2_ROOK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_dlamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=dp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_izamax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=dp)
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_izamax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_izamax( imax-1, a( 1, imax ), 1 )
                          dtemp = cabs1( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=dp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( a( imax, imax ),KIND=dp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 12
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! for only a 2x2 pivot, interchange rows and columns k and p
                 ! in the leading submatrix a(1:k,1:k)
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! (1) swap columnar parts
                    if( p>1 )call stdlib_zswap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = p + 1, k - 1
                       t = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( p, j ) )
                       a( p, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( p, k ) = conjg( a( p, k ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( k, k ),KIND=dp)
                    a( k, k ) = real( a( p, p ),KIND=dp)
                    a( p, p ) = r1
                 end if
                 ! for both 1x1 and 2x2 pivots, interchange rows and
                 ! columns kk and kp in the leading submatrix a(1:k,1:k)
                 if( kp/=kk ) then
                    ! (1) swap columnar parts
                    if( kp>1 )call stdlib_zswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = kp + 1, kk - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( kk, kk ),KIND=dp)
                    a( kk, kk ) = real( a( kp, kp ),KIND=dp)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       ! (*) make sure that diagonal element of pivot is real
                       a( k, k ) = real( a( k, k ),KIND=dp)
                       ! (5) swap row elements
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 else
                    ! (*) make sure that diagonal element of pivot is real
                    a( k, k ) = real( a( k, k ),KIND=dp)
                    if( kstep==2 )a( k-1, k-1 ) = real( a( k-1, k-1 ),KIND=dp)
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( abs( real( a( k, k ),KIND=dp) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = one / real( a( k, k ),KIND=dp)
                          call stdlib_zher( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_zdscal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = real( a( k, k ),KIND=dp)
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_zher( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       ! d = |a12|
                       d = stdlib_dlapy2( real( a( k-1, k ),KIND=dp),aimag( a( k-1, k ) ) )
                                 
                       d11 = real( a( k, k ) / d,KIND=dp)
                       d22 = real( a( k-1, k-1 ) / d,KIND=dp)
                       d12 = a( k-1, k ) / d
                       tt = one / ( d11*d22-one )
                       do j = k - 2, 1, -1
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wkm1 = tt*( d11*a( j, k-1 )-conjg( d12 )*a( j, k ) )
                          wk = tt*( d22*a( j, k )-d12*a( j, k-1 ) )
                          ! perform a rank-2 update of a(1:k-2,1:k-2)
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) -( a( i, k ) / d )*conjg( wk ) -( a( i, k-1 ) &
                                       / d )*conjg( wkm1 )
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d
                          a( j, k-1 ) = wkm1 / d
                          ! (*) make sure that diagonal element of pivot is real
                          a( j, j ) = cmplx( real( a( j, j ),KIND=dp), zero,KIND=dp)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=dp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_izamax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=dp)
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_izamax( imax-k, a( imax, k ), lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_izamax( n-imax, a( imax+1, imax ),1 )
                          dtemp = cabs1( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=dp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( a( imax, imax ),KIND=dp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 42
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! for only a 2x2 pivot, interchange rows and columns k and p
                 ! in the trailing submatrix a(k:n,k:n)
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! (1) swap columnar parts
                    if( p<n )call stdlib_zswap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = k + 1, p - 1
                       t = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( p, j ) )
                       a( p, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( p, k ) = conjg( a( p, k ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( k, k ),KIND=dp)
                    a( k, k ) = real( a( p, p ),KIND=dp)
                    a( p, p ) = r1
                 end if
                 ! for both 1x1 and 2x2 pivots, interchange rows and
                 ! columns kk and kp in the trailing submatrix a(k:n,k:n)
                 if( kp/=kk ) then
                    ! (1) swap columnar parts
                    if( kp<n )call stdlib_zswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! (2) swap and conjugate middle parts
                    do j = kk + 1, kp - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( kk, kk ),KIND=dp)
                    a( kk, kk ) = real( a( kp, kp ),KIND=dp)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       ! (*) make sure that diagonal element of pivot is real
                       a( k, k ) = real( a( k, k ),KIND=dp)
                       ! (5) swap row elements
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 else
                    ! (*) make sure that diagonal element of pivot is real
                    a( k, k ) = real( a( k, k ),KIND=dp)
                    if( kstep==2 )a( k+1, k+1 ) = real( a( k+1, k+1 ),KIND=dp)
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of a now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) and
                       ! store l(k) in column k
                       ! handle division by a small number
                       if( abs( real( a( k, k ),KIND=dp) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = one / real( a( k, k ),KIND=dp)
                          call stdlib_zher( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_zdscal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = real( a( k, k ),KIND=dp)
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_zher( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       ! d = |a21|
                       d = stdlib_dlapy2( real( a( k+1, k ),KIND=dp),aimag( a( k+1, k ) ) )
                                 
                       d11 = real( a( k+1, k+1 ),KIND=dp) / d
                       d22 = real( a( k, k ),KIND=dp) / d
                       d21 = a( k+1, k ) / d
                       tt = one / ( d11*d22-one )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = tt*( d11*a( j, k )-d21*a( j, k+1 ) )
                          wkp1 = tt*( d22*a( j, k+1 )-conjg( d21 )*a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) -( a( i, k ) / d )*conjg( wk ) -( a( i, k+1 ) &
                                       / d )*conjg( wkp1 )
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d
                          a( j, k+1 ) = wkp1 / d
                          ! (*) make sure that diagonal element of pivot is real
                          a( j, j ) = cmplx( real( a( j, j ),KIND=dp), zero,KIND=dp)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_zhetf2_rook

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hetf2_rook( uplo, n, a, lda, ipiv, info )
     !! ZHETF2_ROOK: computes the factorization of a complex Hermitian matrix A
     !! using the bounded Bunch-Kaufman ("rook") diagonal pivoting method:
     !! A = U*D*U**H  or  A = L*D*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**H is the conjugate transpose of U, and D is
     !! Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
        ! ======================================================================
           ! Parameters 
           real(${ck}$), parameter :: sevten = 17.0e+0_${ck}$
           
           
           ! Local Scalars 
           logical(lk) :: done, upper
           integer(ilp) :: i, ii, imax, itemp, j, jmax, k, kk, kp, kstep, p
           real(${ck}$) :: absakk, alpha, colmax, d, d11, d22, r1, dtemp, rowmax, tt, sfmin
           complex(${ck}$) :: d12, d21, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=${ck}$) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETF2_ROOK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_${c2ri(ci)}$lamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=${ck}$) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ci}$amax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=${ck}$)
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_i${ci}$amax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_i${ci}$amax( imax-1, a( 1, imax ), 1 )
                          dtemp = cabs1( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=${ck}$) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( a( imax, imax ),KIND=${ck}$) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 12
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! for only a 2x2 pivot, interchange rows and columns k and p
                 ! in the leading submatrix a(1:k,1:k)
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! (1) swap columnar parts
                    if( p>1 )call stdlib_${ci}$swap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = p + 1, k - 1
                       t = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( p, j ) )
                       a( p, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( p, k ) = conjg( a( p, k ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( k, k ),KIND=${ck}$)
                    a( k, k ) = real( a( p, p ),KIND=${ck}$)
                    a( p, p ) = r1
                 end if
                 ! for both 1x1 and 2x2 pivots, interchange rows and
                 ! columns kk and kp in the leading submatrix a(1:k,1:k)
                 if( kp/=kk ) then
                    ! (1) swap columnar parts
                    if( kp>1 )call stdlib_${ci}$swap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = kp + 1, kk - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( kk, kk ),KIND=${ck}$)
                    a( kk, kk ) = real( a( kp, kp ),KIND=${ck}$)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       ! (*) make sure that diagonal element of pivot is real
                       a( k, k ) = real( a( k, k ),KIND=${ck}$)
                       ! (5) swap row elements
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 else
                    ! (*) make sure that diagonal element of pivot is real
                    a( k, k ) = real( a( k, k ),KIND=${ck}$)
                    if( kstep==2 )a( k-1, k-1 ) = real( a( k-1, k-1 ),KIND=${ck}$)
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( abs( real( a( k, k ),KIND=${ck}$) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = one / real( a( k, k ),KIND=${ck}$)
                          call stdlib_${ci}$her( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_${ci}$dscal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = real( a( k, k ),KIND=${ck}$)
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_${ci}$her( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       ! d = |a12|
                       d = stdlib_${c2ri(ci)}$lapy2( real( a( k-1, k ),KIND=${ck}$),aimag( a( k-1, k ) ) )
                                 
                       d11 = real( a( k, k ) / d,KIND=${ck}$)
                       d22 = real( a( k-1, k-1 ) / d,KIND=${ck}$)
                       d12 = a( k-1, k ) / d
                       tt = one / ( d11*d22-one )
                       do j = k - 2, 1, -1
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wkm1 = tt*( d11*a( j, k-1 )-conjg( d12 )*a( j, k ) )
                          wk = tt*( d22*a( j, k )-d12*a( j, k-1 ) )
                          ! perform a rank-2 update of a(1:k-2,1:k-2)
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) -( a( i, k ) / d )*conjg( wk ) -( a( i, k-1 ) &
                                       / d )*conjg( wkm1 )
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d
                          a( j, k-1 ) = wkm1 / d
                          ! (*) make sure that diagonal element of pivot is real
                          a( j, j ) = cmplx( real( a( j, j ),KIND=${ck}$), zero,KIND=${ck}$)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( a( k, k ),KIND=${ck}$) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ci}$amax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( a( k, k ),KIND=${ck}$)
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_i${ci}$amax( imax-k, a( imax, k ), lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_i${ci}$amax( n-imax, a( imax+1, imax ),1 )
                          dtemp = cabs1( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=${ck}$) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( a( imax, imax ),KIND=${ck}$) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 42
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! for only a 2x2 pivot, interchange rows and columns k and p
                 ! in the trailing submatrix a(k:n,k:n)
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! (1) swap columnar parts
                    if( p<n )call stdlib_${ci}$swap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    ! (2) swap and conjugate middle parts
                    do j = k + 1, p - 1
                       t = conjg( a( j, k ) )
                       a( j, k ) = conjg( a( p, j ) )
                       a( p, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( p, k ) = conjg( a( p, k ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( k, k ),KIND=${ck}$)
                    a( k, k ) = real( a( p, p ),KIND=${ck}$)
                    a( p, p ) = r1
                 end if
                 ! for both 1x1 and 2x2 pivots, interchange rows and
                 ! columns kk and kp in the trailing submatrix a(k:n,k:n)
                 if( kp/=kk ) then
                    ! (1) swap columnar parts
                    if( kp<n )call stdlib_${ci}$swap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! (2) swap and conjugate middle parts
                    do j = kk + 1, kp - 1
                       t = conjg( a( j, kk ) )
                       a( j, kk ) = conjg( a( kp, j ) )
                       a( kp, j ) = t
                    end do
                    ! (3) swap and conjugate corner elements at row-col interserction
                    a( kp, kk ) = conjg( a( kp, kk ) )
                    ! (4) swap diagonal elements at row-col intersection
                    r1 = real( a( kk, kk ),KIND=${ck}$)
                    a( kk, kk ) = real( a( kp, kp ),KIND=${ck}$)
                    a( kp, kp ) = r1
                    if( kstep==2 ) then
                       ! (*) make sure that diagonal element of pivot is real
                       a( k, k ) = real( a( k, k ),KIND=${ck}$)
                       ! (5) swap row elements
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 else
                    ! (*) make sure that diagonal element of pivot is real
                    a( k, k ) = real( a( k, k ),KIND=${ck}$)
                    if( kstep==2 )a( k+1, k+1 ) = real( a( k+1, k+1 ),KIND=${ck}$)
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of a now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) and
                       ! store l(k) in column k
                       ! handle division by a small number
                       if( abs( real( a( k, k ),KIND=${ck}$) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = one / real( a( k, k ),KIND=${ck}$)
                          call stdlib_${ci}$her( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_${ci}$dscal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = real( a( k, k ),KIND=${ck}$)
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_${ci}$her( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       ! d = |a21|
                       d = stdlib_${c2ri(ci)}$lapy2( real( a( k+1, k ),KIND=${ck}$),aimag( a( k+1, k ) ) )
                                 
                       d11 = real( a( k+1, k+1 ),KIND=${ck}$) / d
                       d22 = real( a( k, k ),KIND=${ck}$) / d
                       d21 = a( k+1, k ) / d
                       tt = one / ( d11*d22-one )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = tt*( d11*a( j, k )-d21*a( j, k+1 ) )
                          wkp1 = tt*( d22*a( j, k+1 )-conjg( d21 )*a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) -( a( i, k ) / d )*conjg( wk ) -( a( i, k+1 ) &
                                       / d )*conjg( wkp1 )
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d
                          a( j, k+1 ) = wkp1 / d
                          ! (*) make sure that diagonal element of pivot is real
                          a( j, j ) = cmplx( real( a( j, j ),KIND=${ck}$), zero,KIND=${ck}$)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_${ci}$hetf2_rook

#:endif
#:endfor



     module pure subroutine stdlib_ssptri( uplo, n, ap, ipiv, work, info )
     !! SSPTRI computes the inverse of a real symmetric indefinite matrix
     !! A in packed storage using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by SSPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(inout) :: ap(*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kcnext, kp, kpc, kstep, kx, npp
           real(sp) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSPTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              kp = n*( n+1 ) / 2
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. ap( kp )==zero )return
                 kp = kp - info
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              kp = 1
              do info = 1, n
                 if( ipiv( info )>0 .and. ap( kp )==zero )return
                 kp = kp + n - info + 1
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              kcnext = kc + k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc+k-1 ) = one / ap( kc+k-1 )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_scopy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_sspmv( uplo, k-1, -one, ap, work, 1, zero, ap( kc ),1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -stdlib_sdot( k-1, work, 1, ap( kc ), 1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( ap( kcnext+k-1 ) )
                 ak = ap( kc+k-1 ) / t
                 akp1 = ap( kcnext+k ) / t
                 akkp1 = ap( kcnext+k-1 ) / t
                 d = t*( ak*akp1-one )
                 ap( kc+k-1 ) = akp1 / d
                 ap( kcnext+k ) = ak / d
                 ap( kcnext+k-1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_scopy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_sspmv( uplo, k-1, -one, ap, work, 1, zero, ap( kc ),1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -stdlib_sdot( k-1, work, 1, ap( kc ), 1 )
                    ap( kcnext+k-1 ) = ap( kcnext+k-1 ) -stdlib_sdot( k-1, ap( kc ), 1, ap( &
                              kcnext ),1 )
                    call stdlib_scopy( k-1, ap( kcnext ), 1, work, 1 )
                    call stdlib_sspmv( uplo, k-1, -one, ap, work, 1, zero,ap( kcnext ), 1 )
                              
                    ap( kcnext+k ) = ap( kcnext+k ) -stdlib_sdot( k-1, work, 1, ap( kcnext ), 1 )
                              
                 end if
                 kstep = 2
                 kcnext = kcnext + k + 1
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kpc = ( kp-1 )*kp / 2 + 1
                 call stdlib_sswap( kp-1, ap( kc ), 1, ap( kpc ), 1 )
                 kx = kpc + kp - 1
                 do j = kp + 1, k - 1
                    kx = kx + j - 1
                    temp = ap( kc+j-1 )
                    ap( kc+j-1 ) = ap( kx )
                    ap( kx ) = temp
                 end do
                 temp = ap( kc+k-1 )
                 ap( kc+k-1 ) = ap( kpc+kp-1 )
                 ap( kpc+kp-1 ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc+k+k-1 )
                    ap( kc+k+k-1 ) = ap( kc+k+kp-1 )
                    ap( kc+k+kp-1 ) = temp
                 end if
              end if
              k = k + kstep
              kc = kcnext
              go to 30
              50 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              npp = n*( n+1 ) / 2
              k = n
              kc = npp
              60 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 80
              kcnext = kc - ( n-k+2 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc ) = one / ap( kc )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_scopy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_sspmv( uplo, n-k, -one, ap( kc+n-k+1 ), work, 1,zero, ap( kc+1 ), &
                              1 )
                    ap( kc ) = ap( kc ) - stdlib_sdot( n-k, work, 1, ap( kc+1 ), 1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( ap( kcnext+1 ) )
                 ak = ap( kcnext ) / t
                 akp1 = ap( kc ) / t
                 akkp1 = ap( kcnext+1 ) / t
                 d = t*( ak*akp1-one )
                 ap( kcnext ) = akp1 / d
                 ap( kc ) = ak / d
                 ap( kcnext+1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_scopy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_sspmv( uplo, n-k, -one, ap( kc+( n-k+1 ) ), work, 1,zero, ap( kc+&
                              1 ), 1 )
                    ap( kc ) = ap( kc ) - stdlib_sdot( n-k, work, 1, ap( kc+1 ), 1 )
                    ap( kcnext+1 ) = ap( kcnext+1 ) -stdlib_sdot( n-k, ap( kc+1 ), 1,ap( kcnext+2 &
                              ), 1 )
                    call stdlib_scopy( n-k, ap( kcnext+2 ), 1, work, 1 )
                    call stdlib_sspmv( uplo, n-k, -one, ap( kc+( n-k+1 ) ), work, 1,zero, ap( &
                              kcnext+2 ), 1 )
                    ap( kcnext ) = ap( kcnext ) -stdlib_sdot( n-k, work, 1, ap( kcnext+2 ), 1 )
                              
                 end if
                 kstep = 2
                 kcnext = kcnext - ( n-k+3 )
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kpc = npp - ( n-kp+1 )*( n-kp+2 ) / 2 + 1
                 if( kp<n )call stdlib_sswap( n-kp, ap( kc+kp-k+1 ), 1, ap( kpc+1 ), 1 )
                 kx = kc + kp - k
                 do j = k + 1, kp - 1
                    kx = kx + n - j + 1
                    temp = ap( kc+j-k )
                    ap( kc+j-k ) = ap( kx )
                    ap( kx ) = temp
                 end do
                 temp = ap( kc )
                 ap( kc ) = ap( kpc )
                 ap( kpc ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc-n+k-1 )
                    ap( kc-n+k-1 ) = ap( kc-n+kp-1 )
                    ap( kc-n+kp-1 ) = temp
                 end if
              end if
              k = k - kstep
              kc = kcnext
              go to 60
              80 continue
           end if
           return
     end subroutine stdlib_ssptri

     module pure subroutine stdlib_dsptri( uplo, n, ap, ipiv, work, info )
     !! DSPTRI computes the inverse of a real symmetric indefinite matrix
     !! A in packed storage using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by DSPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(dp), intent(inout) :: ap(*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kcnext, kp, kpc, kstep, kx, npp
           real(dp) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              kp = n*( n+1 ) / 2
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. ap( kp )==zero )return
                 kp = kp - info
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              kp = 1
              do info = 1, n
                 if( ipiv( info )>0 .and. ap( kp )==zero )return
                 kp = kp + n - info + 1
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              kcnext = kc + k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc+k-1 ) = one / ap( kc+k-1 )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_dcopy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_dspmv( uplo, k-1, -one, ap, work, 1, zero, ap( kc ),1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -stdlib_ddot( k-1, work, 1, ap( kc ), 1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( ap( kcnext+k-1 ) )
                 ak = ap( kc+k-1 ) / t
                 akp1 = ap( kcnext+k ) / t
                 akkp1 = ap( kcnext+k-1 ) / t
                 d = t*( ak*akp1-one )
                 ap( kc+k-1 ) = akp1 / d
                 ap( kcnext+k ) = ak / d
                 ap( kcnext+k-1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_dcopy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_dspmv( uplo, k-1, -one, ap, work, 1, zero, ap( kc ),1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -stdlib_ddot( k-1, work, 1, ap( kc ), 1 )
                    ap( kcnext+k-1 ) = ap( kcnext+k-1 ) -stdlib_ddot( k-1, ap( kc ), 1, ap( &
                              kcnext ),1 )
                    call stdlib_dcopy( k-1, ap( kcnext ), 1, work, 1 )
                    call stdlib_dspmv( uplo, k-1, -one, ap, work, 1, zero,ap( kcnext ), 1 )
                              
                    ap( kcnext+k ) = ap( kcnext+k ) -stdlib_ddot( k-1, work, 1, ap( kcnext ), 1 )
                              
                 end if
                 kstep = 2
                 kcnext = kcnext + k + 1
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kpc = ( kp-1 )*kp / 2 + 1
                 call stdlib_dswap( kp-1, ap( kc ), 1, ap( kpc ), 1 )
                 kx = kpc + kp - 1
                 do j = kp + 1, k - 1
                    kx = kx + j - 1
                    temp = ap( kc+j-1 )
                    ap( kc+j-1 ) = ap( kx )
                    ap( kx ) = temp
                 end do
                 temp = ap( kc+k-1 )
                 ap( kc+k-1 ) = ap( kpc+kp-1 )
                 ap( kpc+kp-1 ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc+k+k-1 )
                    ap( kc+k+k-1 ) = ap( kc+k+kp-1 )
                    ap( kc+k+kp-1 ) = temp
                 end if
              end if
              k = k + kstep
              kc = kcnext
              go to 30
              50 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              npp = n*( n+1 ) / 2
              k = n
              kc = npp
              60 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 80
              kcnext = kc - ( n-k+2 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc ) = one / ap( kc )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_dcopy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_dspmv( uplo, n-k, -one, ap( kc+n-k+1 ), work, 1,zero, ap( kc+1 ), &
                              1 )
                    ap( kc ) = ap( kc ) - stdlib_ddot( n-k, work, 1, ap( kc+1 ), 1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( ap( kcnext+1 ) )
                 ak = ap( kcnext ) / t
                 akp1 = ap( kc ) / t
                 akkp1 = ap( kcnext+1 ) / t
                 d = t*( ak*akp1-one )
                 ap( kcnext ) = akp1 / d
                 ap( kc ) = ak / d
                 ap( kcnext+1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_dcopy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_dspmv( uplo, n-k, -one, ap( kc+( n-k+1 ) ), work, 1,zero, ap( kc+&
                              1 ), 1 )
                    ap( kc ) = ap( kc ) - stdlib_ddot( n-k, work, 1, ap( kc+1 ), 1 )
                    ap( kcnext+1 ) = ap( kcnext+1 ) -stdlib_ddot( n-k, ap( kc+1 ), 1,ap( kcnext+2 &
                              ), 1 )
                    call stdlib_dcopy( n-k, ap( kcnext+2 ), 1, work, 1 )
                    call stdlib_dspmv( uplo, n-k, -one, ap( kc+( n-k+1 ) ), work, 1,zero, ap( &
                              kcnext+2 ), 1 )
                    ap( kcnext ) = ap( kcnext ) -stdlib_ddot( n-k, work, 1, ap( kcnext+2 ), 1 )
                              
                 end if
                 kstep = 2
                 kcnext = kcnext - ( n-k+3 )
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kpc = npp - ( n-kp+1 )*( n-kp+2 ) / 2 + 1
                 if( kp<n )call stdlib_dswap( n-kp, ap( kc+kp-k+1 ), 1, ap( kpc+1 ), 1 )
                 kx = kc + kp - k
                 do j = k + 1, kp - 1
                    kx = kx + n - j + 1
                    temp = ap( kc+j-k )
                    ap( kc+j-k ) = ap( kx )
                    ap( kx ) = temp
                 end do
                 temp = ap( kc )
                 ap( kc ) = ap( kpc )
                 ap( kpc ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc-n+k-1 )
                    ap( kc-n+k-1 ) = ap( kc-n+kp-1 )
                    ap( kc-n+kp-1 ) = temp
                 end if
              end if
              k = k - kstep
              kc = kcnext
              go to 60
              80 continue
           end if
           return
     end subroutine stdlib_dsptri

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sptri( uplo, n, ap, ipiv, work, info )
     !! DSPTRI: computes the inverse of a real symmetric indefinite matrix
     !! A in packed storage using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by DSPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(inout) :: ap(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kcnext, kp, kpc, kstep, kx, npp
           real(${rk}$) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              kp = n*( n+1 ) / 2
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. ap( kp )==zero )return
                 kp = kp - info
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              kp = 1
              do info = 1, n
                 if( ipiv( info )>0 .and. ap( kp )==zero )return
                 kp = kp + n - info + 1
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              kcnext = kc + k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc+k-1 ) = one / ap( kc+k-1 )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_${ri}$copy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_${ri}$spmv( uplo, k-1, -one, ap, work, 1, zero, ap( kc ),1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -stdlib_${ri}$dot( k-1, work, 1, ap( kc ), 1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( ap( kcnext+k-1 ) )
                 ak = ap( kc+k-1 ) / t
                 akp1 = ap( kcnext+k ) / t
                 akkp1 = ap( kcnext+k-1 ) / t
                 d = t*( ak*akp1-one )
                 ap( kc+k-1 ) = akp1 / d
                 ap( kcnext+k ) = ak / d
                 ap( kcnext+k-1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_${ri}$copy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_${ri}$spmv( uplo, k-1, -one, ap, work, 1, zero, ap( kc ),1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -stdlib_${ri}$dot( k-1, work, 1, ap( kc ), 1 )
                    ap( kcnext+k-1 ) = ap( kcnext+k-1 ) -stdlib_${ri}$dot( k-1, ap( kc ), 1, ap( &
                              kcnext ),1 )
                    call stdlib_${ri}$copy( k-1, ap( kcnext ), 1, work, 1 )
                    call stdlib_${ri}$spmv( uplo, k-1, -one, ap, work, 1, zero,ap( kcnext ), 1 )
                              
                    ap( kcnext+k ) = ap( kcnext+k ) -stdlib_${ri}$dot( k-1, work, 1, ap( kcnext ), 1 )
                              
                 end if
                 kstep = 2
                 kcnext = kcnext + k + 1
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kpc = ( kp-1 )*kp / 2 + 1
                 call stdlib_${ri}$swap( kp-1, ap( kc ), 1, ap( kpc ), 1 )
                 kx = kpc + kp - 1
                 do j = kp + 1, k - 1
                    kx = kx + j - 1
                    temp = ap( kc+j-1 )
                    ap( kc+j-1 ) = ap( kx )
                    ap( kx ) = temp
                 end do
                 temp = ap( kc+k-1 )
                 ap( kc+k-1 ) = ap( kpc+kp-1 )
                 ap( kpc+kp-1 ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc+k+k-1 )
                    ap( kc+k+k-1 ) = ap( kc+k+kp-1 )
                    ap( kc+k+kp-1 ) = temp
                 end if
              end if
              k = k + kstep
              kc = kcnext
              go to 30
              50 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              npp = n*( n+1 ) / 2
              k = n
              kc = npp
              60 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 80
              kcnext = kc - ( n-k+2 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc ) = one / ap( kc )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_${ri}$copy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_${ri}$spmv( uplo, n-k, -one, ap( kc+n-k+1 ), work, 1,zero, ap( kc+1 ), &
                              1 )
                    ap( kc ) = ap( kc ) - stdlib_${ri}$dot( n-k, work, 1, ap( kc+1 ), 1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( ap( kcnext+1 ) )
                 ak = ap( kcnext ) / t
                 akp1 = ap( kc ) / t
                 akkp1 = ap( kcnext+1 ) / t
                 d = t*( ak*akp1-one )
                 ap( kcnext ) = akp1 / d
                 ap( kc ) = ak / d
                 ap( kcnext+1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_${ri}$copy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_${ri}$spmv( uplo, n-k, -one, ap( kc+( n-k+1 ) ), work, 1,zero, ap( kc+&
                              1 ), 1 )
                    ap( kc ) = ap( kc ) - stdlib_${ri}$dot( n-k, work, 1, ap( kc+1 ), 1 )
                    ap( kcnext+1 ) = ap( kcnext+1 ) -stdlib_${ri}$dot( n-k, ap( kc+1 ), 1,ap( kcnext+2 &
                              ), 1 )
                    call stdlib_${ri}$copy( n-k, ap( kcnext+2 ), 1, work, 1 )
                    call stdlib_${ri}$spmv( uplo, n-k, -one, ap( kc+( n-k+1 ) ), work, 1,zero, ap( &
                              kcnext+2 ), 1 )
                    ap( kcnext ) = ap( kcnext ) -stdlib_${ri}$dot( n-k, work, 1, ap( kcnext+2 ), 1 )
                              
                 end if
                 kstep = 2
                 kcnext = kcnext - ( n-k+3 )
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kpc = npp - ( n-kp+1 )*( n-kp+2 ) / 2 + 1
                 if( kp<n )call stdlib_${ri}$swap( n-kp, ap( kc+kp-k+1 ), 1, ap( kpc+1 ), 1 )
                 kx = kc + kp - k
                 do j = k + 1, kp - 1
                    kx = kx + n - j + 1
                    temp = ap( kc+j-k )
                    ap( kc+j-k ) = ap( kx )
                    ap( kx ) = temp
                 end do
                 temp = ap( kc )
                 ap( kc ) = ap( kpc )
                 ap( kpc ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc-n+k-1 )
                    ap( kc-n+k-1 ) = ap( kc-n+kp-1 )
                    ap( kc-n+kp-1 ) = temp
                 end if
              end if
              k = k - kstep
              kc = kcnext
              go to 60
              80 continue
           end if
           return
     end subroutine stdlib_${ri}$sptri

#:endif
#:endfor

     module pure subroutine stdlib_csptri( uplo, n, ap, ipiv, work, info )
     !! CSPTRI computes the inverse of a complex symmetric indefinite matrix
     !! A in packed storage using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by CSPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: ap(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kcnext, kp, kpc, kstep, kx, npp
           complex(sp) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSPTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              kp = n*( n+1 ) / 2
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. ap( kp )==czero )return
                 kp = kp - info
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              kp = 1
              do info = 1, n
                 if( ipiv( info )>0 .and. ap( kp )==czero )return
                 kp = kp + n - info + 1
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              kcnext = kc + k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc+k-1 ) = cone / ap( kc+k-1 )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_cspmv( uplo, k-1, -cone, ap, work, 1, czero, ap( kc ),1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -stdlib_cdotu( k-1, work, 1, ap( kc ), 1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = ap( kcnext+k-1 )
                 ak = ap( kc+k-1 ) / t
                 akp1 = ap( kcnext+k ) / t
                 akkp1 = ap( kcnext+k-1 ) / t
                 d = t*( ak*akp1-cone )
                 ap( kc+k-1 ) = akp1 / d
                 ap( kcnext+k ) = ak / d
                 ap( kcnext+k-1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_cspmv( uplo, k-1, -cone, ap, work, 1, czero, ap( kc ),1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -stdlib_cdotu( k-1, work, 1, ap( kc ), 1 )
                    ap( kcnext+k-1 ) = ap( kcnext+k-1 ) -stdlib_cdotu( k-1, ap( kc ), 1, ap( &
                              kcnext ),1 )
                    call stdlib_ccopy( k-1, ap( kcnext ), 1, work, 1 )
                    call stdlib_cspmv( uplo, k-1, -cone, ap, work, 1, czero,ap( kcnext ), 1 )
                              
                    ap( kcnext+k ) = ap( kcnext+k ) -stdlib_cdotu( k-1, work, 1, ap( kcnext ), 1 )
                              
                 end if
                 kstep = 2
                 kcnext = kcnext + k + 1
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kpc = ( kp-1 )*kp / 2 + 1
                 call stdlib_cswap( kp-1, ap( kc ), 1, ap( kpc ), 1 )
                 kx = kpc + kp - 1
                 do j = kp + 1, k - 1
                    kx = kx + j - 1
                    temp = ap( kc+j-1 )
                    ap( kc+j-1 ) = ap( kx )
                    ap( kx ) = temp
                 end do
                 temp = ap( kc+k-1 )
                 ap( kc+k-1 ) = ap( kpc+kp-1 )
                 ap( kpc+kp-1 ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc+k+k-1 )
                    ap( kc+k+k-1 ) = ap( kc+k+kp-1 )
                    ap( kc+k+kp-1 ) = temp
                 end if
              end if
              k = k + kstep
              kc = kcnext
              go to 30
              50 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              npp = n*( n+1 ) / 2
              k = n
              kc = npp
              60 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 80
              kcnext = kc - ( n-k+2 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc ) = cone / ap( kc )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_cspmv( uplo, n-k, -cone, ap( kc+n-k+1 ), work, 1,czero, ap( kc+1 )&
                              , 1 )
                    ap( kc ) = ap( kc ) - stdlib_cdotu( n-k, work, 1, ap( kc+1 ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = ap( kcnext+1 )
                 ak = ap( kcnext ) / t
                 akp1 = ap( kc ) / t
                 akkp1 = ap( kcnext+1 ) / t
                 d = t*( ak*akp1-cone )
                 ap( kcnext ) = akp1 / d
                 ap( kc ) = ak / d
                 ap( kcnext+1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_cspmv( uplo, n-k, -cone, ap( kc+( n-k+1 ) ), work, 1,czero, ap( &
                              kc+1 ), 1 )
                    ap( kc ) = ap( kc ) - stdlib_cdotu( n-k, work, 1, ap( kc+1 ),1 )
                    ap( kcnext+1 ) = ap( kcnext+1 ) -stdlib_cdotu( n-k, ap( kc+1 ), 1,ap( kcnext+&
                              2 ), 1 )
                    call stdlib_ccopy( n-k, ap( kcnext+2 ), 1, work, 1 )
                    call stdlib_cspmv( uplo, n-k, -cone, ap( kc+( n-k+1 ) ), work, 1,czero, ap( &
                              kcnext+2 ), 1 )
                    ap( kcnext ) = ap( kcnext ) -stdlib_cdotu( n-k, work, 1, ap( kcnext+2 ), 1 )
                              
                 end if
                 kstep = 2
                 kcnext = kcnext - ( n-k+3 )
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kpc = npp - ( n-kp+1 )*( n-kp+2 ) / 2 + 1
                 if( kp<n )call stdlib_cswap( n-kp, ap( kc+kp-k+1 ), 1, ap( kpc+1 ), 1 )
                 kx = kc + kp - k
                 do j = k + 1, kp - 1
                    kx = kx + n - j + 1
                    temp = ap( kc+j-k )
                    ap( kc+j-k ) = ap( kx )
                    ap( kx ) = temp
                 end do
                 temp = ap( kc )
                 ap( kc ) = ap( kpc )
                 ap( kpc ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc-n+k-1 )
                    ap( kc-n+k-1 ) = ap( kc-n+kp-1 )
                    ap( kc-n+kp-1 ) = temp
                 end if
              end if
              k = k - kstep
              kc = kcnext
              go to 60
              80 continue
           end if
           return
     end subroutine stdlib_csptri

     module pure subroutine stdlib_zsptri( uplo, n, ap, ipiv, work, info )
     !! ZSPTRI computes the inverse of a complex symmetric indefinite matrix
     !! A in packed storage using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by ZSPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(inout) :: ap(*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kcnext, kp, kpc, kstep, kx, npp
           complex(dp) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSPTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              kp = n*( n+1 ) / 2
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. ap( kp )==czero )return
                 kp = kp - info
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              kp = 1
              do info = 1, n
                 if( ipiv( info )>0 .and. ap( kp )==czero )return
                 kp = kp + n - info + 1
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              kcnext = kc + k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc+k-1 ) = cone / ap( kc+k-1 )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_zcopy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_zspmv( uplo, k-1, -cone, ap, work, 1, czero, ap( kc ),1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -stdlib_zdotu( k-1, work, 1, ap( kc ), 1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = ap( kcnext+k-1 )
                 ak = ap( kc+k-1 ) / t
                 akp1 = ap( kcnext+k ) / t
                 akkp1 = ap( kcnext+k-1 ) / t
                 d = t*( ak*akp1-cone )
                 ap( kc+k-1 ) = akp1 / d
                 ap( kcnext+k ) = ak / d
                 ap( kcnext+k-1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_zcopy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_zspmv( uplo, k-1, -cone, ap, work, 1, czero, ap( kc ),1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -stdlib_zdotu( k-1, work, 1, ap( kc ), 1 )
                    ap( kcnext+k-1 ) = ap( kcnext+k-1 ) -stdlib_zdotu( k-1, ap( kc ), 1, ap( &
                              kcnext ),1 )
                    call stdlib_zcopy( k-1, ap( kcnext ), 1, work, 1 )
                    call stdlib_zspmv( uplo, k-1, -cone, ap, work, 1, czero,ap( kcnext ), 1 )
                              
                    ap( kcnext+k ) = ap( kcnext+k ) -stdlib_zdotu( k-1, work, 1, ap( kcnext ), 1 )
                              
                 end if
                 kstep = 2
                 kcnext = kcnext + k + 1
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kpc = ( kp-1 )*kp / 2 + 1
                 call stdlib_zswap( kp-1, ap( kc ), 1, ap( kpc ), 1 )
                 kx = kpc + kp - 1
                 do j = kp + 1, k - 1
                    kx = kx + j - 1
                    temp = ap( kc+j-1 )
                    ap( kc+j-1 ) = ap( kx )
                    ap( kx ) = temp
                 end do
                 temp = ap( kc+k-1 )
                 ap( kc+k-1 ) = ap( kpc+kp-1 )
                 ap( kpc+kp-1 ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc+k+k-1 )
                    ap( kc+k+k-1 ) = ap( kc+k+kp-1 )
                    ap( kc+k+kp-1 ) = temp
                 end if
              end if
              k = k + kstep
              kc = kcnext
              go to 30
              50 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              npp = n*( n+1 ) / 2
              k = n
              kc = npp
              60 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 80
              kcnext = kc - ( n-k+2 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc ) = cone / ap( kc )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_zcopy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_zspmv( uplo, n-k, -cone, ap( kc+n-k+1 ), work, 1,czero, ap( kc+1 )&
                              , 1 )
                    ap( kc ) = ap( kc ) - stdlib_zdotu( n-k, work, 1, ap( kc+1 ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = ap( kcnext+1 )
                 ak = ap( kcnext ) / t
                 akp1 = ap( kc ) / t
                 akkp1 = ap( kcnext+1 ) / t
                 d = t*( ak*akp1-cone )
                 ap( kcnext ) = akp1 / d
                 ap( kc ) = ak / d
                 ap( kcnext+1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_zcopy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_zspmv( uplo, n-k, -cone, ap( kc+( n-k+1 ) ), work, 1,czero, ap( &
                              kc+1 ), 1 )
                    ap( kc ) = ap( kc ) - stdlib_zdotu( n-k, work, 1, ap( kc+1 ),1 )
                    ap( kcnext+1 ) = ap( kcnext+1 ) -stdlib_zdotu( n-k, ap( kc+1 ), 1,ap( kcnext+&
                              2 ), 1 )
                    call stdlib_zcopy( n-k, ap( kcnext+2 ), 1, work, 1 )
                    call stdlib_zspmv( uplo, n-k, -cone, ap( kc+( n-k+1 ) ), work, 1,czero, ap( &
                              kcnext+2 ), 1 )
                    ap( kcnext ) = ap( kcnext ) -stdlib_zdotu( n-k, work, 1, ap( kcnext+2 ), 1 )
                              
                 end if
                 kstep = 2
                 kcnext = kcnext - ( n-k+3 )
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kpc = npp - ( n-kp+1 )*( n-kp+2 ) / 2 + 1
                 if( kp<n )call stdlib_zswap( n-kp, ap( kc+kp-k+1 ), 1, ap( kpc+1 ), 1 )
                 kx = kc + kp - k
                 do j = k + 1, kp - 1
                    kx = kx + n - j + 1
                    temp = ap( kc+j-k )
                    ap( kc+j-k ) = ap( kx )
                    ap( kx ) = temp
                 end do
                 temp = ap( kc )
                 ap( kc ) = ap( kpc )
                 ap( kpc ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc-n+k-1 )
                    ap( kc-n+k-1 ) = ap( kc-n+kp-1 )
                    ap( kc-n+kp-1 ) = temp
                 end if
              end if
              k = k - kstep
              kc = kcnext
              go to 60
              80 continue
           end if
           return
     end subroutine stdlib_zsptri

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sptri( uplo, n, ap, ipiv, work, info )
     !! ZSPTRI: computes the inverse of a complex symmetric indefinite matrix
     !! A in packed storage using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by ZSPTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(inout) :: ap(*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kc, kcnext, kp, kpc, kstep, kx, npp
           complex(${ck}$) :: ak, akkp1, akp1, d, t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSPTRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              kp = n*( n+1 ) / 2
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. ap( kp )==czero )return
                 kp = kp - info
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              kp = 1
              do info = 1, n
                 if( ipiv( info )>0 .and. ap( kp )==czero )return
                 kp = kp + n - info + 1
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              kc = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              kcnext = kc + k
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc+k-1 ) = cone / ap( kc+k-1 )
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_${ci}$copy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_${ci}$spmv( uplo, k-1, -cone, ap, work, 1, czero, ap( kc ),1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -stdlib_${ci}$dotu( k-1, work, 1, ap( kc ), 1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = ap( kcnext+k-1 )
                 ak = ap( kc+k-1 ) / t
                 akp1 = ap( kcnext+k ) / t
                 akkp1 = ap( kcnext+k-1 ) / t
                 d = t*( ak*akp1-cone )
                 ap( kc+k-1 ) = akp1 / d
                 ap( kcnext+k ) = ak / d
                 ap( kcnext+k-1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_${ci}$copy( k-1, ap( kc ), 1, work, 1 )
                    call stdlib_${ci}$spmv( uplo, k-1, -cone, ap, work, 1, czero, ap( kc ),1 )
                    ap( kc+k-1 ) = ap( kc+k-1 ) -stdlib_${ci}$dotu( k-1, work, 1, ap( kc ), 1 )
                    ap( kcnext+k-1 ) = ap( kcnext+k-1 ) -stdlib_${ci}$dotu( k-1, ap( kc ), 1, ap( &
                              kcnext ),1 )
                    call stdlib_${ci}$copy( k-1, ap( kcnext ), 1, work, 1 )
                    call stdlib_${ci}$spmv( uplo, k-1, -cone, ap, work, 1, czero,ap( kcnext ), 1 )
                              
                    ap( kcnext+k ) = ap( kcnext+k ) -stdlib_${ci}$dotu( k-1, work, 1, ap( kcnext ), 1 )
                              
                 end if
                 kstep = 2
                 kcnext = kcnext + k + 1
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 kpc = ( kp-1 )*kp / 2 + 1
                 call stdlib_${ci}$swap( kp-1, ap( kc ), 1, ap( kpc ), 1 )
                 kx = kpc + kp - 1
                 do j = kp + 1, k - 1
                    kx = kx + j - 1
                    temp = ap( kc+j-1 )
                    ap( kc+j-1 ) = ap( kx )
                    ap( kx ) = temp
                 end do
                 temp = ap( kc+k-1 )
                 ap( kc+k-1 ) = ap( kpc+kp-1 )
                 ap( kpc+kp-1 ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc+k+k-1 )
                    ap( kc+k+k-1 ) = ap( kc+k+kp-1 )
                    ap( kc+k+kp-1 ) = temp
                 end if
              end if
              k = k + kstep
              kc = kcnext
              go to 30
              50 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**t.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              npp = n*( n+1 ) / 2
              k = n
              kc = npp
              60 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 80
              kcnext = kc - ( n-k+2 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 ap( kc ) = cone / ap( kc )
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_${ci}$copy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_${ci}$spmv( uplo, n-k, -cone, ap( kc+n-k+1 ), work, 1,czero, ap( kc+1 )&
                              , 1 )
                    ap( kc ) = ap( kc ) - stdlib_${ci}$dotu( n-k, work, 1, ap( kc+1 ),1 )
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = ap( kcnext+1 )
                 ak = ap( kcnext ) / t
                 akp1 = ap( kc ) / t
                 akkp1 = ap( kcnext+1 ) / t
                 d = t*( ak*akp1-cone )
                 ap( kcnext ) = akp1 / d
                 ap( kc ) = ak / d
                 ap( kcnext+1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_${ci}$copy( n-k, ap( kc+1 ), 1, work, 1 )
                    call stdlib_${ci}$spmv( uplo, n-k, -cone, ap( kc+( n-k+1 ) ), work, 1,czero, ap( &
                              kc+1 ), 1 )
                    ap( kc ) = ap( kc ) - stdlib_${ci}$dotu( n-k, work, 1, ap( kc+1 ),1 )
                    ap( kcnext+1 ) = ap( kcnext+1 ) -stdlib_${ci}$dotu( n-k, ap( kc+1 ), 1,ap( kcnext+&
                              2 ), 1 )
                    call stdlib_${ci}$copy( n-k, ap( kcnext+2 ), 1, work, 1 )
                    call stdlib_${ci}$spmv( uplo, n-k, -cone, ap( kc+( n-k+1 ) ), work, 1,czero, ap( &
                              kcnext+2 ), 1 )
                    ap( kcnext ) = ap( kcnext ) -stdlib_${ci}$dotu( n-k, work, 1, ap( kcnext+2 ), 1 )
                              
                 end if
                 kstep = 2
                 kcnext = kcnext - ( n-k+3 )
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 kpc = npp - ( n-kp+1 )*( n-kp+2 ) / 2 + 1
                 if( kp<n )call stdlib_${ci}$swap( n-kp, ap( kc+kp-k+1 ), 1, ap( kpc+1 ), 1 )
                 kx = kc + kp - k
                 do j = k + 1, kp - 1
                    kx = kx + n - j + 1
                    temp = ap( kc+j-k )
                    ap( kc+j-k ) = ap( kx )
                    ap( kx ) = temp
                 end do
                 temp = ap( kc )
                 ap( kc ) = ap( kpc )
                 ap( kpc ) = temp
                 if( kstep==2 ) then
                    temp = ap( kc-n+k-1 )
                    ap( kc-n+k-1 ) = ap( kc-n+kp-1 )
                    ap( kc-n+kp-1 ) = temp
                 end if
              end if
              k = k - kstep
              kc = kcnext
              go to 60
              80 continue
           end if
           return
     end subroutine stdlib_${ci}$sptri

#:endif
#:endfor



     module pure subroutine stdlib_ssycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info )
     !! SSYCON_ROOK estimates the reciprocal of the condition number (in the
     !! 1-norm) of a real symmetric matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by SSYTRF_ROOK.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(in) :: a(lda,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(sp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYCON_ROOK', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_slacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_ssytrs_rook( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_ssycon_rook

     module pure subroutine stdlib_dsycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info )
     !! DSYCON_ROOK estimates the reciprocal of the condition number (in the
     !! 1-norm) of a real symmetric matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by DSYTRF_ROOK.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(dp), intent(in) :: anorm
           real(dp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(in) :: a(lda,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(dp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYCON_ROOK', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_dlacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_dsytrs_rook( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_dsycon_rook

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,iwork, info )
     !! DSYCON_ROOK: estimates the reciprocal of the condition number (in the
     !! 1-norm) of a real symmetric matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by DSYTRF_ROOK.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(${rk}$), intent(in) :: anorm
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(${rk}$) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYCON_ROOK', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==zero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_${ri}$sytrs_rook( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_${ri}$sycon_rook

#:endif
#:endfor

     module pure subroutine stdlib_csycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
     !! CSYCON_ROOK estimates the reciprocal of the condition number (in the
     !! 1-norm) of a complex symmetric matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by CSYTRF_ROOK.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(sp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYCON_ROOK', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==czero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_csytrs_rook( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_csycon_rook

     module pure subroutine stdlib_zsycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
     !! ZSYCON_ROOK estimates the reciprocal of the condition number (in the
     !! 1-norm) of a complex symmetric matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by ZSYTRF_ROOK.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(dp), intent(in) :: anorm
           real(dp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(dp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYCON_ROOK', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==czero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_zlacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_zsytrs_rook( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_zsycon_rook

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sycon_rook( uplo, n, a, lda, ipiv, anorm, rcond, work,info )
     !! ZSYCON_ROOK: estimates the reciprocal of the condition number (in the
     !! 1-norm) of a complex symmetric matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by ZSYTRF_ROOK.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           real(${ck}$), intent(in) :: anorm
           real(${ck}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, kase
           real(${ck}$) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( anorm<zero ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYCON_ROOK', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. a( i, i )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do i = 1, n
                 if( ipiv( i )>0 .and. a( i, i )==czero )return
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_${ci}$lacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_${ci}$sytrs_rook( uplo, n, 1, a, lda, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_${ci}$sycon_rook

#:endif
#:endfor



     module pure subroutine stdlib_ssytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
     !! SSYTRS_3 solves a system of linear equations A * X = B with a real
     !! symmetric matrix A using the factorization computed
     !! by SSYTRF_RK or SSYTRF_BK:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This algorithm is using Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(in) :: a(lda,*), e(*)
           real(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j, k, kp
           real(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYTRS_3', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! begin upper
              ! solve a*x = b, where a = u*d*u**t.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
              call stdlib_strsm( 'L', 'U', 'N', 'U', n, nrhs, one, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i = n
              do while ( i>=1 )
                 if( ipiv( i )>0 ) then
                    call stdlib_sscal( nrhs, one / a( i, i ), b( i, 1 ), ldb )
                 else if ( i>1 ) then
                    akm1k = e( i )
                    akm1 = a( i-1, i-1 ) / akm1k
                    ak = a( i, i ) / akm1k
                    denom = akm1*ak - one
                    do j = 1, nrhs
                       bkm1 = b( i-1, j ) / akm1k
                       bk = b( i, j ) / akm1k
                       b( i-1, j ) = ( ak*bkm1-bk ) / denom
                       b( i, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i - 1
                 end if
                 i = i - 1
              end do
              ! compute (u**t \ b) -> b   [ u**t \ (d \ (u \p**t * b) ) ]
              call stdlib_strsm( 'L', 'U', 'T', 'U', n, nrhs, one, a, lda, b, ldb )
              ! p * b  [ p * (u**t \ (d \ (u \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n, 1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
           else
              ! begin lower
              ! solve a*x = b, where a = l*d*l**t.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n, 1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
              call stdlib_strsm( 'L', 'L', 'N', 'U', n, nrhs, one, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i = 1
              do while ( i<=n )
                 if( ipiv( i )>0 ) then
                    call stdlib_sscal( nrhs, one / a( i, i ), b( i, 1 ), ldb )
                 else if( i<n ) then
                    akm1k = e( i )
                    akm1 = a( i, i ) / akm1k
                    ak = a( i+1, i+1 ) / akm1k
                    denom = akm1*ak - one
                    do  j = 1, nrhs
                       bkm1 = b( i, j ) / akm1k
                       bk = b( i+1, j ) / akm1k
                       b( i, j ) = ( ak*bkm1-bk ) / denom
                       b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i + 1
                 end if
                 i = i + 1
              end do
              ! compute (l**t \ b) -> b   [ l**t \ (d \ (l \p**t * b) ) ]
              call stdlib_strsm('L', 'L', 'T', 'U', n, nrhs, one, a, lda, b, ldb )
              ! p * b  [ p * (l**t \ (d \ (l \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! end lower
           end if
           return
     end subroutine stdlib_ssytrs_3

     module pure subroutine stdlib_dsytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
     !! DSYTRS_3 solves a system of linear equations A * X = B with a real
     !! symmetric matrix A using the factorization computed
     !! by DSYTRF_RK or DSYTRF_BK:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This algorithm is using Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(dp), intent(in) :: a(lda,*), e(*)
           real(dp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j, k, kp
           real(dp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRS_3', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! begin upper
              ! solve a*x = b, where a = u*d*u**t.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
              call stdlib_dtrsm( 'L', 'U', 'N', 'U', n, nrhs, one, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i = n
              do while ( i>=1 )
                 if( ipiv( i )>0 ) then
                    call stdlib_dscal( nrhs, one / a( i, i ), b( i, 1 ), ldb )
                 else if ( i>1 ) then
                    akm1k = e( i )
                    akm1 = a( i-1, i-1 ) / akm1k
                    ak = a( i, i ) / akm1k
                    denom = akm1*ak - one
                    do j = 1, nrhs
                       bkm1 = b( i-1, j ) / akm1k
                       bk = b( i, j ) / akm1k
                       b( i-1, j ) = ( ak*bkm1-bk ) / denom
                       b( i, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i - 1
                 end if
                 i = i - 1
              end do
              ! compute (u**t \ b) -> b   [ u**t \ (d \ (u \p**t * b) ) ]
              call stdlib_dtrsm( 'L', 'U', 'T', 'U', n, nrhs, one, a, lda, b, ldb )
              ! p * b  [ p * (u**t \ (d \ (u \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
           else
              ! begin lower
              ! solve a*x = b, where a = l*d*l**t.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
              call stdlib_dtrsm( 'L', 'L', 'N', 'U', n, nrhs, one, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i = 1
              do while ( i<=n )
                 if( ipiv( i )>0 ) then
                    call stdlib_dscal( nrhs, one / a( i, i ), b( i, 1 ), ldb )
                 else if( i<n ) then
                    akm1k = e( i )
                    akm1 = a( i, i ) / akm1k
                    ak = a( i+1, i+1 ) / akm1k
                    denom = akm1*ak - one
                    do  j = 1, nrhs
                       bkm1 = b( i, j ) / akm1k
                       bk = b( i+1, j ) / akm1k
                       b( i, j ) = ( ak*bkm1-bk ) / denom
                       b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i + 1
                 end if
                 i = i + 1
              end do
              ! compute (l**t \ b) -> b   [ l**t \ (d \ (l \p**t * b) ) ]
              call stdlib_dtrsm('L', 'L', 'T', 'U', n, nrhs, one, a, lda, b, ldb )
              ! p * b  [ p * (l**t \ (d \ (l \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! end lower
           end if
           return
     end subroutine stdlib_dsytrs_3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
     !! DSYTRS_3: solves a system of linear equations A * X = B with a real
     !! symmetric matrix A using the factorization computed
     !! by DSYTRF_RK or DSYTRF_BK:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This algorithm is using Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(in) :: a(lda,*), e(*)
           real(${rk}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j, k, kp
           real(${rk}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRS_3', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! begin upper
              ! solve a*x = b, where a = u*d*u**t.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
              call stdlib_${ri}$trsm( 'L', 'U', 'N', 'U', n, nrhs, one, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i = n
              do while ( i>=1 )
                 if( ipiv( i )>0 ) then
                    call stdlib_${ri}$scal( nrhs, one / a( i, i ), b( i, 1 ), ldb )
                 else if ( i>1 ) then
                    akm1k = e( i )
                    akm1 = a( i-1, i-1 ) / akm1k
                    ak = a( i, i ) / akm1k
                    denom = akm1*ak - one
                    do j = 1, nrhs
                       bkm1 = b( i-1, j ) / akm1k
                       bk = b( i, j ) / akm1k
                       b( i-1, j ) = ( ak*bkm1-bk ) / denom
                       b( i, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i - 1
                 end if
                 i = i - 1
              end do
              ! compute (u**t \ b) -> b   [ u**t \ (d \ (u \p**t * b) ) ]
              call stdlib_${ri}$trsm( 'L', 'U', 'T', 'U', n, nrhs, one, a, lda, b, ldb )
              ! p * b  [ p * (u**t \ (d \ (u \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
           else
              ! begin lower
              ! solve a*x = b, where a = l*d*l**t.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
              call stdlib_${ri}$trsm( 'L', 'L', 'N', 'U', n, nrhs, one, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i = 1
              do while ( i<=n )
                 if( ipiv( i )>0 ) then
                    call stdlib_${ri}$scal( nrhs, one / a( i, i ), b( i, 1 ), ldb )
                 else if( i<n ) then
                    akm1k = e( i )
                    akm1 = a( i, i ) / akm1k
                    ak = a( i+1, i+1 ) / akm1k
                    denom = akm1*ak - one
                    do  j = 1, nrhs
                       bkm1 = b( i, j ) / akm1k
                       bk = b( i+1, j ) / akm1k
                       b( i, j ) = ( ak*bkm1-bk ) / denom
                       b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i + 1
                 end if
                 i = i + 1
              end do
              ! compute (l**t \ b) -> b   [ l**t \ (d \ (l \p**t * b) ) ]
              call stdlib_${ri}$trsm('L', 'L', 'T', 'U', n, nrhs, one, a, lda, b, ldb )
              ! p * b  [ p * (l**t \ (d \ (l \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! end lower
           end if
           return
     end subroutine stdlib_${ri}$sytrs_3

#:endif
#:endfor

     module pure subroutine stdlib_csytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
     !! CSYTRS_3 solves a system of linear equations A * X = B with a complex
     !! symmetric matrix A using the factorization computed
     !! by CSYTRF_RK or CSYTRF_BK:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This algorithm is using Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*), e(*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j, k, kp
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRS_3', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! begin upper
              ! solve a*x = b, where a = u*d*u**t.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
              call stdlib_ctrsm( 'L', 'U', 'N', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i = n
              do while ( i>=1 )
                 if( ipiv( i )>0 ) then
                    call stdlib_cscal( nrhs, cone / a( i, i ), b( i, 1 ), ldb )
                 else if ( i>1 ) then
                    akm1k = e( i )
                    akm1 = a( i-1, i-1 ) / akm1k
                    ak = a( i, i ) / akm1k
                    denom = akm1*ak - cone
                    do j = 1, nrhs
                       bkm1 = b( i-1, j ) / akm1k
                       bk = b( i, j ) / akm1k
                       b( i-1, j ) = ( ak*bkm1-bk ) / denom
                       b( i, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i - 1
                 end if
                 i = i - 1
              end do
              ! compute (u**t \ b) -> b   [ u**t \ (d \ (u \p**t * b) ) ]
              call stdlib_ctrsm( 'L', 'U', 'T', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! p * b  [ p * (u**t \ (d \ (u \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv( i ) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n, 1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
           else
              ! begin lower
              ! solve a*x = b, where a = l*d*l**t.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n, 1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
              call stdlib_ctrsm( 'L', 'L', 'N', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i = 1
              do while ( i<=n )
                 if( ipiv( i )>0 ) then
                    call stdlib_cscal( nrhs, cone / a( i, i ), b( i, 1 ), ldb )
                 else if( i<n ) then
                    akm1k = e( i )
                    akm1 = a( i, i ) / akm1k
                    ak = a( i+1, i+1 ) / akm1k
                    denom = akm1*ak - cone
                    do  j = 1, nrhs
                       bkm1 = b( i, j ) / akm1k
                       bk = b( i+1, j ) / akm1k
                       b( i, j ) = ( ak*bkm1-bk ) / denom
                       b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i + 1
                 end if
                 i = i + 1
              end do
              ! compute (l**t \ b) -> b   [ l**t \ (d \ (l \p**t * b) ) ]
              call stdlib_ctrsm('L', 'L', 'T', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! p * b  [ p * (l**t \ (d \ (l \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! end lower
           end if
           return
     end subroutine stdlib_csytrs_3

     module pure subroutine stdlib_zsytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
     !! ZSYTRS_3 solves a system of linear equations A * X = B with a complex
     !! symmetric matrix A using the factorization computed
     !! by ZSYTRF_RK or ZSYTRF_BK:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This algorithm is using Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: a(lda,*), e(*)
           complex(dp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j, k, kp
           complex(dp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRS_3', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! begin upper
              ! solve a*x = b, where a = u*d*u**t.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
              call stdlib_ztrsm( 'L', 'U', 'N', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i = n
              do while ( i>=1 )
                 if( ipiv( i )>0 ) then
                    call stdlib_zscal( nrhs, cone / a( i, i ), b( i, 1 ), ldb )
                 else if ( i>1 ) then
                    akm1k = e( i )
                    akm1 = a( i-1, i-1 ) / akm1k
                    ak = a( i, i ) / akm1k
                    denom = akm1*ak - cone
                    do j = 1, nrhs
                       bkm1 = b( i-1, j ) / akm1k
                       bk = b( i, j ) / akm1k
                       b( i-1, j ) = ( ak*bkm1-bk ) / denom
                       b( i, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i - 1
                 end if
                 i = i - 1
              end do
              ! compute (u**t \ b) -> b   [ u**t \ (d \ (u \p**t * b) ) ]
              call stdlib_ztrsm( 'L', 'U', 'T', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! p * b  [ p * (u**t \ (d \ (u \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n, 1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
           else
              ! begin lower
              ! solve a*x = b, where a = l*d*l**t.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n, 1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
              call stdlib_ztrsm( 'L', 'L', 'N', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i = 1
              do while ( i<=n )
                 if( ipiv( i )>0 ) then
                    call stdlib_zscal( nrhs, cone / a( i, i ), b( i, 1 ), ldb )
                 else if( i<n ) then
                    akm1k = e( i )
                    akm1 = a( i, i ) / akm1k
                    ak = a( i+1, i+1 ) / akm1k
                    denom = akm1*ak - cone
                    do  j = 1, nrhs
                       bkm1 = b( i, j ) / akm1k
                       bk = b( i+1, j ) / akm1k
                       b( i, j ) = ( ak*bkm1-bk ) / denom
                       b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i + 1
                 end if
                 i = i + 1
              end do
              ! compute (l**t \ b) -> b   [ l**t \ (d \ (l \p**t * b) ) ]
              call stdlib_ztrsm('L', 'L', 'T', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! p * b  [ p * (l**t \ (d \ (l \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! end lower
           end if
           return
     end subroutine stdlib_zsytrs_3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
     !! ZSYTRS_3: solves a system of linear equations A * X = B with a complex
     !! symmetric matrix A using the factorization computed
     !! by ZSYTRF_RK or ZSYTRF_BK:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This algorithm is using Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: a(lda,*), e(*)
           complex(${ck}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j, k, kp
           complex(${ck}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRS_3', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! begin upper
              ! solve a*x = b, where a = u*d*u**t.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
              call stdlib_${ci}$trsm( 'L', 'U', 'N', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i = n
              do while ( i>=1 )
                 if( ipiv( i )>0 ) then
                    call stdlib_${ci}$scal( nrhs, cone / a( i, i ), b( i, 1 ), ldb )
                 else if ( i>1 ) then
                    akm1k = e( i )
                    akm1 = a( i-1, i-1 ) / akm1k
                    ak = a( i, i ) / akm1k
                    denom = akm1*ak - cone
                    do j = 1, nrhs
                       bkm1 = b( i-1, j ) / akm1k
                       bk = b( i, j ) / akm1k
                       b( i-1, j ) = ( ak*bkm1-bk ) / denom
                       b( i, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i - 1
                 end if
                 i = i - 1
              end do
              ! compute (u**t \ b) -> b   [ u**t \ (d \ (u \p**t * b) ) ]
              call stdlib_${ci}$trsm( 'L', 'U', 'T', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! p * b  [ p * (u**t \ (d \ (u \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n, 1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
           else
              ! begin lower
              ! solve a*x = b, where a = l*d*l**t.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n, 1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
              call stdlib_${ci}$trsm( 'L', 'L', 'N', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i = 1
              do while ( i<=n )
                 if( ipiv( i )>0 ) then
                    call stdlib_${ci}$scal( nrhs, cone / a( i, i ), b( i, 1 ), ldb )
                 else if( i<n ) then
                    akm1k = e( i )
                    akm1 = a( i, i ) / akm1k
                    ak = a( i+1, i+1 ) / akm1k
                    denom = akm1*ak - cone
                    do  j = 1, nrhs
                       bkm1 = b( i, j ) / akm1k
                       bk = b( i+1, j ) / akm1k
                       b( i, j ) = ( ak*bkm1-bk ) / denom
                       b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i + 1
                 end if
                 i = i + 1
              end do
              ! compute (l**t \ b) -> b   [ l**t \ (d \ (l \p**t * b) ) ]
              call stdlib_${ci}$trsm('L', 'L', 'T', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! p * b  [ p * (l**t \ (d \ (l \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! end lower
           end if
           return
     end subroutine stdlib_${ci}$sytrs_3

#:endif
#:endfor





     module pure subroutine stdlib_sspcon( uplo, n, ap, ipiv, anorm, rcond, work, iwork,info )
     !! SSPCON estimates the reciprocal of the condition number (in the
     !! 1-norm) of a real symmetric packed matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by SSPTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(in) :: ap(*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, ip, kase
           real(sp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( anorm<zero ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSPCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              ip = n*( n+1 ) / 2
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip - i
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              ip = 1
              do i = 1, n
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip + n - i + 1
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_slacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_ssptrs( uplo, n, 1, ap, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_sspcon

     module pure subroutine stdlib_dspcon( uplo, n, ap, ipiv, anorm, rcond, work, iwork,info )
     !! DSPCON estimates the reciprocal of the condition number (in the
     !! 1-norm) of a real symmetric packed matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by DSPTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(dp), intent(in) :: anorm
           real(dp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(in) :: ap(*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, ip, kase
           real(dp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( anorm<zero ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              ip = n*( n+1 ) / 2
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip - i
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              ip = 1
              do i = 1, n
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip + n - i + 1
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_dlacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_dsptrs( uplo, n, 1, ap, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_dspcon

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$spcon( uplo, n, ap, ipiv, anorm, rcond, work, iwork,info )
     !! DSPCON: estimates the reciprocal of the condition number (in the
     !! 1-norm) of a real symmetric packed matrix A using the factorization
     !! A = U*D*U**T or A = L*D*L**T computed by DSPTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(${rk}$), intent(in) :: anorm
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: ap(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, ip, kase
           real(${rk}$) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( anorm<zero ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              ip = n*( n+1 ) / 2
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip - i
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              ip = 1
              do i = 1, n
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip + n - i + 1
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_${ri}$lacn2( n, work( n+1 ), work, iwork, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_${ri}$sptrs( uplo, n, 1, ap, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_${ri}$spcon

#:endif
#:endfor

     module pure subroutine stdlib_cspcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
     !! CSPCON estimates the reciprocal of the condition number (in the
     !! 1-norm) of a complex symmetric packed matrix A using the
     !! factorization A = U*D*U**T or A = L*D*L**T computed by CSPTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: ap(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, ip, kase
           real(sp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( anorm<zero ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSPCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              ip = n*( n+1 ) / 2
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip - i
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              ip = 1
              do i = 1, n
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip + n - i + 1
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_csptrs( uplo, n, 1, ap, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_cspcon

     module pure subroutine stdlib_zspcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
     !! ZSPCON estimates the reciprocal of the condition number (in the
     !! 1-norm) of a complex symmetric packed matrix A using the
     !! factorization A = U*D*U**T or A = L*D*L**T computed by ZSPTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(dp), intent(in) :: anorm
           real(dp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: ap(*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, ip, kase
           real(dp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( anorm<zero ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSPCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              ip = n*( n+1 ) / 2
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip - i
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              ip = 1
              do i = 1, n
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip + n - i + 1
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_zlacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_zsptrs( uplo, n, 1, ap, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_zspcon

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$spcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
     !! ZSPCON: estimates the reciprocal of the condition number (in the
     !! 1-norm) of a complex symmetric packed matrix A using the
     !! factorization A = U*D*U**T or A = L*D*L**T computed by ZSPTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(${ck}$), intent(in) :: anorm
           real(${ck}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: ap(*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, ip, kase
           real(${ck}$) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( anorm<zero ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSPCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              ip = n*( n+1 ) / 2
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip - i
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              ip = 1
              do i = 1, n
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip + n - i + 1
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_${ci}$lacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**t) or inv(u*d*u**t).
              call stdlib_${ci}$sptrs( uplo, n, 1, ap, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_${ci}$spcon

#:endif
#:endfor









     module pure subroutine stdlib_ssptrf( uplo, n, ap, ipiv, info )
     !! SSPTRF computes the factorization of a real symmetric matrix A stored
     !! in packed format using the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: ap(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kc, kk, knc, kp, kpc, kstep, kx, npp
           real(sp) :: absakk, alpha, colmax, d11, d12, d21, d22, r1, rowmax, t, wk, wkm1, &
                     wkp1
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSPTRF', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              kc = ( n-1 )*n / 2 + 1
              10 continue
              knc = kc
              ! if k < 1, exit from loop
              if( k<1 )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( ap( kc+k-1 ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k>1 ) then
                 imax = stdlib_isamax( k-1, ap( kc ), 1 )
                 colmax = abs( ap( kc+imax-1 ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    rowmax = zero
                    jmax = imax
                    kx = imax*( imax+1 ) / 2 + imax
                    do j = imax + 1, k
                       if( abs( ap( kx ) )>rowmax ) then
                          rowmax = abs( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + j
                    end do
                    kpc = ( imax-1 )*imax / 2 + 1
                    if( imax>1 ) then
                       jmax = stdlib_isamax( imax-1, ap( kpc ), 1 )
                       rowmax = max( rowmax, abs( ap( kpc+jmax-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( ap( kpc+imax-1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kstep==2 )knc = knc - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_sswap( kp-1, ap( knc ), 1, ap( kpc ), 1 )
                    kx = kpc + kp - 1
                    do j = kp + 1, kk - 1
                       kx = kx + j - 1
                       t = ap( knc+j-1 )
                       ap( knc+j-1 ) = ap( kx )
                       ap( kx ) = t
                    end do
                    t = ap( knc+kk-1 )
                    ap( knc+kk-1 ) = ap( kpc+kp-1 )
                    ap( kpc+kp-1 ) = t
                    if( kstep==2 ) then
                       t = ap( kc+k-2 )
                       ap( kc+k-2 ) = ap( kc+kp-1 )
                       ap( kc+kp-1 ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**t = a - w(k)*1/d(k)*w(k)**t
                    r1 = one / ap( kc+k-1 )
                    call stdlib_sspr( uplo, k-1, -r1, ap( kc ), 1, ap )
                    ! store u(k) in column k
                    call stdlib_sscal( k-1, r1, ap( kc ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**t
                    if( k>2 ) then
                       d12 = ap( k-1+( k-1 )*k / 2 )
                       d22 = ap( k-1+( k-2 )*( k-1 ) / 2 ) / d12
                       d11 = ap( k+( k-1 )*k / 2 ) / d12
                       t = one / ( d11*d22-one )
                       d12 = t / d12
                       do j = k - 2, 1, -1
                          wkm1 = d12*( d11*ap( j+( k-2 )*( k-1 ) / 2 )-ap( j+( k-1 )*k / 2 ) )
                                    
                          wk = d12*( d22*ap( j+( k-1 )*k / 2 )-ap( j+( k-2 )*( k-1 ) / 2 ) )
                                    
                          do i = j, 1, -1
                             ap( i+( j-1 )*j / 2 ) = ap( i+( j-1 )*j / 2 ) -ap( i+( k-1 )*k / 2 )&
                                       *wk -ap( i+( k-2 )*( k-1 ) / 2 )*wkm1
                          end do
                          ap( j+( k-1 )*k / 2 ) = wk
                          ap( j+( k-2 )*( k-1 ) / 2 ) = wkm1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              kc = knc - k
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              kc = 1
              npp = n*( n+1 ) / 2
              60 continue
              knc = kc
              ! if k > n, exit from loop
              if( k>n )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( ap( kc ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k<n ) then
                 imax = k + stdlib_isamax( n-k, ap( kc+1 ), 1 )
                 colmax = abs( ap( kc+imax-k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    rowmax = zero
                    kx = kc + imax - k
                    do j = k, imax - 1
                       if( abs( ap( kx ) )>rowmax ) then
                          rowmax = abs( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + n - j
                    end do
                    kpc = npp - ( n-imax+1 )*( n-imax+2 ) / 2 + 1
                    if( imax<n ) then
                       jmax = imax + stdlib_isamax( n-imax, ap( kpc+1 ), 1 )
                       rowmax = max( rowmax, abs( ap( kpc+jmax-imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( ap( kpc ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kstep==2 )knc = knc + n - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_sswap( n-kp, ap( knc+kp-kk+1 ), 1, ap( kpc+1 ),1 )
                              
                    kx = knc + kp - kk
                    do j = kk + 1, kp - 1
                       kx = kx + n - j + 1
                       t = ap( knc+j-kk )
                       ap( knc+j-kk ) = ap( kx )
                       ap( kx ) = t
                    end do
                    t = ap( knc )
                    ap( knc ) = ap( kpc )
                    ap( kpc ) = t
                    if( kstep==2 ) then
                       t = ap( kc+1 )
                       ap( kc+1 ) = ap( kc+kp-k )
                       ap( kc+kp-k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**t = a - w(k)*(1/d(k))*w(k)**t
                       r1 = one / ap( kc )
                       call stdlib_sspr( uplo, n-k, -r1, ap( kc+1 ), 1,ap( kc+n-k+1 ) )
                       ! store l(k) in column k
                       call stdlib_sscal( n-k, r1, ap( kc+1 ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**t
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**t
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d21 = ap( k+1+( k-1 )*( 2*n-k ) / 2 )
                       d11 = ap( k+1+k*( 2*n-k-1 ) / 2 ) / d21
                       d22 = ap( k+( k-1 )*( 2*n-k ) / 2 ) / d21
                       t = one / ( d11*d22-one )
                       d21 = t / d21
                       do j = k + 2, n
                          wk = d21*( d11*ap( j+( k-1 )*( 2*n-k ) / 2 )-ap( j+k*( 2*n-k-1 ) / 2 ) )
                                    
                          wkp1 = d21*( d22*ap( j+k*( 2*n-k-1 ) / 2 )-ap( j+( k-1 )*( 2*n-k ) / 2 )&
                                     )
                          do i = j, n
                             ap( i+( j-1 )*( 2*n-j ) / 2 ) = ap( i+( j-1 )*( 2*n-j ) / 2 ) - ap( &
                                       i+( k-1 )*( 2*n-k ) /2 )*wk - ap( i+k*( 2*n-k-1 ) / 2 )*wkp1
                          end do
                          ap( j+( k-1 )*( 2*n-k ) / 2 ) = wk
                          ap( j+k*( 2*n-k-1 ) / 2 ) = wkp1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              kc = knc + n - k + 2
              go to 60
           end if
           110 continue
           return
     end subroutine stdlib_ssptrf

     module pure subroutine stdlib_dsptrf( uplo, n, ap, ipiv, info )
     !! DSPTRF computes the factorization of a real symmetric matrix A stored
     !! in packed format using the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: ap(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kc, kk, knc, kp, kpc, kstep, kx, npp
           real(dp) :: absakk, alpha, colmax, d11, d12, d21, d22, r1, rowmax, t, wk, wkm1, &
                     wkp1
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPTRF', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              kc = ( n-1 )*n / 2 + 1
              10 continue
              knc = kc
              ! if k < 1, exit from loop
              if( k<1 )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( ap( kc+k-1 ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k>1 ) then
                 imax = stdlib_idamax( k-1, ap( kc ), 1 )
                 colmax = abs( ap( kc+imax-1 ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    rowmax = zero
                    jmax = imax
                    kx = imax*( imax+1 ) / 2 + imax
                    do j = imax + 1, k
                       if( abs( ap( kx ) )>rowmax ) then
                          rowmax = abs( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + j
                    end do
                    kpc = ( imax-1 )*imax / 2 + 1
                    if( imax>1 ) then
                       jmax = stdlib_idamax( imax-1, ap( kpc ), 1 )
                       rowmax = max( rowmax, abs( ap( kpc+jmax-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( ap( kpc+imax-1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kstep==2 )knc = knc - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_dswap( kp-1, ap( knc ), 1, ap( kpc ), 1 )
                    kx = kpc + kp - 1
                    do j = kp + 1, kk - 1
                       kx = kx + j - 1
                       t = ap( knc+j-1 )
                       ap( knc+j-1 ) = ap( kx )
                       ap( kx ) = t
                    end do
                    t = ap( knc+kk-1 )
                    ap( knc+kk-1 ) = ap( kpc+kp-1 )
                    ap( kpc+kp-1 ) = t
                    if( kstep==2 ) then
                       t = ap( kc+k-2 )
                       ap( kc+k-2 ) = ap( kc+kp-1 )
                       ap( kc+kp-1 ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**t = a - w(k)*1/d(k)*w(k)**t
                    r1 = one / ap( kc+k-1 )
                    call stdlib_dspr( uplo, k-1, -r1, ap( kc ), 1, ap )
                    ! store u(k) in column k
                    call stdlib_dscal( k-1, r1, ap( kc ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**t
                    if( k>2 ) then
                       d12 = ap( k-1+( k-1 )*k / 2 )
                       d22 = ap( k-1+( k-2 )*( k-1 ) / 2 ) / d12
                       d11 = ap( k+( k-1 )*k / 2 ) / d12
                       t = one / ( d11*d22-one )
                       d12 = t / d12
                       do j = k - 2, 1, -1
                          wkm1 = d12*( d11*ap( j+( k-2 )*( k-1 ) / 2 )-ap( j+( k-1 )*k / 2 ) )
                                    
                          wk = d12*( d22*ap( j+( k-1 )*k / 2 )-ap( j+( k-2 )*( k-1 ) / 2 ) )
                                    
                          do i = j, 1, -1
                             ap( i+( j-1 )*j / 2 ) = ap( i+( j-1 )*j / 2 ) -ap( i+( k-1 )*k / 2 )&
                                       *wk -ap( i+( k-2 )*( k-1 ) / 2 )*wkm1
                          end do
                          ap( j+( k-1 )*k / 2 ) = wk
                          ap( j+( k-2 )*( k-1 ) / 2 ) = wkm1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              kc = knc - k
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              kc = 1
              npp = n*( n+1 ) / 2
              60 continue
              knc = kc
              ! if k > n, exit from loop
              if( k>n )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( ap( kc ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k<n ) then
                 imax = k + stdlib_idamax( n-k, ap( kc+1 ), 1 )
                 colmax = abs( ap( kc+imax-k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    rowmax = zero
                    kx = kc + imax - k
                    do j = k, imax - 1
                       if( abs( ap( kx ) )>rowmax ) then
                          rowmax = abs( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + n - j
                    end do
                    kpc = npp - ( n-imax+1 )*( n-imax+2 ) / 2 + 1
                    if( imax<n ) then
                       jmax = imax + stdlib_idamax( n-imax, ap( kpc+1 ), 1 )
                       rowmax = max( rowmax, abs( ap( kpc+jmax-imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( ap( kpc ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kstep==2 )knc = knc + n - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_dswap( n-kp, ap( knc+kp-kk+1 ), 1, ap( kpc+1 ),1 )
                              
                    kx = knc + kp - kk
                    do j = kk + 1, kp - 1
                       kx = kx + n - j + 1
                       t = ap( knc+j-kk )
                       ap( knc+j-kk ) = ap( kx )
                       ap( kx ) = t
                    end do
                    t = ap( knc )
                    ap( knc ) = ap( kpc )
                    ap( kpc ) = t
                    if( kstep==2 ) then
                       t = ap( kc+1 )
                       ap( kc+1 ) = ap( kc+kp-k )
                       ap( kc+kp-k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**t = a - w(k)*(1/d(k))*w(k)**t
                       r1 = one / ap( kc )
                       call stdlib_dspr( uplo, n-k, -r1, ap( kc+1 ), 1,ap( kc+n-k+1 ) )
                       ! store l(k) in column k
                       call stdlib_dscal( n-k, r1, ap( kc+1 ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**t
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**t
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d21 = ap( k+1+( k-1 )*( 2*n-k ) / 2 )
                       d11 = ap( k+1+k*( 2*n-k-1 ) / 2 ) / d21
                       d22 = ap( k+( k-1 )*( 2*n-k ) / 2 ) / d21
                       t = one / ( d11*d22-one )
                       d21 = t / d21
                       do j = k + 2, n
                          wk = d21*( d11*ap( j+( k-1 )*( 2*n-k ) / 2 )-ap( j+k*( 2*n-k-1 ) / 2 ) )
                                    
                          wkp1 = d21*( d22*ap( j+k*( 2*n-k-1 ) / 2 )-ap( j+( k-1 )*( 2*n-k ) / 2 )&
                                     )
                          do i = j, n
                             ap( i+( j-1 )*( 2*n-j ) / 2 ) = ap( i+( j-1 )*( 2*n-j ) / 2 ) - ap( &
                                       i+( k-1 )*( 2*n-k ) /2 )*wk - ap( i+k*( 2*n-k-1 ) / 2 )*wkp1
                          end do
                          ap( j+( k-1 )*( 2*n-k ) / 2 ) = wk
                          ap( j+k*( 2*n-k-1 ) / 2 ) = wkp1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              kc = knc + n - k + 2
              go to 60
           end if
           110 continue
           return
     end subroutine stdlib_dsptrf

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sptrf( uplo, n, ap, ipiv, info )
     !! DSPTRF: computes the factorization of a real symmetric matrix A stored
     !! in packed format using the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: ap(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sevten = 17.0e+0_${rk}$
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kc, kk, knc, kp, kpc, kstep, kx, npp
           real(${rk}$) :: absakk, alpha, colmax, d11, d12, d21, d22, r1, rowmax, t, wk, wkm1, &
                     wkp1
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPTRF', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              kc = ( n-1 )*n / 2 + 1
              10 continue
              knc = kc
              ! if k < 1, exit from loop
              if( k<1 )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( ap( kc+k-1 ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k>1 ) then
                 imax = stdlib_i${ri}$amax( k-1, ap( kc ), 1 )
                 colmax = abs( ap( kc+imax-1 ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    rowmax = zero
                    jmax = imax
                    kx = imax*( imax+1 ) / 2 + imax
                    do j = imax + 1, k
                       if( abs( ap( kx ) )>rowmax ) then
                          rowmax = abs( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + j
                    end do
                    kpc = ( imax-1 )*imax / 2 + 1
                    if( imax>1 ) then
                       jmax = stdlib_i${ri}$amax( imax-1, ap( kpc ), 1 )
                       rowmax = max( rowmax, abs( ap( kpc+jmax-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( ap( kpc+imax-1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kstep==2 )knc = knc - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_${ri}$swap( kp-1, ap( knc ), 1, ap( kpc ), 1 )
                    kx = kpc + kp - 1
                    do j = kp + 1, kk - 1
                       kx = kx + j - 1
                       t = ap( knc+j-1 )
                       ap( knc+j-1 ) = ap( kx )
                       ap( kx ) = t
                    end do
                    t = ap( knc+kk-1 )
                    ap( knc+kk-1 ) = ap( kpc+kp-1 )
                    ap( kpc+kp-1 ) = t
                    if( kstep==2 ) then
                       t = ap( kc+k-2 )
                       ap( kc+k-2 ) = ap( kc+kp-1 )
                       ap( kc+kp-1 ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**t = a - w(k)*1/d(k)*w(k)**t
                    r1 = one / ap( kc+k-1 )
                    call stdlib_${ri}$spr( uplo, k-1, -r1, ap( kc ), 1, ap )
                    ! store u(k) in column k
                    call stdlib_${ri}$scal( k-1, r1, ap( kc ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**t
                    if( k>2 ) then
                       d12 = ap( k-1+( k-1 )*k / 2 )
                       d22 = ap( k-1+( k-2 )*( k-1 ) / 2 ) / d12
                       d11 = ap( k+( k-1 )*k / 2 ) / d12
                       t = one / ( d11*d22-one )
                       d12 = t / d12
                       do j = k - 2, 1, -1
                          wkm1 = d12*( d11*ap( j+( k-2 )*( k-1 ) / 2 )-ap( j+( k-1 )*k / 2 ) )
                                    
                          wk = d12*( d22*ap( j+( k-1 )*k / 2 )-ap( j+( k-2 )*( k-1 ) / 2 ) )
                                    
                          do i = j, 1, -1
                             ap( i+( j-1 )*j / 2 ) = ap( i+( j-1 )*j / 2 ) -ap( i+( k-1 )*k / 2 )&
                                       *wk -ap( i+( k-2 )*( k-1 ) / 2 )*wkm1
                          end do
                          ap( j+( k-1 )*k / 2 ) = wk
                          ap( j+( k-2 )*( k-1 ) / 2 ) = wkm1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              kc = knc - k
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              kc = 1
              npp = n*( n+1 ) / 2
              60 continue
              knc = kc
              ! if k > n, exit from loop
              if( k>n )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( ap( kc ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k<n ) then
                 imax = k + stdlib_i${ri}$amax( n-k, ap( kc+1 ), 1 )
                 colmax = abs( ap( kc+imax-k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    rowmax = zero
                    kx = kc + imax - k
                    do j = k, imax - 1
                       if( abs( ap( kx ) )>rowmax ) then
                          rowmax = abs( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + n - j
                    end do
                    kpc = npp - ( n-imax+1 )*( n-imax+2 ) / 2 + 1
                    if( imax<n ) then
                       jmax = imax + stdlib_i${ri}$amax( n-imax, ap( kpc+1 ), 1 )
                       rowmax = max( rowmax, abs( ap( kpc+jmax-imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( ap( kpc ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kstep==2 )knc = knc + n - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_${ri}$swap( n-kp, ap( knc+kp-kk+1 ), 1, ap( kpc+1 ),1 )
                              
                    kx = knc + kp - kk
                    do j = kk + 1, kp - 1
                       kx = kx + n - j + 1
                       t = ap( knc+j-kk )
                       ap( knc+j-kk ) = ap( kx )
                       ap( kx ) = t
                    end do
                    t = ap( knc )
                    ap( knc ) = ap( kpc )
                    ap( kpc ) = t
                    if( kstep==2 ) then
                       t = ap( kc+1 )
                       ap( kc+1 ) = ap( kc+kp-k )
                       ap( kc+kp-k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**t = a - w(k)*(1/d(k))*w(k)**t
                       r1 = one / ap( kc )
                       call stdlib_${ri}$spr( uplo, n-k, -r1, ap( kc+1 ), 1,ap( kc+n-k+1 ) )
                       ! store l(k) in column k
                       call stdlib_${ri}$scal( n-k, r1, ap( kc+1 ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**t
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**t
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d21 = ap( k+1+( k-1 )*( 2*n-k ) / 2 )
                       d11 = ap( k+1+k*( 2*n-k-1 ) / 2 ) / d21
                       d22 = ap( k+( k-1 )*( 2*n-k ) / 2 ) / d21
                       t = one / ( d11*d22-one )
                       d21 = t / d21
                       do j = k + 2, n
                          wk = d21*( d11*ap( j+( k-1 )*( 2*n-k ) / 2 )-ap( j+k*( 2*n-k-1 ) / 2 ) )
                                    
                          wkp1 = d21*( d22*ap( j+k*( 2*n-k-1 ) / 2 )-ap( j+( k-1 )*( 2*n-k ) / 2 )&
                                     )
                          do i = j, n
                             ap( i+( j-1 )*( 2*n-j ) / 2 ) = ap( i+( j-1 )*( 2*n-j ) / 2 ) - ap( &
                                       i+( k-1 )*( 2*n-k ) /2 )*wk - ap( i+k*( 2*n-k-1 ) / 2 )*wkp1
                          end do
                          ap( j+( k-1 )*( 2*n-k ) / 2 ) = wk
                          ap( j+k*( 2*n-k-1 ) / 2 ) = wkp1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              kc = knc + n - k + 2
              go to 60
           end if
           110 continue
           return
     end subroutine stdlib_${ri}$sptrf

#:endif
#:endfor

     module pure subroutine stdlib_csptrf( uplo, n, ap, ipiv, info )
     !! CSPTRF computes the factorization of a complex symmetric matrix A
     !! stored in packed format using the Bunch-Kaufman diagonal pivoting
     !! method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: ap(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kc, kk, knc, kp, kpc, kstep, kx, npp
           real(sp) :: absakk, alpha, colmax, rowmax
           complex(sp) :: d11, d12, d21, d22, r1, t, wk, wkm1, wkp1, zdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSPTRF', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              kc = ( n-1 )*n / 2 + 1
              10 continue
              knc = kc
              ! if k < 1, exit from loop
              if( k<1 )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( ap( kc+k-1 ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, ap( kc ), 1 )
                 colmax = cabs1( ap( kc+imax-1 ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    rowmax = zero
                    jmax = imax
                    kx = imax*( imax+1 ) / 2 + imax
                    do j = imax + 1, k
                       if( cabs1( ap( kx ) )>rowmax ) then
                          rowmax = cabs1( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + j
                    end do
                    kpc = ( imax-1 )*imax / 2 + 1
                    if( imax>1 ) then
                       jmax = stdlib_icamax( imax-1, ap( kpc ), 1 )
                       rowmax = max( rowmax, cabs1( ap( kpc+jmax-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( ap( kpc+imax-1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kstep==2 )knc = knc - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_cswap( kp-1, ap( knc ), 1, ap( kpc ), 1 )
                    kx = kpc + kp - 1
                    do j = kp + 1, kk - 1
                       kx = kx + j - 1
                       t = ap( knc+j-1 )
                       ap( knc+j-1 ) = ap( kx )
                       ap( kx ) = t
                    end do
                    t = ap( knc+kk-1 )
                    ap( knc+kk-1 ) = ap( kpc+kp-1 )
                    ap( kpc+kp-1 ) = t
                    if( kstep==2 ) then
                       t = ap( kc+k-2 )
                       ap( kc+k-2 ) = ap( kc+kp-1 )
                       ap( kc+kp-1 ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**t = a - w(k)*1/d(k)*w(k)**t
                    r1 = cone / ap( kc+k-1 )
                    call stdlib_cspr( uplo, k-1, -r1, ap( kc ), 1, ap )
                    ! store u(k) in column k
                    call stdlib_cscal( k-1, r1, ap( kc ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**t
                    if( k>2 ) then
                       d12 = ap( k-1+( k-1 )*k / 2 )
                       d22 = ap( k-1+( k-2 )*( k-1 ) / 2 ) / d12
                       d11 = ap( k+( k-1 )*k / 2 ) / d12
                       t = cone / ( d11*d22-cone )
                       d12 = t / d12
                       do j = k - 2, 1, -1
                          wkm1 = d12*( d11*ap( j+( k-2 )*( k-1 ) / 2 )-ap( j+( k-1 )*k / 2 ) )
                                    
                          wk = d12*( d22*ap( j+( k-1 )*k / 2 )-ap( j+( k-2 )*( k-1 ) / 2 ) )
                                    
                          do i = j, 1, -1
                             ap( i+( j-1 )*j / 2 ) = ap( i+( j-1 )*j / 2 ) -ap( i+( k-1 )*k / 2 )&
                                       *wk -ap( i+( k-2 )*( k-1 ) / 2 )*wkm1
                          end do
                          ap( j+( k-1 )*k / 2 ) = wk
                          ap( j+( k-2 )*( k-1 ) / 2 ) = wkm1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              kc = knc - k
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              kc = 1
              npp = n*( n+1 ) / 2
              60 continue
              knc = kc
              ! if k > n, exit from loop
              if( k>n )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( ap( kc ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, ap( kc+1 ), 1 )
                 colmax = cabs1( ap( kc+imax-k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    rowmax = zero
                    kx = kc + imax - k
                    do j = k, imax - 1
                       if( cabs1( ap( kx ) )>rowmax ) then
                          rowmax = cabs1( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + n - j
                    end do
                    kpc = npp - ( n-imax+1 )*( n-imax+2 ) / 2 + 1
                    if( imax<n ) then
                       jmax = imax + stdlib_icamax( n-imax, ap( kpc+1 ), 1 )
                       rowmax = max( rowmax, cabs1( ap( kpc+jmax-imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( ap( kpc ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kstep==2 )knc = knc + n - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_cswap( n-kp, ap( knc+kp-kk+1 ), 1, ap( kpc+1 ),1 )
                              
                    kx = knc + kp - kk
                    do j = kk + 1, kp - 1
                       kx = kx + n - j + 1
                       t = ap( knc+j-kk )
                       ap( knc+j-kk ) = ap( kx )
                       ap( kx ) = t
                    end do
                    t = ap( knc )
                    ap( knc ) = ap( kpc )
                    ap( kpc ) = t
                    if( kstep==2 ) then
                       t = ap( kc+1 )
                       ap( kc+1 ) = ap( kc+kp-k )
                       ap( kc+kp-k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**t = a - w(k)*(1/d(k))*w(k)**t
                       r1 = cone / ap( kc )
                       call stdlib_cspr( uplo, n-k, -r1, ap( kc+1 ), 1,ap( kc+n-k+1 ) )
                       ! store l(k) in column k
                       call stdlib_cscal( n-k, r1, ap( kc+1 ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**t
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**t
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d21 = ap( k+1+( k-1 )*( 2*n-k ) / 2 )
                       d11 = ap( k+1+k*( 2*n-k-1 ) / 2 ) / d21
                       d22 = ap( k+( k-1 )*( 2*n-k ) / 2 ) / d21
                       t = cone / ( d11*d22-cone )
                       d21 = t / d21
                       do j = k + 2, n
                          wk = d21*( d11*ap( j+( k-1 )*( 2*n-k ) / 2 )-ap( j+k*( 2*n-k-1 ) / 2 ) )
                                    
                          wkp1 = d21*( d22*ap( j+k*( 2*n-k-1 ) / 2 )-ap( j+( k-1 )*( 2*n-k ) / 2 )&
                                     )
                          do i = j, n
                             ap( i+( j-1 )*( 2*n-j ) / 2 ) = ap( i+( j-1 )*( 2*n-j ) / 2 ) - ap( &
                                       i+( k-1 )*( 2*n-k ) /2 )*wk - ap( i+k*( 2*n-k-1 ) / 2 )*wkp1
                          end do
                          ap( j+( k-1 )*( 2*n-k ) / 2 ) = wk
                          ap( j+k*( 2*n-k-1 ) / 2 ) = wkp1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              kc = knc + n - k + 2
              go to 60
           end if
           110 continue
           return
     end subroutine stdlib_csptrf

     module pure subroutine stdlib_zsptrf( uplo, n, ap, ipiv, info )
     !! ZSPTRF computes the factorization of a complex symmetric matrix A
     !! stored in packed format using the Bunch-Kaufman diagonal pivoting
     !! method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: ap(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kc, kk, knc, kp, kpc, kstep, kx, npp
           real(dp) :: absakk, alpha, colmax, rowmax
           complex(dp) :: d11, d12, d21, d22, r1, t, wk, wkm1, wkp1, zdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=dp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSPTRF', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              kc = ( n-1 )*n / 2 + 1
              10 continue
              knc = kc
              ! if k < 1, exit from loop
              if( k<1 )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( ap( kc+k-1 ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k>1 ) then
                 imax = stdlib_izamax( k-1, ap( kc ), 1 )
                 colmax = cabs1( ap( kc+imax-1 ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    rowmax = zero
                    jmax = imax
                    kx = imax*( imax+1 ) / 2 + imax
                    do j = imax + 1, k
                       if( cabs1( ap( kx ) )>rowmax ) then
                          rowmax = cabs1( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + j
                    end do
                    kpc = ( imax-1 )*imax / 2 + 1
                    if( imax>1 ) then
                       jmax = stdlib_izamax( imax-1, ap( kpc ), 1 )
                       rowmax = max( rowmax, cabs1( ap( kpc+jmax-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( ap( kpc+imax-1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kstep==2 )knc = knc - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_zswap( kp-1, ap( knc ), 1, ap( kpc ), 1 )
                    kx = kpc + kp - 1
                    do j = kp + 1, kk - 1
                       kx = kx + j - 1
                       t = ap( knc+j-1 )
                       ap( knc+j-1 ) = ap( kx )
                       ap( kx ) = t
                    end do
                    t = ap( knc+kk-1 )
                    ap( knc+kk-1 ) = ap( kpc+kp-1 )
                    ap( kpc+kp-1 ) = t
                    if( kstep==2 ) then
                       t = ap( kc+k-2 )
                       ap( kc+k-2 ) = ap( kc+kp-1 )
                       ap( kc+kp-1 ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**t = a - w(k)*1/d(k)*w(k)**t
                    r1 = cone / ap( kc+k-1 )
                    call stdlib_zspr( uplo, k-1, -r1, ap( kc ), 1, ap )
                    ! store u(k) in column k
                    call stdlib_zscal( k-1, r1, ap( kc ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**t
                    if( k>2 ) then
                       d12 = ap( k-1+( k-1 )*k / 2 )
                       d22 = ap( k-1+( k-2 )*( k-1 ) / 2 ) / d12
                       d11 = ap( k+( k-1 )*k / 2 ) / d12
                       t = cone / ( d11*d22-cone )
                       d12 = t / d12
                       do j = k - 2, 1, -1
                          wkm1 = d12*( d11*ap( j+( k-2 )*( k-1 ) / 2 )-ap( j+( k-1 )*k / 2 ) )
                                    
                          wk = d12*( d22*ap( j+( k-1 )*k / 2 )-ap( j+( k-2 )*( k-1 ) / 2 ) )
                                    
                          do i = j, 1, -1
                             ap( i+( j-1 )*j / 2 ) = ap( i+( j-1 )*j / 2 ) -ap( i+( k-1 )*k / 2 )&
                                       *wk -ap( i+( k-2 )*( k-1 ) / 2 )*wkm1
                          end do
                          ap( j+( k-1 )*k / 2 ) = wk
                          ap( j+( k-2 )*( k-1 ) / 2 ) = wkm1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              kc = knc - k
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              kc = 1
              npp = n*( n+1 ) / 2
              60 continue
              knc = kc
              ! if k > n, exit from loop
              if( k>n )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( ap( kc ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k<n ) then
                 imax = k + stdlib_izamax( n-k, ap( kc+1 ), 1 )
                 colmax = cabs1( ap( kc+imax-k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    rowmax = zero
                    kx = kc + imax - k
                    do j = k, imax - 1
                       if( cabs1( ap( kx ) )>rowmax ) then
                          rowmax = cabs1( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + n - j
                    end do
                    kpc = npp - ( n-imax+1 )*( n-imax+2 ) / 2 + 1
                    if( imax<n ) then
                       jmax = imax + stdlib_izamax( n-imax, ap( kpc+1 ), 1 )
                       rowmax = max( rowmax, cabs1( ap( kpc+jmax-imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( ap( kpc ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kstep==2 )knc = knc + n - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_zswap( n-kp, ap( knc+kp-kk+1 ), 1, ap( kpc+1 ),1 )
                              
                    kx = knc + kp - kk
                    do j = kk + 1, kp - 1
                       kx = kx + n - j + 1
                       t = ap( knc+j-kk )
                       ap( knc+j-kk ) = ap( kx )
                       ap( kx ) = t
                    end do
                    t = ap( knc )
                    ap( knc ) = ap( kpc )
                    ap( kpc ) = t
                    if( kstep==2 ) then
                       t = ap( kc+1 )
                       ap( kc+1 ) = ap( kc+kp-k )
                       ap( kc+kp-k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**t = a - w(k)*(1/d(k))*w(k)**t
                       r1 = cone / ap( kc )
                       call stdlib_zspr( uplo, n-k, -r1, ap( kc+1 ), 1,ap( kc+n-k+1 ) )
                       ! store l(k) in column k
                       call stdlib_zscal( n-k, r1, ap( kc+1 ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**t
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**t
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d21 = ap( k+1+( k-1 )*( 2*n-k ) / 2 )
                       d11 = ap( k+1+k*( 2*n-k-1 ) / 2 ) / d21
                       d22 = ap( k+( k-1 )*( 2*n-k ) / 2 ) / d21
                       t = cone / ( d11*d22-cone )
                       d21 = t / d21
                       do j = k + 2, n
                          wk = d21*( d11*ap( j+( k-1 )*( 2*n-k ) / 2 )-ap( j+k*( 2*n-k-1 ) / 2 ) )
                                    
                          wkp1 = d21*( d22*ap( j+k*( 2*n-k-1 ) / 2 )-ap( j+( k-1 )*( 2*n-k ) / 2 )&
                                     )
                          do i = j, n
                             ap( i+( j-1 )*( 2*n-j ) / 2 ) = ap( i+( j-1 )*( 2*n-j ) / 2 ) - ap( &
                                       i+( k-1 )*( 2*n-k ) /2 )*wk - ap( i+k*( 2*n-k-1 ) / 2 )*wkp1
                          end do
                          ap( j+( k-1 )*( 2*n-k ) / 2 ) = wk
                          ap( j+k*( 2*n-k-1 ) / 2 ) = wkp1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              kc = knc + n - k + 2
              go to 60
           end if
           110 continue
           return
     end subroutine stdlib_zsptrf

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sptrf( uplo, n, ap, ipiv, info )
     !! ZSPTRF: computes the factorization of a complex symmetric matrix A
     !! stored in packed format using the Bunch-Kaufman diagonal pivoting
     !! method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: ap(*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: sevten = 17.0e+0_${ck}$
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kc, kk, knc, kp, kpc, kstep, kx, npp
           real(${ck}$) :: absakk, alpha, colmax, rowmax
           complex(${ck}$) :: d11, d12, d21, d22, r1, t, wk, wkm1, wkp1, zdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=${ck}$) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSPTRF', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              kc = ( n-1 )*n / 2 + 1
              10 continue
              knc = kc
              ! if k < 1, exit from loop
              if( k<1 )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( ap( kc+k-1 ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k>1 ) then
                 imax = stdlib_i${ci}$amax( k-1, ap( kc ), 1 )
                 colmax = cabs1( ap( kc+imax-1 ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    rowmax = zero
                    jmax = imax
                    kx = imax*( imax+1 ) / 2 + imax
                    do j = imax + 1, k
                       if( cabs1( ap( kx ) )>rowmax ) then
                          rowmax = cabs1( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + j
                    end do
                    kpc = ( imax-1 )*imax / 2 + 1
                    if( imax>1 ) then
                       jmax = stdlib_i${ci}$amax( imax-1, ap( kpc ), 1 )
                       rowmax = max( rowmax, cabs1( ap( kpc+jmax-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( ap( kpc+imax-1 ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kstep==2 )knc = knc - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_${ci}$swap( kp-1, ap( knc ), 1, ap( kpc ), 1 )
                    kx = kpc + kp - 1
                    do j = kp + 1, kk - 1
                       kx = kx + j - 1
                       t = ap( knc+j-1 )
                       ap( knc+j-1 ) = ap( kx )
                       ap( kx ) = t
                    end do
                    t = ap( knc+kk-1 )
                    ap( knc+kk-1 ) = ap( kpc+kp-1 )
                    ap( kpc+kp-1 ) = t
                    if( kstep==2 ) then
                       t = ap( kc+k-2 )
                       ap( kc+k-2 ) = ap( kc+kp-1 )
                       ap( kc+kp-1 ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**t = a - w(k)*1/d(k)*w(k)**t
                    r1 = cone / ap( kc+k-1 )
                    call stdlib_${ci}$spr( uplo, k-1, -r1, ap( kc ), 1, ap )
                    ! store u(k) in column k
                    call stdlib_${ci}$scal( k-1, r1, ap( kc ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**t
                    if( k>2 ) then
                       d12 = ap( k-1+( k-1 )*k / 2 )
                       d22 = ap( k-1+( k-2 )*( k-1 ) / 2 ) / d12
                       d11 = ap( k+( k-1 )*k / 2 ) / d12
                       t = cone / ( d11*d22-cone )
                       d12 = t / d12
                       do j = k - 2, 1, -1
                          wkm1 = d12*( d11*ap( j+( k-2 )*( k-1 ) / 2 )-ap( j+( k-1 )*k / 2 ) )
                                    
                          wk = d12*( d22*ap( j+( k-1 )*k / 2 )-ap( j+( k-2 )*( k-1 ) / 2 ) )
                                    
                          do i = j, 1, -1
                             ap( i+( j-1 )*j / 2 ) = ap( i+( j-1 )*j / 2 ) -ap( i+( k-1 )*k / 2 )&
                                       *wk -ap( i+( k-2 )*( k-1 ) / 2 )*wkm1
                          end do
                          ap( j+( k-1 )*k / 2 ) = wk
                          ap( j+( k-2 )*( k-1 ) / 2 ) = wkm1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              kc = knc - k
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              kc = 1
              npp = n*( n+1 ) / 2
              60 continue
              knc = kc
              ! if k > n, exit from loop
              if( k>n )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( ap( kc ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k<n ) then
                 imax = k + stdlib_i${ci}$amax( n-k, ap( kc+1 ), 1 )
                 colmax = cabs1( ap( kc+imax-k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    rowmax = zero
                    kx = kc + imax - k
                    do j = k, imax - 1
                       if( cabs1( ap( kx ) )>rowmax ) then
                          rowmax = cabs1( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + n - j
                    end do
                    kpc = npp - ( n-imax+1 )*( n-imax+2 ) / 2 + 1
                    if( imax<n ) then
                       jmax = imax + stdlib_i${ci}$amax( n-imax, ap( kpc+1 ), 1 )
                       rowmax = max( rowmax, cabs1( ap( kpc+jmax-imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( ap( kpc ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kstep==2 )knc = knc + n - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_${ci}$swap( n-kp, ap( knc+kp-kk+1 ), 1, ap( kpc+1 ),1 )
                              
                    kx = knc + kp - kk
                    do j = kk + 1, kp - 1
                       kx = kx + n - j + 1
                       t = ap( knc+j-kk )
                       ap( knc+j-kk ) = ap( kx )
                       ap( kx ) = t
                    end do
                    t = ap( knc )
                    ap( knc ) = ap( kpc )
                    ap( kpc ) = t
                    if( kstep==2 ) then
                       t = ap( kc+1 )
                       ap( kc+1 ) = ap( kc+kp-k )
                       ap( kc+kp-k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**t = a - w(k)*(1/d(k))*w(k)**t
                       r1 = cone / ap( kc )
                       call stdlib_${ci}$spr( uplo, n-k, -r1, ap( kc+1 ), 1,ap( kc+n-k+1 ) )
                       ! store l(k) in column k
                       call stdlib_${ci}$scal( n-k, r1, ap( kc+1 ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**t
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**t
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d21 = ap( k+1+( k-1 )*( 2*n-k ) / 2 )
                       d11 = ap( k+1+k*( 2*n-k-1 ) / 2 ) / d21
                       d22 = ap( k+( k-1 )*( 2*n-k ) / 2 ) / d21
                       t = cone / ( d11*d22-cone )
                       d21 = t / d21
                       do j = k + 2, n
                          wk = d21*( d11*ap( j+( k-1 )*( 2*n-k ) / 2 )-ap( j+k*( 2*n-k-1 ) / 2 ) )
                                    
                          wkp1 = d21*( d22*ap( j+k*( 2*n-k-1 ) / 2 )-ap( j+( k-1 )*( 2*n-k ) / 2 )&
                                     )
                          do i = j, n
                             ap( i+( j-1 )*( 2*n-j ) / 2 ) = ap( i+( j-1 )*( 2*n-j ) / 2 ) - ap( &
                                       i+( k-1 )*( 2*n-k ) /2 )*wk - ap( i+k*( 2*n-k-1 ) / 2 )*wkp1
                          end do
                          ap( j+( k-1 )*( 2*n-k ) / 2 ) = wk
                          ap( j+k*( 2*n-k-1 ) / 2 ) = wkp1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              kc = knc + n - k + 2
              go to 60
           end if
           110 continue
           return
     end subroutine stdlib_${ci}$sptrf

#:endif
#:endfor





     module pure subroutine stdlib_ssytrf( uplo, n, a, lda, ipiv, work, lwork, info )
     !! SSYTRF computes the factorization of a real symmetric matrix A using
     !! the Bunch-Kaufman diagonal pivoting method.  The form of the
     !! factorization is
     !! A = U**T*D*U  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'SSYTRF', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYTRF', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'SSYTRF', uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u**t*d*u using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_slasyf;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_slasyf( uplo, k, nb, kb, a, lda, ipiv, work, ldwork,iinfo )
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_ssytf2( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_slasyf;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_slasyf( uplo, n-k+1, nb, kb, a( k, k ), lda, ipiv( k ),work, ldwork, &
                           iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_ssytf2( uplo, n-k+1, a( k, k ), lda, ipiv( k ), iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_ssytrf

     module pure subroutine stdlib_dsytrf( uplo, n, a, lda, ipiv, work, lwork, info )
     !! DSYTRF computes the factorization of a real symmetric matrix A using
     !! the Bunch-Kaufman diagonal pivoting method.  The form of the
     !! factorization is
     !! A = U**T*D*U  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'DSYTRF', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRF', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'DSYTRF', uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u**t*d*u using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_dlasyf;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_dlasyf( uplo, k, nb, kb, a, lda, ipiv, work, ldwork,iinfo )
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_dsytf2( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_dlasyf;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_dlasyf( uplo, n-k+1, nb, kb, a( k, k ), lda, ipiv( k ),work, ldwork, &
                           iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_dsytf2( uplo, n-k+1, a( k, k ), lda, ipiv( k ), iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dsytrf

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sytrf( uplo, n, a, lda, ipiv, work, lwork, info )
     !! DSYTRF: computes the factorization of a real symmetric matrix A using
     !! the Bunch-Kaufman diagonal pivoting method.  The form of the
     !! factorization is
     !! A = U**T*D*U  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'DSYTRF', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRF', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'DSYTRF', uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u**t*d*u using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ri}$lasyf;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_${ri}$lasyf( uplo, k, nb, kb, a, lda, ipiv, work, ldwork,iinfo )
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_${ri}$sytf2( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ri}$lasyf;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_${ri}$lasyf( uplo, n-k+1, nb, kb, a( k, k ), lda, ipiv( k ),work, ldwork, &
                           iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_${ri}$sytf2( uplo, n-k+1, a( k, k ), lda, ipiv( k ), iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sytrf

#:endif
#:endfor

     module pure subroutine stdlib_csytrf( uplo, n, a, lda, ipiv, work, lwork, info )
     !! CSYTRF computes the factorization of a complex symmetric matrix A
     !! using the Bunch-Kaufman diagonal pivoting method.  The form of the
     !! factorization is
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'CSYTRF', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRF', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'CSYTRF', uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clasyf;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_clasyf( uplo, k, nb, kb, a, lda, ipiv, work, n, iinfo )
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_csytf2( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_clasyf;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_clasyf( uplo, n-k+1, nb, kb, a( k, k ), lda, ipiv( k ),work, n, &
                           iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_csytf2( uplo, n-k+1, a( k, k ), lda, ipiv( k ), iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csytrf

     module pure subroutine stdlib_zsytrf( uplo, n, a, lda, ipiv, work, lwork, info )
     !! ZSYTRF computes the factorization of a complex symmetric matrix A
     !! using the Bunch-Kaufman diagonal pivoting method.  The form of the
     !! factorization is
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'ZSYTRF', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRF', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'ZSYTRF', uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_zlasyf;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_zlasyf( uplo, k, nb, kb, a, lda, ipiv, work, n, iinfo )
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_zsytf2( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_zlasyf;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_zlasyf( uplo, n-k+1, nb, kb, a( k, k ), lda, ipiv( k ),work, n, &
                           iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_zsytf2( uplo, n-k+1, a( k, k ), lda, ipiv( k ), iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zsytrf

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sytrf( uplo, n, a, lda, ipiv, work, lwork, info )
     !! ZSYTRF: computes the factorization of a complex symmetric matrix A
     !! using the Bunch-Kaufman diagonal pivoting method.  The form of the
     !! factorization is
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: iinfo, iws, j, k, kb, ldwork, lwkopt, nb, nbmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              ! determine the block size
              nb = stdlib_ilaenv( 1, 'ZSYTRF', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRF', -info )
              return
           else if( lquery ) then
              return
           end if
           nbmin = 2
           ldwork = n
           if( nb>1 .and. nb<n ) then
              iws = ldwork*nb
              if( lwork<iws ) then
                 nb = max( lwork / ldwork, 1 )
                 nbmin = max( 2, stdlib_ilaenv( 2, 'ZSYTRF', uplo, n, -1, -1, -1 ) )
              end if
           else
              iws = 1
           end if
           if( nb<nbmin )nb = n
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ci}$lasyf;
              ! kb is either nb or nb-1, or k for the last block
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 40
              if( k>nb ) then
                 ! factorize columns k-kb+1:k of a and use blocked code to
                 ! update columns 1:k-kb
                 call stdlib_${ci}$lasyf( uplo, k, nb, kb, a, lda, ipiv, work, n, iinfo )
              else
                 ! use unblocked code to factorize columns 1:k of a
                 call stdlib_${ci}$sytf2( uplo, k, a, lda, ipiv, iinfo )
                 kb = k
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo
              ! decrease k and return to the start of the main loop
              k = k - kb
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! kb, where kb is the number of columns factorized by stdlib_${ci}$lasyf;
              ! kb is either nb or nb-1, or n-k+1 for the last block
              k = 1
              20 continue
              ! if k > n, exit from loop
              if( k>n )go to 40
              if( k<=n-nb ) then
                 ! factorize columns k:k+kb-1 of a and use blocked code to
                 ! update columns k+kb:n
                 call stdlib_${ci}$lasyf( uplo, n-k+1, nb, kb, a( k, k ), lda, ipiv( k ),work, n, &
                           iinfo )
              else
                 ! use unblocked code to factorize columns k:n of a
                 call stdlib_${ci}$sytf2( uplo, n-k+1, a( k, k ), lda, ipiv( k ), iinfo )
                 kb = n - k + 1
              end if
              ! set info on the first occurrence of a zero pivot
              if( info==0 .and. iinfo>0 )info = iinfo + k - 1
              ! adjust ipiv
              do j = k, k + kb - 1
                 if( ipiv( j )>0 ) then
                    ipiv( j ) = ipiv( j ) + k - 1
                 else
                    ipiv( j ) = ipiv( j ) - k + 1
                 end if
              end do
              ! increase k and return to the start of the main loop
              k = k + kb
              go to 20
           end if
           40 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$sytrf

#:endif
#:endfor



     module pure subroutine stdlib_ssyconv( uplo, way, n, a, lda, ipiv, e, info )
     !! SSYCONV convert A given by TRF into L and D and vice-versa.
     !! Get Non-diag elements of D (returned in workspace) and
     !! apply or reverse permutation done in TRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip, j
           real(sp) :: temp
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYCONV', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
            ! a is upper
            ! convert a (a is upper)
              ! convert value
              if ( convert ) then
                 i=n
                 e(1)=zero
                 do while ( i > 1 )
                    if( ipiv(i) < 0 ) then
                       e(i)=a(i-1,i)
                       e(i-1)=zero
                       a(i-1,i)=zero
                       i=i-1
                    else
                       e(i)=zero
                    endif
                    i=i-1
                 end do
              ! convert permutations
              i=n
              do while ( i >= 1 )
                 if( ipiv(i) > 0) then
                    ip=ipiv(i)
                    if( i < n) then
                       do j= i+1,n
                         temp=a(ip,j)
                         a(ip,j)=a(i,j)
                         a(i,j)=temp
                       end do
                    endif
                 else
                   ip=-ipiv(i)
                    if( i < n) then
                  do j= i+1,n
                      temp=a(ip,j)
                      a(ip,j)=a(i-1,j)
                      a(i-1,j)=temp
                  end do
                     endif
                     i=i-1
                endif
                i=i-1
             end do
              else
            ! revert a (a is upper)
              ! revert permutations
                 i=1
                 do while ( i <= n )
                    if( ipiv(i) > 0 ) then
                       ip=ipiv(i)
                       if( i < n) then
                       do j= i+1,n
                         temp=a(ip,j)
                         a(ip,j)=a(i,j)
                         a(i,j)=temp
                       end do
                       endif
                    else
                      ip=-ipiv(i)
                      i=i+1
                      if( i < n) then
                         do j= i+1,n
                            temp=a(ip,j)
                            a(ip,j)=a(i-1,j)
                            a(i-1,j)=temp
                         end do
                      endif
                    endif
                    i=i+1
                 end do
              ! revert value
                 i=n
                 do while ( i > 1 )
                    if( ipiv(i) < 0 ) then
                       a(i-1,i)=e(i)
                       i=i-1
                    endif
                    i=i-1
                 end do
              end if
           else
            ! a is lower
              if ( convert ) then
            ! convert a (a is lower)
              ! convert value
                 i=1
                 e(n)=zero
                 do while ( i <= n )
                    if( i<n .and. ipiv(i) < 0 ) then
                       e(i)=a(i+1,i)
                       e(i+1)=zero
                       a(i+1,i)=zero
                       i=i+1
                    else
                       e(i)=zero
                    endif
                    i=i+1
                 end do
              ! convert permutations
              i=1
              do while ( i <= n )
                 if( ipiv(i) > 0 ) then
                    ip=ipiv(i)
                    if (i > 1) then
                    do j= 1,i-1
                      temp=a(ip,j)
                      a(ip,j)=a(i,j)
                      a(i,j)=temp
                    end do
                    endif
                 else
                   ip=-ipiv(i)
                   if (i > 1) then
                   do j= 1,i-1
                      temp=a(ip,j)
                      a(ip,j)=a(i+1,j)
                      a(i+1,j)=temp
                   end do
                   endif
                   i=i+1
                endif
                i=i+1
             end do
              else
            ! revert a (a is lower)
              ! revert permutations
                 i=n
                 do while ( i >= 1 )
                    if( ipiv(i) > 0 ) then
                       ip=ipiv(i)
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(i,j)
                             a(i,j)=a(ip,j)
                             a(ip,j)=temp
                          end do
                       endif
                    else
                       ip=-ipiv(i)
                       i=i-1
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(i+1,j)
                             a(i+1,j)=a(ip,j)
                             a(ip,j)=temp
                          end do
                       endif
                    endif
                    i=i-1
                 end do
              ! revert value
                 i=1
                 do while ( i <= n-1 )
                    if( ipiv(i) < 0 ) then
                       a(i+1,i)=e(i)
                       i=i+1
                    endif
                    i=i+1
                 end do
              end if
           end if
           return
     end subroutine stdlib_ssyconv

     module pure subroutine stdlib_dsyconv( uplo, way, n, a, lda, ipiv, e, info )
     !! DSYCONV convert A given by TRF into L and D and vice-versa.
     !! Get Non-diag elements of D (returned in workspace) and
     !! apply or reverse permutation done in TRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip, j
           real(dp) :: temp
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYCONV', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
            ! a is upper
            ! convert a (a is upper)
              ! convert value
              if ( convert ) then
                 i=n
                 e(1)=zero
                 do while ( i > 1 )
                    if( ipiv(i) < 0 ) then
                       e(i)=a(i-1,i)
                       e(i-1)=zero
                       a(i-1,i)=zero
                       i=i-1
                    else
                       e(i)=zero
                    endif
                    i=i-1
                 end do
              ! convert permutations
              i=n
              do while ( i >= 1 )
                 if( ipiv(i) > 0) then
                    ip=ipiv(i)
                    if( i < n) then
                       do j= i+1,n
                         temp=a(ip,j)
                         a(ip,j)=a(i,j)
                         a(i,j)=temp
                       end do
                    endif
                 else
                   ip=-ipiv(i)
                    if( i < n) then
                  do j= i+1,n
                      temp=a(ip,j)
                      a(ip,j)=a(i-1,j)
                      a(i-1,j)=temp
                  end do
                     endif
                     i=i-1
                endif
                i=i-1
             end do
              else
            ! revert a (a is upper)
              ! revert permutations
                 i=1
                 do while ( i <= n )
                    if( ipiv(i) > 0 ) then
                       ip=ipiv(i)
                       if( i < n) then
                       do j= i+1,n
                         temp=a(ip,j)
                         a(ip,j)=a(i,j)
                         a(i,j)=temp
                       end do
                       endif
                    else
                      ip=-ipiv(i)
                      i=i+1
                      if( i < n) then
                         do j= i+1,n
                            temp=a(ip,j)
                            a(ip,j)=a(i-1,j)
                            a(i-1,j)=temp
                         end do
                      endif
                    endif
                    i=i+1
                 end do
              ! revert value
                 i=n
                 do while ( i > 1 )
                    if( ipiv(i) < 0 ) then
                       a(i-1,i)=e(i)
                       i=i-1
                    endif
                    i=i-1
                 end do
              end if
           else
            ! a is lower
              if ( convert ) then
            ! convert a (a is lower)
              ! convert value
                 i=1
                 e(n)=zero
                 do while ( i <= n )
                    if( i<n .and. ipiv(i) < 0 ) then
                       e(i)=a(i+1,i)
                       e(i+1)=zero
                       a(i+1,i)=zero
                       i=i+1
                    else
                       e(i)=zero
                    endif
                    i=i+1
                 end do
              ! convert permutations
              i=1
              do while ( i <= n )
                 if( ipiv(i) > 0 ) then
                    ip=ipiv(i)
                    if (i > 1) then
                    do j= 1,i-1
                      temp=a(ip,j)
                      a(ip,j)=a(i,j)
                      a(i,j)=temp
                    end do
                    endif
                 else
                   ip=-ipiv(i)
                   if (i > 1) then
                   do j= 1,i-1
                      temp=a(ip,j)
                      a(ip,j)=a(i+1,j)
                      a(i+1,j)=temp
                   end do
                   endif
                   i=i+1
                endif
                i=i+1
             end do
              else
            ! revert a (a is lower)
              ! revert permutations
                 i=n
                 do while ( i >= 1 )
                    if( ipiv(i) > 0 ) then
                       ip=ipiv(i)
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(i,j)
                             a(i,j)=a(ip,j)
                             a(ip,j)=temp
                          end do
                       endif
                    else
                       ip=-ipiv(i)
                       i=i-1
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(i+1,j)
                             a(i+1,j)=a(ip,j)
                             a(ip,j)=temp
                          end do
                       endif
                    endif
                    i=i-1
                 end do
              ! revert value
                 i=1
                 do while ( i <= n-1 )
                    if( ipiv(i) < 0 ) then
                       a(i+1,i)=e(i)
                       i=i+1
                    endif
                    i=i+1
                 end do
              end if
           end if
           return
     end subroutine stdlib_dsyconv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$syconv( uplo, way, n, a, lda, ipiv, e, info )
     !! DSYCONV: convert A given by TRF into L and D and vice-versa.
     !! Get Non-diag elements of D (returned in workspace) and
     !! apply or reverse permutation done in TRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip, j
           real(${rk}$) :: temp
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYCONV', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
            ! a is upper
            ! convert a (a is upper)
              ! convert value
              if ( convert ) then
                 i=n
                 e(1)=zero
                 do while ( i > 1 )
                    if( ipiv(i) < 0 ) then
                       e(i)=a(i-1,i)
                       e(i-1)=zero
                       a(i-1,i)=zero
                       i=i-1
                    else
                       e(i)=zero
                    endif
                    i=i-1
                 end do
              ! convert permutations
              i=n
              do while ( i >= 1 )
                 if( ipiv(i) > 0) then
                    ip=ipiv(i)
                    if( i < n) then
                       do j= i+1,n
                         temp=a(ip,j)
                         a(ip,j)=a(i,j)
                         a(i,j)=temp
                       end do
                    endif
                 else
                   ip=-ipiv(i)
                    if( i < n) then
                  do j= i+1,n
                      temp=a(ip,j)
                      a(ip,j)=a(i-1,j)
                      a(i-1,j)=temp
                  end do
                     endif
                     i=i-1
                endif
                i=i-1
             end do
              else
            ! revert a (a is upper)
              ! revert permutations
                 i=1
                 do while ( i <= n )
                    if( ipiv(i) > 0 ) then
                       ip=ipiv(i)
                       if( i < n) then
                       do j= i+1,n
                         temp=a(ip,j)
                         a(ip,j)=a(i,j)
                         a(i,j)=temp
                       end do
                       endif
                    else
                      ip=-ipiv(i)
                      i=i+1
                      if( i < n) then
                         do j= i+1,n
                            temp=a(ip,j)
                            a(ip,j)=a(i-1,j)
                            a(i-1,j)=temp
                         end do
                      endif
                    endif
                    i=i+1
                 end do
              ! revert value
                 i=n
                 do while ( i > 1 )
                    if( ipiv(i) < 0 ) then
                       a(i-1,i)=e(i)
                       i=i-1
                    endif
                    i=i-1
                 end do
              end if
           else
            ! a is lower
              if ( convert ) then
            ! convert a (a is lower)
              ! convert value
                 i=1
                 e(n)=zero
                 do while ( i <= n )
                    if( i<n .and. ipiv(i) < 0 ) then
                       e(i)=a(i+1,i)
                       e(i+1)=zero
                       a(i+1,i)=zero
                       i=i+1
                    else
                       e(i)=zero
                    endif
                    i=i+1
                 end do
              ! convert permutations
              i=1
              do while ( i <= n )
                 if( ipiv(i) > 0 ) then
                    ip=ipiv(i)
                    if (i > 1) then
                    do j= 1,i-1
                      temp=a(ip,j)
                      a(ip,j)=a(i,j)
                      a(i,j)=temp
                    end do
                    endif
                 else
                   ip=-ipiv(i)
                   if (i > 1) then
                   do j= 1,i-1
                      temp=a(ip,j)
                      a(ip,j)=a(i+1,j)
                      a(i+1,j)=temp
                   end do
                   endif
                   i=i+1
                endif
                i=i+1
             end do
              else
            ! revert a (a is lower)
              ! revert permutations
                 i=n
                 do while ( i >= 1 )
                    if( ipiv(i) > 0 ) then
                       ip=ipiv(i)
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(i,j)
                             a(i,j)=a(ip,j)
                             a(ip,j)=temp
                          end do
                       endif
                    else
                       ip=-ipiv(i)
                       i=i-1
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(i+1,j)
                             a(i+1,j)=a(ip,j)
                             a(ip,j)=temp
                          end do
                       endif
                    endif
                    i=i-1
                 end do
              ! revert value
                 i=1
                 do while ( i <= n-1 )
                    if( ipiv(i) < 0 ) then
                       a(i+1,i)=e(i)
                       i=i+1
                    endif
                    i=i+1
                 end do
              end if
           end if
           return
     end subroutine stdlib_${ri}$syconv

#:endif
#:endfor

     module pure subroutine stdlib_csyconv( uplo, way, n, a, lda, ipiv, e, info )
     !! CSYCONV convert A given by TRF into L and D and vice-versa.
     !! Get Non-diag elements of D (returned in workspace) and
     !! apply or reverse permutation done in TRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip, j
           complex(sp) :: temp
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYCONV', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
            ! a is upper
            ! convert a (a is upper)
              ! convert value
              if ( convert ) then
                 i=n
                 e(1)=czero
                 do while ( i > 1 )
                    if( ipiv(i) < 0 ) then
                       e(i)=a(i-1,i)
                       e(i-1)=czero
                       a(i-1,i)=czero
                       i=i-1
                    else
                       e(i)=czero
                    endif
                    i=i-1
                 end do
              ! convert permutations
              i=n
              do while ( i >= 1 )
                 if( ipiv(i) > 0) then
                    ip=ipiv(i)
                    if( i < n) then
                       do j= i+1,n
                         temp=a(ip,j)
                         a(ip,j)=a(i,j)
                         a(i,j)=temp
                       end do
                    endif
                 else
                   ip=-ipiv(i)
                    if( i < n) then
                  do j= i+1,n
                      temp=a(ip,j)
                      a(ip,j)=a(i-1,j)
                      a(i-1,j)=temp
                  end do
                     endif
                     i=i-1
                endif
                i=i-1
             end do
              else
            ! revert a (a is upper)
              ! revert permutations
                 i=1
                 do while ( i <= n )
                    if( ipiv(i) > 0 ) then
                       ip=ipiv(i)
                       if( i < n) then
                       do j= i+1,n
                         temp=a(ip,j)
                         a(ip,j)=a(i,j)
                         a(i,j)=temp
                       end do
                       endif
                    else
                      ip=-ipiv(i)
                      i=i+1
                      if( i < n) then
                         do j= i+1,n
                            temp=a(ip,j)
                            a(ip,j)=a(i-1,j)
                            a(i-1,j)=temp
                         end do
                      endif
                    endif
                    i=i+1
                 end do
              ! revert value
                 i=n
                 do while ( i > 1 )
                    if( ipiv(i) < 0 ) then
                       a(i-1,i)=e(i)
                       i=i-1
                    endif
                    i=i-1
                 end do
              end if
           else
            ! a is lower
              if ( convert ) then
            ! convert a (a is lower)
              ! convert value
                 i=1
                 e(n)=czero
                 do while ( i <= n )
                    if( i<n .and. ipiv(i) < 0 ) then
                       e(i)=a(i+1,i)
                       e(i+1)=czero
                       a(i+1,i)=czero
                       i=i+1
                    else
                       e(i)=czero
                    endif
                    i=i+1
                 end do
              ! convert permutations
              i=1
              do while ( i <= n )
                 if( ipiv(i) > 0 ) then
                    ip=ipiv(i)
                    if (i > 1) then
                    do j= 1,i-1
                      temp=a(ip,j)
                      a(ip,j)=a(i,j)
                      a(i,j)=temp
                    end do
                    endif
                 else
                   ip=-ipiv(i)
                   if (i > 1) then
                   do j= 1,i-1
                      temp=a(ip,j)
                      a(ip,j)=a(i+1,j)
                      a(i+1,j)=temp
                   end do
                   endif
                   i=i+1
                endif
                i=i+1
             end do
              else
            ! revert a (a is lower)
              ! revert permutations
                 i=n
                 do while ( i >= 1 )
                    if( ipiv(i) > 0 ) then
                       ip=ipiv(i)
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(i,j)
                             a(i,j)=a(ip,j)
                             a(ip,j)=temp
                          end do
                       endif
                    else
                       ip=-ipiv(i)
                       i=i-1
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(i+1,j)
                             a(i+1,j)=a(ip,j)
                             a(ip,j)=temp
                          end do
                       endif
                    endif
                    i=i-1
                 end do
              ! revert value
                 i=1
                 do while ( i <= n-1 )
                    if( ipiv(i) < 0 ) then
                       a(i+1,i)=e(i)
                       i=i+1
                    endif
                    i=i+1
                 end do
              end if
           end if
           return
     end subroutine stdlib_csyconv

     module pure subroutine stdlib_zsyconv( uplo, way, n, a, lda, ipiv, e, info )
     !! ZSYCONV converts A given by ZHETRF into L and D or vice-versa.
     !! Get nondiagonal elements of D (returned in workspace) and
     !! apply or reverse permutation done in TRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip, j
           complex(dp) :: temp
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYCONV', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! a is upper
              if ( convert ) then
                 ! convert a (a is upper)
                 ! convert value
                 i=n
                 e(1)=czero
                 do while ( i > 1 )
                    if( ipiv(i) < 0 ) then
                       e(i)=a(i-1,i)
                       e(i-1)=czero
                       a(i-1,i)=czero
                       i=i-1
                    else
                       e(i)=czero
                    endif
                    i=i-1
                 end do
                 ! convert permutations
                 i=n
                 do while ( i >= 1 )
                    if( ipiv(i) > 0) then
                       ip=ipiv(i)
                       if( i < n) then
                          do j= i+1,n
                            temp=a(ip,j)
                            a(ip,j)=a(i,j)
                            a(i,j)=temp
                          end do
                       endif
                    else
                       ip=-ipiv(i)
                       if( i < n) then
                          do j= i+1,n
                             temp=a(ip,j)
                             a(ip,j)=a(i-1,j)
                             a(i-1,j)=temp
                          end do
                       endif
                       i=i-1
                    endif
                    i=i-1
                 end do
              else
                 ! revert a (a is upper)
                 ! revert permutations
                 i=1
                 do while ( i <= n )
                    if( ipiv(i) > 0 ) then
                       ip=ipiv(i)
                       if( i < n) then
                       do j= i+1,n
                         temp=a(ip,j)
                         a(ip,j)=a(i,j)
                         a(i,j)=temp
                       end do
                       endif
                    else
                      ip=-ipiv(i)
                      i=i+1
                      if( i < n) then
                         do j= i+1,n
                            temp=a(ip,j)
                            a(ip,j)=a(i-1,j)
                            a(i-1,j)=temp
                         end do
                      endif
                    endif
                    i=i+1
                 end do
                 ! revert value
                 i=n
                 do while ( i > 1 )
                    if( ipiv(i) < 0 ) then
                       a(i-1,i)=e(i)
                       i=i-1
                    endif
                    i=i-1
                 end do
              end if
           else
              ! a is lower
              if ( convert ) then
                 ! convert a (a is lower)
                 ! convert value
                 i=1
                 e(n)=czero
                 do while ( i <= n )
                    if( i<n .and. ipiv(i) < 0 ) then
                       e(i)=a(i+1,i)
                       e(i+1)=czero
                       a(i+1,i)=czero
                       i=i+1
                    else
                       e(i)=czero
                    endif
                    i=i+1
                 end do
                 ! convert permutations
                 i=1
                 do while ( i <= n )
                    if( ipiv(i) > 0 ) then
                       ip=ipiv(i)
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(ip,j)
                             a(ip,j)=a(i,j)
                             a(i,j)=temp
                          end do
                       endif
                    else
                       ip=-ipiv(i)
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(ip,j)
                             a(ip,j)=a(i+1,j)
                             a(i+1,j)=temp
                          end do
                       endif
                       i=i+1
                    endif
                    i=i+1
                 end do
              else
                 ! revert a (a is lower)
                 ! revert permutations
                 i=n
                 do while ( i >= 1 )
                    if( ipiv(i) > 0 ) then
                       ip=ipiv(i)
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(i,j)
                             a(i,j)=a(ip,j)
                             a(ip,j)=temp
                          end do
                       endif
                    else
                       ip=-ipiv(i)
                       i=i-1
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(i+1,j)
                             a(i+1,j)=a(ip,j)
                             a(ip,j)=temp
                          end do
                       endif
                    endif
                    i=i-1
                 end do
                 ! revert value
                 i=1
                 do while ( i <= n-1 )
                    if( ipiv(i) < 0 ) then
                       a(i+1,i)=e(i)
                       i=i+1
                    endif
                    i=i+1
                 end do
              end if
           end if
           return
     end subroutine stdlib_zsyconv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$syconv( uplo, way, n, a, lda, ipiv, e, info )
     !! ZSYCONV: converts A given by ZHETRF into L and D or vice-versa.
     !! Get nondiagonal elements of D (returned in workspace) and
     !! apply or reverse permutation done in TRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip, j
           complex(${ck}$) :: temp
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYCONV', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! a is upper
              if ( convert ) then
                 ! convert a (a is upper)
                 ! convert value
                 i=n
                 e(1)=czero
                 do while ( i > 1 )
                    if( ipiv(i) < 0 ) then
                       e(i)=a(i-1,i)
                       e(i-1)=czero
                       a(i-1,i)=czero
                       i=i-1
                    else
                       e(i)=czero
                    endif
                    i=i-1
                 end do
                 ! convert permutations
                 i=n
                 do while ( i >= 1 )
                    if( ipiv(i) > 0) then
                       ip=ipiv(i)
                       if( i < n) then
                          do j= i+1,n
                            temp=a(ip,j)
                            a(ip,j)=a(i,j)
                            a(i,j)=temp
                          end do
                       endif
                    else
                       ip=-ipiv(i)
                       if( i < n) then
                          do j= i+1,n
                             temp=a(ip,j)
                             a(ip,j)=a(i-1,j)
                             a(i-1,j)=temp
                          end do
                       endif
                       i=i-1
                    endif
                    i=i-1
                 end do
              else
                 ! revert a (a is upper)
                 ! revert permutations
                 i=1
                 do while ( i <= n )
                    if( ipiv(i) > 0 ) then
                       ip=ipiv(i)
                       if( i < n) then
                       do j= i+1,n
                         temp=a(ip,j)
                         a(ip,j)=a(i,j)
                         a(i,j)=temp
                       end do
                       endif
                    else
                      ip=-ipiv(i)
                      i=i+1
                      if( i < n) then
                         do j= i+1,n
                            temp=a(ip,j)
                            a(ip,j)=a(i-1,j)
                            a(i-1,j)=temp
                         end do
                      endif
                    endif
                    i=i+1
                 end do
                 ! revert value
                 i=n
                 do while ( i > 1 )
                    if( ipiv(i) < 0 ) then
                       a(i-1,i)=e(i)
                       i=i-1
                    endif
                    i=i-1
                 end do
              end if
           else
              ! a is lower
              if ( convert ) then
                 ! convert a (a is lower)
                 ! convert value
                 i=1
                 e(n)=czero
                 do while ( i <= n )
                    if( i<n .and. ipiv(i) < 0 ) then
                       e(i)=a(i+1,i)
                       e(i+1)=czero
                       a(i+1,i)=czero
                       i=i+1
                    else
                       e(i)=czero
                    endif
                    i=i+1
                 end do
                 ! convert permutations
                 i=1
                 do while ( i <= n )
                    if( ipiv(i) > 0 ) then
                       ip=ipiv(i)
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(ip,j)
                             a(ip,j)=a(i,j)
                             a(i,j)=temp
                          end do
                       endif
                    else
                       ip=-ipiv(i)
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(ip,j)
                             a(ip,j)=a(i+1,j)
                             a(i+1,j)=temp
                          end do
                       endif
                       i=i+1
                    endif
                    i=i+1
                 end do
              else
                 ! revert a (a is lower)
                 ! revert permutations
                 i=n
                 do while ( i >= 1 )
                    if( ipiv(i) > 0 ) then
                       ip=ipiv(i)
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(i,j)
                             a(i,j)=a(ip,j)
                             a(ip,j)=temp
                          end do
                       endif
                    else
                       ip=-ipiv(i)
                       i=i-1
                       if (i > 1) then
                          do j= 1,i-1
                             temp=a(i+1,j)
                             a(i+1,j)=a(ip,j)
                             a(ip,j)=temp
                          end do
                       endif
                    endif
                    i=i-1
                 end do
                 ! revert value
                 i=1
                 do while ( i <= n-1 )
                    if( ipiv(i) < 0 ) then
                       a(i+1,i)=e(i)
                       i=i+1
                    endif
                    i=i+1
                 end do
              end if
           end if
           return
     end subroutine stdlib_${ci}$syconv

#:endif
#:endfor



     module pure subroutine stdlib_ssytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )
     !! SSYTRS_AA solves a system of linear equations A*X = B with a real
     !! symmetric matrix A using the factorization A = U**T*T*U or
     !! A = L*T*L**T computed by SSYTRF_AA.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, nrhs, lda, ldb, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(in) :: a(lda,*)
           real(sp), intent(inout) :: b(ldb,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           logical(lk) :: lquery, upper
           integer(ilp) :: k, kp, lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max( 1, 3*n-2 ) .and. .not.lquery ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYTRS_AA', -info )
              return
           else if( lquery ) then
              lwkopt = (3*n-2)
              work( 1 ) = lwkopt
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u**t*t*u.
              ! 1) forward substitution with u**t
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 k = 1
                 do while ( k<=n )
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                    k = k + 1
                 end do
                 ! compute u**t \ b -> b    [ (u**t \p**t * b) ]
                 call stdlib_strsm( 'L', 'U', 'T', 'U', n-1, nrhs, one, a( 1, 2 ),lda, b( 2, 1 ), &
                           ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (u**t \p**t * b) ]
              call stdlib_slacpy( 'F', 1, n, a(1, 1), lda+1, work(n), 1)
              if( n>1 ) then
                  call stdlib_slacpy( 'F', 1, n-1, a(1, 2), lda+1, work(1), 1)
                  call stdlib_slacpy( 'F', 1, n-1, a(1, 2), lda+1, work(2*n), 1)
              end if
              call stdlib_sgtsv(n, nrhs, work(1), work(n), work(2*n), b, ldb,info)
              ! 3) backward substitution with u
              if( n>1 ) then
                 ! compute u \ b -> b   [ u \ (t \ (u**t \p**t * b) ) ]
                 call stdlib_strsm( 'L', 'U', 'N', 'U', n-1, nrhs, one, a( 1, 2 ),lda, b(2, 1), &
                           ldb)
                 ! pivot, p * b -> b  [ p * (u \ (t \ (u**t \p**t * b) )) ]
                 k = n
                 do while ( k>=1 )
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                    k = k - 1
                 end do
              end if
           else
              ! solve a*x = b, where a = l*t*l**t.
              ! 1) forward substitution with l
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 k = 1
                 do while ( k<=n )
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                    k = k + 1
                 end do
                 ! compute l \ b -> b    [ (l \p**t * b) ]
                 call stdlib_strsm( 'L', 'L', 'N', 'U', n-1, nrhs, one, a( 2, 1),lda, b(2, 1), &
                           ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (l \p**t * b) ]
              call stdlib_slacpy( 'F', 1, n, a(1, 1), lda+1, work(n), 1)
              if( n>1 ) then
                  call stdlib_slacpy( 'F', 1, n-1, a(2, 1), lda+1, work(1), 1)
                  call stdlib_slacpy( 'F', 1, n-1, a(2, 1), lda+1, work(2*n), 1)
              end if
              call stdlib_sgtsv(n, nrhs, work(1), work(n), work(2*n), b, ldb,info)
              ! 3) backward substitution with l**t
              if( n>1 ) then
                 ! compute l**t \ b -> b   [ l**t \ (t \ (l \p**t * b) ) ]
                 call stdlib_strsm( 'L', 'L', 'T', 'U', n-1, nrhs, one, a( 2, 1 ),lda, b( 2, 1 ), &
                           ldb)
                 ! pivot, p * b -> b  [ p * (l**t \ (t \ (l \p**t * b) )) ]
                 k = n
                 do while ( k>=1 )
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                    k = k - 1
                 end do
              end if
           end if
           return
     end subroutine stdlib_ssytrs_aa

     module pure subroutine stdlib_dsytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )
     !! DSYTRS_AA solves a system of linear equations A*X = B with a real
     !! symmetric matrix A using the factorization A = U**T*T*U or
     !! A = L*T*L**T computed by DSYTRF_AA.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, nrhs, lda, ldb, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(dp), intent(in) :: a(lda,*)
           real(dp), intent(inout) :: b(ldb,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           logical(lk) :: lquery, upper
           integer(ilp) :: k, kp, lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max( 1, 3*n-2 ) .and. .not.lquery ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRS_AA', -info )
              return
           else if( lquery ) then
              lwkopt = (3*n-2)
              work( 1 ) = lwkopt
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u**t*t*u.
              ! 1) forward substitution with u**t
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 do k = 1, n
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
                 ! compute u**t \ b -> b    [ (u**t \p**t * b) ]
                 call stdlib_dtrsm('L', 'U', 'T', 'U', n-1, nrhs, one, a( 1, 2 ),lda, b( 2, 1 ), &
                           ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (u**t \p**t * b) ]
              call stdlib_dlacpy( 'F', 1, n, a( 1, 1 ), lda+1, work( n ), 1)
              if( n>1 ) then
                 call stdlib_dlacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 1 ), 1 )
                 call stdlib_dlacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 2*n ), 1 )
              end if
              call stdlib_dgtsv( n, nrhs, work( 1 ), work( n ), work( 2*n ), b, ldb,info )
              ! 3) backward substitution with u
              if( n>1 ) then
                 ! compute u \ b -> b   [ u \ (t \ (u**t \p**t * b) ) ]
                 call stdlib_dtrsm( 'L', 'U', 'N', 'U', n-1, nrhs, one, a( 1, 2 ),lda, b( 2, 1 ), &
                           ldb)
                 ! pivot, p * b -> b  [ p * (u \ (t \ (u**t \p**t * b) )) ]
                 do k = n, 1, -1
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
              end if
           else
              ! solve a*x = b, where a = l*t*l**t.
              ! 1) forward substitution with l
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 do k = 1, n
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
                 ! compute l \ b -> b    [ (l \p**t * b) ]
                 call stdlib_dtrsm( 'L', 'L', 'N', 'U', n-1, nrhs, one, a( 2, 1 ),lda, b( 2, 1 ), &
                           ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (l \p**t * b) ]
              call stdlib_dlacpy( 'F', 1, n, a(1, 1), lda+1, work(n), 1)
              if( n>1 ) then
                 call stdlib_dlacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 1 ), 1 )
                 call stdlib_dlacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 2*n ), 1 )
              end if
              call stdlib_dgtsv( n, nrhs, work( 1 ), work(n), work( 2*n ), b, ldb,info)
              ! 3) backward substitution with l**t
              if( n>1 ) then
                 ! compute (l**t \ b) -> b   [ l**t \ (t \ (l \p**t * b) ) ]
                 call stdlib_dtrsm( 'L', 'L', 'T', 'U', n-1, nrhs, one, a( 2, 1 ),lda, b( 2, 1 ), &
                           ldb)
                 ! pivot, p * b -> b  [ p * (l**t \ (t \ (l \p**t * b) )) ]
                 do k = n, 1, -1
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
              end if
           end if
           return
     end subroutine stdlib_dsytrs_aa

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )
     !! DSYTRS_AA: solves a system of linear equations A*X = B with a real
     !! symmetric matrix A using the factorization A = U**T*T*U or
     !! A = L*T*L**T computed by DSYTRF_AA.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, nrhs, lda, ldb, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           logical(lk) :: lquery, upper
           integer(ilp) :: k, kp, lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max( 1, 3*n-2 ) .and. .not.lquery ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRS_AA', -info )
              return
           else if( lquery ) then
              lwkopt = (3*n-2)
              work( 1 ) = lwkopt
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u**t*t*u.
              ! 1) forward substitution with u**t
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 do k = 1, n
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
                 ! compute u**t \ b -> b    [ (u**t \p**t * b) ]
                 call stdlib_${ri}$trsm('L', 'U', 'T', 'U', n-1, nrhs, one, a( 1, 2 ),lda, b( 2, 1 ), &
                           ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (u**t \p**t * b) ]
              call stdlib_${ri}$lacpy( 'F', 1, n, a( 1, 1 ), lda+1, work( n ), 1)
              if( n>1 ) then
                 call stdlib_${ri}$lacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 1 ), 1 )
                 call stdlib_${ri}$lacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 2*n ), 1 )
              end if
              call stdlib_${ri}$gtsv( n, nrhs, work( 1 ), work( n ), work( 2*n ), b, ldb,info )
              ! 3) backward substitution with u
              if( n>1 ) then
                 ! compute u \ b -> b   [ u \ (t \ (u**t \p**t * b) ) ]
                 call stdlib_${ri}$trsm( 'L', 'U', 'N', 'U', n-1, nrhs, one, a( 1, 2 ),lda, b( 2, 1 ), &
                           ldb)
                 ! pivot, p * b -> b  [ p * (u \ (t \ (u**t \p**t * b) )) ]
                 do k = n, 1, -1
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
              end if
           else
              ! solve a*x = b, where a = l*t*l**t.
              ! 1) forward substitution with l
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 do k = 1, n
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
                 ! compute l \ b -> b    [ (l \p**t * b) ]
                 call stdlib_${ri}$trsm( 'L', 'L', 'N', 'U', n-1, nrhs, one, a( 2, 1 ),lda, b( 2, 1 ), &
                           ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (l \p**t * b) ]
              call stdlib_${ri}$lacpy( 'F', 1, n, a(1, 1), lda+1, work(n), 1)
              if( n>1 ) then
                 call stdlib_${ri}$lacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 1 ), 1 )
                 call stdlib_${ri}$lacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 2*n ), 1 )
              end if
              call stdlib_${ri}$gtsv( n, nrhs, work( 1 ), work(n), work( 2*n ), b, ldb,info)
              ! 3) backward substitution with l**t
              if( n>1 ) then
                 ! compute (l**t \ b) -> b   [ l**t \ (t \ (l \p**t * b) ) ]
                 call stdlib_${ri}$trsm( 'L', 'L', 'T', 'U', n-1, nrhs, one, a( 2, 1 ),lda, b( 2, 1 ), &
                           ldb)
                 ! pivot, p * b -> b  [ p * (l**t \ (t \ (l \p**t * b) )) ]
                 do k = n, 1, -1
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
              end if
           end if
           return
     end subroutine stdlib_${ri}$sytrs_aa

#:endif
#:endfor

     module pure subroutine stdlib_csytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )
     !! CSYTRS_AA solves a system of linear equations A*X = B with a complex
     !! symmetric matrix A using the factorization A = U**T*T*U or
     !! A = L*T*L**T computed by CSYTRF_AA.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, nrhs, lda, ldb, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           logical(lk) :: lquery, upper
           integer(ilp) :: k, kp, lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max( 1, 3*n-2 ) .and. .not.lquery ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRS_AA', -info )
              return
           else if( lquery ) then
              lwkopt = (3*n-2)
              work( 1 ) = lwkopt
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u**t*t*u.
              ! 1) forward substitution with u**t
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 do k = 1, n
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
                 ! compute u**t \ b -> b    [ (u**t \p**t * b) ]
                 call stdlib_ctrsm( 'L', 'U', 'T', 'U', n-1, nrhs, cone, a( 1, 2 ),lda, b( 2, 1 ),&
                            ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (u**t \p**t * b) ]
              call stdlib_clacpy( 'F', 1, n, a( 1, 1 ), lda+1, work( n ), 1)
              if( n>1 ) then
                 call stdlib_clacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 1 ), 1 )
                 call stdlib_clacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 2*n ), 1 )
              end if
              call stdlib_cgtsv( n, nrhs, work( 1 ), work( n ), work( 2*n ), b, ldb,info )
              ! 3) backward substitution with u
              if( n>1 ) then
                 ! compute u \ b -> b   [ u \ (t \ (u**t \p**t * b) ) ]
                 call stdlib_ctrsm( 'L', 'U', 'N', 'U', n-1, nrhs, cone, a( 1, 2 ),lda, b( 2, 1 ),&
                            ldb)
                 ! pivot, p * b -> b  [ p * (u**t \ (t \ (u \p**t * b) )) ]
                 do k = n, 1, -1
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
              end if
           else
              ! solve a*x = b, where a = l*t*l**t.
              ! 1) forward substitution with l
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 do k = 1, n
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
                 ! compute l \ b -> b    [ (l \p**t * b) ]
                 call stdlib_ctrsm( 'L', 'L', 'N', 'U', n-1, nrhs, cone, a( 2, 1 ),lda, b( 2, 1 ),&
                            ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (l \p**t * b) ]
              call stdlib_clacpy( 'F', 1, n, a(1, 1), lda+1, work(n), 1)
              if( n>1 ) then
                 call stdlib_clacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 1 ), 1 )
                 call stdlib_clacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 2*n ), 1 )
              end if
              call stdlib_cgtsv( n, nrhs, work( 1 ), work(n), work( 2*n ), b, ldb,info)
              ! 3) backward substitution with l**t
              if( n>1 ) then
                 ! compute (l**t \ b) -> b   [ l**t \ (t \ (l \p**t * b) ) ]
                 call stdlib_ctrsm( 'L', 'L', 'T', 'U', n-1, nrhs, cone, a( 2, 1 ),lda, b( 2, 1 ),&
                            ldb)
                 ! pivot, p * b -> b  [ p * (l**t \ (t \ (l \p**t * b) )) ]
                 do k = n, 1, -1
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
              end if
           end if
           return
     end subroutine stdlib_csytrs_aa

     module pure subroutine stdlib_zsytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )
     !! ZSYTRS_AA solves a system of linear equations A*X = B with a complex
     !! symmetric matrix A using the factorization A = U**T*T*U or
     !! A = L*T*L**T computed by ZSYTRF_AA.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, nrhs, lda, ldb, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(inout) :: b(ldb,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           logical(lk) :: lquery, upper
           integer(ilp) :: k, kp, lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max( 1, 3*n-2 ) .and. .not.lquery ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRS_AA', -info )
              return
           else if( lquery ) then
              lwkopt = (3*n-2)
              work( 1 ) = lwkopt
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u**t*t*u.
              ! 1) forward substitution with u**t
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 do k = 1, n
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
                 ! compute u**t \ b -> b    [ (u**t \p**t * b) ]
                 call stdlib_ztrsm( 'L', 'U', 'T', 'U', n-1, nrhs, cone, a( 1, 2 ),lda, b( 2, 1 ),&
                            ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (u**t \p**t * b) ]
              call stdlib_zlacpy( 'F', 1, n, a( 1, 1 ), lda+1, work( n ), 1)
              if( n>1 ) then
                 call stdlib_zlacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 1 ), 1 )
                 call stdlib_zlacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 2*n ), 1 )
              end if
              call stdlib_zgtsv( n, nrhs, work( 1 ), work( n ), work( 2*n ), b, ldb,info )
              ! 3) backward substitution with u
              if( n>1 ) then
                 ! compute u \ b -> b   [ u \ (t \ (u**t \p**t * b) ) ]
                 call stdlib_ztrsm( 'L', 'U', 'N', 'U', n-1, nrhs, cone, a( 1, 2 ),lda, b( 2, 1 ),&
                            ldb)
                 ! pivot, p * b -> b  [ p * (u \ (t \ (u**t \p**t * b) )) ]
                 do k = n, 1, -1
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
              end if
           else
              ! solve a*x = b, where a = l*t*l**t.
              ! 1) forward substitution with l
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 do k = 1, n
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
                 ! compute l \ b -> b    [ (l \p**t * b) ]
                 call stdlib_ztrsm( 'L', 'L', 'N', 'U', n-1, nrhs, cone, a( 2, 1 ),lda, b( 2, 1 ),&
                            ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (l \p**t * b) ]
              call stdlib_zlacpy( 'F', 1, n, a(1, 1), lda+1, work(n), 1)
              if( n>1 ) then
                 call stdlib_zlacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 1 ), 1 )
                 call stdlib_zlacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 2*n ), 1 )
              end if
              call stdlib_zgtsv( n, nrhs, work( 1 ), work(n), work( 2*n ), b, ldb,info)
              ! 3) backward substitution with l**t
              if( n>1 ) then
                 ! compute (l**t \ b) -> b   [ l**t \ (t \ (l \p**t * b) ) ]
                 call stdlib_ztrsm( 'L', 'L', 'T', 'U', n-1, nrhs, cone, a( 2, 1 ),lda, b( 2, 1 ),&
                            ldb)
                 ! pivot, p * b -> b  [ p * (l**t \ (t \ (l \p**t * b) )) ]
                 do k = n, 1, -1
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
              end if
           end if
           return
     end subroutine stdlib_zsytrs_aa

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )
     !! ZSYTRS_AA: solves a system of linear equations A*X = B with a complex
     !! symmetric matrix A using the factorization A = U**T*T*U or
     !! A = L*T*L**T computed by ZSYTRF_AA.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, nrhs, lda, ldb, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(inout) :: b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           logical(lk) :: lquery, upper
           integer(ilp) :: k, kp, lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max( 1, 3*n-2 ) .and. .not.lquery ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRS_AA', -info )
              return
           else if( lquery ) then
              lwkopt = (3*n-2)
              work( 1 ) = lwkopt
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u**t*t*u.
              ! 1) forward substitution with u**t
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 do k = 1, n
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
                 ! compute u**t \ b -> b    [ (u**t \p**t * b) ]
                 call stdlib_${ci}$trsm( 'L', 'U', 'T', 'U', n-1, nrhs, cone, a( 1, 2 ),lda, b( 2, 1 ),&
                            ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (u**t \p**t * b) ]
              call stdlib_${ci}$lacpy( 'F', 1, n, a( 1, 1 ), lda+1, work( n ), 1)
              if( n>1 ) then
                 call stdlib_${ci}$lacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 1 ), 1 )
                 call stdlib_${ci}$lacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 2*n ), 1 )
              end if
              call stdlib_${ci}$gtsv( n, nrhs, work( 1 ), work( n ), work( 2*n ), b, ldb,info )
              ! 3) backward substitution with u
              if( n>1 ) then
                 ! compute u \ b -> b   [ u \ (t \ (u**t \p**t * b) ) ]
                 call stdlib_${ci}$trsm( 'L', 'U', 'N', 'U', n-1, nrhs, cone, a( 1, 2 ),lda, b( 2, 1 ),&
                            ldb)
                 ! pivot, p * b -> b  [ p * (u \ (t \ (u**t \p**t * b) )) ]
                 do k = n, 1, -1
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
              end if
           else
              ! solve a*x = b, where a = l*t*l**t.
              ! 1) forward substitution with l
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 do k = 1, n
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
                 ! compute l \ b -> b    [ (l \p**t * b) ]
                 call stdlib_${ci}$trsm( 'L', 'L', 'N', 'U', n-1, nrhs, cone, a( 2, 1 ),lda, b( 2, 1 ),&
                            ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (l \p**t * b) ]
              call stdlib_${ci}$lacpy( 'F', 1, n, a(1, 1), lda+1, work(n), 1)
              if( n>1 ) then
                 call stdlib_${ci}$lacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 1 ), 1 )
                 call stdlib_${ci}$lacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 2*n ), 1 )
              end if
              call stdlib_${ci}$gtsv( n, nrhs, work( 1 ), work(n), work( 2*n ), b, ldb,info)
              ! 3) backward substitution with l**t
              if( n>1 ) then
                 ! compute (l**t \ b) -> b   [ l**t \ (t \ (l \p**t * b) ) ]
                 call stdlib_${ci}$trsm( 'L', 'L', 'T', 'U', n-1, nrhs, cone, a( 2, 1 ),lda, b( 2, 1 ),&
                            ldb)
                 ! pivot, p * b -> b  [ p * (l**t \ (t \ (l \p**t * b) )) ]
                 do k = n, 1, -1
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
              end if
           end if
           return
     end subroutine stdlib_${ci}$sytrs_aa

#:endif
#:endfor



     module pure subroutine stdlib_slasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
     !! SLASYF_ROOK computes a partial factorization of a real symmetric
     !! matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! SLASYF_ROOK is an auxiliary routine called by SSYTRF_ROOK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, j, jb, jj, jmax, jp1, jp2, k, kk, kw, kkw, kp, kstep, p, &
                     ii
           real(sp) :: absakk, alpha, colmax, d11, d12, d21, d22, stemp, r1, rowmax, t, &
                     sfmin
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              call stdlib_scopy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_sgemv( 'NO TRANSPOSE', k, n-k, -one, a( 1, k+1 ),lda, w( k, kw+&
                        1 ), ldw, one, w( 1, kw ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_isamax( k-1, w( 1, kw ), 1 )
                 colmax = abs( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_scopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       call stdlib_scopy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                       call stdlib_scopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       if( k<n )call stdlib_sgemv( 'NO TRANSPOSE', k, n-k, -one,a( 1, k+1 ), lda, &
                                 w( imax, kw+1 ), ldw,one, w( 1, kw-1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_isamax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = abs( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_isamax( imax-1, w( 1, kw-1 ), 1 )
                          stemp = abs( w( itemp, kw-1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! abs( w( imax, kw-1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.(abs( w( imax, kw-1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_scopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_scopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! ============================================================
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_scopy( k-p, a( p+1, k ), 1, a( p, p+1 ), lda )
                    call stdlib_scopy( p, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in last n-k+1 columns of a
                    ! and last n-k+2 columns of w
                    call stdlib_sswap( n-k+1, a( k, k ), lda, a( p, k ), lda )
                    call stdlib_sswap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ), ldw )
                 end if
                 ! updated column kp is already stored in column kkw of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_scopy( k-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_scopy( kp, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last n-kk+1 columns
                    ! of a and w
                    call stdlib_sswap( n-kk+1, a( kk, kk ), lda, a( kp, kk ), lda )
                    call stdlib_sswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! store u(k) in column k of a
                    call stdlib_scopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       if( abs( a( k, k ) )>=sfmin ) then
                          r1 = one / a( k, k )
                          call stdlib_sscal( k-1, r1, a( 1, k ), 1 )
                       else if( a( k, k )/=zero ) then
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now
                    ! hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    if( k>2 ) then
                       ! store u(k) and u(k-1) in columns k and k-1 of a
                       d12 = w( k-1, kw )
                       d11 = w( k, kw ) / d12
                       d22 = w( k-1, kw-1 ) / d12
                       t = one / ( d11*d22-one )
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( (d11*w( j, kw-1 )-w( j, kw ) ) /d12 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /d12 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_sgemv( 'NO TRANSPOSE', jj-j+1, n-k, -one,a( j, k+1 ), lda, w( jj, &
                              kw+1 ), ldw, one,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_sgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb,n-k, -one, a( &
                           1, k+1 ), lda, w( j, kw+1 ), ldw,one, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in columns k+1:n
              j = k + 1
              60 continue
                 kstep = 1
                 jp1 = 1
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    j = j + 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 j = j + 1
                 if( jp2/=jj .and. j<=n )call stdlib_sswap( n-j+1, a( jp2, j ), lda, a( jj, j ), &
                           lda )
                 jj = j - 1
                 if( jp1/=jj .and. kstep==2 )call stdlib_sswap( n-j+1, a( jp1, j ), lda, a( jj, j &
                           ), lda )
              if( j<=n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update it
              call stdlib_scopy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              if( k>1 )call stdlib_sgemv( 'NO TRANSPOSE', n-k+1, k-1, -one, a( k, 1 ),lda, w( k, &
                        1 ), ldw, one, w( k, k ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_isamax( n-k, w( k+1, k ), 1 )
                 colmax = abs( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_scopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_scopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_scopy( n-imax+1, a( imax, imax ), 1,w( imax, k+1 ), 1 )
                       if( k>1 )call stdlib_sgemv( 'NO TRANSPOSE', n-k+1, k-1, -one,a( k, 1 ), &
                                 lda, w( imax, 1 ), ldw,one, w( k, k+1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_isamax( imax-k, w( k, k+1 ), 1 )
                          rowmax = abs( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_isamax( n-imax, w( imax+1, k+1 ), 1)
                          stemp = abs( w( itemp, k+1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! abs( w( imax, k+1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( w( imax, k+1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_scopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_scopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 72
                 end if
                 ! ============================================================
                 kk = k + kstep - 1
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_scopy( p-k, a( k, k ), 1, a( p, k ), lda )
                    call stdlib_scopy( n-p+1, a( p, k ), 1, a( p, p ), 1 )
                    ! interchange rows k and p in first k columns of a
                    ! and first k+1 columns of w
                    call stdlib_sswap( k, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_sswap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! updated column kp is already stored in column kk of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_scopy( kp-k-1, a( k+1, kk ), 1, a( kp, k+1 ), lda )
                    call stdlib_scopy( n-kp+1, a( kp, kk ), 1, a( kp, kp ), 1 )
                    ! interchange rows kk and kp in first kk columns of a and w
                    call stdlib_sswap( kk, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_sswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    ! store l(k) in column k of a
                    call stdlib_scopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       if( abs( a( k, k ) )>=sfmin ) then
                          r1 = one / a( k, k )
                          call stdlib_sscal( n-k, r1, a( k+1, k ), 1 )
                       else if( a( k, k )/=zero ) then
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! store l(k) and l(k+1) in columns k and k+1 of a
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = one / ( d11*d22-one )
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /d21 )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_sgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -one,a( jj, 1 ), lda, w( jj, &
                              1 ), ldw, one,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_sgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           one, a( j+jb, 1 ), lda, w( j, 1 ), ldw,one, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! in columns 1:k-1
              j = k - 1
              120 continue
                 kstep = 1
                 jp1 = 1
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    j = j - 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 j = j - 1
                 if( jp2/=jj .and. j>=1 )call stdlib_sswap( j, a( jp2, 1 ), lda, a( jj, 1 ), lda )
                           
                 jj = j + 1
                 if( jp1/=jj .and. kstep==2 )call stdlib_sswap( j, a( jp1, 1 ), lda, a( jj, 1 ), &
                           lda )
              if( j>=1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_slasyf_rook

     module pure subroutine stdlib_dlasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
     !! DLASYF_ROOK computes a partial factorization of a real symmetric
     !! matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! DLASYF_ROOK is an auxiliary routine called by DSYTRF_ROOK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, j, jb, jj, jmax, jp1, jp2, k, kk, kw, kkw, kp, kstep, p, &
                     ii
           real(dp) :: absakk, alpha, colmax, d11, d12, d21, d22, dtemp, r1, rowmax, t, &
                     sfmin
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_dlamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              call stdlib_dcopy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_dgemv( 'NO TRANSPOSE', k, n-k, -one, a( 1, k+1 ),lda, w( k, kw+&
                        1 ), ldw, one, w( 1, kw ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_idamax( k-1, w( 1, kw ), 1 )
                 colmax = abs( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_dcopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       call stdlib_dcopy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                       call stdlib_dcopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       if( k<n )call stdlib_dgemv( 'NO TRANSPOSE', k, n-k, -one,a( 1, k+1 ), lda, &
                                 w( imax, kw+1 ), ldw,one, w( 1, kw-1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_idamax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = abs( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_idamax( imax-1, w( 1, kw-1 ), 1 )
                          dtemp = abs( w( itemp, kw-1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! abs( w( imax, kw-1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.(abs( w( imax, kw-1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_dcopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_dcopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! ============================================================
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_dcopy( k-p, a( p+1, k ), 1, a( p, p+1 ), lda )
                    call stdlib_dcopy( p, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in last n-k+1 columns of a
                    ! and last n-k+2 columns of w
                    call stdlib_dswap( n-k+1, a( k, k ), lda, a( p, k ), lda )
                    call stdlib_dswap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ), ldw )
                 end if
                 ! updated column kp is already stored in column kkw of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_dcopy( k-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_dcopy( kp, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last n-kk+1 columns
                    ! of a and w
                    call stdlib_dswap( n-kk+1, a( kk, kk ), lda, a( kp, kk ), lda )
                    call stdlib_dswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! store u(k) in column k of a
                    call stdlib_dcopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       if( abs( a( k, k ) )>=sfmin ) then
                          r1 = one / a( k, k )
                          call stdlib_dscal( k-1, r1, a( 1, k ), 1 )
                       else if( a( k, k )/=zero ) then
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now
                    ! hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    if( k>2 ) then
                       ! store u(k) and u(k-1) in columns k and k-1 of a
                       d12 = w( k-1, kw )
                       d11 = w( k, kw ) / d12
                       d22 = w( k-1, kw-1 ) / d12
                       t = one / ( d11*d22-one )
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( (d11*w( j, kw-1 )-w( j, kw ) ) /d12 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /d12 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_dgemv( 'NO TRANSPOSE', jj-j+1, n-k, -one,a( j, k+1 ), lda, w( jj, &
                              kw+1 ), ldw, one,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_dgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb,n-k, -one, a( &
                           1, k+1 ), lda, w( j, kw+1 ), ldw,one, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in columns k+1:n
              j = k + 1
              60 continue
                 kstep = 1
                 jp1 = 1
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    j = j + 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 j = j + 1
                 if( jp2/=jj .and. j<=n )call stdlib_dswap( n-j+1, a( jp2, j ), lda, a( jj, j ), &
                           lda )
                 jj = j - 1
                 if( jp1/=jj .and. kstep==2 )call stdlib_dswap( n-j+1, a( jp1, j ), lda, a( jj, j &
                           ), lda )
              if( j<=n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update it
              call stdlib_dcopy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              if( k>1 )call stdlib_dgemv( 'NO TRANSPOSE', n-k+1, k-1, -one, a( k, 1 ),lda, w( k, &
                        1 ), ldw, one, w( k, k ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_idamax( n-k, w( k+1, k ), 1 )
                 colmax = abs( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_dcopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_dcopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_dcopy( n-imax+1, a( imax, imax ), 1,w( imax, k+1 ), 1 )
                       if( k>1 )call stdlib_dgemv( 'NO TRANSPOSE', n-k+1, k-1, -one,a( k, 1 ), &
                                 lda, w( imax, 1 ), ldw,one, w( k, k+1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_idamax( imax-k, w( k, k+1 ), 1 )
                          rowmax = abs( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_idamax( n-imax, w( imax+1, k+1 ), 1)
                          dtemp = abs( w( itemp, k+1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! abs( w( imax, k+1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( w( imax, k+1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_dcopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_dcopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 72
                 end if
                 ! ============================================================
                 kk = k + kstep - 1
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_dcopy( p-k, a( k, k ), 1, a( p, k ), lda )
                    call stdlib_dcopy( n-p+1, a( p, k ), 1, a( p, p ), 1 )
                    ! interchange rows k and p in first k columns of a
                    ! and first k+1 columns of w
                    call stdlib_dswap( k, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_dswap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! updated column kp is already stored in column kk of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_dcopy( kp-k-1, a( k+1, kk ), 1, a( kp, k+1 ), lda )
                    call stdlib_dcopy( n-kp+1, a( kp, kk ), 1, a( kp, kp ), 1 )
                    ! interchange rows kk and kp in first kk columns of a and w
                    call stdlib_dswap( kk, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_dswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    ! store l(k) in column k of a
                    call stdlib_dcopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       if( abs( a( k, k ) )>=sfmin ) then
                          r1 = one / a( k, k )
                          call stdlib_dscal( n-k, r1, a( k+1, k ), 1 )
                       else if( a( k, k )/=zero ) then
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! store l(k) and l(k+1) in columns k and k+1 of a
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = one / ( d11*d22-one )
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /d21 )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_dgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -one,a( jj, 1 ), lda, w( jj, &
                              1 ), ldw, one,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_dgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           one, a( j+jb, 1 ), lda, w( j, 1 ), ldw,one, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! in columns 1:k-1
              j = k - 1
              120 continue
                 kstep = 1
                 jp1 = 1
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    j = j - 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 j = j - 1
                 if( jp2/=jj .and. j>=1 )call stdlib_dswap( j, a( jp2, 1 ), lda, a( jj, 1 ), lda )
                           
                 jj = j + 1
                 if( jp1/=jj .and. kstep==2 )call stdlib_dswap( j, a( jp1, 1 ), lda, a( jj, 1 ), &
                           lda )
              if( j>=1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_dlasyf_rook

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$lasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
     !! DLASYF_ROOK: computes a partial factorization of a real symmetric
     !! matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! DLASYF_ROOK is an auxiliary routine called by DSYTRF_ROOK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sevten = 17.0e+0_${rk}$
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, j, jb, jj, jmax, jp1, jp2, k, kk, kw, kkw, kp, kstep, p, &
                     ii
           real(${rk}$) :: absakk, alpha, colmax, d11, d12, d21, d22, dtemp, r1, rowmax, t, &
                     sfmin
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_${ri}$lamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              call stdlib_${ri}$copy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_${ri}$gemv( 'NO TRANSPOSE', k, n-k, -one, a( 1, k+1 ),lda, w( k, kw+&
                        1 ), ldw, one, w( 1, kw ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ri}$amax( k-1, w( 1, kw ), 1 )
                 colmax = abs( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_${ri}$copy( k, w( 1, kw ), 1, a( 1, k ), 1 )
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       call stdlib_${ri}$copy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                       call stdlib_${ri}$copy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       if( k<n )call stdlib_${ri}$gemv( 'NO TRANSPOSE', k, n-k, -one,a( 1, k+1 ), lda, &
                                 w( imax, kw+1 ), ldw,one, w( 1, kw-1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_i${ri}$amax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = abs( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_i${ri}$amax( imax-1, w( 1, kw-1 ), 1 )
                          dtemp = abs( w( itemp, kw-1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! abs( w( imax, kw-1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.(abs( w( imax, kw-1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_${ri}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_${ri}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! ============================================================
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_${ri}$copy( k-p, a( p+1, k ), 1, a( p, p+1 ), lda )
                    call stdlib_${ri}$copy( p, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in last n-k+1 columns of a
                    ! and last n-k+2 columns of w
                    call stdlib_${ri}$swap( n-k+1, a( k, k ), lda, a( p, k ), lda )
                    call stdlib_${ri}$swap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ), ldw )
                 end if
                 ! updated column kp is already stored in column kkw of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_${ri}$copy( k-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_${ri}$copy( kp, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last n-kk+1 columns
                    ! of a and w
                    call stdlib_${ri}$swap( n-kk+1, a( kk, kk ), lda, a( kp, kk ), lda )
                    call stdlib_${ri}$swap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! store u(k) in column k of a
                    call stdlib_${ri}$copy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       if( abs( a( k, k ) )>=sfmin ) then
                          r1 = one / a( k, k )
                          call stdlib_${ri}$scal( k-1, r1, a( 1, k ), 1 )
                       else if( a( k, k )/=zero ) then
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now
                    ! hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    if( k>2 ) then
                       ! store u(k) and u(k-1) in columns k and k-1 of a
                       d12 = w( k-1, kw )
                       d11 = w( k, kw ) / d12
                       d22 = w( k-1, kw-1 ) / d12
                       t = one / ( d11*d22-one )
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( (d11*w( j, kw-1 )-w( j, kw ) ) /d12 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /d12 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', jj-j+1, n-k, -one,a( j, k+1 ), lda, w( jj, &
                              kw+1 ), ldw, one,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb,n-k, -one, a( &
                           1, k+1 ), lda, w( j, kw+1 ), ldw,one, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in columns k+1:n
              j = k + 1
              60 continue
                 kstep = 1
                 jp1 = 1
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    j = j + 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 j = j + 1
                 if( jp2/=jj .and. j<=n )call stdlib_${ri}$swap( n-j+1, a( jp2, j ), lda, a( jj, j ), &
                           lda )
                 jj = j - 1
                 if( jp1/=jj .and. kstep==2 )call stdlib_${ri}$swap( n-j+1, a( jp1, j ), lda, a( jj, j &
                           ), lda )
              if( j<=n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update it
              call stdlib_${ri}$copy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              if( k>1 )call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -one, a( k, 1 ),lda, w( k, &
                        1 ), ldw, one, w( k, k ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ri}$amax( n-k, w( k+1, k ), 1 )
                 colmax = abs( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_${ri}$copy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_${ri}$copy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_${ri}$copy( n-imax+1, a( imax, imax ), 1,w( imax, k+1 ), 1 )
                       if( k>1 )call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -one,a( k, 1 ), &
                                 lda, w( imax, 1 ), ldw,one, w( k, k+1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_i${ri}$amax( imax-k, w( k, k+1 ), 1 )
                          rowmax = abs( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_i${ri}$amax( n-imax, w( imax+1, k+1 ), 1)
                          dtemp = abs( w( itemp, k+1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! abs( w( imax, k+1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( w( imax, k+1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_${ri}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_${ri}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 72
                 end if
                 ! ============================================================
                 kk = k + kstep - 1
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_${ri}$copy( p-k, a( k, k ), 1, a( p, k ), lda )
                    call stdlib_${ri}$copy( n-p+1, a( p, k ), 1, a( p, p ), 1 )
                    ! interchange rows k and p in first k columns of a
                    ! and first k+1 columns of w
                    call stdlib_${ri}$swap( k, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_${ri}$swap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! updated column kp is already stored in column kk of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_${ri}$copy( kp-k-1, a( k+1, kk ), 1, a( kp, k+1 ), lda )
                    call stdlib_${ri}$copy( n-kp+1, a( kp, kk ), 1, a( kp, kp ), 1 )
                    ! interchange rows kk and kp in first kk columns of a and w
                    call stdlib_${ri}$swap( kk, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_${ri}$swap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    ! store l(k) in column k of a
                    call stdlib_${ri}$copy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       if( abs( a( k, k ) )>=sfmin ) then
                          r1 = one / a( k, k )
                          call stdlib_${ri}$scal( n-k, r1, a( k+1, k ), 1 )
                       else if( a( k, k )/=zero ) then
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! store l(k) and l(k+1) in columns k and k+1 of a
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = one / ( d11*d22-one )
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /d21 )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', j+jb-jj, k-1, -one,a( jj, 1 ), lda, w( jj, &
                              1 ), ldw, one,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           one, a( j+jb, 1 ), lda, w( j, 1 ), ldw,one, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! in columns 1:k-1
              j = k - 1
              120 continue
                 kstep = 1
                 jp1 = 1
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    j = j - 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 j = j - 1
                 if( jp2/=jj .and. j>=1 )call stdlib_${ri}$swap( j, a( jp2, 1 ), lda, a( jj, 1 ), lda )
                           
                 jj = j + 1
                 if( jp1/=jj .and. kstep==2 )call stdlib_${ri}$swap( j, a( jp1, 1 ), lda, a( jj, 1 ), &
                           lda )
              if( j>=1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_${ri}$lasyf_rook

#:endif
#:endfor

     module pure subroutine stdlib_clasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
     !! CLASYF_ROOK computes a partial factorization of a complex symmetric
     !! matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! CLASYF_ROOK is an auxiliary routine called by CSYTRF_ROOK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, j, jb, jj, jmax, jp1, jp2, k, kk, kw, kkw, kp, kstep, p, &
                     ii
           real(sp) :: absakk, alpha, colmax, rowmax, stemp, sfmin
           complex(sp) :: d11, d12, d21, d22, r1, t, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              call stdlib_ccopy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ),lda, w( k, &
                        kw+1 ), ldw, cone, w( 1, kw ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_ccopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       call stdlib_ccopy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                       call stdlib_ccopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       if( k<n )call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda,&
                                  w( imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_icamax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = cabs1( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_icamax( imax-1, w( 1, kw-1 ), 1 )
                          stemp = cabs1( w( itemp, kw-1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! cabs1( w( imax, kw-1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.(cabs1( w( imax, kw-1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! ============================================================
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_ccopy( k-p, a( p+1, k ), 1, a( p, p+1 ), lda )
                    call stdlib_ccopy( p, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in last n-k+1 columns of a
                    ! and last n-k+2 columns of w
                    call stdlib_cswap( n-k+1, a( k, k ), lda, a( p, k ), lda )
                    call stdlib_cswap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ), ldw )
                 end if
                 ! updated column kp is already stored in column kkw of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_ccopy( k-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_ccopy( kp, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last n-kk+1 columns
                    ! of a and w
                    call stdlib_cswap( n-kk+1, a( kk, kk ), lda, a( kp, kk ), lda )
                    call stdlib_cswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! store u(k) in column k of a
                    call stdlib_ccopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          r1 = cone / a( k, k )
                          call stdlib_cscal( k-1, r1, a( 1, k ), 1 )
                       else if( a( k, k )/=czero ) then
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now
                    ! hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    if( k>2 ) then
                       ! store u(k) and u(k-1) in columns k and k-1 of a
                       d12 = w( k-1, kw )
                       d11 = w( k, kw ) / d12
                       d22 = w( k-1, kw-1 ) / d12
                       t = cone / ( d11*d22-cone )
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( (d11*w( j, kw-1 )-w( j, kw ) ) /d12 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /d12 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_cgemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb,n-k, -cone, a( &
                           1, k+1 ), lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in columns k+1:n
              j = k + 1
              60 continue
                 kstep = 1
                 jp1 = 1
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    j = j + 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 j = j + 1
                 if( jp2/=jj .and. j<=n )call stdlib_cswap( n-j+1, a( jp2, j ), lda, a( jj, j ), &
                           lda )
                 jj = j - 1
                 if( jp1/=jj .and. kstep==2 )call stdlib_cswap( n-j+1, a( jp1, j ), lda, a( jj, j &
                           ), lda )
              if( j<=n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update it
              call stdlib_ccopy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              if( k>1 )call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( k, &
                        1 ), ldw, cone, w( k, k ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_ccopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_ccopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_ccopy( n-imax+1, a( imax, imax ), 1,w( imax, k+1 ), 1 )
                       if( k>1 )call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone,a( k, 1 ), &
                                 lda, w( imax, 1 ), ldw,cone, w( k, k+1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_icamax( imax-k, w( k, k+1 ), 1 )
                          rowmax = cabs1( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_icamax( n-imax, w( imax+1, k+1 ), 1)
                          stemp = cabs1( w( itemp, k+1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! cabs1( w( imax, k+1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( cabs1( w( imax, k+1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 72
                 end if
                 ! ============================================================
                 kk = k + kstep - 1
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_ccopy( p-k, a( k, k ), 1, a( p, k ), lda )
                    call stdlib_ccopy( n-p+1, a( p, k ), 1, a( p, p ), 1 )
                    ! interchange rows k and p in first k columns of a
                    ! and first k+1 columns of w
                    call stdlib_cswap( k, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_cswap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! updated column kp is already stored in column kk of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_ccopy( kp-k-1, a( k+1, kk ), 1, a( kp, k+1 ), lda )
                    call stdlib_ccopy( n-kp+1, a( kp, kk ), 1, a( kp, kp ), 1 )
                    ! interchange rows kk and kp in first kk columns of a and w
                    call stdlib_cswap( kk, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_cswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    ! store l(k) in column k of a
                    call stdlib_ccopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          r1 = cone / a( k, k )
                          call stdlib_cscal( n-k, r1, a( k+1, k ), 1 )
                       else if( a( k, k )/=czero ) then
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! store l(k) and l(k+1) in columns k and k+1 of a
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /d21 )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_cgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ), ldw,cone, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! in columns 1:k-1
              j = k - 1
              120 continue
                 kstep = 1
                 jp1 = 1
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    j = j - 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 j = j - 1
                 if( jp2/=jj .and. j>=1 )call stdlib_cswap( j, a( jp2, 1 ), lda, a( jj, 1 ), lda )
                           
                 jj = j + 1
                 if( jp1/=jj .and. kstep==2 )call stdlib_cswap( j, a( jp1, 1 ), lda, a( jj, 1 ), &
                           lda )
              if( j>=1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_clasyf_rook

     module pure subroutine stdlib_zlasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
     !! ZLASYF_ROOK computes a partial factorization of a complex symmetric
     !! matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! ZLASYF_ROOK is an auxiliary routine called by ZSYTRF_ROOK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, j, jb, jj, jmax, jp1, jp2, k, kk, kw, kkw, kp, kstep, p, &
                     ii
           real(dp) :: absakk, alpha, colmax, rowmax, dtemp, sfmin
           complex(dp) :: d11, d12, d21, d22, r1, t, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=dp) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_dlamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              call stdlib_zcopy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_zgemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ),lda, w( k, &
                        kw+1 ), ldw, cone, w( 1, kw ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_izamax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_zcopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       call stdlib_zcopy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                       call stdlib_zcopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       if( k<n )call stdlib_zgemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda,&
                                  w( imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_izamax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = cabs1( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_izamax( imax-1, w( 1, kw-1 ), 1 )
                          dtemp = cabs1( w( itemp, kw-1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! cabs1( w( imax, kw-1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.(cabs1( w( imax, kw-1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_zcopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_zcopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! ============================================================
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_zcopy( k-p, a( p+1, k ), 1, a( p, p+1 ), lda )
                    call stdlib_zcopy( p, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in last n-k+1 columns of a
                    ! and last n-k+2 columns of w
                    call stdlib_zswap( n-k+1, a( k, k ), lda, a( p, k ), lda )
                    call stdlib_zswap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ), ldw )
                 end if
                 ! updated column kp is already stored in column kkw of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_zcopy( k-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_zcopy( kp, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last n-kk+1 columns
                    ! of a and w
                    call stdlib_zswap( n-kk+1, a( kk, kk ), lda, a( kp, kk ), lda )
                    call stdlib_zswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! store u(k) in column k of a
                    call stdlib_zcopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          r1 = cone / a( k, k )
                          call stdlib_zscal( k-1, r1, a( 1, k ), 1 )
                       else if( a( k, k )/=czero ) then
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now
                    ! hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    if( k>2 ) then
                       ! store u(k) and u(k-1) in columns k and k-1 of a
                       d12 = w( k-1, kw )
                       d11 = w( k, kw ) / d12
                       d22 = w( k-1, kw-1 ) / d12
                       t = cone / ( d11*d22-cone )
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( (d11*w( j, kw-1 )-w( j, kw ) ) /d12 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /d12 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_zgemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_zgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb,n-k, -cone, a( &
                           1, k+1 ), lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in columns k+1:n
              j = k + 1
              60 continue
                 kstep = 1
                 jp1 = 1
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    j = j + 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 j = j + 1
                 if( jp2/=jj .and. j<=n )call stdlib_zswap( n-j+1, a( jp2, j ), lda, a( jj, j ), &
                           lda )
                 jj = j - 1
                 if( jp1/=jj .and. kstep==2 )call stdlib_zswap( n-j+1, a( jp1, j ), lda, a( jj, j &
                           ), lda )
              if( j<=n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update it
              call stdlib_zcopy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              if( k>1 )call stdlib_zgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( k, &
                        1 ), ldw, cone, w( k, k ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_izamax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_zcopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_zcopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_zcopy( n-imax+1, a( imax, imax ), 1,w( imax, k+1 ), 1 )
                       if( k>1 )call stdlib_zgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone,a( k, 1 ), &
                                 lda, w( imax, 1 ), ldw,cone, w( k, k+1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_izamax( imax-k, w( k, k+1 ), 1 )
                          rowmax = cabs1( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_izamax( n-imax, w( imax+1, k+1 ), 1)
                          dtemp = cabs1( w( itemp, k+1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! cabs1( w( imax, k+1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( cabs1( w( imax, k+1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_zcopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_zcopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 72
                 end if
                 ! ============================================================
                 kk = k + kstep - 1
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_zcopy( p-k, a( k, k ), 1, a( p, k ), lda )
                    call stdlib_zcopy( n-p+1, a( p, k ), 1, a( p, p ), 1 )
                    ! interchange rows k and p in first k columns of a
                    ! and first k+1 columns of w
                    call stdlib_zswap( k, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_zswap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! updated column kp is already stored in column kk of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_zcopy( kp-k-1, a( k+1, kk ), 1, a( kp, k+1 ), lda )
                    call stdlib_zcopy( n-kp+1, a( kp, kk ), 1, a( kp, kp ), 1 )
                    ! interchange rows kk and kp in first kk columns of a and w
                    call stdlib_zswap( kk, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_zswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    ! store l(k) in column k of a
                    call stdlib_zcopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          r1 = cone / a( k, k )
                          call stdlib_zscal( n-k, r1, a( k+1, k ), 1 )
                       else if( a( k, k )/=czero ) then
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! store l(k) and l(k+1) in columns k and k+1 of a
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /d21 )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_zgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_zgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ), ldw,cone, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! in columns 1:k-1
              j = k - 1
              120 continue
                 kstep = 1
                 jp1 = 1
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    j = j - 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 j = j - 1
                 if( jp2/=jj .and. j>=1 )call stdlib_zswap( j, a( jp2, 1 ), lda, a( jj, 1 ), lda )
                           
                 jj = j + 1
                 if( jp1/=jj .and. kstep==2 )call stdlib_zswap( j, a( jp1, 1 ), lda, a( jj, 1 ), &
                           lda )
              if( j>=1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_zlasyf_rook

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$lasyf_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
     !! ZLASYF_ROOK: computes a partial factorization of a complex symmetric
     !! matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! ZLASYF_ROOK is an auxiliary routine called by ZSYTRF_ROOK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: sevten = 17.0e+0_${ck}$
           
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, j, jb, jj, jmax, jp1, jp2, k, kk, kw, kkw, kp, kstep, p, &
                     ii
           real(${ck}$) :: absakk, alpha, colmax, rowmax, dtemp, sfmin
           complex(${ck}$) :: d11, d12, d21, d22, r1, t, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=${ck}$) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_${c2ri(ci)}$lamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              call stdlib_${ci}$copy( k, a( 1, k ), 1, w( 1, kw ), 1 )
              if( k<n )call stdlib_${ci}$gemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ),lda, w( k, &
                        kw+1 ), ldw, cone, w( 1, kw ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, kw ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ci}$amax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_${ci}$copy( k, w( 1, kw ), 1, a( 1, k ), 1 )
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       call stdlib_${ci}$copy( imax, a( 1, imax ), 1, w( 1, kw-1 ), 1 )
                       call stdlib_${ci}$copy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       if( k<n )call stdlib_${ci}$gemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda,&
                                  w( imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_i${ci}$amax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = cabs1( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_i${ci}$amax( imax-1, w( 1, kw-1 ), 1 )
                          dtemp = cabs1( w( itemp, kw-1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! cabs1( w( imax, kw-1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.(cabs1( w( imax, kw-1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_${ci}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_${ci}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! ============================================================
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_${ci}$copy( k-p, a( p+1, k ), 1, a( p, p+1 ), lda )
                    call stdlib_${ci}$copy( p, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in last n-k+1 columns of a
                    ! and last n-k+2 columns of w
                    call stdlib_${ci}$swap( n-k+1, a( k, k ), lda, a( p, k ), lda )
                    call stdlib_${ci}$swap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ), ldw )
                 end if
                 ! updated column kp is already stored in column kkw of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_${ci}$copy( k-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_${ci}$copy( kp, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last n-kk+1 columns
                    ! of a and w
                    call stdlib_${ci}$swap( n-kk+1, a( kk, kk ), lda, a( kp, kk ), lda )
                    call stdlib_${ci}$swap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! store u(k) in column k of a
                    call stdlib_${ci}$copy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          r1 = cone / a( k, k )
                          call stdlib_${ci}$scal( k-1, r1, a( 1, k ), 1 )
                       else if( a( k, k )/=czero ) then
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now
                    ! hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    if( k>2 ) then
                       ! store u(k) and u(k-1) in columns k and k-1 of a
                       d12 = w( k-1, kw )
                       d11 = w( k, kw ) / d12
                       d22 = w( k-1, kw-1 ) / d12
                       t = cone / ( d11*d22-cone )
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( (d11*w( j, kw-1 )-w( j, kw ) ) /d12 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /d12 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**t = a11 - u12*w**t
              ! computing blocks of nb columns at a time
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_${ci}$gemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb,n-k, -cone, a( &
                           1, k+1 ), lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in columns k+1:n
              j = k + 1
              60 continue
                 kstep = 1
                 jp1 = 1
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    j = j + 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 j = j + 1
                 if( jp2/=jj .and. j<=n )call stdlib_${ci}$swap( n-j+1, a( jp2, j ), lda, a( jj, j ), &
                           lda )
                 jj = j - 1
                 if( jp1/=jj .and. kstep==2 )call stdlib_${ci}$swap( n-j+1, a( jp1, j ), lda, a( jj, j &
                           ), lda )
              if( j<=n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update it
              call stdlib_${ci}$copy( n-k+1, a( k, k ), 1, w( k, k ), 1 )
              if( k>1 )call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( k, &
                        1 ), ldw, cone, w( k, k ), 1 )
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( w( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ci}$amax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 call stdlib_${ci}$copy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
              else
                 ! ============================================================
                 ! test for interchange
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_${ci}$copy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_${ci}$copy( n-imax+1, a( imax, imax ), 1,w( imax, k+1 ), 1 )
                       if( k>1 )call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -cone,a( k, 1 ), &
                                 lda, w( imax, 1 ), ldw,cone, w( k, k+1 ), 1 )
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_i${ci}$amax( imax-k, w( k, k+1 ), 1 )
                          rowmax = cabs1( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_i${ci}$amax( n-imax, w( imax+1, k+1 ), 1)
                          dtemp = cabs1( w( itemp, k+1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for
                       ! cabs1( w( imax, k+1 ) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( cabs1( w( imax, k+1 ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_${ci}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_${ci}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 72
                 end if
                 ! ============================================================
                 kk = k + kstep - 1
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p
                    call stdlib_${ci}$copy( p-k, a( k, k ), 1, a( p, k ), lda )
                    call stdlib_${ci}$copy( n-p+1, a( p, k ), 1, a( p, p ), 1 )
                    ! interchange rows k and p in first k columns of a
                    ! and first k+1 columns of w
                    call stdlib_${ci}$swap( k, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_${ci}$swap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! updated column kp is already stored in column kk of w
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp
                    a( kp, k ) = a( kk, k )
                    call stdlib_${ci}$copy( kp-k-1, a( k+1, kk ), 1, a( kp, k+1 ), lda )
                    call stdlib_${ci}$copy( n-kp+1, a( kp, kk ), 1, a( kp, kp ), 1 )
                    ! interchange rows kk and kp in first kk columns of a and w
                    call stdlib_${ci}$swap( kk, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_${ci}$swap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    ! store l(k) in column k of a
                    call stdlib_${ci}$copy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          r1 = cone / a( k, k )
                          call stdlib_${ci}$scal( n-k, r1, a( k+1, k ), 1 )
                       else if( a( k, k )/=czero ) then
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / a( k, k )
                          end do
                       end if
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! store l(k) and l(k+1) in columns k and k+1 of a
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /d21 )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**t = a22 - l21*w**t
              ! computing blocks of nb columns at a time
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    call stdlib_${ci}$gemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ), ldw,cone, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! in columns 1:k-1
              j = k - 1
              120 continue
                 kstep = 1
                 jp1 = 1
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    j = j - 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 j = j - 1
                 if( jp2/=jj .and. j>=1 )call stdlib_${ci}$swap( j, a( jp2, 1 ), lda, a( jj, 1 ), lda )
                           
                 jj = j + 1
                 if( jp1/=jj .and. kstep==2 )call stdlib_${ci}$swap( j, a( jp1, 1 ), lda, a( jj, 1 ), &
                           lda )
              if( j>=1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_${ci}$lasyf_rook

#:endif
#:endfor



     module pure subroutine stdlib_clahef_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
     !! CLAHEF_ROOK computes a partial factorization of a complex Hermitian
     !! matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting
     !! method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0      I     )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! Note that U**H denotes the conjugate transpose of U.
     !! CLAHEF_ROOK is an auxiliary routine called by CHETRF_ROOK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, ii, j, jb, jj, jmax, jp1, jp2, k, kk, kkw, kp, kstep, kw, &
                     p
           real(sp) :: absakk, alpha, colmax, stemp, r1, rowmax, t, sfmin
           complex(sp) :: d11, d21, d22, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11 (note that conjg(w) is actually stored)
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              if( k>1 )call stdlib_ccopy( k-1, a( 1, k ), 1, w( 1, kw ), 1 )
              w( k, kw ) = real( a( k, k ),KIND=sp)
              if( k<n ) then
                 call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ), lda,w( k, kw+1 ), &
                           ldw, cone, w( 1, kw ), 1 )
                 w( k, kw ) = real( w( k, kw ),KIND=sp)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, kw ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( w( k, kw ),KIND=sp)
                 if( k>1 )call stdlib_ccopy( k-1, w( 1, kw ), 1, a( 1, k ), 1 )
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! lop until pivot found
                    done = .false.
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       if( imax>1 )call stdlib_ccopy( imax-1, a( 1, imax ), 1, w( 1, kw-1 ),1 )
                                 
                       w( imax, kw-1 ) = real( a( imax, imax ),KIND=sp)
                       call stdlib_ccopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       call stdlib_clacgv( k-imax, w( imax+1, kw-1 ), 1 )
                       if( k<n ) then
                          call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda, w( &
                                    imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                          w( imax, kw-1 ) = real( w( imax, kw-1 ),KIND=sp)
                       end if
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_icamax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = cabs1( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_icamax( imax-1, w( 1, kw-1 ), 1 )
                          stemp = cabs1( w( itemp, kw-1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=sp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( w( imax,kw-1 ),KIND=sp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 12
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns p and k.
                 ! updated column p is already stored in column kw of w.
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p of submatrix a
                    ! at step k. no need to copy element into columns
                    ! k and k-1 of a for 2-by-2 pivot, since these columns
                    ! will be later overwritten.
                    a( p, p ) = real( a( k, k ),KIND=sp)
                    call stdlib_ccopy( k-1-p, a( p+1, k ), 1, a( p, p+1 ),lda )
                    call stdlib_clacgv( k-1-p, a( p, p+1 ), lda )
                    if( p>1 )call stdlib_ccopy( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in the last k+1 to n columns of a
                    ! (columns k and k-1 of a for 2-by-2 pivot will be
                    ! later overwritten). interchange rows k and p
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_cswap( n-k, a( k, k+1 ), lda, a( p, k+1 ),lda )
                    call stdlib_cswap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ),ldw )
                 end if
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=sp)
                    call stdlib_ccopy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_clacgv( kk-1-kp, a( kp, kp+1 ), lda )
                    if( kp>1 )call stdlib_ccopy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_cswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_cswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! (1) store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element u(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=sp) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_ccopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(3))
                       ! handle division by a small number
                       t = real( a( k, k ),KIND=sp)
                       if( abs( t )>=sfmin ) then
                          r1 = one / t
                          call stdlib_csscal( k-1, r1, a( 1, k ), 1 )
                       else
                          do ii = 1, k-1
                             a( ii, k ) = a( ii, k ) / t
                          end do
                       end if
                       ! (2) conjugate column w(kw)
                       call stdlib_clacgv( k-1, w( 1, kw ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! (1) store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! (note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored)
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! handle division by a small number. (note: order of
                       ! operations is important)
                       ! = ( t*(( d11 )/conj(d21)) t*((  -1 )/d21 ) )
                         ! (   ((  -1 )          )   (( d22 )     ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0 in 2x2 pivot case(4),
                            ! since |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / conjg( d21 )
                       d22 = w( k-1, kw-1 ) / d21
                       t = one / ( real( d11*d22,KIND=sp)-one )
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( ( d11*w( j, kw-1 )-w( j, kw ) ) /d21 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /conjg( d21 ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                    ! (2) conjugate columns w(kw) and w(kw-1)
                    call stdlib_clacgv( k-1, w( 1, kw ), 1 )
                    call stdlib_clacgv( k-2, w( 1, kw-1 ), 1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**h = a11 - u12*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                    call stdlib_cgemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k,-cone, a( &
                           1, k+1 ), lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in of rows in columns k+1:n looping backwards from k+1 to n
              j = k + 1
              60 continue
                 ! undo the interchanges (if any) of rows j and jp2
                 ! (or j and jp2, and j+1 and jp1) at each step j
                 kstep = 1
                 jp1 = 1
                 ! (here, j is a diagonal index)
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    ! (here, j is a diagonal index)
                    j = j + 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 ! (note: here, j is used to determine row length. length n-j+1
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j + 1
                 if( jp2/=jj .and. j<=n )call stdlib_cswap( n-j+1, a( jp2, j ), lda, a( jj, j ), &
                           lda )
                 jj = jj + 1
                 if( kstep==2 .and. jp1/=jj .and. j<=n )call stdlib_cswap( n-j+1, a( jp1, j ), &
                           lda, a( jj, j ), lda )
              if( j<n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22 (note that conjg(w) is actually stored)
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update column k of w
              w( k, k ) = real( a( k, k ),KIND=sp)
              if( k<n )call stdlib_ccopy( n-k, a( k+1, k ), 1, w( k+1, k ), 1 )
              if( k>1 ) then
                 call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( k, 1 ), &
                           ldw, cone, w( k, k ), 1 )
                 w( k, k ) = real( w( k, k ),KIND=sp)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, k ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( w( k, k ),KIND=sp)
                 if( k<n )call stdlib_ccopy( n-k, w( k+1, k ), 1, a( k+1, k ), 1 )
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_ccopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_clacgv( imax-k, w( k, k+1 ), 1 )
                       w( imax, k+1 ) = real( a( imax, imax ),KIND=sp)
                       if( imax<n )call stdlib_ccopy( n-imax, a( imax+1, imax ), 1,w( imax+1, k+1 &
                                 ), 1 )
                       if( k>1 ) then
                          call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone,a( k, 1 ), lda, w( &
                                    imax, 1 ), ldw,cone, w( k, k+1 ), 1 )
                          w( imax, k+1 ) = real( w( imax, k+1 ),KIND=sp)
                       end if
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_icamax( imax-k, w( k, k+1 ), 1 )
                          rowmax = cabs1( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_icamax( n-imax, w( imax+1, k+1 ), 1)
                          stemp = cabs1( w( itemp, k+1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,k+1 ),KIND=sp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( w( imax,k+1 ),KIND=sp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 72
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns p and k (only for 2-by-2 pivot).
                 ! updated column p is already stored in column k of w.
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column kk-1 to column p of submatrix a
                    ! at step k. no need to copy element into columns
                    ! k and k+1 of a for 2-by-2 pivot, since these columns
                    ! will be later overwritten.
                    a( p, p ) = real( a( k, k ),KIND=sp)
                    call stdlib_ccopy( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                    call stdlib_clacgv( p-k-1, a( p, k+1 ), lda )
                    if( p<n )call stdlib_ccopy( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    ! interchange rows k and p in first k-1 columns of a
                    ! (columns k and k+1 of a for 2-by-2 pivot will be
                    ! later overwritten). interchange rows k and p
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_cswap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_cswap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=sp)
                    call stdlib_ccopy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    call stdlib_clacgv( kp-kk-1, a( kp, kk+1 ), lda )
                    if( kp<n )call stdlib_ccopy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (column k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_cswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_cswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! (1) store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=sp) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_ccopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(3))
                       ! handle division by a small number
                       t = real( a( k, k ),KIND=sp)
                       if( abs( t )>=sfmin ) then
                          r1 = one / t
                          call stdlib_csscal( n-k, r1, a( k+1, k ), 1 )
                       else
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / t
                          end do
                       end if
                       ! (2) conjugate column w(k)
                       call stdlib_clacgv( n-k, w( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! (1) store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored.
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! handle division by a small number. (note: order of
                       ! operations is important)
                       ! = ( t*(( d11 )/conj(d21)) t*((  -1 )/d21 ) )
                         ! (   ((  -1 )          )   (( d22 )     ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0 in 2x2 pivot case(4),
                            ! since |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / conjg( d21 )
                       t = one / ( real( d11*d22,KIND=sp)-one )
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /conjg( d21 ) )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    ! (2) conjugate columns w(k) and w(k+1)
                    call stdlib_clacgv( n-k, w( k+1, k ), 1 )
                    call stdlib_clacgv( n-k-1, w( k+2, k+1 ), 1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**h = a22 - l21*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                    call stdlib_cgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! of rows in columns 1:k-1 looping backwards from k-1 to 1
              j = k - 1
              120 continue
                 ! undo the interchanges (if any) of rows j and jp2
                 ! (or j and jp2, and j-1 and jp1) at each step j
                 kstep = 1
                 jp1 = 1
                 ! (here, j is a diagonal index)
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    ! (here, j is a diagonal index)
                    j = j - 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 ! (note: here, j is used to determine row length. length j
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j - 1
                 if( jp2/=jj .and. j>=1 )call stdlib_cswap( j, a( jp2, 1 ), lda, a( jj, 1 ), lda )
                           
                 jj = jj -1
                 if( kstep==2 .and. jp1/=jj .and. j>=1 )call stdlib_cswap( j, a( jp1, 1 ), lda, a(&
                            jj, 1 ), lda )
              if( j>1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_clahef_rook

     module pure subroutine stdlib_zlahef_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
     !! ZLAHEF_ROOK computes a partial factorization of a complex Hermitian
     !! matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting
     !! method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0      I     )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! Note that U**H denotes the conjugate transpose of U.
     !! ZLAHEF_ROOK is an auxiliary routine called by ZHETRF_ROOK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, ii, j, jb, jj, jmax, jp1, jp2, k, kk, kkw, kp, kstep, kw, &
                     p
           real(dp) :: absakk, alpha, colmax, dtemp, r1, rowmax, t, sfmin
           complex(dp) :: d11, d21, d22, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=dp) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_dlamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11 (note that conjg(w) is actually stored)
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              if( k>1 )call stdlib_zcopy( k-1, a( 1, k ), 1, w( 1, kw ), 1 )
              w( k, kw ) = real( a( k, k ),KIND=dp)
              if( k<n ) then
                 call stdlib_zgemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ), lda,w( k, kw+1 ), &
                           ldw, cone, w( 1, kw ), 1 )
                 w( k, kw ) = real( w( k, kw ),KIND=dp)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, kw ),KIND=dp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_izamax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( w( k, kw ),KIND=dp)
                 if( k>1 )call stdlib_zcopy( k-1, w( 1, kw ), 1, a( 1, k ), 1 )
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! lop until pivot found
                    done = .false.
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       if( imax>1 )call stdlib_zcopy( imax-1, a( 1, imax ), 1, w( 1, kw-1 ),1 )
                                 
                       w( imax, kw-1 ) = real( a( imax, imax ),KIND=dp)
                       call stdlib_zcopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       call stdlib_zlacgv( k-imax, w( imax+1, kw-1 ), 1 )
                       if( k<n ) then
                          call stdlib_zgemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda, w( &
                                    imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                          w( imax, kw-1 ) = real( w( imax, kw-1 ),KIND=dp)
                       end if
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_izamax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = cabs1( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_izamax( imax-1, w( 1, kw-1 ), 1 )
                          dtemp = cabs1( w( itemp, kw-1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=dp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( w( imax,kw-1 ),KIND=dp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_zcopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_zcopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 12
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns p and k.
                 ! updated column p is already stored in column kw of w.
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p of submatrix a
                    ! at step k. no need to copy element into columns
                    ! k and k-1 of a for 2-by-2 pivot, since these columns
                    ! will be later overwritten.
                    a( p, p ) = real( a( k, k ),KIND=dp)
                    call stdlib_zcopy( k-1-p, a( p+1, k ), 1, a( p, p+1 ),lda )
                    call stdlib_zlacgv( k-1-p, a( p, p+1 ), lda )
                    if( p>1 )call stdlib_zcopy( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in the last k+1 to n columns of a
                    ! (columns k and k-1 of a for 2-by-2 pivot will be
                    ! later overwritten). interchange rows k and p
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_zswap( n-k, a( k, k+1 ), lda, a( p, k+1 ),lda )
                    call stdlib_zswap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ),ldw )
                 end if
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=dp)
                    call stdlib_zcopy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_zlacgv( kk-1-kp, a( kp, kp+1 ), lda )
                    if( kp>1 )call stdlib_zcopy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_zswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_zswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! (1) store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element u(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=dp) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_zcopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(3))
                       ! handle division by a small number
                       t = real( a( k, k ),KIND=dp)
                       if( abs( t )>=sfmin ) then
                          r1 = one / t
                          call stdlib_zdscal( k-1, r1, a( 1, k ), 1 )
                       else
                          do ii = 1, k-1
                             a( ii, k ) = a( ii, k ) / t
                          end do
                       end if
                       ! (2) conjugate column w(kw)
                       call stdlib_zlacgv( k-1, w( 1, kw ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! (1) store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! (note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored)
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! handle division by a small number. (note: order of
                       ! operations is important)
                       ! = ( t*(( d11 )/conj(d21)) t*((  -1 )/d21 ) )
                         ! (   ((  -1 )          )   (( d22 )     ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0 in 2x2 pivot case(4),
                            ! since |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / conjg( d21 )
                       d22 = w( k-1, kw-1 ) / d21
                       t = one / ( real( d11*d22,KIND=dp)-one )
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( ( d11*w( j, kw-1 )-w( j, kw ) ) /d21 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /conjg( d21 ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                    ! (2) conjugate columns w(kw) and w(kw-1)
                    call stdlib_zlacgv( k-1, w( 1, kw ), 1 )
                    call stdlib_zlacgv( k-2, w( 1, kw-1 ), 1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**h = a11 - u12*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=dp)
                    call stdlib_zgemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=dp)
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_zgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k,-cone, a( &
                           1, k+1 ), lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in of rows in columns k+1:n looping backwards from k+1 to n
              j = k + 1
              60 continue
                 ! undo the interchanges (if any) of rows j and jp2
                 ! (or j and jp2, and j+1 and jp1) at each step j
                 kstep = 1
                 jp1 = 1
                 ! (here, j is a diagonal index)
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    ! (here, j is a diagonal index)
                    j = j + 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 ! (note: here, j is used to determine row length. length n-j+1
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j + 1
                 if( jp2/=jj .and. j<=n )call stdlib_zswap( n-j+1, a( jp2, j ), lda, a( jj, j ), &
                           lda )
                 jj = jj + 1
                 if( kstep==2 .and. jp1/=jj .and. j<=n )call stdlib_zswap( n-j+1, a( jp1, j ), &
                           lda, a( jj, j ), lda )
              if( j<n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22 (note that conjg(w) is actually stored)
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update column k of w
              w( k, k ) = real( a( k, k ),KIND=dp)
              if( k<n )call stdlib_zcopy( n-k, a( k+1, k ), 1, w( k+1, k ), 1 )
              if( k>1 ) then
                 call stdlib_zgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( k, 1 ), &
                           ldw, cone, w( k, k ), 1 )
                 w( k, k ) = real( w( k, k ),KIND=dp)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, k ),KIND=dp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_izamax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( w( k, k ),KIND=dp)
                 if( k<n )call stdlib_zcopy( n-k, w( k+1, k ), 1, a( k+1, k ), 1 )
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_zcopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_zlacgv( imax-k, w( k, k+1 ), 1 )
                       w( imax, k+1 ) = real( a( imax, imax ),KIND=dp)
                       if( imax<n )call stdlib_zcopy( n-imax, a( imax+1, imax ), 1,w( imax+1, k+1 &
                                 ), 1 )
                       if( k>1 ) then
                          call stdlib_zgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone,a( k, 1 ), lda, w( &
                                    imax, 1 ), ldw,cone, w( k, k+1 ), 1 )
                          w( imax, k+1 ) = real( w( imax, k+1 ),KIND=dp)
                       end if
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_izamax( imax-k, w( k, k+1 ), 1 )
                          rowmax = cabs1( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_izamax( n-imax, w( imax+1, k+1 ), 1)
                          dtemp = cabs1( w( itemp, k+1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,k+1 ),KIND=dp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( w( imax,k+1 ),KIND=dp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_zcopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_zcopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 72
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns p and k (only for 2-by-2 pivot).
                 ! updated column p is already stored in column k of w.
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column kk-1 to column p of submatrix a
                    ! at step k. no need to copy element into columns
                    ! k and k+1 of a for 2-by-2 pivot, since these columns
                    ! will be later overwritten.
                    a( p, p ) = real( a( k, k ),KIND=dp)
                    call stdlib_zcopy( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                    call stdlib_zlacgv( p-k-1, a( p, k+1 ), lda )
                    if( p<n )call stdlib_zcopy( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    ! interchange rows k and p in first k-1 columns of a
                    ! (columns k and k+1 of a for 2-by-2 pivot will be
                    ! later overwritten). interchange rows k and p
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_zswap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_zswap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=dp)
                    call stdlib_zcopy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    call stdlib_zlacgv( kp-kk-1, a( kp, kk+1 ), lda )
                    if( kp<n )call stdlib_zcopy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (column k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_zswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_zswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! (1) store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=dp) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_zcopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(3))
                       ! handle division by a small number
                       t = real( a( k, k ),KIND=dp)
                       if( abs( t )>=sfmin ) then
                          r1 = one / t
                          call stdlib_zdscal( n-k, r1, a( k+1, k ), 1 )
                       else
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / t
                          end do
                       end if
                       ! (2) conjugate column w(k)
                       call stdlib_zlacgv( n-k, w( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! (1) store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored.
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! handle division by a small number. (note: order of
                       ! operations is important)
                       ! = ( t*(( d11 )/conj(d21)) t*((  -1 )/d21 ) )
                         ! (   ((  -1 )          )   (( d22 )     ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0 in 2x2 pivot case(4),
                            ! since |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / conjg( d21 )
                       t = one / ( real( d11*d22,KIND=dp)-one )
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /conjg( d21 ) )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    ! (2) conjugate columns w(k) and w(k+1)
                    call stdlib_zlacgv( n-k, w( k+1, k ), 1 )
                    call stdlib_zlacgv( n-k-1, w( k+2, k+1 ), 1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**h = a22 - l21*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=dp)
                    call stdlib_zgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=dp)
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_zgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! of rows in columns 1:k-1 looping backwards from k-1 to 1
              j = k - 1
              120 continue
                 ! undo the interchanges (if any) of rows j and jp2
                 ! (or j and jp2, and j-1 and jp1) at each step j
                 kstep = 1
                 jp1 = 1
                 ! (here, j is a diagonal index)
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    ! (here, j is a diagonal index)
                    j = j - 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 ! (note: here, j is used to determine row length. length j
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j - 1
                 if( jp2/=jj .and. j>=1 )call stdlib_zswap( j, a( jp2, 1 ), lda, a( jj, 1 ), lda )
                           
                 jj = jj -1
                 if( kstep==2 .and. jp1/=jj .and. j>=1 )call stdlib_zswap( j, a( jp1, 1 ), lda, a(&
                            jj, 1 ), lda )
              if( j>1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_zlahef_rook

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$lahef_rook( uplo, n, nb, kb, a, lda, ipiv, w, ldw,info )
     !! ZLAHEF_ROOK: computes a partial factorization of a complex Hermitian
     !! matrix A using the bounded Bunch-Kaufman ("rook") diagonal pivoting
     !! method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'
     !! ( L21  I ) (  0  A22 ) (  0      I     )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! Note that U**H denotes the conjugate transpose of U.
     !! ZLAHEF_ROOK is an auxiliary routine called by ZHETRF_ROOK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: w(ldw,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: sevten = 17.0e+0_${ck}$
           
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, ii, j, jb, jj, jmax, jp1, jp2, k, kk, kkw, kp, kstep, kw, &
                     p
           real(${ck}$) :: absakk, alpha, colmax, dtemp, r1, rowmax, t, sfmin
           complex(${ck}$) :: d11, d21, d22, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=${ck}$) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_${c2ri(ci)}$lamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11 (note that conjg(w) is actually stored)
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              if( k>1 )call stdlib_${ci}$copy( k-1, a( 1, k ), 1, w( 1, kw ), 1 )
              w( k, kw ) = real( a( k, k ),KIND=${ck}$)
              if( k<n ) then
                 call stdlib_${ci}$gemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ), lda,w( k, kw+1 ), &
                           ldw, cone, w( 1, kw ), 1 )
                 w( k, kw ) = real( w( k, kw ),KIND=${ck}$)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, kw ),KIND=${ck}$) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ci}$amax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( w( k, kw ),KIND=${ck}$)
                 if( k>1 )call stdlib_${ci}$copy( k-1, w( 1, kw ), 1, a( 1, k ), 1 )
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! lop until pivot found
                    done = .false.
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       if( imax>1 )call stdlib_${ci}$copy( imax-1, a( 1, imax ), 1, w( 1, kw-1 ),1 )
                                 
                       w( imax, kw-1 ) = real( a( imax, imax ),KIND=${ck}$)
                       call stdlib_${ci}$copy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       call stdlib_${ci}$lacgv( k-imax, w( imax+1, kw-1 ), 1 )
                       if( k<n ) then
                          call stdlib_${ci}$gemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda, w( &
                                    imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                          w( imax, kw-1 ) = real( w( imax, kw-1 ),KIND=${ck}$)
                       end if
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_i${ci}$amax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = cabs1( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_i${ci}$amax( imax-1, w( 1, kw-1 ), 1 )
                          dtemp = cabs1( w( itemp, kw-1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=${ck}$) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( w( imax,kw-1 ),KIND=${ck}$) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_${ci}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_${ci}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 12
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns p and k.
                 ! updated column p is already stored in column kw of w.
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p of submatrix a
                    ! at step k. no need to copy element into columns
                    ! k and k-1 of a for 2-by-2 pivot, since these columns
                    ! will be later overwritten.
                    a( p, p ) = real( a( k, k ),KIND=${ck}$)
                    call stdlib_${ci}$copy( k-1-p, a( p+1, k ), 1, a( p, p+1 ),lda )
                    call stdlib_${ci}$lacgv( k-1-p, a( p, p+1 ), lda )
                    if( p>1 )call stdlib_${ci}$copy( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in the last k+1 to n columns of a
                    ! (columns k and k-1 of a for 2-by-2 pivot will be
                    ! later overwritten). interchange rows k and p
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_${ci}$swap( n-k, a( k, k+1 ), lda, a( p, k+1 ),lda )
                    call stdlib_${ci}$swap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ),ldw )
                 end if
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=${ck}$)
                    call stdlib_${ci}$copy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_${ci}$lacgv( kk-1-kp, a( kp, kp+1 ), lda )
                    if( kp>1 )call stdlib_${ci}$copy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_${ci}$swap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_${ci}$swap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! (1) store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element u(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=${ck}$) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_${ci}$copy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(3))
                       ! handle division by a small number
                       t = real( a( k, k ),KIND=${ck}$)
                       if( abs( t )>=sfmin ) then
                          r1 = one / t
                          call stdlib_${ci}$dscal( k-1, r1, a( 1, k ), 1 )
                       else
                          do ii = 1, k-1
                             a( ii, k ) = a( ii, k ) / t
                          end do
                       end if
                       ! (2) conjugate column w(kw)
                       call stdlib_${ci}$lacgv( k-1, w( 1, kw ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! (1) store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! (note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored)
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! handle division by a small number. (note: order of
                       ! operations is important)
                       ! = ( t*(( d11 )/conj(d21)) t*((  -1 )/d21 ) )
                         ! (   ((  -1 )          )   (( d22 )     ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0 in 2x2 pivot case(4),
                            ! since |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / conjg( d21 )
                       d22 = w( k-1, kw-1 ) / d21
                       t = one / ( real( d11*d22,KIND=${ck}$)-one )
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( ( d11*w( j, kw-1 )-w( j, kw ) ) /d21 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /conjg( d21 ) )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = w( k-1, kw )
                    a( k, k ) = w( k, kw )
                    ! (2) conjugate columns w(kw) and w(kw-1)
                    call stdlib_${ci}$lacgv( k-1, w( 1, kw ), 1 )
                    call stdlib_${ci}$lacgv( k-2, w( 1, kw-1 ), 1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**h = a11 - u12*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=${ck}$)
                    call stdlib_${ci}$gemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=${ck}$)
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k,-cone, a( &
                           1, k+1 ), lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! put u12 in standard form by partially undoing the interchanges
              ! in of rows in columns k+1:n looping backwards from k+1 to n
              j = k + 1
              60 continue
                 ! undo the interchanges (if any) of rows j and jp2
                 ! (or j and jp2, and j+1 and jp1) at each step j
                 kstep = 1
                 jp1 = 1
                 ! (here, j is a diagonal index)
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    ! (here, j is a diagonal index)
                    j = j + 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 ! (note: here, j is used to determine row length. length n-j+1
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j + 1
                 if( jp2/=jj .and. j<=n )call stdlib_${ci}$swap( n-j+1, a( jp2, j ), lda, a( jj, j ), &
                           lda )
                 jj = jj + 1
                 if( kstep==2 .and. jp1/=jj .and. j<=n )call stdlib_${ci}$swap( n-j+1, a( jp1, j ), &
                           lda, a( jj, j ), lda )
              if( j<n )go to 60
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22 (note that conjg(w) is actually stored)
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update column k of w
              w( k, k ) = real( a( k, k ),KIND=${ck}$)
              if( k<n )call stdlib_${ci}$copy( n-k, a( k+1, k ), 1, w( k+1, k ), 1 )
              if( k>1 ) then
                 call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( k, 1 ), &
                           ldw, cone, w( k, k ), 1 )
                 w( k, k ) = real( w( k, k ),KIND=${ck}$)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, k ),KIND=${ck}$) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ci}$amax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( w( k, k ),KIND=${ck}$)
                 if( k<n )call stdlib_${ci}$copy( n-k, w( k+1, k ), 1, a( k+1, k ), 1 )
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_${ci}$copy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_${ci}$lacgv( imax-k, w( k, k+1 ), 1 )
                       w( imax, k+1 ) = real( a( imax, imax ),KIND=${ck}$)
                       if( imax<n )call stdlib_${ci}$copy( n-imax, a( imax+1, imax ), 1,w( imax+1, k+1 &
                                 ), 1 )
                       if( k>1 ) then
                          call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -cone,a( k, 1 ), lda, w( &
                                    imax, 1 ), ldw,cone, w( k, k+1 ), 1 )
                          w( imax, k+1 ) = real( w( imax, k+1 ),KIND=${ck}$)
                       end if
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_i${ci}$amax( imax-k, w( k, k+1 ), 1 )
                          rowmax = cabs1( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_i${ci}$amax( n-imax, w( imax+1, k+1 ), 1)
                          dtemp = cabs1( w( itemp, k+1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,k+1 ),KIND=${ck}$) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( w( imax,k+1 ),KIND=${ck}$) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_${ci}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_${ci}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 72
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns p and k (only for 2-by-2 pivot).
                 ! updated column p is already stored in column k of w.
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column kk-1 to column p of submatrix a
                    ! at step k. no need to copy element into columns
                    ! k and k+1 of a for 2-by-2 pivot, since these columns
                    ! will be later overwritten.
                    a( p, p ) = real( a( k, k ),KIND=${ck}$)
                    call stdlib_${ci}$copy( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                    call stdlib_${ci}$lacgv( p-k-1, a( p, k+1 ), lda )
                    if( p<n )call stdlib_${ci}$copy( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    ! interchange rows k and p in first k-1 columns of a
                    ! (columns k and k+1 of a for 2-by-2 pivot will be
                    ! later overwritten). interchange rows k and p
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_${ci}$swap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_${ci}$swap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=${ck}$)
                    call stdlib_${ci}$copy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    call stdlib_${ci}$lacgv( kp-kk-1, a( kp, kk+1 ), lda )
                    if( kp<n )call stdlib_${ci}$copy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (column k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_${ci}$swap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_${ci}$swap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! (1) store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=${ck}$) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_${ci}$copy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(3))
                       ! handle division by a small number
                       t = real( a( k, k ),KIND=${ck}$)
                       if( abs( t )>=sfmin ) then
                          r1 = one / t
                          call stdlib_${ci}$dscal( n-k, r1, a( k+1, k ), 1 )
                       else
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / t
                          end do
                       end if
                       ! (2) conjugate column w(k)
                       call stdlib_${ci}$lacgv( n-k, w( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! (1) store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored.
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! handle division by a small number. (note: order of
                       ! operations is important)
                       ! = ( t*(( d11 )/conj(d21)) t*((  -1 )/d21 ) )
                         ! (   ((  -1 )          )   (( d22 )     ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0 in 2x2 pivot case(4),
                            ! since |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / conjg( d21 )
                       t = one / ( real( d11*d22,KIND=${ck}$)-one )
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /conjg( d21 ) )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy d(k) to a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = w( k+1, k )
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    ! (2) conjugate columns w(k) and w(k+1)
                    call stdlib_${ci}$lacgv( n-k, w( k+1, k ), 1 )
                    call stdlib_${ci}$lacgv( n-k-1, w( k+2, k+1 ), 1 )
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**h = a22 - l21*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=${ck}$)
                    call stdlib_${ci}$gemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=${ck}$)
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! put l21 in standard form by partially undoing the interchanges
              ! of rows in columns 1:k-1 looping backwards from k-1 to 1
              j = k - 1
              120 continue
                 ! undo the interchanges (if any) of rows j and jp2
                 ! (or j and jp2, and j-1 and jp1) at each step j
                 kstep = 1
                 jp1 = 1
                 ! (here, j is a diagonal index)
                 jj = j
                 jp2 = ipiv( j )
                 if( jp2<0 ) then
                    jp2 = -jp2
                    ! (here, j is a diagonal index)
                    j = j - 1
                    jp1 = -ipiv( j )
                    kstep = 2
                 end if
                 ! (note: here, j is used to determine row length. length j
                 ! of the rows to swap back doesn't include diagonal element)
                 j = j - 1
                 if( jp2/=jj .and. j>=1 )call stdlib_${ci}$swap( j, a( jp2, 1 ), lda, a( jj, 1 ), lda )
                           
                 jj = jj -1
                 if( kstep==2 .and. jp1/=jj .and. j>=1 )call stdlib_${ci}$swap( j, a( jp1, 1 ), lda, a(&
                            jj, 1 ), lda )
              if( j>1 )go to 120
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_${ci}$lahef_rook

#:endif
#:endfor





     module pure subroutine stdlib_cheswapr( uplo, n, a, lda, i1, i2)
     !! CHESWAPR applies an elementary permutation on the rows and the columns of
     !! a hermitian matrix.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: i1, i2, lda, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,n)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           complex(sp) :: tmp
           ! Executable Statements 
           upper = stdlib_lsame( uplo, 'U' )
           if (upper) then
               ! upper
               ! first swap
                ! - swap column i1 and i2 from i1 to i1-1
              call stdlib_cswap( i1-1, a(1,i1), 1, a(1,i2), 1 )
                ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap row i1 from i1+1 to i2-1 with col i2 from i1+1 to i2-1
                ! - swap a(i2,i1) and a(i1,i2)
              tmp=a(i1,i1)
              a(i1,i1)=a(i2,i2)
              a(i2,i2)=tmp
              do i=1,i2-i1-1
                 tmp=a(i1,i1+i)
                 a(i1,i1+i)=conjg(a(i1+i,i2))
                 a(i1+i,i2)=conjg(tmp)
              end do
               a(i1,i2)=conjg(a(i1,i2))
                ! third swap
                ! - swap row i1 and i2 from i2+1 to n
              do i=i2+1,n
                 tmp=a(i1,i)
                 a(i1,i)=a(i2,i)
                 a(i2,i)=tmp
              end do
             else
               ! lower
               ! first swap
                ! - swap row i1 and i2 from 1 to i1-1
              call stdlib_cswap ( i1-1, a(i1,1), lda, a(i2,1), lda )
               ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap col i1 from i1+1 to i2-1 with row i2 from i1+1 to i2-1
                ! - swap a(i2,i1) and a(i1,i2)
               tmp=a(i1,i1)
               a(i1,i1)=a(i2,i2)
               a(i2,i2)=tmp
               do i=1,i2-i1-1
                  tmp=a(i1+i,i1)
                  a(i1+i,i1)=conjg(a(i2,i1+i))
                  a(i2,i1+i)=conjg(tmp)
               end do
               a(i2,i1)=conjg(a(i2,i1))
               ! third swap
                ! - swap col i1 and i2 from i2+1 to n
               do i=i2+1,n
                  tmp=a(i,i1)
                  a(i,i1)=a(i,i2)
                  a(i,i2)=tmp
               end do
           endif
     end subroutine stdlib_cheswapr

     module pure subroutine stdlib_zheswapr( uplo, n, a, lda, i1, i2)
     !! ZHESWAPR applies an elementary permutation on the rows and the columns of
     !! a hermitian matrix.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: i1, i2, lda, n
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,n)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           complex(dp) :: tmp
           ! Executable Statements 
           upper = stdlib_lsame( uplo, 'U' )
           if (upper) then
               ! upper
               ! first swap
                ! - swap column i1 and i2 from i1 to i1-1
              call stdlib_zswap( i1-1, a(1,i1), 1, a(1,i2), 1 )
                ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap row i1 from i1+1 to i2-1 with col i2 from i1+1 to i2-1
                ! - swap a(i2,i1) and a(i1,i2)
              tmp=a(i1,i1)
              a(i1,i1)=a(i2,i2)
              a(i2,i2)=tmp
              do i=1,i2-i1-1
                 tmp=a(i1,i1+i)
                 a(i1,i1+i)=conjg(a(i1+i,i2))
                 a(i1+i,i2)=conjg(tmp)
              end do
               a(i1,i2)=conjg(a(i1,i2))
                ! third swap
                ! - swap row i1 and i2 from i2+1 to n
              do i=i2+1,n
                 tmp=a(i1,i)
                 a(i1,i)=a(i2,i)
                 a(i2,i)=tmp
              end do
             else
               ! lower
               ! first swap
                ! - swap row i1 and i2 from 1 to i1-1
              call stdlib_zswap ( i1-1, a(i1,1), lda, a(i2,1), lda )
               ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap col i1 from i1+1 to i2-1 with row i2 from i1+1 to i2-1
                ! - swap a(i2,i1) and a(i1,i2)
               tmp=a(i1,i1)
               a(i1,i1)=a(i2,i2)
               a(i2,i2)=tmp
               do i=1,i2-i1-1
                  tmp=a(i1+i,i1)
                  a(i1+i,i1)=conjg(a(i2,i1+i))
                  a(i2,i1+i)=conjg(tmp)
               end do
               a(i2,i1)=conjg(a(i2,i1))
               ! third swap
                ! - swap col i1 and i2 from i2+1 to n
               do i=i2+1,n
                  tmp=a(i,i1)
                  a(i,i1)=a(i,i2)
                  a(i,i2)=tmp
               end do
           endif
     end subroutine stdlib_zheswapr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$heswapr( uplo, n, a, lda, i1, i2)
     !! ZHESWAPR: applies an elementary permutation on the rows and the columns of
     !! a hermitian matrix.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: i1, i2, lda, n
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,n)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           complex(${ck}$) :: tmp
           ! Executable Statements 
           upper = stdlib_lsame( uplo, 'U' )
           if (upper) then
               ! upper
               ! first swap
                ! - swap column i1 and i2 from i1 to i1-1
              call stdlib_${ci}$swap( i1-1, a(1,i1), 1, a(1,i2), 1 )
                ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap row i1 from i1+1 to i2-1 with col i2 from i1+1 to i2-1
                ! - swap a(i2,i1) and a(i1,i2)
              tmp=a(i1,i1)
              a(i1,i1)=a(i2,i2)
              a(i2,i2)=tmp
              do i=1,i2-i1-1
                 tmp=a(i1,i1+i)
                 a(i1,i1+i)=conjg(a(i1+i,i2))
                 a(i1+i,i2)=conjg(tmp)
              end do
               a(i1,i2)=conjg(a(i1,i2))
                ! third swap
                ! - swap row i1 and i2 from i2+1 to n
              do i=i2+1,n
                 tmp=a(i1,i)
                 a(i1,i)=a(i2,i)
                 a(i2,i)=tmp
              end do
             else
               ! lower
               ! first swap
                ! - swap row i1 and i2 from 1 to i1-1
              call stdlib_${ci}$swap ( i1-1, a(i1,1), lda, a(i2,1), lda )
               ! second swap :
                ! - swap a(i1,i1) and a(i2,i2)
                ! - swap col i1 from i1+1 to i2-1 with row i2 from i1+1 to i2-1
                ! - swap a(i2,i1) and a(i1,i2)
               tmp=a(i1,i1)
               a(i1,i1)=a(i2,i2)
               a(i2,i2)=tmp
               do i=1,i2-i1-1
                  tmp=a(i1+i,i1)
                  a(i1+i,i1)=conjg(a(i2,i1+i))
                  a(i2,i1+i)=conjg(tmp)
               end do
               a(i2,i1)=conjg(a(i2,i1))
               ! third swap
                ! - swap col i1 and i2 from i2+1 to n
               do i=i2+1,n
                  tmp=a(i,i1)
                  a(i,i1)=a(i,i2)
                  a(i,i2)=tmp
               end do
           endif
     end subroutine stdlib_${ci}$heswapr

#:endif
#:endfor



     module pure subroutine stdlib_ssytf2_rk( uplo, n, a, lda, e, ipiv, info )
     !! SSYTF2_RK computes the factorization of a real symmetric matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: e(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           ! Local Scalars 
           logical(lk) :: upper, done
           integer(ilp) :: i, imax, j, jmax, itemp, k, kk, kp, kstep, p, ii
           real(sp) :: absakk, alpha, colmax, d11, d12, d21, d22, rowmax, stemp, t, wk, wkm1, &
                     wkp1, sfmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYTF2_RK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = zero
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 34
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_isamax( k-1, a( 1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = zero
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange,
                    ! use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_isamax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = abs( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_isamax( imax-1, a( 1, imax ), 1 )
                          stemp = abs( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( abs( a( imax, imax ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the leading
                    ! submatrix a(1:k,1:k) if we have a 2-by-2 pivot
                    if( p>1 )call stdlib_sswap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    if( p<(k-1) )call stdlib_sswap( k-p-1, a( p+1, k ), 1, a( p, p+1 ),lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_sswap( n-k, a( k, k+1 ), lda, a( p, k+1 ), lda )
                 end if
                 ! second swap
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    if( kp>1 )call stdlib_sswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    if( ( kk>1 ) .and. ( kp<(kk-1) ) )call stdlib_sswap( kk-kp-1, a( kp+1, kk ), &
                              1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_sswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( abs( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = one / a( k, k )
                          call stdlib_ssyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_sscal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_ssyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = zero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = one / ( d11*d22-one )
                       do j = k - 2, 1, -1
                          wkm1 = t*( d11*a( j, k-1 )-a( j, k ) )
                          wk = t*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - (a( i, k ) / d12 )*wk -( a( i, k-1 ) / d12 )&
                                       *wkm1
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d12
                          a( j, k-1 ) = wkm1 / d12
                       end do
                    end if
                    ! copy superdiagonal elements of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    e( k ) = a( k-1, k )
                    e( k-1 ) = zero
                    a( k-1, k ) = zero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              34 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = zero
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 64
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_isamax( n-k, a( k+1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ! set e( k ) to zero
                 if( k<n )e( k ) = zero
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_isamax( imax-k, a( imax, k ), lda )
                          rowmax = abs( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_isamax( n-imax, a( imax+1, imax ),1 )
                          stemp = abs( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( abs( a( imax, imax ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 42
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the trailing
                    ! submatrix a(k:n,k:n) if we have a 2-by-2 pivot
                    if( p<n )call stdlib_sswap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    if( p>(k+1) )call stdlib_sswap( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_sswap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                 end if
                 ! second swap
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_sswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    if( ( kk<n ) .and. ( kp>(kk+1) ) )call stdlib_sswap( kp-kk-1, a( kk+1, kk ), &
                              1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_sswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                    ! perform a rank-1 update of a(k+1:n,k+1:n) and
                    ! store l(k) in column k
                       if( abs( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = one / a( k, k )
                          call stdlib_ssyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_sscal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_ssyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = zero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = one / ( d11*d22-one )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = t*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = t*( d22*a( j, k+1 )-a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) - ( a( i, k ) / d21 )*wk -( a( i, k+1 ) / d21 )&
                                       *wkp1
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d21
                          a( j, k+1 ) = wkp1 / d21
                       end do
                    end if
                    ! copy subdiagonal elements of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    e( k ) = a( k+1, k )
                    e( k+1 ) = zero
                    a( k+1, k ) = zero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
              64 continue
           end if
           return
     end subroutine stdlib_ssytf2_rk

     module pure subroutine stdlib_dsytf2_rk( uplo, n, a, lda, e, ipiv, info )
     !! DSYTF2_RK computes the factorization of a real symmetric matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: e(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           ! Local Scalars 
           logical(lk) :: upper, done
           integer(ilp) :: i, imax, j, jmax, itemp, k, kk, kp, kstep, p, ii
           real(dp) :: absakk, alpha, colmax, d11, d12, d21, d22, rowmax, dtemp, t, wk, wkm1, &
                     wkp1, sfmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTF2_RK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_dlamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = zero
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 34
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_idamax( k-1, a( 1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = zero
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange,
                    ! use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_idamax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = abs( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_idamax( imax-1, a( 1, imax ), 1 )
                          dtemp = abs( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( abs( a( imax, imax ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the leading
                    ! submatrix a(1:k,1:k) if we have a 2-by-2 pivot
                    if( p>1 )call stdlib_dswap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    if( p<(k-1) )call stdlib_dswap( k-p-1, a( p+1, k ), 1, a( p, p+1 ),lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_dswap( n-k, a( k, k+1 ), lda, a( p, k+1 ), lda )
                 end if
                 ! second swap
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    if( kp>1 )call stdlib_dswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    if( ( kk>1 ) .and. ( kp<(kk-1) ) )call stdlib_dswap( kk-kp-1, a( kp+1, kk ), &
                              1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_dswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( abs( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = one / a( k, k )
                          call stdlib_dsyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_dscal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_dsyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = zero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = one / ( d11*d22-one )
                       do j = k - 2, 1, -1
                          wkm1 = t*( d11*a( j, k-1 )-a( j, k ) )
                          wk = t*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - (a( i, k ) / d12 )*wk -( a( i, k-1 ) / d12 )&
                                       *wkm1
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d12
                          a( j, k-1 ) = wkm1 / d12
                       end do
                    end if
                    ! copy superdiagonal elements of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    e( k ) = a( k-1, k )
                    e( k-1 ) = zero
                    a( k-1, k ) = zero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              34 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = zero
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 64
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_idamax( n-k, a( k+1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ! set e( k ) to zero
                 if( k<n )e( k ) = zero
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_idamax( imax-k, a( imax, k ), lda )
                          rowmax = abs( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_idamax( n-imax, a( imax+1, imax ),1 )
                          dtemp = abs( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( abs( a( imax, imax ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 42
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the trailing
                    ! submatrix a(k:n,k:n) if we have a 2-by-2 pivot
                    if( p<n )call stdlib_dswap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    if( p>(k+1) )call stdlib_dswap( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_dswap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                 end if
                 ! second swap
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_dswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    if( ( kk<n ) .and. ( kp>(kk+1) ) )call stdlib_dswap( kp-kk-1, a( kk+1, kk ), &
                              1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_dswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                    ! perform a rank-1 update of a(k+1:n,k+1:n) and
                    ! store l(k) in column k
                       if( abs( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = one / a( k, k )
                          call stdlib_dsyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_dscal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_dsyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = zero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = one / ( d11*d22-one )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = t*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = t*( d22*a( j, k+1 )-a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) - ( a( i, k ) / d21 )*wk -( a( i, k+1 ) / d21 )&
                                       *wkp1
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d21
                          a( j, k+1 ) = wkp1 / d21
                       end do
                    end if
                    ! copy subdiagonal elements of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    e( k ) = a( k+1, k )
                    e( k+1 ) = zero
                    a( k+1, k ) = zero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
              64 continue
           end if
           return
     end subroutine stdlib_dsytf2_rk

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sytf2_rk( uplo, n, a, lda, e, ipiv, info )
     !! DSYTF2_RK: computes the factorization of a real symmetric matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: e(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sevten = 17.0e+0_${rk}$
           
           
           ! Local Scalars 
           logical(lk) :: upper, done
           integer(ilp) :: i, imax, j, jmax, itemp, k, kk, kp, kstep, p, ii
           real(${rk}$) :: absakk, alpha, colmax, d11, d12, d21, d22, rowmax, dtemp, t, wk, wkm1, &
                     wkp1, sfmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTF2_RK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_${ri}$lamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = zero
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 34
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ri}$amax( k-1, a( 1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = zero
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange,
                    ! use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_i${ri}$amax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = abs( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_i${ri}$amax( imax-1, a( 1, imax ), 1 )
                          dtemp = abs( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( abs( a( imax, imax ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the leading
                    ! submatrix a(1:k,1:k) if we have a 2-by-2 pivot
                    if( p>1 )call stdlib_${ri}$swap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    if( p<(k-1) )call stdlib_${ri}$swap( k-p-1, a( p+1, k ), 1, a( p, p+1 ),lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_${ri}$swap( n-k, a( k, k+1 ), lda, a( p, k+1 ), lda )
                 end if
                 ! second swap
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    if( kp>1 )call stdlib_${ri}$swap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    if( ( kk>1 ) .and. ( kp<(kk-1) ) )call stdlib_${ri}$swap( kk-kp-1, a( kp+1, kk ), &
                              1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_${ri}$swap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( abs( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = one / a( k, k )
                          call stdlib_${ri}$syr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_${ri}$scal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_${ri}$syr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = zero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = one / ( d11*d22-one )
                       do j = k - 2, 1, -1
                          wkm1 = t*( d11*a( j, k-1 )-a( j, k ) )
                          wk = t*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - (a( i, k ) / d12 )*wk -( a( i, k-1 ) / d12 )&
                                       *wkm1
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d12
                          a( j, k-1 ) = wkm1 / d12
                       end do
                    end if
                    ! copy superdiagonal elements of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    e( k ) = a( k-1, k )
                    e( k-1 ) = zero
                    a( k-1, k ) = zero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              34 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = zero
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 64
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ri}$amax( n-k, a( k+1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ! set e( k ) to zero
                 if( k<n )e( k ) = zero
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_i${ri}$amax( imax-k, a( imax, k ), lda )
                          rowmax = abs( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_i${ri}$amax( n-imax, a( imax+1, imax ),1 )
                          dtemp = abs( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( abs( a( imax, imax ) )<alpha*rowmax ) )then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 42
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the trailing
                    ! submatrix a(k:n,k:n) if we have a 2-by-2 pivot
                    if( p<n )call stdlib_${ri}$swap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    if( p>(k+1) )call stdlib_${ri}$swap( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_${ri}$swap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                 end if
                 ! second swap
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_${ri}$swap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    if( ( kk<n ) .and. ( kp>(kk+1) ) )call stdlib_${ri}$swap( kp-kk-1, a( kk+1, kk ), &
                              1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_${ri}$swap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                    ! perform a rank-1 update of a(k+1:n,k+1:n) and
                    ! store l(k) in column k
                       if( abs( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = one / a( k, k )
                          call stdlib_${ri}$syr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_${ri}$scal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_${ri}$syr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = zero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = one / ( d11*d22-one )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = t*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = t*( d22*a( j, k+1 )-a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) - ( a( i, k ) / d21 )*wk -( a( i, k+1 ) / d21 )&
                                       *wkp1
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d21
                          a( j, k+1 ) = wkp1 / d21
                       end do
                    end if
                    ! copy subdiagonal elements of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    e( k ) = a( k+1, k )
                    e( k+1 ) = zero
                    a( k+1, k ) = zero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
              64 continue
           end if
           return
     end subroutine stdlib_${ri}$sytf2_rk

#:endif
#:endfor

     module pure subroutine stdlib_csytf2_rk( uplo, n, a, lda, e, ipiv, info )
     !! CSYTF2_RK computes the factorization of a complex symmetric matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: e(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: upper, done
           integer(ilp) :: i, imax, j, jmax, itemp, k, kk, kp, kstep, p, ii
           real(sp) :: absakk, alpha, colmax, rowmax, stemp, sfmin
           complex(sp) :: d11, d12, d21, d22, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTF2_RK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = czero
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 34
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = czero
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange,
                    ! use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_icamax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_icamax( imax-1, a( 1, imax ), 1 )
                          stemp = cabs1( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( cabs1( a( imax, imax ) )<alpha*rowmax ))then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the leading
                    ! submatrix a(1:k,1:k) if we have a 2-by-2 pivot
                    if( p>1 )call stdlib_cswap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    if( p<(k-1) )call stdlib_cswap( k-p-1, a( p+1, k ), 1, a( p, p+1 ),lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_cswap( n-k, a( k, k+1 ), lda, a( p, k+1 ), lda )
                 end if
                 ! second swap
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    if( kp>1 )call stdlib_cswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    if( ( kk>1 ) .and. ( kp<(kk-1) ) )call stdlib_cswap( kk-kp-1, a( kp+1, kk ), &
                              1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_cswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = cone / a( k, k )
                          call stdlib_csyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_cscal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_csyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = cone / ( d11*d22-cone )
                       do j = k - 2, 1, -1
                          wkm1 = t*( d11*a( j, k-1 )-a( j, k ) )
                          wk = t*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - (a( i, k ) / d12 )*wk -( a( i, k-1 ) / d12 )&
                                       *wkm1
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d12
                          a( j, k-1 ) = wkm1 / d12
                       end do
                    end if
                    ! copy superdiagonal elements of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    e( k ) = a( k-1, k )
                    e( k-1 ) = czero
                    a( k-1, k ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              34 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = czero
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 64
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ! set e( k ) to zero
                 if( k<n )e( k ) = czero
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_icamax( imax-k, a( imax, k ), lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_icamax( n-imax, a( imax+1, imax ),1 )
                          stemp = cabs1( a( itemp, imax ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( cabs1( a( imax, imax ) )<alpha*rowmax ))then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 42
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the trailing
                    ! submatrix a(k:n,k:n) if we have a 2-by-2 pivot
                    if( p<n )call stdlib_cswap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    if( p>(k+1) )call stdlib_cswap( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_cswap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                 end if
                 ! second swap
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    if( ( kk<n ) .and. ( kp>(kk+1) ) )call stdlib_cswap( kp-kk-1, a( kk+1, kk ), &
                              1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_cswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                    ! perform a rank-1 update of a(k+1:n,k+1:n) and
                    ! store l(k) in column k
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = cone / a( k, k )
                          call stdlib_csyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_cscal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_csyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = t*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = t*( d22*a( j, k+1 )-a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) - ( a( i, k ) / d21 )*wk -( a( i, k+1 ) / d21 )&
                                       *wkp1
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d21
                          a( j, k+1 ) = wkp1 / d21
                       end do
                    end if
                    ! copy subdiagonal elements of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    e( k ) = a( k+1, k )
                    e( k+1 ) = czero
                    a( k+1, k ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
              64 continue
           end if
           return
     end subroutine stdlib_csytf2_rk

     module pure subroutine stdlib_zsytf2_rk( uplo, n, a, lda, e, ipiv, info )
     !! ZSYTF2_RK computes the factorization of a complex symmetric matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: e(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           
           ! Local Scalars 
           logical(lk) :: upper, done
           integer(ilp) :: i, imax, j, jmax, itemp, k, kk, kp, kstep, p, ii
           real(dp) :: absakk, alpha, colmax, rowmax, dtemp, sfmin
           complex(dp) :: d11, d12, d21, d22, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=dp) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTF2_RK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_dlamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = czero
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 34
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_izamax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = czero
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange,
                    ! use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_izamax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_izamax( imax-1, a( 1, imax ), 1 )
                          dtemp = cabs1( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( cabs1( a( imax, imax ) )<alpha*rowmax ))then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the leading
                    ! submatrix a(1:k,1:k) if we have a 2-by-2 pivot
                    if( p>1 )call stdlib_zswap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    if( p<(k-1) )call stdlib_zswap( k-p-1, a( p+1, k ), 1, a( p, p+1 ),lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_zswap( n-k, a( k, k+1 ), lda, a( p, k+1 ), lda )
                 end if
                 ! second swap
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    if( kp>1 )call stdlib_zswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    if( ( kk>1 ) .and. ( kp<(kk-1) ) )call stdlib_zswap( kk-kp-1, a( kp+1, kk ), &
                              1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_zswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = cone / a( k, k )
                          call stdlib_zsyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_zscal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_zsyr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = cone / ( d11*d22-cone )
                       do j = k - 2, 1, -1
                          wkm1 = t*( d11*a( j, k-1 )-a( j, k ) )
                          wk = t*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - (a( i, k ) / d12 )*wk -( a( i, k-1 ) / d12 )&
                                       *wkm1
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d12
                          a( j, k-1 ) = wkm1 / d12
                       end do
                    end if
                    ! copy superdiagonal elements of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    e( k ) = a( k-1, k )
                    e( k-1 ) = czero
                    a( k-1, k ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              34 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = czero
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 64
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_izamax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ! set e( k ) to zero
                 if( k<n )e( k ) = czero
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_izamax( imax-k, a( imax, k ), lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_izamax( n-imax, a( imax+1, imax ),1 )
                          dtemp = cabs1( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( cabs1( a( imax, imax ) )<alpha*rowmax ))then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 42
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the trailing
                    ! submatrix a(k:n,k:n) if we have a 2-by-2 pivot
                    if( p<n )call stdlib_zswap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    if( p>(k+1) )call stdlib_zswap( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_zswap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                 end if
                 ! second swap
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_zswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    if( ( kk<n ) .and. ( kp>(kk+1) ) )call stdlib_zswap( kp-kk-1, a( kk+1, kk ), &
                              1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_zswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                    ! perform a rank-1 update of a(k+1:n,k+1:n) and
                    ! store l(k) in column k
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = cone / a( k, k )
                          call stdlib_zsyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_zscal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_zsyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = t*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = t*( d22*a( j, k+1 )-a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) - ( a( i, k ) / d21 )*wk -( a( i, k+1 ) / d21 )&
                                       *wkp1
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d21
                          a( j, k+1 ) = wkp1 / d21
                       end do
                    end if
                    ! copy subdiagonal elements of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    e( k ) = a( k+1, k )
                    e( k+1 ) = czero
                    a( k+1, k ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
              64 continue
           end if
           return
     end subroutine stdlib_zsytf2_rk

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sytf2_rk( uplo, n, a, lda, e, ipiv, info )
     !! ZSYTF2_RK: computes the factorization of a complex symmetric matrix A
     !! using the bounded Bunch-Kaufman (rook) diagonal pivoting method:
     !! A = P*U*D*(U**T)*(P**T) or A = P*L*D*(L**T)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
     !! For more information see Further Details section.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: e(*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: sevten = 17.0e+0_${ck}$
           
           
           
           ! Local Scalars 
           logical(lk) :: upper, done
           integer(ilp) :: i, imax, j, jmax, itemp, k, kk, kp, kstep, p, ii
           real(${ck}$) :: absakk, alpha, colmax, rowmax, dtemp, sfmin
           complex(${ck}$) :: d11, d12, d21, d22, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=${ck}$) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTF2_RK', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_${c2ri(ci)}$lamch( 'S' )
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = czero
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 34
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ci}$amax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = czero
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange,
                    ! use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    12 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_i${ci}$amax( k-imax, a( imax, imax+1 ),lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_i${ci}$amax( imax-1, a( 1, imax ), 1 )
                          dtemp = cabs1( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( cabs1( a( imax, imax ) )<alpha*rowmax ))then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 12
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the leading
                    ! submatrix a(1:k,1:k) if we have a 2-by-2 pivot
                    if( p>1 )call stdlib_${ci}$swap( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    if( p<(k-1) )call stdlib_${ci}$swap( k-p-1, a( p+1, k ), 1, a( p, p+1 ),lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_${ci}$swap( n-k, a( k, k+1 ), lda, a( p, k+1 ), lda )
                 end if
                 ! second swap
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    if( kp>1 )call stdlib_${ci}$swap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    if( ( kk>1 ) .and. ( kp<(kk-1) ) )call stdlib_${ci}$swap( kk-kp-1, a( kp+1, kk ), &
                              1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert upper triangle of a into u form by applying
                    ! the interchanges in columns k+1:n.
                    if( k<n )call stdlib_${ci}$swap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    if( k>1 ) then
                       ! perform a rank-1 update of a(1:k-1,1:k-1) and
                       ! store u(k) in column k
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(1:k-1,1:k-1) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*1/d(k)*w(k)**t
                          d11 = cone / a( k, k )
                          call stdlib_${ci}$syr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                          ! store u(k) in column k
                          call stdlib_${ci}$scal( k-1, d11, a( 1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = 1, k - 1
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - u(k)*d(k)*u(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_${ci}$syr( uplo, k-1, -d11, a( 1, k ), 1, a, lda )
                       end if
                       ! store the superdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( ( a(k-1)a(k) )*inv(d(k)) ) * ( a(k-1)a(k) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = cone / ( d11*d22-cone )
                       do j = k - 2, 1, -1
                          wkm1 = t*( d11*a( j, k-1 )-a( j, k ) )
                          wk = t*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - (a( i, k ) / d12 )*wk -( a( i, k-1 ) / d12 )&
                                       *wkm1
                          end do
                          ! store u(k) and u(k-1) in cols k and k-1 for row j
                          a( j, k ) = wk / d12
                          a( j, k-1 ) = wkm1 / d12
                       end do
                    end if
                    ! copy superdiagonal elements of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    e( k ) = a( k-1, k )
                    e( k-1 ) = czero
                    a( k-1, k ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              34 continue
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = czero
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 64
              kstep = 1
              p = k
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ci}$amax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( ( max( absakk, colmax )==zero ) ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ! set e( k ) to zero
                 if( k<n )e( k ) = czero
              else
                 ! test for interchange
                 ! equivalent to testing for (used to handle nan and inf)
                 ! absakk>=alpha*colmax
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    42 continue
                       ! begin pivot search loop body
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_i${ci}$amax( imax-k, a( imax, k ), lda )
                          rowmax = cabs1( a( imax, jmax ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_i${ci}$amax( n-imax, a( imax+1, imax ),1 )
                          dtemp = cabs1( a( itemp, imax ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! equivalent to testing for (used to handle nan and inf)
                       ! abs( a( imax, imax ) )>=alpha*rowmax
                       if( .not.( cabs1( a( imax, imax ) )<alpha*rowmax ))then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          done = .true.
                       ! equivalent to testing for rowmax == colmax,
                       ! used to handle nan and inf
                       else if( ( p==jmax ).or.( rowmax<=colmax ) ) then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       else
                          ! pivot not found, set variables and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                       end if
                       ! end pivot search loop body
                    if( .not. done ) goto 42
                 end if
                 ! swap two rows and two columns
                 ! first swap
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! interchange rows and column k and p in the trailing
                    ! submatrix a(k:n,k:n) if we have a 2-by-2 pivot
                    if( p<n )call stdlib_${ci}$swap( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    if( p>(k+1) )call stdlib_${ci}$swap( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                              
                    t = a( k, k )
                    a( k, k ) = a( p, p )
                    a( p, p ) = t
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_${ci}$swap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                 end if
                 ! second swap
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_${ci}$swap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    if( ( kk<n ) .and. ( kp>(kk+1) ) )call stdlib_${ci}$swap( kp-kk-1, a( kk+1, kk ), &
                              1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                    ! convert lower triangle of a into l form by applying
                    ! the interchanges in columns 1:k-1.
                    if ( k>1 )call stdlib_${ci}$swap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                    ! perform a rank-1 update of a(k+1:n,k+1:n) and
                    ! store l(k) in column k
                       if( cabs1( a( k, k ) )>=sfmin ) then
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                          d11 = cone / a( k, k )
                          call stdlib_${ci}$syr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                          ! store l(k) in column k
                          call stdlib_${ci}$scal( n-k, d11, a( k+1, k ), 1 )
                       else
                          ! store l(k) in column k
                          d11 = a( k, k )
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / d11
                          end do
                          ! perform a rank-1 update of a(k+1:n,k+1:n) as
                          ! a := a - l(k)*d(k)*l(k)**t
                             ! = a - w(k)*(1/d(k))*w(k)**t
                             ! = a - (w(k)/d(k))*(d(k))*(w(k)/d(k))**t
                          call stdlib_${ci}$syr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                    
                       end if
                       ! store the subdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! perform a rank-2 update of a(k+2:n,k+2:n) as
                    ! a := a - ( l(k) l(k+1) ) * d(k) * ( l(k) l(k+1) )**t
                       ! = a - ( ( a(k)a(k+1) )*inv(d(k) ) * ( a(k)a(k+1) )**t
                    ! and store l(k) and l(k+1) in columns k and k+1
                    if( k<n-1 ) then
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       do j = k + 2, n
                          ! compute  d21 * ( w(k)w(k+1) ) * inv(d(k)) for row j
                          wk = t*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = t*( d22*a( j, k+1 )-a( j, k ) )
                          ! perform a rank-2 update of a(k+2:n,k+2:n)
                          do i = j, n
                             a( i, j ) = a( i, j ) - ( a( i, k ) / d21 )*wk -( a( i, k+1 ) / d21 )&
                                       *wkp1
                          end do
                          ! store l(k) and l(k+1) in cols k and k+1 for row j
                          a( j, k ) = wk / d21
                          a( j, k+1 ) = wkp1 / d21
                       end do
                    end if
                    ! copy subdiagonal elements of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    e( k ) = a( k+1, k )
                    e( k+1 ) = czero
                    a( k+1, k ) = czero
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
              64 continue
           end if
           return
     end subroutine stdlib_${ci}$sytf2_rk

#:endif
#:endfor



     module pure subroutine stdlib_chptrf( uplo, n, ap, ipiv, info )
     !! CHPTRF computes the factorization of a complex Hermitian packed
     !! matrix A using the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**H  or  A = L*D*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: ap(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kc, kk, knc, kp, kpc, kstep, kx, npp
           real(sp) :: absakk, alpha, colmax, d, d11, d22, r1, rowmax, tt
           complex(sp) :: d12, d21, t, wk, wkm1, wkp1, zdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPTRF', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              kc = ( n-1 )*n / 2 + 1
              10 continue
              knc = kc
              ! if k < 1, exit from loop
              if( k<1 )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( ap( kc+k-1 ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, ap( kc ), 1 )
                 colmax = cabs1( ap( kc+imax-1 ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ap( kc+k-1 ) = real( ap( kc+k-1 ),KIND=sp)
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    rowmax = zero
                    jmax = imax
                    kx = imax*( imax+1 ) / 2 + imax
                    do j = imax + 1, k
                       if( cabs1( ap( kx ) )>rowmax ) then
                          rowmax = cabs1( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + j
                    end do
                    kpc = ( imax-1 )*imax / 2 + 1
                    if( imax>1 ) then
                       jmax = stdlib_icamax( imax-1, ap( kpc ), 1 )
                       rowmax = max( rowmax, cabs1( ap( kpc+jmax-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( real( ap( kpc+imax-1 ),KIND=sp) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kstep==2 )knc = knc - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_cswap( kp-1, ap( knc ), 1, ap( kpc ), 1 )
                    kx = kpc + kp - 1
                    do j = kp + 1, kk - 1
                       kx = kx + j - 1
                       t = conjg( ap( knc+j-1 ) )
                       ap( knc+j-1 ) = conjg( ap( kx ) )
                       ap( kx ) = t
                    end do
                    ap( kx+kk-1 ) = conjg( ap( kx+kk-1 ) )
                    r1 = real( ap( knc+kk-1 ),KIND=sp)
                    ap( knc+kk-1 ) = real( ap( kpc+kp-1 ),KIND=sp)
                    ap( kpc+kp-1 ) = r1
                    if( kstep==2 ) then
                       ap( kc+k-1 ) = real( ap( kc+k-1 ),KIND=sp)
                       t = ap( kc+k-2 )
                       ap( kc+k-2 ) = ap( kc+kp-1 )
                       ap( kc+kp-1 ) = t
                    end if
                 else
                    ap( kc+k-1 ) = real( ap( kc+k-1 ),KIND=sp)
                    if( kstep==2 )ap( kc-1 ) = real( ap( kc-1 ),KIND=sp)
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**h = a - w(k)*1/d(k)*w(k)**h
                    r1 = one / real( ap( kc+k-1 ),KIND=sp)
                    call stdlib_chpr( uplo, k-1, -r1, ap( kc ), 1, ap )
                    ! store u(k) in column k
                    call stdlib_csscal( k-1, r1, ap( kc ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**h
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**h
                    if( k>2 ) then
                       d = stdlib_slapy2( real( ap( k-1+( k-1 )*k / 2 ),KIND=sp),aimag( ap( k-1+( &
                                 k-1 )*k / 2 ) ) )
                       d22 = real( ap( k-1+( k-2 )*( k-1 ) / 2 ),KIND=sp) / d
                       d11 = real( ap( k+( k-1 )*k / 2 ),KIND=sp) / d
                       tt = one / ( d11*d22-one )
                       d12 = ap( k-1+( k-1 )*k / 2 ) / d
                       d = tt / d
                       do j = k - 2, 1, -1
                          wkm1 = d*( d11*ap( j+( k-2 )*( k-1 ) / 2 )-conjg( d12 )*ap( j+( k-1 )*k &
                                    / 2 ) )
                          wk = d*( d22*ap( j+( k-1 )*k / 2 )-d12*ap( j+( k-2 )*( k-1 ) / 2 ) )
                                    
                          do i = j, 1, -1
                             ap( i+( j-1 )*j / 2 ) = ap( i+( j-1 )*j / 2 ) -ap( i+( k-1 )*k / 2 )&
                                       *conjg( wk ) -ap( i+( k-2 )*( k-1 ) / 2 )*conjg( wkm1 )
                          end do
                          ap( j+( k-1 )*k / 2 ) = wk
                          ap( j+( k-2 )*( k-1 ) / 2 ) = wkm1
                          ap( j+( j-1 )*j / 2 ) = cmplx( real( ap( j+( j-1 )*j / 2 ),KIND=sp), &
                                    zero,KIND=sp)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              kc = knc - k
              go to 10
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              kc = 1
              npp = n*( n+1 ) / 2
              60 continue
              knc = kc
              ! if k > n, exit from loop
              if( k>n )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( ap( kc ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, ap( kc+1 ), 1 )
                 colmax = cabs1( ap( kc+imax-k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ap( kc ) = real( ap( kc ),KIND=sp)
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    rowmax = zero
                    kx = kc + imax - k
                    do j = k, imax - 1
                       if( cabs1( ap( kx ) )>rowmax ) then
                          rowmax = cabs1( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + n - j
                    end do
                    kpc = npp - ( n-imax+1 )*( n-imax+2 ) / 2 + 1
                    if( imax<n ) then
                       jmax = imax + stdlib_icamax( n-imax, ap( kpc+1 ), 1 )
                       rowmax = max( rowmax, cabs1( ap( kpc+jmax-imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( real( ap( kpc ),KIND=sp) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kstep==2 )knc = knc + n - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_cswap( n-kp, ap( knc+kp-kk+1 ), 1, ap( kpc+1 ),1 )
                              
                    kx = knc + kp - kk
                    do j = kk + 1, kp - 1
                       kx = kx + n - j + 1
                       t = conjg( ap( knc+j-kk ) )
                       ap( knc+j-kk ) = conjg( ap( kx ) )
                       ap( kx ) = t
                    end do
                    ap( knc+kp-kk ) = conjg( ap( knc+kp-kk ) )
                    r1 = real( ap( knc ),KIND=sp)
                    ap( knc ) = real( ap( kpc ),KIND=sp)
                    ap( kpc ) = r1
                    if( kstep==2 ) then
                       ap( kc ) = real( ap( kc ),KIND=sp)
                       t = ap( kc+1 )
                       ap( kc+1 ) = ap( kc+kp-k )
                       ap( kc+kp-k ) = t
                    end if
                 else
                    ap( kc ) = real( ap( kc ),KIND=sp)
                    if( kstep==2 )ap( knc ) = real( ap( knc ),KIND=sp)
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**h = a - w(k)*(1/d(k))*w(k)**h
                       r1 = one / real( ap( kc ),KIND=sp)
                       call stdlib_chpr( uplo, n-k, -r1, ap( kc+1 ), 1,ap( kc+n-k+1 ) )
                       ! store l(k) in column k
                       call stdlib_csscal( n-k, r1, ap( kc+1 ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**h
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**h
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d = stdlib_slapy2( real( ap( k+1+( k-1 )*( 2*n-k ) / 2 ),KIND=sp),aimag( &
                                 ap( k+1+( k-1 )*( 2*n-k ) / 2 ) ) )
                       d11 = real( ap( k+1+k*( 2*n-k-1 ) / 2 ),KIND=sp) / d
                       d22 = real( ap( k+( k-1 )*( 2*n-k ) / 2 ),KIND=sp) / d
                       tt = one / ( d11*d22-one )
                       d21 = ap( k+1+( k-1 )*( 2*n-k ) / 2 ) / d
                       d = tt / d
                       do j = k + 2, n
                          wk = d*( d11*ap( j+( k-1 )*( 2*n-k ) / 2 )-d21*ap( j+k*( 2*n-k-1 ) / 2 )&
                                     )
                          wkp1 = d*( d22*ap( j+k*( 2*n-k-1 ) / 2 )-conjg( d21 )*ap( j+( k-1 )*( &
                                    2*n-k ) / 2 ) )
                          do i = j, n
                             ap( i+( j-1 )*( 2*n-j ) / 2 ) = ap( i+( j-1 )*( 2*n-j ) / 2 ) - ap( &
                             i+( k-1 )*( 2*n-k ) /2 )*conjg( wk ) - ap( i+k*( 2*n-k-1 ) / 2 )&
                                       *conjg( wkp1 )
                          end do
                          ap( j+( k-1 )*( 2*n-k ) / 2 ) = wk
                          ap( j+k*( 2*n-k-1 ) / 2 ) = wkp1
                          ap( j+( j-1 )*( 2*n-j ) / 2 )= cmplx( real( ap( j+( j-1 )*( 2*n-j ) / 2 &
                                    ),KIND=sp),zero,KIND=sp)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              kc = knc + n - k + 2
              go to 60
           end if
           110 continue
           return
     end subroutine stdlib_chptrf

     module pure subroutine stdlib_zhptrf( uplo, n, ap, ipiv, info )
     !! ZHPTRF computes the factorization of a complex Hermitian packed
     !! matrix A using the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**H  or  A = L*D*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: ap(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kc, kk, knc, kp, kpc, kstep, kx, npp
           real(dp) :: absakk, alpha, colmax, d, d11, d22, r1, rowmax, tt
           complex(dp) :: d12, d21, t, wk, wkm1, wkp1, zdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=dp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHPTRF', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              kc = ( n-1 )*n / 2 + 1
              10 continue
              knc = kc
              ! if k < 1, exit from loop
              if( k<1 )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( ap( kc+k-1 ),KIND=dp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k>1 ) then
                 imax = stdlib_izamax( k-1, ap( kc ), 1 )
                 colmax = cabs1( ap( kc+imax-1 ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ap( kc+k-1 ) = real( ap( kc+k-1 ),KIND=dp)
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    rowmax = zero
                    jmax = imax
                    kx = imax*( imax+1 ) / 2 + imax
                    do j = imax + 1, k
                       if( cabs1( ap( kx ) )>rowmax ) then
                          rowmax = cabs1( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + j
                    end do
                    kpc = ( imax-1 )*imax / 2 + 1
                    if( imax>1 ) then
                       jmax = stdlib_izamax( imax-1, ap( kpc ), 1 )
                       rowmax = max( rowmax, cabs1( ap( kpc+jmax-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( real( ap( kpc+imax-1 ),KIND=dp) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kstep==2 )knc = knc - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_zswap( kp-1, ap( knc ), 1, ap( kpc ), 1 )
                    kx = kpc + kp - 1
                    do j = kp + 1, kk - 1
                       kx = kx + j - 1
                       t = conjg( ap( knc+j-1 ) )
                       ap( knc+j-1 ) = conjg( ap( kx ) )
                       ap( kx ) = t
                    end do
                    ap( kx+kk-1 ) = conjg( ap( kx+kk-1 ) )
                    r1 = real( ap( knc+kk-1 ),KIND=dp)
                    ap( knc+kk-1 ) = real( ap( kpc+kp-1 ),KIND=dp)
                    ap( kpc+kp-1 ) = r1
                    if( kstep==2 ) then
                       ap( kc+k-1 ) = real( ap( kc+k-1 ),KIND=dp)
                       t = ap( kc+k-2 )
                       ap( kc+k-2 ) = ap( kc+kp-1 )
                       ap( kc+kp-1 ) = t
                    end if
                 else
                    ap( kc+k-1 ) = real( ap( kc+k-1 ),KIND=dp)
                    if( kstep==2 )ap( kc-1 ) = real( ap( kc-1 ),KIND=dp)
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**h = a - w(k)*1/d(k)*w(k)**h
                    r1 = one / real( ap( kc+k-1 ),KIND=dp)
                    call stdlib_zhpr( uplo, k-1, -r1, ap( kc ), 1, ap )
                    ! store u(k) in column k
                    call stdlib_zdscal( k-1, r1, ap( kc ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**h
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**h
                    if( k>2 ) then
                       d = stdlib_dlapy2( real( ap( k-1+( k-1 )*k / 2 ),KIND=dp),aimag( ap( k-1+( &
                                 k-1 )*k / 2 ) ) )
                       d22 = real( ap( k-1+( k-2 )*( k-1 ) / 2 ),KIND=dp) / d
                       d11 = real( ap( k+( k-1 )*k / 2 ),KIND=dp) / d
                       tt = one / ( d11*d22-one )
                       d12 = ap( k-1+( k-1 )*k / 2 ) / d
                       d = tt / d
                       do j = k - 2, 1, -1
                          wkm1 = d*( d11*ap( j+( k-2 )*( k-1 ) / 2 )-conjg( d12 )*ap( j+( k-1 )*k &
                                    / 2 ) )
                          wk = d*( d22*ap( j+( k-1 )*k / 2 )-d12*ap( j+( k-2 )*( k-1 ) / 2 ) )
                                    
                          do i = j, 1, -1
                             ap( i+( j-1 )*j / 2 ) = ap( i+( j-1 )*j / 2 ) -ap( i+( k-1 )*k / 2 )&
                                       *conjg( wk ) -ap( i+( k-2 )*( k-1 ) / 2 )*conjg( wkm1 )
                          end do
                          ap( j+( k-1 )*k / 2 ) = wk
                          ap( j+( k-2 )*( k-1 ) / 2 ) = wkm1
                          ap( j+( j-1 )*j / 2 ) = cmplx( real( ap( j+( j-1 )*j / 2 ),KIND=dp), &
                                    zero,KIND=dp)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              kc = knc - k
              go to 10
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              kc = 1
              npp = n*( n+1 ) / 2
              60 continue
              knc = kc
              ! if k > n, exit from loop
              if( k>n )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( ap( kc ),KIND=dp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k<n ) then
                 imax = k + stdlib_izamax( n-k, ap( kc+1 ), 1 )
                 colmax = cabs1( ap( kc+imax-k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ap( kc ) = real( ap( kc ),KIND=dp)
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    rowmax = zero
                    kx = kc + imax - k
                    do j = k, imax - 1
                       if( cabs1( ap( kx ) )>rowmax ) then
                          rowmax = cabs1( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + n - j
                    end do
                    kpc = npp - ( n-imax+1 )*( n-imax+2 ) / 2 + 1
                    if( imax<n ) then
                       jmax = imax + stdlib_izamax( n-imax, ap( kpc+1 ), 1 )
                       rowmax = max( rowmax, cabs1( ap( kpc+jmax-imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( real( ap( kpc ),KIND=dp) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kstep==2 )knc = knc + n - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_zswap( n-kp, ap( knc+kp-kk+1 ), 1, ap( kpc+1 ),1 )
                              
                    kx = knc + kp - kk
                    do j = kk + 1, kp - 1
                       kx = kx + n - j + 1
                       t = conjg( ap( knc+j-kk ) )
                       ap( knc+j-kk ) = conjg( ap( kx ) )
                       ap( kx ) = t
                    end do
                    ap( knc+kp-kk ) = conjg( ap( knc+kp-kk ) )
                    r1 = real( ap( knc ),KIND=dp)
                    ap( knc ) = real( ap( kpc ),KIND=dp)
                    ap( kpc ) = r1
                    if( kstep==2 ) then
                       ap( kc ) = real( ap( kc ),KIND=dp)
                       t = ap( kc+1 )
                       ap( kc+1 ) = ap( kc+kp-k )
                       ap( kc+kp-k ) = t
                    end if
                 else
                    ap( kc ) = real( ap( kc ),KIND=dp)
                    if( kstep==2 )ap( knc ) = real( ap( knc ),KIND=dp)
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**h = a - w(k)*(1/d(k))*w(k)**h
                       r1 = one / real( ap( kc ),KIND=dp)
                       call stdlib_zhpr( uplo, n-k, -r1, ap( kc+1 ), 1,ap( kc+n-k+1 ) )
                       ! store l(k) in column k
                       call stdlib_zdscal( n-k, r1, ap( kc+1 ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**h
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**h
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d = stdlib_dlapy2( real( ap( k+1+( k-1 )*( 2*n-k ) / 2 ),KIND=dp),aimag( &
                                 ap( k+1+( k-1 )*( 2*n-k ) / 2 ) ) )
                       d11 = real( ap( k+1+k*( 2*n-k-1 ) / 2 ),KIND=dp) / d
                       d22 = real( ap( k+( k-1 )*( 2*n-k ) / 2 ),KIND=dp) / d
                       tt = one / ( d11*d22-one )
                       d21 = ap( k+1+( k-1 )*( 2*n-k ) / 2 ) / d
                       d = tt / d
                       do j = k + 2, n
                          wk = d*( d11*ap( j+( k-1 )*( 2*n-k ) / 2 )-d21*ap( j+k*( 2*n-k-1 ) / 2 )&
                                     )
                          wkp1 = d*( d22*ap( j+k*( 2*n-k-1 ) / 2 )-conjg( d21 )*ap( j+( k-1 )*( &
                                    2*n-k ) /2 ) )
                          do i = j, n
                             ap( i+( j-1 )*( 2*n-j ) / 2 ) = ap( i+( j-1 )*( 2*n-j ) / 2 ) - ap( &
                             i+( k-1 )*( 2*n-k ) /2 )*conjg( wk ) - ap( i+k*( 2*n-k-1 ) / 2 )&
                                       *conjg( wkp1 )
                          end do
                          ap( j+( k-1 )*( 2*n-k ) / 2 ) = wk
                          ap( j+k*( 2*n-k-1 ) / 2 ) = wkp1
                          ap( j+( j-1 )*( 2*n-j ) / 2 )= cmplx( real( ap( j+( j-1 )*( 2*n-j ) / 2 &
                                    ),KIND=dp),zero,KIND=dp)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              kc = knc + n - k + 2
              go to 60
           end if
           110 continue
           return
     end subroutine stdlib_zhptrf

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hptrf( uplo, n, ap, ipiv, info )
     !! ZHPTRF: computes the factorization of a complex Hermitian packed
     !! matrix A using the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**H  or  A = L*D*L**H
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: ap(*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: sevten = 17.0e+0_${ck}$
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kc, kk, knc, kp, kpc, kstep, kx, npp
           real(${ck}$) :: absakk, alpha, colmax, d, d11, d22, r1, rowmax, tt
           complex(${ck}$) :: d12, d21, t, wk, wkm1, wkp1, zdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=${ck}$) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHPTRF', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**h using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              kc = ( n-1 )*n / 2 + 1
              10 continue
              knc = kc
              ! if k < 1, exit from loop
              if( k<1 )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( ap( kc+k-1 ),KIND=${ck}$) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k>1 ) then
                 imax = stdlib_i${ci}$amax( k-1, ap( kc ), 1 )
                 colmax = cabs1( ap( kc+imax-1 ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ap( kc+k-1 ) = real( ap( kc+k-1 ),KIND=${ck}$)
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    rowmax = zero
                    jmax = imax
                    kx = imax*( imax+1 ) / 2 + imax
                    do j = imax + 1, k
                       if( cabs1( ap( kx ) )>rowmax ) then
                          rowmax = cabs1( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + j
                    end do
                    kpc = ( imax-1 )*imax / 2 + 1
                    if( imax>1 ) then
                       jmax = stdlib_i${ci}$amax( imax-1, ap( kpc ), 1 )
                       rowmax = max( rowmax, cabs1( ap( kpc+jmax-1 ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( real( ap( kpc+imax-1 ),KIND=${ck}$) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kstep==2 )knc = knc - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_${ci}$swap( kp-1, ap( knc ), 1, ap( kpc ), 1 )
                    kx = kpc + kp - 1
                    do j = kp + 1, kk - 1
                       kx = kx + j - 1
                       t = conjg( ap( knc+j-1 ) )
                       ap( knc+j-1 ) = conjg( ap( kx ) )
                       ap( kx ) = t
                    end do
                    ap( kx+kk-1 ) = conjg( ap( kx+kk-1 ) )
                    r1 = real( ap( knc+kk-1 ),KIND=${ck}$)
                    ap( knc+kk-1 ) = real( ap( kpc+kp-1 ),KIND=${ck}$)
                    ap( kpc+kp-1 ) = r1
                    if( kstep==2 ) then
                       ap( kc+k-1 ) = real( ap( kc+k-1 ),KIND=${ck}$)
                       t = ap( kc+k-2 )
                       ap( kc+k-2 ) = ap( kc+kp-1 )
                       ap( kc+kp-1 ) = t
                    end if
                 else
                    ap( kc+k-1 ) = real( ap( kc+k-1 ),KIND=${ck}$)
                    if( kstep==2 )ap( kc-1 ) = real( ap( kc-1 ),KIND=${ck}$)
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**h = a - w(k)*1/d(k)*w(k)**h
                    r1 = one / real( ap( kc+k-1 ),KIND=${ck}$)
                    call stdlib_${ci}$hpr( uplo, k-1, -r1, ap( kc ), 1, ap )
                    ! store u(k) in column k
                    call stdlib_${ci}$dscal( k-1, r1, ap( kc ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**h
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**h
                    if( k>2 ) then
                       d = stdlib_${c2ri(ci)}$lapy2( real( ap( k-1+( k-1 )*k / 2 ),KIND=${ck}$),aimag( ap( k-1+( &
                                 k-1 )*k / 2 ) ) )
                       d22 = real( ap( k-1+( k-2 )*( k-1 ) / 2 ),KIND=${ck}$) / d
                       d11 = real( ap( k+( k-1 )*k / 2 ),KIND=${ck}$) / d
                       tt = one / ( d11*d22-one )
                       d12 = ap( k-1+( k-1 )*k / 2 ) / d
                       d = tt / d
                       do j = k - 2, 1, -1
                          wkm1 = d*( d11*ap( j+( k-2 )*( k-1 ) / 2 )-conjg( d12 )*ap( j+( k-1 )*k &
                                    / 2 ) )
                          wk = d*( d22*ap( j+( k-1 )*k / 2 )-d12*ap( j+( k-2 )*( k-1 ) / 2 ) )
                                    
                          do i = j, 1, -1
                             ap( i+( j-1 )*j / 2 ) = ap( i+( j-1 )*j / 2 ) -ap( i+( k-1 )*k / 2 )&
                                       *conjg( wk ) -ap( i+( k-2 )*( k-1 ) / 2 )*conjg( wkm1 )
                          end do
                          ap( j+( k-1 )*k / 2 ) = wk
                          ap( j+( k-2 )*( k-1 ) / 2 ) = wkm1
                          ap( j+( j-1 )*j / 2 ) = cmplx( real( ap( j+( j-1 )*j / 2 ),KIND=${ck}$), &
                                    zero,KIND=${ck}$)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              kc = knc - k
              go to 10
           else
              ! factorize a as l*d*l**h using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              kc = 1
              npp = n*( n+1 ) / 2
              60 continue
              knc = kc
              ! if k > n, exit from loop
              if( k>n )go to 110
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( ap( kc ),KIND=${ck}$) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value
              if( k<n ) then
                 imax = k + stdlib_i${ci}$amax( n-k, ap( kc+1 ), 1 )
                 colmax = cabs1( ap( kc+imax-k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero: set info and continue
                 if( info==0 )info = k
                 kp = k
                 ap( kc ) = real( ap( kc ),KIND=${ck}$)
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    rowmax = zero
                    kx = kc + imax - k
                    do j = k, imax - 1
                       if( cabs1( ap( kx ) )>rowmax ) then
                          rowmax = cabs1( ap( kx ) )
                          jmax = j
                       end if
                       kx = kx + n - j
                    end do
                    kpc = npp - ( n-imax+1 )*( n-imax+2 ) / 2 + 1
                    if( imax<n ) then
                       jmax = imax + stdlib_i${ci}$amax( n-imax, ap( kpc+1 ), 1 )
                       rowmax = max( rowmax, cabs1( ap( kpc+jmax-imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( real( ap( kpc ),KIND=${ck}$) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kstep==2 )knc = knc + n - k + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_${ci}$swap( n-kp, ap( knc+kp-kk+1 ), 1, ap( kpc+1 ),1 )
                              
                    kx = knc + kp - kk
                    do j = kk + 1, kp - 1
                       kx = kx + n - j + 1
                       t = conjg( ap( knc+j-kk ) )
                       ap( knc+j-kk ) = conjg( ap( kx ) )
                       ap( kx ) = t
                    end do
                    ap( knc+kp-kk ) = conjg( ap( knc+kp-kk ) )
                    r1 = real( ap( knc ),KIND=${ck}$)
                    ap( knc ) = real( ap( kpc ),KIND=${ck}$)
                    ap( kpc ) = r1
                    if( kstep==2 ) then
                       ap( kc ) = real( ap( kc ),KIND=${ck}$)
                       t = ap( kc+1 )
                       ap( kc+1 ) = ap( kc+kp-k )
                       ap( kc+kp-k ) = t
                    end if
                 else
                    ap( kc ) = real( ap( kc ),KIND=${ck}$)
                    if( kstep==2 )ap( knc ) = real( ap( knc ),KIND=${ck}$)
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**h = a - w(k)*(1/d(k))*w(k)**h
                       r1 = one / real( ap( kc ),KIND=${ck}$)
                       call stdlib_${ci}$hpr( uplo, n-k, -r1, ap( kc+1 ), 1,ap( kc+n-k+1 ) )
                       ! store l(k) in column k
                       call stdlib_${ci}$dscal( n-k, r1, ap( kc+1 ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**h
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**h
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d = stdlib_${c2ri(ci)}$lapy2( real( ap( k+1+( k-1 )*( 2*n-k ) / 2 ),KIND=${ck}$),aimag( &
                                 ap( k+1+( k-1 )*( 2*n-k ) / 2 ) ) )
                       d11 = real( ap( k+1+k*( 2*n-k-1 ) / 2 ),KIND=${ck}$) / d
                       d22 = real( ap( k+( k-1 )*( 2*n-k ) / 2 ),KIND=${ck}$) / d
                       tt = one / ( d11*d22-one )
                       d21 = ap( k+1+( k-1 )*( 2*n-k ) / 2 ) / d
                       d = tt / d
                       do j = k + 2, n
                          wk = d*( d11*ap( j+( k-1 )*( 2*n-k ) / 2 )-d21*ap( j+k*( 2*n-k-1 ) / 2 )&
                                     )
                          wkp1 = d*( d22*ap( j+k*( 2*n-k-1 ) / 2 )-conjg( d21 )*ap( j+( k-1 )*( &
                                    2*n-k ) /2 ) )
                          do i = j, n
                             ap( i+( j-1 )*( 2*n-j ) / 2 ) = ap( i+( j-1 )*( 2*n-j ) / 2 ) - ap( &
                             i+( k-1 )*( 2*n-k ) /2 )*conjg( wk ) - ap( i+k*( 2*n-k-1 ) / 2 )&
                                       *conjg( wkp1 )
                          end do
                          ap( j+( k-1 )*( 2*n-k ) / 2 ) = wk
                          ap( j+k*( 2*n-k-1 ) / 2 ) = wkp1
                          ap( j+( j-1 )*( 2*n-j ) / 2 )= cmplx( real( ap( j+( j-1 )*( 2*n-j ) / 2 &
                                    ),KIND=${ck}$),zero,KIND=${ck}$)
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              kc = knc + n - k + 2
              go to 60
           end if
           110 continue
           return
     end subroutine stdlib_${ci}$hptrf

#:endif
#:endfor



     module pure subroutine stdlib_chetrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
     !! CHETRS_3 solves a system of linear equations A * X = B with a complex
     !! Hermitian matrix A using the factorization computed
     !! by CHETRF_RK or CHETRF_BK:
     !! A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This algorithm is using Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*), e(*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j, k, kp
           real(sp) :: s
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRS_3', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! begin upper
              ! solve a*x = b, where a = u*d*u**h.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
              call stdlib_ctrsm( 'L', 'U', 'N', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i = n
              do while ( i>=1 )
                 if( ipiv( i )>0 ) then
                    s = real( cone,KIND=sp) / real( a( i, i ),KIND=sp)
                    call stdlib_csscal( nrhs, s, b( i, 1 ), ldb )
                 else if ( i>1 ) then
                    akm1k = e( i )
                    akm1 = a( i-1, i-1 ) / akm1k
                    ak = a( i, i ) / conjg( akm1k )
                    denom = akm1*ak - cone
                    do j = 1, nrhs
                       bkm1 = b( i-1, j ) / akm1k
                       bk = b( i, j ) / conjg( akm1k )
                       b( i-1, j ) = ( ak*bkm1-bk ) / denom
                       b( i, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i - 1
                 end if
                 i = i - 1
              end do
              ! compute (u**h \ b) -> b   [ u**h \ (d \ (u \p**t * b) ) ]
              call stdlib_ctrsm( 'L', 'U', 'C', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! p * b  [ p * (u**h \ (d \ (u \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n, 1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
           else
              ! begin lower
              ! solve a*x = b, where a = l*d*l**h.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n, 1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
              call stdlib_ctrsm( 'L', 'L', 'N', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i = 1
              do while ( i<=n )
                 if( ipiv( i )>0 ) then
                    s = real( cone,KIND=sp) / real( a( i, i ),KIND=sp)
                    call stdlib_csscal( nrhs, s, b( i, 1 ), ldb )
                 else if( i<n ) then
                    akm1k = e( i )
                    akm1 = a( i, i ) / conjg( akm1k )
                    ak = a( i+1, i+1 ) / akm1k
                    denom = akm1*ak - cone
                    do  j = 1, nrhs
                       bkm1 = b( i, j ) / conjg( akm1k )
                       bk = b( i+1, j ) / akm1k
                       b( i, j ) = ( ak*bkm1-bk ) / denom
                       b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i + 1
                 end if
                 i = i + 1
              end do
              ! compute (l**h \ b) -> b   [ l**h \ (d \ (l \p**t * b) ) ]
              call stdlib_ctrsm('L', 'L', 'C', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! p * b  [ p * (l**h \ (d \ (l \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! end lower
           end if
           return
     end subroutine stdlib_chetrs_3

     module pure subroutine stdlib_zhetrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
     !! ZHETRS_3 solves a system of linear equations A * X = B with a complex
     !! Hermitian matrix A using the factorization computed
     !! by ZHETRF_RK or ZHETRF_BK:
     !! A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This algorithm is using Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: a(lda,*), e(*)
           complex(dp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j, k, kp
           real(dp) :: s
           complex(dp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRS_3', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! begin upper
              ! solve a*x = b, where a = u*d*u**h.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
              call stdlib_ztrsm( 'L', 'U', 'N', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i = n
              do while ( i>=1 )
                 if( ipiv( i )>0 ) then
                    s = real( cone,KIND=dp) / real( a( i, i ),KIND=dp)
                    call stdlib_zdscal( nrhs, s, b( i, 1 ), ldb )
                 else if ( i>1 ) then
                    akm1k = e( i )
                    akm1 = a( i-1, i-1 ) / akm1k
                    ak = a( i, i ) / conjg( akm1k )
                    denom = akm1*ak - cone
                    do j = 1, nrhs
                       bkm1 = b( i-1, j ) / akm1k
                       bk = b( i, j ) / conjg( akm1k )
                       b( i-1, j ) = ( ak*bkm1-bk ) / denom
                       b( i, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i - 1
                 end if
                 i = i - 1
              end do
              ! compute (u**h \ b) -> b   [ u**h \ (d \ (u \p**t * b) ) ]
              call stdlib_ztrsm( 'L', 'U', 'C', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! p * b  [ p * (u**h \ (d \ (u \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n, 1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
           else
              ! begin lower
              ! solve a*x = b, where a = l*d*l**h.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n, 1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
              call stdlib_ztrsm( 'L', 'L', 'N', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i = 1
              do while ( i<=n )
                 if( ipiv( i )>0 ) then
                    s = real( cone,KIND=dp) / real( a( i, i ),KIND=dp)
                    call stdlib_zdscal( nrhs, s, b( i, 1 ), ldb )
                 else if( i<n ) then
                    akm1k = e( i )
                    akm1 = a( i, i ) / conjg( akm1k )
                    ak = a( i+1, i+1 ) / akm1k
                    denom = akm1*ak - cone
                    do  j = 1, nrhs
                       bkm1 = b( i, j ) / conjg( akm1k )
                       bk = b( i+1, j ) / akm1k
                       b( i, j ) = ( ak*bkm1-bk ) / denom
                       b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i + 1
                 end if
                 i = i + 1
              end do
              ! compute (l**h \ b) -> b   [ l**h \ (d \ (l \p**t * b) ) ]
              call stdlib_ztrsm('L', 'L', 'C', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! p * b  [ p * (l**h \ (d \ (l \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! end lower
           end if
           return
     end subroutine stdlib_zhetrs_3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hetrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,info )
     !! ZHETRS_3: solves a system of linear equations A * X = B with a complex
     !! Hermitian matrix A using the factorization computed
     !! by ZHETRF_RK or ZHETRF_BK:
     !! A = P*U*D*(U**H)*(P**T) or A = P*L*D*(L**H)*(P**T),
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This algorithm is using Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: a(lda,*), e(*)
           complex(${ck}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j, k, kp
           real(${ck}$) :: s
           complex(${ck}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRS_3', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! begin upper
              ! solve a*x = b, where a = u*d*u**h.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
              call stdlib_${ci}$trsm( 'L', 'U', 'N', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i = n
              do while ( i>=1 )
                 if( ipiv( i )>0 ) then
                    s = real( cone,KIND=${ck}$) / real( a( i, i ),KIND=${ck}$)
                    call stdlib_${ci}$dscal( nrhs, s, b( i, 1 ), ldb )
                 else if ( i>1 ) then
                    akm1k = e( i )
                    akm1 = a( i-1, i-1 ) / akm1k
                    ak = a( i, i ) / conjg( akm1k )
                    denom = akm1*ak - cone
                    do j = 1, nrhs
                       bkm1 = b( i-1, j ) / akm1k
                       bk = b( i, j ) / conjg( akm1k )
                       b( i-1, j ) = ( ak*bkm1-bk ) / denom
                       b( i, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i - 1
                 end if
                 i = i - 1
              end do
              ! compute (u**h \ b) -> b   [ u**h \ (d \ (u \p**t * b) ) ]
              call stdlib_${ci}$trsm( 'L', 'U', 'C', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! p * b  [ p * (u**h \ (d \ (u \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for upper case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n, 1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
           else
              ! begin lower
              ! solve a*x = b, where a = l*d*l**h.
              ! p**t * b
              ! interchange rows k and ipiv(k) of matrix b in the same order
              ! that the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with increment 1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = 1, n, 1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
              call stdlib_${ci}$trsm( 'L', 'L', 'N', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i = 1
              do while ( i<=n )
                 if( ipiv( i )>0 ) then
                    s = real( cone,KIND=${ck}$) / real( a( i, i ),KIND=${ck}$)
                    call stdlib_${ci}$dscal( nrhs, s, b( i, 1 ), ldb )
                 else if( i<n ) then
                    akm1k = e( i )
                    akm1 = a( i, i ) / conjg( akm1k )
                    ak = a( i+1, i+1 ) / akm1k
                    denom = akm1*ak - cone
                    do  j = 1, nrhs
                       bkm1 = b( i, j ) / conjg( akm1k )
                       bk = b( i+1, j ) / akm1k
                       b( i, j ) = ( ak*bkm1-bk ) / denom
                       b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                    end do
                    i = i + 1
                 end if
                 i = i + 1
              end do
              ! compute (l**h \ b) -> b   [ l**h \ (d \ (l \p**t * b) ) ]
              call stdlib_${ci}$trsm('L', 'L', 'C', 'U', n, nrhs, cone, a, lda, b, ldb )
              ! p * b  [ p * (l**h \ (d \ (l \p**t * b) )) ]
              ! interchange rows k and ipiv(k) of matrix b in reverse order
              ! from the formation order of ipiv(i) vector for lower case.
              ! (we can do the simple loop over ipiv with decrement -1,
              ! since the abs value of ipiv(i) represents the row index
              ! of the interchange with row i in both 1x1 and 2x2 pivot cases)
              do k = n, 1, -1
                 kp = abs( ipiv( k ) )
                 if( kp/=k ) then
                    call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end if
              end do
              ! end lower
           end if
           return
     end subroutine stdlib_${ci}$hetrs_3

#:endif
#:endfor



     module pure subroutine stdlib_chetrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
     !! CHETRS2 solves a system of linear equations A*X = B with a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by CHETRF and converted by CSYCONV.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, j, k, kp
           real(sp) :: s
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRS2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           ! convert a
           call stdlib_csyconv( uplo, 'C', n, a, lda, ipiv, work, iinfo )
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**h.
             ! p**t * b
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp==-ipiv( k-1 ) )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb &
                           )
                 k=k-2
              end if
             end do
        ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
             call stdlib_ctrsm('L','U','N','U',n,nrhs,cone,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i=n
              do while ( i >= 1 )
                 if( ipiv(i) > 0 ) then
                   s = real( cone,KIND=sp) / real( a( i, i ),KIND=sp)
                   call stdlib_csscal( nrhs, s, b( i, 1 ), ldb )
                 elseif ( i > 1) then
                    if ( ipiv(i-1) == ipiv(i) ) then
                       akm1k = work(i)
                       akm1 = a( i-1, i-1 ) / akm1k
                       ak = a( i, i ) / conjg( akm1k )
                       denom = akm1*ak - cone
                       do j = 1, nrhs
                          bkm1 = b( i-1, j ) / akm1k
                          bk = b( i, j ) / conjg( akm1k )
                          b( i-1, j ) = ( ak*bkm1-bk ) / denom
                          b( i, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                    i = i - 1
                    endif
                 endif
                 i = i - 1
              end do
            ! compute (u**h \ b) -> b   [ u**h \ (d \ (u \p**t * b) ) ]
              call stdlib_ctrsm('L','U','C','U',n,nrhs,cone,a,lda,b,ldb)
             ! p * b  [ p * (u**h \ (d \ (u \p**t * b) )) ]
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k < n .and. kp==-ipiv( k+1 ) )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp,&
                            1 ), ldb )
                 k=k+2
              endif
             end do
           else
              ! solve a*x = b, where a = l*d*l**h.
             ! p**t * b
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k+1).
                 kp = -ipiv( k+1 )
                 if( kp==-ipiv( k ) )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                           
                 k=k+2
              endif
             end do
        ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
             call stdlib_ctrsm('L','L','N','U',n,nrhs,cone,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i=1
              do while ( i <= n )
                 if( ipiv(i) > 0 ) then
                   s = real( cone,KIND=sp) / real( a( i, i ),KIND=sp)
                   call stdlib_csscal( nrhs, s, b( i, 1 ), ldb )
                 else
                       akm1k = work(i)
                       akm1 = a( i, i ) / conjg( akm1k )
                       ak = a( i+1, i+1 ) / akm1k
                       denom = akm1*ak - cone
                       do j = 1, nrhs
                          bkm1 = b( i, j ) / conjg( akm1k )
                          bk = b( i+1, j ) / akm1k
                          b( i, j ) = ( ak*bkm1-bk ) / denom
                          b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                       i = i + 1
                 endif
                 i = i + 1
              end do
        ! compute (l**h \ b) -> b   [ l**h \ (d \ (l \p**t * b) ) ]
             call stdlib_ctrsm('L','L','C','U',n,nrhs,cone,a,lda,b,ldb)
             ! p * b  [ p * (l**h \ (d \ (l \p**t * b) )) ]
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k>1 .and. kp==-ipiv( k-1 ) )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, &
                           1 ), ldb )
                 k=k-2
              endif
             end do
           end if
           ! revert a
           call stdlib_csyconv( uplo, 'R', n, a, lda, ipiv, work, iinfo )
           return
     end subroutine stdlib_chetrs2

     module pure subroutine stdlib_zhetrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
     !! ZHETRS2 solves a system of linear equations A*X = B with a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by ZHETRF and converted by ZSYCONV.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, j, k, kp
           real(dp) :: s
           complex(dp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRS2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           ! convert a
           call stdlib_zsyconv( uplo, 'C', n, a, lda, ipiv, work, iinfo )
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**h.
             ! p**t * b
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp==-ipiv( k-1 ) )call stdlib_zswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb &
                           )
                 k=k-2
              end if
             end do
        ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
             call stdlib_ztrsm('L','U','N','U',n,nrhs,cone,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i=n
              do while ( i >= 1 )
                 if( ipiv(i) > 0 ) then
                   s = real( cone,KIND=dp) / real( a( i, i ),KIND=dp)
                   call stdlib_zdscal( nrhs, s, b( i, 1 ), ldb )
                 elseif ( i > 1) then
                    if ( ipiv(i-1) == ipiv(i) ) then
                       akm1k = work(i)
                       akm1 = a( i-1, i-1 ) / akm1k
                       ak = a( i, i ) / conjg( akm1k )
                       denom = akm1*ak - cone
                       do j = 1, nrhs
                          bkm1 = b( i-1, j ) / akm1k
                          bk = b( i, j ) / conjg( akm1k )
                          b( i-1, j ) = ( ak*bkm1-bk ) / denom
                          b( i, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                    i = i - 1
                    endif
                 endif
                 i = i - 1
              end do
            ! compute (u**h \ b) -> b   [ u**h \ (d \ (u \p**t * b) ) ]
              call stdlib_ztrsm('L','U','C','U',n,nrhs,cone,a,lda,b,ldb)
             ! p * b  [ p * (u**h \ (d \ (u \p**t * b) )) ]
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k < n .and. kp==-ipiv( k+1 ) )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp,&
                            1 ), ldb )
                 k=k+2
              endif
             end do
           else
              ! solve a*x = b, where a = l*d*l**h.
             ! p**t * b
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k+1).
                 kp = -ipiv( k+1 )
                 if( kp==-ipiv( k ) )call stdlib_zswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                           
                 k=k+2
              endif
             end do
        ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
             call stdlib_ztrsm('L','L','N','U',n,nrhs,cone,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i=1
              do while ( i <= n )
                 if( ipiv(i) > 0 ) then
                   s = real( cone,KIND=dp) / real( a( i, i ),KIND=dp)
                   call stdlib_zdscal( nrhs, s, b( i, 1 ), ldb )
                 else
                       akm1k = work(i)
                       akm1 = a( i, i ) / conjg( akm1k )
                       ak = a( i+1, i+1 ) / akm1k
                       denom = akm1*ak - cone
                       do j = 1, nrhs
                          bkm1 = b( i, j ) / conjg( akm1k )
                          bk = b( i+1, j ) / akm1k
                          b( i, j ) = ( ak*bkm1-bk ) / denom
                          b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                       i = i + 1
                 endif
                 i = i + 1
              end do
        ! compute (l**h \ b) -> b   [ l**h \ (d \ (l \p**t * b) ) ]
             call stdlib_ztrsm('L','L','C','U',n,nrhs,cone,a,lda,b,ldb)
             ! p * b  [ p * (l**h \ (d \ (l \p**t * b) )) ]
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k>1 .and. kp==-ipiv( k-1 ) )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, &
                           1 ), ldb )
                 k=k-2
              endif
             end do
           end if
           ! revert a
           call stdlib_zsyconv( uplo, 'R', n, a, lda, ipiv, work, iinfo )
           return
     end subroutine stdlib_zhetrs2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hetrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
     !! ZHETRS2: solves a system of linear equations A*X = B with a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by ZHETRF and converted by ZSYCONV.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, j, k, kp
           real(${ck}$) :: s
           complex(${ck}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRS2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           ! convert a
           call stdlib_${ci}$syconv( uplo, 'C', n, a, lda, ipiv, work, iinfo )
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**h.
             ! p**t * b
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp==-ipiv( k-1 ) )call stdlib_${ci}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb &
                           )
                 k=k-2
              end if
             end do
        ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
             call stdlib_${ci}$trsm('L','U','N','U',n,nrhs,cone,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i=n
              do while ( i >= 1 )
                 if( ipiv(i) > 0 ) then
                   s = real( cone,KIND=${ck}$) / real( a( i, i ),KIND=${ck}$)
                   call stdlib_${ci}$dscal( nrhs, s, b( i, 1 ), ldb )
                 elseif ( i > 1) then
                    if ( ipiv(i-1) == ipiv(i) ) then
                       akm1k = work(i)
                       akm1 = a( i-1, i-1 ) / akm1k
                       ak = a( i, i ) / conjg( akm1k )
                       denom = akm1*ak - cone
                       do j = 1, nrhs
                          bkm1 = b( i-1, j ) / akm1k
                          bk = b( i, j ) / conjg( akm1k )
                          b( i-1, j ) = ( ak*bkm1-bk ) / denom
                          b( i, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                    i = i - 1
                    endif
                 endif
                 i = i - 1
              end do
            ! compute (u**h \ b) -> b   [ u**h \ (d \ (u \p**t * b) ) ]
              call stdlib_${ci}$trsm('L','U','C','U',n,nrhs,cone,a,lda,b,ldb)
             ! p * b  [ p * (u**h \ (d \ (u \p**t * b) )) ]
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k < n .and. kp==-ipiv( k+1 ) )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp,&
                            1 ), ldb )
                 k=k+2
              endif
             end do
           else
              ! solve a*x = b, where a = l*d*l**h.
             ! p**t * b
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k+1).
                 kp = -ipiv( k+1 )
                 if( kp==-ipiv( k ) )call stdlib_${ci}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                           
                 k=k+2
              endif
             end do
        ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
             call stdlib_${ci}$trsm('L','L','N','U',n,nrhs,cone,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i=1
              do while ( i <= n )
                 if( ipiv(i) > 0 ) then
                   s = real( cone,KIND=${ck}$) / real( a( i, i ),KIND=${ck}$)
                   call stdlib_${ci}$dscal( nrhs, s, b( i, 1 ), ldb )
                 else
                       akm1k = work(i)
                       akm1 = a( i, i ) / conjg( akm1k )
                       ak = a( i+1, i+1 ) / akm1k
                       denom = akm1*ak - cone
                       do j = 1, nrhs
                          bkm1 = b( i, j ) / conjg( akm1k )
                          bk = b( i+1, j ) / akm1k
                          b( i, j ) = ( ak*bkm1-bk ) / denom
                          b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                       i = i + 1
                 endif
                 i = i + 1
              end do
        ! compute (l**h \ b) -> b   [ l**h \ (d \ (l \p**t * b) ) ]
             call stdlib_${ci}$trsm('L','L','C','U',n,nrhs,cone,a,lda,b,ldb)
             ! p * b  [ p * (l**h \ (d \ (l \p**t * b) )) ]
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k>1 .and. kp==-ipiv( k-1 ) )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, &
                           1 ), ldb )
                 k=k-2
              endif
             end do
           end if
           ! revert a
           call stdlib_${ci}$syconv( uplo, 'R', n, a, lda, ipiv, work, iinfo )
           return
     end subroutine stdlib_${ci}$hetrs2

#:endif
#:endfor



     module pure subroutine stdlib_chetri( uplo, n, a, lda, ipiv, work, info )
     !! CHETRI computes the inverse of a complex Hermitian indefinite matrix
     !! A using the factorization A = U*D*U**H or A = L*D*L**H computed by
     !! CHETRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp, kstep
           real(sp) :: ak, akp1, d, t
           complex(sp) :: akkp1, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / real( a( k, k ),KIND=sp)
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_chemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - real( stdlib_cdotc( k-1, work, 1, a( 1,k ), 1 ),&
                              KIND=sp)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k+1 ) )
                 ak = real( a( k, k ),KIND=sp) / t
                 akp1 = real( a( k+1, k+1 ),KIND=sp) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-one )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_ccopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_chemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - real( stdlib_cdotc( k-1, work, 1, a( 1,k ), 1 ),&
                              KIND=sp)
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_cdotc( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_ccopy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_chemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -real( stdlib_cdotc( k-1, work, 1, a( 1, k+1 ),&
                              1 ),KIND=sp)
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 call stdlib_cswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                 do j = kp + 1, k - 1
                    temp = conjg( a( j, k ) )
                    a( j, k ) = conjg( a( kp, j ) )
                    a( kp, j ) = temp
                 end do
                 a( kp, k ) = conjg( a( kp, k ) )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
              end if
              k = k + kstep
              go to 30
              50 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              60 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / real( a( k, k ),KIND=sp)
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_chemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - real( stdlib_cdotc( n-k, work, 1,a( k+1, k ), 1 ),&
                              KIND=sp)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k-1 ) )
                 ak = real( a( k-1, k-1 ),KIND=sp) / t
                 akp1 = real( a( k, k ),KIND=sp) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-one )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_ccopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_chemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - real( stdlib_cdotc( n-k, work, 1,a( k+1, k ), 1 ),&
                              KIND=sp)
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_cdotc( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 &
                              )
                    call stdlib_ccopy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_chemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -real( stdlib_cdotc( n-k, work, 1, a( k+1, k-1 )&
                              ,1 ),KIND=sp)
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 if( kp<n )call stdlib_cswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                 do j = k + 1, kp - 1
                    temp = conjg( a( j, k ) )
                    a( j, k ) = conjg( a( kp, j ) )
                    a( kp, j ) = temp
                 end do
                 a( kp, k ) = conjg( a( kp, k ) )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
              end if
              k = k - kstep
              go to 60
              80 continue
           end if
           return
     end subroutine stdlib_chetri

     module pure subroutine stdlib_zhetri( uplo, n, a, lda, ipiv, work, info )
     !! ZHETRI computes the inverse of a complex Hermitian indefinite matrix
     !! A using the factorization A = U*D*U**H or A = L*D*L**H computed by
     !! ZHETRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp, kstep
           real(dp) :: ak, akp1, d, t
           complex(dp) :: akkp1, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / real( a( k, k ),KIND=dp)
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_zcopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_zhemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - real( stdlib_zdotc( k-1, work, 1, a( 1,k ), 1 ),&
                              KIND=dp)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k+1 ) )
                 ak = real( a( k, k ),KIND=dp) / t
                 akp1 = real( a( k+1, k+1 ),KIND=dp) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-one )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_zcopy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_zhemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - real( stdlib_zdotc( k-1, work, 1, a( 1,k ), 1 ),&
                              KIND=dp)
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_zdotc( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_zcopy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_zhemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -real( stdlib_zdotc( k-1, work, 1, a( 1, k+1 ),&
                              1 ),KIND=dp)
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 call stdlib_zswap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                 do j = kp + 1, k - 1
                    temp = conjg( a( j, k ) )
                    a( j, k ) = conjg( a( kp, j ) )
                    a( kp, j ) = temp
                 end do
                 a( kp, k ) = conjg( a( kp, k ) )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
              end if
              k = k + kstep
              go to 30
              50 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              60 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / real( a( k, k ),KIND=dp)
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_zcopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_zhemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - real( stdlib_zdotc( n-k, work, 1,a( k+1, k ), 1 ),&
                              KIND=dp)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k-1 ) )
                 ak = real( a( k-1, k-1 ),KIND=dp) / t
                 akp1 = real( a( k, k ),KIND=dp) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-one )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_zcopy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_zhemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - real( stdlib_zdotc( n-k, work, 1,a( k+1, k ), 1 ),&
                              KIND=dp)
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_zdotc( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 &
                              )
                    call stdlib_zcopy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_zhemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -real( stdlib_zdotc( n-k, work, 1, a( k+1, k-1 )&
                              ,1 ),KIND=dp)
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 if( kp<n )call stdlib_zswap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                 do j = k + 1, kp - 1
                    temp = conjg( a( j, k ) )
                    a( j, k ) = conjg( a( kp, j ) )
                    a( kp, j ) = temp
                 end do
                 a( kp, k ) = conjg( a( kp, k ) )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
              end if
              k = k - kstep
              go to 60
              80 continue
           end if
           return
     end subroutine stdlib_zhetri

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hetri( uplo, n, a, lda, ipiv, work, info )
     !! ZHETRI: computes the inverse of a complex Hermitian indefinite matrix
     !! A using the factorization A = U*D*U**H or A = L*D*L**H computed by
     !! ZHETRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp, kstep
           real(${ck}$) :: ak, akp1, d, t
           complex(${ck}$) :: akkp1, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRI', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              do info = n, 1, -1
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              do info = 1, n
                 if( ipiv( info )>0 .and. a( info, info )==czero )return
              end do
           end if
           info = 0
           if( upper ) then
              ! compute inv(a) from the factorization a = u*d*u**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              30 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / real( a( k, k ),KIND=${ck}$)
                 ! compute column k of the inverse.
                 if( k>1 ) then
                    call stdlib_${ci}$copy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_${ci}$hemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - real( stdlib_${ci}$dotc( k-1, work, 1, a( 1,k ), 1 ),&
                              KIND=${ck}$)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k+1 ) )
                 ak = real( a( k, k ),KIND=${ck}$) / t
                 akp1 = real( a( k+1, k+1 ),KIND=${ck}$) / t
                 akkp1 = a( k, k+1 ) / t
                 d = t*( ak*akp1-one )
                 a( k, k ) = akp1 / d
                 a( k+1, k+1 ) = ak / d
                 a( k, k+1 ) = -akkp1 / d
                 ! compute columns k and k+1 of the inverse.
                 if( k>1 ) then
                    call stdlib_${ci}$copy( k-1, a( 1, k ), 1, work, 1 )
                    call stdlib_${ci}$hemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k ), 1 )
                              
                    a( k, k ) = a( k, k ) - real( stdlib_${ci}$dotc( k-1, work, 1, a( 1,k ), 1 ),&
                              KIND=${ck}$)
                    a( k, k+1 ) = a( k, k+1 ) -stdlib_${ci}$dotc( k-1, a( 1, k ), 1, a( 1, k+1 ), 1 )
                              
                    call stdlib_${ci}$copy( k-1, a( 1, k+1 ), 1, work, 1 )
                    call stdlib_${ci}$hemv( uplo, k-1, -cone, a, lda, work, 1, czero,a( 1, k+1 ), 1 )
                              
                    a( k+1, k+1 ) = a( k+1, k+1 ) -real( stdlib_${ci}$dotc( k-1, work, 1, a( 1, k+1 ),&
                              1 ),KIND=${ck}$)
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the leading
                 ! submatrix a(1:k+1,1:k+1)
                 call stdlib_${ci}$swap( kp-1, a( 1, k ), 1, a( 1, kp ), 1 )
                 do j = kp + 1, k - 1
                    temp = conjg( a( j, k ) )
                    a( j, k ) = conjg( a( kp, j ) )
                    a( kp, j ) = temp
                 end do
                 a( kp, k ) = conjg( a( kp, k ) )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k+1 )
                    a( k, k+1 ) = a( kp, k+1 )
                    a( kp, k+1 ) = temp
                 end if
              end if
              k = k + kstep
              go to 30
              50 continue
           else
              ! compute inv(a) from the factorization a = l*d*l**h.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              60 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! invert the diagonal block.
                 a( k, k ) = one / real( a( k, k ),KIND=${ck}$)
                 ! compute column k of the inverse.
                 if( k<n ) then
                    call stdlib_${ci}$copy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_${ci}$hemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - real( stdlib_${ci}$dotc( n-k, work, 1,a( k+1, k ), 1 ),&
                              KIND=${ck}$)
                 end if
                 kstep = 1
              else
                 ! 2 x 2 diagonal block
                 ! invert the diagonal block.
                 t = abs( a( k, k-1 ) )
                 ak = real( a( k-1, k-1 ),KIND=${ck}$) / t
                 akp1 = real( a( k, k ),KIND=${ck}$) / t
                 akkp1 = a( k, k-1 ) / t
                 d = t*( ak*akp1-one )
                 a( k-1, k-1 ) = akp1 / d
                 a( k, k ) = ak / d
                 a( k, k-1 ) = -akkp1 / d
                 ! compute columns k-1 and k of the inverse.
                 if( k<n ) then
                    call stdlib_${ci}$copy( n-k, a( k+1, k ), 1, work, 1 )
                    call stdlib_${ci}$hemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k ), 1 )
                    a( k, k ) = a( k, k ) - real( stdlib_${ci}$dotc( n-k, work, 1,a( k+1, k ), 1 ),&
                              KIND=${ck}$)
                    a( k, k-1 ) = a( k, k-1 ) -stdlib_${ci}$dotc( n-k, a( k+1, k ), 1, a( k+1, k-1 ),1 &
                              )
                    call stdlib_${ci}$copy( n-k, a( k+1, k-1 ), 1, work, 1 )
                    call stdlib_${ci}$hemv( uplo, n-k, -cone, a( k+1, k+1 ), lda, work,1, czero, a( k+&
                              1, k-1 ), 1 )
                    a( k-1, k-1 ) = a( k-1, k-1 ) -real( stdlib_${ci}$dotc( n-k, work, 1, a( k+1, k-1 )&
                              ,1 ),KIND=${ck}$)
                 end if
                 kstep = 2
              end if
              kp = abs( ipiv( k ) )
              if( kp/=k ) then
                 ! interchange rows and columns k and kp in the trailing
                 ! submatrix a(k-1:n,k-1:n)
                 if( kp<n )call stdlib_${ci}$swap( n-kp, a( kp+1, k ), 1, a( kp+1, kp ), 1 )
                 do j = k + 1, kp - 1
                    temp = conjg( a( j, k ) )
                    a( j, k ) = conjg( a( kp, j ) )
                    a( kp, j ) = temp
                 end do
                 a( kp, k ) = conjg( a( kp, k ) )
                 temp = a( k, k )
                 a( k, k ) = a( kp, kp )
                 a( kp, kp ) = temp
                 if( kstep==2 ) then
                    temp = a( k, k-1 )
                    a( k, k-1 ) = a( kp, k-1 )
                    a( kp, k-1 ) = temp
                 end if
              end if
              k = k - kstep
              go to 60
              80 continue
           end if
           return
     end subroutine stdlib_${ci}$hetri

#:endif
#:endfor



     module pure subroutine stdlib_ssyconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
     !! If parameter WAY = 'C':
     !! SSYCONVF_ROOK converts the factorization output format used in
     !! SSYTRF_ROOK provided on entry in parameter A into the factorization
     !! output format used in SSYTRF_RK (or SSYTRF_BK) that is stored
     !! on exit in parameters A and E. IPIV format for SSYTRF_ROOK and
     !! SSYTRF_RK (or SSYTRF_BK) is the same and is not converted.
     !! If parameter WAY = 'R':
     !! SSYCONVF_ROOK performs the conversion in reverse direction, i.e.
     !! converts the factorization output format used in SSYTRF_RK
     !! (or SSYTRF_BK) provided on entry in parameters A and E into
     !! the factorization output format used in SSYTRF_ROOK that is stored
     !! on exit in parameter A. IPIV format for SSYTRF_ROOK and
     !! SSYTRF_RK (or SSYTRF_BK) is the same and is not converted.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*), e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip, ip2
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYCONVF_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! begin a is upper
              if ( convert ) then
                 ! convert a (a is upper)
                 ! convert value
                 ! assign superdiagonal entries of d to array e and zero out
                 ! corresponding entries in input storage a
                 i = n
                 e( 1 ) = zero
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       e( i ) = a( i-1, i )
                       e( i-1 ) = zero
                       a( i-1, i ) = zero
                       i = i - 1
                    else
                       e( i ) = zero
                    end if
                    i = i - 1
                 end do
                 ! convert permutations
                 ! apply permutations to submatrices of upper part of a
                 ! in factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_sswap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i and ipiv(i) and i-1 and ipiv(i-1)
                       ! in a(1:i,n-i:n)
                       ip = -ipiv( i )
                       ip2 = -ipiv( i-1 )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_sswap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                          if( ip2/=(i-1) ) then
                             call stdlib_sswap( n-i, a( i-1, i+1 ), lda,a( ip2, i+1 ), lda )
                                       
                          end if
                       end if
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              else
                 ! revert a (a is upper)
                 ! revert permutations
                 ! apply permutations to submatrices of upper part of a
                 ! in reverse factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_sswap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i-1) and i and ipiv(i)
                       ! in a(1:i,n-i:n)
                       i = i + 1
                       ip = -ipiv( i )
                       ip2 = -ipiv( i-1 )
                       if( i<n ) then
                          if( ip2/=(i-1) ) then
                             call stdlib_sswap( n-i, a( ip2, i+1 ), lda,a( i-1, i+1 ), lda )
                                       
                          end if
                          if( ip/=i ) then
                             call stdlib_sswap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    end if
                    i = i + 1
                 end do
                 ! revert value
                 ! assign superdiagonal entries of d from array e to
                 ! superdiagonal entries of a.
                 i = n
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       a( i-1, i ) = e( i )
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              ! end a is upper
              end if
           else
              ! begin a is lower
              if ( convert ) then
                 ! convert a (a is lower)
                 ! convert value
                 ! assign subdiagonal entries of d to array e and zero out
                 ! corresponding entries in input storage a
                 i = 1
                 e( n ) = zero
                 do while ( i<=n )
                    if( i<n .and. ipiv(i)<0 ) then
                       e( i ) = a( i+1, i )
                       e( i+1 ) = zero
                       a( i+1, i ) = zero
                       i = i + 1
                    else
                       e( i ) = zero
                    end if
                    i = i + 1
                 end do
                 ! convert permutations
                 ! apply permutations to submatrices of lower part of a
                 ! in factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_sswap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i and ipiv(i) and i+1 and ipiv(i+1)
                       ! in a(i:n,1:i-1)
                       ip = -ipiv( i )
                       ip2 = -ipiv( i+1 )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_sswap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                          if( ip2/=(i+1) ) then
                             call stdlib_sswap( i-1, a( i+1, 1 ), lda,a( ip2, 1 ), lda )
                          end if
                       end if
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              else
                 ! revert a (a is lower)
                 ! revert permutations
                 ! apply permutations to submatrices of lower part of a
                 ! in reverse factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_sswap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i+1) and i and ipiv(i)
                       ! in a(i:n,1:i-1)
                       i = i - 1
                       ip = -ipiv( i )
                       ip2 = -ipiv( i+1 )
                       if ( i>1 ) then
                          if( ip2/=(i+1) ) then
                             call stdlib_sswap( i-1, a( ip2, 1 ), lda,a( i+1, 1 ), lda )
                          end if
                          if( ip/=i ) then
                             call stdlib_sswap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    end if
                    i = i - 1
                 end do
                 ! revert value
                 ! assign subdiagonal entries of d from array e to
                 ! subgiagonal entries of a.
                 i = 1
                 do while ( i<=n-1 )
                    if( ipiv( i )<0 ) then
                       a( i + 1, i ) = e( i )
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              end if
              ! end a is lower
           end if
           return
     end subroutine stdlib_ssyconvf_rook

     module pure subroutine stdlib_dsyconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
     !! If parameter WAY = 'C':
     !! DSYCONVF_ROOK converts the factorization output format used in
     !! DSYTRF_ROOK provided on entry in parameter A into the factorization
     !! output format used in DSYTRF_RK (or DSYTRF_BK) that is stored
     !! on exit in parameters A and E. IPIV format for DSYTRF_ROOK and
     !! DSYTRF_RK (or DSYTRF_BK) is the same and is not converted.
     !! If parameter WAY = 'R':
     !! DSYCONVF_ROOK performs the conversion in reverse direction, i.e.
     !! converts the factorization output format used in DSYTRF_RK
     !! (or DSYTRF_BK) provided on entry in parameters A and E into
     !! the factorization output format used in DSYTRF_ROOK that is stored
     !! on exit in parameter A. IPIV format for DSYTRF_ROOK and
     !! DSYTRF_RK (or DSYTRF_BK) is the same and is not converted.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*), e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip, ip2
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYCONVF_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! begin a is upper
              if ( convert ) then
                 ! convert a (a is upper)
                 ! convert value
                 ! assign superdiagonal entries of d to array e and zero out
                 ! corresponding entries in input storage a
                 i = n
                 e( 1 ) = zero
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       e( i ) = a( i-1, i )
                       e( i-1 ) = zero
                       a( i-1, i ) = zero
                       i = i - 1
                    else
                       e( i ) = zero
                    end if
                    i = i - 1
                 end do
                 ! convert permutations
                 ! apply permutations to submatrices of upper part of a
                 ! in factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_dswap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i and ipiv(i) and i-1 and ipiv(i-1)
                       ! in a(1:i,n-i:n)
                       ip = -ipiv( i )
                       ip2 = -ipiv( i-1 )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_dswap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                          if( ip2/=(i-1) ) then
                             call stdlib_dswap( n-i, a( i-1, i+1 ), lda,a( ip2, i+1 ), lda )
                                       
                          end if
                       end if
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              else
                 ! revert a (a is upper)
                 ! revert permutations
                 ! apply permutations to submatrices of upper part of a
                 ! in reverse factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_dswap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i-1) and i and ipiv(i)
                       ! in a(1:i,n-i:n)
                       i = i + 1
                       ip = -ipiv( i )
                       ip2 = -ipiv( i-1 )
                       if( i<n ) then
                          if( ip2/=(i-1) ) then
                             call stdlib_dswap( n-i, a( ip2, i+1 ), lda,a( i-1, i+1 ), lda )
                                       
                          end if
                          if( ip/=i ) then
                             call stdlib_dswap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    end if
                    i = i + 1
                 end do
                 ! revert value
                 ! assign superdiagonal entries of d from array e to
                 ! superdiagonal entries of a.
                 i = n
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       a( i-1, i ) = e( i )
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              ! end a is upper
              end if
           else
              ! begin a is lower
              if ( convert ) then
                 ! convert a (a is lower)
                 ! convert value
                 ! assign subdiagonal entries of d to array e and zero out
                 ! corresponding entries in input storage a
                 i = 1
                 e( n ) = zero
                 do while ( i<=n )
                    if( i<n .and. ipiv(i)<0 ) then
                       e( i ) = a( i+1, i )
                       e( i+1 ) = zero
                       a( i+1, i ) = zero
                       i = i + 1
                    else
                       e( i ) = zero
                    end if
                    i = i + 1
                 end do
                 ! convert permutations
                 ! apply permutations to submatrices of lower part of a
                 ! in factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_dswap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i and ipiv(i) and i+1 and ipiv(i+1)
                       ! in a(i:n,1:i-1)
                       ip = -ipiv( i )
                       ip2 = -ipiv( i+1 )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_dswap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                          if( ip2/=(i+1) ) then
                             call stdlib_dswap( i-1, a( i+1, 1 ), lda,a( ip2, 1 ), lda )
                          end if
                       end if
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              else
                 ! revert a (a is lower)
                 ! revert permutations
                 ! apply permutations to submatrices of lower part of a
                 ! in reverse factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_dswap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i+1) and i and ipiv(i)
                       ! in a(i:n,1:i-1)
                       i = i - 1
                       ip = -ipiv( i )
                       ip2 = -ipiv( i+1 )
                       if ( i>1 ) then
                          if( ip2/=(i+1) ) then
                             call stdlib_dswap( i-1, a( ip2, 1 ), lda,a( i+1, 1 ), lda )
                          end if
                          if( ip/=i ) then
                             call stdlib_dswap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    end if
                    i = i - 1
                 end do
                 ! revert value
                 ! assign subdiagonal entries of d from array e to
                 ! subgiagonal entries of a.
                 i = 1
                 do while ( i<=n-1 )
                    if( ipiv( i )<0 ) then
                       a( i + 1, i ) = e( i )
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              end if
              ! end a is lower
           end if
           return
     end subroutine stdlib_dsyconvf_rook

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$syconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
     !! If parameter WAY = 'C':
     !! DSYCONVF_ROOK: converts the factorization output format used in
     !! DSYTRF_ROOK provided on entry in parameter A into the factorization
     !! output format used in DSYTRF_RK (or DSYTRF_BK) that is stored
     !! on exit in parameters A and E. IPIV format for DSYTRF_ROOK and
     !! DSYTRF_RK (or DSYTRF_BK) is the same and is not converted.
     !! If parameter WAY = 'R':
     !! DSYCONVF_ROOK performs the conversion in reverse direction, i.e.
     !! converts the factorization output format used in DSYTRF_RK
     !! (or DSYTRF_BK) provided on entry in parameters A and E into
     !! the factorization output format used in DSYTRF_ROOK that is stored
     !! on exit in parameter A. IPIV format for DSYTRF_ROOK and
     !! DSYTRF_RK (or DSYTRF_BK) is the same and is not converted.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip, ip2
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYCONVF_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! begin a is upper
              if ( convert ) then
                 ! convert a (a is upper)
                 ! convert value
                 ! assign superdiagonal entries of d to array e and zero out
                 ! corresponding entries in input storage a
                 i = n
                 e( 1 ) = zero
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       e( i ) = a( i-1, i )
                       e( i-1 ) = zero
                       a( i-1, i ) = zero
                       i = i - 1
                    else
                       e( i ) = zero
                    end if
                    i = i - 1
                 end do
                 ! convert permutations
                 ! apply permutations to submatrices of upper part of a
                 ! in factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i and ipiv(i) and i-1 and ipiv(i-1)
                       ! in a(1:i,n-i:n)
                       ip = -ipiv( i )
                       ip2 = -ipiv( i-1 )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                          if( ip2/=(i-1) ) then
                             call stdlib_${ri}$swap( n-i, a( i-1, i+1 ), lda,a( ip2, i+1 ), lda )
                                       
                          end if
                       end if
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              else
                 ! revert a (a is upper)
                 ! revert permutations
                 ! apply permutations to submatrices of upper part of a
                 ! in reverse factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i-1) and i and ipiv(i)
                       ! in a(1:i,n-i:n)
                       i = i + 1
                       ip = -ipiv( i )
                       ip2 = -ipiv( i-1 )
                       if( i<n ) then
                          if( ip2/=(i-1) ) then
                             call stdlib_${ri}$swap( n-i, a( ip2, i+1 ), lda,a( i-1, i+1 ), lda )
                                       
                          end if
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    end if
                    i = i + 1
                 end do
                 ! revert value
                 ! assign superdiagonal entries of d from array e to
                 ! superdiagonal entries of a.
                 i = n
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       a( i-1, i ) = e( i )
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              ! end a is upper
              end if
           else
              ! begin a is lower
              if ( convert ) then
                 ! convert a (a is lower)
                 ! convert value
                 ! assign subdiagonal entries of d to array e and zero out
                 ! corresponding entries in input storage a
                 i = 1
                 e( n ) = zero
                 do while ( i<=n )
                    if( i<n .and. ipiv(i)<0 ) then
                       e( i ) = a( i+1, i )
                       e( i+1 ) = zero
                       a( i+1, i ) = zero
                       i = i + 1
                    else
                       e( i ) = zero
                    end if
                    i = i + 1
                 end do
                 ! convert permutations
                 ! apply permutations to submatrices of lower part of a
                 ! in factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i and ipiv(i) and i+1 and ipiv(i+1)
                       ! in a(i:n,1:i-1)
                       ip = -ipiv( i )
                       ip2 = -ipiv( i+1 )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                          if( ip2/=(i+1) ) then
                             call stdlib_${ri}$swap( i-1, a( i+1, 1 ), lda,a( ip2, 1 ), lda )
                          end if
                       end if
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              else
                 ! revert a (a is lower)
                 ! revert permutations
                 ! apply permutations to submatrices of lower part of a
                 ! in reverse factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i+1) and i and ipiv(i)
                       ! in a(i:n,1:i-1)
                       i = i - 1
                       ip = -ipiv( i )
                       ip2 = -ipiv( i+1 )
                       if ( i>1 ) then
                          if( ip2/=(i+1) ) then
                             call stdlib_${ri}$swap( i-1, a( ip2, 1 ), lda,a( i+1, 1 ), lda )
                          end if
                          if( ip/=i ) then
                             call stdlib_${ri}$swap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    end if
                    i = i - 1
                 end do
                 ! revert value
                 ! assign subdiagonal entries of d from array e to
                 ! subgiagonal entries of a.
                 i = 1
                 do while ( i<=n-1 )
                    if( ipiv( i )<0 ) then
                       a( i + 1, i ) = e( i )
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              end if
              ! end a is lower
           end if
           return
     end subroutine stdlib_${ri}$syconvf_rook

#:endif
#:endfor

     module pure subroutine stdlib_csyconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
     !! If parameter WAY = 'C':
     !! CSYCONVF_ROOK converts the factorization output format used in
     !! CSYTRF_ROOK provided on entry in parameter A into the factorization
     !! output format used in CSYTRF_RK (or CSYTRF_BK) that is stored
     !! on exit in parameters A and E. IPIV format for CSYTRF_ROOK and
     !! CSYTRF_RK (or CSYTRF_BK) is the same and is not converted.
     !! If parameter WAY = 'R':
     !! CSYCONVF_ROOK performs the conversion in reverse direction, i.e.
     !! converts the factorization output format used in CSYTRF_RK
     !! (or CSYTRF_BK) provided on entry in parameters A and E into
     !! the factorization output format used in CSYTRF_ROOK that is stored
     !! on exit in parameter A. IPIV format for CSYTRF_ROOK and
     !! CSYTRF_RK (or CSYTRF_BK) is the same and is not converted.
     !! CSYCONVF_ROOK can also convert in Hermitian matrix case, i.e. between
     !! formats used in CHETRF_ROOK and CHETRF_RK (or CHETRF_BK).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip, ip2
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYCONVF_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! begin a is upper
              if ( convert ) then
                 ! convert a (a is upper)
                 ! convert value
                 ! assign superdiagonal entries of d to array e and czero out
                 ! corresponding entries in input storage a
                 i = n
                 e( 1 ) = czero
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       e( i ) = a( i-1, i )
                       e( i-1 ) = czero
                       a( i-1, i ) = czero
                       i = i - 1
                    else
                       e( i ) = czero
                    end if
                    i = i - 1
                 end do
                 ! convert permutations
                 ! apply permutations to submatrices of upper part of a
                 ! in factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_cswap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i and ipiv(i) and i-1 and ipiv(i-1)
                       ! in a(1:i,n-i:n)
                       ip = -ipiv( i )
                       ip2 = -ipiv( i-1 )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_cswap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                          if( ip2/=(i-1) ) then
                             call stdlib_cswap( n-i, a( i-1, i+1 ), lda,a( ip2, i+1 ), lda )
                                       
                          end if
                       end if
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              else
                 ! revert a (a is upper)
                 ! revert permutations
                 ! apply permutations to submatrices of upper part of a
                 ! in reverse factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_cswap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i-1) and i and ipiv(i)
                       ! in a(1:i,n-i:n)
                       i = i + 1
                       ip = -ipiv( i )
                       ip2 = -ipiv( i-1 )
                       if( i<n ) then
                          if( ip2/=(i-1) ) then
                             call stdlib_cswap( n-i, a( ip2, i+1 ), lda,a( i-1, i+1 ), lda )
                                       
                          end if
                          if( ip/=i ) then
                             call stdlib_cswap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    end if
                    i = i + 1
                 end do
                 ! revert value
                 ! assign superdiagonal entries of d from array e to
                 ! superdiagonal entries of a.
                 i = n
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       a( i-1, i ) = e( i )
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              ! end a is upper
              end if
           else
              ! begin a is lower
              if ( convert ) then
                 ! convert a (a is lower)
                 ! convert value
                 ! assign subdiagonal entries of d to array e and czero out
                 ! corresponding entries in input storage a
                 i = 1
                 e( n ) = czero
                 do while ( i<=n )
                    if( i<n .and. ipiv(i)<0 ) then
                       e( i ) = a( i+1, i )
                       e( i+1 ) = czero
                       a( i+1, i ) = czero
                       i = i + 1
                    else
                       e( i ) = czero
                    end if
                    i = i + 1
                 end do
                 ! convert permutations
                 ! apply permutations to submatrices of lower part of a
                 ! in factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_cswap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i and ipiv(i) and i+1 and ipiv(i+1)
                       ! in a(i:n,1:i-1)
                       ip = -ipiv( i )
                       ip2 = -ipiv( i+1 )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_cswap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                          if( ip2/=(i+1) ) then
                             call stdlib_cswap( i-1, a( i+1, 1 ), lda,a( ip2, 1 ), lda )
                          end if
                       end if
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              else
                 ! revert a (a is lower)
                 ! revert permutations
                 ! apply permutations to submatrices of lower part of a
                 ! in reverse factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_cswap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i+1) and i and ipiv(i)
                       ! in a(i:n,1:i-1)
                       i = i - 1
                       ip = -ipiv( i )
                       ip2 = -ipiv( i+1 )
                       if ( i>1 ) then
                          if( ip2/=(i+1) ) then
                             call stdlib_cswap( i-1, a( ip2, 1 ), lda,a( i+1, 1 ), lda )
                          end if
                          if( ip/=i ) then
                             call stdlib_cswap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    end if
                    i = i - 1
                 end do
                 ! revert value
                 ! assign subdiagonal entries of d from array e to
                 ! subgiagonal entries of a.
                 i = 1
                 do while ( i<=n-1 )
                    if( ipiv( i )<0 ) then
                       a( i + 1, i ) = e( i )
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              end if
              ! end a is lower
           end if
           return
     end subroutine stdlib_csyconvf_rook

     module pure subroutine stdlib_zsyconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
     !! If parameter WAY = 'C':
     !! ZSYCONVF_ROOK converts the factorization output format used in
     !! ZSYTRF_ROOK provided on entry in parameter A into the factorization
     !! output format used in ZSYTRF_RK (or ZSYTRF_BK) that is stored
     !! on exit in parameters A and E. IPIV format for ZSYTRF_ROOK and
     !! ZSYTRF_RK (or ZSYTRF_BK) is the same and is not converted.
     !! If parameter WAY = 'R':
     !! ZSYCONVF_ROOK performs the conversion in reverse direction, i.e.
     !! converts the factorization output format used in ZSYTRF_RK
     !! (or ZSYTRF_BK) provided on entry in parameters A and E into
     !! the factorization output format used in ZSYTRF_ROOK that is stored
     !! on exit in parameter A. IPIV format for ZSYTRF_ROOK and
     !! ZSYTRF_RK (or ZSYTRF_BK) is the same and is not converted.
     !! ZSYCONVF_ROOK can also convert in Hermitian matrix case, i.e. between
     !! formats used in ZHETRF_ROOK and ZHETRF_RK (or ZHETRF_BK).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip, ip2
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYCONVF_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! begin a is upper
              if ( convert ) then
                 ! convert a (a is upper)
                 ! convert value
                 ! assign superdiagonal entries of d to array e and czero out
                 ! corresponding entries in input storage a
                 i = n
                 e( 1 ) = czero
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       e( i ) = a( i-1, i )
                       e( i-1 ) = czero
                       a( i-1, i ) = czero
                       i = i - 1
                    else
                       e( i ) = czero
                    end if
                    i = i - 1
                 end do
                 ! convert permutations
                 ! apply permutations to submatrices of upper part of a
                 ! in factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_zswap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i and ipiv(i) and i-1 and ipiv(i-1)
                       ! in a(1:i,n-i:n)
                       ip = -ipiv( i )
                       ip2 = -ipiv( i-1 )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_zswap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                          if( ip2/=(i-1) ) then
                             call stdlib_zswap( n-i, a( i-1, i+1 ), lda,a( ip2, i+1 ), lda )
                                       
                          end if
                       end if
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              else
                 ! revert a (a is upper)
                 ! revert permutations
                 ! apply permutations to submatrices of upper part of a
                 ! in reverse factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_zswap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i-1) and i and ipiv(i)
                       ! in a(1:i,n-i:n)
                       i = i + 1
                       ip = -ipiv( i )
                       ip2 = -ipiv( i-1 )
                       if( i<n ) then
                          if( ip2/=(i-1) ) then
                             call stdlib_zswap( n-i, a( ip2, i+1 ), lda,a( i-1, i+1 ), lda )
                                       
                          end if
                          if( ip/=i ) then
                             call stdlib_zswap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    end if
                    i = i + 1
                 end do
                 ! revert value
                 ! assign superdiagonal entries of d from array e to
                 ! superdiagonal entries of a.
                 i = n
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       a( i-1, i ) = e( i )
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              ! end a is upper
              end if
           else
              ! begin a is lower
              if ( convert ) then
                 ! convert a (a is lower)
                 ! convert value
                 ! assign subdiagonal entries of d to array e and czero out
                 ! corresponding entries in input storage a
                 i = 1
                 e( n ) = czero
                 do while ( i<=n )
                    if( i<n .and. ipiv(i)<0 ) then
                       e( i ) = a( i+1, i )
                       e( i+1 ) = czero
                       a( i+1, i ) = czero
                       i = i + 1
                    else
                       e( i ) = czero
                    end if
                    i = i + 1
                 end do
                 ! convert permutations
                 ! apply permutations to submatrices of lower part of a
                 ! in factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_zswap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i and ipiv(i) and i+1 and ipiv(i+1)
                       ! in a(i:n,1:i-1)
                       ip = -ipiv( i )
                       ip2 = -ipiv( i+1 )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_zswap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                          if( ip2/=(i+1) ) then
                             call stdlib_zswap( i-1, a( i+1, 1 ), lda,a( ip2, 1 ), lda )
                          end if
                       end if
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              else
                 ! revert a (a is lower)
                 ! revert permutations
                 ! apply permutations to submatrices of lower part of a
                 ! in reverse factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_zswap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i+1) and i and ipiv(i)
                       ! in a(i:n,1:i-1)
                       i = i - 1
                       ip = -ipiv( i )
                       ip2 = -ipiv( i+1 )
                       if ( i>1 ) then
                          if( ip2/=(i+1) ) then
                             call stdlib_zswap( i-1, a( ip2, 1 ), lda,a( i+1, 1 ), lda )
                          end if
                          if( ip/=i ) then
                             call stdlib_zswap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    end if
                    i = i - 1
                 end do
                 ! revert value
                 ! assign subdiagonal entries of d from array e to
                 ! subgiagonal entries of a.
                 i = 1
                 do while ( i<=n-1 )
                    if( ipiv( i )<0 ) then
                       a( i + 1, i ) = e( i )
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              end if
              ! end a is lower
           end if
           return
     end subroutine stdlib_zsyconvf_rook

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$syconvf_rook( uplo, way, n, a, lda, e, ipiv, info )
     !! If parameter WAY = 'C':
     !! ZSYCONVF_ROOK: converts the factorization output format used in
     !! ZSYTRF_ROOK provided on entry in parameter A into the factorization
     !! output format used in ZSYTRF_RK (or ZSYTRF_BK) that is stored
     !! on exit in parameters A and E. IPIV format for ZSYTRF_ROOK and
     !! ZSYTRF_RK (or ZSYTRF_BK) is the same and is not converted.
     !! If parameter WAY = 'R':
     !! ZSYCONVF_ROOK performs the conversion in reverse direction, i.e.
     !! converts the factorization output format used in ZSYTRF_RK
     !! (or ZSYTRF_BK) provided on entry in parameters A and E into
     !! the factorization output format used in ZSYTRF_ROOK that is stored
     !! on exit in parameter A. IPIV format for ZSYTRF_ROOK and
     !! ZSYTRF_RK (or ZSYTRF_BK) is the same and is not converted.
     !! ZSYCONVF_ROOK can also convert in Hermitian matrix case, i.e. between
     !! formats used in ZHETRF_ROOK and ZHETRF_RK (or ZHETRF_BK).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, way
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), e(*)
        ! =====================================================================
           
           ! External Subroutines 
           logical(lk) :: upper, convert
           integer(ilp) :: i, ip, ip2
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           convert = stdlib_lsame( way, 'C' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( .not.convert .and. .not.stdlib_lsame( way, 'R' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYCONVF_ROOK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! begin a is upper
              if ( convert ) then
                 ! convert a (a is upper)
                 ! convert value
                 ! assign superdiagonal entries of d to array e and czero out
                 ! corresponding entries in input storage a
                 i = n
                 e( 1 ) = czero
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       e( i ) = a( i-1, i )
                       e( i-1 ) = czero
                       a( i-1, i ) = czero
                       i = i - 1
                    else
                       e( i ) = czero
                    end if
                    i = i - 1
                 end do
                 ! convert permutations
                 ! apply permutations to submatrices of upper part of a
                 ! in factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_${ci}$swap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i and ipiv(i) and i-1 and ipiv(i-1)
                       ! in a(1:i,n-i:n)
                       ip = -ipiv( i )
                       ip2 = -ipiv( i-1 )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_${ci}$swap( n-i, a( i, i+1 ), lda,a( ip, i+1 ), lda )
                          end if
                          if( ip2/=(i-1) ) then
                             call stdlib_${ci}$swap( n-i, a( i-1, i+1 ), lda,a( ip2, i+1 ), lda )
                                       
                          end if
                       end if
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              else
                 ! revert a (a is upper)
                 ! revert permutations
                 ! apply permutations to submatrices of upper part of a
                 ! in reverse factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(1:i,n-i:n)
                       ip = ipiv( i )
                       if( i<n ) then
                          if( ip/=i ) then
                             call stdlib_${ci}$swap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i-1 and ipiv(i-1) and i and ipiv(i)
                       ! in a(1:i,n-i:n)
                       i = i + 1
                       ip = -ipiv( i )
                       ip2 = -ipiv( i-1 )
                       if( i<n ) then
                          if( ip2/=(i-1) ) then
                             call stdlib_${ci}$swap( n-i, a( ip2, i+1 ), lda,a( i-1, i+1 ), lda )
                                       
                          end if
                          if( ip/=i ) then
                             call stdlib_${ci}$swap( n-i, a( ip, i+1 ), lda,a( i, i+1 ), lda )
                          end if
                       end if
                    end if
                    i = i + 1
                 end do
                 ! revert value
                 ! assign superdiagonal entries of d from array e to
                 ! superdiagonal entries of a.
                 i = n
                 do while ( i>1 )
                    if( ipiv( i )<0 ) then
                       a( i-1, i ) = e( i )
                       i = i - 1
                    end if
                    i = i - 1
                 end do
              ! end a is upper
              end if
           else
              ! begin a is lower
              if ( convert ) then
                 ! convert a (a is lower)
                 ! convert value
                 ! assign subdiagonal entries of d to array e and czero out
                 ! corresponding entries in input storage a
                 i = 1
                 e( n ) = czero
                 do while ( i<=n )
                    if( i<n .and. ipiv(i)<0 ) then
                       e( i ) = a( i+1, i )
                       e( i+1 ) = czero
                       a( i+1, i ) = czero
                       i = i + 1
                    else
                       e( i ) = czero
                    end if
                    i = i + 1
                 end do
                 ! convert permutations
                 ! apply permutations to submatrices of lower part of a
                 ! in factorization order where i increases from 1 to n
                 i = 1
                 do while ( i<=n )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_${ci}$swap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i and ipiv(i) and i+1 and ipiv(i+1)
                       ! in a(i:n,1:i-1)
                       ip = -ipiv( i )
                       ip2 = -ipiv( i+1 )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_${ci}$swap( i-1, a( i, 1 ), lda,a( ip, 1 ), lda )
                          end if
                          if( ip2/=(i+1) ) then
                             call stdlib_${ci}$swap( i-1, a( i+1, 1 ), lda,a( ip2, 1 ), lda )
                          end if
                       end if
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              else
                 ! revert a (a is lower)
                 ! revert permutations
                 ! apply permutations to submatrices of lower part of a
                 ! in reverse factorization order where i decreases from n to 1
                 i = n
                 do while ( i>=1 )
                    if( ipiv( i )>0 ) then
                       ! 1-by-1 pivot interchange
                       ! swap rows i and ipiv(i) in a(i:n,1:i-1)
                       ip = ipiv( i )
                       if ( i>1 ) then
                          if( ip/=i ) then
                             call stdlib_${ci}$swap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    else
                       ! 2-by-2 pivot interchange
                       ! swap rows i+1 and ipiv(i+1) and i and ipiv(i)
                       ! in a(i:n,1:i-1)
                       i = i - 1
                       ip = -ipiv( i )
                       ip2 = -ipiv( i+1 )
                       if ( i>1 ) then
                          if( ip2/=(i+1) ) then
                             call stdlib_${ci}$swap( i-1, a( ip2, 1 ), lda,a( i+1, 1 ), lda )
                          end if
                          if( ip/=i ) then
                             call stdlib_${ci}$swap( i-1, a( ip, 1 ), lda,a( i, 1 ), lda )
                          end if
                       end if
                    end if
                    i = i - 1
                 end do
                 ! revert value
                 ! assign subdiagonal entries of d from array e to
                 ! subgiagonal entries of a.
                 i = 1
                 do while ( i<=n-1 )
                    if( ipiv( i )<0 ) then
                       a( i + 1, i ) = e( i )
                       i = i + 1
                    end if
                    i = i + 1
                 end do
              end if
              ! end a is lower
           end if
           return
     end subroutine stdlib_${ci}$syconvf_rook

#:endif
#:endfor



     module pure subroutine stdlib_chetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )
     !! CHETRS_AA solves a system of linear equations A*X = B with a complex
     !! hermitian matrix A using the factorization A = U**H*T*U or
     !! A = L*T*L**H computed by CHETRF_AA.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, nrhs, lda, ldb, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           logical(lk) :: lquery, upper
           integer(ilp) :: k, kp, lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max( 1, 3*n-2 ) .and. .not.lquery ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRS_AA', -info )
              return
           else if( lquery ) then
              lwkopt = (3*n-2)
              work( 1 ) = lwkopt
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u**h*t*u.
              ! 1) forward substitution with u**h
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 k = 1
                 do while ( k<=n )
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                    k = k + 1
                 end do
                 ! compute u**h \ b -> b    [ (u**h \p**t * b) ]
                 call stdlib_ctrsm( 'L', 'U', 'C', 'U', n-1, nrhs, cone, a( 1, 2 ),lda, b( 2, 1 ),&
                            ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (u**h \p**t * b) ]
              call stdlib_clacpy( 'F', 1, n, a(1, 1), lda+1, work(n), 1)
              if( n>1 ) then
                  call stdlib_clacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 2*n ), 1)
                  call stdlib_clacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 1 ), 1)
                  call stdlib_clacgv( n-1, work( 1 ), 1 )
              end if
              call stdlib_cgtsv(n, nrhs, work(1), work(n), work(2*n), b, ldb,info)
              ! 3) backward substitution with u
              if( n>1 ) then
                 ! compute u \ b -> b   [ u \ (t \ (u**h \p**t * b) ) ]
                 call stdlib_ctrsm( 'L', 'U', 'N', 'U', n-1, nrhs, cone, a( 1, 2 ),lda, b(2, 1), &
                           ldb)
                 ! pivot, p * b  -> b [ p * (u \ (t \ (u**h \p**t * b) )) ]
                 k = n
                 do while ( k>=1 )
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                    k = k - 1
                 end do
              end if
           else
              ! solve a*x = b, where a = l*t*l**h.
              ! 1) forward substitution with l
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 k = 1
                 do while ( k<=n )
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                    k = k + 1
                 end do
                 ! compute l \ b -> b    [ (l \p**t * b) ]
                 call stdlib_ctrsm( 'L', 'L', 'N', 'U', n-1, nrhs, cone, a( 2, 1),lda, b(2, 1), &
                           ldb )
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (l \p**t * b) ]
              call stdlib_clacpy( 'F', 1, n, a(1, 1), lda+1, work(n), 1)
              if( n>1 ) then
                  call stdlib_clacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 1 ), 1 )
                  call stdlib_clacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 2*n ), 1)
                  call stdlib_clacgv( n-1, work( 2*n ), 1 )
              end if
              call stdlib_cgtsv(n, nrhs, work(1), work(n), work(2*n), b, ldb,info)
              ! 3) backward substitution with l**h
              if( n>1 ) then
                 ! compute (l**h \ b) -> b   [ l**h \ (t \ (l \p**t * b) ) ]
                 call stdlib_ctrsm( 'L', 'L', 'C', 'U', n-1, nrhs, cone, a( 2, 1 ),lda, b( 2, 1 ),&
                            ldb )
                 ! pivot, p * b -> b  [ p * (l**h \ (t \ (l \p**t * b) )) ]
                 k = n
                 do while ( k>=1 )
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                    k = k - 1
                 end do
              end if
           end if
           return
     end subroutine stdlib_chetrs_aa

     module pure subroutine stdlib_zhetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )
     !! ZHETRS_AA solves a system of linear equations A*X = B with a complex
     !! hermitian matrix A using the factorization A = U**H*T*U or
     !! A = L*T*L**H computed by ZHETRF_AA.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, nrhs, lda, ldb, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(inout) :: b(ldb,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           logical(lk) :: lquery, upper
           integer(ilp) :: k, kp, lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max( 1, 3*n-2 ) .and. .not.lquery ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRS_AA', -info )
              return
           else if( lquery ) then
              lwkopt = (3*n-2)
              work( 1 ) = lwkopt
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u**h*t*u.
              ! 1) forward substitution with u**h
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 do k = 1, n
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
                 ! compute u**h \ b -> b    [ (u**h \p**t * b) ]
                 call stdlib_ztrsm( 'L', 'U', 'C', 'U', n-1, nrhs, cone, a( 1, 2 ),lda, b( 2, 1 ),&
                            ldb )
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (u**h \p**t * b) ]
              call stdlib_zlacpy( 'F', 1, n, a(1, 1), lda+1, work(n), 1 )
              if( n>1 ) then
                  call stdlib_zlacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 2*n ), 1)
                  call stdlib_zlacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 1 ), 1 )
                  call stdlib_zlacgv( n-1, work( 1 ), 1 )
              end if
              call stdlib_zgtsv( n, nrhs, work(1), work(n), work(2*n), b, ldb,info )
              ! 3) backward substitution with u
              if( n>1 ) then
                 ! compute u \ b -> b   [ u \ (t \ (u**h \p**t * b) ) ]
                 call stdlib_ztrsm( 'L', 'U', 'N', 'U', n-1, nrhs, cone, a( 1, 2 ),lda, b(2, 1), &
                           ldb)
                 ! pivot, p * b  [ p * (u**h \ (t \ (u \p**t * b) )) ]
                 do k = n, 1, -1
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
              end if
           else
              ! solve a*x = b, where a = l*t*l**h.
              ! 1) forward substitution with l
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 do k = 1, n
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
                 ! compute l \ b -> b    [ (l \p**t * b) ]
                 call stdlib_ztrsm( 'L', 'L', 'N', 'U', n-1, nrhs, cone, a( 2, 1 ),lda, b(2, 1), &
                           ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (l \p**t * b) ]
              call stdlib_zlacpy( 'F', 1, n, a(1, 1), lda+1, work(n), 1)
              if( n>1 ) then
                  call stdlib_zlacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 1 ), 1)
                  call stdlib_zlacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 2*n ), 1)
                  call stdlib_zlacgv( n-1, work( 2*n ), 1 )
              end if
              call stdlib_zgtsv(n, nrhs, work(1), work(n), work(2*n), b, ldb,info)
              ! 3) backward substitution with l**h
              if( n>1 ) then
                 ! compute l**h \ b -> b   [ l**h \ (t \ (l \p**t * b) ) ]
                 call stdlib_ztrsm( 'L', 'L', 'C', 'U', n-1, nrhs, cone, a( 2, 1 ),lda, b( 2, 1 ),&
                            ldb)
                 ! pivot, p * b  [ p * (l**h \ (t \ (l \p**t * b) )) ]
                 do k = n, 1, -1
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
              end if
           end if
           return
     end subroutine stdlib_zhetrs_aa

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, lwork, info )
     !! ZHETRS_AA: solves a system of linear equations A*X = B with a complex
     !! hermitian matrix A using the factorization A = U**H*T*U or
     !! A = L*T*L**H computed by ZHETRF_AA.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, nrhs, lda, ldb, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(inout) :: b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           logical(lk) :: lquery, upper
           integer(ilp) :: k, kp, lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max( 1, 3*n-2 ) .and. .not.lquery ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRS_AA', -info )
              return
           else if( lquery ) then
              lwkopt = (3*n-2)
              work( 1 ) = lwkopt
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u**h*t*u.
              ! 1) forward substitution with u**h
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 do k = 1, n
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
                 ! compute u**h \ b -> b    [ (u**h \p**t * b) ]
                 call stdlib_${ci}$trsm( 'L', 'U', 'C', 'U', n-1, nrhs, cone, a( 1, 2 ),lda, b( 2, 1 ),&
                            ldb )
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (u**h \p**t * b) ]
              call stdlib_${ci}$lacpy( 'F', 1, n, a(1, 1), lda+1, work(n), 1 )
              if( n>1 ) then
                  call stdlib_${ci}$lacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 2*n ), 1)
                  call stdlib_${ci}$lacpy( 'F', 1, n-1, a( 1, 2 ), lda+1, work( 1 ), 1 )
                  call stdlib_${ci}$lacgv( n-1, work( 1 ), 1 )
              end if
              call stdlib_${ci}$gtsv( n, nrhs, work(1), work(n), work(2*n), b, ldb,info )
              ! 3) backward substitution with u
              if( n>1 ) then
                 ! compute u \ b -> b   [ u \ (t \ (u**h \p**t * b) ) ]
                 call stdlib_${ci}$trsm( 'L', 'U', 'N', 'U', n-1, nrhs, cone, a( 1, 2 ),lda, b(2, 1), &
                           ldb)
                 ! pivot, p * b  [ p * (u**h \ (t \ (u \p**t * b) )) ]
                 do k = n, 1, -1
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
              end if
           else
              ! solve a*x = b, where a = l*t*l**h.
              ! 1) forward substitution with l
              if( n>1 ) then
                 ! pivot, p**t * b -> b
                 do k = 1, n
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
                 ! compute l \ b -> b    [ (l \p**t * b) ]
                 call stdlib_${ci}$trsm( 'L', 'L', 'N', 'U', n-1, nrhs, cone, a( 2, 1 ),lda, b(2, 1), &
                           ldb)
              end if
              ! 2) solve with triangular matrix t
              ! compute t \ b -> b   [ t \ (l \p**t * b) ]
              call stdlib_${ci}$lacpy( 'F', 1, n, a(1, 1), lda+1, work(n), 1)
              if( n>1 ) then
                  call stdlib_${ci}$lacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 1 ), 1)
                  call stdlib_${ci}$lacpy( 'F', 1, n-1, a( 2, 1 ), lda+1, work( 2*n ), 1)
                  call stdlib_${ci}$lacgv( n-1, work( 2*n ), 1 )
              end if
              call stdlib_${ci}$gtsv(n, nrhs, work(1), work(n), work(2*n), b, ldb,info)
              ! 3) backward substitution with l**h
              if( n>1 ) then
                 ! compute l**h \ b -> b   [ l**h \ (t \ (l \p**t * b) ) ]
                 call stdlib_${ci}$trsm( 'L', 'L', 'C', 'U', n-1, nrhs, cone, a( 2, 1 ),lda, b( 2, 1 ),&
                            ldb)
                 ! pivot, p * b  [ p * (l**h \ (t \ (l \p**t * b) )) ]
                 do k = n, 1, -1
                    kp = ipiv( k )
                    if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 end do
              end if
           end if
           return
     end subroutine stdlib_${ci}$hetrs_aa

#:endif
#:endfor



     module pure subroutine stdlib_clahef_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
     !! CLAHEF_RK computes a partial factorization of a complex Hermitian
     !! matrix A using the bounded Bunch-Kaufman (rook) diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L',
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! CLAHEF_RK is an auxiliary routine called by CHETRF_RK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: w(ldw,*), e(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, ii, j, jb, jj, jmax, k, kk, kkw, kp, kstep, kw, p
           real(sp) :: absakk, alpha, colmax, stemp, r1, rowmax, t, sfmin
           complex(sp) :: d11, d21, d22, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_slamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11 (note that conjg(w) is actually stored)
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = czero
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              if( k>1 )call stdlib_ccopy( k-1, a( 1, k ), 1, w( 1, kw ), 1 )
              w( k, kw ) = real( a( k, k ),KIND=sp)
              if( k<n ) then
                 call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ), lda,w( k, kw+1 ), &
                           ldw, cone, w( 1, kw ), 1 )
                 w( k, kw ) = real( w( k, kw ),KIND=sp)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, kw ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( w( k, kw ),KIND=sp)
                 if( k>1 )call stdlib_ccopy( k-1, w( 1, kw ), 1, a( 1, k ), 1 )
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = czero
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! lop until pivot found
                    done = .false.
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       if( imax>1 )call stdlib_ccopy( imax-1, a( 1, imax ), 1, w( 1, kw-1 ),1 )
                                 
                       w( imax, kw-1 ) = real( a( imax, imax ),KIND=sp)
                       call stdlib_ccopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       call stdlib_clacgv( k-imax, w( imax+1, kw-1 ), 1 )
                       if( k<n ) then
                          call stdlib_cgemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda, w( &
                                    imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                          w( imax, kw-1 ) = real( w( imax, kw-1 ),KIND=sp)
                       end if
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_icamax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = cabs1( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_icamax( imax-1, w( 1, kw-1 ), 1 )
                          stemp = cabs1( w( itemp, kw-1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=sp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( w( imax,kw-1 ),KIND=sp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_ccopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 12
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns p and k.
                 ! updated column p is already stored in column kw of w.
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p of submatrix a
                    ! at step k. no need to copy element into columns
                    ! k and k-1 of a for 2-by-2 pivot, since these columns
                    ! will be later overwritten.
                    a( p, p ) = real( a( k, k ),KIND=sp)
                    call stdlib_ccopy( k-1-p, a( p+1, k ), 1, a( p, p+1 ),lda )
                    call stdlib_clacgv( k-1-p, a( p, p+1 ), lda )
                    if( p>1 )call stdlib_ccopy( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in the last k+1 to n columns of a
                    ! (columns k and k-1 of a for 2-by-2 pivot will be
                    ! later overwritten). interchange rows k and p
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_cswap( n-k, a( k, k+1 ), lda, a( p, k+1 ),lda )
                    call stdlib_cswap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ),ldw )
                 end if
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=sp)
                    call stdlib_ccopy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_clacgv( kk-1-kp, a( kp, kp+1 ), lda )
                    if( kp>1 )call stdlib_ccopy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_cswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_cswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! (1) store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element u(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=sp) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_ccopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(3))
                       ! handle division by a small number
                       t = real( a( k, k ),KIND=sp)
                       if( abs( t )>=sfmin ) then
                          r1 = one / t
                          call stdlib_csscal( k-1, r1, a( 1, k ), 1 )
                       else
                          do ii = 1, k-1
                             a( ii, k ) = a( ii, k ) / t
                          end do
                       end if
                       ! (2) conjugate column w(kw)
                       call stdlib_clacgv( k-1, w( 1, kw ), 1 )
                       ! store the superdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! (1) store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! (note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored)
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! handle division by a small number. (note: order of
                       ! operations is important)
                       ! = ( t*(( d11 )/conj(d21)) t*((  -1 )/d21 ) )
                         ! (   ((  -1 )          )   (( d22 )     ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0 in 2x2 pivot case(4),
                            ! since |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / conjg( d21 )
                       d22 = w( k-1, kw-1 ) / d21
                       t = one / ( real( d11*d22,KIND=sp)-one )
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( ( d11*w( j, kw-1 )-w( j, kw ) ) /d21 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /conjg( d21 ) )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy superdiagonal element of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = czero
                    a( k, k ) = w( k, kw )
                    e( k ) = w( k-1, kw )
                    e( k-1 ) = czero
                    ! (2) conjugate columns w(kw) and w(kw-1)
                    call stdlib_clacgv( k-1, w( 1, kw ), 1 )
                    call stdlib_clacgv( k-2, w( 1, kw-1 ), 1 )
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**h = a11 - u12*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                    call stdlib_cgemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k,-cone, a( &
                           1, k+1 ), lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22 (note that conjg(w) is actually stored)
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = czero
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update column k of w
              w( k, k ) = real( a( k, k ),KIND=sp)
              if( k<n )call stdlib_ccopy( n-k, a( k+1, k ), 1, w( k+1, k ), 1 )
              if( k>1 ) then
                 call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( k, 1 ), &
                           ldw, cone, w( k, k ), 1 )
                 w( k, k ) = real( w( k, k ),KIND=sp)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, k ),KIND=sp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( w( k, k ),KIND=sp)
                 if( k<n )call stdlib_ccopy( n-k, w( k+1, k ), 1, a( k+1, k ), 1 )
                 ! set e( k ) to zero
                 if( k<n )e( k ) = czero
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_ccopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_clacgv( imax-k, w( k, k+1 ), 1 )
                       w( imax, k+1 ) = real( a( imax, imax ),KIND=sp)
                       if( imax<n )call stdlib_ccopy( n-imax, a( imax+1, imax ), 1,w( imax+1, k+1 &
                                 ), 1 )
                       if( k>1 ) then
                          call stdlib_cgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone,a( k, 1 ), lda, w( &
                                    imax, 1 ), ldw,cone, w( k, k+1 ), 1 )
                          w( imax, k+1 ) = real( w( imax, k+1 ),KIND=sp)
                       end if
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_icamax( imax-k, w( k, k+1 ), 1 )
                          rowmax = cabs1( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_icamax( n-imax, w( imax+1, k+1 ), 1)
                          stemp = cabs1( w( itemp, k+1 ) )
                          if( stemp>rowmax ) then
                             rowmax = stemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,k+1 ),KIND=sp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( w( imax,k+1 ),KIND=sp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_ccopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 72
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns p and k (only for 2-by-2 pivot).
                 ! updated column p is already stored in column k of w.
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column kk-1 to column p of submatrix a
                    ! at step k. no need to copy element into columns
                    ! k and k+1 of a for 2-by-2 pivot, since these columns
                    ! will be later overwritten.
                    a( p, p ) = real( a( k, k ),KIND=sp)
                    call stdlib_ccopy( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                    call stdlib_clacgv( p-k-1, a( p, k+1 ), lda )
                    if( p<n )call stdlib_ccopy( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    ! interchange rows k and p in first k-1 columns of a
                    ! (columns k and k+1 of a for 2-by-2 pivot will be
                    ! later overwritten). interchange rows k and p
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_cswap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_cswap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=sp)
                    call stdlib_ccopy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    call stdlib_clacgv( kp-kk-1, a( kp, kk+1 ), lda )
                    if( kp<n )call stdlib_ccopy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (column k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_cswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_cswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! (1) store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=sp) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_ccopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(3))
                       ! handle division by a small number
                       t = real( a( k, k ),KIND=sp)
                       if( abs( t )>=sfmin ) then
                          r1 = one / t
                          call stdlib_csscal( n-k, r1, a( k+1, k ), 1 )
                       else
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / t
                          end do
                       end if
                       ! (2) conjugate column w(k)
                       call stdlib_clacgv( n-k, w( k+1, k ), 1 )
                       ! store the subdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! (1) store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored.
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! handle division by a small number. (note: order of
                       ! operations is important)
                       ! = ( t*(( d11 )/conj(d21)) t*((  -1 )/d21 ) )
                         ! (   ((  -1 )          )   (( d22 )     ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0 in 2x2 pivot case(4),
                            ! since |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / conjg( d21 )
                       t = one / ( real( d11*d22,KIND=sp)-one )
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /conjg( d21 ) )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy subdiagonal element of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = czero
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    e( k ) = w( k+1, k )
                    e( k+1 ) = czero
                    ! (2) conjugate columns w(k) and w(k+1)
                    call stdlib_clacgv( n-k, w( k+1, k ), 1 )
                    call stdlib_clacgv( n-k-1, w( k+2, k+1 ), 1 )
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**h = a22 - l21*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                    call stdlib_cgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=sp)
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_clahef_rk

     module pure subroutine stdlib_zlahef_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
     !! ZLAHEF_RK computes a partial factorization of a complex Hermitian
     !! matrix A using the bounded Bunch-Kaufman (rook) diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L',
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! ZLAHEF_RK is an auxiliary routine called by ZHETRF_RK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: w(ldw,*), e(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, ii, j, jb, jj, jmax, k, kk, kkw, kp, kstep, kw, p
           real(dp) :: absakk, alpha, colmax, dtemp, r1, rowmax, t, sfmin
           complex(dp) :: d11, d21, d22, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=dp) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_dlamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11 (note that conjg(w) is actually stored)
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = czero
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              if( k>1 )call stdlib_zcopy( k-1, a( 1, k ), 1, w( 1, kw ), 1 )
              w( k, kw ) = real( a( k, k ),KIND=dp)
              if( k<n ) then
                 call stdlib_zgemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ), lda,w( k, kw+1 ), &
                           ldw, cone, w( 1, kw ), 1 )
                 w( k, kw ) = real( w( k, kw ),KIND=dp)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, kw ),KIND=dp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_izamax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( w( k, kw ),KIND=dp)
                 if( k>1 )call stdlib_zcopy( k-1, w( 1, kw ), 1, a( 1, k ), 1 )
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = czero
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! lop until pivot found
                    done = .false.
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       if( imax>1 )call stdlib_zcopy( imax-1, a( 1, imax ), 1, w( 1, kw-1 ),1 )
                                 
                       w( imax, kw-1 ) = real( a( imax, imax ),KIND=dp)
                       call stdlib_zcopy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       call stdlib_zlacgv( k-imax, w( imax+1, kw-1 ), 1 )
                       if( k<n ) then
                          call stdlib_zgemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda, w( &
                                    imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                          w( imax, kw-1 ) = real( w( imax, kw-1 ),KIND=dp)
                       end if
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_izamax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = cabs1( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_izamax( imax-1, w( 1, kw-1 ), 1 )
                          dtemp = cabs1( w( itemp, kw-1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=dp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( w( imax,kw-1 ),KIND=dp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_zcopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_zcopy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 12
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns p and k.
                 ! updated column p is already stored in column kw of w.
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p of submatrix a
                    ! at step k. no need to copy element into columns
                    ! k and k-1 of a for 2-by-2 pivot, since these columns
                    ! will be later overwritten.
                    a( p, p ) = real( a( k, k ),KIND=dp)
                    call stdlib_zcopy( k-1-p, a( p+1, k ), 1, a( p, p+1 ),lda )
                    call stdlib_zlacgv( k-1-p, a( p, p+1 ), lda )
                    if( p>1 )call stdlib_zcopy( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in the last k+1 to n columns of a
                    ! (columns k and k-1 of a for 2-by-2 pivot will be
                    ! later overwritten). interchange rows k and p
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_zswap( n-k, a( k, k+1 ), lda, a( p, k+1 ),lda )
                    call stdlib_zswap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ),ldw )
                 end if
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=dp)
                    call stdlib_zcopy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_zlacgv( kk-1-kp, a( kp, kp+1 ), lda )
                    if( kp>1 )call stdlib_zcopy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_zswap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_zswap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! (1) store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element u(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=dp) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_zcopy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(3))
                       ! handle division by a small number
                       t = real( a( k, k ),KIND=dp)
                       if( abs( t )>=sfmin ) then
                          r1 = one / t
                          call stdlib_zdscal( k-1, r1, a( 1, k ), 1 )
                       else
                          do ii = 1, k-1
                             a( ii, k ) = a( ii, k ) / t
                          end do
                       end if
                       ! (2) conjugate column w(kw)
                       call stdlib_zlacgv( k-1, w( 1, kw ), 1 )
                       ! store the superdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! (1) store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! (note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored)
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! handle division by a small number. (note: order of
                       ! operations is important)
                       ! = ( t*(( d11 )/conj(d21)) t*((  -1 )/d21 ) )
                         ! (   ((  -1 )          )   (( d22 )     ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0 in 2x2 pivot case(4),
                            ! since |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / conjg( d21 )
                       d22 = w( k-1, kw-1 ) / d21
                       t = one / ( real( d11*d22,KIND=dp)-one )
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( ( d11*w( j, kw-1 )-w( j, kw ) ) /d21 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /conjg( d21 ) )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy superdiagonal element of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = czero
                    a( k, k ) = w( k, kw )
                    e( k ) = w( k-1, kw )
                    e( k-1 ) = czero
                    ! (2) conjugate columns w(kw) and w(kw-1)
                    call stdlib_zlacgv( k-1, w( 1, kw ), 1 )
                    call stdlib_zlacgv( k-2, w( 1, kw-1 ), 1 )
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**h = a11 - u12*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=dp)
                    call stdlib_zgemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=dp)
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_zgemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k,-cone, a( &
                           1, k+1 ), lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22 (note that conjg(w) is actually stored)
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = czero
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update column k of w
              w( k, k ) = real( a( k, k ),KIND=dp)
              if( k<n )call stdlib_zcopy( n-k, a( k+1, k ), 1, w( k+1, k ), 1 )
              if( k>1 ) then
                 call stdlib_zgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( k, 1 ), &
                           ldw, cone, w( k, k ), 1 )
                 w( k, k ) = real( w( k, k ),KIND=dp)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, k ),KIND=dp) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_izamax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( w( k, k ),KIND=dp)
                 if( k<n )call stdlib_zcopy( n-k, w( k+1, k ), 1, a( k+1, k ), 1 )
                 ! set e( k ) to zero
                 if( k<n )e( k ) = czero
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_zcopy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_zlacgv( imax-k, w( k, k+1 ), 1 )
                       w( imax, k+1 ) = real( a( imax, imax ),KIND=dp)
                       if( imax<n )call stdlib_zcopy( n-imax, a( imax+1, imax ), 1,w( imax+1, k+1 &
                                 ), 1 )
                       if( k>1 ) then
                          call stdlib_zgemv( 'NO TRANSPOSE', n-k+1, k-1, -cone,a( k, 1 ), lda, w( &
                                    imax, 1 ), ldw,cone, w( k, k+1 ), 1 )
                          w( imax, k+1 ) = real( w( imax, k+1 ),KIND=dp)
                       end if
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_izamax( imax-k, w( k, k+1 ), 1 )
                          rowmax = cabs1( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_izamax( n-imax, w( imax+1, k+1 ), 1)
                          dtemp = cabs1( w( itemp, k+1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,k+1 ),KIND=dp) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( w( imax,k+1 ),KIND=dp) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_zcopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_zcopy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 72
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns p and k (only for 2-by-2 pivot).
                 ! updated column p is already stored in column k of w.
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column kk-1 to column p of submatrix a
                    ! at step k. no need to copy element into columns
                    ! k and k+1 of a for 2-by-2 pivot, since these columns
                    ! will be later overwritten.
                    a( p, p ) = real( a( k, k ),KIND=dp)
                    call stdlib_zcopy( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                    call stdlib_zlacgv( p-k-1, a( p, k+1 ), lda )
                    if( p<n )call stdlib_zcopy( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    ! interchange rows k and p in first k-1 columns of a
                    ! (columns k and k+1 of a for 2-by-2 pivot will be
                    ! later overwritten). interchange rows k and p
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_zswap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_zswap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=dp)
                    call stdlib_zcopy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    call stdlib_zlacgv( kp-kk-1, a( kp, kk+1 ), lda )
                    if( kp<n )call stdlib_zcopy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (column k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_zswap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_zswap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! (1) store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=dp) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_zcopy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(3))
                       ! handle division by a small number
                       t = real( a( k, k ),KIND=dp)
                       if( abs( t )>=sfmin ) then
                          r1 = one / t
                          call stdlib_zdscal( n-k, r1, a( k+1, k ), 1 )
                       else
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / t
                          end do
                       end if
                       ! (2) conjugate column w(k)
                       call stdlib_zlacgv( n-k, w( k+1, k ), 1 )
                       ! store the subdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! (1) store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored.
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! handle division by a small number. (note: order of
                       ! operations is important)
                       ! = ( t*(( d11 )/conj(d21)) t*((  -1 )/d21 ) )
                         ! (   ((  -1 )          )   (( d22 )     ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0 in 2x2 pivot case(4),
                            ! since |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / conjg( d21 )
                       t = one / ( real( d11*d22,KIND=dp)-one )
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /conjg( d21 ) )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy subdiagonal element of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = czero
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    e( k ) = w( k+1, k )
                    e( k+1 ) = czero
                    ! (2) conjugate columns w(k) and w(k+1)
                    call stdlib_zlacgv( n-k, w( k+1, k ), 1 )
                    call stdlib_zlacgv( n-k-1, w( k+2, k+1 ), 1 )
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**h = a22 - l21*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=dp)
                    call stdlib_zgemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=dp)
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_zgemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_zlahef_rk

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$lahef_rk( uplo, n, nb, kb, a, lda, e, ipiv, w, ldw,info )
     !! ZLAHEF_RK: computes a partial factorization of a complex Hermitian
     !! matrix A using the bounded Bunch-Kaufman (rook) diagonal
     !! pivoting method. The partial factorization has the form:
     !! A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
     !! ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
     !! A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L',
     !! ( L21  I ) (  0  A22 ) (  0       I    )
     !! where the order of D is at most NB. The actual order is returned in
     !! the argument KB, and is either NB or NB-1, or N if N <= NB.
     !! ZLAHEF_RK is an auxiliary routine called by ZHETRF_RK. It uses
     !! blocked code (calling Level 3 BLAS) to update the submatrix
     !! A11 (if UPLO = 'U') or A22 (if UPLO = 'L').
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info, kb
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: w(ldw,*), e(*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: sevten = 17.0e+0_${ck}$
           
           
           
           
           ! Local Scalars 
           logical(lk) :: done
           integer(ilp) :: imax, itemp, ii, j, jb, jj, jmax, k, kk, kkw, kp, kstep, kw, p
           real(${ck}$) :: absakk, alpha, colmax, dtemp, r1, rowmax, t, sfmin
           complex(${ck}$) :: d11, d21, d22, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=${ck}$) ) + abs( aimag( z ) )
           ! Executable Statements 
           info = 0
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           ! compute machine safe minimum
           sfmin = stdlib_${c2ri(ci)}$lamch( 'S' )
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! factorize the trailing columns of a using the upper triangle
              ! of a and working backwards, and compute the matrix w = u12*d
              ! for use in updating a11 (note that conjg(w) is actually stored)
              ! initialize the first entry of array e, where superdiagonal
              ! elements of d are stored
              e( 1 ) = czero
              ! k is the main loop index, decreasing from n in steps of 1 or 2
              k = n
              10 continue
              ! kw is the column of w which corresponds to column k of a
              kw = nb + k - n
              ! exit from loop
              if( ( k<=n-nb+1 .and. nb<n ) .or. k<1 )go to 30
              kstep = 1
              p = k
              ! copy column k of a to column kw of w and update it
              if( k>1 )call stdlib_${ci}$copy( k-1, a( 1, k ), 1, w( 1, kw ), 1 )
              w( k, kw ) = real( a( k, k ),KIND=${ck}$)
              if( k<n ) then
                 call stdlib_${ci}$gemv( 'NO TRANSPOSE', k, n-k, -cone, a( 1, k+1 ), lda,w( k, kw+1 ), &
                           ldw, cone, w( 1, kw ), 1 )
                 w( k, kw ) = real( w( k, kw ),KIND=${ck}$)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, kw ),KIND=${ck}$) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ci}$amax( k-1, w( 1, kw ), 1 )
                 colmax = cabs1( w( imax, kw ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( w( k, kw ),KIND=${ck}$)
                 if( k>1 )call stdlib_${ci}$copy( k-1, w( 1, kw ), 1, a( 1, k ), 1 )
                 ! set e( k ) to zero
                 if( k>1 )e( k ) = czero
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! lop until pivot found
                    done = .false.
                    12 continue
                       ! begin pivot search loop body
                       ! copy column imax to column kw-1 of w and update it
                       if( imax>1 )call stdlib_${ci}$copy( imax-1, a( 1, imax ), 1, w( 1, kw-1 ),1 )
                                 
                       w( imax, kw-1 ) = real( a( imax, imax ),KIND=${ck}$)
                       call stdlib_${ci}$copy( k-imax, a( imax, imax+1 ), lda,w( imax+1, kw-1 ), 1 )
                                 
                       call stdlib_${ci}$lacgv( k-imax, w( imax+1, kw-1 ), 1 )
                       if( k<n ) then
                          call stdlib_${ci}$gemv( 'NO TRANSPOSE', k, n-k, -cone,a( 1, k+1 ), lda, w( &
                                    imax, kw+1 ), ldw,cone, w( 1, kw-1 ), 1 )
                          w( imax, kw-1 ) = real( w( imax, kw-1 ),KIND=${ck}$)
                       end if
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = imax + stdlib_i${ci}$amax( k-imax, w( imax+1, kw-1 ),1 )
                          rowmax = cabs1( w( jmax, kw-1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax>1 ) then
                          itemp = stdlib_i${ci}$amax( imax-1, w( 1, kw-1 ), 1 )
                          dtemp = cabs1( w( itemp, kw-1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,kw-1 ),KIND=${ck}$) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( w( imax,kw-1 ),KIND=${ck}$) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column kw-1 of w to column kw of w
                          call stdlib_${ci}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k-1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_${ci}$copy( k, w( 1, kw-1 ), 1, w( 1, kw ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 12
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k - kstep + 1
                 ! kkw is the column of w which corresponds to column kk of a
                 kkw = nb + kk - n
                 ! interchange rows and columns p and k.
                 ! updated column p is already stored in column kw of w.
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column k to column p of submatrix a
                    ! at step k. no need to copy element into columns
                    ! k and k-1 of a for 2-by-2 pivot, since these columns
                    ! will be later overwritten.
                    a( p, p ) = real( a( k, k ),KIND=${ck}$)
                    call stdlib_${ci}$copy( k-1-p, a( p+1, k ), 1, a( p, p+1 ),lda )
                    call stdlib_${ci}$lacgv( k-1-p, a( p, p+1 ), lda )
                    if( p>1 )call stdlib_${ci}$copy( p-1, a( 1, k ), 1, a( 1, p ), 1 )
                    ! interchange rows k and p in the last k+1 to n columns of a
                    ! (columns k and k-1 of a for 2-by-2 pivot will be
                    ! later overwritten). interchange rows k and p
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_${ci}$swap( n-k, a( k, k+1 ), lda, a( p, k+1 ),lda )
                    call stdlib_${ci}$swap( n-kk+1, w( k, kkw ), ldw, w( p, kkw ),ldw )
                 end if
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kkw of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k-1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=${ck}$)
                    call stdlib_${ci}$copy( kk-1-kp, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    call stdlib_${ci}$lacgv( kk-1-kp, a( kp, kp+1 ), lda )
                    if( kp>1 )call stdlib_${ci}$copy( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    ! interchange rows kk and kp in last k+1 to n columns of a
                    ! (columns k (or k and k-1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in last kkw to nb columns of w.
                    if( k<n )call stdlib_${ci}$swap( n-k, a( kk, k+1 ), lda, a( kp, k+1 ),lda )
                    call stdlib_${ci}$swap( n-kk+1, w( kk, kkw ), ldw, w( kp, kkw ),ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column kw of w now holds
                    ! w(kw) = u(k)*d(k),
                    ! where u(k) is the k-th column of u
                    ! (1) store subdiag. elements of column u(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element u(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,kw)
                       ! a(1:k-1,k) := u(1:k-1,k) = w(1:k-1,kw)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=${ck}$) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_${ci}$copy( k, w( 1, kw ), 1, a( 1, k ), 1 )
                    if( k>1 ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(3))
                       ! handle division by a small number
                       t = real( a( k, k ),KIND=${ck}$)
                       if( abs( t )>=sfmin ) then
                          r1 = one / t
                          call stdlib_${ci}$dscal( k-1, r1, a( 1, k ), 1 )
                       else
                          do ii = 1, k-1
                             a( ii, k ) = a( ii, k ) / t
                          end do
                       end if
                       ! (2) conjugate column w(kw)
                       call stdlib_${ci}$lacgv( k-1, w( 1, kw ), 1 )
                       ! store the superdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns kw and kw-1 of w now hold
                    ! ( w(kw-1) w(kw) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! (1) store u(1:k-2,k-1) and u(1:k-2,k) and 2-by-2
                    ! block d(k-1:k,k-1:k) in columns k-1 and k of a.
                    ! (note: 2-by-2 diagonal block u(k-1:k,k-1:k) is a unit
                    ! block and not stored)
                       ! a(k-1:k,k-1:k) := d(k-1:k,k-1:k) = w(k-1:k,kw-1:kw)
                       ! a(1:k-2,k-1:k) := u(1:k-2,k:k-1:k) =
                       ! = w(1:k-2,kw-1:kw) * ( d(k-1:k,k-1:k)**(-1) )
                    if( k>2 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! handle division by a small number. (note: order of
                       ! operations is important)
                       ! = ( t*(( d11 )/conj(d21)) t*((  -1 )/d21 ) )
                         ! (   ((  -1 )          )   (( d22 )     ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0 in 2x2 pivot case(4),
                            ! since |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k-1, kw )
                       d11 = w( k, kw ) / conjg( d21 )
                       d22 = w( k-1, kw-1 ) / d21
                       t = one / ( real( d11*d22,KIND=${ck}$)-one )
                       ! update elements in columns a(k-1) and a(k) as
                       ! dot products of rows of ( w(kw-1) w(kw) ) and columns
                       ! of d**(-1)
                       do j = 1, k - 2
                          a( j, k-1 ) = t*( ( d11*w( j, kw-1 )-w( j, kw ) ) /d21 )
                          a( j, k ) = t*( ( d22*w( j, kw )-w( j, kw-1 ) ) /conjg( d21 ) )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy superdiagonal element of d(k) to e(k) and
                    ! zero out superdiagonal entry of a
                    a( k-1, k-1 ) = w( k-1, kw-1 )
                    a( k-1, k ) = czero
                    a( k, k ) = w( k, kw )
                    e( k ) = w( k-1, kw )
                    e( k-1 ) = czero
                    ! (2) conjugate columns w(kw) and w(kw-1)
                    call stdlib_${ci}$lacgv( k-1, w( 1, kw ), 1 )
                    call stdlib_${ci}$lacgv( k-2, w( 1, kw-1 ), 1 )
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
              30 continue
              ! update the upper triangle of a11 (= a(1:k,1:k)) as
              ! a11 := a11 - u12*d*u12**h = a11 - u12*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = ( ( k-1 ) / nb )*nb + 1, 1, -nb
                 jb = min( nb, k-j+1 )
                 ! update the upper triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=${ck}$)
                    call stdlib_${ci}$gemv( 'NO TRANSPOSE', jj-j+1, n-k, -cone,a( j, k+1 ), lda, w( jj,&
                               kw+1 ), ldw, cone,a( j, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=${ck}$)
                 end do
                 ! update the rectangular superdiagonal block
                 if( j>=2 )call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', j-1, jb, n-k,-cone, a( &
                           1, k+1 ), lda, w( j, kw+1 ), ldw,cone, a( 1, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = n - k
           else
              ! factorize the leading columns of a using the lower triangle
              ! of a and working forwards, and compute the matrix w = l21*d
              ! for use in updating a22 (note that conjg(w) is actually stored)
              ! initialize the unused last entry of the subdiagonal array e.
              e( n ) = czero
              ! k is the main loop index, increasing from 1 in steps of 1 or 2
              k = 1
              70 continue
              ! exit from loop
              if( ( k>=nb .and. nb<n ) .or. k>n )go to 90
              kstep = 1
              p = k
              ! copy column k of a to column k of w and update column k of w
              w( k, k ) = real( a( k, k ),KIND=${ck}$)
              if( k<n )call stdlib_${ci}$copy( n-k, a( k+1, k ), 1, w( k+1, k ), 1 )
              if( k>1 ) then
                 call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -cone, a( k, 1 ),lda, w( k, 1 ), &
                           ldw, cone, w( k, k ), 1 )
                 w( k, k ) = real( w( k, k ),KIND=${ck}$)
              end if
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( real( w( k, k ),KIND=${ck}$) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ci}$amax( n-k, w( k+1, k ), 1 )
                 colmax = cabs1( w( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero ) then
                 ! column k is zero or underflow: set info and continue
                 if( info==0 )info = k
                 kp = k
                 a( k, k ) = real( w( k, k ),KIND=${ck}$)
                 if( k<n )call stdlib_${ci}$copy( n-k, w( k+1, k ), 1, a( k+1, k ), 1 )
                 ! set e( k ) to zero
                 if( k<n )e( k ) = czero
              else
                 ! ============================================================
                 ! begin pivot search
                 ! case(1)
                 ! equivalent to testing for absakk>=alpha*colmax
                 ! (used to handle nan and inf)
                 if( .not.( absakk<alpha*colmax ) ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    done = .false.
                    ! loop until pivot found
                    72 continue
                       ! begin pivot search loop body
                       ! copy column imax to column k+1 of w and update it
                       call stdlib_${ci}$copy( imax-k, a( imax, k ), lda, w( k, k+1 ), 1)
                       call stdlib_${ci}$lacgv( imax-k, w( k, k+1 ), 1 )
                       w( imax, k+1 ) = real( a( imax, imax ),KIND=${ck}$)
                       if( imax<n )call stdlib_${ci}$copy( n-imax, a( imax+1, imax ), 1,w( imax+1, k+1 &
                                 ), 1 )
                       if( k>1 ) then
                          call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-k+1, k-1, -cone,a( k, 1 ), lda, w( &
                                    imax, 1 ), ldw,cone, w( k, k+1 ), 1 )
                          w( imax, k+1 ) = real( w( imax, k+1 ),KIND=${ck}$)
                       end if
                       ! jmax is the column-index of the largest off-diagonal
                       ! element in row imax, and rowmax is its absolute value.
                       ! determine both rowmax and jmax.
                       if( imax/=k ) then
                          jmax = k - 1 + stdlib_i${ci}$amax( imax-k, w( k, k+1 ), 1 )
                          rowmax = cabs1( w( jmax, k+1 ) )
                       else
                          rowmax = zero
                       end if
                       if( imax<n ) then
                          itemp = imax + stdlib_i${ci}$amax( n-imax, w( imax+1, k+1 ), 1)
                          dtemp = cabs1( w( itemp, k+1 ) )
                          if( dtemp>rowmax ) then
                             rowmax = dtemp
                             jmax = itemp
                          end if
                       end if
                       ! case(2)
                       ! equivalent to testing for
                       ! abs( real( w( imax,k+1 ),KIND=${ck}$) )>=alpha*rowmax
                       ! (used to handle nan and inf)
                       if( .not.( abs( real( w( imax,k+1 ),KIND=${ck}$) )<alpha*rowmax ) ) &
                                 then
                          ! interchange rows and columns k and imax,
                          ! use 1-by-1 pivot block
                          kp = imax
                          ! copy column k+1 of w to column k of w
                          call stdlib_${ci}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                          done = .true.
                       ! case(3)
                       ! equivalent to testing for rowmax==colmax,
                       ! (used to handle nan and inf)
                       else if( ( p==jmax ) .or. ( rowmax<=colmax ) )then
                          ! interchange rows and columns k+1 and imax,
                          ! use 2-by-2 pivot block
                          kp = imax
                          kstep = 2
                          done = .true.
                       ! case(4)
                       else
                          ! pivot not found: set params and repeat
                          p = imax
                          colmax = rowmax
                          imax = jmax
                          ! copy updated jmaxth (next imaxth) column to kth of w
                          call stdlib_${ci}$copy( n-k+1, w( k, k+1 ), 1, w( k, k ), 1 )
                       end if
                       ! end pivot search loop body
                    if( .not.done ) goto 72
                 end if
                 ! end pivot search
                 ! ============================================================
                 ! kk is the column of a where pivoting step stopped
                 kk = k + kstep - 1
                 ! interchange rows and columns p and k (only for 2-by-2 pivot).
                 ! updated column p is already stored in column k of w.
                 if( ( kstep==2 ) .and. ( p/=k ) ) then
                    ! copy non-updated column kk-1 to column p of submatrix a
                    ! at step k. no need to copy element into columns
                    ! k and k+1 of a for 2-by-2 pivot, since these columns
                    ! will be later overwritten.
                    a( p, p ) = real( a( k, k ),KIND=${ck}$)
                    call stdlib_${ci}$copy( p-k-1, a( k+1, k ), 1, a( p, k+1 ), lda )
                    call stdlib_${ci}$lacgv( p-k-1, a( p, k+1 ), lda )
                    if( p<n )call stdlib_${ci}$copy( n-p, a( p+1, k ), 1, a( p+1, p ), 1 )
                    ! interchange rows k and p in first k-1 columns of a
                    ! (columns k and k+1 of a for 2-by-2 pivot will be
                    ! later overwritten). interchange rows k and p
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_${ci}$swap( k-1, a( k, 1 ), lda, a( p, 1 ), lda )
                    call stdlib_${ci}$swap( kk, w( k, 1 ), ldw, w( p, 1 ), ldw )
                 end if
                 ! interchange rows and columns kp and kk.
                 ! updated column kp is already stored in column kk of w.
                 if( kp/=kk ) then
                    ! copy non-updated column kk to column kp of submatrix a
                    ! at step k. no need to copy element into column k
                    ! (or k and k+1 for 2-by-2 pivot) of a, since these columns
                    ! will be later overwritten.
                    a( kp, kp ) = real( a( kk, kk ),KIND=${ck}$)
                    call stdlib_${ci}$copy( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    call stdlib_${ci}$lacgv( kp-kk-1, a( kp, kk+1 ), lda )
                    if( kp<n )call stdlib_${ci}$copy( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    ! interchange rows kk and kp in first k-1 columns of a
                    ! (column k (or k and k+1 for 2-by-2 pivot) of a will be
                    ! later overwritten). interchange rows kk and kp
                    ! in first kk columns of w.
                    if( k>1 )call stdlib_${ci}$swap( k-1, a( kk, 1 ), lda, a( kp, 1 ), lda )
                    call stdlib_${ci}$swap( kk, w( kk, 1 ), ldw, w( kp, 1 ), ldw )
                 end if
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k of w now holds
                    ! w(k) = l(k)*d(k),
                    ! where l(k) is the k-th column of l
                    ! (1) store subdiag. elements of column l(k)
                    ! and 1-by-1 block d(k) in column k of a.
                    ! (note: diagonal element l(k,k) is a unit element
                    ! and not stored)
                       ! a(k,k) := d(k,k) = w(k,k)
                       ! a(k+1:n,k) := l(k+1:n,k) = w(k+1:n,k)/d(k,k)
                    ! (note: no need to use for hermitian matrix
                    ! a( k, k ) = real( w( k, k),KIND=${ck}$) to separately copy diagonal
                    ! element d(k,k) from w (potentially saves only one load))
                    call stdlib_${ci}$copy( n-k+1, w( k, k ), 1, a( k, k ), 1 )
                    if( k<n ) then
                       ! (note: no need to check if a(k,k) is not zero,
                        ! since that was ensured earlier in pivot search:
                        ! case a(k,k) = 0 falls into 2x2 pivot case(3))
                       ! handle division by a small number
                       t = real( a( k, k ),KIND=${ck}$)
                       if( abs( t )>=sfmin ) then
                          r1 = one / t
                          call stdlib_${ci}$dscal( n-k, r1, a( k+1, k ), 1 )
                       else
                          do ii = k + 1, n
                             a( ii, k ) = a( ii, k ) / t
                          end do
                       end if
                       ! (2) conjugate column w(k)
                       call stdlib_${ci}$lacgv( n-k, w( k+1, k ), 1 )
                       ! store the subdiagonal element of d in array e
                       e( k ) = czero
                    end if
                 else
                    ! 2-by-2 pivot block d(k): columns k and k+1 of w now hold
                    ! ( w(k) w(k+1) ) = ( l(k) l(k+1) )*d(k)
                    ! where l(k) and l(k+1) are the k-th and (k+1)-th columns
                    ! of l
                    ! (1) store l(k+2:n,k) and l(k+2:n,k+1) and 2-by-2
                    ! block d(k:k+1,k:k+1) in columns k and k+1 of a.
                    ! note: 2-by-2 diagonal block l(k:k+1,k:k+1) is a unit
                    ! block and not stored.
                       ! a(k:k+1,k:k+1) := d(k:k+1,k:k+1) = w(k:k+1,k:k+1)
                       ! a(k+2:n,k:k+1) := l(k+2:n,k:k+1) =
                       ! = w(k+2:n,k:k+1) * ( d(k:k+1,k:k+1)**(-1) )
                    if( k<n-1 ) then
                       ! factor out the columns of the inverse of 2-by-2 pivot
                       ! block d, so that each column contains 1, to reduce the
                       ! number of flops when we multiply panel
                       ! ( w(kw-1) w(kw) ) by this inverse, i.e. by d**(-1).
                       ! d**(-1) = ( d11 cj(d21) )**(-1) =
                                 ! ( d21    d22 )
                       ! = 1/(d11*d22-|d21|**2) * ( ( d22) (-cj(d21) ) ) =
                                                ! ( (-d21) (     d11 ) )
                       ! = 1/(|d21|**2) * 1/((d11/cj(d21))*(d22/d21)-1) *
                         ! * ( d21*( d22/d21 ) conj(d21)*(           - 1 ) ) =
                           ! (     (      -1 )           ( d11/conj(d21) ) )
                       ! = 1/(|d21|**2) * 1/(d22*d11-1) *
                         ! * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                           ! (     (  -1 )           ( d22 ) )
                       ! = (1/|d21|**2) * t * ( d21*( d11 ) conj(d21)*(  -1 ) ) =
                                            ! (     (  -1 )           ( d22 ) )
                       ! = ( (t/conj(d21))*( d11 ) (t/d21)*(  -1 ) ) =
                         ! (               (  -1 )         ( d22 ) )
                       ! handle division by a small number. (note: order of
                       ! operations is important)
                       ! = ( t*(( d11 )/conj(d21)) t*((  -1 )/d21 ) )
                         ! (   ((  -1 )          )   (( d22 )     ) ),
                       ! where d11 = d22/d21,
                             ! d22 = d11/conj(d21),
                             ! d21 = d21,
                             ! t = 1/(d22*d11-1).
                       ! (note: no need to check for division by zero,
                        ! since that was ensured earlier in pivot search:
                        ! (a) d21 != 0 in 2x2 pivot case(4),
                            ! since |d21| should be larger than |d11| and |d22|;
                        ! (b) (d22*d11 - 1) != 0, since from (a),
                            ! both |d11| < 1, |d22| < 1, hence |d22*d11| << 1.)
                       d21 = w( k+1, k )
                       d11 = w( k+1, k+1 ) / d21
                       d22 = w( k, k ) / conjg( d21 )
                       t = one / ( real( d11*d22,KIND=${ck}$)-one )
                       ! update elements in columns a(k) and a(k+1) as
                       ! dot products of rows of ( w(k) w(k+1) ) and columns
                       ! of d**(-1)
                       do j = k + 2, n
                          a( j, k ) = t*( ( d11*w( j, k )-w( j, k+1 ) ) /conjg( d21 ) )
                          a( j, k+1 ) = t*( ( d22*w( j, k+1 )-w( j, k ) ) /d21 )
                       end do
                    end if
                    ! copy diagonal elements of d(k) to a,
                    ! copy subdiagonal element of d(k) to e(k) and
                    ! zero out subdiagonal entry of a
                    a( k, k ) = w( k, k )
                    a( k+1, k ) = czero
                    a( k+1, k+1 ) = w( k+1, k+1 )
                    e( k ) = w( k+1, k )
                    e( k+1 ) = czero
                    ! (2) conjugate columns w(k) and w(k+1)
                    call stdlib_${ci}$lacgv( n-k, w( k+1, k ), 1 )
                    call stdlib_${ci}$lacgv( n-k-1, w( k+2, k+1 ), 1 )
                 end if
                 ! end column k is nonsingular
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -p
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 70
              90 continue
              ! update the lower triangle of a22 (= a(k:n,k:n)) as
              ! a22 := a22 - l21*d*l21**h = a22 - l21*w**h
              ! computing blocks of nb columns at a time (note that conjg(w) is
              ! actually stored)
              do j = k, n, nb
                 jb = min( nb, n-j+1 )
                 ! update the lower triangle of the diagonal block
                 do jj = j, j + jb - 1
                    a( jj, jj ) = real( a( jj, jj ),KIND=${ck}$)
                    call stdlib_${ci}$gemv( 'NO TRANSPOSE', j+jb-jj, k-1, -cone,a( jj, 1 ), lda, w( jj,&
                               1 ), ldw, cone,a( jj, jj ), 1 )
                    a( jj, jj ) = real( a( jj, jj ),KIND=${ck}$)
                 end do
                 ! update the rectangular subdiagonal block
                 if( j+jb<=n )call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'TRANSPOSE', n-j-jb+1, jb,k-1, -&
                           cone, a( j+jb, 1 ), lda, w( j, 1 ),ldw, cone, a( j+jb, j ), lda )
              end do
              ! set kb to the number of columns factorized
              kb = k - 1
           end if
           return
     end subroutine stdlib_${ci}$lahef_rk

#:endif
#:endfor



     module pure subroutine stdlib_chprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, work,&
     !! CHPRFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is Hermitian indefinite
     !! and packed, and provides error bounds and backward error estimates
     !! for the solution.
                rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: afp(*), ap(*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, ik, j, k, kase, kk, nz
           real(sp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(sp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=sp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( ldx<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_slamch( 'EPSILON' )
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_ccopy( n, b( 1, j ), 1, work, 1 )
              call stdlib_chpmv( uplo, n, -cone, ap, x( 1, j ), 1, cone, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              kk = 1
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    ik = kk
                    do i = 1, k - 1
                       rwork( i ) = rwork( i ) + cabs1( ap( ik ) )*xk
                       s = s + cabs1( ap( ik ) )*cabs1( x( i, j ) )
                       ik = ik + 1
                    end do
                    rwork( k ) = rwork( k ) + abs( real( ap( kk+k-1 ),KIND=sp) )*xk + s
                    kk = kk + k
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + abs( real( ap( kk ),KIND=sp) )*xk
                    ik = kk + 1
                    do i = k + 1, n
                       rwork( i ) = rwork( i ) + cabs1( ap( ik ) )*xk
                       s = s + cabs1( ap( ik ) )*cabs1( x( i, j ) )
                       ik = ik + 1
                    end do
                    rwork( k ) = rwork( k ) + s
                    kk = kk + ( n-k+1 )
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_chptrs( uplo, n, 1, afp, ipiv, work, n, info )
                 call stdlib_caxpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_clacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_clacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**h).
                    call stdlib_chptrs( uplo, n, 1, afp, ipiv, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_chptrs( uplo, n, 1, afp, ipiv, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_chprfs

     module pure subroutine stdlib_zhprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, work,&
     !! ZHPRFS improves the computed solution to a system of linear
     !! equations when the coefficient matrix is Hermitian indefinite
     !! and packed, and provides error bounds and backward error estimates
     !! for the solution.
                rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(dp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(dp), intent(in) :: afp(*), ap(*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
           complex(dp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, ik, j, k, kase, kk, nz
           real(dp) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(dp) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=dp) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( ldx<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHPRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_dlamch( 'EPSILON' )
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_zcopy( n, b( 1, j ), 1, work, 1 )
              call stdlib_zhpmv( uplo, n, -cone, ap, x( 1, j ), 1, cone, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              kk = 1
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    ik = kk
                    do i = 1, k - 1
                       rwork( i ) = rwork( i ) + cabs1( ap( ik ) )*xk
                       s = s + cabs1( ap( ik ) )*cabs1( x( i, j ) )
                       ik = ik + 1
                    end do
                    rwork( k ) = rwork( k ) + abs( real( ap( kk+k-1 ),KIND=dp) )*xk + s
                    kk = kk + k
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + abs( real( ap( kk ),KIND=dp) )*xk
                    ik = kk + 1
                    do i = k + 1, n
                       rwork( i ) = rwork( i ) + cabs1( ap( ik ) )*xk
                       s = s + cabs1( ap( ik ) )*cabs1( x( i, j ) )
                       ik = ik + 1
                    end do
                    rwork( k ) = rwork( k ) + s
                    kk = kk + ( n-k+1 )
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_zhptrs( uplo, n, 1, afp, ipiv, work, n, info )
                 call stdlib_zaxpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_zlacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_zlacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**h).
                    call stdlib_zhptrs( uplo, n, 1, afp, ipiv, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_zhptrs( uplo, n, 1, afp, ipiv, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_zhprfs

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx,ferr, berr, work,&
     !! ZHPRFS: improves the computed solution to a system of linear
     !! equations when the coefficient matrix is Hermitian indefinite
     !! and packed, and provides error bounds and backward error estimates
     !! for the solution.
                rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${ck}$), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(${ck}$), intent(in) :: afp(*), ap(*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: itmax = 5
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: count, i, ik, j, k, kase, kk, nz
           real(${ck}$) :: eps, lstres, s, safe1, safe2, safmin, xk
           complex(${ck}$) :: zdum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( zdum ) = abs( real( zdum,KIND=${ck}$) ) + abs( aimag( zdum ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( ldx<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHPRFS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 ) then
              do j = 1, nrhs
                 ferr( j ) = zero
                 berr( j ) = zero
              end do
              return
           end if
           ! nz = maximum number of nonzero elements in each row of a, plus 1
           nz = n + 1
           eps = stdlib_${c2ri(ci)}$lamch( 'EPSILON' )
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           safe1 = nz*safmin
           safe2 = safe1 / eps
           ! do for each right hand side
           loop_140: do j = 1, nrhs
              count = 1
              lstres = three
              20 continue
              ! loop until stopping criterion is satisfied.
              ! compute residual r = b - a * x
              call stdlib_${ci}$copy( n, b( 1, j ), 1, work, 1 )
              call stdlib_${ci}$hpmv( uplo, n, -cone, ap, x( 1, j ), 1, cone, work, 1 )
              ! compute componentwise relative backward error from formula
              ! max(i) ( abs(r(i)) / ( abs(a)*abs(x) + abs(b) )(i) )
              ! where abs(z) is the componentwise absolute value of the matrix
              ! or vector z.  if the i-th component of the denominator is less
              ! than safe2, then safe1 is added to the i-th components of the
              ! numerator and denominator before dividing.
              do i = 1, n
                 rwork( i ) = cabs1( b( i, j ) )
              end do
              ! compute abs(a)*abs(x) + abs(b).
              kk = 1
              if( upper ) then
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    ik = kk
                    do i = 1, k - 1
                       rwork( i ) = rwork( i ) + cabs1( ap( ik ) )*xk
                       s = s + cabs1( ap( ik ) )*cabs1( x( i, j ) )
                       ik = ik + 1
                    end do
                    rwork( k ) = rwork( k ) + abs( real( ap( kk+k-1 ),KIND=${ck}$) )*xk + s
                    kk = kk + k
                 end do
              else
                 do k = 1, n
                    s = zero
                    xk = cabs1( x( k, j ) )
                    rwork( k ) = rwork( k ) + abs( real( ap( kk ),KIND=${ck}$) )*xk
                    ik = kk + 1
                    do i = k + 1, n
                       rwork( i ) = rwork( i ) + cabs1( ap( ik ) )*xk
                       s = s + cabs1( ap( ik ) )*cabs1( x( i, j ) )
                       ik = ik + 1
                    end do
                    rwork( k ) = rwork( k ) + s
                    kk = kk + ( n-k+1 )
                 end do
              end if
              s = zero
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    s = max( s, cabs1( work( i ) ) / rwork( i ) )
                 else
                    s = max( s, ( cabs1( work( i ) )+safe1 ) /( rwork( i )+safe1 ) )
                 end if
              end do
              berr( j ) = s
              ! test stopping criterion. continue iterating if
                 ! 1) the residual berr(j) is larger than machine epsilon, and
                 ! 2) berr(j) decreased by at least a factor of 2 during the
                    ! last iteration, and
                 ! 3) at most itmax iterations tried.
              if( berr( j )>eps .and. two*berr( j )<=lstres .and.count<=itmax ) then
                 ! update solution and try again.
                 call stdlib_${ci}$hptrs( uplo, n, 1, afp, ipiv, work, n, info )
                 call stdlib_${ci}$axpy( n, cone, work, 1, x( 1, j ), 1 )
                 lstres = berr( j )
                 count = count + 1
                 go to 20
              end if
              ! bound error from formula
              ! norm(x - xtrue) / norm(x) .le. ferr =
              ! norm( abs(inv(a))*
                 ! ( abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) ))) / norm(x)
              ! where
                ! norm(z) is the magnitude of the largest component of z
                ! inv(a) is the inverse of a
                ! abs(z) is the componentwise absolute value of the matrix or
                   ! vector z
                ! nz is the maximum number of nonzeros in any row of a, plus 1
                ! eps is machine epsilon
              ! the i-th component of abs(r)+nz*eps*(abs(a)*abs(x)+abs(b))
              ! is incremented by safe1 if the i-th component of
              ! abs(a)*abs(x) + abs(b) is less than safe2.
              ! use stdlib_${ci}$lacn2 to estimate the infinity-norm of the matrix
                 ! inv(a) * diag(w),
              ! where w = abs(r) + nz*eps*( abs(a)*abs(x)+abs(b) )))
              do i = 1, n
                 if( rwork( i )>safe2 ) then
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i )
                 else
                    rwork( i ) = cabs1( work( i ) ) + nz*eps*rwork( i ) +safe1
                 end if
              end do
              kase = 0
              100 continue
              call stdlib_${ci}$lacn2( n, work( n+1 ), work, ferr( j ), kase, isave )
              if( kase/=0 ) then
                 if( kase==1 ) then
                    ! multiply by diag(w)*inv(a**h).
                    call stdlib_${ci}$hptrs( uplo, n, 1, afp, ipiv, work, n, info )
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                 else if( kase==2 ) then
                    ! multiply by inv(a)*diag(w).
                    do i = 1, n
                       work( i ) = rwork( i )*work( i )
                    end do
                    call stdlib_${ci}$hptrs( uplo, n, 1, afp, ipiv, work, n, info )
                 end if
                 go to 100
              end if
              ! normalize error.
              lstres = zero
              do i = 1, n
                 lstres = max( lstres, cabs1( x( i, j ) ) )
              end do
              if( lstres/=zero )ferr( j ) = ferr( j ) / lstres
           end do loop_140
           return
     end subroutine stdlib_${ci}$hprfs

#:endif
#:endfor



     module pure subroutine stdlib_slaqsy( uplo, n, a, lda, s, scond, amax, equed )
     !! SLAQSY equilibrates a symmetric matrix A using the scaling factors
     !! in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(in) :: amax, scond
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(in) :: s(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: thresh = 0.1e+0_sp
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: cj, large, small
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_slamch( 'SAFE MINIMUM' ) / stdlib_slamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = 1, j
                       a( i, j ) = cj*s( i )*a( i, j )
                    end do
                 end do
              else
                 ! lower triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = j, n
                       a( i, j ) = cj*s( i )*a( i, j )
                    end do
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_slaqsy

     module pure subroutine stdlib_dlaqsy( uplo, n, a, lda, s, scond, amax, equed )
     !! DLAQSY equilibrates a symmetric matrix A using the scaling factors
     !! in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, n
           real(dp), intent(in) :: amax, scond
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(in) :: s(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: thresh = 0.1e+0_dp
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(dp) :: cj, large, small
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_dlamch( 'SAFE MINIMUM' ) / stdlib_dlamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = 1, j
                       a( i, j ) = cj*s( i )*a( i, j )
                    end do
                 end do
              else
                 ! lower triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = j, n
                       a( i, j ) = cj*s( i )*a( i, j )
                    end do
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_dlaqsy

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$laqsy( uplo, n, a, lda, s, scond, amax, equed )
     !! DLAQSY: equilibrates a symmetric matrix A using the scaling factors
     !! in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, n
           real(${rk}$), intent(in) :: amax, scond
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: s(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: thresh = 0.1e+0_${rk}$
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: cj, large, small
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_${ri}$lamch( 'SAFE MINIMUM' ) / stdlib_${ri}$lamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = 1, j
                       a( i, j ) = cj*s( i )*a( i, j )
                    end do
                 end do
              else
                 ! lower triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = j, n
                       a( i, j ) = cj*s( i )*a( i, j )
                    end do
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_${ri}$laqsy

#:endif
#:endfor

     module pure subroutine stdlib_claqsy( uplo, n, a, lda, s, scond, amax, equed )
     !! CLAQSY equilibrates a symmetric matrix A using the scaling factors
     !! in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, n
           real(sp), intent(in) :: amax, scond
           ! Array Arguments 
           real(sp), intent(in) :: s(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: thresh = 0.1e+0_sp
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: cj, large, small
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_slamch( 'SAFE MINIMUM' ) / stdlib_slamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = 1, j
                       a( i, j ) = cj*s( i )*a( i, j )
                    end do
                 end do
              else
                 ! lower triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = j, n
                       a( i, j ) = cj*s( i )*a( i, j )
                    end do
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_claqsy

     module pure subroutine stdlib_zlaqsy( uplo, n, a, lda, s, scond, amax, equed )
     !! ZLAQSY equilibrates a symmetric matrix A using the scaling factors
     !! in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, n
           real(dp), intent(in) :: amax, scond
           ! Array Arguments 
           real(dp), intent(in) :: s(*)
           complex(dp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: thresh = 0.1e+0_dp
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(dp) :: cj, large, small
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_dlamch( 'SAFE MINIMUM' ) / stdlib_dlamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = 1, j
                       a( i, j ) = cj*s( i )*a( i, j )
                    end do
                 end do
              else
                 ! lower triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = j, n
                       a( i, j ) = cj*s( i )*a( i, j )
                    end do
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_zlaqsy

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$laqsy( uplo, n, a, lda, s, scond, amax, equed )
     !! ZLAQSY: equilibrates a symmetric matrix A using the scaling factors
     !! in the vector S.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(out) :: equed
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, n
           real(${ck}$), intent(in) :: amax, scond
           ! Array Arguments 
           real(${ck}$), intent(in) :: s(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: thresh = 0.1e+0_${ck}$
           
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${ck}$) :: cj, large, small
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              equed = 'N'
              return
           end if
           ! initialize large and small.
           small = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' ) / stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           large = one / small
           if( scond>=thresh .and. amax>=small .and. amax<=large ) then
              ! no equilibration
              equed = 'N'
           else
              ! replace a by diag(s) * a * diag(s).
              if( stdlib_lsame( uplo, 'U' ) ) then
                 ! upper triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = 1, j
                       a( i, j ) = cj*s( i )*a( i, j )
                    end do
                 end do
              else
                 ! lower triangle of a is stored.
                 do j = 1, n
                    cj = s( j )
                    do i = j, n
                       a( i, j ) = cj*s( i )*a( i, j )
                    end do
                 end do
              end if
              equed = 'Y'
           end if
           return
     end subroutine stdlib_${ci}$laqsy

#:endif
#:endfor



     module pure subroutine stdlib_ssytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
     !! SSYTRS solves a system of linear equations A*X = B with a real
     !! symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by SSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(in) :: a(lda,*)
           real(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           real(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_sger( k-1, nrhs, -one, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_sscal( nrhs, one / a( k, k ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_sswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_sger( k-2, nrhs, -one, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 call stdlib_sger( k-2, nrhs, -one, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ), &
                           ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_sgemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb, a( 1, k ),1, one, b( k, &
                           1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 call stdlib_sgemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb, a( 1, k ),1, one, b( k, &
                           1 ), ldb )
                 call stdlib_sgemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb,a( 1, k+1 ), 1, one, b( &
                           k+1, 1 ), ldb )
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_sger( n-k, nrhs, -one, a( k+1, k ), 1, b( k, 1 ),ldb, b( k+&
                           1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_sscal( nrhs, one / a( k, k ), b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_sswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_sger( n-k-1, nrhs, -one, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, 1 &
                              ), ldb )
                    call stdlib_sger( n-k-1, nrhs, -one, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( k+&
                              2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / akm1k
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_sgemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+&
                           1, k ), 1, one, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_sgemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+1, k ),&
                               1, one, b( k, 1 ), ldb )
                    call stdlib_sgemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+1, k-1 &
                              ), 1, one, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_ssytrs

     module pure subroutine stdlib_dsytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
     !! DSYTRS solves a system of linear equations A*X = B with a real
     !! symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by DSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(dp), intent(in) :: a(lda,*)
           real(dp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           real(dp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_dger( k-1, nrhs, -one, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_dscal( nrhs, one / a( k, k ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_dswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_dger( k-2, nrhs, -one, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 call stdlib_dger( k-2, nrhs, -one, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ), &
                           ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_dgemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb, a( 1, k ),1, one, b( k, &
                           1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 call stdlib_dgemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb, a( 1, k ),1, one, b( k, &
                           1 ), ldb )
                 call stdlib_dgemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb,a( 1, k+1 ), 1, one, b( &
                           k+1, 1 ), ldb )
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_dger( n-k, nrhs, -one, a( k+1, k ), 1, b( k, 1 ),ldb, b( k+&
                           1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_dscal( nrhs, one / a( k, k ), b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_dswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_dger( n-k-1, nrhs, -one, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, 1 &
                              ), ldb )
                    call stdlib_dger( n-k-1, nrhs, -one, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( k+&
                              2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / akm1k
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_dgemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+&
                           1, k ), 1, one, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_dgemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+1, k ),&
                               1, one, b( k, 1 ), ldb )
                    call stdlib_dgemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+1, k-1 &
                              ), 1, one, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_dsytrs

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
     !! DSYTRS: solves a system of linear equations A*X = B with a real
     !! symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by DSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(in) :: a(lda,*)
           real(${rk}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           real(${rk}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_${ri}$ger( k-1, nrhs, -one, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_${ri}$scal( nrhs, one / a( k, k ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_${ri}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_${ri}$ger( k-2, nrhs, -one, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb )
                           
                 call stdlib_${ri}$ger( k-2, nrhs, -one, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ), &
                           ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_${ri}$gemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb, a( 1, k ),1, one, b( k, &
                           1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 call stdlib_${ri}$gemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb, a( 1, k ),1, one, b( k, &
                           1 ), ldb )
                 call stdlib_${ri}$gemv( 'TRANSPOSE', k-1, nrhs, -one, b, ldb,a( 1, k+1 ), 1, one, b( &
                           k+1, 1 ), ldb )
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ri}$ger( n-k, nrhs, -one, a( k+1, k ), 1, b( k, 1 ),ldb, b( k+&
                           1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_${ri}$scal( nrhs, one / a( k, k ), b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_${ri}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_${ri}$ger( n-k-1, nrhs, -one, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, 1 &
                              ), ldb )
                    call stdlib_${ri}$ger( n-k-1, nrhs, -one, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( k+&
                              2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / akm1k
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - one
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ri}$gemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+&
                           1, k ), 1, one, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+1, k ),&
                               1, one, b( k, 1 ), ldb )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-k, nrhs, -one, b( k+1, 1 ),ldb, a( k+1, k-1 &
                              ), 1, one, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_${ri}$sytrs

#:endif
#:endfor

     module pure subroutine stdlib_csytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
     !! CSYTRS solves a system of linear equations A*X = B with a complex
     !! symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by CSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_cgeru( k-1, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_cscal( nrhs, cone / a( k, k ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_cgeru( k-2, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 call stdlib_cgeru( k-2, nrhs, -cone, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ), &
                           ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_cgemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb, a( 1, k ),1, cone, b( &
                           k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 call stdlib_cgemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb, a( 1, k ),1, cone, b( &
                           k, 1 ), ldb )
                 call stdlib_cgemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb,a( 1, k+1 ), 1, cone, b(&
                            k+1, 1 ), ldb )
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_cgeru( n-k, nrhs, -cone, a( k+1, k ), 1, b( k, 1 ),ldb, b( &
                           k+1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_cscal( nrhs, cone / a( k, k ), b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_cgeru( n-k-1, nrhs, -cone, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_cgeru( n-k-1, nrhs, -cone, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / akm1k
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_cgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+&
                           1, k ), 1, cone, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_cgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+1, k )&
                              , 1, cone, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+1, k-&
                              1 ), 1, cone, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_csytrs

     module pure subroutine stdlib_zsytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
     !! ZSYTRS solves a system of linear equations A*X = B with a complex
     !! symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by ZSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           complex(dp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_zgeru( k-1, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_zscal( nrhs, cone / a( k, k ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_zswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_zgeru( k-2, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 call stdlib_zgeru( k-2, nrhs, -cone, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ), &
                           ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_zgemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb, a( 1, k ),1, cone, b( &
                           k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 call stdlib_zgemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb, a( 1, k ),1, cone, b( &
                           k, 1 ), ldb )
                 call stdlib_zgemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb,a( 1, k+1 ), 1, cone, b(&
                            k+1, 1 ), ldb )
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_zgeru( n-k, nrhs, -cone, a( k+1, k ), 1, b( k, 1 ),ldb, b( &
                           k+1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_zscal( nrhs, cone / a( k, k ), b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_zswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_zgeru( n-k-1, nrhs, -cone, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_zgeru( n-k-1, nrhs, -cone, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / akm1k
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_zgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+&
                           1, k ), 1, cone, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_zgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+1, k )&
                              , 1, cone, b( k, 1 ), ldb )
                    call stdlib_zgemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+1, k-&
                              1 ), 1, cone, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_zsytrs

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
     !! ZSYTRS: solves a system of linear equations A*X = B with a complex
     !! symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by ZSYTRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           complex(${ck}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_${ci}$geru( k-1, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_${ci}$scal( nrhs, cone / a( k, k ), b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_${ci}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_${ci}$geru( k-2, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 call stdlib_${ci}$geru( k-2, nrhs, -cone, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ), &
                           ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / akm1k
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**t *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**t(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_${ci}$gemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb, a( 1, k ),1, cone, b( &
                           k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**t(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 call stdlib_${ci}$gemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb, a( 1, k ),1, cone, b( &
                           k, 1 ), ldb )
                 call stdlib_${ci}$gemv( 'TRANSPOSE', k-1, nrhs, -cone, b, ldb,a( 1, k+1 ), 1, cone, b(&
                            k+1, 1 ), ldb )
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**t.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ci}$geru( n-k, nrhs, -cone, a( k+1, k ), 1, b( k, 1 ),ldb, b( &
                           k+1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 call stdlib_${ci}$scal( nrhs, cone / a( k, k ), b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_${ci}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_${ci}$geru( n-k-1, nrhs, -cone, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_${ci}$geru( n-k-1, nrhs, -cone, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / akm1k
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / akm1k
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**t *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**t(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ci}$gemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+&
                           1, k ), 1, cone, b( k, 1 ), ldb )
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**t(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_${ci}$gemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+1, k )&
                              , 1, cone, b( k, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'TRANSPOSE', n-k, nrhs, -cone, b( k+1, 1 ),ldb, a( k+1, k-&
                              1 ), 1, cone, b( k-1, 1 ),ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_${ci}$sytrs

#:endif
#:endfor



     module pure subroutine stdlib_ssytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
     !! SSYTRS2 solves a system of linear equations A*X = B with a real
     !! symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by SSYTRF and converted by SSYCONV.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, j, k, kp
           real(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYTRS2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           ! convert a
           call stdlib_ssyconv( uplo, 'C', n, a, lda, ipiv, work, iinfo )
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
             ! p**t * b
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp==-ipiv( k-1 ) )call stdlib_sswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb &
                           )
                 k=k-2
              end if
             end do
        ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
             call stdlib_strsm('L','U','N','U',n,nrhs,one,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i=n
              do while ( i >= 1 )
                 if( ipiv(i) > 0 ) then
                   call stdlib_sscal( nrhs, one / a( i, i ), b( i, 1 ), ldb )
                 elseif ( i > 1) then
                    if ( ipiv(i-1) == ipiv(i) ) then
                       akm1k = work(i)
                       akm1 = a( i-1, i-1 ) / akm1k
                       ak = a( i, i ) / akm1k
                       denom = akm1*ak - one
                       do j = 1, nrhs
                          bkm1 = b( i-1, j ) / akm1k
                          bk = b( i, j ) / akm1k
                          b( i-1, j ) = ( ak*bkm1-bk ) / denom
                          b( i, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                    i = i - 1
                    endif
                 endif
                 i = i - 1
              end do
            ! compute (u**t \ b) -> b   [ u**t \ (d \ (u \p**t * b) ) ]
              call stdlib_strsm('L','U','T','U',n,nrhs,one,a,lda,b,ldb)
             ! p * b  [ p * (u**t \ (d \ (u \p**t * b) )) ]
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k < n .and. kp==-ipiv( k+1 ) )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp,&
                            1 ), ldb )
                 k=k+2
              endif
             end do
           else
              ! solve a*x = b, where a = l*d*l**t.
             ! p**t * b
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k+1).
                 kp = -ipiv( k+1 )
                 if( kp==-ipiv( k ) )call stdlib_sswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                           
                 k=k+2
              endif
             end do
        ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
             call stdlib_strsm('L','L','N','U',n,nrhs,one,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i=1
              do while ( i <= n )
                 if( ipiv(i) > 0 ) then
                   call stdlib_sscal( nrhs, one / a( i, i ), b( i, 1 ), ldb )
                 else
                       akm1k = work(i)
                       akm1 = a( i, i ) / akm1k
                       ak = a( i+1, i+1 ) / akm1k
                       denom = akm1*ak - one
                       do j = 1, nrhs
                          bkm1 = b( i, j ) / akm1k
                          bk = b( i+1, j ) / akm1k
                          b( i, j ) = ( ak*bkm1-bk ) / denom
                          b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                       i = i + 1
                 endif
                 i = i + 1
              end do
        ! compute (l**t \ b) -> b   [ l**t \ (d \ (l \p**t * b) ) ]
             call stdlib_strsm('L','L','T','U',n,nrhs,one,a,lda,b,ldb)
             ! p * b  [ p * (l**t \ (d \ (l \p**t * b) )) ]
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k>1 .and. kp==-ipiv( k-1 ) )call stdlib_sswap( nrhs, b( k, 1 ), ldb, b( kp, &
                           1 ), ldb )
                 k=k-2
              endif
             end do
           end if
           ! revert a
           call stdlib_ssyconv( uplo, 'R', n, a, lda, ipiv, work, iinfo )
           return
     end subroutine stdlib_ssytrs2

     module pure subroutine stdlib_dsytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
     !! DSYTRS2 solves a system of linear equations A*X = B with a real
     !! symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by DSYTRF and converted by DSYCONV.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, j, k, kp
           real(dp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRS2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           ! convert a
           call stdlib_dsyconv( uplo, 'C', n, a, lda, ipiv, work, iinfo )
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
             ! p**t * b
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp==-ipiv( k-1 ) )call stdlib_dswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb &
                           )
                 k=k-2
              end if
             end do
        ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
             call stdlib_dtrsm('L','U','N','U',n,nrhs,one,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i=n
              do while ( i >= 1 )
                 if( ipiv(i) > 0 ) then
                   call stdlib_dscal( nrhs, one / a( i, i ), b( i, 1 ), ldb )
                 elseif ( i > 1) then
                    if ( ipiv(i-1) == ipiv(i) ) then
                       akm1k = work(i)
                       akm1 = a( i-1, i-1 ) / akm1k
                       ak = a( i, i ) / akm1k
                       denom = akm1*ak - one
                       do j = 1, nrhs
                          bkm1 = b( i-1, j ) / akm1k
                          bk = b( i, j ) / akm1k
                          b( i-1, j ) = ( ak*bkm1-bk ) / denom
                          b( i, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                    i = i - 1
                    endif
                 endif
                 i = i - 1
              end do
            ! compute (u**t \ b) -> b   [ u**t \ (d \ (u \p**t * b) ) ]
              call stdlib_dtrsm('L','U','T','U',n,nrhs,one,a,lda,b,ldb)
             ! p * b  [ p * (u**t \ (d \ (u \p**t * b) )) ]
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k < n .and. kp==-ipiv( k+1 ) )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp,&
                            1 ), ldb )
                 k=k+2
              endif
             end do
           else
              ! solve a*x = b, where a = l*d*l**t.
             ! p**t * b
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k+1).
                 kp = -ipiv( k+1 )
                 if( kp==-ipiv( k ) )call stdlib_dswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                           
                 k=k+2
              endif
             end do
        ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
             call stdlib_dtrsm('L','L','N','U',n,nrhs,one,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i=1
              do while ( i <= n )
                 if( ipiv(i) > 0 ) then
                   call stdlib_dscal( nrhs, one / a( i, i ), b( i, 1 ), ldb )
                 else
                       akm1k = work(i)
                       akm1 = a( i, i ) / akm1k
                       ak = a( i+1, i+1 ) / akm1k
                       denom = akm1*ak - one
                       do j = 1, nrhs
                          bkm1 = b( i, j ) / akm1k
                          bk = b( i+1, j ) / akm1k
                          b( i, j ) = ( ak*bkm1-bk ) / denom
                          b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                       i = i + 1
                 endif
                 i = i + 1
              end do
        ! compute (l**t \ b) -> b   [ l**t \ (d \ (l \p**t * b) ) ]
             call stdlib_dtrsm('L','L','T','U',n,nrhs,one,a,lda,b,ldb)
             ! p * b  [ p * (l**t \ (d \ (l \p**t * b) )) ]
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k>1 .and. kp==-ipiv( k-1 ) )call stdlib_dswap( nrhs, b( k, 1 ), ldb, b( kp, &
                           1 ), ldb )
                 k=k-2
              endif
             end do
           end if
           ! revert a
           call stdlib_dsyconv( uplo, 'R', n, a, lda, ipiv, work, iinfo )
           return
     end subroutine stdlib_dsytrs2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
     !! DSYTRS2: solves a system of linear equations A*X = B with a real
     !! symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by DSYTRF and converted by DSYCONV.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, j, k, kp
           real(${rk}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRS2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           ! convert a
           call stdlib_${ri}$syconv( uplo, 'C', n, a, lda, ipiv, work, iinfo )
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
             ! p**t * b
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp==-ipiv( k-1 ) )call stdlib_${ri}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb &
                           )
                 k=k-2
              end if
             end do
        ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
             call stdlib_${ri}$trsm('L','U','N','U',n,nrhs,one,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i=n
              do while ( i >= 1 )
                 if( ipiv(i) > 0 ) then
                   call stdlib_${ri}$scal( nrhs, one / a( i, i ), b( i, 1 ), ldb )
                 elseif ( i > 1) then
                    if ( ipiv(i-1) == ipiv(i) ) then
                       akm1k = work(i)
                       akm1 = a( i-1, i-1 ) / akm1k
                       ak = a( i, i ) / akm1k
                       denom = akm1*ak - one
                       do j = 1, nrhs
                          bkm1 = b( i-1, j ) / akm1k
                          bk = b( i, j ) / akm1k
                          b( i-1, j ) = ( ak*bkm1-bk ) / denom
                          b( i, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                    i = i - 1
                    endif
                 endif
                 i = i - 1
              end do
            ! compute (u**t \ b) -> b   [ u**t \ (d \ (u \p**t * b) ) ]
              call stdlib_${ri}$trsm('L','U','T','U',n,nrhs,one,a,lda,b,ldb)
             ! p * b  [ p * (u**t \ (d \ (u \p**t * b) )) ]
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k < n .and. kp==-ipiv( k+1 ) )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp,&
                            1 ), ldb )
                 k=k+2
              endif
             end do
           else
              ! solve a*x = b, where a = l*d*l**t.
             ! p**t * b
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k+1).
                 kp = -ipiv( k+1 )
                 if( kp==-ipiv( k ) )call stdlib_${ri}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                           
                 k=k+2
              endif
             end do
        ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
             call stdlib_${ri}$trsm('L','L','N','U',n,nrhs,one,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i=1
              do while ( i <= n )
                 if( ipiv(i) > 0 ) then
                   call stdlib_${ri}$scal( nrhs, one / a( i, i ), b( i, 1 ), ldb )
                 else
                       akm1k = work(i)
                       akm1 = a( i, i ) / akm1k
                       ak = a( i+1, i+1 ) / akm1k
                       denom = akm1*ak - one
                       do j = 1, nrhs
                          bkm1 = b( i, j ) / akm1k
                          bk = b( i+1, j ) / akm1k
                          b( i, j ) = ( ak*bkm1-bk ) / denom
                          b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                       i = i + 1
                 endif
                 i = i + 1
              end do
        ! compute (l**t \ b) -> b   [ l**t \ (d \ (l \p**t * b) ) ]
             call stdlib_${ri}$trsm('L','L','T','U',n,nrhs,one,a,lda,b,ldb)
             ! p * b  [ p * (l**t \ (d \ (l \p**t * b) )) ]
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k>1 .and. kp==-ipiv( k-1 ) )call stdlib_${ri}$swap( nrhs, b( k, 1 ), ldb, b( kp, &
                           1 ), ldb )
                 k=k-2
              endif
             end do
           end if
           ! revert a
           call stdlib_${ri}$syconv( uplo, 'R', n, a, lda, ipiv, work, iinfo )
           return
     end subroutine stdlib_${ri}$sytrs2

#:endif
#:endfor

     module pure subroutine stdlib_csytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
     !! CSYTRS2 solves a system of linear equations A*X = B with a complex
     !! symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by CSYTRF and converted by CSYCONV.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, j, k, kp
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRS2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           ! convert a
           call stdlib_csyconv( uplo, 'C', n, a, lda, ipiv, work, iinfo )
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
             ! p**t * b
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp==-ipiv( k-1 ) )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb &
                           )
                 k=k-2
              end if
             end do
        ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
             call stdlib_ctrsm('L','U','N','U',n,nrhs,cone,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i=n
              do while ( i >= 1 )
                 if( ipiv(i) > 0 ) then
                   call stdlib_cscal( nrhs, cone / a( i, i ), b( i, 1 ), ldb )
                 elseif ( i > 1) then
                    if ( ipiv(i-1) == ipiv(i) ) then
                       akm1k = work(i)
                       akm1 = a( i-1, i-1 ) / akm1k
                       ak = a( i, i ) / akm1k
                       denom = akm1*ak - cone
                       do j = 1, nrhs
                          bkm1 = b( i-1, j ) / akm1k
                          bk = b( i, j ) / akm1k
                          b( i-1, j ) = ( ak*bkm1-bk ) / denom
                          b( i, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                    i = i - 1
                    endif
                 endif
                 i = i - 1
              end do
            ! compute (u**t \ b) -> b   [ u**t \ (d \ (u \p**t * b) ) ]
              call stdlib_ctrsm('L','U','T','U',n,nrhs,cone,a,lda,b,ldb)
             ! p * b  [ p * (u**t \ (d \ (u \p**t * b) )) ]
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k < n .and. kp==-ipiv( k+1 ) )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp,&
                            1 ), ldb )
                 k=k+2
              endif
             end do
           else
              ! solve a*x = b, where a = l*d*l**t.
             ! p**t * b
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k+1).
                 kp = -ipiv( k+1 )
                 if( kp==-ipiv( k ) )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                           
                 k=k+2
              endif
             end do
        ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
             call stdlib_ctrsm('L','L','N','U',n,nrhs,cone,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i=1
              do while ( i <= n )
                 if( ipiv(i) > 0 ) then
                   call stdlib_cscal( nrhs, cone / a( i, i ), b( i, 1 ), ldb )
                 else
                       akm1k = work(i)
                       akm1 = a( i, i ) / akm1k
                       ak = a( i+1, i+1 ) / akm1k
                       denom = akm1*ak - cone
                       do j = 1, nrhs
                          bkm1 = b( i, j ) / akm1k
                          bk = b( i+1, j ) / akm1k
                          b( i, j ) = ( ak*bkm1-bk ) / denom
                          b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                       i = i + 1
                 endif
                 i = i + 1
              end do
        ! compute (l**t \ b) -> b   [ l**t \ (d \ (l \p**t * b) ) ]
             call stdlib_ctrsm('L','L','T','U',n,nrhs,cone,a,lda,b,ldb)
             ! p * b  [ p * (l**t \ (d \ (l \p**t * b) )) ]
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k>1 .and. kp==-ipiv( k-1 ) )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, &
                           1 ), ldb )
                 k=k-2
              endif
             end do
           end if
           ! revert a
           call stdlib_csyconv( uplo, 'R', n, a, lda, ipiv, work, iinfo )
           return
     end subroutine stdlib_csytrs2

     module pure subroutine stdlib_zsytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
     !! ZSYTRS2 solves a system of linear equations A*X = B with a complex
     !! symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by ZSYTRF and converted by ZSYCONV.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, j, k, kp
           complex(dp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRS2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           ! convert a
           call stdlib_zsyconv( uplo, 'C', n, a, lda, ipiv, work, iinfo )
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
             ! p**t * b
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp==-ipiv( k-1 ) )call stdlib_zswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb &
                           )
                 k=k-2
              end if
             end do
        ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
             call stdlib_ztrsm('L','U','N','U',n,nrhs,cone,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i=n
              do while ( i >= 1 )
                 if( ipiv(i) > 0 ) then
                   call stdlib_zscal( nrhs, cone / a( i, i ), b( i, 1 ), ldb )
                 elseif ( i > 1) then
                    if ( ipiv(i-1) == ipiv(i) ) then
                       akm1k = work(i)
                       akm1 = a( i-1, i-1 ) / akm1k
                       ak = a( i, i ) / akm1k
                       denom = akm1*ak - cone
                       do j = 1, nrhs
                          bkm1 = b( i-1, j ) / akm1k
                          bk = b( i, j ) / akm1k
                          b( i-1, j ) = ( ak*bkm1-bk ) / denom
                          b( i, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                    i = i - 1
                    endif
                 endif
                 i = i - 1
              end do
            ! compute (u**t \ b) -> b   [ u**t \ (d \ (u \p**t * b) ) ]
              call stdlib_ztrsm('L','U','T','U',n,nrhs,cone,a,lda,b,ldb)
             ! p * b  [ p * (u**t \ (d \ (u \p**t * b) )) ]
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k < n .and. kp==-ipiv( k+1 ) )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp,&
                            1 ), ldb )
                 k=k+2
              endif
             end do
           else
              ! solve a*x = b, where a = l*d*l**t.
             ! p**t * b
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k+1).
                 kp = -ipiv( k+1 )
                 if( kp==-ipiv( k ) )call stdlib_zswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                           
                 k=k+2
              endif
             end do
        ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
             call stdlib_ztrsm('L','L','N','U',n,nrhs,cone,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i=1
              do while ( i <= n )
                 if( ipiv(i) > 0 ) then
                   call stdlib_zscal( nrhs, cone / a( i, i ), b( i, 1 ), ldb )
                 else
                       akm1k = work(i)
                       akm1 = a( i, i ) / akm1k
                       ak = a( i+1, i+1 ) / akm1k
                       denom = akm1*ak - cone
                       do j = 1, nrhs
                          bkm1 = b( i, j ) / akm1k
                          bk = b( i+1, j ) / akm1k
                          b( i, j ) = ( ak*bkm1-bk ) / denom
                          b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                       i = i + 1
                 endif
                 i = i + 1
              end do
        ! compute (l**t \ b) -> b   [ l**t \ (d \ (l \p**t * b) ) ]
             call stdlib_ztrsm('L','L','T','U',n,nrhs,cone,a,lda,b,ldb)
             ! p * b  [ p * (l**t \ (d \ (l \p**t * b) )) ]
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k>1 .and. kp==-ipiv( k-1 ) )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, &
                           1 ), ldb )
                 k=k-2
              endif
             end do
           end if
           ! revert a
           call stdlib_zsyconv( uplo, 'R', n, a, lda, ipiv, work, iinfo )
           return
     end subroutine stdlib_zsytrs2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sytrs2( uplo, n, nrhs, a, lda, ipiv, b, ldb,work, info )
     !! ZSYTRS2: solves a system of linear equations A*X = B with a complex
     !! symmetric matrix A using the factorization A = U*D*U**T or
     !! A = L*D*L**T computed by ZSYTRF and converted by ZSYCONV.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, j, k, kp
           complex(${ck}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRS2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           ! convert a
           call stdlib_${ci}$syconv( uplo, 'C', n, a, lda, ipiv, work, iinfo )
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**t.
             ! p**t * b
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp==-ipiv( k-1 ) )call stdlib_${ci}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb &
                           )
                 k=k-2
              end if
             end do
        ! compute (u \p**t * b) -> b    [ (u \p**t * b) ]
             call stdlib_${ci}$trsm('L','U','N','U',n,nrhs,cone,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (u \p**t * b) ]
              i=n
              do while ( i >= 1 )
                 if( ipiv(i) > 0 ) then
                   call stdlib_${ci}$scal( nrhs, cone / a( i, i ), b( i, 1 ), ldb )
                 elseif ( i > 1) then
                    if ( ipiv(i-1) == ipiv(i) ) then
                       akm1k = work(i)
                       akm1 = a( i-1, i-1 ) / akm1k
                       ak = a( i, i ) / akm1k
                       denom = akm1*ak - cone
                       do j = 1, nrhs
                          bkm1 = b( i-1, j ) / akm1k
                          bk = b( i, j ) / akm1k
                          b( i-1, j ) = ( ak*bkm1-bk ) / denom
                          b( i, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                    i = i - 1
                    endif
                 endif
                 i = i - 1
              end do
            ! compute (u**t \ b) -> b   [ u**t \ (d \ (u \p**t * b) ) ]
              call stdlib_${ci}$trsm('L','U','T','U',n,nrhs,cone,a,lda,b,ldb)
             ! p * b  [ p * (u**t \ (d \ (u \p**t * b) )) ]
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k < n .and. kp==-ipiv( k+1 ) )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp,&
                            1 ), ldb )
                 k=k+2
              endif
             end do
           else
              ! solve a*x = b, where a = l*d*l**t.
             ! p**t * b
             k=1
             do while ( k <= n )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k+1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k and -ipiv(k+1).
                 kp = -ipiv( k+1 )
                 if( kp==-ipiv( k ) )call stdlib_${ci}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                           
                 k=k+2
              endif
             end do
        ! compute (l \p**t * b) -> b    [ (l \p**t * b) ]
             call stdlib_${ci}$trsm('L','L','N','U',n,nrhs,cone,a,lda,b,ldb)
        ! compute d \ b -> b   [ d \ (l \p**t * b) ]
              i=1
              do while ( i <= n )
                 if( ipiv(i) > 0 ) then
                   call stdlib_${ci}$scal( nrhs, cone / a( i, i ), b( i, 1 ), ldb )
                 else
                       akm1k = work(i)
                       akm1 = a( i, i ) / akm1k
                       ak = a( i+1, i+1 ) / akm1k
                       denom = akm1*ak - cone
                       do j = 1, nrhs
                          bkm1 = b( i, j ) / akm1k
                          bk = b( i+1, j ) / akm1k
                          b( i, j ) = ( ak*bkm1-bk ) / denom
                          b( i+1, j ) = ( akm1*bk-bkm1 ) / denom
                       end do
                       i = i + 1
                 endif
                 i = i + 1
              end do
        ! compute (l**t \ b) -> b   [ l**t \ (d \ (l \p**t * b) ) ]
             call stdlib_${ci}$trsm('L','L','T','U',n,nrhs,cone,a,lda,b,ldb)
             ! p * b  [ p * (l**t \ (d \ (l \p**t * b) )) ]
             k=n
             do while ( k >= 1 )
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k=k-1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( k>1 .and. kp==-ipiv( k-1 ) )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, &
                           1 ), ldb )
                 k=k-2
              endif
             end do
           end if
           ! revert a
           call stdlib_${ci}$syconv( uplo, 'R', n, a, lda, ipiv, work, iinfo )
           return
     end subroutine stdlib_${ci}$sytrs2

#:endif
#:endfor





     module pure subroutine stdlib_chpcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
     !! CHPCON estimates the reciprocal of the condition number of a complex
     !! Hermitian packed matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by CHPTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(sp), intent(in) :: anorm
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: ap(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, ip, kase
           real(sp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( anorm<zero ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              ip = n*( n+1 ) / 2
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip - i
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              ip = 1
              do i = 1, n
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip + n - i + 1
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_clacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**h) or inv(u*d*u**h).
              call stdlib_chptrs( uplo, n, 1, ap, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_chpcon

     module pure subroutine stdlib_zhpcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
     !! ZHPCON estimates the reciprocal of the condition number of a complex
     !! Hermitian packed matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by ZHPTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(dp), intent(in) :: anorm
           real(dp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: ap(*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, ip, kase
           real(dp) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( anorm<zero ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHPCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              ip = n*( n+1 ) / 2
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip - i
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              ip = 1
              do i = 1, n
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip + n - i + 1
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_zlacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**h) or inv(u*d*u**h).
              call stdlib_zhptrs( uplo, n, 1, ap, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_zhpcon

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hpcon( uplo, n, ap, ipiv, anorm, rcond, work, info )
     !! ZHPCON: estimates the reciprocal of the condition number of a complex
     !! Hermitian packed matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by ZHPTRF.
     !! An estimate is obtained for norm(inv(A)), and the reciprocal of the
     !! condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(${ck}$), intent(in) :: anorm
           real(${ck}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: ap(*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, ip, kase
           real(${ck}$) :: ainvnm
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( anorm<zero ) then
              info = -5
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHPCON', -info )
              return
           end if
           ! quick return if possible
           rcond = zero
           if( n==0 ) then
              rcond = one
              return
           else if( anorm<=zero ) then
              return
           end if
           ! check that the diagonal matrix d is nonsingular.
           if( upper ) then
              ! upper triangular storage: examine d from bottom to top
              ip = n*( n+1 ) / 2
              do i = n, 1, -1
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip - i
              end do
           else
              ! lower triangular storage: examine d from top to bottom.
              ip = 1
              do i = 1, n
                 if( ipiv( i )>0 .and. ap( ip )==zero )return
                 ip = ip + n - i + 1
              end do
           end if
           ! estimate the 1-norm of the inverse.
           kase = 0
           30 continue
           call stdlib_${ci}$lacn2( n, work( n+1 ), work, ainvnm, kase, isave )
           if( kase/=0 ) then
              ! multiply by inv(l*d*l**h) or inv(u*d*u**h).
              call stdlib_${ci}$hptrs( uplo, n, 1, ap, ipiv, work, n, info )
              go to 30
           end if
           ! compute the estimate of the reciprocal condition number.
           if( ainvnm/=zero )rcond = ( one / ainvnm ) / anorm
           return
     end subroutine stdlib_${ci}$hpcon

#:endif
#:endfor





     module pure subroutine stdlib_ssytf2( uplo, n, a, lda, ipiv, info )
     !! SSYTF2 computes the factorization of a real symmetric matrix A using
     !! the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**T is the transpose of U, and D is symmetric and
     !! block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kk, kp, kstep
           real(sp) :: absakk, alpha, colmax, d11, d12, d21, d22, r1, rowmax, t, wk, wkm1, &
                     wkp1
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYTF2', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_isamax( k-1, a( 1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) .or. stdlib_sisnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = imax + stdlib_isamax( k-imax, a( imax, imax+1 ), lda )
                    rowmax = abs( a( imax, jmax ) )
                    if( imax>1 ) then
                       jmax = stdlib_isamax( imax-1, a( 1, imax ), 1 )
                       rowmax = max( rowmax, abs( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( a( imax, imax ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_sswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    call stdlib_sswap( kk-kp-1, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**t = a - w(k)*1/d(k)*w(k)**t
                    r1 = one / a( k, k )
                    call stdlib_ssyr( uplo, k-1, -r1, a( 1, k ), 1, a, lda )
                    ! store u(k) in column k
                    call stdlib_sscal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**t
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = one / ( d11*d22-one )
                       d12 = t / d12
                       do j = k - 2, 1, -1
                          wkm1 = d12*( d11*a( j, k-1 )-a( j, k ) )
                          wk = d12*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - a( i, k )*wk -a( i, k-1 )*wkm1
                          end do
                          a( j, k ) = wk
                          a( j, k-1 ) = wkm1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_isamax( n-k, a( k+1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) .or. stdlib_sisnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = k - 1 + stdlib_isamax( imax-k, a( imax, k ), lda )
                    rowmax = abs( a( imax, jmax ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_isamax( n-imax, a( imax+1, imax ), 1 )
                       rowmax = max( rowmax, abs( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( a( imax, imax ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_sswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    call stdlib_sswap( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**t = a - w(k)*(1/d(k))*w(k)**t
                       d11 = one / a( k, k )
                       call stdlib_ssyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                 
                       ! store l(k) in column k
                       call stdlib_sscal( n-k, d11, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k)
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( (a(k) a(k+1))*d(k)**(-1) ) * (a(k) a(k+1))**t
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = one / ( d11*d22-one )
                       d21 = t / d21
                       do j = k + 2, n
                          wk = d21*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = d21*( d22*a( j, k+1 )-a( j, k ) )
                          do i = j, n
                             a( i, j ) = a( i, j ) - a( i, k )*wk -a( i, k+1 )*wkp1
                          end do
                          a( j, k ) = wk
                          a( j, k+1 ) = wkp1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_ssytf2

     module pure subroutine stdlib_dsytf2( uplo, n, a, lda, ipiv, info )
     !! DSYTF2 computes the factorization of a real symmetric matrix A using
     !! the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**T is the transpose of U, and D is symmetric and
     !! block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kk, kp, kstep
           real(dp) :: absakk, alpha, colmax, d11, d12, d21, d22, r1, rowmax, t, wk, wkm1, &
                     wkp1
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTF2', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_idamax( k-1, a( 1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) .or. stdlib_disnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = imax + stdlib_idamax( k-imax, a( imax, imax+1 ), lda )
                    rowmax = abs( a( imax, jmax ) )
                    if( imax>1 ) then
                       jmax = stdlib_idamax( imax-1, a( 1, imax ), 1 )
                       rowmax = max( rowmax, abs( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( a( imax, imax ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_dswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    call stdlib_dswap( kk-kp-1, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**t = a - w(k)*1/d(k)*w(k)**t
                    r1 = one / a( k, k )
                    call stdlib_dsyr( uplo, k-1, -r1, a( 1, k ), 1, a, lda )
                    ! store u(k) in column k
                    call stdlib_dscal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**t
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = one / ( d11*d22-one )
                       d12 = t / d12
                       do j = k - 2, 1, -1
                          wkm1 = d12*( d11*a( j, k-1 )-a( j, k ) )
                          wk = d12*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - a( i, k )*wk -a( i, k-1 )*wkm1
                          end do
                          a( j, k ) = wk
                          a( j, k-1 ) = wkm1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_idamax( n-k, a( k+1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) .or. stdlib_disnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = k - 1 + stdlib_idamax( imax-k, a( imax, k ), lda )
                    rowmax = abs( a( imax, jmax ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_idamax( n-imax, a( imax+1, imax ), 1 )
                       rowmax = max( rowmax, abs( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( a( imax, imax ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_dswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    call stdlib_dswap( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**t = a - w(k)*(1/d(k))*w(k)**t
                       d11 = one / a( k, k )
                       call stdlib_dsyr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                 
                       ! store l(k) in column k
                       call stdlib_dscal( n-k, d11, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k)
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( (a(k) a(k+1))*d(k)**(-1) ) * (a(k) a(k+1))**t
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = one / ( d11*d22-one )
                       d21 = t / d21
                       do j = k + 2, n
                          wk = d21*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = d21*( d22*a( j, k+1 )-a( j, k ) )
                          do i = j, n
                             a( i, j ) = a( i, j ) - a( i, k )*wk -a( i, k+1 )*wkp1
                          end do
                          a( j, k ) = wk
                          a( j, k+1 ) = wkp1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_dsytf2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sytf2( uplo, n, a, lda, ipiv, info )
     !! DSYTF2: computes the factorization of a real symmetric matrix A using
     !! the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**T is the transpose of U, and D is symmetric and
     !! block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sevten = 17.0e+0_${rk}$
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kk, kp, kstep
           real(${rk}$) :: absakk, alpha, colmax, d11, d12, d21, d22, r1, rowmax, t, wk, wkm1, &
                     wkp1
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTF2', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ri}$amax( k-1, a( 1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) .or. stdlib_${ri}$isnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = imax + stdlib_i${ri}$amax( k-imax, a( imax, imax+1 ), lda )
                    rowmax = abs( a( imax, jmax ) )
                    if( imax>1 ) then
                       jmax = stdlib_i${ri}$amax( imax-1, a( 1, imax ), 1 )
                       rowmax = max( rowmax, abs( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( a( imax, imax ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_${ri}$swap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    call stdlib_${ri}$swap( kk-kp-1, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**t = a - w(k)*1/d(k)*w(k)**t
                    r1 = one / a( k, k )
                    call stdlib_${ri}$syr( uplo, k-1, -r1, a( 1, k ), 1, a, lda )
                    ! store u(k) in column k
                    call stdlib_${ri}$scal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**t
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = one / ( d11*d22-one )
                       d12 = t / d12
                       do j = k - 2, 1, -1
                          wkm1 = d12*( d11*a( j, k-1 )-a( j, k ) )
                          wk = d12*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - a( i, k )*wk -a( i, k-1 )*wkm1
                          end do
                          a( j, k ) = wk
                          a( j, k-1 ) = wkm1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = abs( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ri}$amax( n-k, a( k+1, k ), 1 )
                 colmax = abs( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( (max( absakk, colmax )==zero) .or. stdlib_${ri}$isnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = k - 1 + stdlib_i${ri}$amax( imax-k, a( imax, k ), lda )
                    rowmax = abs( a( imax, jmax ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_i${ri}$amax( n-imax, a( imax+1, imax ), 1 )
                       rowmax = max( rowmax, abs( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( abs( a( imax, imax ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_${ri}$swap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    call stdlib_${ri}$swap( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**t = a - w(k)*(1/d(k))*w(k)**t
                       d11 = one / a( k, k )
                       call stdlib_${ri}$syr( uplo, n-k, -d11, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                 
                       ! store l(k) in column k
                       call stdlib_${ri}$scal( n-k, d11, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k)
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( (a(k) a(k+1))*d(k)**(-1) ) * (a(k) a(k+1))**t
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = one / ( d11*d22-one )
                       d21 = t / d21
                       do j = k + 2, n
                          wk = d21*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = d21*( d22*a( j, k+1 )-a( j, k ) )
                          do i = j, n
                             a( i, j ) = a( i, j ) - a( i, k )*wk -a( i, k+1 )*wkp1
                          end do
                          a( j, k ) = wk
                          a( j, k+1 ) = wkp1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_${ri}$sytf2

#:endif
#:endfor

     module pure subroutine stdlib_csytf2( uplo, n, a, lda, ipiv, info )
     !! CSYTF2 computes the factorization of a complex symmetric matrix A
     !! using the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**T is the transpose of U, and D is symmetric and
     !! block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sevten = 17.0e+0_sp
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kk, kp, kstep
           real(sp) :: absakk, alpha, colmax, rowmax
           complex(sp) :: d11, d12, d21, d22, r1, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=sp) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTF2', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_icamax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero .or. stdlib_sisnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = imax + stdlib_icamax( k-imax, a( imax, imax+1 ), lda )
                    rowmax = cabs1( a( imax, jmax ) )
                    if( imax>1 ) then
                       jmax = stdlib_icamax( imax-1, a( 1, imax ), 1 )
                       rowmax = max( rowmax, cabs1( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( a( imax, imax ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_cswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    call stdlib_cswap( kk-kp-1, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**t = a - w(k)*1/d(k)*w(k)**t
                    r1 = cone / a( k, k )
                    call stdlib_csyr( uplo, k-1, -r1, a( 1, k ), 1, a, lda )
                    ! store u(k) in column k
                    call stdlib_cscal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**t
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = cone / ( d11*d22-cone )
                       d12 = t / d12
                       do j = k - 2, 1, -1
                          wkm1 = d12*( d11*a( j, k-1 )-a( j, k ) )
                          wk = d12*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - a( i, k )*wk -a( i, k-1 )*wkm1
                          end do
                          a( j, k ) = wk
                          a( j, k-1 ) = wkm1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_icamax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero .or. stdlib_sisnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = k - 1 + stdlib_icamax( imax-k, a( imax, k ), lda )
                    rowmax = cabs1( a( imax, jmax ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_icamax( n-imax, a( imax+1, imax ), 1 )
                       rowmax = max( rowmax, cabs1( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( a( imax, imax ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_cswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    call stdlib_cswap( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**t = a - w(k)*(1/d(k))*w(k)**t
                       r1 = cone / a( k, k )
                       call stdlib_csyr( uplo, n-k, -r1, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                 
                       ! store l(k) in column k
                       call stdlib_cscal( n-k, r1, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k)
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**t
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**t
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       d21 = t / d21
                       do j = k + 2, n
                          wk = d21*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = d21*( d22*a( j, k+1 )-a( j, k ) )
                          do i = j, n
                             a( i, j ) = a( i, j ) - a( i, k )*wk -a( i, k+1 )*wkp1
                          end do
                          a( j, k ) = wk
                          a( j, k+1 ) = wkp1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_csytf2

     module pure subroutine stdlib_zsytf2( uplo, n, a, lda, ipiv, info )
     !! ZSYTF2 computes the factorization of a complex symmetric matrix A
     !! using the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**T is the transpose of U, and D is symmetric and
     !! block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sevten = 17.0e+0_dp
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kk, kp, kstep
           real(dp) :: absakk, alpha, colmax, rowmax
           complex(dp) :: d11, d12, d21, d22, r1, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=dp) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTF2', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_izamax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero .or. stdlib_disnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = imax + stdlib_izamax( k-imax, a( imax, imax+1 ), lda )
                    rowmax = cabs1( a( imax, jmax ) )
                    if( imax>1 ) then
                       jmax = stdlib_izamax( imax-1, a( 1, imax ), 1 )
                       rowmax = max( rowmax, cabs1( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( a( imax, imax ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_zswap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    call stdlib_zswap( kk-kp-1, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**t = a - w(k)*1/d(k)*w(k)**t
                    r1 = cone / a( k, k )
                    call stdlib_zsyr( uplo, k-1, -r1, a( 1, k ), 1, a, lda )
                    ! store u(k) in column k
                    call stdlib_zscal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**t
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = cone / ( d11*d22-cone )
                       d12 = t / d12
                       do j = k - 2, 1, -1
                          wkm1 = d12*( d11*a( j, k-1 )-a( j, k ) )
                          wk = d12*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - a( i, k )*wk -a( i, k-1 )*wkm1
                          end do
                          a( j, k ) = wk
                          a( j, k-1 ) = wkm1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_izamax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero .or. stdlib_disnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = k - 1 + stdlib_izamax( imax-k, a( imax, k ), lda )
                    rowmax = cabs1( a( imax, jmax ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_izamax( n-imax, a( imax+1, imax ), 1 )
                       rowmax = max( rowmax, cabs1( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( a( imax, imax ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_zswap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    call stdlib_zswap( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**t = a - w(k)*(1/d(k))*w(k)**t
                       r1 = cone / a( k, k )
                       call stdlib_zsyr( uplo, n-k, -r1, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                 
                       ! store l(k) in column k
                       call stdlib_zscal( n-k, r1, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k)
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**t
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**t
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       d21 = t / d21
                       do j = k + 2, n
                          wk = d21*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = d21*( d22*a( j, k+1 )-a( j, k ) )
                          do i = j, n
                             a( i, j ) = a( i, j ) - a( i, k )*wk -a( i, k+1 )*wkp1
                          end do
                          a( j, k ) = wk
                          a( j, k+1 ) = wkp1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_zsytf2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sytf2( uplo, n, a, lda, ipiv, info )
     !! ZSYTF2: computes the factorization of a complex symmetric matrix A
     !! using the Bunch-Kaufman diagonal pivoting method:
     !! A = U*D*U**T  or  A = L*D*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, U**T is the transpose of U, and D is symmetric and
     !! block diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! This is the unblocked version of the algorithm, calling Level 2 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: sevten = 17.0e+0_${ck}$
           
           
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, imax, j, jmax, k, kk, kp, kstep
           real(${ck}$) :: absakk, alpha, colmax, rowmax
           complex(${ck}$) :: d11, d12, d21, d22, r1, t, wk, wkm1, wkp1, z
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( z ) = abs( real( z,KIND=${ck}$) ) + abs( aimag( z ) )
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTF2', -info )
              return
           end if
           ! initialize alpha for use in choosing pivot block size.
           alpha = ( one+sqrt( sevten ) ) / eight
           if( upper ) then
              ! factorize a as u*d*u**t using the upper triangle of a
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2
              k = n
              10 continue
              ! if k < 1, exit from loop
              if( k<1 )go to 70
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k>1 ) then
                 imax = stdlib_i${ci}$amax( k-1, a( 1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero .or. stdlib_${c2ri(ci)}$isnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = imax + stdlib_i${ci}$amax( k-imax, a( imax, imax+1 ), lda )
                    rowmax = cabs1( a( imax, jmax ) )
                    if( imax>1 ) then
                       jmax = stdlib_i${ci}$amax( imax-1, a( 1, imax ), 1 )
                       rowmax = max( rowmax, cabs1( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( a( imax, imax ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k-1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k - kstep + 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the leading
                    ! submatrix a(1:k,1:k)
                    call stdlib_${ci}$swap( kp-1, a( 1, kk ), 1, a( 1, kp ), 1 )
                    call stdlib_${ci}$swap( kk-kp-1, a( kp+1, kk ), 1, a( kp, kp+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k-1, k )
                       a( k-1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the leading submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = u(k)*d(k)
                    ! where u(k) is the k-th column of u
                    ! perform a rank-1 update of a(1:k-1,1:k-1) as
                    ! a := a - u(k)*d(k)*u(k)**t = a - w(k)*1/d(k)*w(k)**t
                    r1 = cone / a( k, k )
                    call stdlib_${ci}$syr( uplo, k-1, -r1, a( 1, k ), 1, a, lda )
                    ! store u(k) in column k
                    call stdlib_${ci}$scal( k-1, r1, a( 1, k ), 1 )
                 else
                    ! 2-by-2 pivot block d(k): columns k and k-1 now hold
                    ! ( w(k-1) w(k) ) = ( u(k-1) u(k) )*d(k)
                    ! where u(k) and u(k-1) are the k-th and (k-1)-th columns
                    ! of u
                    ! perform a rank-2 update of a(1:k-2,1:k-2) as
                    ! a := a - ( u(k-1) u(k) )*d(k)*( u(k-1) u(k) )**t
                       ! = a - ( w(k-1) w(k) )*inv(d(k))*( w(k-1) w(k) )**t
                    if( k>2 ) then
                       d12 = a( k-1, k )
                       d22 = a( k-1, k-1 ) / d12
                       d11 = a( k, k ) / d12
                       t = cone / ( d11*d22-cone )
                       d12 = t / d12
                       do j = k - 2, 1, -1
                          wkm1 = d12*( d11*a( j, k-1 )-a( j, k ) )
                          wk = d12*( d22*a( j, k )-a( j, k-1 ) )
                          do i = j, 1, -1
                             a( i, j ) = a( i, j ) - a( i, k )*wk -a( i, k-1 )*wkm1
                          end do
                          a( j, k ) = wk
                          a( j, k-1 ) = wkm1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k-1 ) = -kp
              end if
              ! decrease k and return to the start of the main loop
              k = k - kstep
              go to 10
           else
              ! factorize a as l*d*l**t using the lower triangle of a
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2
              k = 1
              40 continue
              ! if k > n, exit from loop
              if( k>n )go to 70
              kstep = 1
              ! determine rows and columns to be interchanged and whether
              ! a 1-by-1 or 2-by-2 pivot block will be used
              absakk = cabs1( a( k, k ) )
              ! imax is the row-index of the largest off-diagonal element in
              ! column k, and colmax is its absolute value.
              ! determine both colmax and imax.
              if( k<n ) then
                 imax = k + stdlib_i${ci}$amax( n-k, a( k+1, k ), 1 )
                 colmax = cabs1( a( imax, k ) )
              else
                 colmax = zero
              end if
              if( max( absakk, colmax )==zero .or. stdlib_${c2ri(ci)}$isnan(absakk) ) then
                 ! column k is zero or underflow, or contains a nan:
                 ! set info and continue
                 if( info==0 )info = k
                 kp = k
              else
                 if( absakk>=alpha*colmax ) then
                    ! no interchange, use 1-by-1 pivot block
                    kp = k
                 else
                    ! jmax is the column-index of the largest off-diagonal
                    ! element in row imax, and rowmax is its absolute value
                    jmax = k - 1 + stdlib_i${ci}$amax( imax-k, a( imax, k ), lda )
                    rowmax = cabs1( a( imax, jmax ) )
                    if( imax<n ) then
                       jmax = imax + stdlib_i${ci}$amax( n-imax, a( imax+1, imax ), 1 )
                       rowmax = max( rowmax, cabs1( a( jmax, imax ) ) )
                    end if
                    if( absakk>=alpha*colmax*( colmax / rowmax ) ) then
                       ! no interchange, use 1-by-1 pivot block
                       kp = k
                    else if( cabs1( a( imax, imax ) )>=alpha*rowmax ) then
                       ! interchange rows and columns k and imax, use 1-by-1
                       ! pivot block
                       kp = imax
                    else
                       ! interchange rows and columns k+1 and imax, use 2-by-2
                       ! pivot block
                       kp = imax
                       kstep = 2
                    end if
                 end if
                 kk = k + kstep - 1
                 if( kp/=kk ) then
                    ! interchange rows and columns kk and kp in the trailing
                    ! submatrix a(k:n,k:n)
                    if( kp<n )call stdlib_${ci}$swap( n-kp, a( kp+1, kk ), 1, a( kp+1, kp ), 1 )
                              
                    call stdlib_${ci}$swap( kp-kk-1, a( kk+1, kk ), 1, a( kp, kk+1 ),lda )
                    t = a( kk, kk )
                    a( kk, kk ) = a( kp, kp )
                    a( kp, kp ) = t
                    if( kstep==2 ) then
                       t = a( k+1, k )
                       a( k+1, k ) = a( kp, k )
                       a( kp, k ) = t
                    end if
                 end if
                 ! update the trailing submatrix
                 if( kstep==1 ) then
                    ! 1-by-1 pivot block d(k): column k now holds
                    ! w(k) = l(k)*d(k)
                    ! where l(k) is the k-th column of l
                    if( k<n ) then
                       ! perform a rank-1 update of a(k+1:n,k+1:n) as
                       ! a := a - l(k)*d(k)*l(k)**t = a - w(k)*(1/d(k))*w(k)**t
                       r1 = cone / a( k, k )
                       call stdlib_${ci}$syr( uplo, n-k, -r1, a( k+1, k ), 1,a( k+1, k+1 ), lda )
                                 
                       ! store l(k) in column k
                       call stdlib_${ci}$scal( n-k, r1, a( k+1, k ), 1 )
                    end if
                 else
                    ! 2-by-2 pivot block d(k)
                    if( k<n-1 ) then
                       ! perform a rank-2 update of a(k+2:n,k+2:n) as
                       ! a := a - ( l(k) l(k+1) )*d(k)*( l(k) l(k+1) )**t
                          ! = a - ( w(k) w(k+1) )*inv(d(k))*( w(k) w(k+1) )**t
                       ! where l(k) and l(k+1) are the k-th and (k+1)-th
                       ! columns of l
                       d21 = a( k+1, k )
                       d11 = a( k+1, k+1 ) / d21
                       d22 = a( k, k ) / d21
                       t = cone / ( d11*d22-cone )
                       d21 = t / d21
                       do j = k + 2, n
                          wk = d21*( d11*a( j, k )-a( j, k+1 ) )
                          wkp1 = d21*( d22*a( j, k+1 )-a( j, k ) )
                          do i = j, n
                             a( i, j ) = a( i, j ) - a( i, k )*wk -a( i, k+1 )*wkp1
                          end do
                          a( j, k ) = wk
                          a( j, k+1 ) = wkp1
                       end do
                    end if
                 end if
              end if
              ! store details of the interchanges in ipiv
              if( kstep==1 ) then
                 ipiv( k ) = kp
              else
                 ipiv( k ) = -kp
                 ipiv( k+1 ) = -kp
              end if
              ! increase k and return to the start of the main loop
              k = k + kstep
              go to 40
           end if
           70 continue
           return
     end subroutine stdlib_${ci}$sytf2

#:endif
#:endfor



     module pure subroutine stdlib_ssytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
     !! SSYTRF_AA computes the factorization of a real symmetric matrix A
     !! using the Aasen's algorithm.  The form of the factorization is
     !! A = U**T*T*U  or  A = L*T*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is a symmetric tridiagonal matrix.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, lda, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: j, lwkopt
           integer(ilp) :: nb, mj, nj, k1, k2, j1, j2, j3, jb
           real(sp) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! determine the block size
           nb = stdlib_ilaenv( 1, 'SSYTRF_AA', uplo, n, -1, -1, -1 )
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              lwkopt = (nb+1)*n
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYTRF_AA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return
           if ( n==0 ) then
               return
           endif
           ipiv( 1 ) = 1
           if ( n==1 ) then
              return
           end if
           ! adjust block size based on the workspace size
           if( lwork<((1+nb)*n) ) then
              nb = ( lwork-n ) / n
           end if
           if( upper ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              ! copy first row a(1, 1:n) into h(1:n) (stored in work(1:n))
              call stdlib_scopy( n, a( 1, 1 ), lda, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_slasyf;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              10 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j + 1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_slasyf_aa( uplo, 2-k1, n-j, jb,a( max(1, j), j+1 ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_sswap( j1-k1-2, a( 1, j2 ), 1,a( 1, ipiv(j2) ), 1 )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
               ! the row a(j1-1, j2-1:n) stores u(j1, j2+1:n) and
               ! work stores the current block of the auxiriarly matrix h
              if( j<n ) then
                 ! if first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = a( j, j+1 )
                    a( j, j+1 ) = one
                    call stdlib_scopy( n-j, a( j-1, j+1 ), lda,work( (j+1-j1+1)+jb*n ), 1 )
                              
                    call stdlib_sscal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=1 and k2= 0 for the first panel,
                     ! while k1=0 and k2=1 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_sgemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_sgemv( 'NO TRANSPOSE', mj, jb+1,-one, work( j3-j1+1+k1*n ), &
                                    n,a( j1-k2, j3 ), 1,one, a( j3, j3 ), lda )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block of j2-th block row with stdlib_sgemm
                       call stdlib_sgemm( 'TRANSPOSE', 'TRANSPOSE',nj, n-j3+1, jb+1,-one, a( j1-&
                                 k2, j2 ), lda,work( j3-j1+1+k1*n ), n,one, a( j2, j3 ), lda )
                    end do
                    ! recover t( j, j+1 )
                    a( j, j+1 ) = alpha
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_scopy( n-j, a( j+1, j+1 ), lda, work( 1 ), 1 )
              end if
              go to 10
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              ! copy first column a(1:n, 1) into h(1:n, 1)
               ! (stored in work(1:n))
              call stdlib_scopy( n, a( 1, 1 ), 1, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_slasyf;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              11 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j+1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_slasyf_aa( uplo, 2-k1, n-j, jb,a( j+1, max(1, j) ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_sswap( j1-k1-2, a( j2, 1 ), lda,a( ipiv(j2), 1 ), lda )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
                ! a(j2+1, j1-1) stores l(j2+1, j1) and
                ! work(j2+1, 1) stores h(j2+1, 1)
              if( j<n ) then
                 ! if first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = a( j+1, j )
                    a( j+1, j ) = one
                    call stdlib_scopy( n-j, a( j+1, j-1 ), 1,work( (j+1-j1+1)+jb*n ), 1 )
                    call stdlib_sscal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=1 and k2= 0 for the first panel,
                     ! while k1=0 and k2=1 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_sgemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_sgemv( 'NO TRANSPOSE', mj, jb+1,-one, work( j3-j1+1+k1*n ), &
                                    n,a( j3, j1-k2 ), lda,one, a( j3, j3 ), 1 )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block in j2-th block column with stdlib_sgemm
                       call stdlib_sgemm( 'NO TRANSPOSE', 'TRANSPOSE',n-j3+1, nj, jb+1,-one, work(&
                                  j3-j1+1+k1*n ), n,a( j2, j1-k2 ), lda,one, a( j3, j2 ), lda )
                    end do
                    ! recover t( j+1, j )
                    a( j+1, j ) = alpha
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_scopy( n-j, a( j+1, j+1 ), 1, work( 1 ), 1 )
              end if
              go to 11
           end if
           20 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_ssytrf_aa

     module pure subroutine stdlib_dsytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
     !! DSYTRF_AA computes the factorization of a real symmetric matrix A
     !! using the Aasen's algorithm.  The form of the factorization is
     !! A = U**T*T*U  or  A = L*T*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is a symmetric tridiagonal matrix.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, lda, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: j, lwkopt
           integer(ilp) :: nb, mj, nj, k1, k2, j1, j2, j3, jb
           real(dp) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! determine the block size
           nb = stdlib_ilaenv( 1, 'DSYTRF_AA', uplo, n, -1, -1, -1 )
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              lwkopt = (nb+1)*n
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRF_AA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return
           if ( n==0 ) then
               return
           endif
           ipiv( 1 ) = 1
           if ( n==1 ) then
              return
           end if
           ! adjust block size based on the workspace size
           if( lwork<((1+nb)*n) ) then
              nb = ( lwork-n ) / n
           end if
           if( upper ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              ! copy first row a(1, 1:n) into h(1:n) (stored in work(1:n))
              call stdlib_dcopy( n, a( 1, 1 ), lda, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_dlasyf;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              10 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j + 1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_dlasyf_aa( uplo, 2-k1, n-j, jb,a( max(1, j), j+1 ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_dswap( j1-k1-2, a( 1, j2 ), 1,a( 1, ipiv(j2) ), 1 )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
               ! the row a(j1-1, j2-1:n) stores u(j1, j2+1:n) and
               ! work stores the current block of the auxiriarly matrix h
              if( j<n ) then
                 ! if first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = a( j, j+1 )
                    a( j, j+1 ) = one
                    call stdlib_dcopy( n-j, a( j-1, j+1 ), lda,work( (j+1-j1+1)+jb*n ), 1 )
                              
                    call stdlib_dscal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=1 and k2= 0 for the first panel,
                     ! while k1=0 and k2=1 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_dgemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_dgemv( 'NO TRANSPOSE', mj, jb+1,-one, work( j3-j1+1+k1*n ), &
                                    n,a( j1-k2, j3 ), 1,one, a( j3, j3 ), lda )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block of j2-th block row with stdlib_dgemm
                       call stdlib_dgemm( 'TRANSPOSE', 'TRANSPOSE',nj, n-j3+1, jb+1,-one, a( j1-&
                                 k2, j2 ), lda,work( j3-j1+1+k1*n ), n,one, a( j2, j3 ), lda )
                    end do
                    ! recover t( j, j+1 )
                    a( j, j+1 ) = alpha
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_dcopy( n-j, a( j+1, j+1 ), lda, work( 1 ), 1 )
              end if
              go to 10
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              ! copy first column a(1:n, 1) into h(1:n, 1)
               ! (stored in work(1:n))
              call stdlib_dcopy( n, a( 1, 1 ), 1, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_dlasyf;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              11 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j+1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_dlasyf_aa( uplo, 2-k1, n-j, jb,a( j+1, max(1, j) ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_dswap( j1-k1-2, a( j2, 1 ), lda,a( ipiv(j2), 1 ), lda )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
                ! a(j2+1, j1-1) stores l(j2+1, j1) and
                ! work(j2+1, 1) stores h(j2+1, 1)
              if( j<n ) then
                 ! if first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = a( j+1, j )
                    a( j+1, j ) = one
                    call stdlib_dcopy( n-j, a( j+1, j-1 ), 1,work( (j+1-j1+1)+jb*n ), 1 )
                    call stdlib_dscal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=1 and k2= 0 for the first panel,
                     ! while k1=0 and k2=1 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_dgemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_dgemv( 'NO TRANSPOSE', mj, jb+1,-one, work( j3-j1+1+k1*n ), &
                                    n,a( j3, j1-k2 ), lda,one, a( j3, j3 ), 1 )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block in j2-th block column with stdlib_dgemm
                       call stdlib_dgemm( 'NO TRANSPOSE', 'TRANSPOSE',n-j3+1, nj, jb+1,-one, work(&
                                  j3-j1+1+k1*n ), n,a( j2, j1-k2 ), lda,one, a( j3, j2 ), lda )
                    end do
                    ! recover t( j+1, j )
                    a( j+1, j ) = alpha
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_dcopy( n-j, a( j+1, j+1 ), 1, work( 1 ), 1 )
              end if
              go to 11
           end if
           20 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dsytrf_aa

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
     !! DSYTRF_AA: computes the factorization of a real symmetric matrix A
     !! using the Aasen's algorithm.  The form of the factorization is
     !! A = U**T*T*U  or  A = L*T*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is a symmetric tridiagonal matrix.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, lda, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: j, lwkopt
           integer(ilp) :: nb, mj, nj, k1, k2, j1, j2, j3, jb
           real(${rk}$) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! determine the block size
           nb = stdlib_ilaenv( 1, 'DSYTRF_AA', uplo, n, -1, -1, -1 )
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              lwkopt = (nb+1)*n
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRF_AA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return
           if ( n==0 ) then
               return
           endif
           ipiv( 1 ) = 1
           if ( n==1 ) then
              return
           end if
           ! adjust block size based on the workspace size
           if( lwork<((1+nb)*n) ) then
              nb = ( lwork-n ) / n
           end if
           if( upper ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              ! copy first row a(1, 1:n) into h(1:n) (stored in work(1:n))
              call stdlib_${ri}$copy( n, a( 1, 1 ), lda, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_${ri}$lasyf;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              10 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j + 1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_${ri}$lasyf_aa( uplo, 2-k1, n-j, jb,a( max(1, j), j+1 ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_${ri}$swap( j1-k1-2, a( 1, j2 ), 1,a( 1, ipiv(j2) ), 1 )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
               ! the row a(j1-1, j2-1:n) stores u(j1, j2+1:n) and
               ! work stores the current block of the auxiriarly matrix h
              if( j<n ) then
                 ! if first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = a( j, j+1 )
                    a( j, j+1 ) = one
                    call stdlib_${ri}$copy( n-j, a( j-1, j+1 ), lda,work( (j+1-j1+1)+jb*n ), 1 )
                              
                    call stdlib_${ri}$scal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=1 and k2= 0 for the first panel,
                     ! while k1=0 and k2=1 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_${ri}$gemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_${ri}$gemv( 'NO TRANSPOSE', mj, jb+1,-one, work( j3-j1+1+k1*n ), &
                                    n,a( j1-k2, j3 ), 1,one, a( j3, j3 ), lda )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block of j2-th block row with stdlib_${ri}$gemm
                       call stdlib_${ri}$gemm( 'TRANSPOSE', 'TRANSPOSE',nj, n-j3+1, jb+1,-one, a( j1-&
                                 k2, j2 ), lda,work( j3-j1+1+k1*n ), n,one, a( j2, j3 ), lda )
                    end do
                    ! recover t( j, j+1 )
                    a( j, j+1 ) = alpha
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_${ri}$copy( n-j, a( j+1, j+1 ), lda, work( 1 ), 1 )
              end if
              go to 10
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              ! copy first column a(1:n, 1) into h(1:n, 1)
               ! (stored in work(1:n))
              call stdlib_${ri}$copy( n, a( 1, 1 ), 1, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_${ri}$lasyf;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              11 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j+1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_${ri}$lasyf_aa( uplo, 2-k1, n-j, jb,a( j+1, max(1, j) ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_${ri}$swap( j1-k1-2, a( j2, 1 ), lda,a( ipiv(j2), 1 ), lda )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
                ! a(j2+1, j1-1) stores l(j2+1, j1) and
                ! work(j2+1, 1) stores h(j2+1, 1)
              if( j<n ) then
                 ! if first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = a( j+1, j )
                    a( j+1, j ) = one
                    call stdlib_${ri}$copy( n-j, a( j+1, j-1 ), 1,work( (j+1-j1+1)+jb*n ), 1 )
                    call stdlib_${ri}$scal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=1 and k2= 0 for the first panel,
                     ! while k1=0 and k2=1 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_${ri}$gemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_${ri}$gemv( 'NO TRANSPOSE', mj, jb+1,-one, work( j3-j1+1+k1*n ), &
                                    n,a( j3, j1-k2 ), lda,one, a( j3, j3 ), 1 )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block in j2-th block column with stdlib_${ri}$gemm
                       call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'TRANSPOSE',n-j3+1, nj, jb+1,-one, work(&
                                  j3-j1+1+k1*n ), n,a( j2, j1-k2 ), lda,one, a( j3, j2 ), lda )
                    end do
                    ! recover t( j+1, j )
                    a( j+1, j ) = alpha
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_${ri}$copy( n-j, a( j+1, j+1 ), 1, work( 1 ), 1 )
              end if
              go to 11
           end if
           20 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sytrf_aa

#:endif
#:endfor

     module pure subroutine stdlib_csytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
     !! CSYTRF_AA computes the factorization of a complex symmetric matrix A
     !! using the Aasen's algorithm.  The form of the factorization is
     !! A = U**T*T*U  or  A = L*T*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is a complex symmetric tridiagonal matrix.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, lda, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: j, lwkopt
           integer(ilp) :: nb, mj, nj, k1, k2, j1, j2, j3, jb
           complex(sp) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! determine the block size
           nb = stdlib_ilaenv( 1, 'CSYTRF_AA', uplo, n, -1, -1, -1 )
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              lwkopt = (nb+1)*n
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYTRF_AA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return
           if ( n==0 ) then
               return
           endif
           ipiv( 1 ) = 1
           if ( n==1 ) then
              return
           end if
           ! adjust block size based on the workspace size
           if( lwork<((1+nb)*n) ) then
              nb = ( lwork-n ) / n
           end if
           if( upper ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              ! copy first row a(1, 1:n) into h(1:n) (stored in work(1:n))
              call stdlib_ccopy( n, a( 1, 1 ), lda, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_clasyf;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              10 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j + 1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_clasyf_aa( uplo, 2-k1, n-j, jb,a( max(1, j), j+1 ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_cswap( j1-k1-2, a( 1, j2 ), 1,a( 1, ipiv(j2) ), 1 )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
               ! the row a(j1-1, j2-1:n) stores u(j1, j2+1:n) and
               ! work stores the current block of the auxiriarly matrix h
              if( j<n ) then
                 ! if first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = a( j, j+1 )
                    a( j, j+1 ) = cone
                    call stdlib_ccopy( n-j, a( j-1, j+1 ), lda,work( (j+1-j1+1)+jb*n ), 1 )
                              
                    call stdlib_cscal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=1 and k2= 0 for the first panel,
                     ! while k1=0 and k2=1 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_cgemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_cgemv( 'NO TRANSPOSE', mj, jb+1,-cone, work( j3-j1+1+k1*n ),&
                                     n,a( j1-k2, j3 ), 1,cone, a( j3, j3 ), lda )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block of j2-th block row with stdlib_cgemm
                       call stdlib_cgemm( 'TRANSPOSE', 'TRANSPOSE',nj, n-j3+1, jb+1,-cone, a( j1-&
                                 k2, j2 ), lda,work( j3-j1+1+k1*n ), n,cone, a( j2, j3 ), lda )
                    end do
                    ! recover t( j, j+1 )
                    a( j, j+1 ) = alpha
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_ccopy( n-j, a( j+1, j+1 ), lda, work( 1 ), 1 )
              end if
              go to 10
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              ! copy first column a(1:n, 1) into h(1:n, 1)
               ! (stored in work(1:n))
              call stdlib_ccopy( n, a( 1, 1 ), 1, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_clasyf;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              11 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j+1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_clasyf_aa( uplo, 2-k1, n-j, jb,a( j+1, max(1, j) ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_cswap( j1-k1-2, a( j2, 1 ), lda,a( ipiv(j2), 1 ), lda )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
                ! a(j2+1, j1-1) stores l(j2+1, j1) and
                ! work(j2+1, 1) stores h(j2+1, 1)
              if( j<n ) then
                 ! if first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = a( j+1, j )
                    a( j+1, j ) = cone
                    call stdlib_ccopy( n-j, a( j+1, j-1 ), 1,work( (j+1-j1+1)+jb*n ), 1 )
                    call stdlib_cscal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=1 and k2= 0 for the first panel,
                     ! while k1=0 and k2=1 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_cgemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_cgemv( 'NO TRANSPOSE', mj, jb+1,-cone, work( j3-j1+1+k1*n ),&
                                     n,a( j3, j1-k2 ), lda,cone, a( j3, j3 ), 1 )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block in j2-th block column with stdlib_cgemm
                       call stdlib_cgemm( 'NO TRANSPOSE', 'TRANSPOSE',n-j3+1, nj, jb+1,-cone, &
                       work( j3-j1+1+k1*n ), n,a( j2, j1-k2 ), lda,cone, a( j3, j2 ), lda )
                                 
                    end do
                    ! recover t( j+1, j )
                    a( j+1, j ) = alpha
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_ccopy( n-j, a( j+1, j+1 ), 1, work( 1 ), 1 )
              end if
              go to 11
           end if
           20 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csytrf_aa

     module pure subroutine stdlib_zsytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
     !! ZSYTRF_AA computes the factorization of a complex symmetric matrix A
     !! using the Aasen's algorithm.  The form of the factorization is
     !! A = U**T*T*U  or  A = L*T*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is a complex symmetric tridiagonal matrix.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, lda, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: j, lwkopt
           integer(ilp) :: nb, mj, nj, k1, k2, j1, j2, j3, jb
           complex(dp) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! determine the block size
           nb = stdlib_ilaenv( 1, 'ZSYTRF_AA', uplo, n, -1, -1, -1 )
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              lwkopt = (nb+1)*n
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRF_AA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return
           if ( n==0 ) then
               return
           endif
           ipiv( 1 ) = 1
           if ( n==1 ) then
              return
           end if
           ! adjust block size based on the workspace size
           if( lwork<((1+nb)*n) ) then
              nb = ( lwork-n ) / n
           end if
           if( upper ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              ! copy first row a(1, 1:n) into h(1:n) (stored in work(1:n))
              call stdlib_zcopy( n, a( 1, 1 ), lda, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_zlasyf;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              10 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j + 1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_zlasyf_aa( uplo, 2-k1, n-j, jb,a( max(1, j), j+1 ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_zswap( j1-k1-2, a( 1, j2 ), 1,a( 1, ipiv(j2) ), 1 )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
               ! the row a(j1-1, j2-1:n) stores u(j1, j2+1:n) and
               ! work stores the current block of the auxiriarly matrix h
              if( j<n ) then
                 ! if first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = a( j, j+1 )
                    a( j, j+1 ) = cone
                    call stdlib_zcopy( n-j, a( j-1, j+1 ), lda,work( (j+1-j1+1)+jb*n ), 1 )
                              
                    call stdlib_zscal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=1 and k2= 0 for the first panel,
                     ! while k1=0 and k2=1 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_zgemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_zgemv( 'NO TRANSPOSE', mj, jb+1,-cone, work( j3-j1+1+k1*n ),&
                                     n,a( j1-k2, j3 ), 1,cone, a( j3, j3 ), lda )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block of j2-th block row with stdlib_zgemm
                       call stdlib_zgemm( 'TRANSPOSE', 'TRANSPOSE',nj, n-j3+1, jb+1,-cone, a( j1-&
                                 k2, j2 ), lda,work( j3-j1+1+k1*n ), n,cone, a( j2, j3 ), lda )
                    end do
                    ! recover t( j, j+1 )
                    a( j, j+1 ) = alpha
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_zcopy( n-j, a( j+1, j+1 ), lda, work( 1 ), 1 )
              end if
              go to 10
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              ! copy first column a(1:n, 1) into h(1:n, 1)
               ! (stored in work(1:n))
              call stdlib_zcopy( n, a( 1, 1 ), 1, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_zlasyf;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              11 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j+1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_zlasyf_aa( uplo, 2-k1, n-j, jb,a( j+1, max(1, j) ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_zswap( j1-k1-2, a( j2, 1 ), lda,a( ipiv(j2), 1 ), lda )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
                ! a(j2+1, j1-1) stores l(j2+1, j1) and
                ! work(j2+1, 1) stores h(j2+1, 1)
              if( j<n ) then
                 ! if first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = a( j+1, j )
                    a( j+1, j ) = cone
                    call stdlib_zcopy( n-j, a( j+1, j-1 ), 1,work( (j+1-j1+1)+jb*n ), 1 )
                    call stdlib_zscal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=1 and k2= 0 for the first panel,
                     ! while k1=0 and k2=1 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_zgemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_zgemv( 'NO TRANSPOSE', mj, jb+1,-cone, work( j3-j1+1+k1*n ),&
                                     n,a( j3, j1-k2 ), lda,cone, a( j3, j3 ), 1 )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block in j2-th block column with stdlib_zgemm
                       call stdlib_zgemm( 'NO TRANSPOSE', 'TRANSPOSE',n-j3+1, nj, jb+1,-cone, &
                       work( j3-j1+1+k1*n ), n,a( j2, j1-k2 ), lda,cone, a( j3, j2 ), lda )
                                 
                    end do
                    ! recover t( j+1, j )
                    a( j+1, j ) = alpha
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_zcopy( n-j, a( j+1, j+1 ), 1, work( 1 ), 1 )
              end if
              go to 11
           end if
           20 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zsytrf_aa

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info)
     !! ZSYTRF_AA: computes the factorization of a complex symmetric matrix A
     !! using the Aasen's algorithm.  The form of the factorization is
     !! A = U**T*T*U  or  A = L*T*L**T
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is a complex symmetric tridiagonal matrix.
     !! This is the blocked version of the algorithm, calling Level 3 BLAS.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, lda, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: j, lwkopt
           integer(ilp) :: nb, mj, nj, k1, k2, j1, j2, j3, jb
           complex(${ck}$) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! determine the block size
           nb = stdlib_ilaenv( 1, 'ZSYTRF_AA', uplo, n, -1, -1, -1 )
           ! test the input parameters.
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              lwkopt = (nb+1)*n
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYTRF_AA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return
           if ( n==0 ) then
               return
           endif
           ipiv( 1 ) = 1
           if ( n==1 ) then
              return
           end if
           ! adjust block size based on the workspace size
           if( lwork<((1+nb)*n) ) then
              nb = ( lwork-n ) / n
           end if
           if( upper ) then
              ! .....................................................
              ! factorize a as u**t*d*u using the upper triangle of a
              ! .....................................................
              ! copy first row a(1, 1:n) into h(1:n) (stored in work(1:n))
              call stdlib_${ci}$copy( n, a( 1, 1 ), lda, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_${ci}$lasyf;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              10 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j + 1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_${ci}$lasyf_aa( uplo, 2-k1, n-j, jb,a( max(1, j), j+1 ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_${ci}$swap( j1-k1-2, a( 1, j2 ), 1,a( 1, ipiv(j2) ), 1 )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
               ! the row a(j1-1, j2-1:n) stores u(j1, j2+1:n) and
               ! work stores the current block of the auxiriarly matrix h
              if( j<n ) then
                 ! if first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = a( j, j+1 )
                    a( j, j+1 ) = cone
                    call stdlib_${ci}$copy( n-j, a( j-1, j+1 ), lda,work( (j+1-j1+1)+jb*n ), 1 )
                              
                    call stdlib_${ci}$scal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=1 and k2= 0 for the first panel,
                     ! while k1=0 and k2=1 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_${ci}$gemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_${ci}$gemv( 'NO TRANSPOSE', mj, jb+1,-cone, work( j3-j1+1+k1*n ),&
                                     n,a( j1-k2, j3 ), 1,cone, a( j3, j3 ), lda )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block of j2-th block row with stdlib_${ci}$gemm
                       call stdlib_${ci}$gemm( 'TRANSPOSE', 'TRANSPOSE',nj, n-j3+1, jb+1,-cone, a( j1-&
                                 k2, j2 ), lda,work( j3-j1+1+k1*n ), n,cone, a( j2, j3 ), lda )
                    end do
                    ! recover t( j, j+1 )
                    a( j, j+1 ) = alpha
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_${ci}$copy( n-j, a( j+1, j+1 ), lda, work( 1 ), 1 )
              end if
              go to 10
           else
              ! .....................................................
              ! factorize a as l*d*l**t using the lower triangle of a
              ! .....................................................
              ! copy first column a(1:n, 1) into h(1:n, 1)
               ! (stored in work(1:n))
              call stdlib_${ci}$copy( n, a( 1, 1 ), 1, work( 1 ), 1 )
              ! j is the main loop index, increasing from 1 to n in steps of
              ! jb, where jb is the number of columns factorized by stdlib_${ci}$lasyf;
              ! jb is either nb, or n-j+1 for the last block
              j = 0
              11 continue
              if( j>=n )go to 20
              ! each step of the main loop
               ! j is the last column of the previous panel
               ! j1 is the first column of the current panel
               ! k1 identifies if the previous column of the panel has been
                ! explicitly stored, e.g., k1=1 for the first panel, and
                ! k1=0 for the rest
              j1 = j+1
              jb = min( n-j1+1, nb )
              k1 = max(1, j)-j
              ! panel factorization
              call stdlib_${ci}$lasyf_aa( uplo, 2-k1, n-j, jb,a( j+1, max(1, j) ), lda,ipiv( j+1 ), &
                        work, n, work( n*nb+1 ) )
              ! adjust ipiv and apply it back (j-th step picks (j+1)-th pivot)
              do j2 = j+2, min(n, j+jb+1)
                 ipiv( j2 ) = ipiv( j2 ) + j
                 if( (j2/=ipiv(j2)) .and. ((j1-k1)>2) ) then
                    call stdlib_${ci}$swap( j1-k1-2, a( j2, 1 ), lda,a( ipiv(j2), 1 ), lda )
                 end if
              end do
              j = j + jb
              ! trailing submatrix update, where
                ! a(j2+1, j1-1) stores l(j2+1, j1) and
                ! work(j2+1, 1) stores h(j2+1, 1)
              if( j<n ) then
                 ! if first panel and jb=1 (nb=1), then nothing to do
                 if( j1>1 .or. jb>1 ) then
                    ! merge rank-1 update with blas-3 update
                    alpha = a( j+1, j )
                    a( j+1, j ) = cone
                    call stdlib_${ci}$copy( n-j, a( j+1, j-1 ), 1,work( (j+1-j1+1)+jb*n ), 1 )
                    call stdlib_${ci}$scal( n-j, alpha, work( (j+1-j1+1)+jb*n ), 1 )
                    ! k1 identifies if the previous column of the panel has been
                     ! explicitly stored, e.g., k1=1 and k2= 0 for the first panel,
                     ! while k1=0 and k2=1 for the rest
                    if( j1>1 ) then
                       ! not first panel
                       k2 = 1
                    else
                       ! first panel
                       k2 = 0
                       ! first update skips the first column
                       jb = jb - 1
                    end if
                    do j2 = j+1, n, nb
                       nj = min( nb, n-j2+1 )
                       ! update (j2, j2) diagonal block with stdlib_${ci}$gemv
                       j3 = j2
                       do mj = nj-1, 1, -1
                          call stdlib_${ci}$gemv( 'NO TRANSPOSE', mj, jb+1,-cone, work( j3-j1+1+k1*n ),&
                                     n,a( j3, j1-k2 ), lda,cone, a( j3, j3 ), 1 )
                          j3 = j3 + 1
                       end do
                       ! update off-diagonal block in j2-th block column with stdlib_${ci}$gemm
                       call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'TRANSPOSE',n-j3+1, nj, jb+1,-cone, &
                       work( j3-j1+1+k1*n ), n,a( j2, j1-k2 ), lda,cone, a( j3, j2 ), lda )
                                 
                    end do
                    ! recover t( j+1, j )
                    a( j+1, j ) = alpha
                 end if
                 ! work(j+1, 1) stores h(j+1, 1)
                 call stdlib_${ci}$copy( n-j, a( j+1, j+1 ), 1, work( 1 ), 1 )
              end if
              go to 11
           end if
           20 continue
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$sytrf_aa

#:endif
#:endfor



     module pure subroutine stdlib_chetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
     !! CHETRS solves a system of linear equations A*X = B with a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by CHETRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*)
           complex(sp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           real(sp) :: s
           complex(sp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**h.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_cgeru( k-1, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=sp) / real( a( k, k ),KIND=sp)
                 call stdlib_csscal( nrhs, s, b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_cswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_cgeru( k-2, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 call stdlib_cgeru( k-2, nrhs, -cone, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ), &
                           ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / conjg( akm1k )
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / conjg( akm1k )
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**h *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**h(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**h(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k+1, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k+1 )&
                              , 1, cone, b( k+1, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**h.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_cgeru( n-k, nrhs, -cone, a( k+1, k ), 1, b( k, 1 ),ldb, b( &
                           k+1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=sp) / real( a( k, k ),KIND=sp)
                 call stdlib_csscal( nrhs, s, b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_cswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_cgeru( n-k-1, nrhs, -cone, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_cgeru( n-k-1, nrhs, -cone, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / conjg( akm1k )
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / conjg( akm1k )
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**h *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**h(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**h(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k-1, 1 ), ldb )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k-1 ), 1, cone,b( k-1, 1 ), ldb )
                    call stdlib_clacgv( nrhs, b( k-1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_cswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_chetrs

     module pure subroutine stdlib_zhetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
     !! ZHETRS solves a system of linear equations A*X = B with a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by ZHETRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: a(lda,*)
           complex(dp), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           real(dp) :: s
           complex(dp) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**h.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_zgeru( k-1, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=dp) / real( a( k, k ),KIND=dp)
                 call stdlib_zdscal( nrhs, s, b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_zswap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_zgeru( k-2, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 call stdlib_zgeru( k-2, nrhs, -cone, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ), &
                           ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / conjg( akm1k )
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / conjg( akm1k )
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**h *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**h(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 ) then
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**h(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k+1, 1 ), ldb )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k+1 )&
                              , 1, cone, b( k+1, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**h.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_zgeru( n-k, nrhs, -cone, a( k+1, k ), 1, b( k, 1 ),ldb, b( &
                           k+1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=dp) / real( a( k, k ),KIND=dp)
                 call stdlib_zdscal( nrhs, s, b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_zswap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_zgeru( n-k-1, nrhs, -cone, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_zgeru( n-k-1, nrhs, -cone, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / conjg( akm1k )
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / conjg( akm1k )
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**h *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**h(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n ) then
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**h(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k-1, 1 ), ldb )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k-1 ), 1, cone,b( k-1, 1 ), ldb )
                    call stdlib_zlacgv( nrhs, b( k-1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_zswap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_zhetrs

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
     !! ZHETRS: solves a system of linear equations A*X = B with a complex
     !! Hermitian matrix A using the factorization A = U*D*U**H or
     !! A = L*D*L**H computed by ZHETRF.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: a(lda,*)
           complex(${ck}$), intent(inout) :: b(ldb,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: j, k, kp
           real(${ck}$) :: s
           complex(${ck}$) :: ak, akm1, akm1k, bk, bkm1, denom
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRS', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. nrhs==0 )return
           if( upper ) then
              ! solve a*x = b, where a = u*d*u**h.
              ! first solve u*d*x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              10 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 30
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 call stdlib_${ci}$geru( k-1, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=${ck}$) / real( a( k, k ),KIND=${ck}$)
                 call stdlib_${ci}$dscal( nrhs, s, b( k, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k-1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k-1 )call stdlib_${ci}$swap( nrhs, b( k-1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(u(k)), where u(k) is the transformation
                 ! stored in columns k-1 and k of a.
                 call stdlib_${ci}$geru( k-2, nrhs, -cone, a( 1, k ), 1, b( k, 1 ), ldb,b( 1, 1 ), ldb &
                           )
                 call stdlib_${ci}$geru( k-2, nrhs, -cone, a( 1, k-1 ), 1, b( k-1, 1 ),ldb, b( 1, 1 ), &
                           ldb )
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k-1, k )
                 akm1 = a( k-1, k-1 ) / akm1k
                 ak = a( k, k ) / conjg( akm1k )
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k-1, j ) / akm1k
                    bk = b( k, j ) / conjg( akm1k )
                    b( k-1, j ) = ( ak*bkm1-bk ) / denom
                    b( k, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k - 2
              end if
              go to 10
              30 continue
              ! next solve u**h *x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              40 continue
              ! if k > n, exit from loop.
              if( k>n )go to 50
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(u**h(k)), where u(k) is the transformation
                 ! stored in column k of a.
                 if( k>1 ) then
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(u**h(k+1)), where u(k+1) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k>1 ) then
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k ), &
                              1, cone, b( k, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k+1, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', k-1, nrhs, -cone, b,ldb, a( 1, k+1 )&
                              , 1, cone, b( k+1, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k+1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k + 2
              end if
              go to 40
              50 continue
           else
              ! solve a*x = b, where a = l*d*l**h.
              ! first solve l*d*x = b, overwriting b with x.
              ! k is the main loop index, increasing from 1 to n in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = 1
              60 continue
              ! if k > n, exit from loop.
              if( k>n )go to 80
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n )call stdlib_${ci}$geru( n-k, nrhs, -cone, a( k+1, k ), 1, b( k, 1 ),ldb, b( &
                           k+1, 1 ), ldb )
                 ! multiply by the inverse of the diagonal block.
                 s = real( cone,KIND=${ck}$) / real( a( k, k ),KIND=${ck}$)
                 call stdlib_${ci}$dscal( nrhs, s, b( k, 1 ), ldb )
                 k = k + 1
              else
                 ! 2 x 2 diagonal block
                 ! interchange rows k+1 and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k+1 )call stdlib_${ci}$swap( nrhs, b( k+1, 1 ), ldb, b( kp, 1 ), ldb )
                 ! multiply by inv(l(k)), where l(k) is the transformation
                 ! stored in columns k and k+1 of a.
                 if( k<n-1 ) then
                    call stdlib_${ci}$geru( n-k-1, nrhs, -cone, a( k+2, k ), 1, b( k, 1 ),ldb, b( k+2, &
                              1 ), ldb )
                    call stdlib_${ci}$geru( n-k-1, nrhs, -cone, a( k+2, k+1 ), 1,b( k+1, 1 ), ldb, b( &
                              k+2, 1 ), ldb )
                 end if
                 ! multiply by the inverse of the diagonal block.
                 akm1k = a( k+1, k )
                 akm1 = a( k, k ) / conjg( akm1k )
                 ak = a( k+1, k+1 ) / akm1k
                 denom = akm1*ak - cone
                 do j = 1, nrhs
                    bkm1 = b( k, j ) / conjg( akm1k )
                    bk = b( k+1, j ) / akm1k
                    b( k, j ) = ( ak*bkm1-bk ) / denom
                    b( k+1, j ) = ( akm1*bk-bkm1 ) / denom
                 end do
                 k = k + 2
              end if
              go to 60
              80 continue
              ! next solve l**h *x = b, overwriting b with x.
              ! k is the main loop index, decreasing from n to 1 in steps of
              ! 1 or 2, depending on the size of the diagonal blocks.
              k = n
              90 continue
              ! if k < 1, exit from loop.
              if( k<1 )go to 100
              if( ipiv( k )>0 ) then
                 ! 1 x 1 diagonal block
                 ! multiply by inv(l**h(k)), where l(k) is the transformation
                 ! stored in column k of a.
                 if( k<n ) then
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                 end if
                 ! interchange rows k and ipiv(k).
                 kp = ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 1
              else
                 ! 2 x 2 diagonal block
                 ! multiply by inv(l**h(k-1)), where l(k-1) is the transformation
                 ! stored in columns k-1 and k of a.
                 if( k<n ) then
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k ), 1, cone,b( k, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k-1, 1 ), ldb )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', n-k, nrhs, -cone,b( k+1, 1 ), ldb, &
                              a( k+1, k-1 ), 1, cone,b( k-1, 1 ), ldb )
                    call stdlib_${ci}$lacgv( nrhs, b( k-1, 1 ), ldb )
                 end if
                 ! interchange rows k and -ipiv(k).
                 kp = -ipiv( k )
                 if( kp/=k )call stdlib_${ci}$swap( nrhs, b( k, 1 ), ldb, b( kp, 1 ), ldb )
                 k = k - 2
              end if
              go to 90
              100 continue
           end if
           return
     end subroutine stdlib_${ci}$hetrs

#:endif
#:endfor


end submodule stdlib_lapack_solve_ldl_comp
