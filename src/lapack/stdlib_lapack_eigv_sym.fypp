#:include "common.fypp" 
module stdlib_lapack_eigv_sym
  use stdlib_linalg_constants
  use stdlib_linalg_lapack_aux
  use stdlib_linalg_blas
  use stdlib_lapack_svd_drivers
  use stdlib_lapack_eigv_gen
  use stdlib_lapack_blas_like_mnorm
  use stdlib_lapack_householder_reflectors
  use stdlib_lapack_eigv_sym_comp
  use stdlib_lapack_orthogonal_factors_ql
  use stdlib_lapack_blas_like_l3
  implicit none(type,external)


  contains

     pure subroutine stdlib_cunmtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
     !! CUNMTR overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! nq-1 elementary reflectors, as returned by CHETRD:
     !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldc, lwork, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery, upper
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, ni, nq, nw
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'C' ) )&
                     then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, nq ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           else if( lwork<nw .and. .not.lquery ) then
              info = -12
           end if
           if( info==0 ) then
              if( upper ) then
                 if( left ) then
                    nb = stdlib_ilaenv( 1, 'CUNMQL', side // trans, m-1, n, m-1,-1 )
                 else
                    nb = stdlib_ilaenv( 1, 'CUNMQL', side // trans, m, n-1, n-1,-1 )
                 end if
              else
                 if( left ) then
                    nb = stdlib_ilaenv( 1, 'CUNMQR', side // trans, m-1, n, m-1,-1 )
                 else
                    nb = stdlib_ilaenv( 1, 'CUNMQR', side // trans, m, n-1, n-1,-1 )
                 end if
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNMTR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nq==1 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = m - 1
              ni = n
           else
              mi = m
              ni = n - 1
           end if
           if( upper ) then
              ! q was determined by a call to stdlib_chetrd with uplo = 'u'
              call stdlib_cunmql( side, trans, mi, ni, nq-1, a( 1, 2 ), lda, tau, c,ldc, work, &
                        lwork, iinfo )
           else
              ! q was determined by a call to stdlib_chetrd with uplo = 'l'
              if( left ) then
                 i1 = 2
                 i2 = 1
              else
                 i1 = 1
                 i2 = 2
              end if
              call stdlib_cunmqr( side, trans, mi, ni, nq-1, a( 2, 1 ), lda, tau,c( i1, i2 ), ldc,&
                         work, lwork, iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cunmtr

     pure subroutine stdlib_zunmtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
     !! ZUNMTR overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! nq-1 elementary reflectors, as returned by ZHETRD:
     !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldc, lwork, m, n
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*), c(ldc,*)
           complex(dp), intent(in) :: tau(*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery, upper
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, ni, nq, nw
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'C' ) )&
                     then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, nq ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           else if( lwork<nw .and. .not.lquery ) then
              info = -12
           end if
           if( info==0 ) then
              if( upper ) then
                 if( left ) then
                    nb = stdlib_ilaenv( 1, 'ZUNMQL', side // trans, m-1, n, m-1,-1 )
                 else
                    nb = stdlib_ilaenv( 1, 'ZUNMQL', side // trans, m, n-1, n-1,-1 )
                 end if
              else
                 if( left ) then
                    nb = stdlib_ilaenv( 1, 'ZUNMQR', side // trans, m-1, n, m-1,-1 )
                 else
                    nb = stdlib_ilaenv( 1, 'ZUNMQR', side // trans, m, n-1, n-1,-1 )
                 end if
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZUNMTR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nq==1 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = m - 1
              ni = n
           else
              mi = m
              ni = n - 1
           end if
           if( upper ) then
              ! q was determined by a call to stdlib_zhetrd with uplo = 'u'
              call stdlib_zunmql( side, trans, mi, ni, nq-1, a( 1, 2 ), lda, tau, c,ldc, work, &
                        lwork, iinfo )
           else
              ! q was determined by a call to stdlib_zhetrd with uplo = 'l'
              if( left ) then
                 i1 = 2
                 i2 = 1
              else
                 i1 = 1
                 i2 = 2
              end if
              call stdlib_zunmqr( side, trans, mi, ni, nq-1, a( 2, 1 ), lda, tau,c( i1, i2 ), ldc,&
                         work, lwork, iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zunmtr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$unmtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
     !! ZUNMTR: overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! nq-1 elementary reflectors, as returned by ZHETRD:
     !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldc, lwork, m, n
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*), c(ldc,*)
           complex(${ck}$), intent(in) :: tau(*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery, upper
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, ni, nq, nw
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'C' ) )&
                     then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, nq ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           else if( lwork<nw .and. .not.lquery ) then
              info = -12
           end if
           if( info==0 ) then
              if( upper ) then
                 if( left ) then
                    nb = stdlib_ilaenv( 1, 'ZUNMQL', side // trans, m-1, n, m-1,-1 )
                 else
                    nb = stdlib_ilaenv( 1, 'ZUNMQL', side // trans, m, n-1, n-1,-1 )
                 end if
              else
                 if( left ) then
                    nb = stdlib_ilaenv( 1, 'ZUNMQR', side // trans, m-1, n, m-1,-1 )
                 else
                    nb = stdlib_ilaenv( 1, 'ZUNMQR', side // trans, m, n-1, n-1,-1 )
                 end if
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZUNMTR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nq==1 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = m - 1
              ni = n
           else
              mi = m
              ni = n - 1
           end if
           if( upper ) then
              ! q was determined by a call to stdlib_${ci}$hetrd with uplo = 'u'
              call stdlib_${ci}$unmql( side, trans, mi, ni, nq-1, a( 1, 2 ), lda, tau, c,ldc, work, &
                        lwork, iinfo )
           else
              ! q was determined by a call to stdlib_${ci}$hetrd with uplo = 'l'
              if( left ) then
                 i1 = 2
                 i2 = 1
              else
                 i1 = 1
                 i2 = 2
              end if
              call stdlib_${ci}$unmqr( side, trans, mi, ni, nq-1, a( 2, 1 ), lda, tau,c( i1, i2 ), ldc,&
                         work, lwork, iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$unmtr

#:endif
#:endfor



     pure subroutine stdlib_slarrr( n, d, e, info )
     !! Perform tests to decide whether the symmetric tridiagonal matrix T
     !! warrants expensive computations which guarantee high relative accuracy
     !! in the eigenvalues.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(in) :: d(*)
           real(sp), intent(inout) :: e(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: relcond = 0.999_sp
           
           ! Local Scalars 
           integer(ilp) :: i
           logical(lk) :: yesrel
           real(sp) :: eps, safmin, smlnum, rmin, tmp, tmp2, offdig, offdig2
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              info = 0
              return
           end if
           ! as a default, do not go for relative-accuracy preserving computations.
           info = 1
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           eps = stdlib_slamch( 'PRECISION' )
           smlnum = safmin / eps
           rmin = sqrt( smlnum )
           ! tests for relative accuracy
           ! test for scaled diagonal dominance
           ! scale the diagonal entries to one and check whether the sum of the
           ! off-diagonals is less than one
           ! the sdd relative error bounds have a 1/(1- 2*x) factor in them,
           ! x = max(offdig + offdig2), so when x is close to 1/2, no relative
           ! accuracy is promised.  in the notation of the code fragment below,
           ! 1/(1 - (offdig + offdig2)) is the condition number.
           ! we don't think it is worth going into "sdd mode" unless the relative
           ! condition number is reasonable, not 1/macheps.
           ! the threshold should be compatible with other thresholds used in the
           ! code. we set  offdig + offdig2 <= .999_sp =: relcond, it corresponds
           ! to losing at most 3 decimal digits: 1 / (1 - (offdig + offdig2)) <= 1000
           ! instead of the current offdig + offdig2 < 1
           yesrel = .true.
           offdig = zero
           tmp = sqrt(abs(d(1)))
           if (tmp<rmin) yesrel = .false.
           if(.not.yesrel) goto 11
           do i = 2, n
              tmp2 = sqrt(abs(d(i)))
              if (tmp2<rmin) yesrel = .false.
              if(.not.yesrel) goto 11
              offdig2 = abs(e(i-1))/(tmp*tmp2)
              if(offdig+offdig2>=relcond) yesrel = .false.
              if(.not.yesrel) goto 11
              tmp = tmp2
              offdig = offdig2
           end do
           11 continue
           if( yesrel ) then
              info = 0
              return
           else
           endif
           ! *** more to be implemented ***
           ! test if the lower bidiagonal matrix l from t = l d l^t
           ! (zero shift facto) is well conditioned
           ! test if the upper bidiagonal matrix u from t = u d u^t
           ! (zero shift facto) is well conditioned.
           ! in this case, the matrix needs to be flipped and, at the end
           ! of the eigenvector computation, the flip needs to be applied
           ! to the computed eigenvectors (and the support)
           return
     end subroutine stdlib_slarrr

     pure subroutine stdlib_dlarrr( n, d, e, info )
     !! Perform tests to decide whether the symmetric tridiagonal matrix T
     !! warrants expensive computations which guarantee high relative accuracy
     !! in the eigenvalues.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(in) :: d(*)
           real(dp), intent(inout) :: e(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: relcond = 0.999_dp
           
           ! Local Scalars 
           integer(ilp) :: i
           logical(lk) :: yesrel
           real(dp) :: eps, safmin, smlnum, rmin, tmp, tmp2, offdig, offdig2
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              info = 0
              return
           end if
           ! as a default, do not go for relative-accuracy preserving computations.
           info = 1
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           eps = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin / eps
           rmin = sqrt( smlnum )
           ! tests for relative accuracy
           ! test for scaled diagonal dominance
           ! scale the diagonal entries to one and check whether the sum of the
           ! off-diagonals is less than one
           ! the sdd relative error bounds have a 1/(1- 2*x) factor in them,
           ! x = max(offdig + offdig2), so when x is close to 1/2, no relative
           ! accuracy is promised.  in the notation of the code fragment below,
           ! 1/(1 - (offdig + offdig2)) is the condition number.
           ! we don't think it is worth going into "sdd mode" unless the relative
           ! condition number is reasonable, not 1/macheps.
           ! the threshold should be compatible with other thresholds used in the
           ! code. we set  offdig + offdig2 <= .999_dp =: relcond, it corresponds
           ! to losing at most 3 decimal digits: 1 / (1 - (offdig + offdig2)) <= 1000
           ! instead of the current offdig + offdig2 < 1
           yesrel = .true.
           offdig = zero
           tmp = sqrt(abs(d(1)))
           if (tmp<rmin) yesrel = .false.
           if(.not.yesrel) goto 11
           do i = 2, n
              tmp2 = sqrt(abs(d(i)))
              if (tmp2<rmin) yesrel = .false.
              if(.not.yesrel) goto 11
              offdig2 = abs(e(i-1))/(tmp*tmp2)
              if(offdig+offdig2>=relcond) yesrel = .false.
              if(.not.yesrel) goto 11
              tmp = tmp2
              offdig = offdig2
           end do
           11 continue
           if( yesrel ) then
              info = 0
              return
           else
           endif
           ! *** more to be implemented ***
           ! test if the lower bidiagonal matrix l from t = l d l^t
           ! (zero shift facto) is well conditioned
           ! test if the upper bidiagonal matrix u from t = u d u^t
           ! (zero shift facto) is well conditioned.
           ! in this case, the matrix needs to be flipped and, at the end
           ! of the eigenvector computation, the flip needs to be applied
           ! to the computed eigenvectors (and the support)
           return
     end subroutine stdlib_dlarrr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$larrr( n, d, e, info )
     !! Perform tests to decide whether the symmetric tridiagonal matrix T
     !! warrants expensive computations which guarantee high relative accuracy
     !! in the eigenvalues.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(*)
           real(${rk}$), intent(inout) :: e(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: relcond = 0.999_${rk}$
           
           ! Local Scalars 
           integer(ilp) :: i
           logical(lk) :: yesrel
           real(${rk}$) :: eps, safmin, smlnum, rmin, tmp, tmp2, offdig, offdig2
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              info = 0
              return
           end if
           ! as a default, do not go for relative-accuracy preserving computations.
           info = 1
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           rmin = sqrt( smlnum )
           ! tests for relative accuracy
           ! test for scaled diagonal dominance
           ! scale the diagonal entries to one and check whether the sum of the
           ! off-diagonals is less than one
           ! the sdd relative error bounds have a 1/(1- 2*x) factor in them,
           ! x = max(offdig + offdig2), so when x is close to 1/2, no relative
           ! accuracy is promised.  in the notation of the code fragment below,
           ! 1/(1 - (offdig + offdig2)) is the condition number.
           ! we don't think it is worth going into "sdd mode" unless the relative
           ! condition number is reasonable, not 1/macheps.
           ! the threshold should be compatible with other thresholds used in the
           ! code. we set  offdig + offdig2 <= .999_${rk}$ =: relcond, it corresponds
           ! to losing at most 3 decimal digits: 1 / (1 - (offdig + offdig2)) <= 1000
           ! instead of the current offdig + offdig2 < 1
           yesrel = .true.
           offdig = zero
           tmp = sqrt(abs(d(1)))
           if (tmp<rmin) yesrel = .false.
           if(.not.yesrel) goto 11
           do i = 2, n
              tmp2 = sqrt(abs(d(i)))
              if (tmp2<rmin) yesrel = .false.
              if(.not.yesrel) goto 11
              offdig2 = abs(e(i-1))/(tmp*tmp2)
              if(offdig+offdig2>=relcond) yesrel = .false.
              if(.not.yesrel) goto 11
              tmp = tmp2
              offdig = offdig2
           end do
           11 continue
           if( yesrel ) then
              info = 0
              return
           else
           endif
           ! *** more to be implemented ***
           ! test if the lower bidiagonal matrix l from t = l d l^t
           ! (zero shift facto) is well conditioned
           ! test if the upper bidiagonal matrix u from t = u d u^t
           ! (zero shift facto) is well conditioned.
           ! in this case, the matrix needs to be flipped and, at the end
           ! of the eigenvector computation, the flip needs to be applied
           ! to the computed eigenvectors (and the support)
           return
     end subroutine stdlib_${ri}$larrr

#:endif
#:endfor



     pure subroutine stdlib_chetd2( uplo, n, a, lda, d, e, tau, info )
     !! CHETD2 reduces a complex Hermitian matrix A to real symmetric
     !! tridiagonal form T by a unitary similarity transformation:
     !! Q**H * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           complex(sp) :: alpha, taui
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETD2', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           if( upper ) then
              ! reduce the upper triangle of a
              a( n, n ) = real( a( n, n ),KIND=sp)
              do i = n - 1, 1, -1
                 ! generate elementary reflector h(i) = i - tau * v * v**h
                 ! to annihilate a(1:i-1,i+1)
                 alpha = a( i, i+1 )
                 call stdlib_clarfg( i, alpha, a( 1, i+1 ), 1, taui )
                 e( i ) = real( alpha,KIND=sp)
                 if( taui/=czero ) then
                    ! apply h(i) from both sides to a(1:i,1:i)
                    a( i, i+1 ) = cone
                    ! compute  x := tau * a * v  storing x in tau(1:i)
                    call stdlib_chemv( uplo, i, taui, a, lda, a( 1, i+1 ), 1, czero,tau, 1 )
                              
                    ! compute  w := x - 1/2 * tau * (x**h * v) * v
                    alpha = -chalf*taui*stdlib_cdotc( i, tau, 1, a( 1, i+1 ), 1 )
                    call stdlib_caxpy( i, alpha, a( 1, i+1 ), 1, tau, 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**h - w * v**h
                    call stdlib_cher2( uplo, i, -cone, a( 1, i+1 ), 1, tau, 1, a,lda )
                 else
                    a( i, i ) = real( a( i, i ),KIND=sp)
                 end if
                 a( i, i+1 ) = e( i )
                 d( i+1 ) = real( a( i+1, i+1 ),KIND=sp)
                 tau( i ) = taui
              end do
              d( 1 ) = real( a( 1, 1 ),KIND=sp)
           else
              ! reduce the lower triangle of a
              a( 1, 1 ) = real( a( 1, 1 ),KIND=sp)
              do i = 1, n - 1
                 ! generate elementary reflector h(i) = i - tau * v * v**h
                 ! to annihilate a(i+2:n,i)
                 alpha = a( i+1, i )
                 call stdlib_clarfg( n-i, alpha, a( min( i+2, n ), i ), 1, taui )
                 e( i ) = real( alpha,KIND=sp)
                 if( taui/=czero ) then
                    ! apply h(i) from both sides to a(i+1:n,i+1:n)
                    a( i+1, i ) = cone
                    ! compute  x := tau * a * v  storing y in tau(i:n-1)
                    call stdlib_chemv( uplo, n-i, taui, a( i+1, i+1 ), lda,a( i+1, i ), 1, czero, &
                              tau( i ), 1 )
                    ! compute  w := x - 1/2 * tau * (x**h * v) * v
                    alpha = -chalf*taui*stdlib_cdotc( n-i, tau( i ), 1, a( i+1, i ),1 )
                    call stdlib_caxpy( n-i, alpha, a( i+1, i ), 1, tau( i ), 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**h - w * v**h
                    call stdlib_cher2( uplo, n-i, -cone, a( i+1, i ), 1, tau( i ), 1,a( i+1, i+1 )&
                              , lda )
                 else
                    a( i+1, i+1 ) = real( a( i+1, i+1 ),KIND=sp)
                 end if
                 a( i+1, i ) = e( i )
                 d( i ) = real( a( i, i ),KIND=sp)
                 tau( i ) = taui
              end do
              d( n ) = real( a( n, n ),KIND=sp)
           end if
           return
     end subroutine stdlib_chetd2

     pure subroutine stdlib_zhetd2( uplo, n, a, lda, d, e, tau, info )
     !! ZHETD2 reduces a complex Hermitian matrix A to real symmetric
     !! tridiagonal form T by a unitary similarity transformation:
     !! Q**H * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(dp), intent(out) :: d(*), e(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: tau(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           complex(dp) :: alpha, taui
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U')
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETD2', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           if( upper ) then
              ! reduce the upper triangle of a
              a( n, n ) = real( a( n, n ),KIND=dp)
              do i = n - 1, 1, -1
                 ! generate elementary reflector h(i) = i - tau * v * v**h
                 ! to annihilate a(1:i-1,i+1)
                 alpha = a( i, i+1 )
                 call stdlib_zlarfg( i, alpha, a( 1, i+1 ), 1, taui )
                 e( i ) = real( alpha,KIND=dp)
                 if( taui/=czero ) then
                    ! apply h(i) from both sides to a(1:i,1:i)
                    a( i, i+1 ) = cone
                    ! compute  x := tau * a * v  storing x in tau(1:i)
                    call stdlib_zhemv( uplo, i, taui, a, lda, a( 1, i+1 ), 1, czero,tau, 1 )
                              
                    ! compute  w := x - 1/2 * tau * (x**h * v) * v
                    alpha = -chalf*taui*stdlib_zdotc( i, tau, 1, a( 1, i+1 ), 1 )
                    call stdlib_zaxpy( i, alpha, a( 1, i+1 ), 1, tau, 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**h - w * v**h
                    call stdlib_zher2( uplo, i, -cone, a( 1, i+1 ), 1, tau, 1, a,lda )
                 else
                    a( i, i ) = real( a( i, i ),KIND=dp)
                 end if
                 a( i, i+1 ) = e( i )
                 d( i+1 ) = real( a( i+1, i+1 ),KIND=dp)
                 tau( i ) = taui
              end do
              d( 1 ) = real( a( 1, 1 ),KIND=dp)
           else
              ! reduce the lower triangle of a
              a( 1, 1 ) = real( a( 1, 1 ),KIND=dp)
              do i = 1, n - 1
                 ! generate elementary reflector h(i) = i - tau * v * v**h
                 ! to annihilate a(i+2:n,i)
                 alpha = a( i+1, i )
                 call stdlib_zlarfg( n-i, alpha, a( min( i+2, n ), i ), 1, taui )
                 e( i ) = real( alpha,KIND=dp)
                 if( taui/=czero ) then
                    ! apply h(i) from both sides to a(i+1:n,i+1:n)
                    a( i+1, i ) = cone
                    ! compute  x := tau * a * v  storing y in tau(i:n-1)
                    call stdlib_zhemv( uplo, n-i, taui, a( i+1, i+1 ), lda,a( i+1, i ), 1, czero, &
                              tau( i ), 1 )
                    ! compute  w := x - 1/2 * tau * (x**h * v) * v
                    alpha = -chalf*taui*stdlib_zdotc( n-i, tau( i ), 1, a( i+1, i ),1 )
                    call stdlib_zaxpy( n-i, alpha, a( i+1, i ), 1, tau( i ), 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**h - w * v**h
                    call stdlib_zher2( uplo, n-i, -cone, a( i+1, i ), 1, tau( i ), 1,a( i+1, i+1 )&
                              , lda )
                 else
                    a( i+1, i+1 ) = real( a( i+1, i+1 ),KIND=dp)
                 end if
                 a( i+1, i ) = e( i )
                 d( i ) = real( a( i, i ),KIND=dp)
                 tau( i ) = taui
              end do
              d( n ) = real( a( n, n ),KIND=dp)
           end if
           return
     end subroutine stdlib_zhetd2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$hetd2( uplo, n, a, lda, d, e, tau, info )
     !! ZHETD2: reduces a complex Hermitian matrix A to real symmetric
     !! tridiagonal form T by a unitary similarity transformation:
     !! Q**H * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(${ck}$), intent(out) :: d(*), e(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: tau(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           complex(${ck}$) :: alpha, taui
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U')
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETD2', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           if( upper ) then
              ! reduce the upper triangle of a
              a( n, n ) = real( a( n, n ),KIND=${ck}$)
              do i = n - 1, 1, -1
                 ! generate elementary reflector h(i) = i - tau * v * v**h
                 ! to annihilate a(1:i-1,i+1)
                 alpha = a( i, i+1 )
                 call stdlib_${ci}$larfg( i, alpha, a( 1, i+1 ), 1, taui )
                 e( i ) = real( alpha,KIND=${ck}$)
                 if( taui/=czero ) then
                    ! apply h(i) from both sides to a(1:i,1:i)
                    a( i, i+1 ) = cone
                    ! compute  x := tau * a * v  storing x in tau(1:i)
                    call stdlib_${ci}$hemv( uplo, i, taui, a, lda, a( 1, i+1 ), 1, czero,tau, 1 )
                              
                    ! compute  w := x - 1/2 * tau * (x**h * v) * v
                    alpha = -chalf*taui*stdlib_${ci}$dotc( i, tau, 1, a( 1, i+1 ), 1 )
                    call stdlib_${ci}$axpy( i, alpha, a( 1, i+1 ), 1, tau, 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**h - w * v**h
                    call stdlib_${ci}$her2( uplo, i, -cone, a( 1, i+1 ), 1, tau, 1, a,lda )
                 else
                    a( i, i ) = real( a( i, i ),KIND=${ck}$)
                 end if
                 a( i, i+1 ) = e( i )
                 d( i+1 ) = real( a( i+1, i+1 ),KIND=${ck}$)
                 tau( i ) = taui
              end do
              d( 1 ) = real( a( 1, 1 ),KIND=${ck}$)
           else
              ! reduce the lower triangle of a
              a( 1, 1 ) = real( a( 1, 1 ),KIND=${ck}$)
              do i = 1, n - 1
                 ! generate elementary reflector h(i) = i - tau * v * v**h
                 ! to annihilate a(i+2:n,i)
                 alpha = a( i+1, i )
                 call stdlib_${ci}$larfg( n-i, alpha, a( min( i+2, n ), i ), 1, taui )
                 e( i ) = real( alpha,KIND=${ck}$)
                 if( taui/=czero ) then
                    ! apply h(i) from both sides to a(i+1:n,i+1:n)
                    a( i+1, i ) = cone
                    ! compute  x := tau * a * v  storing y in tau(i:n-1)
                    call stdlib_${ci}$hemv( uplo, n-i, taui, a( i+1, i+1 ), lda,a( i+1, i ), 1, czero, &
                              tau( i ), 1 )
                    ! compute  w := x - 1/2 * tau * (x**h * v) * v
                    alpha = -chalf*taui*stdlib_${ci}$dotc( n-i, tau( i ), 1, a( i+1, i ),1 )
                    call stdlib_${ci}$axpy( n-i, alpha, a( i+1, i ), 1, tau( i ), 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**h - w * v**h
                    call stdlib_${ci}$her2( uplo, n-i, -cone, a( i+1, i ), 1, tau( i ), 1,a( i+1, i+1 )&
                              , lda )
                 else
                    a( i+1, i+1 ) = real( a( i+1, i+1 ),KIND=${ck}$)
                 end if
                 a( i+1, i ) = e( i )
                 d( i ) = real( a( i, i ),KIND=${ck}$)
                 tau( i ) = taui
              end do
              d( n ) = real( a( n, n ),KIND=${ck}$)
           end if
           return
     end subroutine stdlib_${ci}$hetd2

#:endif
#:endfor



     pure subroutine stdlib_slarrc( jobt, n, vl, vu, d, e, pivmin,eigcnt, lcnt, rcnt, info )
     !! Find the number of eigenvalues of the symmetric tridiagonal matrix T
     !! that are in the interval (VL,VU] if JOBT = 'T', and of L D L^T
     !! if JOBT = 'L'.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobt
           integer(ilp), intent(out) :: eigcnt, info, lcnt, rcnt
           integer(ilp), intent(in) :: n
           real(sp), intent(in) :: pivmin, vl, vu
           ! Array Arguments 
           real(sp), intent(in) :: d(*), e(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           logical(lk) :: matt
           real(sp) :: lpivot, rpivot, sl, su, tmp, tmp2
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           lcnt = 0
           rcnt = 0
           eigcnt = 0
           matt = stdlib_lsame( jobt, 'T' )
           if (matt) then
              ! sturm sequence count on t
              lpivot = d( 1 ) - vl
              rpivot = d( 1 ) - vu
              if( lpivot<=zero ) then
                 lcnt = lcnt + 1
              endif
              if( rpivot<=zero ) then
                 rcnt = rcnt + 1
              endif
              do i = 1, n-1
                 tmp = e(i)**2
                 lpivot = ( d( i+1 )-vl ) - tmp/lpivot
                 rpivot = ( d( i+1 )-vu ) - tmp/rpivot
                 if( lpivot<=zero ) then
                    lcnt = lcnt + 1
                 endif
                 if( rpivot<=zero ) then
                    rcnt = rcnt + 1
                 endif
              end do
           else
              ! sturm sequence count on l d l^t
              sl = -vl
              su = -vu
              do i = 1, n - 1
                 lpivot = d( i ) + sl
                 rpivot = d( i ) + su
                 if( lpivot<=zero ) then
                    lcnt = lcnt + 1
                 endif
                 if( rpivot<=zero ) then
                    rcnt = rcnt + 1
                 endif
                 tmp = e(i) * d(i) * e(i)
                 tmp2 = tmp / lpivot
                 if( tmp2==zero ) then
                    sl =  tmp - vl
                 else
                    sl = sl*tmp2 - vl
                 end if
                 tmp2 = tmp / rpivot
                 if( tmp2==zero ) then
                    su =  tmp - vu
                 else
                    su = su*tmp2 - vu
                 end if
              end do
              lpivot = d( n ) + sl
              rpivot = d( n ) + su
              if( lpivot<=zero ) then
                 lcnt = lcnt + 1
              endif
              if( rpivot<=zero ) then
                 rcnt = rcnt + 1
              endif
           endif
           eigcnt = rcnt - lcnt
           return
     end subroutine stdlib_slarrc

     pure subroutine stdlib_dlarrc( jobt, n, vl, vu, d, e, pivmin,eigcnt, lcnt, rcnt, info )
     !! Find the number of eigenvalues of the symmetric tridiagonal matrix T
     !! that are in the interval (VL,VU] if JOBT = 'T', and of L D L^T
     !! if JOBT = 'L'.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobt
           integer(ilp), intent(out) :: eigcnt, info, lcnt, rcnt
           integer(ilp), intent(in) :: n
           real(dp), intent(in) :: pivmin, vl, vu
           ! Array Arguments 
           real(dp), intent(in) :: d(*), e(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           logical(lk) :: matt
           real(dp) :: lpivot, rpivot, sl, su, tmp, tmp2
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           lcnt = 0
           rcnt = 0
           eigcnt = 0
           matt = stdlib_lsame( jobt, 'T' )
           if (matt) then
              ! sturm sequence count on t
              lpivot = d( 1 ) - vl
              rpivot = d( 1 ) - vu
              if( lpivot<=zero ) then
                 lcnt = lcnt + 1
              endif
              if( rpivot<=zero ) then
                 rcnt = rcnt + 1
              endif
              do i = 1, n-1
                 tmp = e(i)**2
                 lpivot = ( d( i+1 )-vl ) - tmp/lpivot
                 rpivot = ( d( i+1 )-vu ) - tmp/rpivot
                 if( lpivot<=zero ) then
                    lcnt = lcnt + 1
                 endif
                 if( rpivot<=zero ) then
                    rcnt = rcnt + 1
                 endif
              end do
           else
              ! sturm sequence count on l d l^t
              sl = -vl
              su = -vu
              do i = 1, n - 1
                 lpivot = d( i ) + sl
                 rpivot = d( i ) + su
                 if( lpivot<=zero ) then
                    lcnt = lcnt + 1
                 endif
                 if( rpivot<=zero ) then
                    rcnt = rcnt + 1
                 endif
                 tmp = e(i) * d(i) * e(i)
                 tmp2 = tmp / lpivot
                 if( tmp2==zero ) then
                    sl =  tmp - vl
                 else
                    sl = sl*tmp2 - vl
                 end if
                 tmp2 = tmp / rpivot
                 if( tmp2==zero ) then
                    su =  tmp - vu
                 else
                    su = su*tmp2 - vu
                 end if
              end do
              lpivot = d( n ) + sl
              rpivot = d( n ) + su
              if( lpivot<=zero ) then
                 lcnt = lcnt + 1
              endif
              if( rpivot<=zero ) then
                 rcnt = rcnt + 1
              endif
           endif
           eigcnt = rcnt - lcnt
           return
     end subroutine stdlib_dlarrc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$larrc( jobt, n, vl, vu, d, e, pivmin,eigcnt, lcnt, rcnt, info )
     !! Find the number of eigenvalues of the symmetric tridiagonal matrix T
     !! that are in the interval (VL,VU] if JOBT = 'T', and of L D L^T
     !! if JOBT = 'L'.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobt
           integer(ilp), intent(out) :: eigcnt, info, lcnt, rcnt
           integer(ilp), intent(in) :: n
           real(${rk}$), intent(in) :: pivmin, vl, vu
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(*), e(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           logical(lk) :: matt
           real(${rk}$) :: lpivot, rpivot, sl, su, tmp, tmp2
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           lcnt = 0
           rcnt = 0
           eigcnt = 0
           matt = stdlib_lsame( jobt, 'T' )
           if (matt) then
              ! sturm sequence count on t
              lpivot = d( 1 ) - vl
              rpivot = d( 1 ) - vu
              if( lpivot<=zero ) then
                 lcnt = lcnt + 1
              endif
              if( rpivot<=zero ) then
                 rcnt = rcnt + 1
              endif
              do i = 1, n-1
                 tmp = e(i)**2
                 lpivot = ( d( i+1 )-vl ) - tmp/lpivot
                 rpivot = ( d( i+1 )-vu ) - tmp/rpivot
                 if( lpivot<=zero ) then
                    lcnt = lcnt + 1
                 endif
                 if( rpivot<=zero ) then
                    rcnt = rcnt + 1
                 endif
              end do
           else
              ! sturm sequence count on l d l^t
              sl = -vl
              su = -vu
              do i = 1, n - 1
                 lpivot = d( i ) + sl
                 rpivot = d( i ) + su
                 if( lpivot<=zero ) then
                    lcnt = lcnt + 1
                 endif
                 if( rpivot<=zero ) then
                    rcnt = rcnt + 1
                 endif
                 tmp = e(i) * d(i) * e(i)
                 tmp2 = tmp / lpivot
                 if( tmp2==zero ) then
                    sl =  tmp - vl
                 else
                    sl = sl*tmp2 - vl
                 end if
                 tmp2 = tmp / rpivot
                 if( tmp2==zero ) then
                    su =  tmp - vu
                 else
                    su = su*tmp2 - vu
                 end if
              end do
              lpivot = d( n ) + sl
              rpivot = d( n ) + su
              if( lpivot<=zero ) then
                 lcnt = lcnt + 1
              endif
              if( rpivot<=zero ) then
                 rcnt = rcnt + 1
              endif
           endif
           eigcnt = rcnt - lcnt
           return
     end subroutine stdlib_${ri}$larrc

#:endif
#:endfor



     pure subroutine stdlib_slaed2( k, n, n1, d, q, ldq, indxq, rho, z, dlamda, w,q2, indx, indxc,&
     !! SLAED2 merges the two sets of eigenvalues together into a single
     !! sorted set.  Then it tries to deflate the size of the problem.
     !! There are two ways in which deflation can occur:  when two or more
     !! eigenvalues are close together or if there is a tiny entry in the
     !! Z vector.  For each such occurrence the order of the related secular
     !! equation problem is reduced by one.
                indxp, coltyp, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info, k
           integer(ilp), intent(in) :: ldq, n, n1
           real(sp), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(out) :: coltyp(*), indx(*), indxc(*), indxp(*)
           integer(ilp), intent(inout) :: indxq(*)
           real(sp), intent(inout) :: d(*), q(ldq,*), z(*)
           real(sp), intent(out) :: dlamda(*), q2(*), w(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: mone = -1.0_sp
           
           ! Local Arrays 
           integer(ilp) :: ctot(4), psm(4)
           ! Local Scalars 
           integer(ilp) :: ct, i, imax, iq1, iq2, j, jmax, js, k2, n1p1, n2, nj, pj
           real(sp) :: c, eps, s, t, tau, tol
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           else if( min( 1, ( n / 2 ) )>n1 .or. ( n / 2 )<n1 ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SLAED2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           n2 = n - n1
           n1p1 = n1 + 1
           if( rho<zero ) then
              call stdlib_sscal( n2, mone, z( n1p1 ), 1 )
           end if
           ! normalize z so that norm(z) = 1.  since z is the concatenation of
           ! two normalized vectors, norm2(z) = sqrt(2).
           t = one / sqrt( two )
           call stdlib_sscal( n, t, z, 1 )
           ! rho = abs( norm(z)**2 * rho )
           rho = abs( two*rho )
           ! sort the eigenvalues into increasing order
           do i = n1p1, n
              indxq( i ) = indxq( i ) + n1
           end do
           ! re-integrate the deflated parts from the last pass
           do i = 1, n
              dlamda( i ) = d( indxq( i ) )
           end do
           call stdlib_slamrg( n1, n2, dlamda, 1, 1, indxc )
           do i = 1, n
              indx( i ) = indxq( indxc( i ) )
           end do
           ! calculate the allowable deflation tolerance
           imax = stdlib_isamax( n, z, 1 )
           jmax = stdlib_isamax( n, d, 1 )
           eps = stdlib_slamch( 'EPSILON' )
           tol = eight*eps*max( abs( d( jmax ) ), abs( z( imax ) ) )
           ! if the rank-1 modifier is small enough, no more needs to be done
           ! except to reorganize q so that its columns correspond with the
           ! elements in d.
           if( rho*abs( z( imax ) )<=tol ) then
              k = 0
              iq2 = 1
              do j = 1, n
                 i = indx( j )
                 call stdlib_scopy( n, q( 1, i ), 1, q2( iq2 ), 1 )
                 dlamda( j ) = d( i )
                 iq2 = iq2 + n
              end do
              call stdlib_slacpy( 'A', n, n, q2, n, q, ldq )
              call stdlib_scopy( n, dlamda, 1, d, 1 )
              go to 190
           end if
           ! if there are multiple eigenvalues then the problem deflates.  here
           ! the number of equal eigenvalues are found.  as each equal
           ! eigenvalue is found, an elementary reflector is computed to rotate
           ! the corresponding eigensubspace so that the corresponding
           ! components of z are zero in this new basis.
           do i = 1, n1
              coltyp( i ) = 1
           end do
           do i = n1p1, n
              coltyp( i ) = 3
           end do
           k = 0
           k2 = n + 1
           do j = 1, n
              nj = indx( j )
              if( rho*abs( z( nj ) )<=tol ) then
                 ! deflate due to small z component.
                 k2 = k2 - 1
                 coltyp( nj ) = 4
                 indxp( k2 ) = nj
                 if( j==n )go to 100
              else
                 pj = nj
                 go to 80
              end if
           end do
           80 continue
           j = j + 1
           nj = indx( j )
           if( j>n )go to 100
           if( rho*abs( z( nj ) )<=tol ) then
              ! deflate due to small z component.
              k2 = k2 - 1
              coltyp( nj ) = 4
              indxp( k2 ) = nj
           else
              ! check if eigenvalues are close enough to allow deflation.
              s = z( pj )
              c = z( nj )
              ! find sqrt(a**2+b**2) without overflow or
              ! destructive underflow.
              tau = stdlib_slapy2( c, s )
              t = d( nj ) - d( pj )
              c = c / tau
              s = -s / tau
              if( abs( t*c*s )<=tol ) then
                 ! deflation is possible.
                 z( nj ) = tau
                 z( pj ) = zero
                 if( coltyp( nj )/=coltyp( pj ) )coltyp( nj ) = 2
                 coltyp( pj ) = 4
                 call stdlib_srot( n, q( 1, pj ), 1, q( 1, nj ), 1, c, s )
                 t = d( pj )*c**2 + d( nj )*s**2
                 d( nj ) = d( pj )*s**2 + d( nj )*c**2
                 d( pj ) = t
                 k2 = k2 - 1
                 i = 1
                 90 continue
                 if( k2+i<=n ) then
                    if( d( pj )<d( indxp( k2+i ) ) ) then
                       indxp( k2+i-1 ) = indxp( k2+i )
                       indxp( k2+i ) = pj
                       i = i + 1
                       go to 90
                    else
                       indxp( k2+i-1 ) = pj
                    end if
                 else
                    indxp( k2+i-1 ) = pj
                 end if
                 pj = nj
              else
                 k = k + 1
                 dlamda( k ) = d( pj )
                 w( k ) = z( pj )
                 indxp( k ) = pj
                 pj = nj
              end if
           end if
           go to 80
           100 continue
           ! record the last eigenvalue.
           k = k + 1
           dlamda( k ) = d( pj )
           w( k ) = z( pj )
           indxp( k ) = pj
           ! count up the total number of the various types of columns, then
           ! form a permutation which positions the four column types into
           ! four uniform groups (although one or more of these groups may be
           ! empty).
           do j = 1, 4
              ctot( j ) = 0
           end do
           do j = 1, n
              ct = coltyp( j )
              ctot( ct ) = ctot( ct ) + 1
           end do
           ! psm(*) = position in submatrix (of types 1 through 4)
           psm( 1 ) = 1
           psm( 2 ) = 1 + ctot( 1 )
           psm( 3 ) = psm( 2 ) + ctot( 2 )
           psm( 4 ) = psm( 3 ) + ctot( 3 )
           k = n - ctot( 4 )
           ! fill out the indxc array so that the permutation which it induces
           ! will place all type-1 columns first, all type-2 columns next,
           ! then all type-3's, and finally all type-4's.
           do j = 1, n
              js = indxp( j )
              ct = coltyp( js )
              indx( psm( ct ) ) = js
              indxc( psm( ct ) ) = j
              psm( ct ) = psm( ct ) + 1
           end do
           ! sort the eigenvalues and corresponding eigenvectors into dlamda
           ! and q2 respectively.  the eigenvalues/vectors which were not
           ! deflated go into the first k slots of dlamda and q2 respectively,
           ! while those which were deflated go into the last n - k slots.
           i = 1
           iq1 = 1
           iq2 = 1 + ( ctot( 1 )+ctot( 2 ) )*n1
           do j = 1, ctot( 1 )
              js = indx( i )
              call stdlib_scopy( n1, q( 1, js ), 1, q2( iq1 ), 1 )
              z( i ) = d( js )
              i = i + 1
              iq1 = iq1 + n1
           end do
           do j = 1, ctot( 2 )
              js = indx( i )
              call stdlib_scopy( n1, q( 1, js ), 1, q2( iq1 ), 1 )
              call stdlib_scopy( n2, q( n1+1, js ), 1, q2( iq2 ), 1 )
              z( i ) = d( js )
              i = i + 1
              iq1 = iq1 + n1
              iq2 = iq2 + n2
           end do
           do j = 1, ctot( 3 )
              js = indx( i )
              call stdlib_scopy( n2, q( n1+1, js ), 1, q2( iq2 ), 1 )
              z( i ) = d( js )
              i = i + 1
              iq2 = iq2 + n2
           end do
           iq1 = iq2
           do j = 1, ctot( 4 )
              js = indx( i )
              call stdlib_scopy( n, q( 1, js ), 1, q2( iq2 ), 1 )
              iq2 = iq2 + n
              z( i ) = d( js )
              i = i + 1
           end do
           ! the deflated eigenvalues and their corresponding vectors go back
           ! into the last n - k slots of d and q respectively.
           if( k<n ) then
              call stdlib_slacpy( 'A', n, ctot( 4 ), q2( iq1 ), n,q( 1, k+1 ), ldq )
              call stdlib_scopy( n-k, z( k+1 ), 1, d( k+1 ), 1 )
           end if
           ! copy ctot into coltyp for referencing in stdlib_slaed3.
           do j = 1, 4
              coltyp( j ) = ctot( j )
           end do
           190 continue
           return
     end subroutine stdlib_slaed2

     pure subroutine stdlib_dlaed2( k, n, n1, d, q, ldq, indxq, rho, z, dlamda, w,q2, indx, indxc,&
     !! DLAED2 merges the two sets of eigenvalues together into a single
     !! sorted set.  Then it tries to deflate the size of the problem.
     !! There are two ways in which deflation can occur:  when two or more
     !! eigenvalues are close together or if there is a tiny entry in the
     !! Z vector.  For each such occurrence the order of the related secular
     !! equation problem is reduced by one.
                indxp, coltyp, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info, k
           integer(ilp), intent(in) :: ldq, n, n1
           real(dp), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(out) :: coltyp(*), indx(*), indxc(*), indxp(*)
           integer(ilp), intent(inout) :: indxq(*)
           real(dp), intent(inout) :: d(*), q(ldq,*), z(*)
           real(dp), intent(out) :: dlamda(*), q2(*), w(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: mone = -1.0_dp
           
           ! Local Arrays 
           integer(ilp) :: ctot(4), psm(4)
           ! Local Scalars 
           integer(ilp) :: ct, i, imax, iq1, iq2, j, jmax, js, k2, n1p1, n2, nj, pj
           real(dp) :: c, eps, s, t, tau, tol
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           else if( min( 1, ( n / 2 ) )>n1 .or. ( n / 2 )<n1 ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           n2 = n - n1
           n1p1 = n1 + 1
           if( rho<zero ) then
              call stdlib_dscal( n2, mone, z( n1p1 ), 1 )
           end if
           ! normalize z so that norm(z) = 1.  since z is the concatenation of
           ! two normalized vectors, norm2(z) = sqrt(2).
           t = one / sqrt( two )
           call stdlib_dscal( n, t, z, 1 )
           ! rho = abs( norm(z)**2 * rho )
           rho = abs( two*rho )
           ! sort the eigenvalues into increasing order
           do i = n1p1, n
              indxq( i ) = indxq( i ) + n1
           end do
           ! re-integrate the deflated parts from the last pass
           do i = 1, n
              dlamda( i ) = d( indxq( i ) )
           end do
           call stdlib_dlamrg( n1, n2, dlamda, 1, 1, indxc )
           do i = 1, n
              indx( i ) = indxq( indxc( i ) )
           end do
           ! calculate the allowable deflation tolerance
           imax = stdlib_idamax( n, z, 1 )
           jmax = stdlib_idamax( n, d, 1 )
           eps = stdlib_dlamch( 'EPSILON' )
           tol = eight*eps*max( abs( d( jmax ) ), abs( z( imax ) ) )
           ! if the rank-1 modifier is small enough, no more needs to be done
           ! except to reorganize q so that its columns correspond with the
           ! elements in d.
           if( rho*abs( z( imax ) )<=tol ) then
              k = 0
              iq2 = 1
              do j = 1, n
                 i = indx( j )
                 call stdlib_dcopy( n, q( 1, i ), 1, q2( iq2 ), 1 )
                 dlamda( j ) = d( i )
                 iq2 = iq2 + n
              end do
              call stdlib_dlacpy( 'A', n, n, q2, n, q, ldq )
              call stdlib_dcopy( n, dlamda, 1, d, 1 )
              go to 190
           end if
           ! if there are multiple eigenvalues then the problem deflates.  here
           ! the number of equal eigenvalues are found.  as each equal
           ! eigenvalue is found, an elementary reflector is computed to rotate
           ! the corresponding eigensubspace so that the corresponding
           ! components of z are zero in this new basis.
           do i = 1, n1
              coltyp( i ) = 1
           end do
           do i = n1p1, n
              coltyp( i ) = 3
           end do
           k = 0
           k2 = n + 1
           do j = 1, n
              nj = indx( j )
              if( rho*abs( z( nj ) )<=tol ) then
                 ! deflate due to small z component.
                 k2 = k2 - 1
                 coltyp( nj ) = 4
                 indxp( k2 ) = nj
                 if( j==n )go to 100
              else
                 pj = nj
                 go to 80
              end if
           end do
           80 continue
           j = j + 1
           nj = indx( j )
           if( j>n )go to 100
           if( rho*abs( z( nj ) )<=tol ) then
              ! deflate due to small z component.
              k2 = k2 - 1
              coltyp( nj ) = 4
              indxp( k2 ) = nj
           else
              ! check if eigenvalues are close enough to allow deflation.
              s = z( pj )
              c = z( nj )
              ! find sqrt(a**2+b**2) without overflow or
              ! destructive underflow.
              tau = stdlib_dlapy2( c, s )
              t = d( nj ) - d( pj )
              c = c / tau
              s = -s / tau
              if( abs( t*c*s )<=tol ) then
                 ! deflation is possible.
                 z( nj ) = tau
                 z( pj ) = zero
                 if( coltyp( nj )/=coltyp( pj ) )coltyp( nj ) = 2
                 coltyp( pj ) = 4
                 call stdlib_drot( n, q( 1, pj ), 1, q( 1, nj ), 1, c, s )
                 t = d( pj )*c**2 + d( nj )*s**2
                 d( nj ) = d( pj )*s**2 + d( nj )*c**2
                 d( pj ) = t
                 k2 = k2 - 1
                 i = 1
                 90 continue
                 if( k2+i<=n ) then
                    if( d( pj )<d( indxp( k2+i ) ) ) then
                       indxp( k2+i-1 ) = indxp( k2+i )
                       indxp( k2+i ) = pj
                       i = i + 1
                       go to 90
                    else
                       indxp( k2+i-1 ) = pj
                    end if
                 else
                    indxp( k2+i-1 ) = pj
                 end if
                 pj = nj
              else
                 k = k + 1
                 dlamda( k ) = d( pj )
                 w( k ) = z( pj )
                 indxp( k ) = pj
                 pj = nj
              end if
           end if
           go to 80
           100 continue
           ! record the last eigenvalue.
           k = k + 1
           dlamda( k ) = d( pj )
           w( k ) = z( pj )
           indxp( k ) = pj
           ! count up the total number of the various types of columns, then
           ! form a permutation which positions the four column types into
           ! four uniform groups (although one or more of these groups may be
           ! empty).
           do j = 1, 4
              ctot( j ) = 0
           end do
           do j = 1, n
              ct = coltyp( j )
              ctot( ct ) = ctot( ct ) + 1
           end do
           ! psm(*) = position in submatrix (of types 1 through 4)
           psm( 1 ) = 1
           psm( 2 ) = 1 + ctot( 1 )
           psm( 3 ) = psm( 2 ) + ctot( 2 )
           psm( 4 ) = psm( 3 ) + ctot( 3 )
           k = n - ctot( 4 )
           ! fill out the indxc array so that the permutation which it induces
           ! will place all type-1 columns first, all type-2 columns next,
           ! then all type-3's, and finally all type-4's.
           do j = 1, n
              js = indxp( j )
              ct = coltyp( js )
              indx( psm( ct ) ) = js
              indxc( psm( ct ) ) = j
              psm( ct ) = psm( ct ) + 1
           end do
           ! sort the eigenvalues and corresponding eigenvectors into dlamda
           ! and q2 respectively.  the eigenvalues/vectors which were not
           ! deflated go into the first k slots of dlamda and q2 respectively,
           ! while those which were deflated go into the last n - k slots.
           i = 1
           iq1 = 1
           iq2 = 1 + ( ctot( 1 )+ctot( 2 ) )*n1
           do j = 1, ctot( 1 )
              js = indx( i )
              call stdlib_dcopy( n1, q( 1, js ), 1, q2( iq1 ), 1 )
              z( i ) = d( js )
              i = i + 1
              iq1 = iq1 + n1
           end do
           do j = 1, ctot( 2 )
              js = indx( i )
              call stdlib_dcopy( n1, q( 1, js ), 1, q2( iq1 ), 1 )
              call stdlib_dcopy( n2, q( n1+1, js ), 1, q2( iq2 ), 1 )
              z( i ) = d( js )
              i = i + 1
              iq1 = iq1 + n1
              iq2 = iq2 + n2
           end do
           do j = 1, ctot( 3 )
              js = indx( i )
              call stdlib_dcopy( n2, q( n1+1, js ), 1, q2( iq2 ), 1 )
              z( i ) = d( js )
              i = i + 1
              iq2 = iq2 + n2
           end do
           iq1 = iq2
           do j = 1, ctot( 4 )
              js = indx( i )
              call stdlib_dcopy( n, q( 1, js ), 1, q2( iq2 ), 1 )
              iq2 = iq2 + n
              z( i ) = d( js )
              i = i + 1
           end do
           ! the deflated eigenvalues and their corresponding vectors go back
           ! into the last n - k slots of d and q respectively.
           if( k<n ) then
              call stdlib_dlacpy( 'A', n, ctot( 4 ), q2( iq1 ), n,q( 1, k+1 ), ldq )
              call stdlib_dcopy( n-k, z( k+1 ), 1, d( k+1 ), 1 )
           end if
           ! copy ctot into coltyp for referencing in stdlib_dlaed3.
           do j = 1, 4
              coltyp( j ) = ctot( j )
           end do
           190 continue
           return
     end subroutine stdlib_dlaed2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laed2( k, n, n1, d, q, ldq, indxq, rho, z, dlamda, w,q2, indx, indxc,&
     !! DLAED2: merges the two sets of eigenvalues together into a single
     !! sorted set.  Then it tries to deflate the size of the problem.
     !! There are two ways in which deflation can occur:  when two or more
     !! eigenvalues are close together or if there is a tiny entry in the
     !! Z vector.  For each such occurrence the order of the related secular
     !! equation problem is reduced by one.
                indxp, coltyp, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info, k
           integer(ilp), intent(in) :: ldq, n, n1
           real(${rk}$), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(out) :: coltyp(*), indx(*), indxc(*), indxp(*)
           integer(ilp), intent(inout) :: indxq(*)
           real(${rk}$), intent(inout) :: d(*), q(ldq,*), z(*)
           real(${rk}$), intent(out) :: dlamda(*), q2(*), w(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: mone = -1.0_${rk}$
           
           ! Local Arrays 
           integer(ilp) :: ctot(4), psm(4)
           ! Local Scalars 
           integer(ilp) :: ct, i, imax, iq1, iq2, j, jmax, js, k2, n1p1, n2, nj, pj
           real(${rk}$) :: c, eps, s, t, tau, tol
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           else if( min( 1, ( n / 2 ) )>n1 .or. ( n / 2 )<n1 ) then
              info = -3
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED2', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           n2 = n - n1
           n1p1 = n1 + 1
           if( rho<zero ) then
              call stdlib_${ri}$scal( n2, mone, z( n1p1 ), 1 )
           end if
           ! normalize z so that norm(z) = 1.  since z is the concatenation of
           ! two normalized vectors, norm2(z) = sqrt(2).
           t = one / sqrt( two )
           call stdlib_${ri}$scal( n, t, z, 1 )
           ! rho = abs( norm(z)**2 * rho )
           rho = abs( two*rho )
           ! sort the eigenvalues into increasing order
           do i = n1p1, n
              indxq( i ) = indxq( i ) + n1
           end do
           ! re-integrate the deflated parts from the last pass
           do i = 1, n
              dlamda( i ) = d( indxq( i ) )
           end do
           call stdlib_${ri}$lamrg( n1, n2, dlamda, 1, 1, indxc )
           do i = 1, n
              indx( i ) = indxq( indxc( i ) )
           end do
           ! calculate the allowable deflation tolerance
           imax = stdlib_i${ri}$amax( n, z, 1 )
           jmax = stdlib_i${ri}$amax( n, d, 1 )
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           tol = eight*eps*max( abs( d( jmax ) ), abs( z( imax ) ) )
           ! if the rank-1 modifier is small enough, no more needs to be done
           ! except to reorganize q so that its columns correspond with the
           ! elements in d.
           if( rho*abs( z( imax ) )<=tol ) then
              k = 0
              iq2 = 1
              do j = 1, n
                 i = indx( j )
                 call stdlib_${ri}$copy( n, q( 1, i ), 1, q2( iq2 ), 1 )
                 dlamda( j ) = d( i )
                 iq2 = iq2 + n
              end do
              call stdlib_${ri}$lacpy( 'A', n, n, q2, n, q, ldq )
              call stdlib_${ri}$copy( n, dlamda, 1, d, 1 )
              go to 190
           end if
           ! if there are multiple eigenvalues then the problem deflates.  here
           ! the number of equal eigenvalues are found.  as each equal
           ! eigenvalue is found, an elementary reflector is computed to rotate
           ! the corresponding eigensubspace so that the corresponding
           ! components of z are zero in this new basis.
           do i = 1, n1
              coltyp( i ) = 1
           end do
           do i = n1p1, n
              coltyp( i ) = 3
           end do
           k = 0
           k2 = n + 1
           do j = 1, n
              nj = indx( j )
              if( rho*abs( z( nj ) )<=tol ) then
                 ! deflate due to small z component.
                 k2 = k2 - 1
                 coltyp( nj ) = 4
                 indxp( k2 ) = nj
                 if( j==n )go to 100
              else
                 pj = nj
                 go to 80
              end if
           end do
           80 continue
           j = j + 1
           nj = indx( j )
           if( j>n )go to 100
           if( rho*abs( z( nj ) )<=tol ) then
              ! deflate due to small z component.
              k2 = k2 - 1
              coltyp( nj ) = 4
              indxp( k2 ) = nj
           else
              ! check if eigenvalues are close enough to allow deflation.
              s = z( pj )
              c = z( nj )
              ! find sqrt(a**2+b**2) without overflow or
              ! destructive underflow.
              tau = stdlib_${ri}$lapy2( c, s )
              t = d( nj ) - d( pj )
              c = c / tau
              s = -s / tau
              if( abs( t*c*s )<=tol ) then
                 ! deflation is possible.
                 z( nj ) = tau
                 z( pj ) = zero
                 if( coltyp( nj )/=coltyp( pj ) )coltyp( nj ) = 2
                 coltyp( pj ) = 4
                 call stdlib_${ri}$rot( n, q( 1, pj ), 1, q( 1, nj ), 1, c, s )
                 t = d( pj )*c**2 + d( nj )*s**2
                 d( nj ) = d( pj )*s**2 + d( nj )*c**2
                 d( pj ) = t
                 k2 = k2 - 1
                 i = 1
                 90 continue
                 if( k2+i<=n ) then
                    if( d( pj )<d( indxp( k2+i ) ) ) then
                       indxp( k2+i-1 ) = indxp( k2+i )
                       indxp( k2+i ) = pj
                       i = i + 1
                       go to 90
                    else
                       indxp( k2+i-1 ) = pj
                    end if
                 else
                    indxp( k2+i-1 ) = pj
                 end if
                 pj = nj
              else
                 k = k + 1
                 dlamda( k ) = d( pj )
                 w( k ) = z( pj )
                 indxp( k ) = pj
                 pj = nj
              end if
           end if
           go to 80
           100 continue
           ! record the last eigenvalue.
           k = k + 1
           dlamda( k ) = d( pj )
           w( k ) = z( pj )
           indxp( k ) = pj
           ! count up the total number of the various types of columns, then
           ! form a permutation which positions the four column types into
           ! four uniform groups (although one or more of these groups may be
           ! empty).
           do j = 1, 4
              ctot( j ) = 0
           end do
           do j = 1, n
              ct = coltyp( j )
              ctot( ct ) = ctot( ct ) + 1
           end do
           ! psm(*) = position in submatrix (of types 1 through 4)
           psm( 1 ) = 1
           psm( 2 ) = 1 + ctot( 1 )
           psm( 3 ) = psm( 2 ) + ctot( 2 )
           psm( 4 ) = psm( 3 ) + ctot( 3 )
           k = n - ctot( 4 )
           ! fill out the indxc array so that the permutation which it induces
           ! will place all type-1 columns first, all type-2 columns next,
           ! then all type-3's, and finally all type-4's.
           do j = 1, n
              js = indxp( j )
              ct = coltyp( js )
              indx( psm( ct ) ) = js
              indxc( psm( ct ) ) = j
              psm( ct ) = psm( ct ) + 1
           end do
           ! sort the eigenvalues and corresponding eigenvectors into dlamda
           ! and q2 respectively.  the eigenvalues/vectors which were not
           ! deflated go into the first k slots of dlamda and q2 respectively,
           ! while those which were deflated go into the last n - k slots.
           i = 1
           iq1 = 1
           iq2 = 1 + ( ctot( 1 )+ctot( 2 ) )*n1
           do j = 1, ctot( 1 )
              js = indx( i )
              call stdlib_${ri}$copy( n1, q( 1, js ), 1, q2( iq1 ), 1 )
              z( i ) = d( js )
              i = i + 1
              iq1 = iq1 + n1
           end do
           do j = 1, ctot( 2 )
              js = indx( i )
              call stdlib_${ri}$copy( n1, q( 1, js ), 1, q2( iq1 ), 1 )
              call stdlib_${ri}$copy( n2, q( n1+1, js ), 1, q2( iq2 ), 1 )
              z( i ) = d( js )
              i = i + 1
              iq1 = iq1 + n1
              iq2 = iq2 + n2
           end do
           do j = 1, ctot( 3 )
              js = indx( i )
              call stdlib_${ri}$copy( n2, q( n1+1, js ), 1, q2( iq2 ), 1 )
              z( i ) = d( js )
              i = i + 1
              iq2 = iq2 + n2
           end do
           iq1 = iq2
           do j = 1, ctot( 4 )
              js = indx( i )
              call stdlib_${ri}$copy( n, q( 1, js ), 1, q2( iq2 ), 1 )
              iq2 = iq2 + n
              z( i ) = d( js )
              i = i + 1
           end do
           ! the deflated eigenvalues and their corresponding vectors go back
           ! into the last n - k slots of d and q respectively.
           if( k<n ) then
              call stdlib_${ri}$lacpy( 'A', n, ctot( 4 ), q2( iq1 ), n,q( 1, k+1 ), ldq )
              call stdlib_${ri}$copy( n-k, z( k+1 ), 1, d( k+1 ), 1 )
           end if
           ! copy ctot into coltyp for referencing in stdlib_${ri}$laed3.
           do j = 1, 4
              coltyp( j ) = ctot( j )
           end do
           190 continue
           return
     end subroutine stdlib_${ri}$laed2

#:endif
#:endfor





     pure subroutine stdlib_ssbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
     !! SSBGVD computes all the eigenvalues, and optionally, the eigenvectors
     !! of a real generalized symmetric-definite banded eigenproblem, of the
     !! form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric and
     !! banded, and B is also positive definite.  If eigenvectors are
     !! desired, it uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               lwork, iwork, liwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ka, kb, ldab, ldbb, ldz, liwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper, wantz
           character :: vect
           integer(ilp) :: iinfo, inde, indwk2, indwrk, liwmin, llwrk2, lwmin
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           info = 0
           if( n<=1 ) then
              liwmin = 1
              lwmin = 1
           else if( wantz ) then
              liwmin = 3 + 5*n
              lwmin = 1 + 5*n + 2*n**2
           else
              liwmin = 1
              lwmin = 2*n
           end if
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ka<0 ) then
              info = -4
           else if( kb<0 .or. kb>ka ) then
              info = -5
           else if( ldab<ka+1 ) then
              info = -7
           else if( ldbb<kb+1 ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -12
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -14
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSBGVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_spbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           inde = 1
           indwrk = inde + n
           indwk2 = indwrk + n*n
           llwrk2 = lwork - indwk2 + 1
           call stdlib_ssbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, z, ldz,work, iinfo )
                     
           ! reduce to tridiagonal form.
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_ssbtrd( vect, uplo, n, ka, ab, ldab, w, work( inde ), z, ldz,work( indwrk )&
                     , iinfo )
           ! for eigenvalues only, call stdlib_ssterf. for eigenvectors, call stdlib_sstedc.
           if( .not.wantz ) then
              call stdlib_ssterf( n, w, work( inde ), info )
           else
              call stdlib_sstedc( 'I', n, w, work( inde ), work( indwrk ), n,work( indwk2 ), &
                        llwrk2, iwork, liwork, info )
              call stdlib_sgemm( 'N', 'N', n, n, n, one, z, ldz, work( indwrk ), n,zero, work( &
                        indwk2 ), n )
              call stdlib_slacpy( 'A', n, n, work( indwk2 ), n, z, ldz )
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_ssbgvd

     pure subroutine stdlib_dsbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
     !! DSBGVD computes all the eigenvalues, and optionally, the eigenvectors
     !! of a real generalized symmetric-definite banded eigenproblem, of the
     !! form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric and
     !! banded, and B is also positive definite.  If eigenvectors are
     !! desired, it uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               lwork, iwork, liwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ka, kb, ldab, ldbb, ldz, liwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper, wantz
           character :: vect
           integer(ilp) :: iinfo, inde, indwk2, indwrk, liwmin, llwrk2, lwmin
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           info = 0
           if( n<=1 ) then
              liwmin = 1
              lwmin = 1
           else if( wantz ) then
              liwmin = 3 + 5*n
              lwmin = 1 + 5*n + 2*n**2
           else
              liwmin = 1
              lwmin = 2*n
           end if
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ka<0 ) then
              info = -4
           else if( kb<0 .or. kb>ka ) then
              info = -5
           else if( ldab<ka+1 ) then
              info = -7
           else if( ldbb<kb+1 ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -12
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -14
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSBGVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_dpbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           inde = 1
           indwrk = inde + n
           indwk2 = indwrk + n*n
           llwrk2 = lwork - indwk2 + 1
           call stdlib_dsbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, z, ldz,work, iinfo )
                     
           ! reduce to tridiagonal form.
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_dsbtrd( vect, uplo, n, ka, ab, ldab, w, work( inde ), z, ldz,work( indwrk )&
                     , iinfo )
           ! for eigenvalues only, call stdlib_dsterf. for eigenvectors, call stdlib_sstedc.
           if( .not.wantz ) then
              call stdlib_dsterf( n, w, work( inde ), info )
           else
              call stdlib_dstedc( 'I', n, w, work( inde ), work( indwrk ), n,work( indwk2 ), &
                        llwrk2, iwork, liwork, info )
              call stdlib_dgemm( 'N', 'N', n, n, n, one, z, ldz, work( indwrk ), n,zero, work( &
                        indwk2 ), n )
              call stdlib_dlacpy( 'A', n, n, work( indwk2 ), n, z, ldz )
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_dsbgvd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$sbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
     !! DSBGVD: computes all the eigenvalues, and optionally, the eigenvectors
     !! of a real generalized symmetric-definite banded eigenproblem, of the
     !! form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric and
     !! banded, and B is also positive definite.  If eigenvectors are
     !! desired, it uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               lwork, iwork, liwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ka, kb, ldab, ldbb, ldz, liwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper, wantz
           character :: vect
           integer(ilp) :: iinfo, inde, indwk2, indwrk, liwmin, llwrk2, lwmin
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           info = 0
           if( n<=1 ) then
              liwmin = 1
              lwmin = 1
           else if( wantz ) then
              liwmin = 3 + 5*n
              lwmin = 1 + 5*n + 2*n**2
           else
              liwmin = 1
              lwmin = 2*n
           end if
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ka<0 ) then
              info = -4
           else if( kb<0 .or. kb>ka ) then
              info = -5
           else if( ldab<ka+1 ) then
              info = -7
           else if( ldbb<kb+1 ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -12
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -14
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSBGVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_${ri}$pbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           inde = 1
           indwrk = inde + n
           indwk2 = indwrk + n*n
           llwrk2 = lwork - indwk2 + 1
           call stdlib_${ri}$sbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, z, ldz,work, iinfo )
                     
           ! reduce to tridiagonal form.
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_${ri}$sbtrd( vect, uplo, n, ka, ab, ldab, w, work( inde ), z, ldz,work( indwrk )&
                     , iinfo )
           ! for eigenvalues only, call stdlib_${ri}$sterf. for eigenvectors, call stdlib_dstedc.
           if( .not.wantz ) then
              call stdlib_${ri}$sterf( n, w, work( inde ), info )
           else
              call stdlib_${ri}$stedc( 'I', n, w, work( inde ), work( indwrk ), n,work( indwk2 ), &
                        llwrk2, iwork, liwork, info )
              call stdlib_${ri}$gemm( 'N', 'N', n, n, n, one, z, ldz, work( indwrk ), n,zero, work( &
                        indwk2 ), n )
              call stdlib_${ri}$lacpy( 'A', n, n, work( indwk2 ), n, z, ldz )
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$sbgvd

#:endif
#:endfor



     pure subroutine stdlib_sstev( jobz, n, d, e, z, ldz, work, info )
     !! SSTEV computes all eigenvalues and, optionally, eigenvectors of a
     !! real symmetric tridiagonal matrix A.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: wantz
           integer(ilp) :: imax, iscale
           real(sp) :: bignum, eps, rmax, rmin, safmin, sigma, smlnum, tnrm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSTEV ', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           eps = stdlib_slamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           tnrm = stdlib_slanst( 'M', n, d, e )
           if( tnrm>zero .and. tnrm<rmin ) then
              iscale = 1
              sigma = rmin / tnrm
           else if( tnrm>rmax ) then
              iscale = 1
              sigma = rmax / tnrm
           end if
           if( iscale==1 ) then
              call stdlib_sscal( n, sigma, d, 1 )
              call stdlib_sscal( n-1, sigma, e( 1 ), 1 )
           end if
           ! for eigenvalues only, call stdlib_ssterf.  for eigenvalues and
           ! eigenvectors, call stdlib_ssteqr.
           if( .not.wantz ) then
              call stdlib_ssterf( n, d, e, info )
           else
              call stdlib_ssteqr( 'I', n, d, e, z, ldz, work, info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = n
              else
                 imax = info - 1
              end if
              call stdlib_sscal( imax, one / sigma, d, 1 )
           end if
           return
     end subroutine stdlib_sstev

     pure subroutine stdlib_dstev( jobz, n, d, e, z, ldz, work, info )
     !! DSTEV computes all eigenvalues and, optionally, eigenvectors of a
     !! real symmetric tridiagonal matrix A.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: wantz
           integer(ilp) :: imax, iscale
           real(dp) :: bignum, eps, rmax, rmin, safmin, sigma, smlnum, tnrm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEV ', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           eps = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           tnrm = stdlib_dlanst( 'M', n, d, e )
           if( tnrm>zero .and. tnrm<rmin ) then
              iscale = 1
              sigma = rmin / tnrm
           else if( tnrm>rmax ) then
              iscale = 1
              sigma = rmax / tnrm
           end if
           if( iscale==1 ) then
              call stdlib_dscal( n, sigma, d, 1 )
              call stdlib_dscal( n-1, sigma, e( 1 ), 1 )
           end if
           ! for eigenvalues only, call stdlib_dsterf.  for eigenvalues and
           ! eigenvectors, call stdlib_dsteqr.
           if( .not.wantz ) then
              call stdlib_dsterf( n, d, e, info )
           else
              call stdlib_dsteqr( 'I', n, d, e, z, ldz, work, info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = n
              else
                 imax = info - 1
              end if
              call stdlib_dscal( imax, one / sigma, d, 1 )
           end if
           return
     end subroutine stdlib_dstev

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$stev( jobz, n, d, e, z, ldz, work, info )
     !! DSTEV: computes all eigenvalues and, optionally, eigenvectors of a
     !! real symmetric tridiagonal matrix A.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: wantz
           integer(ilp) :: imax, iscale
           real(${rk}$) :: bignum, eps, rmax, rmin, safmin, sigma, smlnum, tnrm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEV ', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           tnrm = stdlib_${ri}$lanst( 'M', n, d, e )
           if( tnrm>zero .and. tnrm<rmin ) then
              iscale = 1
              sigma = rmin / tnrm
           else if( tnrm>rmax ) then
              iscale = 1
              sigma = rmax / tnrm
           end if
           if( iscale==1 ) then
              call stdlib_${ri}$scal( n, sigma, d, 1 )
              call stdlib_${ri}$scal( n-1, sigma, e( 1 ), 1 )
           end if
           ! for eigenvalues only, call stdlib_${ri}$sterf.  for eigenvalues and
           ! eigenvectors, call stdlib_${ri}$steqr.
           if( .not.wantz ) then
              call stdlib_${ri}$sterf( n, d, e, info )
           else
              call stdlib_${ri}$steqr( 'I', n, d, e, z, ldz, work, info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = n
              else
                 imax = info - 1
              end if
              call stdlib_${ri}$scal( imax, one / sigma, d, 1 )
           end if
           return
     end subroutine stdlib_${ri}$stev

#:endif
#:endfor



     pure subroutine stdlib_sstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
     !! SSTEMR computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
     !! a well defined set of pairwise different real eigenvalues, the corresponding
     !! real eigenvectors are pairwise orthogonal.
     !! The spectrum may be computed either completely or partially by specifying
     !! either an interval (VL,VU] or a range of indices IL:IU for the desired
     !! eigenvalues.
     !! Depending on the number of desired eigenvalues, these are computed either
     !! by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
     !! computed by the use of various suitable L D L^T factorizations near clusters
     !! of close eigenvalues (referred to as RRRs, Relatively Robust
     !! Representations). An informal sketch of the algorithm follows.
     !! For each unreduced block (submatrix) of T,
     !! (a) Compute T - sigma I  = L D L^T, so that L and D
     !! define all the wanted eigenvalues to high relative accuracy.
     !! This means that small relative changes in the entries of D and L
     !! cause only small relative changes in the eigenvalues and
     !! eigenvectors. The standard (unfactored) representation of the
     !! tridiagonal matrix T does not have this property in general.
     !! (b) Compute the eigenvalues to suitable accuracy.
     !! If the eigenvectors are desired, the algorithm attains full
     !! accuracy of the computed eigenvalues only right before
     !! the corresponding vectors have to be computed, see steps c) and d).
     !! (c) For each cluster of close eigenvalues, select a new
     !! shift close to the cluster, find a new factorization, and refine
     !! the shifted eigenvalues to suitable accuracy.
     !! (d) For each eigenvalue with a large enough relative separation compute
     !! the corresponding eigenvector by forming a rank revealing twisted
     !! factorization. Go back to (c) for any clusters that remain.
     !! For more details, see:
     !! - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
     !! to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
     !! Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
     !! - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
     !! Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
     !! 2004.  Also LAPACK Working Note 154.
     !! - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
     !! tridiagonal eigenvalue/eigenvector problem",
     !! Computer Science Division Technical Report No. UCB/CSD-97-971,
     !! UC Berkeley, May 1997.
     !! Further Details
     !! 1.SSTEMR works only on machines which follow IEEE-754
     !! floating-point standard in their handling of infinities and NaNs.
     !! This permits the use of efficient inner loops avoiding a check for
     !! zero divisors.
               isuppz, tryrac, work, lwork,iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           logical(lk), intent(inout) :: tryrac
           integer(ilp), intent(in) :: il, iu, ldz, nzc, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(in) :: vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: w(*), work(*)
           real(sp), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: minrgp = 3.0e-3_sp
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, lquery, valeig, wantz, zquery
           integer(ilp) :: i, ibegin, iend, ifirst, iil, iindbl, iindw, iindwk, iinfo, iinspl, &
           iiu, ilast, in, indd, inde2, inderr, indgp, indgrs, indwrk, itmp, itmp2, j, jblk, jj, &
                     liwmin, lwmin, nsplit, nzcmin, offset, wbegin, wend
           real(sp) :: bignum, cs, eps, pivmin, r1, r2, rmax, rmin, rtol1, rtol2, safmin, scale, &
                     smlnum, sn, thresh, tmp, tnrm, wl, wu
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lquery = ( ( lwork==-1 ).or.( liwork==-1 ) )
           zquery = ( nzc==-1 )
           ! stdlib_sstemr needs work of size 6*n, iwork of size 3*n.
           ! in addition, stdlib_slarre needs work of size 6*n, iwork of size 5*n.
           ! furthermore, stdlib_slarrv needs work of size 12*n, iwork of size 7*n.
           if( wantz ) then
              lwmin = 18*n
              liwmin = 10*n
           else
              ! need less workspace if only the eigenvalues are wanted
              lwmin = 12*n
              liwmin = 8*n
           endif
           wl = zero
           wu = zero
           iil = 0
           iiu = 0
           nsplit = 0
           if( valeig ) then
              ! we do not reference vl, vu in the cases range = 'i','a'
              ! the interval (wl, wu] contains all the wanted eigenvalues.
              ! it is either given by the user or computed in stdlib_slarre.
              wl = vl
              wu = vu
           elseif( indeig ) then
              ! we do not reference il, iu in the cases range = 'v','a'
              iil = il
              iiu = iu
           endif
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( valeig .and. n>0 .and. wu<=wl ) then
              info = -7
           else if( indeig .and. ( iil<1 .or. iil>n ) ) then
              info = -8
           else if( indeig .and. ( iiu<iil .or. iiu>n ) ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -13
           else if( lwork<lwmin .and. .not.lquery ) then
              info = -17
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -19
           end if
           ! get machine constants.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           eps = stdlib_slamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( wantz .and. alleig ) then
                 nzcmin = n
              else if( wantz .and. valeig ) then
                 call stdlib_slarrc( 'T', n, vl, vu, d, e, safmin,nzcmin, itmp, itmp2, info )
                           
              else if( wantz .and. indeig ) then
                 nzcmin = iiu-iil+1
              else
                 ! wantz == false.
                 nzcmin = 0
              endif
              if( zquery .and. info==0 ) then
                 z( 1,1 ) = nzcmin
              else if( nzc<nzcmin .and. .not.zquery ) then
                 info = -14
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSTEMR', -info )
              return
           else if( lquery .or. zquery ) then
              return
           end if
           ! handle n = 0, 1, and 2 cases immediately
           m = 0
           if( n==0 )return
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = d( 1 )
              else
                 if( wl<d( 1 ) .and. wu>=d( 1 ) ) then
                    m = 1
                    w( 1 ) = d( 1 )
                 end if
              end if
              if( wantz.and.(.not.zquery) ) then
                 z( 1, 1 ) = one
                 isuppz(1) = 1
                 isuppz(2) = 1
              end if
              return
           end if
           if( n==2 ) then
              if( .not.wantz ) then
                 call stdlib_slae2( d(1), e(1), d(2), r1, r2 )
              else if( wantz.and.(.not.zquery) ) then
                 call stdlib_slaev2( d(1), e(1), d(2), r1, r2, cs, sn )
              end if
              if( alleig.or.(valeig.and.(r2>wl).and.(r2<=wu)).or.(indeig.and.(iil==1)) ) &
                        then
                 m = m+1
                 w( m ) = r2
                 if( wantz.and.(.not.zquery) ) then
                    z( 1, m ) = -sn
                    z( 2, m ) = cs
                    ! note: at most one of sn and cs can be zero.
                    if (sn/=zero) then
                       if (cs/=zero) then
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 2
                       else
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 1
                       end if
                    else
                       isuppz(2*m-1) = 2
                       isuppz(2*m) = 2
                    end if
                 endif
              endif
              if( alleig.or.(valeig.and.(r1>wl).and.(r1<=wu)).or.(indeig.and.(iiu==2)) ) &
                        then
                 m = m+1
                 w( m ) = r1
                 if( wantz.and.(.not.zquery) ) then
                    z( 1, m ) = cs
                    z( 2, m ) = sn
                    ! note: at most one of sn and cs can be zero.
                    if (sn/=zero) then
                       if (cs/=zero) then
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 2
                       else
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 1
                       end if
                    else
                       isuppz(2*m-1) = 2
                       isuppz(2*m) = 2
                    end if
                 endif
              endif
           else
           ! continue with general n
              indgrs = 1
              inderr = 2*n + 1
              indgp = 3*n + 1
              indd = 4*n + 1
              inde2 = 5*n + 1
              indwrk = 6*n + 1
              iinspl = 1
              iindbl = n + 1
              iindw = 2*n + 1
              iindwk = 3*n + 1
              ! scale matrix to allowable range, if necessary.
              ! the allowable range is related to the pivmin parameter; see the
              ! comments in stdlib_slarrd.  the preference for scaling small values
              ! up is heuristic; we expect users' matrices not to be close to the
              ! rmax threshold.
              scale = one
              tnrm = stdlib_slanst( 'M', n, d, e )
              if( tnrm>zero .and. tnrm<rmin ) then
                 scale = rmin / tnrm
              else if( tnrm>rmax ) then
                 scale = rmax / tnrm
              end if
              if( scale/=one ) then
                 call stdlib_sscal( n, scale, d, 1 )
                 call stdlib_sscal( n-1, scale, e, 1 )
                 tnrm = tnrm*scale
                 if( valeig ) then
                    ! if eigenvalues in interval have to be found,
                    ! scale (wl, wu] accordingly
                    wl = wl*scale
                    wu = wu*scale
                 endif
              end if
              ! compute the desired eigenvalues of the tridiagonal after splitting
              ! into smaller subblocks if the corresponding off-diagonal elements
              ! are small
              ! thresh is the splitting parameter for stdlib_slarre
              ! a negative thresh forces the old splitting criterion based on the
              ! size of the off-diagonal. a positive thresh switches to splitting
              ! which preserves relative accuracy.
              if( tryrac ) then
                 ! test whether the matrix warrants the more expensive relative approach.
                 call stdlib_slarrr( n, d, e, iinfo )
              else
                 ! the user does not care about relative accurately eigenvalues
                 iinfo = -1
              endif
              ! set the splitting criterion
              if (iinfo==0) then
                 thresh = eps
              else
                 thresh = -eps
                 ! relative accuracy is desired but t does not guarantee it
                 tryrac = .false.
              endif
              if( tryrac ) then
                 ! copy original diagonal, needed to guarantee relative accuracy
                 call stdlib_scopy(n,d,1,work(indd),1)
              endif
              ! store the squares of the offdiagonal values of t
              do j = 1, n-1
                 work( inde2+j-1 ) = e(j)**2
              end do
              ! set the tolerance parameters for bisection
              if( .not.wantz ) then
                 ! stdlib_slarre computes the eigenvalues to full precision.
                 rtol1 = four * eps
                 rtol2 = four * eps
              else
                 ! stdlib_slarre computes the eigenvalues to less than full precision.
                 ! stdlib_slarrv will refine the eigenvalue approximations, and we can
                 ! need less accurate initial bisection in stdlib_slarre.
                 ! note: these settings do only affect the subset case and stdlib_slarre
                 rtol1 = max( sqrt(eps)*5.0e-2_sp, four * eps )
                 rtol2 = max( sqrt(eps)*5.0e-3_sp, four * eps )
              endif
              call stdlib_slarre( range, n, wl, wu, iil, iiu, d, e,work(inde2), rtol1, rtol2, &
              thresh, nsplit,iwork( iinspl ), m, w, work( inderr ),work( indgp ), iwork( iindbl ),&
              iwork( iindw ), work( indgrs ), pivmin,work( indwrk ), iwork( iindwk ), iinfo )
                        
              if( iinfo/=0 ) then
                 info = 10 + abs( iinfo )
                 return
              end if
              ! note that if range /= 'v', stdlib_slarre computes bounds on the desired
              ! part of the spectrum. all desired eigenvalues are contained in
              ! (wl,wu]
              if( wantz ) then
                 ! compute the desired eigenvectors corresponding to the computed
                 ! eigenvalues
                 call stdlib_slarrv( n, wl, wu, d, e,pivmin, iwork( iinspl ), m,1, m, minrgp, &
                 rtol1, rtol2,w, work( inderr ), work( indgp ), iwork( iindbl ),iwork( iindw ), &
                           work( indgrs ), z, ldz,isuppz, work( indwrk ), iwork( iindwk ), iinfo )
                 if( iinfo/=0 ) then
                    info = 20 + abs( iinfo )
                    return
                 end if
              else
                 ! stdlib_slarre computes eigenvalues of the (shifted) root representation
                 ! stdlib_slarrv returns the eigenvalues of the unshifted matrix.
                 ! however, if the eigenvectors are not desired by the user, we need
                 ! to apply the corresponding shifts from stdlib_slarre to obtain the
                 ! eigenvalues of the original matrix.
                 do j = 1, m
                    itmp = iwork( iindbl+j-1 )
                    w( j ) = w( j ) + e( iwork( iinspl+itmp-1 ) )
                 end do
              end if
              if ( tryrac ) then
                 ! refine computed eigenvalues so that they are relatively accurate
                 ! with respect to the original matrix t.
                 ibegin = 1
                 wbegin = 1
                 loop_39: do jblk = 1, iwork( iindbl+m-1 )
                    iend = iwork( iinspl+jblk-1 )
                    in = iend - ibegin + 1
                    wend = wbegin - 1
                    ! check if any eigenvalues have to be refined in this block
                    36 continue
                    if( wend<m ) then
                       if( iwork( iindbl+wend )==jblk ) then
                          wend = wend + 1
                          go to 36
                       end if
                    end if
                    if( wend<wbegin ) then
                       ibegin = iend + 1
                       cycle loop_39
                    end if
                    offset = iwork(iindw+wbegin-1)-1
                    ifirst = iwork(iindw+wbegin-1)
                    ilast = iwork(iindw+wend-1)
                    rtol2 = four * eps
                    call stdlib_slarrj( in,work(indd+ibegin-1), work(inde2+ibegin-1),ifirst, &
                    ilast, rtol2, offset, w(wbegin),work( inderr+wbegin-1 ),work( indwrk ), iwork(&
                               iindwk ), pivmin,tnrm, iinfo )
                    ibegin = iend + 1
                    wbegin = wend + 1
                 end do loop_39
              endif
              ! if matrix was scaled, then rescale eigenvalues appropriately.
              if( scale/=one ) then
                 call stdlib_sscal( m, one / scale, w, 1 )
              end if
           end if
           ! if eigenvalues are not in increasing order, then sort them,
           ! possibly along with eigenvectors.
           if( nsplit>1 .or. n==2 ) then
              if( .not. wantz ) then
                 call stdlib_slasrt( 'I', m, w, iinfo )
                 if( iinfo/=0 ) then
                    info = 3
                    return
                 end if
              else
                 do j = 1, m - 1
                    i = 0
                    tmp = w( j )
                    do jj = j + 1, m
                       if( w( jj )<tmp ) then
                          i = jj
                          tmp = w( jj )
                       end if
                    end do
                    if( i/=0 ) then
                       w( i ) = w( j )
                       w( j ) = tmp
                       if( wantz ) then
                          call stdlib_sswap( n, z( 1, i ), 1, z( 1, j ), 1 )
                          itmp = isuppz( 2*i-1 )
                          isuppz( 2*i-1 ) = isuppz( 2*j-1 )
                          isuppz( 2*j-1 ) = itmp
                          itmp = isuppz( 2*i )
                          isuppz( 2*i ) = isuppz( 2*j )
                          isuppz( 2*j ) = itmp
                       end if
                    end if
                 end do
              end if
           endif
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_sstemr

     pure subroutine stdlib_dstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
     !! DSTEMR computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
     !! a well defined set of pairwise different real eigenvalues, the corresponding
     !! real eigenvectors are pairwise orthogonal.
     !! The spectrum may be computed either completely or partially by specifying
     !! either an interval (VL,VU] or a range of indices IL:IU for the desired
     !! eigenvalues.
     !! Depending on the number of desired eigenvalues, these are computed either
     !! by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
     !! computed by the use of various suitable L D L^T factorizations near clusters
     !! of close eigenvalues (referred to as RRRs, Relatively Robust
     !! Representations). An informal sketch of the algorithm follows.
     !! For each unreduced block (submatrix) of T,
     !! (a) Compute T - sigma I  = L D L^T, so that L and D
     !! define all the wanted eigenvalues to high relative accuracy.
     !! This means that small relative changes in the entries of D and L
     !! cause only small relative changes in the eigenvalues and
     !! eigenvectors. The standard (unfactored) representation of the
     !! tridiagonal matrix T does not have this property in general.
     !! (b) Compute the eigenvalues to suitable accuracy.
     !! If the eigenvectors are desired, the algorithm attains full
     !! accuracy of the computed eigenvalues only right before
     !! the corresponding vectors have to be computed, see steps c) and d).
     !! (c) For each cluster of close eigenvalues, select a new
     !! shift close to the cluster, find a new factorization, and refine
     !! the shifted eigenvalues to suitable accuracy.
     !! (d) For each eigenvalue with a large enough relative separation compute
     !! the corresponding eigenvector by forming a rank revealing twisted
     !! factorization. Go back to (c) for any clusters that remain.
     !! For more details, see:
     !! - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
     !! to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
     !! Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
     !! - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
     !! Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
     !! 2004.  Also LAPACK Working Note 154.
     !! - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
     !! tridiagonal eigenvalue/eigenvector problem",
     !! Computer Science Division Technical Report No. UCB/CSD-97-971,
     !! UC Berkeley, May 1997.
     !! Further Details
     !! 1.DSTEMR works only on machines which follow IEEE-754
     !! floating-point standard in their handling of infinities and NaNs.
     !! This permits the use of efficient inner loops avoiding a check for
     !! zero divisors.
               isuppz, tryrac, work, lwork,iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           logical(lk), intent(inout) :: tryrac
           integer(ilp), intent(in) :: il, iu, ldz, nzc, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(dp), intent(in) :: vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: w(*), work(*)
           real(dp), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: minrgp = 1.0e-3_dp
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, lquery, valeig, wantz, zquery
           integer(ilp) :: i, ibegin, iend, ifirst, iil, iindbl, iindw, iindwk, iinfo, iinspl, &
           iiu, ilast, in, indd, inde2, inderr, indgp, indgrs, indwrk, itmp, itmp2, j, jblk, jj, &
                     liwmin, lwmin, nsplit, nzcmin, offset, wbegin, wend
           real(dp) :: bignum, cs, eps, pivmin, r1, r2, rmax, rmin, rtol1, rtol2, safmin, scale, &
                     smlnum, sn, thresh, tmp, tnrm, wl, wu
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lquery = ( ( lwork==-1 ).or.( liwork==-1 ) )
           zquery = ( nzc==-1 )
           ! stdlib_dstemr needs work of size 6*n, iwork of size 3*n.
           ! in addition, stdlib_dlarre needs work of size 6*n, iwork of size 5*n.
           ! furthermore, stdlib_dlarrv needs work of size 12*n, iwork of size 7*n.
           if( wantz ) then
              lwmin = 18*n
              liwmin = 10*n
           else
              ! need less workspace if only the eigenvalues are wanted
              lwmin = 12*n
              liwmin = 8*n
           endif
           wl = zero
           wu = zero
           iil = 0
           iiu = 0
           nsplit = 0
           if( valeig ) then
              ! we do not reference vl, vu in the cases range = 'i','a'
              ! the interval (wl, wu] contains all the wanted eigenvalues.
              ! it is either given by the user or computed in stdlib_dlarre.
              wl = vl
              wu = vu
           elseif( indeig ) then
              ! we do not reference il, iu in the cases range = 'v','a'
              iil = il
              iiu = iu
           endif
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( valeig .and. n>0 .and. wu<=wl ) then
              info = -7
           else if( indeig .and. ( iil<1 .or. iil>n ) ) then
              info = -8
           else if( indeig .and. ( iiu<iil .or. iiu>n ) ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -13
           else if( lwork<lwmin .and. .not.lquery ) then
              info = -17
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -19
           end if
           ! get machine constants.
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           eps = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( wantz .and. alleig ) then
                 nzcmin = n
              else if( wantz .and. valeig ) then
                 call stdlib_dlarrc( 'T', n, vl, vu, d, e, safmin,nzcmin, itmp, itmp2, info )
                           
              else if( wantz .and. indeig ) then
                 nzcmin = iiu-iil+1
              else
                 ! wantz == false.
                 nzcmin = 0
              endif
              if( zquery .and. info==0 ) then
                 z( 1,1 ) = nzcmin
              else if( nzc<nzcmin .and. .not.zquery ) then
                 info = -14
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEMR', -info )
              return
           else if( lquery .or. zquery ) then
              return
           end if
           ! handle n = 0, 1, and 2 cases immediately
           m = 0
           if( n==0 )return
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = d( 1 )
              else
                 if( wl<d( 1 ) .and. wu>=d( 1 ) ) then
                    m = 1
                    w( 1 ) = d( 1 )
                 end if
              end if
              if( wantz.and.(.not.zquery) ) then
                 z( 1, 1 ) = one
                 isuppz(1) = 1
                 isuppz(2) = 1
              end if
              return
           end if
           if( n==2 ) then
              if( .not.wantz ) then
                 call stdlib_dlae2( d(1), e(1), d(2), r1, r2 )
              else if( wantz.and.(.not.zquery) ) then
                 call stdlib_dlaev2( d(1), e(1), d(2), r1, r2, cs, sn )
              end if
              if( alleig.or.(valeig.and.(r2>wl).and.(r2<=wu)).or.(indeig.and.(iil==1)) ) &
                        then
                 m = m+1
                 w( m ) = r2
                 if( wantz.and.(.not.zquery) ) then
                    z( 1, m ) = -sn
                    z( 2, m ) = cs
                    ! note: at most one of sn and cs can be zero.
                    if (sn/=zero) then
                       if (cs/=zero) then
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 2
                       else
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 1
                       end if
                    else
                       isuppz(2*m-1) = 2
                       isuppz(2*m) = 2
                    end if
                 endif
              endif
              if( alleig.or.(valeig.and.(r1>wl).and.(r1<=wu)).or.(indeig.and.(iiu==2)) ) &
                        then
                 m = m+1
                 w( m ) = r1
                 if( wantz.and.(.not.zquery) ) then
                    z( 1, m ) = cs
                    z( 2, m ) = sn
                    ! note: at most one of sn and cs can be zero.
                    if (sn/=zero) then
                       if (cs/=zero) then
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 2
                       else
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 1
                       end if
                    else
                       isuppz(2*m-1) = 2
                       isuppz(2*m) = 2
                    end if
                 endif
              endif
           else
           ! continue with general n
              indgrs = 1
              inderr = 2*n + 1
              indgp = 3*n + 1
              indd = 4*n + 1
              inde2 = 5*n + 1
              indwrk = 6*n + 1
              iinspl = 1
              iindbl = n + 1
              iindw = 2*n + 1
              iindwk = 3*n + 1
              ! scale matrix to allowable range, if necessary.
              ! the allowable range is related to the pivmin parameter; see the
              ! comments in stdlib_dlarrd.  the preference for scaling small values
              ! up is heuristic; we expect users' matrices not to be close to the
              ! rmax threshold.
              scale = one
              tnrm = stdlib_dlanst( 'M', n, d, e )
              if( tnrm>zero .and. tnrm<rmin ) then
                 scale = rmin / tnrm
              else if( tnrm>rmax ) then
                 scale = rmax / tnrm
              end if
              if( scale/=one ) then
                 call stdlib_dscal( n, scale, d, 1 )
                 call stdlib_dscal( n-1, scale, e, 1 )
                 tnrm = tnrm*scale
                 if( valeig ) then
                    ! if eigenvalues in interval have to be found,
                    ! scale (wl, wu] accordingly
                    wl = wl*scale
                    wu = wu*scale
                 endif
              end if
              ! compute the desired eigenvalues of the tridiagonal after splitting
              ! into smaller subblocks if the corresponding off-diagonal elements
              ! are small
              ! thresh is the splitting parameter for stdlib_dlarre
              ! a negative thresh forces the old splitting criterion based on the
              ! size of the off-diagonal. a positive thresh switches to splitting
              ! which preserves relative accuracy.
              if( tryrac ) then
                 ! test whether the matrix warrants the more expensive relative approach.
                 call stdlib_dlarrr( n, d, e, iinfo )
              else
                 ! the user does not care about relative accurately eigenvalues
                 iinfo = -1
              endif
              ! set the splitting criterion
              if (iinfo==0) then
                 thresh = eps
              else
                 thresh = -eps
                 ! relative accuracy is desired but t does not guarantee it
                 tryrac = .false.
              endif
              if( tryrac ) then
                 ! copy original diagonal, needed to guarantee relative accuracy
                 call stdlib_dcopy(n,d,1,work(indd),1)
              endif
              ! store the squares of the offdiagonal values of t
              do j = 1, n-1
                 work( inde2+j-1 ) = e(j)**2
              end do
              ! set the tolerance parameters for bisection
              if( .not.wantz ) then
                 ! stdlib_dlarre computes the eigenvalues to full precision.
                 rtol1 = four * eps
                 rtol2 = four * eps
              else
                 ! stdlib_dlarre computes the eigenvalues to less than full precision.
                 ! stdlib_dlarrv will refine the eigenvalue approximations, and we can
                 ! need less accurate initial bisection in stdlib_dlarre.
                 ! note: these settings do only affect the subset case and stdlib_dlarre
                 rtol1 = sqrt(eps)
                 rtol2 = max( sqrt(eps)*5.0e-3_dp, four * eps )
              endif
              call stdlib_dlarre( range, n, wl, wu, iil, iiu, d, e,work(inde2), rtol1, rtol2, &
              thresh, nsplit,iwork( iinspl ), m, w, work( inderr ),work( indgp ), iwork( iindbl ),&
              iwork( iindw ), work( indgrs ), pivmin,work( indwrk ), iwork( iindwk ), iinfo )
                        
              if( iinfo/=0 ) then
                 info = 10 + abs( iinfo )
                 return
              end if
              ! note that if range /= 'v', stdlib_dlarre computes bounds on the desired
              ! part of the spectrum. all desired eigenvalues are contained in
              ! (wl,wu]
              if( wantz ) then
                 ! compute the desired eigenvectors corresponding to the computed
                 ! eigenvalues
                 call stdlib_dlarrv( n, wl, wu, d, e,pivmin, iwork( iinspl ), m,1, m, minrgp, &
                 rtol1, rtol2,w, work( inderr ), work( indgp ), iwork( iindbl ),iwork( iindw ), &
                           work( indgrs ), z, ldz,isuppz, work( indwrk ), iwork( iindwk ), iinfo )
                 if( iinfo/=0 ) then
                    info = 20 + abs( iinfo )
                    return
                 end if
              else
                 ! stdlib_dlarre computes eigenvalues of the (shifted) root representation
                 ! stdlib_dlarrv returns the eigenvalues of the unshifted matrix.
                 ! however, if the eigenvectors are not desired by the user, we need
                 ! to apply the corresponding shifts from stdlib_dlarre to obtain the
                 ! eigenvalues of the original matrix.
                 do j = 1, m
                    itmp = iwork( iindbl+j-1 )
                    w( j ) = w( j ) + e( iwork( iinspl+itmp-1 ) )
                 end do
              end if
              if ( tryrac ) then
                 ! refine computed eigenvalues so that they are relatively accurate
                 ! with respect to the original matrix t.
                 ibegin = 1
                 wbegin = 1
                 loop_39: do jblk = 1, iwork( iindbl+m-1 )
                    iend = iwork( iinspl+jblk-1 )
                    in = iend - ibegin + 1
                    wend = wbegin - 1
                    ! check if any eigenvalues have to be refined in this block
                    36 continue
                    if( wend<m ) then
                       if( iwork( iindbl+wend )==jblk ) then
                          wend = wend + 1
                          go to 36
                       end if
                    end if
                    if( wend<wbegin ) then
                       ibegin = iend + 1
                       cycle loop_39
                    end if
                    offset = iwork(iindw+wbegin-1)-1
                    ifirst = iwork(iindw+wbegin-1)
                    ilast = iwork(iindw+wend-1)
                    rtol2 = four * eps
                    call stdlib_dlarrj( in,work(indd+ibegin-1), work(inde2+ibegin-1),ifirst, &
                    ilast, rtol2, offset, w(wbegin),work( inderr+wbegin-1 ),work( indwrk ), iwork(&
                               iindwk ), pivmin,tnrm, iinfo )
                    ibegin = iend + 1
                    wbegin = wend + 1
                 end do loop_39
              endif
              ! if matrix was scaled, then rescale eigenvalues appropriately.
              if( scale/=one ) then
                 call stdlib_dscal( m, one / scale, w, 1 )
              end if
           end if
           ! if eigenvalues are not in increasing order, then sort them,
           ! possibly along with eigenvectors.
           if( nsplit>1 .or. n==2 ) then
              if( .not. wantz ) then
                 call stdlib_dlasrt( 'I', m, w, iinfo )
                 if( iinfo/=0 ) then
                    info = 3
                    return
                 end if
              else
                 do j = 1, m - 1
                    i = 0
                    tmp = w( j )
                    do jj = j + 1, m
                       if( w( jj )<tmp ) then
                          i = jj
                          tmp = w( jj )
                       end if
                    end do
                    if( i/=0 ) then
                       w( i ) = w( j )
                       w( j ) = tmp
                       if( wantz ) then
                          call stdlib_dswap( n, z( 1, i ), 1, z( 1, j ), 1 )
                          itmp = isuppz( 2*i-1 )
                          isuppz( 2*i-1 ) = isuppz( 2*j-1 )
                          isuppz( 2*j-1 ) = itmp
                          itmp = isuppz( 2*i )
                          isuppz( 2*i ) = isuppz( 2*j )
                          isuppz( 2*j ) = itmp
                       end if
                    end if
                 end do
              end if
           endif
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_dstemr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$stemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
     !! DSTEMR: computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
     !! a well defined set of pairwise different real eigenvalues, the corresponding
     !! real eigenvectors are pairwise orthogonal.
     !! The spectrum may be computed either completely or partially by specifying
     !! either an interval (VL,VU] or a range of indices IL:IU for the desired
     !! eigenvalues.
     !! Depending on the number of desired eigenvalues, these are computed either
     !! by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
     !! computed by the use of various suitable L D L^T factorizations near clusters
     !! of close eigenvalues (referred to as RRRs, Relatively Robust
     !! Representations). An informal sketch of the algorithm follows.
     !! For each unreduced block (submatrix) of T,
     !! (a) Compute T - sigma I  = L D L^T, so that L and D
     !! define all the wanted eigenvalues to high relative accuracy.
     !! This means that small relative changes in the entries of D and L
     !! cause only small relative changes in the eigenvalues and
     !! eigenvectors. The standard (unfactored) representation of the
     !! tridiagonal matrix T does not have this property in general.
     !! (b) Compute the eigenvalues to suitable accuracy.
     !! If the eigenvectors are desired, the algorithm attains full
     !! accuracy of the computed eigenvalues only right before
     !! the corresponding vectors have to be computed, see steps c) and d).
     !! (c) For each cluster of close eigenvalues, select a new
     !! shift close to the cluster, find a new factorization, and refine
     !! the shifted eigenvalues to suitable accuracy.
     !! (d) For each eigenvalue with a large enough relative separation compute
     !! the corresponding eigenvector by forming a rank revealing twisted
     !! factorization. Go back to (c) for any clusters that remain.
     !! For more details, see:
     !! - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
     !! to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
     !! Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
     !! - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
     !! Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
     !! 2004.  Also LAPACK Working Note 154.
     !! - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
     !! tridiagonal eigenvalue/eigenvector problem",
     !! Computer Science Division Technical Report No. UCB/CSD-97-971,
     !! UC Berkeley, May 1997.
     !! Further Details
     !! 1.DSTEMR works only on machines which follow IEEE-754
     !! floating-point standard in their handling of infinities and NaNs.
     !! This permits the use of efficient inner loops avoiding a check for
     !! zero divisors.
               isuppz, tryrac, work, lwork,iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           logical(lk), intent(inout) :: tryrac
           integer(ilp), intent(in) :: il, iu, ldz, nzc, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(in) :: vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: w(*), work(*)
           real(${rk}$), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: minrgp = 1.0e-3_${rk}$
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, lquery, valeig, wantz, zquery
           integer(ilp) :: i, ibegin, iend, ifirst, iil, iindbl, iindw, iindwk, iinfo, iinspl, &
           iiu, ilast, in, indd, inde2, inderr, indgp, indgrs, indwrk, itmp, itmp2, j, jblk, jj, &
                     liwmin, lwmin, nsplit, nzcmin, offset, wbegin, wend
           real(${rk}$) :: bignum, cs, eps, pivmin, r1, r2, rmax, rmin, rtol1, rtol2, safmin, scale, &
                     smlnum, sn, thresh, tmp, tnrm, wl, wu
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lquery = ( ( lwork==-1 ).or.( liwork==-1 ) )
           zquery = ( nzc==-1 )
           ! stdlib_${ri}$stemr needs work of size 6*n, iwork of size 3*n.
           ! in addition, stdlib_${ri}$larre needs work of size 6*n, iwork of size 5*n.
           ! furthermore, stdlib_${ri}$larrv needs work of size 12*n, iwork of size 7*n.
           if( wantz ) then
              lwmin = 18*n
              liwmin = 10*n
           else
              ! need less workspace if only the eigenvalues are wanted
              lwmin = 12*n
              liwmin = 8*n
           endif
           wl = zero
           wu = zero
           iil = 0
           iiu = 0
           nsplit = 0
           if( valeig ) then
              ! we do not reference vl, vu in the cases range = 'i','a'
              ! the interval (wl, wu] contains all the wanted eigenvalues.
              ! it is either given by the user or computed in stdlib_${ri}$larre.
              wl = vl
              wu = vu
           elseif( indeig ) then
              ! we do not reference il, iu in the cases range = 'v','a'
              iil = il
              iiu = iu
           endif
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( valeig .and. n>0 .and. wu<=wl ) then
              info = -7
           else if( indeig .and. ( iil<1 .or. iil>n ) ) then
              info = -8
           else if( indeig .and. ( iiu<iil .or. iiu>n ) ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -13
           else if( lwork<lwmin .and. .not.lquery ) then
              info = -17
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -19
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( wantz .and. alleig ) then
                 nzcmin = n
              else if( wantz .and. valeig ) then
                 call stdlib_${ri}$larrc( 'T', n, vl, vu, d, e, safmin,nzcmin, itmp, itmp2, info )
                           
              else if( wantz .and. indeig ) then
                 nzcmin = iiu-iil+1
              else
                 ! wantz == false.
                 nzcmin = 0
              endif
              if( zquery .and. info==0 ) then
                 z( 1,1 ) = nzcmin
              else if( nzc<nzcmin .and. .not.zquery ) then
                 info = -14
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEMR', -info )
              return
           else if( lquery .or. zquery ) then
              return
           end if
           ! handle n = 0, 1, and 2 cases immediately
           m = 0
           if( n==0 )return
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = d( 1 )
              else
                 if( wl<d( 1 ) .and. wu>=d( 1 ) ) then
                    m = 1
                    w( 1 ) = d( 1 )
                 end if
              end if
              if( wantz.and.(.not.zquery) ) then
                 z( 1, 1 ) = one
                 isuppz(1) = 1
                 isuppz(2) = 1
              end if
              return
           end if
           if( n==2 ) then
              if( .not.wantz ) then
                 call stdlib_${ri}$lae2( d(1), e(1), d(2), r1, r2 )
              else if( wantz.and.(.not.zquery) ) then
                 call stdlib_${ri}$laev2( d(1), e(1), d(2), r1, r2, cs, sn )
              end if
              if( alleig.or.(valeig.and.(r2>wl).and.(r2<=wu)).or.(indeig.and.(iil==1)) ) &
                        then
                 m = m+1
                 w( m ) = r2
                 if( wantz.and.(.not.zquery) ) then
                    z( 1, m ) = -sn
                    z( 2, m ) = cs
                    ! note: at most one of sn and cs can be zero.
                    if (sn/=zero) then
                       if (cs/=zero) then
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 2
                       else
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 1
                       end if
                    else
                       isuppz(2*m-1) = 2
                       isuppz(2*m) = 2
                    end if
                 endif
              endif
              if( alleig.or.(valeig.and.(r1>wl).and.(r1<=wu)).or.(indeig.and.(iiu==2)) ) &
                        then
                 m = m+1
                 w( m ) = r1
                 if( wantz.and.(.not.zquery) ) then
                    z( 1, m ) = cs
                    z( 2, m ) = sn
                    ! note: at most one of sn and cs can be zero.
                    if (sn/=zero) then
                       if (cs/=zero) then
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 2
                       else
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 1
                       end if
                    else
                       isuppz(2*m-1) = 2
                       isuppz(2*m) = 2
                    end if
                 endif
              endif
           else
           ! continue with general n
              indgrs = 1
              inderr = 2*n + 1
              indgp = 3*n + 1
              indd = 4*n + 1
              inde2 = 5*n + 1
              indwrk = 6*n + 1
              iinspl = 1
              iindbl = n + 1
              iindw = 2*n + 1
              iindwk = 3*n + 1
              ! scale matrix to allowable range, if necessary.
              ! the allowable range is related to the pivmin parameter; see the
              ! comments in stdlib_${ri}$larrd.  the preference for scaling small values
              ! up is heuristic; we expect users' matrices not to be close to the
              ! rmax threshold.
              scale = one
              tnrm = stdlib_${ri}$lanst( 'M', n, d, e )
              if( tnrm>zero .and. tnrm<rmin ) then
                 scale = rmin / tnrm
              else if( tnrm>rmax ) then
                 scale = rmax / tnrm
              end if
              if( scale/=one ) then
                 call stdlib_${ri}$scal( n, scale, d, 1 )
                 call stdlib_${ri}$scal( n-1, scale, e, 1 )
                 tnrm = tnrm*scale
                 if( valeig ) then
                    ! if eigenvalues in interval have to be found,
                    ! scale (wl, wu] accordingly
                    wl = wl*scale
                    wu = wu*scale
                 endif
              end if
              ! compute the desired eigenvalues of the tridiagonal after splitting
              ! into smaller subblocks if the corresponding off-diagonal elements
              ! are small
              ! thresh is the splitting parameter for stdlib_${ri}$larre
              ! a negative thresh forces the old splitting criterion based on the
              ! size of the off-diagonal. a positive thresh switches to splitting
              ! which preserves relative accuracy.
              if( tryrac ) then
                 ! test whether the matrix warrants the more expensive relative approach.
                 call stdlib_${ri}$larrr( n, d, e, iinfo )
              else
                 ! the user does not care about relative accurately eigenvalues
                 iinfo = -1
              endif
              ! set the splitting criterion
              if (iinfo==0) then
                 thresh = eps
              else
                 thresh = -eps
                 ! relative accuracy is desired but t does not guarantee it
                 tryrac = .false.
              endif
              if( tryrac ) then
                 ! copy original diagonal, needed to guarantee relative accuracy
                 call stdlib_${ri}$copy(n,d,1,work(indd),1)
              endif
              ! store the squares of the offdiagonal values of t
              do j = 1, n-1
                 work( inde2+j-1 ) = e(j)**2
              end do
              ! set the tolerance parameters for bisection
              if( .not.wantz ) then
                 ! stdlib_${ri}$larre computes the eigenvalues to full precision.
                 rtol1 = four * eps
                 rtol2 = four * eps
              else
                 ! stdlib_${ri}$larre computes the eigenvalues to less than full precision.
                 ! stdlib_${ri}$larrv will refine the eigenvalue approximations, and we can
                 ! need less accurate initial bisection in stdlib_${ri}$larre.
                 ! note: these settings do only affect the subset case and stdlib_${ri}$larre
                 rtol1 = sqrt(eps)
                 rtol2 = max( sqrt(eps)*5.0e-3_${rk}$, four * eps )
              endif
              call stdlib_${ri}$larre( range, n, wl, wu, iil, iiu, d, e,work(inde2), rtol1, rtol2, &
              thresh, nsplit,iwork( iinspl ), m, w, work( inderr ),work( indgp ), iwork( iindbl ),&
              iwork( iindw ), work( indgrs ), pivmin,work( indwrk ), iwork( iindwk ), iinfo )
                        
              if( iinfo/=0 ) then
                 info = 10 + abs( iinfo )
                 return
              end if
              ! note that if range /= 'v', stdlib_${ri}$larre computes bounds on the desired
              ! part of the spectrum. all desired eigenvalues are contained in
              ! (wl,wu]
              if( wantz ) then
                 ! compute the desired eigenvectors corresponding to the computed
                 ! eigenvalues
                 call stdlib_${ri}$larrv( n, wl, wu, d, e,pivmin, iwork( iinspl ), m,1, m, minrgp, &
                 rtol1, rtol2,w, work( inderr ), work( indgp ), iwork( iindbl ),iwork( iindw ), &
                           work( indgrs ), z, ldz,isuppz, work( indwrk ), iwork( iindwk ), iinfo )
                 if( iinfo/=0 ) then
                    info = 20 + abs( iinfo )
                    return
                 end if
              else
                 ! stdlib_${ri}$larre computes eigenvalues of the (shifted) root representation
                 ! stdlib_${ri}$larrv returns the eigenvalues of the unshifted matrix.
                 ! however, if the eigenvectors are not desired by the user, we need
                 ! to apply the corresponding shifts from stdlib_${ri}$larre to obtain the
                 ! eigenvalues of the original matrix.
                 do j = 1, m
                    itmp = iwork( iindbl+j-1 )
                    w( j ) = w( j ) + e( iwork( iinspl+itmp-1 ) )
                 end do
              end if
              if ( tryrac ) then
                 ! refine computed eigenvalues so that they are relatively accurate
                 ! with respect to the original matrix t.
                 ibegin = 1
                 wbegin = 1
                 loop_39: do jblk = 1, iwork( iindbl+m-1 )
                    iend = iwork( iinspl+jblk-1 )
                    in = iend - ibegin + 1
                    wend = wbegin - 1
                    ! check if any eigenvalues have to be refined in this block
                    36 continue
                    if( wend<m ) then
                       if( iwork( iindbl+wend )==jblk ) then
                          wend = wend + 1
                          go to 36
                       end if
                    end if
                    if( wend<wbegin ) then
                       ibegin = iend + 1
                       cycle loop_39
                    end if
                    offset = iwork(iindw+wbegin-1)-1
                    ifirst = iwork(iindw+wbegin-1)
                    ilast = iwork(iindw+wend-1)
                    rtol2 = four * eps
                    call stdlib_${ri}$larrj( in,work(indd+ibegin-1), work(inde2+ibegin-1),ifirst, &
                    ilast, rtol2, offset, w(wbegin),work( inderr+wbegin-1 ),work( indwrk ), iwork(&
                               iindwk ), pivmin,tnrm, iinfo )
                    ibegin = iend + 1
                    wbegin = wend + 1
                 end do loop_39
              endif
              ! if matrix was scaled, then rescale eigenvalues appropriately.
              if( scale/=one ) then
                 call stdlib_${ri}$scal( m, one / scale, w, 1 )
              end if
           end if
           ! if eigenvalues are not in increasing order, then sort them,
           ! possibly along with eigenvectors.
           if( nsplit>1 .or. n==2 ) then
              if( .not. wantz ) then
                 call stdlib_${ri}$lasrt( 'I', m, w, iinfo )
                 if( iinfo/=0 ) then
                    info = 3
                    return
                 end if
              else
                 do j = 1, m - 1
                    i = 0
                    tmp = w( j )
                    do jj = j + 1, m
                       if( w( jj )<tmp ) then
                          i = jj
                          tmp = w( jj )
                       end if
                    end do
                    if( i/=0 ) then
                       w( i ) = w( j )
                       w( j ) = tmp
                       if( wantz ) then
                          call stdlib_${ri}$swap( n, z( 1, i ), 1, z( 1, j ), 1 )
                          itmp = isuppz( 2*i-1 )
                          isuppz( 2*i-1 ) = isuppz( 2*j-1 )
                          isuppz( 2*j-1 ) = itmp
                          itmp = isuppz( 2*i )
                          isuppz( 2*i ) = isuppz( 2*j )
                          isuppz( 2*j ) = itmp
                       end if
                    end if
                 end do
              end if
           endif
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$stemr

#:endif
#:endfor

     pure subroutine stdlib_cstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
     !! CSTEMR computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
     !! a well defined set of pairwise different real eigenvalues, the corresponding
     !! real eigenvectors are pairwise orthogonal.
     !! The spectrum may be computed either completely or partially by specifying
     !! either an interval (VL,VU] or a range of indices IL:IU for the desired
     !! eigenvalues.
     !! Depending on the number of desired eigenvalues, these are computed either
     !! by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
     !! computed by the use of various suitable L D L^T factorizations near clusters
     !! of close eigenvalues (referred to as RRRs, Relatively Robust
     !! Representations). An informal sketch of the algorithm follows.
     !! For each unreduced block (submatrix) of T,
     !! (a) Compute T - sigma I  = L D L^T, so that L and D
     !! define all the wanted eigenvalues to high relative accuracy.
     !! This means that small relative changes in the entries of D and L
     !! cause only small relative changes in the eigenvalues and
     !! eigenvectors. The standard (unfactored) representation of the
     !! tridiagonal matrix T does not have this property in general.
     !! (b) Compute the eigenvalues to suitable accuracy.
     !! If the eigenvectors are desired, the algorithm attains full
     !! accuracy of the computed eigenvalues only right before
     !! the corresponding vectors have to be computed, see steps c) and d).
     !! (c) For each cluster of close eigenvalues, select a new
     !! shift close to the cluster, find a new factorization, and refine
     !! the shifted eigenvalues to suitable accuracy.
     !! (d) For each eigenvalue with a large enough relative separation compute
     !! the corresponding eigenvector by forming a rank revealing twisted
     !! factorization. Go back to (c) for any clusters that remain.
     !! For more details, see:
     !! - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
     !! to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
     !! Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
     !! - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
     !! Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
     !! 2004.  Also LAPACK Working Note 154.
     !! - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
     !! tridiagonal eigenvalue/eigenvector problem",
     !! Computer Science Division Technical Report No. UCB/CSD-97-971,
     !! UC Berkeley, May 1997.
     !! Further Details
     !! 1.CSTEMR works only on machines which follow IEEE-754
     !! floating-point standard in their handling of infinities and NaNs.
     !! This permits the use of efficient inner loops avoiding a check for
     !! zero divisors.
     !! 2. LAPACK routines can be used to reduce a complex Hermitean matrix to
     !! real symmetric tridiagonal form.
     !! (Any complex Hermitean tridiagonal matrix has real values on its diagonal
     !! and potentially complex numbers on its off-diagonals. By applying a
     !! similarity transform with an appropriate diagonal matrix
     !! diag(1,e^{i \phy_1}, ... , e^{i \phy_{n-1}}), the complex Hermitean
     !! matrix can be transformed into a real symmetric matrix and complex
     !! arithmetic can be entirely avoided.)
     !! While the eigenvectors of the real symmetric tridiagonal matrix are real,
     !! the eigenvectors of original complex Hermitean matrix have complex entries
     !! in general.
     !! Since LAPACK drivers overwrite the matrix data with the eigenvectors,
     !! CSTEMR accepts complex workspace to facilitate interoperability
     !! with CUNMTR or CUPMTR.
               isuppz, tryrac, work, lwork,iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           logical(lk), intent(inout) :: tryrac
           integer(ilp), intent(in) :: il, iu, ldz, nzc, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(in) :: vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: w(*), work(*)
           complex(sp), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: minrgp = 3.0e-3_sp
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, lquery, valeig, wantz, zquery
           integer(ilp) :: i, ibegin, iend, ifirst, iil, iindbl, iindw, iindwk, iinfo, iinspl, &
           iiu, ilast, in, indd, inde2, inderr, indgp, indgrs, indwrk, itmp, itmp2, j, jblk, jj, &
                     liwmin, lwmin, nsplit, nzcmin, offset, wbegin, wend
           real(sp) :: bignum, cs, eps, pivmin, r1, r2, rmax, rmin, rtol1, rtol2, safmin, scale, &
                     smlnum, sn, thresh, tmp, tnrm, wl, wu
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lquery = ( ( lwork==-1 ).or.( liwork==-1 ) )
           zquery = ( nzc==-1 )
           ! stdlib_sstemr needs work of size 6*n, iwork of size 3*n.
           ! in addition, stdlib_slarre needs work of size 6*n, iwork of size 5*n.
           ! furthermore, stdlib_clarrv needs work of size 12*n, iwork of size 7*n.
           if( wantz ) then
              lwmin = 18*n
              liwmin = 10*n
           else
              ! need less workspace if only the eigenvalues are wanted
              lwmin = 12*n
              liwmin = 8*n
           endif
           wl = zero
           wu = zero
           iil = 0
           iiu = 0
           nsplit = 0
           if( valeig ) then
              ! we do not reference vl, vu in the cases range = 'i','a'
              ! the interval (wl, wu] contains all the wanted eigenvalues.
              ! it is either given by the user or computed in stdlib_slarre.
              wl = vl
              wu = vu
           elseif( indeig ) then
              ! we do not reference il, iu in the cases range = 'v','a'
              iil = il
              iiu = iu
           endif
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( valeig .and. n>0 .and. wu<=wl ) then
              info = -7
           else if( indeig .and. ( iil<1 .or. iil>n ) ) then
              info = -8
           else if( indeig .and. ( iiu<iil .or. iiu>n ) ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -13
           else if( lwork<lwmin .and. .not.lquery ) then
              info = -17
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -19
           end if
           ! get machine constants.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           eps = stdlib_slamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( wantz .and. alleig ) then
                 nzcmin = n
              else if( wantz .and. valeig ) then
                 call stdlib_slarrc( 'T', n, vl, vu, d, e, safmin,nzcmin, itmp, itmp2, info )
                           
              else if( wantz .and. indeig ) then
                 nzcmin = iiu-iil+1
              else
                 ! wantz == false.
                 nzcmin = 0
              endif
              if( zquery .and. info==0 ) then
                 z( 1,1 ) = nzcmin
              else if( nzc<nzcmin .and. .not.zquery ) then
                 info = -14
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSTEMR', -info )
              return
           else if( lquery .or. zquery ) then
              return
           end if
           ! handle n = 0, 1, and 2 cases immediately
           m = 0
           if( n==0 )return
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = d( 1 )
              else
                 if( wl<d( 1 ) .and. wu>=d( 1 ) ) then
                    m = 1
                    w( 1 ) = d( 1 )
                 end if
              end if
              if( wantz.and.(.not.zquery) ) then
                 z( 1, 1 ) = one
                 isuppz(1) = 1
                 isuppz(2) = 1
              end if
              return
           end if
           if( n==2 ) then
              if( .not.wantz ) then
                 call stdlib_slae2( d(1), e(1), d(2), r1, r2 )
              else if( wantz.and.(.not.zquery) ) then
                 call stdlib_slaev2( d(1), e(1), d(2), r1, r2, cs, sn )
              end if
              if( alleig.or.(valeig.and.(r2>wl).and.(r2<=wu)).or.(indeig.and.(iil==1)) ) &
                        then
                 m = m+1
                 w( m ) = r2
                 if( wantz.and.(.not.zquery) ) then
                    z( 1, m ) = -sn
                    z( 2, m ) = cs
                    ! note: at most one of sn and cs can be zero.
                    if (sn/=zero) then
                       if (cs/=zero) then
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 2
                       else
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 1
                       end if
                    else
                       isuppz(2*m-1) = 2
                       isuppz(2*m) = 2
                    end if
                 endif
              endif
              if( alleig.or.(valeig.and.(r1>wl).and.(r1<=wu)).or.(indeig.and.(iiu==2)) ) &
                        then
                 m = m+1
                 w( m ) = r1
                 if( wantz.and.(.not.zquery) ) then
                    z( 1, m ) = cs
                    z( 2, m ) = sn
                    ! note: at most one of sn and cs can be zero.
                    if (sn/=zero) then
                       if (cs/=zero) then
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 2
                       else
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 1
                       end if
                    else
                       isuppz(2*m-1) = 2
                       isuppz(2*m) = 2
                    end if
                 endif
              endif
           else
              ! continue with general n
              indgrs = 1
              inderr = 2*n + 1
              indgp = 3*n + 1
              indd = 4*n + 1
              inde2 = 5*n + 1
              indwrk = 6*n + 1
              iinspl = 1
              iindbl = n + 1
              iindw = 2*n + 1
              iindwk = 3*n + 1
              ! scale matrix to allowable range, if necessary.
              ! the allowable range is related to the pivmin parameter; see the
              ! comments in stdlib_slarrd.  the preference for scaling small values
              ! up is heuristic; we expect users' matrices not to be close to the
              ! rmax threshold.
              scale = one
              tnrm = stdlib_slanst( 'M', n, d, e )
              if( tnrm>zero .and. tnrm<rmin ) then
                 scale = rmin / tnrm
              else if( tnrm>rmax ) then
                 scale = rmax / tnrm
              end if
              if( scale/=one ) then
                 call stdlib_sscal( n, scale, d, 1 )
                 call stdlib_sscal( n-1, scale, e, 1 )
                 tnrm = tnrm*scale
                 if( valeig ) then
                    ! if eigenvalues in interval have to be found,
                    ! scale (wl, wu] accordingly
                    wl = wl*scale
                    wu = wu*scale
                 endif
              end if
              ! compute the desired eigenvalues of the tridiagonal after splitting
              ! into smaller subblocks if the corresponding off-diagonal elements
              ! are small
              ! thresh is the splitting parameter for stdlib_slarre
              ! a negative thresh forces the old splitting criterion based on the
              ! size of the off-diagonal. a positive thresh switches to splitting
              ! which preserves relative accuracy.
              if( tryrac ) then
                 ! test whether the matrix warrants the more expensive relative approach.
                 call stdlib_slarrr( n, d, e, iinfo )
              else
                 ! the user does not care about relative accurately eigenvalues
                 iinfo = -1
              endif
              ! set the splitting criterion
              if (iinfo==0) then
                 thresh = eps
              else
                 thresh = -eps
                 ! relative accuracy is desired but t does not guarantee it
                 tryrac = .false.
              endif
              if( tryrac ) then
                 ! copy original diagonal, needed to guarantee relative accuracy
                 call stdlib_scopy(n,d,1,work(indd),1)
              endif
              ! store the squares of the offdiagonal values of t
              do j = 1, n-1
                 work( inde2+j-1 ) = e(j)**2
              end do
              ! set the tolerance parameters for bisection
              if( .not.wantz ) then
                 ! stdlib_slarre computes the eigenvalues to full precision.
                 rtol1 = four * eps
                 rtol2 = four * eps
              else
                 ! stdlib_slarre computes the eigenvalues to less than full precision.
                 ! stdlib_clarrv will refine the eigenvalue approximations, and we only
                 ! need less accurate initial bisection in stdlib_slarre.
                 ! note: these settings do only affect the subset case and stdlib_slarre
                 rtol1 = max( sqrt(eps)*5.0e-2_sp, four * eps )
                 rtol2 = max( sqrt(eps)*5.0e-3_sp, four * eps )
              endif
              call stdlib_slarre( range, n, wl, wu, iil, iiu, d, e,work(inde2), rtol1, rtol2, &
              thresh, nsplit,iwork( iinspl ), m, w, work( inderr ),work( indgp ), iwork( iindbl ),&
              iwork( iindw ), work( indgrs ), pivmin,work( indwrk ), iwork( iindwk ), iinfo )
                        
              if( iinfo/=0 ) then
                 info = 10 + abs( iinfo )
                 return
              end if
              ! note that if range /= 'v', stdlib_slarre computes bounds on the desired
              ! part of the spectrum. all desired eigenvalues are contained in
              ! (wl,wu]
              if( wantz ) then
                 ! compute the desired eigenvectors corresponding to the computed
                 ! eigenvalues
                 call stdlib_clarrv( n, wl, wu, d, e,pivmin, iwork( iinspl ), m,1, m, minrgp, &
                 rtol1, rtol2,w, work( inderr ), work( indgp ), iwork( iindbl ),iwork( iindw ), &
                           work( indgrs ), z, ldz,isuppz, work( indwrk ), iwork( iindwk ), iinfo )
                 if( iinfo/=0 ) then
                    info = 20 + abs( iinfo )
                    return
                 end if
              else
                 ! stdlib_slarre computes eigenvalues of the (shifted) root representation
                 ! stdlib_clarrv returns the eigenvalues of the unshifted matrix.
                 ! however, if the eigenvectors are not desired by the user, we need
                 ! to apply the corresponding shifts from stdlib_slarre to obtain the
                 ! eigenvalues of the original matrix.
                 do j = 1, m
                    itmp = iwork( iindbl+j-1 )
                    w( j ) = w( j ) + e( iwork( iinspl+itmp-1 ) )
                 end do
              end if
              if ( tryrac ) then
                 ! refine computed eigenvalues so that they are relatively accurate
                 ! with respect to the original matrix t.
                 ibegin = 1
                 wbegin = 1
                 loop_39: do jblk = 1, iwork( iindbl+m-1 )
                    iend = iwork( iinspl+jblk-1 )
                    in = iend - ibegin + 1
                    wend = wbegin - 1
                    ! check if any eigenvalues have to be refined in this block
                    36 continue
                    if( wend<m ) then
                       if( iwork( iindbl+wend )==jblk ) then
                          wend = wend + 1
                          go to 36
                       end if
                    end if
                    if( wend<wbegin ) then
                       ibegin = iend + 1
                       cycle loop_39
                    end if
                    offset = iwork(iindw+wbegin-1)-1
                    ifirst = iwork(iindw+wbegin-1)
                    ilast = iwork(iindw+wend-1)
                    rtol2 = four * eps
                    call stdlib_slarrj( in,work(indd+ibegin-1), work(inde2+ibegin-1),ifirst, &
                    ilast, rtol2, offset, w(wbegin),work( inderr+wbegin-1 ),work( indwrk ), iwork(&
                               iindwk ), pivmin,tnrm, iinfo )
                    ibegin = iend + 1
                    wbegin = wend + 1
                 end do loop_39
              endif
              ! if matrix was scaled, then rescale eigenvalues appropriately.
              if( scale/=one ) then
                 call stdlib_sscal( m, one / scale, w, 1 )
              end if
           end if
           ! if eigenvalues are not in increasing order, then sort them,
           ! possibly along with eigenvectors.
           if( nsplit>1 .or. n==2 ) then
              if( .not. wantz ) then
                 call stdlib_slasrt( 'I', m, w, iinfo )
                 if( iinfo/=0 ) then
                    info = 3
                    return
                 end if
              else
                 do j = 1, m - 1
                    i = 0
                    tmp = w( j )
                    do jj = j + 1, m
                       if( w( jj )<tmp ) then
                          i = jj
                          tmp = w( jj )
                       end if
                    end do
                    if( i/=0 ) then
                       w( i ) = w( j )
                       w( j ) = tmp
                       if( wantz ) then
                          call stdlib_cswap( n, z( 1, i ), 1, z( 1, j ), 1 )
                          itmp = isuppz( 2*i-1 )
                          isuppz( 2*i-1 ) = isuppz( 2*j-1 )
                          isuppz( 2*j-1 ) = itmp
                          itmp = isuppz( 2*i )
                          isuppz( 2*i ) = isuppz( 2*j )
                          isuppz( 2*j ) = itmp
                       end if
                    end if
                 end do
              end if
           endif
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_cstemr

     pure subroutine stdlib_zstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
     !! ZSTEMR computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
     !! a well defined set of pairwise different real eigenvalues, the corresponding
     !! real eigenvectors are pairwise orthogonal.
     !! The spectrum may be computed either completely or partially by specifying
     !! either an interval (VL,VU] or a range of indices IL:IU for the desired
     !! eigenvalues.
     !! Depending on the number of desired eigenvalues, these are computed either
     !! by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
     !! computed by the use of various suitable L D L^T factorizations near clusters
     !! of close eigenvalues (referred to as RRRs, Relatively Robust
     !! Representations). An informal sketch of the algorithm follows.
     !! For each unreduced block (submatrix) of T,
     !! (a) Compute T - sigma I  = L D L^T, so that L and D
     !! define all the wanted eigenvalues to high relative accuracy.
     !! This means that small relative changes in the entries of D and L
     !! cause only small relative changes in the eigenvalues and
     !! eigenvectors. The standard (unfactored) representation of the
     !! tridiagonal matrix T does not have this property in general.
     !! (b) Compute the eigenvalues to suitable accuracy.
     !! If the eigenvectors are desired, the algorithm attains full
     !! accuracy of the computed eigenvalues only right before
     !! the corresponding vectors have to be computed, see steps c) and d).
     !! (c) For each cluster of close eigenvalues, select a new
     !! shift close to the cluster, find a new factorization, and refine
     !! the shifted eigenvalues to suitable accuracy.
     !! (d) For each eigenvalue with a large enough relative separation compute
     !! the corresponding eigenvector by forming a rank revealing twisted
     !! factorization. Go back to (c) for any clusters that remain.
     !! For more details, see:
     !! - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
     !! to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
     !! Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
     !! - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
     !! Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
     !! 2004.  Also LAPACK Working Note 154.
     !! - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
     !! tridiagonal eigenvalue/eigenvector problem",
     !! Computer Science Division Technical Report No. UCB/CSD-97-971,
     !! UC Berkeley, May 1997.
     !! Further Details
     !! 1.ZSTEMR works only on machines which follow IEEE-754
     !! floating-point standard in their handling of infinities and NaNs.
     !! This permits the use of efficient inner loops avoiding a check for
     !! zero divisors.
     !! 2. LAPACK routines can be used to reduce a complex Hermitean matrix to
     !! real symmetric tridiagonal form.
     !! (Any complex Hermitean tridiagonal matrix has real values on its diagonal
     !! and potentially complex numbers on its off-diagonals. By applying a
     !! similarity transform with an appropriate diagonal matrix
     !! diag(1,e^{i \phy_1}, ... , e^{i \phy_{n-1}}), the complex Hermitean
     !! matrix can be transformed into a real symmetric matrix and complex
     !! arithmetic can be entirely avoided.)
     !! While the eigenvectors of the real symmetric tridiagonal matrix are real,
     !! the eigenvectors of original complex Hermitean matrix have complex entries
     !! in general.
     !! Since LAPACK drivers overwrite the matrix data with the eigenvectors,
     !! ZSTEMR accepts complex workspace to facilitate interoperability
     !! with ZUNMTR or ZUPMTR.
               isuppz, tryrac, work, lwork,iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           logical(lk), intent(inout) :: tryrac
           integer(ilp), intent(in) :: il, iu, ldz, nzc, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(dp), intent(in) :: vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: w(*), work(*)
           complex(dp), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: minrgp = 1.0e-3_dp
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, lquery, valeig, wantz, zquery
           integer(ilp) :: i, ibegin, iend, ifirst, iil, iindbl, iindw, iindwk, iinfo, iinspl, &
           iiu, ilast, in, indd, inde2, inderr, indgp, indgrs, indwrk, itmp, itmp2, j, jblk, jj, &
                     liwmin, lwmin, nsplit, nzcmin, offset, wbegin, wend
           real(dp) :: bignum, cs, eps, pivmin, r1, r2, rmax, rmin, rtol1, rtol2, safmin, scale, &
                     smlnum, sn, thresh, tmp, tnrm, wl, wu
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lquery = ( ( lwork==-1 ).or.( liwork==-1 ) )
           zquery = ( nzc==-1 )
           ! stdlib_dstemr needs work of size 6*n, iwork of size 3*n.
           ! in addition, stdlib_dlarre needs work of size 6*n, iwork of size 5*n.
           ! furthermore, stdlib_zlarrv needs work of size 12*n, iwork of size 7*n.
           if( wantz ) then
              lwmin = 18*n
              liwmin = 10*n
           else
              ! need less workspace if only the eigenvalues are wanted
              lwmin = 12*n
              liwmin = 8*n
           endif
           wl = zero
           wu = zero
           iil = 0
           iiu = 0
           nsplit = 0
           if( valeig ) then
              ! we do not reference vl, vu in the cases range = 'i','a'
              ! the interval (wl, wu] contains all the wanted eigenvalues.
              ! it is either given by the user or computed in stdlib_dlarre.
              wl = vl
              wu = vu
           elseif( indeig ) then
              ! we do not reference il, iu in the cases range = 'v','a'
              iil = il
              iiu = iu
           endif
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( valeig .and. n>0 .and. wu<=wl ) then
              info = -7
           else if( indeig .and. ( iil<1 .or. iil>n ) ) then
              info = -8
           else if( indeig .and. ( iiu<iil .or. iiu>n ) ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -13
           else if( lwork<lwmin .and. .not.lquery ) then
              info = -17
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -19
           end if
           ! get machine constants.
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           eps = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( wantz .and. alleig ) then
                 nzcmin = n
              else if( wantz .and. valeig ) then
                 call stdlib_dlarrc( 'T', n, vl, vu, d, e, safmin,nzcmin, itmp, itmp2, info )
                           
              else if( wantz .and. indeig ) then
                 nzcmin = iiu-iil+1
              else
                 ! wantz == false.
                 nzcmin = 0
              endif
              if( zquery .and. info==0 ) then
                 z( 1,1 ) = nzcmin
              else if( nzc<nzcmin .and. .not.zquery ) then
                 info = -14
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSTEMR', -info )
              return
           else if( lquery .or. zquery ) then
              return
           end if
           ! handle n = 0, 1, and 2 cases immediately
           m = 0
           if( n==0 )return
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = d( 1 )
              else
                 if( wl<d( 1 ) .and. wu>=d( 1 ) ) then
                    m = 1
                    w( 1 ) = d( 1 )
                 end if
              end if
              if( wantz.and.(.not.zquery) ) then
                 z( 1, 1 ) = one
                 isuppz(1) = 1
                 isuppz(2) = 1
              end if
              return
           end if
           if( n==2 ) then
              if( .not.wantz ) then
                 call stdlib_dlae2( d(1), e(1), d(2), r1, r2 )
              else if( wantz.and.(.not.zquery) ) then
                 call stdlib_dlaev2( d(1), e(1), d(2), r1, r2, cs, sn )
              end if
              if( alleig.or.(valeig.and.(r2>wl).and.(r2<=wu)).or.(indeig.and.(iil==1)) ) &
                        then
                 m = m+1
                 w( m ) = r2
                 if( wantz.and.(.not.zquery) ) then
                    z( 1, m ) = -sn
                    z( 2, m ) = cs
                    ! note: at most one of sn and cs can be zero.
                    if (sn/=zero) then
                       if (cs/=zero) then
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 2
                       else
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 1
                       end if
                    else
                       isuppz(2*m-1) = 2
                       isuppz(2*m) = 2
                    end if
                 endif
              endif
              if( alleig.or.(valeig.and.(r1>wl).and.(r1<=wu)).or.(indeig.and.(iiu==2)) ) &
                        then
                 m = m+1
                 w( m ) = r1
                 if( wantz.and.(.not.zquery) ) then
                    z( 1, m ) = cs
                    z( 2, m ) = sn
                    ! note: at most one of sn and cs can be zero.
                    if (sn/=zero) then
                       if (cs/=zero) then
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 2
                       else
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 1
                       end if
                    else
                       isuppz(2*m-1) = 2
                       isuppz(2*m) = 2
                    end if
                 endif
              endif
           else
              ! continue with general n
              indgrs = 1
              inderr = 2*n + 1
              indgp = 3*n + 1
              indd = 4*n + 1
              inde2 = 5*n + 1
              indwrk = 6*n + 1
              iinspl = 1
              iindbl = n + 1
              iindw = 2*n + 1
              iindwk = 3*n + 1
              ! scale matrix to allowable range, if necessary.
              ! the allowable range is related to the pivmin parameter; see the
              ! comments in stdlib_dlarrd.  the preference for scaling small values
              ! up is heuristic; we expect users' matrices not to be close to the
              ! rmax threshold.
              scale = one
              tnrm = stdlib_dlanst( 'M', n, d, e )
              if( tnrm>zero .and. tnrm<rmin ) then
                 scale = rmin / tnrm
              else if( tnrm>rmax ) then
                 scale = rmax / tnrm
              end if
              if( scale/=one ) then
                 call stdlib_dscal( n, scale, d, 1 )
                 call stdlib_dscal( n-1, scale, e, 1 )
                 tnrm = tnrm*scale
                 if( valeig ) then
                    ! if eigenvalues in interval have to be found,
                    ! scale (wl, wu] accordingly
                    wl = wl*scale
                    wu = wu*scale
                 endif
              end if
              ! compute the desired eigenvalues of the tridiagonal after splitting
              ! into smaller subblocks if the corresponding off-diagonal elements
              ! are small
              ! thresh is the splitting parameter for stdlib_dlarre
              ! a negative thresh forces the old splitting criterion based on the
              ! size of the off-diagonal. a positive thresh switches to splitting
              ! which preserves relative accuracy.
              if( tryrac ) then
                 ! test whether the matrix warrants the more expensive relative approach.
                 call stdlib_dlarrr( n, d, e, iinfo )
              else
                 ! the user does not care about relative accurately eigenvalues
                 iinfo = -1
              endif
              ! set the splitting criterion
              if (iinfo==0) then
                 thresh = eps
              else
                 thresh = -eps
                 ! relative accuracy is desired but t does not guarantee it
                 tryrac = .false.
              endif
              if( tryrac ) then
                 ! copy original diagonal, needed to guarantee relative accuracy
                 call stdlib_dcopy(n,d,1,work(indd),1)
              endif
              ! store the squares of the offdiagonal values of t
              do j = 1, n-1
                 work( inde2+j-1 ) = e(j)**2
              end do
              ! set the tolerance parameters for bisection
              if( .not.wantz ) then
                 ! stdlib_dlarre computes the eigenvalues to full precision.
                 rtol1 = four * eps
                 rtol2 = four * eps
              else
                 ! stdlib_dlarre computes the eigenvalues to less than full precision.
                 ! stdlib_zlarrv will refine the eigenvalue approximations, and we only
                 ! need less accurate initial bisection in stdlib_dlarre.
                 ! note: these settings do only affect the subset case and stdlib_dlarre
                 rtol1 = sqrt(eps)
                 rtol2 = max( sqrt(eps)*5.0e-3_dp, four * eps )
              endif
              call stdlib_dlarre( range, n, wl, wu, iil, iiu, d, e,work(inde2), rtol1, rtol2, &
              thresh, nsplit,iwork( iinspl ), m, w, work( inderr ),work( indgp ), iwork( iindbl ),&
              iwork( iindw ), work( indgrs ), pivmin,work( indwrk ), iwork( iindwk ), iinfo )
                        
              if( iinfo/=0 ) then
                 info = 10 + abs( iinfo )
                 return
              end if
              ! note that if range /= 'v', stdlib_dlarre computes bounds on the desired
              ! part of the spectrum. all desired eigenvalues are contained in
              ! (wl,wu]
              if( wantz ) then
                 ! compute the desired eigenvectors corresponding to the computed
                 ! eigenvalues
                 call stdlib_zlarrv( n, wl, wu, d, e,pivmin, iwork( iinspl ), m,1, m, minrgp, &
                 rtol1, rtol2,w, work( inderr ), work( indgp ), iwork( iindbl ),iwork( iindw ), &
                           work( indgrs ), z, ldz,isuppz, work( indwrk ), iwork( iindwk ), iinfo )
                 if( iinfo/=0 ) then
                    info = 20 + abs( iinfo )
                    return
                 end if
              else
                 ! stdlib_dlarre computes eigenvalues of the (shifted) root representation
                 ! stdlib_zlarrv returns the eigenvalues of the unshifted matrix.
                 ! however, if the eigenvectors are not desired by the user, we need
                 ! to apply the corresponding shifts from stdlib_dlarre to obtain the
                 ! eigenvalues of the original matrix.
                 do j = 1, m
                    itmp = iwork( iindbl+j-1 )
                    w( j ) = w( j ) + e( iwork( iinspl+itmp-1 ) )
                 end do
              end if
              if ( tryrac ) then
                 ! refine computed eigenvalues so that they are relatively accurate
                 ! with respect to the original matrix t.
                 ibegin = 1
                 wbegin = 1
                 loop_39: do jblk = 1, iwork( iindbl+m-1 )
                    iend = iwork( iinspl+jblk-1 )
                    in = iend - ibegin + 1
                    wend = wbegin - 1
                    ! check if any eigenvalues have to be refined in this block
                    36 continue
                    if( wend<m ) then
                       if( iwork( iindbl+wend )==jblk ) then
                          wend = wend + 1
                          go to 36
                       end if
                    end if
                    if( wend<wbegin ) then
                       ibegin = iend + 1
                       cycle loop_39
                    end if
                    offset = iwork(iindw+wbegin-1)-1
                    ifirst = iwork(iindw+wbegin-1)
                    ilast = iwork(iindw+wend-1)
                    rtol2 = four * eps
                    call stdlib_dlarrj( in,work(indd+ibegin-1), work(inde2+ibegin-1),ifirst, &
                    ilast, rtol2, offset, w(wbegin),work( inderr+wbegin-1 ),work( indwrk ), iwork(&
                               iindwk ), pivmin,tnrm, iinfo )
                    ibegin = iend + 1
                    wbegin = wend + 1
                 end do loop_39
              endif
              ! if matrix was scaled, then rescale eigenvalues appropriately.
              if( scale/=one ) then
                 call stdlib_dscal( m, one / scale, w, 1 )
              end if
           end if
           ! if eigenvalues are not in increasing order, then sort them,
           ! possibly along with eigenvectors.
           if( nsplit>1 .or. n==2 ) then
              if( .not. wantz ) then
                 call stdlib_dlasrt( 'I', m, w, iinfo )
                 if( iinfo/=0 ) then
                    info = 3
                    return
                 end if
              else
                 do j = 1, m - 1
                    i = 0
                    tmp = w( j )
                    do jj = j + 1, m
                       if( w( jj )<tmp ) then
                          i = jj
                          tmp = w( jj )
                       end if
                    end do
                    if( i/=0 ) then
                       w( i ) = w( j )
                       w( j ) = tmp
                       if( wantz ) then
                          call stdlib_zswap( n, z( 1, i ), 1, z( 1, j ), 1 )
                          itmp = isuppz( 2*i-1 )
                          isuppz( 2*i-1 ) = isuppz( 2*j-1 )
                          isuppz( 2*j-1 ) = itmp
                          itmp = isuppz( 2*i )
                          isuppz( 2*i ) = isuppz( 2*j )
                          isuppz( 2*j ) = itmp
                       end if
                    end if
                 end do
              end if
           endif
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_zstemr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$stemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, nzc, &
     !! ZSTEMR: computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
     !! a well defined set of pairwise different real eigenvalues, the corresponding
     !! real eigenvectors are pairwise orthogonal.
     !! The spectrum may be computed either completely or partially by specifying
     !! either an interval (VL,VU] or a range of indices IL:IU for the desired
     !! eigenvalues.
     !! Depending on the number of desired eigenvalues, these are computed either
     !! by bisection or the dqds algorithm. Numerically orthogonal eigenvectors are
     !! computed by the use of various suitable L D L^T factorizations near clusters
     !! of close eigenvalues (referred to as RRRs, Relatively Robust
     !! Representations). An informal sketch of the algorithm follows.
     !! For each unreduced block (submatrix) of T,
     !! (a) Compute T - sigma I  = L D L^T, so that L and D
     !! define all the wanted eigenvalues to high relative accuracy.
     !! This means that small relative changes in the entries of D and L
     !! cause only small relative changes in the eigenvalues and
     !! eigenvectors. The standard (unfactored) representation of the
     !! tridiagonal matrix T does not have this property in general.
     !! (b) Compute the eigenvalues to suitable accuracy.
     !! If the eigenvectors are desired, the algorithm attains full
     !! accuracy of the computed eigenvalues only right before
     !! the corresponding vectors have to be computed, see steps c) and d).
     !! (c) For each cluster of close eigenvalues, select a new
     !! shift close to the cluster, find a new factorization, and refine
     !! the shifted eigenvalues to suitable accuracy.
     !! (d) For each eigenvalue with a large enough relative separation compute
     !! the corresponding eigenvector by forming a rank revealing twisted
     !! factorization. Go back to (c) for any clusters that remain.
     !! For more details, see:
     !! - Inderjit S. Dhillon and Beresford N. Parlett: "Multiple representations
     !! to compute orthogonal eigenvectors of symmetric tridiagonal matrices,"
     !! Linear Algebra and its Applications, 387(1), pp. 1-28, August 2004.
     !! - Inderjit Dhillon and Beresford Parlett: "Orthogonal Eigenvectors and
     !! Relative Gaps," SIAM Journal on Matrix Analysis and Applications, Vol. 25,
     !! 2004.  Also LAPACK Working Note 154.
     !! - Inderjit Dhillon: "A new O(n^2) algorithm for the symmetric
     !! tridiagonal eigenvalue/eigenvector problem",
     !! Computer Science Division Technical Report No. UCB/CSD-97-971,
     !! UC Berkeley, May 1997.
     !! Further Details
     !! 1.ZSTEMR works only on machines which follow IEEE-754
     !! floating-point standard in their handling of infinities and NaNs.
     !! This permits the use of efficient inner loops avoiding a check for
     !! zero divisors.
     !! 2. LAPACK routines can be used to reduce a complex Hermitean matrix to
     !! real symmetric tridiagonal form.
     !! (Any complex Hermitean tridiagonal matrix has real values on its diagonal
     !! and potentially complex numbers on its off-diagonals. By applying a
     !! similarity transform with an appropriate diagonal matrix
     !! diag(1,e^{i \phy_1}, ... , e^{i \phy_{n-1}}), the complex Hermitean
     !! matrix can be transformed into a real symmetric matrix and complex
     !! arithmetic can be entirely avoided.)
     !! While the eigenvectors of the real symmetric tridiagonal matrix are real,
     !! the eigenvectors of original complex Hermitean matrix have complex entries
     !! in general.
     !! Since LAPACK drivers overwrite the matrix data with the eigenvectors,
     !! ZSTEMR accepts complex workspace to facilitate interoperability
     !! with ZUNMTR or ZUPMTR.
               isuppz, tryrac, work, lwork,iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           logical(lk), intent(inout) :: tryrac
           integer(ilp), intent(in) :: il, iu, ldz, nzc, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(${ck}$), intent(in) :: vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(${ck}$), intent(inout) :: d(*), e(*)
           real(${ck}$), intent(out) :: w(*), work(*)
           complex(${ck}$), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: minrgp = 1.0e-3_${ck}$
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, lquery, valeig, wantz, zquery
           integer(ilp) :: i, ibegin, iend, ifirst, iil, iindbl, iindw, iindwk, iinfo, iinspl, &
           iiu, ilast, in, indd, inde2, inderr, indgp, indgrs, indwrk, itmp, itmp2, j, jblk, jj, &
                     liwmin, lwmin, nsplit, nzcmin, offset, wbegin, wend
           real(${ck}$) :: bignum, cs, eps, pivmin, r1, r2, rmax, rmin, rtol1, rtol2, safmin, scale, &
                     smlnum, sn, thresh, tmp, tnrm, wl, wu
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lquery = ( ( lwork==-1 ).or.( liwork==-1 ) )
           zquery = ( nzc==-1 )
           ! stdlib_${c2ri(ci)}$stemr needs work of size 6*n, iwork of size 3*n.
           ! in addition, stdlib_${c2ri(ci)}$larre needs work of size 6*n, iwork of size 5*n.
           ! furthermore, stdlib_${ci}$larrv needs work of size 12*n, iwork of size 7*n.
           if( wantz ) then
              lwmin = 18*n
              liwmin = 10*n
           else
              ! need less workspace if only the eigenvalues are wanted
              lwmin = 12*n
              liwmin = 8*n
           endif
           wl = zero
           wu = zero
           iil = 0
           iiu = 0
           nsplit = 0
           if( valeig ) then
              ! we do not reference vl, vu in the cases range = 'i','a'
              ! the interval (wl, wu] contains all the wanted eigenvalues.
              ! it is either given by the user or computed in stdlib_${c2ri(ci)}$larre.
              wl = vl
              wu = vu
           elseif( indeig ) then
              ! we do not reference il, iu in the cases range = 'v','a'
              iil = il
              iiu = iu
           endif
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( valeig .and. n>0 .and. wu<=wl ) then
              info = -7
           else if( indeig .and. ( iil<1 .or. iil>n ) ) then
              info = -8
           else if( indeig .and. ( iiu<iil .or. iiu>n ) ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -13
           else if( lwork<lwmin .and. .not.lquery ) then
              info = -17
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -19
           end if
           ! get machine constants.
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( wantz .and. alleig ) then
                 nzcmin = n
              else if( wantz .and. valeig ) then
                 call stdlib_${c2ri(ci)}$larrc( 'T', n, vl, vu, d, e, safmin,nzcmin, itmp, itmp2, info )
                           
              else if( wantz .and. indeig ) then
                 nzcmin = iiu-iil+1
              else
                 ! wantz == false.
                 nzcmin = 0
              endif
              if( zquery .and. info==0 ) then
                 z( 1,1 ) = nzcmin
              else if( nzc<nzcmin .and. .not.zquery ) then
                 info = -14
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSTEMR', -info )
              return
           else if( lquery .or. zquery ) then
              return
           end if
           ! handle n = 0, 1, and 2 cases immediately
           m = 0
           if( n==0 )return
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = d( 1 )
              else
                 if( wl<d( 1 ) .and. wu>=d( 1 ) ) then
                    m = 1
                    w( 1 ) = d( 1 )
                 end if
              end if
              if( wantz.and.(.not.zquery) ) then
                 z( 1, 1 ) = one
                 isuppz(1) = 1
                 isuppz(2) = 1
              end if
              return
           end if
           if( n==2 ) then
              if( .not.wantz ) then
                 call stdlib_${c2ri(ci)}$lae2( d(1), e(1), d(2), r1, r2 )
              else if( wantz.and.(.not.zquery) ) then
                 call stdlib_${c2ri(ci)}$laev2( d(1), e(1), d(2), r1, r2, cs, sn )
              end if
              if( alleig.or.(valeig.and.(r2>wl).and.(r2<=wu)).or.(indeig.and.(iil==1)) ) &
                        then
                 m = m+1
                 w( m ) = r2
                 if( wantz.and.(.not.zquery) ) then
                    z( 1, m ) = -sn
                    z( 2, m ) = cs
                    ! note: at most one of sn and cs can be zero.
                    if (sn/=zero) then
                       if (cs/=zero) then
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 2
                       else
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 1
                       end if
                    else
                       isuppz(2*m-1) = 2
                       isuppz(2*m) = 2
                    end if
                 endif
              endif
              if( alleig.or.(valeig.and.(r1>wl).and.(r1<=wu)).or.(indeig.and.(iiu==2)) ) &
                        then
                 m = m+1
                 w( m ) = r1
                 if( wantz.and.(.not.zquery) ) then
                    z( 1, m ) = cs
                    z( 2, m ) = sn
                    ! note: at most one of sn and cs can be zero.
                    if (sn/=zero) then
                       if (cs/=zero) then
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 2
                       else
                          isuppz(2*m-1) = 1
                          isuppz(2*m) = 1
                       end if
                    else
                       isuppz(2*m-1) = 2
                       isuppz(2*m) = 2
                    end if
                 endif
              endif
           else
              ! continue with general n
              indgrs = 1
              inderr = 2*n + 1
              indgp = 3*n + 1
              indd = 4*n + 1
              inde2 = 5*n + 1
              indwrk = 6*n + 1
              iinspl = 1
              iindbl = n + 1
              iindw = 2*n + 1
              iindwk = 3*n + 1
              ! scale matrix to allowable range, if necessary.
              ! the allowable range is related to the pivmin parameter; see the
              ! comments in stdlib_${c2ri(ci)}$larrd.  the preference for scaling small values
              ! up is heuristic; we expect users' matrices not to be close to the
              ! rmax threshold.
              scale = one
              tnrm = stdlib_${c2ri(ci)}$lanst( 'M', n, d, e )
              if( tnrm>zero .and. tnrm<rmin ) then
                 scale = rmin / tnrm
              else if( tnrm>rmax ) then
                 scale = rmax / tnrm
              end if
              if( scale/=one ) then
                 call stdlib_${c2ri(ci)}$scal( n, scale, d, 1 )
                 call stdlib_${c2ri(ci)}$scal( n-1, scale, e, 1 )
                 tnrm = tnrm*scale
                 if( valeig ) then
                    ! if eigenvalues in interval have to be found,
                    ! scale (wl, wu] accordingly
                    wl = wl*scale
                    wu = wu*scale
                 endif
              end if
              ! compute the desired eigenvalues of the tridiagonal after splitting
              ! into smaller subblocks if the corresponding off-diagonal elements
              ! are small
              ! thresh is the splitting parameter for stdlib_${c2ri(ci)}$larre
              ! a negative thresh forces the old splitting criterion based on the
              ! size of the off-diagonal. a positive thresh switches to splitting
              ! which preserves relative accuracy.
              if( tryrac ) then
                 ! test whether the matrix warrants the more expensive relative approach.
                 call stdlib_${c2ri(ci)}$larrr( n, d, e, iinfo )
              else
                 ! the user does not care about relative accurately eigenvalues
                 iinfo = -1
              endif
              ! set the splitting criterion
              if (iinfo==0) then
                 thresh = eps
              else
                 thresh = -eps
                 ! relative accuracy is desired but t does not guarantee it
                 tryrac = .false.
              endif
              if( tryrac ) then
                 ! copy original diagonal, needed to guarantee relative accuracy
                 call stdlib_${c2ri(ci)}$copy(n,d,1,work(indd),1)
              endif
              ! store the squares of the offdiagonal values of t
              do j = 1, n-1
                 work( inde2+j-1 ) = e(j)**2
              end do
              ! set the tolerance parameters for bisection
              if( .not.wantz ) then
                 ! stdlib_${c2ri(ci)}$larre computes the eigenvalues to full precision.
                 rtol1 = four * eps
                 rtol2 = four * eps
              else
                 ! stdlib_${c2ri(ci)}$larre computes the eigenvalues to less than full precision.
                 ! stdlib_${ci}$larrv will refine the eigenvalue approximations, and we only
                 ! need less accurate initial bisection in stdlib_${c2ri(ci)}$larre.
                 ! note: these settings do only affect the subset case and stdlib_${c2ri(ci)}$larre
                 rtol1 = sqrt(eps)
                 rtol2 = max( sqrt(eps)*5.0e-3_${ck}$, four * eps )
              endif
              call stdlib_${c2ri(ci)}$larre( range, n, wl, wu, iil, iiu, d, e,work(inde2), rtol1, rtol2, &
              thresh, nsplit,iwork( iinspl ), m, w, work( inderr ),work( indgp ), iwork( iindbl ),&
              iwork( iindw ), work( indgrs ), pivmin,work( indwrk ), iwork( iindwk ), iinfo )
                        
              if( iinfo/=0 ) then
                 info = 10 + abs( iinfo )
                 return
              end if
              ! note that if range /= 'v', stdlib_${c2ri(ci)}$larre computes bounds on the desired
              ! part of the spectrum. all desired eigenvalues are contained in
              ! (wl,wu]
              if( wantz ) then
                 ! compute the desired eigenvectors corresponding to the computed
                 ! eigenvalues
                 call stdlib_${ci}$larrv( n, wl, wu, d, e,pivmin, iwork( iinspl ), m,1, m, minrgp, &
                 rtol1, rtol2,w, work( inderr ), work( indgp ), iwork( iindbl ),iwork( iindw ), &
                           work( indgrs ), z, ldz,isuppz, work( indwrk ), iwork( iindwk ), iinfo )
                 if( iinfo/=0 ) then
                    info = 20 + abs( iinfo )
                    return
                 end if
              else
                 ! stdlib_${c2ri(ci)}$larre computes eigenvalues of the (shifted) root representation
                 ! stdlib_${ci}$larrv returns the eigenvalues of the unshifted matrix.
                 ! however, if the eigenvectors are not desired by the user, we need
                 ! to apply the corresponding shifts from stdlib_${c2ri(ci)}$larre to obtain the
                 ! eigenvalues of the original matrix.
                 do j = 1, m
                    itmp = iwork( iindbl+j-1 )
                    w( j ) = w( j ) + e( iwork( iinspl+itmp-1 ) )
                 end do
              end if
              if ( tryrac ) then
                 ! refine computed eigenvalues so that they are relatively accurate
                 ! with respect to the original matrix t.
                 ibegin = 1
                 wbegin = 1
                 loop_39: do jblk = 1, iwork( iindbl+m-1 )
                    iend = iwork( iinspl+jblk-1 )
                    in = iend - ibegin + 1
                    wend = wbegin - 1
                    ! check if any eigenvalues have to be refined in this block
                    36 continue
                    if( wend<m ) then
                       if( iwork( iindbl+wend )==jblk ) then
                          wend = wend + 1
                          go to 36
                       end if
                    end if
                    if( wend<wbegin ) then
                       ibegin = iend + 1
                       cycle loop_39
                    end if
                    offset = iwork(iindw+wbegin-1)-1
                    ifirst = iwork(iindw+wbegin-1)
                    ilast = iwork(iindw+wend-1)
                    rtol2 = four * eps
                    call stdlib_${c2ri(ci)}$larrj( in,work(indd+ibegin-1), work(inde2+ibegin-1),ifirst, &
                    ilast, rtol2, offset, w(wbegin),work( inderr+wbegin-1 ),work( indwrk ), iwork(&
                               iindwk ), pivmin,tnrm, iinfo )
                    ibegin = iend + 1
                    wbegin = wend + 1
                 end do loop_39
              endif
              ! if matrix was scaled, then rescale eigenvalues appropriately.
              if( scale/=one ) then
                 call stdlib_${c2ri(ci)}$scal( m, one / scale, w, 1 )
              end if
           end if
           ! if eigenvalues are not in increasing order, then sort them,
           ! possibly along with eigenvectors.
           if( nsplit>1 .or. n==2 ) then
              if( .not. wantz ) then
                 call stdlib_${c2ri(ci)}$lasrt( 'I', m, w, iinfo )
                 if( iinfo/=0 ) then
                    info = 3
                    return
                 end if
              else
                 do j = 1, m - 1
                    i = 0
                    tmp = w( j )
                    do jj = j + 1, m
                       if( w( jj )<tmp ) then
                          i = jj
                          tmp = w( jj )
                       end if
                    end do
                    if( i/=0 ) then
                       w( i ) = w( j )
                       w( j ) = tmp
                       if( wantz ) then
                          call stdlib_${ci}$swap( n, z( 1, i ), 1, z( 1, j ), 1 )
                          itmp = isuppz( 2*i-1 )
                          isuppz( 2*i-1 ) = isuppz( 2*j-1 )
                          isuppz( 2*j-1 ) = itmp
                          itmp = isuppz( 2*i )
                          isuppz( 2*i ) = isuppz( 2*j )
                          isuppz( 2*j ) = itmp
                       end if
                    end if
                 end do
              end if
           endif
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ci}$stemr

#:endif
#:endfor





     pure subroutine stdlib_cupgtr( uplo, n, ap, tau, q, ldq, work, info )
     !! CUPGTR generates a complex unitary matrix Q which is defined as the
     !! product of n-1 elementary reflectors H(i) of order n, as returned by
     !! CHPTRD using packed storage:
     !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldq, n
           ! Array Arguments 
           complex(sp), intent(in) :: ap(*), tau(*)
           complex(sp), intent(out) :: q(ldq,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, ij, j
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUPGTR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! q was determined by a call to stdlib_chptrd with uplo = 'u'
              ! unpack the vectors which define the elementary reflectors and
              ! set the last row and column of q equal to those of the unit
              ! matrix
              ij = 2
              do j = 1, n - 1
                 do i = 1, j - 1
                    q( i, j ) = ap( ij )
                    ij = ij + 1
                 end do
                 ij = ij + 2
                 q( n, j ) = czero
              end do
              do i = 1, n - 1
                 q( i, n ) = czero
              end do
              q( n, n ) = cone
              ! generate q(1:n-1,1:n-1)
              call stdlib_cung2l( n-1, n-1, n-1, q, ldq, tau, work, iinfo )
           else
              ! q was determined by a call to stdlib_chptrd with uplo = 'l'.
              ! unpack the vectors which define the elementary reflectors and
              ! set the first row and column of q equal to those of the unit
              ! matrix
              q( 1, 1 ) = cone
              do i = 2, n
                 q( i, 1 ) = czero
              end do
              ij = 3
              do j = 2, n
                 q( 1, j ) = czero
                 do i = j + 1, n
                    q( i, j ) = ap( ij )
                    ij = ij + 1
                 end do
                 ij = ij + 2
              end do
              if( n>1 ) then
                 ! generate q(2:n,2:n)
                 call stdlib_cung2r( n-1, n-1, n-1, q( 2, 2 ), ldq, tau, work,iinfo )
              end if
           end if
           return
     end subroutine stdlib_cupgtr

     pure subroutine stdlib_zupgtr( uplo, n, ap, tau, q, ldq, work, info )
     !! ZUPGTR generates a complex unitary matrix Q which is defined as the
     !! product of n-1 elementary reflectors H(i) of order n, as returned by
     !! ZHPTRD using packed storage:
     !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldq, n
           ! Array Arguments 
           complex(dp), intent(in) :: ap(*), tau(*)
           complex(dp), intent(out) :: q(ldq,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, ij, j
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZUPGTR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! q was determined by a call to stdlib_zhptrd with uplo = 'u'
              ! unpack the vectors which define the elementary reflectors and
              ! set the last row and column of q equal to those of the unit
              ! matrix
              ij = 2
              do j = 1, n - 1
                 do i = 1, j - 1
                    q( i, j ) = ap( ij )
                    ij = ij + 1
                 end do
                 ij = ij + 2
                 q( n, j ) = czero
              end do
              do i = 1, n - 1
                 q( i, n ) = czero
              end do
              q( n, n ) = cone
              ! generate q(1:n-1,1:n-1)
              call stdlib_zung2l( n-1, n-1, n-1, q, ldq, tau, work, iinfo )
           else
              ! q was determined by a call to stdlib_zhptrd with uplo = 'l'.
              ! unpack the vectors which define the elementary reflectors and
              ! set the first row and column of q equal to those of the unit
              ! matrix
              q( 1, 1 ) = cone
              do i = 2, n
                 q( i, 1 ) = czero
              end do
              ij = 3
              do j = 2, n
                 q( 1, j ) = czero
                 do i = j + 1, n
                    q( i, j ) = ap( ij )
                    ij = ij + 1
                 end do
                 ij = ij + 2
              end do
              if( n>1 ) then
                 ! generate q(2:n,2:n)
                 call stdlib_zung2r( n-1, n-1, n-1, q( 2, 2 ), ldq, tau, work,iinfo )
              end if
           end if
           return
     end subroutine stdlib_zupgtr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$upgtr( uplo, n, ap, tau, q, ldq, work, info )
     !! ZUPGTR: generates a complex unitary matrix Q which is defined as the
     !! product of n-1 elementary reflectors H(i) of order n, as returned by
     !! ZHPTRD using packed storage:
     !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldq, n
           ! Array Arguments 
           complex(${ck}$), intent(in) :: ap(*), tau(*)
           complex(${ck}$), intent(out) :: q(ldq,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, ij, j
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZUPGTR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! q was determined by a call to stdlib_${ci}$hptrd with uplo = 'u'
              ! unpack the vectors which define the elementary reflectors and
              ! set the last row and column of q equal to those of the unit
              ! matrix
              ij = 2
              do j = 1, n - 1
                 do i = 1, j - 1
                    q( i, j ) = ap( ij )
                    ij = ij + 1
                 end do
                 ij = ij + 2
                 q( n, j ) = czero
              end do
              do i = 1, n - 1
                 q( i, n ) = czero
              end do
              q( n, n ) = cone
              ! generate q(1:n-1,1:n-1)
              call stdlib_${ci}$ung2l( n-1, n-1, n-1, q, ldq, tau, work, iinfo )
           else
              ! q was determined by a call to stdlib_${ci}$hptrd with uplo = 'l'.
              ! unpack the vectors which define the elementary reflectors and
              ! set the first row and column of q equal to those of the unit
              ! matrix
              q( 1, 1 ) = cone
              do i = 2, n
                 q( i, 1 ) = czero
              end do
              ij = 3
              do j = 2, n
                 q( 1, j ) = czero
                 do i = j + 1, n
                    q( i, j ) = ap( ij )
                    ij = ij + 1
                 end do
                 ij = ij + 2
              end do
              if( n>1 ) then
                 ! generate q(2:n,2:n)
                 call stdlib_${ci}$ung2r( n-1, n-1, n-1, q( 2, 2 ), ldq, tau, work,iinfo )
              end if
           end if
           return
     end subroutine stdlib_${ci}$upgtr

#:endif
#:endfor









     pure subroutine stdlib_ssbgvx( jobz, range, uplo, n, ka, kb, ab, ldab, bb,ldbb, q, ldq, vl, &
     !! SSBGVX computes selected eigenvalues, and optionally, eigenvectors
     !! of a real generalized symmetric-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric
     !! and banded, and B is also positive definite.  Eigenvalues and
     !! eigenvectors can be selected by specifying either all eigenvalues,
     !! a range of values or a range of indices for the desired eigenvalues.
               vu, il, iu, abstol, m, w, z,ldz, work, iwork, ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, iu, ka, kb, ldab, ldbb, ldq, ldz, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(sp), intent(out) :: q(ldq,*), w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, test, upper, valeig, wantz
           character :: order, vect
           integer(ilp) :: i, iinfo, indd, inde, indee, indibl, indisp, indiwo, indwrk, itmp1, j, &
                     jj, nsplit
           real(sp) :: tmp1
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ka<0 ) then
              info = -5
           else if( kb<0 .or. kb>ka ) then
              info = -6
           else if( ldab<ka+1 ) then
              info = -8
           else if( ldbb<kb+1 ) then
              info = -10
           else if( ldq<1 .or. ( wantz .and. ldq<n ) ) then
              info = -12
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -14
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -15
                 else if ( iu<min( n, il ) .or. iu>n ) then
                    info = -16
                 end if
              end if
           end if
           if( info==0) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
                 info = -21
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSBGVX', -info )
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_spbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           call stdlib_ssbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq,work, iinfo )
                     
           ! reduce symmetric band matrix to tridiagonal form.
           indd = 1
           inde = indd + n
           indwrk = inde + n
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_ssbtrd( vect, uplo, n, ka, ab, ldab, work( indd ),work( inde ), q, ldq, &
                     work( indwrk ), iinfo )
           ! if all eigenvalues are desired and abstol is less than or equal
           ! to zero, then call stdlib_ssterf or stdlib_ssteqr.  if this fails for some
           ! eigenvalue, then try stdlib_sstebz.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig .or. test ) .and. ( abstol<=zero ) ) then
              call stdlib_scopy( n, work( indd ), 1, w, 1 )
              indee = indwrk + 2*n
              call stdlib_scopy( n-1, work( inde ), 1, work( indee ), 1 )
              if( .not.wantz ) then
                 call stdlib_ssterf( n, w, work( indee ), info )
              else
                 call stdlib_slacpy( 'A', n, n, q, ldq, z, ldz )
                 call stdlib_ssteqr( jobz, n, w, work( indee ), z, ldz,work( indwrk ), info )
                           
                 if( info==0 ) then
                    do i = 1, n
                       ifail( i ) = 0
                    end do
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 30
              end if
              info = 0
           end if
           ! otherwise, call stdlib_sstebz and, if eigenvectors are desired,
           ! call stdlib_sstein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           indibl = 1
           indisp = indibl + n
           indiwo = indisp + n
           call stdlib_sstebz( range, order, n, vl, vu, il, iu, abstol,work( indd ), work( inde ),&
            m, nsplit, w,iwork( indibl ), iwork( indisp ), work( indwrk ),iwork( indiwo ), info )
                      
           if( wantz ) then
              call stdlib_sstein( n, work( indd ), work( inde ), m, w,iwork( indibl ), iwork( &
                        indisp ), z, ldz,work( indwrk ), iwork( indiwo ), ifail, info )
              ! apply transformation matrix used in reduction to tridiagonal
              ! form to eigenvectors returned by stdlib_sstein.
              do j = 1, m
                 call stdlib_scopy( n, z( 1, j ), 1, work( 1 ), 1 )
                 call stdlib_sgemv( 'N', n, n, one, q, ldq, work, 1, zero,z( 1, j ), 1 )
              end do
           end if
           30 continue
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_sswap( n, z( 1, i ), 1, z( 1, j ), 1 )
                    if( info/=0 ) then
                       itmp1 = ifail( i )
                       ifail( i ) = ifail( j )
                       ifail( j ) = itmp1
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_ssbgvx

     pure subroutine stdlib_dsbgvx( jobz, range, uplo, n, ka, kb, ab, ldab, bb,ldbb, q, ldq, vl, &
     !! DSBGVX computes selected eigenvalues, and optionally, eigenvectors
     !! of a real generalized symmetric-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric
     !! and banded, and B is also positive definite.  Eigenvalues and
     !! eigenvectors can be selected by specifying either all eigenvalues,
     !! a range of values or a range of indices for the desired eigenvalues.
               vu, il, iu, abstol, m, w, z,ldz, work, iwork, ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, iu, ka, kb, ldab, ldbb, ldq, ldz, n
           integer(ilp), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(dp), intent(out) :: q(ldq,*), w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, test, upper, valeig, wantz
           character :: order, vect
           integer(ilp) :: i, iinfo, indd, inde, indee, indibl, indisp, indiwo, indwrk, itmp1, j, &
                     jj, nsplit
           real(dp) :: tmp1
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ka<0 ) then
              info = -5
           else if( kb<0 .or. kb>ka ) then
              info = -6
           else if( ldab<ka+1 ) then
              info = -8
           else if( ldbb<kb+1 ) then
              info = -10
           else if( ldq<1 .or. ( wantz .and. ldq<n ) ) then
              info = -12
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -14
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -15
                 else if ( iu<min( n, il ) .or. iu>n ) then
                    info = -16
                 end if
              end if
           end if
           if( info==0) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
                 info = -21
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSBGVX', -info )
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_dpbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           call stdlib_dsbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq,work, iinfo )
                     
           ! reduce symmetric band matrix to tridiagonal form.
           indd = 1
           inde = indd + n
           indwrk = inde + n
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_dsbtrd( vect, uplo, n, ka, ab, ldab, work( indd ),work( inde ), q, ldq, &
                     work( indwrk ), iinfo )
           ! if all eigenvalues are desired and abstol is less than or equal
           ! to zero, then call stdlib_dsterf or stdlib_ssteqr.  if this fails for some
           ! eigenvalue, then try stdlib_dstebz.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig .or. test ) .and. ( abstol<=zero ) ) then
              call stdlib_dcopy( n, work( indd ), 1, w, 1 )
              indee = indwrk + 2*n
              call stdlib_dcopy( n-1, work( inde ), 1, work( indee ), 1 )
              if( .not.wantz ) then
                 call stdlib_dsterf( n, w, work( indee ), info )
              else
                 call stdlib_dlacpy( 'A', n, n, q, ldq, z, ldz )
                 call stdlib_dsteqr( jobz, n, w, work( indee ), z, ldz,work( indwrk ), info )
                           
                 if( info==0 ) then
                    do i = 1, n
                       ifail( i ) = 0
                    end do
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 30
              end if
              info = 0
           end if
           ! otherwise, call stdlib_dstebz and, if eigenvectors are desired,
           ! call stdlib_dstein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           indibl = 1
           indisp = indibl + n
           indiwo = indisp + n
           call stdlib_dstebz( range, order, n, vl, vu, il, iu, abstol,work( indd ), work( inde ),&
            m, nsplit, w,iwork( indibl ), iwork( indisp ), work( indwrk ),iwork( indiwo ), info )
                      
           if( wantz ) then
              call stdlib_dstein( n, work( indd ), work( inde ), m, w,iwork( indibl ), iwork( &
                        indisp ), z, ldz,work( indwrk ), iwork( indiwo ), ifail, info )
              ! apply transformation matrix used in reduction to tridiagonal
              ! form to eigenvectors returned by stdlib_dstein.
              do j = 1, m
                 call stdlib_dcopy( n, z( 1, j ), 1, work( 1 ), 1 )
                 call stdlib_dgemv( 'N', n, n, one, q, ldq, work, 1, zero,z( 1, j ), 1 )
              end do
           end if
           30 continue
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_dswap( n, z( 1, i ), 1, z( 1, j ), 1 )
                    if( info/=0 ) then
                       itmp1 = ifail( i )
                       ifail( i ) = ifail( j )
                       ifail( j ) = itmp1
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_dsbgvx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$sbgvx( jobz, range, uplo, n, ka, kb, ab, ldab, bb,ldbb, q, ldq, vl, &
     !! DSBGVX: computes selected eigenvalues, and optionally, eigenvectors
     !! of a real generalized symmetric-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x.  Here A and B are assumed to be symmetric
     !! and banded, and B is also positive definite.  Eigenvalues and
     !! eigenvectors can be selected by specifying either all eigenvalues,
     !! a range of values or a range of indices for the desired eigenvalues.
               vu, il, iu, abstol, m, w, z,ldz, work, iwork, ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, iu, ka, kb, ldab, ldbb, ldq, ldz, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(${rk}$), intent(out) :: q(ldq,*), w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, test, upper, valeig, wantz
           character :: order, vect
           integer(ilp) :: i, iinfo, indd, inde, indee, indibl, indisp, indiwo, indwrk, itmp1, j, &
                     jj, nsplit
           real(${rk}$) :: tmp1
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ka<0 ) then
              info = -5
           else if( kb<0 .or. kb>ka ) then
              info = -6
           else if( ldab<ka+1 ) then
              info = -8
           else if( ldbb<kb+1 ) then
              info = -10
           else if( ldq<1 .or. ( wantz .and. ldq<n ) ) then
              info = -12
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -14
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -15
                 else if ( iu<min( n, il ) .or. iu>n ) then
                    info = -16
                 end if
              end if
           end if
           if( info==0) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
                 info = -21
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSBGVX', -info )
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_${ri}$pbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           call stdlib_${ri}$sbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq,work, iinfo )
                     
           ! reduce symmetric band matrix to tridiagonal form.
           indd = 1
           inde = indd + n
           indwrk = inde + n
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_${ri}$sbtrd( vect, uplo, n, ka, ab, ldab, work( indd ),work( inde ), q, ldq, &
                     work( indwrk ), iinfo )
           ! if all eigenvalues are desired and abstol is less than or equal
           ! to zero, then call stdlib_${ri}$sterf or stdlib_dsteqr.  if this fails for some
           ! eigenvalue, then try stdlib_${ri}$stebz.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig .or. test ) .and. ( abstol<=zero ) ) then
              call stdlib_${ri}$copy( n, work( indd ), 1, w, 1 )
              indee = indwrk + 2*n
              call stdlib_${ri}$copy( n-1, work( inde ), 1, work( indee ), 1 )
              if( .not.wantz ) then
                 call stdlib_${ri}$sterf( n, w, work( indee ), info )
              else
                 call stdlib_${ri}$lacpy( 'A', n, n, q, ldq, z, ldz )
                 call stdlib_${ri}$steqr( jobz, n, w, work( indee ), z, ldz,work( indwrk ), info )
                           
                 if( info==0 ) then
                    do i = 1, n
                       ifail( i ) = 0
                    end do
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 30
              end if
              info = 0
           end if
           ! otherwise, call stdlib_${ri}$stebz and, if eigenvectors are desired,
           ! call stdlib_${ri}$stein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           indibl = 1
           indisp = indibl + n
           indiwo = indisp + n
           call stdlib_${ri}$stebz( range, order, n, vl, vu, il, iu, abstol,work( indd ), work( inde ),&
            m, nsplit, w,iwork( indibl ), iwork( indisp ), work( indwrk ),iwork( indiwo ), info )
                      
           if( wantz ) then
              call stdlib_${ri}$stein( n, work( indd ), work( inde ), m, w,iwork( indibl ), iwork( &
                        indisp ), z, ldz,work( indwrk ), iwork( indiwo ), ifail, info )
              ! apply transformation matrix used in reduction to tridiagonal
              ! form to eigenvectors returned by stdlib_${ri}$stein.
              do j = 1, m
                 call stdlib_${ri}$copy( n, z( 1, j ), 1, work( 1 ), 1 )
                 call stdlib_${ri}$gemv( 'N', n, n, one, q, ldq, work, 1, zero,z( 1, j ), 1 )
              end do
           end if
           30 continue
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_${ri}$swap( n, z( 1, i ), 1, z( 1, j ), 1 )
                    if( info/=0 ) then
                       itmp1 = ifail( i )
                       ifail( i ) = ifail( j )
                       ifail( j ) = itmp1
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_${ri}$sbgvx

#:endif
#:endfor



     pure subroutine stdlib_sstevr( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
     !! SSTEVR computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T.  Eigenvalues and
     !! eigenvectors can be selected by specifying either a range of values
     !! or a range of indices for the desired eigenvalues.
     !! Whenever possible, SSTEVR calls SSTEMR to compute the
     !! eigenspectrum using Relatively Robust Representations.  SSTEMR
     !! computes eigenvalues by the dqds algorithm, while orthogonal
     !! eigenvectors are computed from various "good" L D L^T representations
     !! (also known as Relatively Robust Representations). Gram-Schmidt
     !! orthogonalization is avoided as far as possible. More specifically,
     !! the various steps of the algorithm are as follows. For the i-th
     !! unreduced block of T,
     !! (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
     !! is a relatively robust representation,
     !! (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
     !! relative accuracy by the dqds algorithm,
     !! (c) If there is a cluster of close eigenvalues, "choose" sigma_i
     !! close to the cluster, and go to step (a),
     !! (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
     !! compute the corresponding eigenvector by forming a
     !! rank-revealing twisted factorization.
     !! The desired accuracy of the output can be specified by the input
     !! parameter ABSTOL.
     !! For more details, see "A new O(n^2) algorithm for the symmetric
     !! tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
     !! Computer Science Division Technical Report No. UCB//CSD-97-971,
     !! UC Berkeley, May 1997.
     !! Note 1 : SSTEVR calls SSTEMR when the full spectrum is requested
     !! on machines which conform to the ieee-754 floating point standard.
     !! SSTEVR calls SSTEBZ and SSTEIN on non-ieee machines and
     !! when partial spectrum requests are made.
     !! Normal execution of SSTEMR may create NaNs and infinities and
     !! hence may abort due to a floating point exception in environments
     !! which do not handle NaNs and infinities in the ieee standard default
     !! manner.
               isuppz, work, lwork, iwork,liwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           integer(ilp), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, test, lquery, valeig, wantz, tryrac
           character :: order
           integer(ilp) :: i, ieeeok, imax, indibl, indifl, indisp, indiwo, iscale, j, jj, liwmin,&
                      lwmin, nsplit
           real(sp) :: bignum, eps, rmax, rmin, safmin, sigma, smlnum, tmp1, tnrm, vll, &
                     vuu
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           ieeeok = stdlib_ilaenv( 10, 'SSTEVR', 'N', 1, 2, 3, 4 )
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lquery = ( ( lwork==-1 ) .or. ( liwork==-1 ) )
           lwmin = max( 1, 20*n )
           liwmin = max(1, 10*n )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -7
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -8
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -9
                 end if
              end if
           end if
           if( info==0 ) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
                 info = -14
              end if
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -17
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -19
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSTEVR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = d( 1 )
              else
                 if( vl<d( 1 ) .and. vu>=d( 1 ) ) then
                    m = 1
                    w( 1 ) = d( 1 )
                 end if
              end if
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           eps = stdlib_slamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           if( valeig ) then
              vll = vl
              vuu = vu
           end if
           tnrm = stdlib_slanst( 'M', n, d, e )
           if( tnrm>zero .and. tnrm<rmin ) then
              iscale = 1
              sigma = rmin / tnrm
           else if( tnrm>rmax ) then
              iscale = 1
              sigma = rmax / tnrm
           end if
           if( iscale==1 ) then
              call stdlib_sscal( n, sigma, d, 1 )
              call stdlib_sscal( n-1, sigma, e( 1 ), 1 )
              if( valeig ) then
                 vll = vl*sigma
                 vuu = vu*sigma
              end if
           end if
           ! initialize indices into workspaces.  note: these indices are used only
           ! if stdlib_ssterf or stdlib_sstemr fail.
           ! iwork(indibl:indibl+m-1) corresponds to iblock in stdlib_sstebz and
           ! stores the block indices of each of the m<=n eigenvalues.
           indibl = 1
           ! iwork(indisp:indisp+nsplit-1) corresponds to isplit in stdlib_sstebz and
           ! stores the starting and finishing indices of each block.
           indisp = indibl + n
           ! iwork(indifl:indifl+n-1) stores the indices of eigenvectors
           ! that corresponding to eigenvectors that fail to converge in
           ! stdlib_sstein.  this information is discarded; if any fail, the driver
           ! returns info > 0.
           indifl = indisp + n
           ! indiwo is the offset of the remaining integer workspace.
           indiwo = indisp + n
           ! if all eigenvalues are desired, then
           ! call stdlib_ssterf or stdlib_sstemr.  if this fails for some eigenvalue, then
           ! try stdlib_sstebz.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig .or. test ) .and. ieeeok==1 ) then
              call stdlib_scopy( n-1, e( 1 ), 1, work( 1 ), 1 )
              if( .not.wantz ) then
                 call stdlib_scopy( n, d, 1, w, 1 )
                 call stdlib_ssterf( n, w, work, info )
              else
                 call stdlib_scopy( n, d, 1, work( n+1 ), 1 )
                 if (abstol <= two*n*eps) then
                    tryrac = .true.
                 else
                    tryrac = .false.
                 end if
                 call stdlib_sstemr( jobz, 'A', n, work( n+1 ), work, vl, vu, il,iu, m, w, z, ldz,&
                            n, isuppz, tryrac,work( 2*n+1 ), lwork-2*n, iwork, liwork, info )
              end if
              if( info==0 ) then
                 m = n
                 go to 10
              end if
              info = 0
           end if
           ! otherwise, call stdlib_sstebz and, if eigenvectors are desired, stdlib_sstein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           call stdlib_sstebz( range, order, n, vll, vuu, il, iu, abstol, d, e, m,nsplit, w, &
                     iwork( indibl ), iwork( indisp ), work,iwork( indiwo ), info )
           if( wantz ) then
              call stdlib_sstein( n, d, e, m, w, iwork( indibl ), iwork( indisp ),z, ldz, work, &
                        iwork( indiwo ), iwork( indifl ),info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           10 continue
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = m
              else
                 imax = info - 1
              end if
              call stdlib_sscal( imax, one / sigma, w, 1 )
           end if
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    w( i ) = w( j )
                    w( j ) = tmp1
                    call stdlib_sswap( n, z( 1, i ), 1, z( 1, j ), 1 )
                 end if
              end do
           end if
            ! causes problems with tests 19
            ! if (wantz .and. indeig ) z( 1,1) = z(1,1) / 1.002_sp + .002
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_sstevr

     pure subroutine stdlib_dstevr( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
     !! DSTEVR computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T.  Eigenvalues and
     !! eigenvectors can be selected by specifying either a range of values
     !! or a range of indices for the desired eigenvalues.
     !! Whenever possible, DSTEVR calls DSTEMR to compute the
     !! eigenspectrum using Relatively Robust Representations.  DSTEMR
     !! computes eigenvalues by the dqds algorithm, while orthogonal
     !! eigenvectors are computed from various "good" L D L^T representations
     !! (also known as Relatively Robust Representations). Gram-Schmidt
     !! orthogonalization is avoided as far as possible. More specifically,
     !! the various steps of the algorithm are as follows. For the i-th
     !! unreduced block of T,
     !! (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
     !! is a relatively robust representation,
     !! (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
     !! relative accuracy by the dqds algorithm,
     !! (c) If there is a cluster of close eigenvalues, "choose" sigma_i
     !! close to the cluster, and go to step (a),
     !! (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
     !! compute the corresponding eigenvector by forming a
     !! rank-revealing twisted factorization.
     !! The desired accuracy of the output can be specified by the input
     !! parameter ABSTOL.
     !! For more details, see "A new O(n^2) algorithm for the symmetric
     !! tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
     !! Computer Science Division Technical Report No. UCB//CSD-97-971,
     !! UC Berkeley, May 1997.
     !! Note 1 : DSTEVR calls DSTEMR when the full spectrum is requested
     !! on machines which conform to the ieee-754 floating point standard.
     !! DSTEVR calls DSTEBZ and DSTEIN on non-ieee machines and
     !! when partial spectrum requests are made.
     !! Normal execution of DSTEMR may create NaNs and infinities and
     !! hence may abort due to a floating point exception in environments
     !! which do not handle NaNs and infinities in the ieee standard default
     !! manner.
               isuppz, work, lwork, iwork,liwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           integer(ilp), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, test, lquery, valeig, wantz, tryrac
           character :: order
           integer(ilp) :: i, ieeeok, imax, indibl, indifl, indisp, indiwo, iscale, itmp1, j, jj, &
                     liwmin, lwmin, nsplit
           real(dp) :: bignum, eps, rmax, rmin, safmin, sigma, smlnum, tmp1, tnrm, vll, &
                     vuu
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           ieeeok = stdlib_ilaenv( 10, 'DSTEVR', 'N', 1, 2, 3, 4 )
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lquery = ( ( lwork==-1 ) .or. ( liwork==-1 ) )
           lwmin = max( 1, 20*n )
           liwmin = max( 1, 10*n )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -7
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -8
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -9
                 end if
              end if
           end if
           if( info==0 ) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
                 info = -14
              end if
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -17
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -19
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEVR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = d( 1 )
              else
                 if( vl<d( 1 ) .and. vu>=d( 1 ) ) then
                    m = 1
                    w( 1 ) = d( 1 )
                 end if
              end if
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           eps = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           if( valeig ) then
              vll = vl
              vuu = vu
           end if
           tnrm = stdlib_dlanst( 'M', n, d, e )
           if( tnrm>zero .and. tnrm<rmin ) then
              iscale = 1
              sigma = rmin / tnrm
           else if( tnrm>rmax ) then
              iscale = 1
              sigma = rmax / tnrm
           end if
           if( iscale==1 ) then
              call stdlib_dscal( n, sigma, d, 1 )
              call stdlib_dscal( n-1, sigma, e( 1 ), 1 )
              if( valeig ) then
                 vll = vl*sigma
                 vuu = vu*sigma
              end if
           end if
           ! initialize indices into workspaces.  note: these indices are used only
           ! if stdlib_dsterf or stdlib_dstemr fail.
           ! iwork(indibl:indibl+m-1) corresponds to iblock in stdlib_dstebz and
           ! stores the block indices of each of the m<=n eigenvalues.
           indibl = 1
           ! iwork(indisp:indisp+nsplit-1) corresponds to isplit in stdlib_dstebz and
           ! stores the starting and finishing indices of each block.
           indisp = indibl + n
           ! iwork(indifl:indifl+n-1) stores the indices of eigenvectors
           ! that corresponding to eigenvectors that fail to converge in
           ! stdlib_dstein.  this information is discarded; if any fail, the driver
           ! returns info > 0.
           indifl = indisp + n
           ! indiwo is the offset of the remaining integer workspace.
           indiwo = indisp + n
           ! if all eigenvalues are desired, then
           ! call stdlib_dsterf or stdlib_dstemr.  if this fails for some eigenvalue, then
           ! try stdlib_dstebz.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig .or. test ) .and. ieeeok==1 ) then
              call stdlib_dcopy( n-1, e( 1 ), 1, work( 1 ), 1 )
              if( .not.wantz ) then
                 call stdlib_dcopy( n, d, 1, w, 1 )
                 call stdlib_dsterf( n, w, work, info )
              else
                 call stdlib_dcopy( n, d, 1, work( n+1 ), 1 )
                 if (abstol <= two*n*eps) then
                    tryrac = .true.
                 else
                    tryrac = .false.
                 end if
                 call stdlib_dstemr( jobz, 'A', n, work( n+1 ), work, vl, vu, il,iu, m, w, z, ldz,&
                            n, isuppz, tryrac,work( 2*n+1 ), lwork-2*n, iwork, liwork, info )
              end if
              if( info==0 ) then
                 m = n
                 go to 10
              end if
              info = 0
           end if
           ! otherwise, call stdlib_dstebz and, if eigenvectors are desired, stdlib_dstein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           call stdlib_dstebz( range, order, n, vll, vuu, il, iu, abstol, d, e, m,nsplit, w, &
                     iwork( indibl ), iwork( indisp ), work,iwork( indiwo ), info )
           if( wantz ) then
              call stdlib_dstein( n, d, e, m, w, iwork( indibl ), iwork( indisp ),z, ldz, work, &
                        iwork( indiwo ), iwork( indifl ),info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           10 continue
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = m
              else
                 imax = info - 1
              end if
              call stdlib_dscal( imax, one / sigma, w, 1 )
           end if
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( i )
                    w( i ) = w( j )
                    iwork( i ) = iwork( j )
                    w( j ) = tmp1
                    iwork( j ) = itmp1
                    call stdlib_dswap( n, z( 1, i ), 1, z( 1, j ), 1 )
                 end if
              end do
           end if
            ! causes problems with tests 19
            ! if (wantz .and. indeig ) z( 1,1) = z(1,1) / 1.002_dp + .002
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_dstevr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$stevr( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
     !! DSTEVR: computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T.  Eigenvalues and
     !! eigenvectors can be selected by specifying either a range of values
     !! or a range of indices for the desired eigenvalues.
     !! Whenever possible, DSTEVR calls DSTEMR to compute the
     !! eigenspectrum using Relatively Robust Representations.  DSTEMR
     !! computes eigenvalues by the dqds algorithm, while orthogonal
     !! eigenvectors are computed from various "good" L D L^T representations
     !! (also known as Relatively Robust Representations). Gram-Schmidt
     !! orthogonalization is avoided as far as possible. More specifically,
     !! the various steps of the algorithm are as follows. For the i-th
     !! unreduced block of T,
     !! (a) Compute T - sigma_i = L_i D_i L_i^T, such that L_i D_i L_i^T
     !! is a relatively robust representation,
     !! (b) Compute the eigenvalues, lambda_j, of L_i D_i L_i^T to high
     !! relative accuracy by the dqds algorithm,
     !! (c) If there is a cluster of close eigenvalues, "choose" sigma_i
     !! close to the cluster, and go to step (a),
     !! (d) Given the approximate eigenvalue lambda_j of L_i D_i L_i^T,
     !! compute the corresponding eigenvector by forming a
     !! rank-revealing twisted factorization.
     !! The desired accuracy of the output can be specified by the input
     !! parameter ABSTOL.
     !! For more details, see "A new O(n^2) algorithm for the symmetric
     !! tridiagonal eigenvalue/eigenvector problem", by Inderjit Dhillon,
     !! Computer Science Division Technical Report No. UCB//CSD-97-971,
     !! UC Berkeley, May 1997.
     !! Note 1 : DSTEVR calls DSTEMR when the full spectrum is requested
     !! on machines which conform to the ieee-754 floating point standard.
     !! DSTEVR calls DSTEBZ and DSTEIN on non-ieee machines and
     !! when partial spectrum requests are made.
     !! Normal execution of DSTEMR may create NaNs and infinities and
     !! hence may abort due to a floating point exception in environments
     !! which do not handle NaNs and infinities in the ieee standard default
     !! manner.
               isuppz, work, lwork, iwork,liwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           integer(ilp), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, test, lquery, valeig, wantz, tryrac
           character :: order
           integer(ilp) :: i, ieeeok, imax, indibl, indifl, indisp, indiwo, iscale, itmp1, j, jj, &
                     liwmin, lwmin, nsplit
           real(${rk}$) :: bignum, eps, rmax, rmin, safmin, sigma, smlnum, tmp1, tnrm, vll, &
                     vuu
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           ieeeok = stdlib_ilaenv( 10, 'DSTEVR', 'N', 1, 2, 3, 4 )
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           lquery = ( ( lwork==-1 ) .or. ( liwork==-1 ) )
           lwmin = max( 1, 20*n )
           liwmin = max( 1, 10*n )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -7
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -8
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -9
                 end if
              end if
           end if
           if( info==0 ) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
                 info = -14
              end if
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -17
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -19
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEVR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = d( 1 )
              else
                 if( vl<d( 1 ) .and. vu>=d( 1 ) ) then
                    m = 1
                    w( 1 ) = d( 1 )
                 end if
              end if
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           if( valeig ) then
              vll = vl
              vuu = vu
           end if
           tnrm = stdlib_${ri}$lanst( 'M', n, d, e )
           if( tnrm>zero .and. tnrm<rmin ) then
              iscale = 1
              sigma = rmin / tnrm
           else if( tnrm>rmax ) then
              iscale = 1
              sigma = rmax / tnrm
           end if
           if( iscale==1 ) then
              call stdlib_${ri}$scal( n, sigma, d, 1 )
              call stdlib_${ri}$scal( n-1, sigma, e( 1 ), 1 )
              if( valeig ) then
                 vll = vl*sigma
                 vuu = vu*sigma
              end if
           end if
           ! initialize indices into workspaces.  note: these indices are used only
           ! if stdlib_${ri}$sterf or stdlib_${ri}$stemr fail.
           ! iwork(indibl:indibl+m-1) corresponds to iblock in stdlib_${ri}$stebz and
           ! stores the block indices of each of the m<=n eigenvalues.
           indibl = 1
           ! iwork(indisp:indisp+nsplit-1) corresponds to isplit in stdlib_${ri}$stebz and
           ! stores the starting and finishing indices of each block.
           indisp = indibl + n
           ! iwork(indifl:indifl+n-1) stores the indices of eigenvectors
           ! that corresponding to eigenvectors that fail to converge in
           ! stdlib_${ri}$stein.  this information is discarded; if any fail, the driver
           ! returns info > 0.
           indifl = indisp + n
           ! indiwo is the offset of the remaining integer workspace.
           indiwo = indisp + n
           ! if all eigenvalues are desired, then
           ! call stdlib_${ri}$sterf or stdlib_${ri}$stemr.  if this fails for some eigenvalue, then
           ! try stdlib_${ri}$stebz.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig .or. test ) .and. ieeeok==1 ) then
              call stdlib_${ri}$copy( n-1, e( 1 ), 1, work( 1 ), 1 )
              if( .not.wantz ) then
                 call stdlib_${ri}$copy( n, d, 1, w, 1 )
                 call stdlib_${ri}$sterf( n, w, work, info )
              else
                 call stdlib_${ri}$copy( n, d, 1, work( n+1 ), 1 )
                 if (abstol <= two*n*eps) then
                    tryrac = .true.
                 else
                    tryrac = .false.
                 end if
                 call stdlib_${ri}$stemr( jobz, 'A', n, work( n+1 ), work, vl, vu, il,iu, m, w, z, ldz,&
                            n, isuppz, tryrac,work( 2*n+1 ), lwork-2*n, iwork, liwork, info )
              end if
              if( info==0 ) then
                 m = n
                 go to 10
              end if
              info = 0
           end if
           ! otherwise, call stdlib_${ri}$stebz and, if eigenvectors are desired, stdlib_${ri}$stein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           call stdlib_${ri}$stebz( range, order, n, vll, vuu, il, iu, abstol, d, e, m,nsplit, w, &
                     iwork( indibl ), iwork( indisp ), work,iwork( indiwo ), info )
           if( wantz ) then
              call stdlib_${ri}$stein( n, d, e, m, w, iwork( indibl ), iwork( indisp ),z, ldz, work, &
                        iwork( indiwo ), iwork( indifl ),info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           10 continue
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = m
              else
                 imax = info - 1
              end if
              call stdlib_${ri}$scal( imax, one / sigma, w, 1 )
           end if
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( i )
                    w( i ) = w( j )
                    iwork( i ) = iwork( j )
                    w( j ) = tmp1
                    iwork( j ) = itmp1
                    call stdlib_${ri}$swap( n, z( 1, i ), 1, z( 1, j ), 1 )
                 end if
              end do
           end if
            ! causes problems with tests 19
            ! if (wantz .and. indeig ) z( 1,1) = z(1,1) / 1.002_${rk}$ + .002
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$stevr

#:endif
#:endfor





     pure subroutine stdlib_slarrb( n, d, lld, ifirst, ilast, rtol1,rtol2, offset, w, wgap, werr, &
     !! Given the relatively robust representation(RRR) L D L^T, SLARRB:
     !! does "limited" bisection to refine the eigenvalues of L D L^T,
     !! W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial
     !! guesses for these eigenvalues are input in W, the corresponding estimate
     !! of the error in these guesses and their gaps are input in WERR
     !! and WGAP, respectively. During bisection, intervals
     !! [left, right] are maintained by storing their mid-points and
     !! semi-widths in the arrays W and WERR respectively.
               work, iwork,pivmin, spdiam, twist, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ifirst, ilast, n, offset, twist
           integer(ilp), intent(out) :: info
           real(sp), intent(in) :: pivmin, rtol1, rtol2, spdiam
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(in) :: d(*), lld(*)
           real(sp), intent(inout) :: w(*), werr(*), wgap(*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           integer(ilp) :: maxitr
           ! Local Scalars 
           integer(ilp) :: i, i1, ii, ip, iter, k, negcnt, next, nint, olnint, prev, r
           real(sp) :: back, cvrgd, gap, left, lgap, mid, mnwdth, rgap, right, tmp, width
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           maxitr = int( ( log( spdiam+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
           mnwdth = two * pivmin
           r = twist
           if((r<1).or.(r>n)) r = n
           ! initialize unconverged intervals in [ work(2*i-1), work(2*i) ].
           ! the sturm count, count( work(2*i-1) ) is arranged to be i-1, while
           ! count( work(2*i) ) is stored in iwork( 2*i ). the integer iwork( 2*i-1 )
           ! for an unconverged interval is set to the index of the next unconverged
           ! interval, and is -1 or 0 for a converged interval. thus a linked
           ! list of unconverged intervals is set up.
           i1 = ifirst
           ! the number of unconverged intervals
           nint = 0
           ! the last unconverged interval found
           prev = 0
           rgap = wgap( i1-offset )
           loop_75: do i = i1, ilast
              k = 2*i
              ii = i - offset
              left = w( ii ) - werr( ii )
              right = w( ii ) + werr( ii )
              lgap = rgap
              rgap = wgap( ii )
              gap = min( lgap, rgap )
              ! make sure that [left,right] contains the desired eigenvalue
              ! compute negcount from dstqds facto l+d+l+^t = l d l^t - left
              ! do while( negcnt(left)>i-1 )
              back = werr( ii )
              20 continue
              negcnt = stdlib_slaneg( n, d, lld, left, pivmin, r )
              if( negcnt>i-1 ) then
                 left = left - back
                 back = two*back
                 go to 20
              end if
              ! do while( negcnt(right)<i )
              ! compute negcount from dstqds facto l+d+l+^t = l d l^t - right
              back = werr( ii )
              50 continue
              negcnt = stdlib_slaneg( n, d, lld, right, pivmin, r )
               if( negcnt<i ) then
                  right = right + back
                  back = two*back
                  go to 50
               end if
              width = half*abs( left - right )
              tmp = max( abs( left ), abs( right ) )
              cvrgd = max(rtol1*gap,rtol2*tmp)
              if( width<=cvrgd .or. width<=mnwdth ) then
                 ! this interval has already converged and does not need refinement.
                 ! (note that the gaps might change through refining the
                  ! eigenvalues, however, they can only get bigger.)
                 ! remove it from the list.
                 iwork( k-1 ) = -1
                 ! make sure that i1 always points to the first unconverged interval
                 if((i==i1).and.(i<ilast)) i1 = i + 1
                 if((prev>=i1).and.(i<=ilast)) iwork( 2*prev-1 ) = i + 1
              else
                 ! unconverged interval found
                 prev = i
                 nint = nint + 1
                 iwork( k-1 ) = i + 1
                 iwork( k ) = negcnt
              end if
              work( k-1 ) = left
              work( k ) = right
           end do loop_75
           ! do while( nint>0 ), i.e. there are still unconverged intervals
           ! and while (iter<maxitr)
           iter = 0
           80 continue
           prev = i1 - 1
           i = i1
           olnint = nint
           loop_100: do ip = 1, olnint
              k = 2*i
              ii = i - offset
              rgap = wgap( ii )
              lgap = rgap
              if(ii>1) lgap = wgap( ii-1 )
              gap = min( lgap, rgap )
              next = iwork( k-1 )
              left = work( k-1 )
              right = work( k )
              mid = half*( left + right )
              ! semiwidth of interval
              width = right - mid
              tmp = max( abs( left ), abs( right ) )
              cvrgd = max(rtol1*gap,rtol2*tmp)
              if( ( width<=cvrgd ) .or. ( width<=mnwdth ).or.( iter==maxitr ) )then
                 ! reduce number of unconverged intervals
                 nint = nint - 1
                 ! mark interval as converged.
                 iwork( k-1 ) = 0
                 if( i1==i ) then
                    i1 = next
                 else
                    ! prev holds the last unconverged interval previously examined
                    if(prev>=i1) iwork( 2*prev-1 ) = next
                 end if
                 i = next
                 cycle loop_100
              end if
              prev = i
              ! perform one bisection step
              negcnt = stdlib_slaneg( n, d, lld, mid, pivmin, r )
              if( negcnt<=i-1 ) then
                 work( k-1 ) = mid
              else
                 work( k ) = mid
              end if
              i = next
           end do loop_100
           iter = iter + 1
           ! do another loop if there are still unconverged intervals
           ! however, in the last iteration, all intervals are accepted
           ! since this is the best we can do.
           if( ( nint>0 ).and.(iter<=maxitr) ) go to 80
           ! at this point, all the intervals have converged
           do i = ifirst, ilast
              k = 2*i
              ii = i - offset
              ! all intervals marked by '0' have been refined.
              if( iwork( k-1 )==0 ) then
                 w( ii ) = half*( work( k-1 )+work( k ) )
                 werr( ii ) = work( k ) - w( ii )
              end if
           end do
           do i = ifirst+1, ilast
              k = 2*i
              ii = i - offset
              wgap( ii-1 ) = max( zero,w(ii) - werr (ii) - w( ii-1 ) - werr( ii-1 ))
           end do
           return
     end subroutine stdlib_slarrb

     pure subroutine stdlib_dlarrb( n, d, lld, ifirst, ilast, rtol1,rtol2, offset, w, wgap, werr, &
     !! Given the relatively robust representation(RRR) L D L^T, DLARRB:
     !! does "limited" bisection to refine the eigenvalues of L D L^T,
     !! W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial
     !! guesses for these eigenvalues are input in W, the corresponding estimate
     !! of the error in these guesses and their gaps are input in WERR
     !! and WGAP, respectively. During bisection, intervals
     !! [left, right] are maintained by storing their mid-points and
     !! semi-widths in the arrays W and WERR respectively.
               work, iwork,pivmin, spdiam, twist, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ifirst, ilast, n, offset, twist
           integer(ilp), intent(out) :: info
           real(dp), intent(in) :: pivmin, rtol1, rtol2, spdiam
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(in) :: d(*), lld(*)
           real(dp), intent(inout) :: w(*), werr(*), wgap(*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           integer(ilp) :: maxitr
           ! Local Scalars 
           integer(ilp) :: i, i1, ii, ip, iter, k, negcnt, next, nint, olnint, prev, r
           real(dp) :: back, cvrgd, gap, left, lgap, mid, mnwdth, rgap, right, tmp, width
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           maxitr = int( ( log( spdiam+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
           mnwdth = two * pivmin
           r = twist
           if((r<1).or.(r>n)) r = n
           ! initialize unconverged intervals in [ work(2*i-1), work(2*i) ].
           ! the sturm count, count( work(2*i-1) ) is arranged to be i-1, while
           ! count( work(2*i) ) is stored in iwork( 2*i ). the integer iwork( 2*i-1 )
           ! for an unconverged interval is set to the index of the next unconverged
           ! interval, and is -1 or 0 for a converged interval. thus a linked
           ! list of unconverged intervals is set up.
           i1 = ifirst
           ! the number of unconverged intervals
           nint = 0
           ! the last unconverged interval found
           prev = 0
           rgap = wgap( i1-offset )
           loop_75: do i = i1, ilast
              k = 2*i
              ii = i - offset
              left = w( ii ) - werr( ii )
              right = w( ii ) + werr( ii )
              lgap = rgap
              rgap = wgap( ii )
              gap = min( lgap, rgap )
              ! make sure that [left,right] contains the desired eigenvalue
              ! compute negcount from dstqds facto l+d+l+^t = l d l^t - left
              ! do while( negcnt(left)>i-1 )
              back = werr( ii )
              20 continue
              negcnt = stdlib_dlaneg( n, d, lld, left, pivmin, r )
              if( negcnt>i-1 ) then
                 left = left - back
                 back = two*back
                 go to 20
              end if
              ! do while( negcnt(right)<i )
              ! compute negcount from dstqds facto l+d+l+^t = l d l^t - right
              back = werr( ii )
              50 continue
              negcnt = stdlib_dlaneg( n, d, lld, right, pivmin, r )
               if( negcnt<i ) then
                  right = right + back
                  back = two*back
                  go to 50
               end if
              width = half*abs( left - right )
              tmp = max( abs( left ), abs( right ) )
              cvrgd = max(rtol1*gap,rtol2*tmp)
              if( width<=cvrgd .or. width<=mnwdth ) then
                 ! this interval has already converged and does not need refinement.
                 ! (note that the gaps might change through refining the
                  ! eigenvalues, however, they can only get bigger.)
                 ! remove it from the list.
                 iwork( k-1 ) = -1
                 ! make sure that i1 always points to the first unconverged interval
                 if((i==i1).and.(i<ilast)) i1 = i + 1
                 if((prev>=i1).and.(i<=ilast)) iwork( 2*prev-1 ) = i + 1
              else
                 ! unconverged interval found
                 prev = i
                 nint = nint + 1
                 iwork( k-1 ) = i + 1
                 iwork( k ) = negcnt
              end if
              work( k-1 ) = left
              work( k ) = right
           end do loop_75
           ! do while( nint>0 ), i.e. there are still unconverged intervals
           ! and while (iter<maxitr)
           iter = 0
           80 continue
           prev = i1 - 1
           i = i1
           olnint = nint
           loop_100: do ip = 1, olnint
              k = 2*i
              ii = i - offset
              rgap = wgap( ii )
              lgap = rgap
              if(ii>1) lgap = wgap( ii-1 )
              gap = min( lgap, rgap )
              next = iwork( k-1 )
              left = work( k-1 )
              right = work( k )
              mid = half*( left + right )
              ! semiwidth of interval
              width = right - mid
              tmp = max( abs( left ), abs( right ) )
              cvrgd = max(rtol1*gap,rtol2*tmp)
              if( ( width<=cvrgd ) .or. ( width<=mnwdth ).or.( iter==maxitr ) )then
                 ! reduce number of unconverged intervals
                 nint = nint - 1
                 ! mark interval as converged.
                 iwork( k-1 ) = 0
                 if( i1==i ) then
                    i1 = next
                 else
                    ! prev holds the last unconverged interval previously examined
                    if(prev>=i1) iwork( 2*prev-1 ) = next
                 end if
                 i = next
                 cycle loop_100
              end if
              prev = i
              ! perform one bisection step
              negcnt = stdlib_dlaneg( n, d, lld, mid, pivmin, r )
              if( negcnt<=i-1 ) then
                 work( k-1 ) = mid
              else
                 work( k ) = mid
              end if
              i = next
           end do loop_100
           iter = iter + 1
           ! do another loop if there are still unconverged intervals
           ! however, in the last iteration, all intervals are accepted
           ! since this is the best we can do.
           if( ( nint>0 ).and.(iter<=maxitr) ) go to 80
           ! at this point, all the intervals have converged
           do i = ifirst, ilast
              k = 2*i
              ii = i - offset
              ! all intervals marked by '0' have been refined.
              if( iwork( k-1 )==0 ) then
                 w( ii ) = half*( work( k-1 )+work( k ) )
                 werr( ii ) = work( k ) - w( ii )
              end if
           end do
           do i = ifirst+1, ilast
              k = 2*i
              ii = i - offset
              wgap( ii-1 ) = max( zero,w(ii) - werr (ii) - w( ii-1 ) - werr( ii-1 ))
           end do
           return
     end subroutine stdlib_dlarrb

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$larrb( n, d, lld, ifirst, ilast, rtol1,rtol2, offset, w, wgap, werr, &
     !! Given the relatively robust representation(RRR) L D L^T, DLARRB:
     !! does "limited" bisection to refine the eigenvalues of L D L^T,
     !! W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial
     !! guesses for these eigenvalues are input in W, the corresponding estimate
     !! of the error in these guesses and their gaps are input in WERR
     !! and WGAP, respectively. During bisection, intervals
     !! [left, right] are maintained by storing their mid-points and
     !! semi-widths in the arrays W and WERR respectively.
               work, iwork,pivmin, spdiam, twist, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ifirst, ilast, n, offset, twist
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(in) :: pivmin, rtol1, rtol2, spdiam
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: d(*), lld(*)
           real(${rk}$), intent(inout) :: w(*), werr(*), wgap(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           integer(ilp) :: maxitr
           ! Local Scalars 
           integer(ilp) :: i, i1, ii, ip, iter, k, negcnt, next, nint, olnint, prev, r
           real(${rk}$) :: back, cvrgd, gap, left, lgap, mid, mnwdth, rgap, right, tmp, width
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           maxitr = int( ( log( spdiam+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
           mnwdth = two * pivmin
           r = twist
           if((r<1).or.(r>n)) r = n
           ! initialize unconverged intervals in [ work(2*i-1), work(2*i) ].
           ! the sturm count, count( work(2*i-1) ) is arranged to be i-1, while
           ! count( work(2*i) ) is stored in iwork( 2*i ). the integer iwork( 2*i-1 )
           ! for an unconverged interval is set to the index of the next unconverged
           ! interval, and is -1 or 0 for a converged interval. thus a linked
           ! list of unconverged intervals is set up.
           i1 = ifirst
           ! the number of unconverged intervals
           nint = 0
           ! the last unconverged interval found
           prev = 0
           rgap = wgap( i1-offset )
           loop_75: do i = i1, ilast
              k = 2*i
              ii = i - offset
              left = w( ii ) - werr( ii )
              right = w( ii ) + werr( ii )
              lgap = rgap
              rgap = wgap( ii )
              gap = min( lgap, rgap )
              ! make sure that [left,right] contains the desired eigenvalue
              ! compute negcount from dstqds facto l+d+l+^t = l d l^t - left
              ! do while( negcnt(left)>i-1 )
              back = werr( ii )
              20 continue
              negcnt = stdlib_${ri}$laneg( n, d, lld, left, pivmin, r )
              if( negcnt>i-1 ) then
                 left = left - back
                 back = two*back
                 go to 20
              end if
              ! do while( negcnt(right)<i )
              ! compute negcount from dstqds facto l+d+l+^t = l d l^t - right
              back = werr( ii )
              50 continue
              negcnt = stdlib_${ri}$laneg( n, d, lld, right, pivmin, r )
               if( negcnt<i ) then
                  right = right + back
                  back = two*back
                  go to 50
               end if
              width = half*abs( left - right )
              tmp = max( abs( left ), abs( right ) )
              cvrgd = max(rtol1*gap,rtol2*tmp)
              if( width<=cvrgd .or. width<=mnwdth ) then
                 ! this interval has already converged and does not need refinement.
                 ! (note that the gaps might change through refining the
                  ! eigenvalues, however, they can only get bigger.)
                 ! remove it from the list.
                 iwork( k-1 ) = -1
                 ! make sure that i1 always points to the first unconverged interval
                 if((i==i1).and.(i<ilast)) i1 = i + 1
                 if((prev>=i1).and.(i<=ilast)) iwork( 2*prev-1 ) = i + 1
              else
                 ! unconverged interval found
                 prev = i
                 nint = nint + 1
                 iwork( k-1 ) = i + 1
                 iwork( k ) = negcnt
              end if
              work( k-1 ) = left
              work( k ) = right
           end do loop_75
           ! do while( nint>0 ), i.e. there are still unconverged intervals
           ! and while (iter<maxitr)
           iter = 0
           80 continue
           prev = i1 - 1
           i = i1
           olnint = nint
           loop_100: do ip = 1, olnint
              k = 2*i
              ii = i - offset
              rgap = wgap( ii )
              lgap = rgap
              if(ii>1) lgap = wgap( ii-1 )
              gap = min( lgap, rgap )
              next = iwork( k-1 )
              left = work( k-1 )
              right = work( k )
              mid = half*( left + right )
              ! semiwidth of interval
              width = right - mid
              tmp = max( abs( left ), abs( right ) )
              cvrgd = max(rtol1*gap,rtol2*tmp)
              if( ( width<=cvrgd ) .or. ( width<=mnwdth ).or.( iter==maxitr ) )then
                 ! reduce number of unconverged intervals
                 nint = nint - 1
                 ! mark interval as converged.
                 iwork( k-1 ) = 0
                 if( i1==i ) then
                    i1 = next
                 else
                    ! prev holds the last unconverged interval previously examined
                    if(prev>=i1) iwork( 2*prev-1 ) = next
                 end if
                 i = next
                 cycle loop_100
              end if
              prev = i
              ! perform one bisection step
              negcnt = stdlib_${ri}$laneg( n, d, lld, mid, pivmin, r )
              if( negcnt<=i-1 ) then
                 work( k-1 ) = mid
              else
                 work( k ) = mid
              end if
              i = next
           end do loop_100
           iter = iter + 1
           ! do another loop if there are still unconverged intervals
           ! however, in the last iteration, all intervals are accepted
           ! since this is the best we can do.
           if( ( nint>0 ).and.(iter<=maxitr) ) go to 80
           ! at this point, all the intervals have converged
           do i = ifirst, ilast
              k = 2*i
              ii = i - offset
              ! all intervals marked by '0' have been refined.
              if( iwork( k-1 )==0 ) then
                 w( ii ) = half*( work( k-1 )+work( k ) )
                 werr( ii ) = work( k ) - w( ii )
              end if
           end do
           do i = ifirst+1, ilast
              k = 2*i
              ii = i - offset
              wgap( ii-1 ) = max( zero,w(ii) - werr (ii) - w( ii-1 ) - werr( ii-1 ))
           end do
           return
     end subroutine stdlib_${ri}$larrb

#:endif
#:endfor



     pure subroutine stdlib_slaeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, givnum,&
     q, qptr, z, ztemp, info )
     !! SLAEDA computes the Z vector corresponding to the merge step in the
     !! CURLVLth step of the merge process with TLVLS steps for the CURPBMth
     !! problem.
                
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: curlvl, curpbm, n, tlvls
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: givcol(2,*), givptr(*), perm(*), prmptr(*), qptr(*)
           real(sp), intent(in) :: givnum(2,*), q(*)
           real(sp), intent(out) :: z(*), ztemp(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: bsiz1, bsiz2, curr, i, k, mid, psiz1, psiz2, ptr, zptr1
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SLAEDA', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! determine location of first number in second half.
           mid = n / 2 + 1
           ! gather last/first rows of appropriate eigenblocks into center of z
           ptr = 1
           ! determine location of lowest level subproblem in the full storage
           ! scheme
           curr = ptr + curpbm*2**curlvl + 2**( curlvl-1 ) - 1
           ! determine size of these matrices.  we add half to the value of
           ! the sqrt in case the machine underestimates one of these square
           ! roots.
           bsiz1 = int( half+sqrt( real( qptr( curr+1 )-qptr( curr ),KIND=sp) ),KIND=ilp)
           bsiz2 = int( half+sqrt( real( qptr( curr+2 )-qptr( curr+1 ),KIND=sp) ),KIND=ilp)
                     
           do k = 1, mid - bsiz1 - 1
              z( k ) = zero
           end do
           call stdlib_scopy( bsiz1, q( qptr( curr )+bsiz1-1 ), bsiz1,z( mid-bsiz1 ), 1 )
           call stdlib_scopy( bsiz2, q( qptr( curr+1 ) ), bsiz2, z( mid ), 1 )
           do k = mid + bsiz2, n
              z( k ) = zero
           end do
           ! loop through remaining levels 1 -> curlvl applying the givens
           ! rotations and permutation and then multiplying the center matrices
           ! against the current z.
           ptr = 2**tlvls + 1
           loop_70: do k = 1, curlvl - 1
              curr = ptr + curpbm*2**( curlvl-k ) + 2**( curlvl-k-1 ) - 1
              psiz1 = prmptr( curr+1 ) - prmptr( curr )
              psiz2 = prmptr( curr+2 ) - prmptr( curr+1 )
              zptr1 = mid - psiz1
             ! apply givens at curr and curr+1
              do i = givptr( curr ), givptr( curr+1 ) - 1
                 call stdlib_srot( 1, z( zptr1+givcol( 1, i )-1 ), 1,z( zptr1+givcol( 2, i )-1 ), &
                           1, givnum( 1, i ),givnum( 2, i ) )
              end do
              do i = givptr( curr+1 ), givptr( curr+2 ) - 1
                 call stdlib_srot( 1, z( mid-1+givcol( 1, i ) ), 1,z( mid-1+givcol( 2, i ) ), 1, &
                           givnum( 1, i ),givnum( 2, i ) )
              end do
              psiz1 = prmptr( curr+1 ) - prmptr( curr )
              psiz2 = prmptr( curr+2 ) - prmptr( curr+1 )
              do i = 0, psiz1 - 1
                 ztemp( i+1 ) = z( zptr1+perm( prmptr( curr )+i )-1 )
              end do
              do i = 0, psiz2 - 1
                 ztemp( psiz1+i+1 ) = z( mid+perm( prmptr( curr+1 )+i )-1 )
              end do
              ! multiply blocks at curr and curr+1
              ! determine size of these matrices.  we add half to the value of
              ! the sqrt in case the machine underestimates one of these
              ! square roots.
              bsiz1 = int( half+sqrt( real( qptr( curr+1 )-qptr( curr ),KIND=sp) ),KIND=ilp)
                        
              bsiz2 = int( half+sqrt( real( qptr( curr+2 )-qptr( curr+1 ),KIND=sp) ),KIND=ilp)
                        
              if( bsiz1>0 ) then
                 call stdlib_sgemv( 'T', bsiz1, bsiz1, one, q( qptr( curr ) ),bsiz1, ztemp( 1 ), &
                           1, zero, z( zptr1 ), 1 )
              end if
              call stdlib_scopy( psiz1-bsiz1, ztemp( bsiz1+1 ), 1, z( zptr1+bsiz1 ),1 )
              if( bsiz2>0 ) then
                 call stdlib_sgemv( 'T', bsiz2, bsiz2, one, q( qptr( curr+1 ) ),bsiz2, ztemp( &
                           psiz1+1 ), 1, zero, z( mid ), 1 )
              end if
              call stdlib_scopy( psiz2-bsiz2, ztemp( psiz1+bsiz2+1 ), 1,z( mid+bsiz2 ), 1 )
                        
              ptr = ptr + 2**( tlvls-k )
           end do loop_70
           return
     end subroutine stdlib_slaeda

     pure subroutine stdlib_dlaeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, givnum,&
     q, qptr, z, ztemp, info )
     !! DLAEDA computes the Z vector corresponding to the merge step in the
     !! CURLVLth step of the merge process with TLVLS steps for the CURPBMth
     !! problem.
                
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: curlvl, curpbm, n, tlvls
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: givcol(2,*), givptr(*), perm(*), prmptr(*), qptr(*)
           real(dp), intent(in) :: givnum(2,*), q(*)
           real(dp), intent(out) :: z(*), ztemp(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: bsiz1, bsiz2, curr, i, k, mid, psiz1, psiz2, ptr, zptr1
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAEDA', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! determine location of first number in second half.
           mid = n / 2 + 1
           ! gather last/first rows of appropriate eigenblocks into center of z
           ptr = 1
           ! determine location of lowest level subproblem in the full storage
           ! scheme
           curr = ptr + curpbm*2**curlvl + 2**( curlvl-1 ) - 1
           ! determine size of these matrices.  we add half to the value of
           ! the sqrt in case the machine underestimates one of these square
           ! roots.
           bsiz1 = int( half+sqrt( real( qptr( curr+1 )-qptr( curr ),KIND=dp) ),KIND=ilp)
           bsiz2 = int( half+sqrt( real( qptr( curr+2 )-qptr( curr+1 ),KIND=dp) ),KIND=ilp)
                     
           do k = 1, mid - bsiz1 - 1
              z( k ) = zero
           end do
           call stdlib_dcopy( bsiz1, q( qptr( curr )+bsiz1-1 ), bsiz1,z( mid-bsiz1 ), 1 )
           call stdlib_dcopy( bsiz2, q( qptr( curr+1 ) ), bsiz2, z( mid ), 1 )
           do k = mid + bsiz2, n
              z( k ) = zero
           end do
           ! loop through remaining levels 1 -> curlvl applying the givens
           ! rotations and permutation and then multiplying the center matrices
           ! against the current z.
           ptr = 2**tlvls + 1
           loop_70: do k = 1, curlvl - 1
              curr = ptr + curpbm*2**( curlvl-k ) + 2**( curlvl-k-1 ) - 1
              psiz1 = prmptr( curr+1 ) - prmptr( curr )
              psiz2 = prmptr( curr+2 ) - prmptr( curr+1 )
              zptr1 = mid - psiz1
             ! apply givens at curr and curr+1
              do i = givptr( curr ), givptr( curr+1 ) - 1
                 call stdlib_drot( 1, z( zptr1+givcol( 1, i )-1 ), 1,z( zptr1+givcol( 2, i )-1 ), &
                           1, givnum( 1, i ),givnum( 2, i ) )
              end do
              do i = givptr( curr+1 ), givptr( curr+2 ) - 1
                 call stdlib_drot( 1, z( mid-1+givcol( 1, i ) ), 1,z( mid-1+givcol( 2, i ) ), 1, &
                           givnum( 1, i ),givnum( 2, i ) )
              end do
              psiz1 = prmptr( curr+1 ) - prmptr( curr )
              psiz2 = prmptr( curr+2 ) - prmptr( curr+1 )
              do i = 0, psiz1 - 1
                 ztemp( i+1 ) = z( zptr1+perm( prmptr( curr )+i )-1 )
              end do
              do i = 0, psiz2 - 1
                 ztemp( psiz1+i+1 ) = z( mid+perm( prmptr( curr+1 )+i )-1 )
              end do
              ! multiply blocks at curr and curr+1
              ! determine size of these matrices.  we add half to the value of
              ! the sqrt in case the machine underestimates one of these
              ! square roots.
              bsiz1 = int( half+sqrt( real( qptr( curr+1 )-qptr( curr ),KIND=dp) ),KIND=ilp)
                        
              bsiz2 = int( half+sqrt( real( qptr( curr+2 )-qptr( curr+1 ),KIND=dp) ),KIND=ilp)
                        
              if( bsiz1>0 ) then
                 call stdlib_dgemv( 'T', bsiz1, bsiz1, one, q( qptr( curr ) ),bsiz1, ztemp( 1 ), &
                           1, zero, z( zptr1 ), 1 )
              end if
              call stdlib_dcopy( psiz1-bsiz1, ztemp( bsiz1+1 ), 1, z( zptr1+bsiz1 ),1 )
              if( bsiz2>0 ) then
                 call stdlib_dgemv( 'T', bsiz2, bsiz2, one, q( qptr( curr+1 ) ),bsiz2, ztemp( &
                           psiz1+1 ), 1, zero, z( mid ), 1 )
              end if
              call stdlib_dcopy( psiz2-bsiz2, ztemp( psiz1+bsiz2+1 ), 1,z( mid+bsiz2 ), 1 )
                        
              ptr = ptr + 2**( tlvls-k )
           end do loop_70
           return
     end subroutine stdlib_dlaeda

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, givnum,&
     q, qptr, z, ztemp, info )
     !! DLAEDA: computes the Z vector corresponding to the merge step in the
     !! CURLVLth step of the merge process with TLVLS steps for the CURPBMth
     !! problem.
                
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: curlvl, curpbm, n, tlvls
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(in) :: givcol(2,*), givptr(*), perm(*), prmptr(*), qptr(*)
           real(${rk}$), intent(in) :: givnum(2,*), q(*)
           real(${rk}$), intent(out) :: z(*), ztemp(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: bsiz1, bsiz2, curr, i, k, mid, psiz1, psiz2, ptr, zptr1
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAEDA', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! determine location of first number in second half.
           mid = n / 2 + 1
           ! gather last/first rows of appropriate eigenblocks into center of z
           ptr = 1
           ! determine location of lowest level subproblem in the full storage
           ! scheme
           curr = ptr + curpbm*2**curlvl + 2**( curlvl-1 ) - 1
           ! determine size of these matrices.  we add half to the value of
           ! the sqrt in case the machine underestimates one of these square
           ! roots.
           bsiz1 = int( half+sqrt( real( qptr( curr+1 )-qptr( curr ),KIND=${rk}$) ),KIND=ilp)
           bsiz2 = int( half+sqrt( real( qptr( curr+2 )-qptr( curr+1 ),KIND=${rk}$) ),KIND=ilp)
                     
           do k = 1, mid - bsiz1 - 1
              z( k ) = zero
           end do
           call stdlib_${ri}$copy( bsiz1, q( qptr( curr )+bsiz1-1 ), bsiz1,z( mid-bsiz1 ), 1 )
           call stdlib_${ri}$copy( bsiz2, q( qptr( curr+1 ) ), bsiz2, z( mid ), 1 )
           do k = mid + bsiz2, n
              z( k ) = zero
           end do
           ! loop through remaining levels 1 -> curlvl applying the givens
           ! rotations and permutation and then multiplying the center matrices
           ! against the current z.
           ptr = 2**tlvls + 1
           loop_70: do k = 1, curlvl - 1
              curr = ptr + curpbm*2**( curlvl-k ) + 2**( curlvl-k-1 ) - 1
              psiz1 = prmptr( curr+1 ) - prmptr( curr )
              psiz2 = prmptr( curr+2 ) - prmptr( curr+1 )
              zptr1 = mid - psiz1
             ! apply givens at curr and curr+1
              do i = givptr( curr ), givptr( curr+1 ) - 1
                 call stdlib_${ri}$rot( 1, z( zptr1+givcol( 1, i )-1 ), 1,z( zptr1+givcol( 2, i )-1 ), &
                           1, givnum( 1, i ),givnum( 2, i ) )
              end do
              do i = givptr( curr+1 ), givptr( curr+2 ) - 1
                 call stdlib_${ri}$rot( 1, z( mid-1+givcol( 1, i ) ), 1,z( mid-1+givcol( 2, i ) ), 1, &
                           givnum( 1, i ),givnum( 2, i ) )
              end do
              psiz1 = prmptr( curr+1 ) - prmptr( curr )
              psiz2 = prmptr( curr+2 ) - prmptr( curr+1 )
              do i = 0, psiz1 - 1
                 ztemp( i+1 ) = z( zptr1+perm( prmptr( curr )+i )-1 )
              end do
              do i = 0, psiz2 - 1
                 ztemp( psiz1+i+1 ) = z( mid+perm( prmptr( curr+1 )+i )-1 )
              end do
              ! multiply blocks at curr and curr+1
              ! determine size of these matrices.  we add half to the value of
              ! the sqrt in case the machine underestimates one of these
              ! square roots.
              bsiz1 = int( half+sqrt( real( qptr( curr+1 )-qptr( curr ),KIND=${rk}$) ),KIND=ilp)
                        
              bsiz2 = int( half+sqrt( real( qptr( curr+2 )-qptr( curr+1 ),KIND=${rk}$) ),KIND=ilp)
                        
              if( bsiz1>0 ) then
                 call stdlib_${ri}$gemv( 'T', bsiz1, bsiz1, one, q( qptr( curr ) ),bsiz1, ztemp( 1 ), &
                           1, zero, z( zptr1 ), 1 )
              end if
              call stdlib_${ri}$copy( psiz1-bsiz1, ztemp( bsiz1+1 ), 1, z( zptr1+bsiz1 ),1 )
              if( bsiz2>0 ) then
                 call stdlib_${ri}$gemv( 'T', bsiz2, bsiz2, one, q( qptr( curr+1 ) ),bsiz2, ztemp( &
                           psiz1+1 ), 1, zero, z( mid ), 1 )
              end if
              call stdlib_${ri}$copy( psiz2-bsiz2, ztemp( psiz1+bsiz2+1 ), 1,z( mid+bsiz2 ), 1 )
                        
              ptr = ptr + 2**( tlvls-k )
           end do loop_70
           return
     end subroutine stdlib_${ri}$laeda

#:endif
#:endfor



     pure subroutine stdlib_sstedc( compz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )
     !! SSTEDC computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric tridiagonal matrix using the divide and conquer method.
     !! The eigenvectors of a full or band real symmetric matrix can also be
     !! found if SSYTRD or SSPTRD or SSBTRD has been used to reduce this
     !! matrix to tridiagonal form.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.  See SLAED3 for details.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, liwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: d(*), e(*), z(ldz,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: finish, i, icompz, ii, j, k, lgn, liwmin, lwmin, m, smlsiz, start, &
                     storez, strtrw
           real(sp) :: eps, orgnrm, p, tiny
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or.( icompz>0 .and. ldz<max( 1, n ) ) ) then
              info = -6
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              smlsiz = stdlib_ilaenv( 9, 'SSTEDC', ' ', 0, 0, 0, 0 )
              if( n<=1 .or. icompz==0 ) then
                 liwmin = 1
                 lwmin = 1
              else if( n<=smlsiz ) then
                 liwmin = 1
                 lwmin = 2*( n - 1 )
              else
                 lgn = int( log( real( n,KIND=sp) )/log( two ),KIND=ilp)
                 if( 2**lgn<n )lgn = lgn + 1
                 if( 2**lgn<n )lgn = lgn + 1
                 if( icompz==1 ) then
                    lwmin = 1 + 3*n + 2*n*lgn + 4*n**2
                    liwmin = 6 + 6*n + 5*n*lgn
                 else if( icompz==2 ) then
                    lwmin = 1 + 4*n + n**2
                    liwmin = 3 + 5*n
                 end if
              end if
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not. lquery ) then
                 info = -8
              else if( liwork<liwmin .and. .not. lquery ) then
                 info = -10
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSTEDC', -info )
              return
           else if (lquery) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz/=0 )z( 1, 1 ) = one
              return
           end if
           ! if the following conditional clause is removed, then the routine
           ! will use the divide and conquer routine to compute only the
           ! eigenvalues, which requires (3n + 3n**2) real workspace and
           ! (2 + 5n + 2n lg(n)) integer workspace.
           ! since on many architectures stdlib_ssterf is much faster than any other
           ! algorithm for finding eigenvalues only, it is used here
           ! as the default. if the conditional clause is removed, then
           ! information on the size of workspace needs to be changed.
           ! if compz = 'n', use stdlib_ssterf to compute the eigenvalues.
           if( icompz==0 ) then
              call stdlib_ssterf( n, d, e, info )
              go to 50
           end if
           ! if n is smaller than the minimum divide size (smlsiz+1), then
           ! solve the problem with another solver.
           if( n<=smlsiz ) then
              call stdlib_ssteqr( compz, n, d, e, z, ldz, work, info )
           else
              ! if compz = 'v', the z matrix must be stored elsewhere for later
              ! use.
              if( icompz==1 ) then
                 storez = 1 + n*n
              else
                 storez = 1
              end if
              if( icompz==2 ) then
                 call stdlib_slaset( 'FULL', n, n, zero, one, z, ldz )
              end if
              ! scale.
              orgnrm = stdlib_slanst( 'M', n, d, e )
              if( orgnrm==zero )go to 50
              eps = stdlib_slamch( 'EPSILON' )
              start = 1
              ! while ( start <= n )
              10 continue
              if( start<=n ) then
                 ! let finish be the position of the next subdiagonal entry
                 ! such that e( finish ) <= tiny or finish = n if no such
                 ! subdiagonal exists.  the matrix identified by the elements
                 ! between start and finish constitutes an independent
                 ! sub-problem.
                 finish = start
                 20 continue
                 if( finish<n ) then
                    tiny = eps*sqrt( abs( d( finish ) ) )*sqrt( abs( d( finish+1 ) ) )
                    if( abs( e( finish ) )>tiny ) then
                       finish = finish + 1
                       go to 20
                    end if
                 end if
                 ! (sub) problem determined.  compute its size and solve it.
                 m = finish - start + 1
                 if( m==1 ) then
                    start = finish + 1
                    go to 10
                 end if
                 if( m>smlsiz ) then
                    ! scale.
                    orgnrm = stdlib_slanst( 'M', m, d( start ), e( start ) )
                    call stdlib_slascl( 'G', 0, 0, orgnrm, one, m, 1, d( start ), m,info )
                    call stdlib_slascl( 'G', 0, 0, orgnrm, one, m-1, 1, e( start ),m-1, info )
                              
                    if( icompz==1 ) then
                       strtrw = 1
                    else
                       strtrw = start
                    end if
                    call stdlib_slaed0( icompz, n, m, d( start ), e( start ),z( strtrw, start ), &
                              ldz, work( 1 ), n,work( storez ), iwork, info )
                    if( info/=0 ) then
                       info = ( info / ( m+1 )+start-1 )*( n+1 ) +mod( info, ( m+1 ) ) + start - &
                                 1
                       go to 50
                    end if
                    ! scale back.
                    call stdlib_slascl( 'G', 0, 0, one, orgnrm, m, 1, d( start ), m,info )
                 else
                    if( icompz==1 ) then
                       ! since qr won't update a z matrix which is larger than
                       ! the length of d, we must solve the sub-problem in a
                       ! workspace and then multiply back into z.
                       call stdlib_ssteqr( 'I', m, d( start ), e( start ), work, m,work( m*m+1 ), &
                                 info )
                       call stdlib_slacpy( 'A', n, m, z( 1, start ), ldz,work( storez ), n )
                                 
                       call stdlib_sgemm( 'N', 'N', n, m, m, one,work( storez ), n, work, m, zero,&
                                 z( 1, start ), ldz )
                    else if( icompz==2 ) then
                       call stdlib_ssteqr( 'I', m, d( start ), e( start ),z( start, start ), ldz, &
                                 work, info )
                    else
                       call stdlib_ssterf( m, d( start ), e( start ), info )
                    end if
                    if( info/=0 ) then
                       info = start*( n+1 ) + finish
                       go to 50
                    end if
                 end if
                 start = finish + 1
                 go to 10
              end if
              ! endwhile
              if( icompz==0 ) then
                ! use quick sort
                call stdlib_slasrt( 'I', n, d, info )
              else
                ! use selection sort to minimize swaps of eigenvectors
                do ii = 2, n
                   i = ii - 1
                   k = i
                   p = d( i )
                   do j = ii, n
                      if( d( j )<p ) then
                         k = j
                         p = d( j )
                      end if
                   end do
                   if( k/=i ) then
                      d( k ) = d( i )
                      d( i ) = p
                      call stdlib_sswap( n, z( 1, i ), 1, z( 1, k ), 1 )
                   end if
                end do
              end if
           end if
           50 continue
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_sstedc

     pure subroutine stdlib_dstedc( compz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )
     !! DSTEDC computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric tridiagonal matrix using the divide and conquer method.
     !! The eigenvectors of a full or band real symmetric matrix can also be
     !! found if DSYTRD or DSPTRD or DSBTRD has been used to reduce this
     !! matrix to tridiagonal form.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.  See DLAED3 for details.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, liwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(inout) :: d(*), e(*), z(ldz,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: finish, i, icompz, ii, j, k, lgn, liwmin, lwmin, m, smlsiz, start, &
                     storez, strtrw
           real(dp) :: eps, orgnrm, p, tiny
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or.( icompz>0 .and. ldz<max( 1, n ) ) ) then
              info = -6
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              smlsiz = stdlib_ilaenv( 9, 'DSTEDC', ' ', 0, 0, 0, 0 )
              if( n<=1 .or. icompz==0 ) then
                 liwmin = 1
                 lwmin = 1
              else if( n<=smlsiz ) then
                 liwmin = 1
                 lwmin = 2*( n - 1 )
              else
                 lgn = int( log( real( n,KIND=dp) )/log( two ),KIND=ilp)
                 if( 2**lgn<n )lgn = lgn + 1
                 if( 2**lgn<n )lgn = lgn + 1
                 if( icompz==1 ) then
                    lwmin = 1 + 3*n + 2*n*lgn + 4*n**2
                    liwmin = 6 + 6*n + 5*n*lgn
                 else if( icompz==2 ) then
                    lwmin = 1 + 4*n + n**2
                    liwmin = 3 + 5*n
                 end if
              end if
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not. lquery ) then
                 info = -8
              else if( liwork<liwmin .and. .not. lquery ) then
                 info = -10
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEDC', -info )
              return
           else if (lquery) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz/=0 )z( 1, 1 ) = one
              return
           end if
           ! if the following conditional clause is removed, then the routine
           ! will use the divide and conquer routine to compute only the
           ! eigenvalues, which requires (3n + 3n**2) real workspace and
           ! (2 + 5n + 2n lg(n)) integer workspace.
           ! since on many architectures stdlib_dsterf is much faster than any other
           ! algorithm for finding eigenvalues only, it is used here
           ! as the default. if the conditional clause is removed, then
           ! information on the size of workspace needs to be changed.
           ! if compz = 'n', use stdlib_dsterf to compute the eigenvalues.
           if( icompz==0 ) then
              call stdlib_dsterf( n, d, e, info )
              go to 50
           end if
           ! if n is smaller than the minimum divide size (smlsiz+1), then
           ! solve the problem with another solver.
           if( n<=smlsiz ) then
              call stdlib_dsteqr( compz, n, d, e, z, ldz, work, info )
           else
              ! if compz = 'v', the z matrix must be stored elsewhere for later
              ! use.
              if( icompz==1 ) then
                 storez = 1 + n*n
              else
                 storez = 1
              end if
              if( icompz==2 ) then
                 call stdlib_dlaset( 'FULL', n, n, zero, one, z, ldz )
              end if
              ! scale.
              orgnrm = stdlib_dlanst( 'M', n, d, e )
              if( orgnrm==zero )go to 50
              eps = stdlib_dlamch( 'EPSILON' )
              start = 1
              ! while ( start <= n )
              10 continue
              if( start<=n ) then
                 ! let finish be the position of the next subdiagonal entry
                 ! such that e( finish ) <= tiny or finish = n if no such
                 ! subdiagonal exists.  the matrix identified by the elements
                 ! between start and finish constitutes an independent
                 ! sub-problem.
                 finish = start
                 20 continue
                 if( finish<n ) then
                    tiny = eps*sqrt( abs( d( finish ) ) )*sqrt( abs( d( finish+1 ) ) )
                    if( abs( e( finish ) )>tiny ) then
                       finish = finish + 1
                       go to 20
                    end if
                 end if
                 ! (sub) problem determined.  compute its size and solve it.
                 m = finish - start + 1
                 if( m==1 ) then
                    start = finish + 1
                    go to 10
                 end if
                 if( m>smlsiz ) then
                    ! scale.
                    orgnrm = stdlib_dlanst( 'M', m, d( start ), e( start ) )
                    call stdlib_dlascl( 'G', 0, 0, orgnrm, one, m, 1, d( start ), m,info )
                    call stdlib_dlascl( 'G', 0, 0, orgnrm, one, m-1, 1, e( start ),m-1, info )
                              
                    if( icompz==1 ) then
                       strtrw = 1
                    else
                       strtrw = start
                    end if
                    call stdlib_dlaed0( icompz, n, m, d( start ), e( start ),z( strtrw, start ), &
                              ldz, work( 1 ), n,work( storez ), iwork, info )
                    if( info/=0 ) then
                       info = ( info / ( m+1 )+start-1 )*( n+1 ) +mod( info, ( m+1 ) ) + start - &
                                 1
                       go to 50
                    end if
                    ! scale back.
                    call stdlib_dlascl( 'G', 0, 0, one, orgnrm, m, 1, d( start ), m,info )
                 else
                    if( icompz==1 ) then
                       ! since qr won't update a z matrix which is larger than
                       ! the length of d, we must solve the sub-problem in a
                       ! workspace and then multiply back into z.
                       call stdlib_dsteqr( 'I', m, d( start ), e( start ), work, m,work( m*m+1 ), &
                                 info )
                       call stdlib_dlacpy( 'A', n, m, z( 1, start ), ldz,work( storez ), n )
                                 
                       call stdlib_dgemm( 'N', 'N', n, m, m, one,work( storez ), n, work, m, zero,&
                                 z( 1, start ), ldz )
                    else if( icompz==2 ) then
                       call stdlib_dsteqr( 'I', m, d( start ), e( start ),z( start, start ), ldz, &
                                 work, info )
                    else
                       call stdlib_dsterf( m, d( start ), e( start ), info )
                    end if
                    if( info/=0 ) then
                       info = start*( n+1 ) + finish
                       go to 50
                    end if
                 end if
                 start = finish + 1
                 go to 10
              end if
              ! endwhile
              if( icompz==0 ) then
                ! use quick sort
                call stdlib_dlasrt( 'I', n, d, info )
              else
                ! use selection sort to minimize swaps of eigenvectors
                do ii = 2, n
                   i = ii - 1
                   k = i
                   p = d( i )
                   do j = ii, n
                      if( d( j )<p ) then
                         k = j
                         p = d( j )
                      end if
                   end do
                   if( k/=i ) then
                      d( k ) = d( i )
                      d( i ) = p
                      call stdlib_dswap( n, z( 1, i ), 1, z( 1, k ), 1 )
                   end if
                end do
              end if
           end if
           50 continue
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_dstedc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$stedc( compz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )
     !! DSTEDC: computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric tridiagonal matrix using the divide and conquer method.
     !! The eigenvectors of a full or band real symmetric matrix can also be
     !! found if DSYTRD or DSPTRD or DSBTRD has been used to reduce this
     !! matrix to tridiagonal form.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.  See DLAED3 for details.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, liwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: finish, i, icompz, ii, j, k, lgn, liwmin, lwmin, m, smlsiz, start, &
                     storez, strtrw
           real(${rk}$) :: eps, orgnrm, p, tiny
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or.( icompz>0 .and. ldz<max( 1, n ) ) ) then
              info = -6
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              smlsiz = stdlib_ilaenv( 9, 'DSTEDC', ' ', 0, 0, 0, 0 )
              if( n<=1 .or. icompz==0 ) then
                 liwmin = 1
                 lwmin = 1
              else if( n<=smlsiz ) then
                 liwmin = 1
                 lwmin = 2*( n - 1 )
              else
                 lgn = int( log( real( n,KIND=${rk}$) )/log( two ),KIND=ilp)
                 if( 2**lgn<n )lgn = lgn + 1
                 if( 2**lgn<n )lgn = lgn + 1
                 if( icompz==1 ) then
                    lwmin = 1 + 3*n + 2*n*lgn + 4*n**2
                    liwmin = 6 + 6*n + 5*n*lgn
                 else if( icompz==2 ) then
                    lwmin = 1 + 4*n + n**2
                    liwmin = 3 + 5*n
                 end if
              end if
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not. lquery ) then
                 info = -8
              else if( liwork<liwmin .and. .not. lquery ) then
                 info = -10
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEDC', -info )
              return
           else if (lquery) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz/=0 )z( 1, 1 ) = one
              return
           end if
           ! if the following conditional clause is removed, then the routine
           ! will use the divide and conquer routine to compute only the
           ! eigenvalues, which requires (3n + 3n**2) real workspace and
           ! (2 + 5n + 2n lg(n)) integer workspace.
           ! since on many architectures stdlib_${ri}$sterf is much faster than any other
           ! algorithm for finding eigenvalues only, it is used here
           ! as the default. if the conditional clause is removed, then
           ! information on the size of workspace needs to be changed.
           ! if compz = 'n', use stdlib_${ri}$sterf to compute the eigenvalues.
           if( icompz==0 ) then
              call stdlib_${ri}$sterf( n, d, e, info )
              go to 50
           end if
           ! if n is smaller than the minimum divide size (smlsiz+1), then
           ! solve the problem with another solver.
           if( n<=smlsiz ) then
              call stdlib_${ri}$steqr( compz, n, d, e, z, ldz, work, info )
           else
              ! if compz = 'v', the z matrix must be stored elsewhere for later
              ! use.
              if( icompz==1 ) then
                 storez = 1 + n*n
              else
                 storez = 1
              end if
              if( icompz==2 ) then
                 call stdlib_${ri}$laset( 'FULL', n, n, zero, one, z, ldz )
              end if
              ! scale.
              orgnrm = stdlib_${ri}$lanst( 'M', n, d, e )
              if( orgnrm==zero )go to 50
              eps = stdlib_${ri}$lamch( 'EPSILON' )
              start = 1
              ! while ( start <= n )
              10 continue
              if( start<=n ) then
                 ! let finish be the position of the next subdiagonal entry
                 ! such that e( finish ) <= tiny or finish = n if no such
                 ! subdiagonal exists.  the matrix identified by the elements
                 ! between start and finish constitutes an independent
                 ! sub-problem.
                 finish = start
                 20 continue
                 if( finish<n ) then
                    tiny = eps*sqrt( abs( d( finish ) ) )*sqrt( abs( d( finish+1 ) ) )
                    if( abs( e( finish ) )>tiny ) then
                       finish = finish + 1
                       go to 20
                    end if
                 end if
                 ! (sub) problem determined.  compute its size and solve it.
                 m = finish - start + 1
                 if( m==1 ) then
                    start = finish + 1
                    go to 10
                 end if
                 if( m>smlsiz ) then
                    ! scale.
                    orgnrm = stdlib_${ri}$lanst( 'M', m, d( start ), e( start ) )
                    call stdlib_${ri}$lascl( 'G', 0, 0, orgnrm, one, m, 1, d( start ), m,info )
                    call stdlib_${ri}$lascl( 'G', 0, 0, orgnrm, one, m-1, 1, e( start ),m-1, info )
                              
                    if( icompz==1 ) then
                       strtrw = 1
                    else
                       strtrw = start
                    end if
                    call stdlib_${ri}$laed0( icompz, n, m, d( start ), e( start ),z( strtrw, start ), &
                              ldz, work( 1 ), n,work( storez ), iwork, info )
                    if( info/=0 ) then
                       info = ( info / ( m+1 )+start-1 )*( n+1 ) +mod( info, ( m+1 ) ) + start - &
                                 1
                       go to 50
                    end if
                    ! scale back.
                    call stdlib_${ri}$lascl( 'G', 0, 0, one, orgnrm, m, 1, d( start ), m,info )
                 else
                    if( icompz==1 ) then
                       ! since qr won't update a z matrix which is larger than
                       ! the length of d, we must solve the sub-problem in a
                       ! workspace and then multiply back into z.
                       call stdlib_${ri}$steqr( 'I', m, d( start ), e( start ), work, m,work( m*m+1 ), &
                                 info )
                       call stdlib_${ri}$lacpy( 'A', n, m, z( 1, start ), ldz,work( storez ), n )
                                 
                       call stdlib_${ri}$gemm( 'N', 'N', n, m, m, one,work( storez ), n, work, m, zero,&
                                 z( 1, start ), ldz )
                    else if( icompz==2 ) then
                       call stdlib_${ri}$steqr( 'I', m, d( start ), e( start ),z( start, start ), ldz, &
                                 work, info )
                    else
                       call stdlib_${ri}$sterf( m, d( start ), e( start ), info )
                    end if
                    if( info/=0 ) then
                       info = start*( n+1 ) + finish
                       go to 50
                    end if
                 end if
                 start = finish + 1
                 go to 10
              end if
              ! endwhile
              if( icompz==0 ) then
                ! use quick sort
                call stdlib_${ri}$lasrt( 'I', n, d, info )
              else
                ! use selection sort to minimize swaps of eigenvectors
                do ii = 2, n
                   i = ii - 1
                   k = i
                   p = d( i )
                   do j = ii, n
                      if( d( j )<p ) then
                         k = j
                         p = d( j )
                      end if
                   end do
                   if( k/=i ) then
                      d( k ) = d( i )
                      d( i ) = p
                      call stdlib_${ri}$swap( n, z( 1, i ), 1, z( 1, k ), 1 )
                   end if
                end do
              end if
           end if
           50 continue
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$stedc

#:endif
#:endfor

     pure subroutine stdlib_cstedc( compz, n, d, e, z, ldz, work, lwork, rwork,lrwork, iwork, &
     !! CSTEDC computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric tridiagonal matrix using the divide and conquer method.
     !! The eigenvectors of a full or band complex Hermitian matrix can also
     !! be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
     !! matrix to tridiagonal form.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.  See SLAED3 for details.
               liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, liwork, lrwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: finish, i, icompz, ii, j, k, lgn, liwmin, ll, lrwmin, lwmin, m, smlsiz,&
                      start
           real(sp) :: eps, orgnrm, p, tiny
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 .or. lrwork==-1 .or. liwork==-1 )
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or.( icompz>0 .and. ldz<max( 1, n ) ) ) then
              info = -6
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              smlsiz = stdlib_ilaenv( 9, 'CSTEDC', ' ', 0, 0, 0, 0 )
              if( n<=1 .or. icompz==0 ) then
                 lwmin = 1
                 liwmin = 1
                 lrwmin = 1
              else if( n<=smlsiz ) then
                 lwmin = 1
                 liwmin = 1
                 lrwmin = 2*( n - 1 )
              else if( icompz==1 ) then
                 lgn = int( log( real( n,KIND=sp) ) / log( two ),KIND=ilp)
                 if( 2**lgn<n )lgn = lgn + 1
                 if( 2**lgn<n )lgn = lgn + 1
                 lwmin = n*n
                 lrwmin = 1 + 3*n + 2*n*lgn + 4*n**2
                 liwmin = 6 + 6*n + 5*n*lgn
              else if( icompz==2 ) then
                 lwmin = 1
                 lrwmin = 1 + 4*n + 2*n**2
                 liwmin = 3 + 5*n
              end if
              work( 1 ) = lwmin
              rwork( 1 ) = lrwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -8
              else if( lrwork<lrwmin .and. .not.lquery ) then
                 info = -10
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSTEDC', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz/=0 )z( 1, 1 ) = one
              return
           end if
           ! if the following conditional clause is removed, then the routine
           ! will use the divide and conquer routine to compute only the
           ! eigenvalues, which requires (3n + 3n**2) real workspace and
           ! (2 + 5n + 2n lg(n)) integer workspace.
           ! since on many architectures stdlib_ssterf is much faster than any other
           ! algorithm for finding eigenvalues only, it is used here
           ! as the default. if the conditional clause is removed, then
           ! information on the size of workspace needs to be changed.
           ! if compz = 'n', use stdlib_ssterf to compute the eigenvalues.
           if( icompz==0 ) then
              call stdlib_ssterf( n, d, e, info )
              go to 70
           end if
           ! if n is smaller than the minimum divide size (smlsiz+1), then
           ! solve the problem with another solver.
           if( n<=smlsiz ) then
              call stdlib_csteqr( compz, n, d, e, z, ldz, rwork, info )
           else
              ! if compz = 'i', we simply call stdlib_sstedc instead.
              if( icompz==2 ) then
                 call stdlib_slaset( 'FULL', n, n, zero, one, rwork, n )
                 ll = n*n + 1
                 call stdlib_sstedc( 'I', n, d, e, rwork, n,rwork( ll ), lrwork-ll+1, iwork, &
                           liwork, info )
                 do j = 1, n
                    do i = 1, n
                       z( i, j ) = rwork( ( j-1 )*n+i )
                    end do
                 end do
                 go to 70
              end if
              ! from now on, only option left to be handled is compz = 'v',
              ! i.e. icompz = 1.
              ! scale.
              orgnrm = stdlib_slanst( 'M', n, d, e )
              if( orgnrm==zero )go to 70
              eps = stdlib_slamch( 'EPSILON' )
              start = 1
              ! while ( start <= n )
              30 continue
              if( start<=n ) then
                 ! let finish be the position of the next subdiagonal entry
                 ! such that e( finish ) <= tiny or finish = n if no such
                 ! subdiagonal exists.  the matrix identified by the elements
                 ! between start and finish constitutes an independent
                 ! sub-problem.
                 finish = start
                 40 continue
                 if( finish<n ) then
                    tiny = eps*sqrt( abs( d( finish ) ) )*sqrt( abs( d( finish+1 ) ) )
                    if( abs( e( finish ) )>tiny ) then
                       finish = finish + 1
                       go to 40
                    end if
                 end if
                 ! (sub) problem determined.  compute its size and solve it.
                 m = finish - start + 1
                 if( m>smlsiz ) then
                    ! scale.
                    orgnrm = stdlib_slanst( 'M', m, d( start ), e( start ) )
                    call stdlib_slascl( 'G', 0, 0, orgnrm, one, m, 1, d( start ), m,info )
                    call stdlib_slascl( 'G', 0, 0, orgnrm, one, m-1, 1, e( start ),m-1, info )
                              
                    call stdlib_claed0( n, m, d( start ), e( start ), z( 1, start ),ldz, work, n, &
                              rwork, iwork, info )
                    if( info>0 ) then
                       info = ( info / ( m+1 )+start-1 )*( n+1 ) +mod( info, ( m+1 ) ) + start - &
                                 1
                       go to 70
                    end if
                    ! scale back.
                    call stdlib_slascl( 'G', 0, 0, one, orgnrm, m, 1, d( start ), m,info )
                 else
                    call stdlib_ssteqr( 'I', m, d( start ), e( start ), rwork, m,rwork( m*m+1 ), &
                              info )
                    call stdlib_clacrm( n, m, z( 1, start ), ldz, rwork, m, work, n,rwork( m*m+1 )&
                               )
                    call stdlib_clacpy( 'A', n, m, work, n, z( 1, start ), ldz )
                    if( info>0 ) then
                       info = start*( n+1 ) + finish
                       go to 70
                    end if
                 end if
                 start = finish + 1
                 go to 30
              end if
              ! endwhile
              ! use selection sort to minimize swaps of eigenvectors
              do ii = 2, n
                i = ii - 1
                k = i
                p = d( i )
                do j = ii, n
                   if( d( j )<p ) then
                      k = j
                      p = d( j )
                   end if
                end do
                if( k/=i ) then
                   d( k ) = d( i )
                   d( i ) = p
                   call stdlib_cswap( n, z( 1, i ), 1, z( 1, k ), 1 )
                end if
              end do
           end if
           70 continue
           work( 1 ) = lwmin
           rwork( 1 ) = lrwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_cstedc

     pure subroutine stdlib_zstedc( compz, n, d, e, z, ldz, work, lwork, rwork,lrwork, iwork, &
     !! ZSTEDC computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric tridiagonal matrix using the divide and conquer method.
     !! The eigenvectors of a full or band complex Hermitian matrix can also
     !! be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this
     !! matrix to tridiagonal form.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.  See DLAED3 for details.
               liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, liwork, lrwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(out) :: work(*)
           complex(dp), intent(inout) :: z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: finish, i, icompz, ii, j, k, lgn, liwmin, ll, lrwmin, lwmin, m, smlsiz,&
                      start
           real(dp) :: eps, orgnrm, p, tiny
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 .or. lrwork==-1 .or. liwork==-1 )
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or.( icompz>0 .and. ldz<max( 1, n ) ) ) then
              info = -6
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              smlsiz = stdlib_ilaenv( 9, 'ZSTEDC', ' ', 0, 0, 0, 0 )
              if( n<=1 .or. icompz==0 ) then
                 lwmin = 1
                 liwmin = 1
                 lrwmin = 1
              else if( n<=smlsiz ) then
                 lwmin = 1
                 liwmin = 1
                 lrwmin = 2*( n - 1 )
              else if( icompz==1 ) then
                 lgn = int( log( real( n,KIND=dp) ) / log( two ),KIND=ilp)
                 if( 2**lgn<n )lgn = lgn + 1
                 if( 2**lgn<n )lgn = lgn + 1
                 lwmin = n*n
                 lrwmin = 1 + 3*n + 2*n*lgn + 4*n**2
                 liwmin = 6 + 6*n + 5*n*lgn
              else if( icompz==2 ) then
                 lwmin = 1
                 lrwmin = 1 + 4*n + 2*n**2
                 liwmin = 3 + 5*n
              end if
              work( 1 ) = lwmin
              rwork( 1 ) = lrwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -8
              else if( lrwork<lrwmin .and. .not.lquery ) then
                 info = -10
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSTEDC', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz/=0 )z( 1, 1 ) = one
              return
           end if
           ! if the following conditional clause is removed, then the routine
           ! will use the divide and conquer routine to compute only the
           ! eigenvalues, which requires (3n + 3n**2) real workspace and
           ! (2 + 5n + 2n lg(n)) integer workspace.
           ! since on many architectures stdlib_dsterf is much faster than any other
           ! algorithm for finding eigenvalues only, it is used here
           ! as the default. if the conditional clause is removed, then
           ! information on the size of workspace needs to be changed.
           ! if compz = 'n', use stdlib_dsterf to compute the eigenvalues.
           if( icompz==0 ) then
              call stdlib_dsterf( n, d, e, info )
              go to 70
           end if
           ! if n is smaller than the minimum divide size (smlsiz+1), then
           ! solve the problem with another solver.
           if( n<=smlsiz ) then
              call stdlib_zsteqr( compz, n, d, e, z, ldz, rwork, info )
           else
              ! if compz = 'i', we simply call stdlib_dstedc instead.
              if( icompz==2 ) then
                 call stdlib_dlaset( 'FULL', n, n, zero, one, rwork, n )
                 ll = n*n + 1
                 call stdlib_dstedc( 'I', n, d, e, rwork, n,rwork( ll ), lrwork-ll+1, iwork, &
                           liwork, info )
                 do j = 1, n
                    do i = 1, n
                       z( i, j ) = rwork( ( j-1 )*n+i )
                    end do
                 end do
                 go to 70
              end if
              ! from now on, only option left to be handled is compz = 'v',
              ! i.e. icompz = 1.
              ! scale.
              orgnrm = stdlib_dlanst( 'M', n, d, e )
              if( orgnrm==zero )go to 70
              eps = stdlib_dlamch( 'EPSILON' )
              start = 1
              ! while ( start <= n )
              30 continue
              if( start<=n ) then
                 ! let finish be the position of the next subdiagonal entry
                 ! such that e( finish ) <= tiny or finish = n if no such
                 ! subdiagonal exists.  the matrix identified by the elements
                 ! between start and finish constitutes an independent
                 ! sub-problem.
                 finish = start
                 40 continue
                 if( finish<n ) then
                    tiny = eps*sqrt( abs( d( finish ) ) )*sqrt( abs( d( finish+1 ) ) )
                    if( abs( e( finish ) )>tiny ) then
                       finish = finish + 1
                       go to 40
                    end if
                 end if
                 ! (sub) problem determined.  compute its size and solve it.
                 m = finish - start + 1
                 if( m>smlsiz ) then
                    ! scale.
                    orgnrm = stdlib_dlanst( 'M', m, d( start ), e( start ) )
                    call stdlib_dlascl( 'G', 0, 0, orgnrm, one, m, 1, d( start ), m,info )
                    call stdlib_dlascl( 'G', 0, 0, orgnrm, one, m-1, 1, e( start ),m-1, info )
                              
                    call stdlib_zlaed0( n, m, d( start ), e( start ), z( 1, start ),ldz, work, n, &
                              rwork, iwork, info )
                    if( info>0 ) then
                       info = ( info / ( m+1 )+start-1 )*( n+1 ) +mod( info, ( m+1 ) ) + start - &
                                 1
                       go to 70
                    end if
                    ! scale back.
                    call stdlib_dlascl( 'G', 0, 0, one, orgnrm, m, 1, d( start ), m,info )
                 else
                    call stdlib_dsteqr( 'I', m, d( start ), e( start ), rwork, m,rwork( m*m+1 ), &
                              info )
                    call stdlib_zlacrm( n, m, z( 1, start ), ldz, rwork, m, work, n,rwork( m*m+1 )&
                               )
                    call stdlib_zlacpy( 'A', n, m, work, n, z( 1, start ), ldz )
                    if( info>0 ) then
                       info = start*( n+1 ) + finish
                       go to 70
                    end if
                 end if
                 start = finish + 1
                 go to 30
              end if
              ! endwhile
              ! use selection sort to minimize swaps of eigenvectors
              do ii = 2, n
                i = ii - 1
                k = i
                p = d( i )
                do j = ii, n
                   if( d( j )<p ) then
                      k = j
                      p = d( j )
                   end if
                end do
                if( k/=i ) then
                   d( k ) = d( i )
                   d( i ) = p
                   call stdlib_zswap( n, z( 1, i ), 1, z( 1, k ), 1 )
                end if
              end do
           end if
           70 continue
           work( 1 ) = lwmin
           rwork( 1 ) = lrwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_zstedc

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$stedc( compz, n, d, e, z, ldz, work, lwork, rwork,lrwork, iwork, &
     !! ZSTEDC: computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric tridiagonal matrix using the divide and conquer method.
     !! The eigenvectors of a full or band complex Hermitian matrix can also
     !! be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this
     !! matrix to tridiagonal form.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.  See DLAED3 for details.
               liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, liwork, lrwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${ck}$), intent(inout) :: d(*), e(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(inout) :: z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: finish, i, icompz, ii, j, k, lgn, liwmin, ll, lrwmin, lwmin, m, smlsiz,&
                      start
           real(${ck}$) :: eps, orgnrm, p, tiny
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 .or. lrwork==-1 .or. liwork==-1 )
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or.( icompz>0 .and. ldz<max( 1, n ) ) ) then
              info = -6
           end if
           if( info==0 ) then
              ! compute the workspace requirements
              smlsiz = stdlib_ilaenv( 9, 'ZSTEDC', ' ', 0, 0, 0, 0 )
              if( n<=1 .or. icompz==0 ) then
                 lwmin = 1
                 liwmin = 1
                 lrwmin = 1
              else if( n<=smlsiz ) then
                 lwmin = 1
                 liwmin = 1
                 lrwmin = 2*( n - 1 )
              else if( icompz==1 ) then
                 lgn = int( log( real( n,KIND=${ck}$) ) / log( two ),KIND=ilp)
                 if( 2**lgn<n )lgn = lgn + 1
                 if( 2**lgn<n )lgn = lgn + 1
                 lwmin = n*n
                 lrwmin = 1 + 3*n + 2*n*lgn + 4*n**2
                 liwmin = 6 + 6*n + 5*n*lgn
              else if( icompz==2 ) then
                 lwmin = 1
                 lrwmin = 1 + 4*n + 2*n**2
                 liwmin = 3 + 5*n
              end if
              work( 1 ) = lwmin
              rwork( 1 ) = lrwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -8
              else if( lrwork<lrwmin .and. .not.lquery ) then
                 info = -10
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -12
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSTEDC', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz/=0 )z( 1, 1 ) = one
              return
           end if
           ! if the following conditional clause is removed, then the routine
           ! will use the divide and conquer routine to compute only the
           ! eigenvalues, which requires (3n + 3n**2) real workspace and
           ! (2 + 5n + 2n lg(n)) integer workspace.
           ! since on many architectures stdlib_${c2ri(ci)}$sterf is much faster than any other
           ! algorithm for finding eigenvalues only, it is used here
           ! as the default. if the conditional clause is removed, then
           ! information on the size of workspace needs to be changed.
           ! if compz = 'n', use stdlib_${c2ri(ci)}$sterf to compute the eigenvalues.
           if( icompz==0 ) then
              call stdlib_${c2ri(ci)}$sterf( n, d, e, info )
              go to 70
           end if
           ! if n is smaller than the minimum divide size (smlsiz+1), then
           ! solve the problem with another solver.
           if( n<=smlsiz ) then
              call stdlib_${ci}$steqr( compz, n, d, e, z, ldz, rwork, info )
           else
              ! if compz = 'i', we simply call stdlib_${c2ri(ci)}$stedc instead.
              if( icompz==2 ) then
                 call stdlib_${c2ri(ci)}$laset( 'FULL', n, n, zero, one, rwork, n )
                 ll = n*n + 1
                 call stdlib_${c2ri(ci)}$stedc( 'I', n, d, e, rwork, n,rwork( ll ), lrwork-ll+1, iwork, &
                           liwork, info )
                 do j = 1, n
                    do i = 1, n
                       z( i, j ) = rwork( ( j-1 )*n+i )
                    end do
                 end do
                 go to 70
              end if
              ! from now on, only option left to be handled is compz = 'v',
              ! i.e. icompz = 1.
              ! scale.
              orgnrm = stdlib_${c2ri(ci)}$lanst( 'M', n, d, e )
              if( orgnrm==zero )go to 70
              eps = stdlib_${c2ri(ci)}$lamch( 'EPSILON' )
              start = 1
              ! while ( start <= n )
              30 continue
              if( start<=n ) then
                 ! let finish be the position of the next subdiagonal entry
                 ! such that e( finish ) <= tiny or finish = n if no such
                 ! subdiagonal exists.  the matrix identified by the elements
                 ! between start and finish constitutes an independent
                 ! sub-problem.
                 finish = start
                 40 continue
                 if( finish<n ) then
                    tiny = eps*sqrt( abs( d( finish ) ) )*sqrt( abs( d( finish+1 ) ) )
                    if( abs( e( finish ) )>tiny ) then
                       finish = finish + 1
                       go to 40
                    end if
                 end if
                 ! (sub) problem determined.  compute its size and solve it.
                 m = finish - start + 1
                 if( m>smlsiz ) then
                    ! scale.
                    orgnrm = stdlib_${c2ri(ci)}$lanst( 'M', m, d( start ), e( start ) )
                    call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, orgnrm, one, m, 1, d( start ), m,info )
                    call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, orgnrm, one, m-1, 1, e( start ),m-1, info )
                              
                    call stdlib_${ci}$laed0( n, m, d( start ), e( start ), z( 1, start ),ldz, work, n, &
                              rwork, iwork, info )
                    if( info>0 ) then
                       info = ( info / ( m+1 )+start-1 )*( n+1 ) +mod( info, ( m+1 ) ) + start - &
                                 1
                       go to 70
                    end if
                    ! scale back.
                    call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, one, orgnrm, m, 1, d( start ), m,info )
                 else
                    call stdlib_${c2ri(ci)}$steqr( 'I', m, d( start ), e( start ), rwork, m,rwork( m*m+1 ), &
                              info )
                    call stdlib_${ci}$lacrm( n, m, z( 1, start ), ldz, rwork, m, work, n,rwork( m*m+1 )&
                               )
                    call stdlib_${ci}$lacpy( 'A', n, m, work, n, z( 1, start ), ldz )
                    if( info>0 ) then
                       info = start*( n+1 ) + finish
                       go to 70
                    end if
                 end if
                 start = finish + 1
                 go to 30
              end if
              ! endwhile
              ! use selection sort to minimize swaps of eigenvectors
              do ii = 2, n
                i = ii - 1
                k = i
                p = d( i )
                do j = ii, n
                   if( d( j )<p ) then
                      k = j
                      p = d( j )
                   end if
                end do
                if( k/=i ) then
                   d( k ) = d( i )
                   d( i ) = p
                   call stdlib_${ci}$swap( n, z( 1, i ), 1, z( 1, k ), 1 )
                end if
              end do
           end if
           70 continue
           work( 1 ) = lwmin
           rwork( 1 ) = lrwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ci}$stedc

#:endif
#:endfor









     pure subroutine stdlib_chetrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
     !! CHETRD reduces a complex Hermitian matrix A to real symmetric
     !! tridiagonal form T by a unitary similarity transformation:
     !! Q**H * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, iws, j, kk, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -9
           end if
           if( info==0 ) then
              ! determine the block size.
              nb = stdlib_ilaenv( 1, 'CHETRD', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHETRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           nx = n
           iws = 1
           if( nb>1 .and. nb<n ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code).
              nx = max( nb, stdlib_ilaenv( 3, 'CHETRD', uplo, n, -1, -1, -1 ) )
              if( nx<n ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = n
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code by setting nx = n.
                    nb = max( lwork / ldwork, 1 )
                    nbmin = stdlib_ilaenv( 2, 'CHETRD', uplo, n, -1, -1, -1 )
                    if( nb<nbmin )nx = n
                 end if
              else
                 nx = n
              end if
           else
              nb = 1
           end if
           if( upper ) then
              ! reduce the upper triangle of a.
              ! columns 1:kk are handled by the unblocked method.
              kk = n - ( ( n-nx+nb-1 ) / nb )*nb
              do i = n - nb + 1, kk + 1, -nb
                 ! reduce columns i:i+nb-1 to tridiagonal form and form the
                 ! matrix w which is needed to update the unreduced part of
                 ! the matrix
                 call stdlib_clatrd( uplo, i+nb-1, nb, a, lda, e, tau, work,ldwork )
                 ! update the unreduced submatrix a(1:i-1,1:i-1), using an
                 ! update of the form:  a := a - v*w**h - w*v**h
                 call stdlib_cher2k( uplo, 'NO TRANSPOSE', i-1, nb, -cone,a( 1, i ), lda, work, &
                           ldwork, one, a, lda )
                 ! copy superdiagonal elements back into a, and diagonal
                 ! elements into d
                 do j = i, i + nb - 1
                    a( j-1, j ) = e( j-1 )
                    d( j ) = real( a( j, j ),KIND=sp)
                 end do
              end do
              ! use unblocked code to reduce the last or only block
              call stdlib_chetd2( uplo, kk, a, lda, d, e, tau, iinfo )
           else
              ! reduce the lower triangle of a
              do i = 1, n - nx, nb
                 ! reduce columns i:i+nb-1 to tridiagonal form and form the
                 ! matrix w which is needed to update the unreduced part of
                 ! the matrix
                 call stdlib_clatrd( uplo, n-i+1, nb, a( i, i ), lda, e( i ),tau( i ), work, &
                           ldwork )
                 ! update the unreduced submatrix a(i+nb:n,i+nb:n), using
                 ! an update of the form:  a := a - v*w**h - w*v**h
                 call stdlib_cher2k( uplo, 'NO TRANSPOSE', n-i-nb+1, nb, -cone,a( i+nb, i ), lda, &
                           work( nb+1 ), ldwork, one,a( i+nb, i+nb ), lda )
                 ! copy subdiagonal elements back into a, and diagonal
                 ! elements into d
                 do j = i, i + nb - 1
                    a( j+1, j ) = e( j )
                    d( j ) = real( a( j, j ),KIND=sp)
                 end do
              end do
              ! use unblocked code to reduce the last or only block
              call stdlib_chetd2( uplo, n-i+1, a( i, i ), lda, d( i ), e( i ),tau( i ), iinfo )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chetrd

     pure subroutine stdlib_zhetrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
     !! ZHETRD reduces a complex Hermitian matrix A to real symmetric
     !! tridiagonal form T by a unitary similarity transformation:
     !! Q**H * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           real(dp), intent(out) :: d(*), e(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, iws, j, kk, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -9
           end if
           if( info==0 ) then
              ! determine the block size.
              nb = stdlib_ilaenv( 1, 'ZHETRD', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           nx = n
           iws = 1
           if( nb>1 .and. nb<n ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code).
              nx = max( nb, stdlib_ilaenv( 3, 'ZHETRD', uplo, n, -1, -1, -1 ) )
              if( nx<n ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = n
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code by setting nx = n.
                    nb = max( lwork / ldwork, 1 )
                    nbmin = stdlib_ilaenv( 2, 'ZHETRD', uplo, n, -1, -1, -1 )
                    if( nb<nbmin )nx = n
                 end if
              else
                 nx = n
              end if
           else
              nb = 1
           end if
           if( upper ) then
              ! reduce the upper triangle of a.
              ! columns 1:kk are handled by the unblocked method.
              kk = n - ( ( n-nx+nb-1 ) / nb )*nb
              do i = n - nb + 1, kk + 1, -nb
                 ! reduce columns i:i+nb-1 to tridiagonal form and form the
                 ! matrix w which is needed to update the unreduced part of
                 ! the matrix
                 call stdlib_zlatrd( uplo, i+nb-1, nb, a, lda, e, tau, work,ldwork )
                 ! update the unreduced submatrix a(1:i-1,1:i-1), using an
                 ! update of the form:  a := a - v*w**h - w*v**h
                 call stdlib_zher2k( uplo, 'NO TRANSPOSE', i-1, nb, -cone,a( 1, i ), lda, work, &
                           ldwork, one, a, lda )
                 ! copy superdiagonal elements back into a, and diagonal
                 ! elements into d
                 do j = i, i + nb - 1
                    a( j-1, j ) = e( j-1 )
                    d( j ) = real( a( j, j ),KIND=dp)
                 end do
              end do
              ! use unblocked code to reduce the last or only block
              call stdlib_zhetd2( uplo, kk, a, lda, d, e, tau, iinfo )
           else
              ! reduce the lower triangle of a
              do i = 1, n - nx, nb
                 ! reduce columns i:i+nb-1 to tridiagonal form and form the
                 ! matrix w which is needed to update the unreduced part of
                 ! the matrix
                 call stdlib_zlatrd( uplo, n-i+1, nb, a( i, i ), lda, e( i ),tau( i ), work, &
                           ldwork )
                 ! update the unreduced submatrix a(i+nb:n,i+nb:n), using
                 ! an update of the form:  a := a - v*w**h - w*v**h
                 call stdlib_zher2k( uplo, 'NO TRANSPOSE', n-i-nb+1, nb, -cone,a( i+nb, i ), lda, &
                           work( nb+1 ), ldwork, one,a( i+nb, i+nb ), lda )
                 ! copy subdiagonal elements back into a, and diagonal
                 ! elements into d
                 do j = i, i + nb - 1
                    a( j+1, j ) = e( j )
                    d( j ) = real( a( j, j ),KIND=dp)
                 end do
              end do
              ! use unblocked code to reduce the last or only block
              call stdlib_zhetd2( uplo, n-i+1, a( i, i ), lda, d( i ), e( i ),tau( i ), iinfo )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zhetrd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$hetrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
     !! ZHETRD: reduces a complex Hermitian matrix A to real symmetric
     !! tridiagonal form T by a unitary similarity transformation:
     !! Q**H * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           real(${ck}$), intent(out) :: d(*), e(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: tau(*), work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, iws, j, kk, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -9
           end if
           if( info==0 ) then
              ! determine the block size.
              nb = stdlib_ilaenv( 1, 'ZHETRD', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHETRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           nx = n
           iws = 1
           if( nb>1 .and. nb<n ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code).
              nx = max( nb, stdlib_ilaenv( 3, 'ZHETRD', uplo, n, -1, -1, -1 ) )
              if( nx<n ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = n
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code by setting nx = n.
                    nb = max( lwork / ldwork, 1 )
                    nbmin = stdlib_ilaenv( 2, 'ZHETRD', uplo, n, -1, -1, -1 )
                    if( nb<nbmin )nx = n
                 end if
              else
                 nx = n
              end if
           else
              nb = 1
           end if
           if( upper ) then
              ! reduce the upper triangle of a.
              ! columns 1:kk are handled by the unblocked method.
              kk = n - ( ( n-nx+nb-1 ) / nb )*nb
              do i = n - nb + 1, kk + 1, -nb
                 ! reduce columns i:i+nb-1 to tridiagonal form and form the
                 ! matrix w which is needed to update the unreduced part of
                 ! the matrix
                 call stdlib_${ci}$latrd( uplo, i+nb-1, nb, a, lda, e, tau, work,ldwork )
                 ! update the unreduced submatrix a(1:i-1,1:i-1), using an
                 ! update of the form:  a := a - v*w**h - w*v**h
                 call stdlib_${ci}$her2k( uplo, 'NO TRANSPOSE', i-1, nb, -cone,a( 1, i ), lda, work, &
                           ldwork, one, a, lda )
                 ! copy superdiagonal elements back into a, and diagonal
                 ! elements into d
                 do j = i, i + nb - 1
                    a( j-1, j ) = e( j-1 )
                    d( j ) = real( a( j, j ),KIND=${ck}$)
                 end do
              end do
              ! use unblocked code to reduce the last or only block
              call stdlib_${ci}$hetd2( uplo, kk, a, lda, d, e, tau, iinfo )
           else
              ! reduce the lower triangle of a
              do i = 1, n - nx, nb
                 ! reduce columns i:i+nb-1 to tridiagonal form and form the
                 ! matrix w which is needed to update the unreduced part of
                 ! the matrix
                 call stdlib_${ci}$latrd( uplo, n-i+1, nb, a( i, i ), lda, e( i ),tau( i ), work, &
                           ldwork )
                 ! update the unreduced submatrix a(i+nb:n,i+nb:n), using
                 ! an update of the form:  a := a - v*w**h - w*v**h
                 call stdlib_${ci}$her2k( uplo, 'NO TRANSPOSE', n-i-nb+1, nb, -cone,a( i+nb, i ), lda, &
                           work( nb+1 ), ldwork, one,a( i+nb, i+nb ), lda )
                 ! copy subdiagonal elements back into a, and diagonal
                 ! elements into d
                 do j = i, i + nb - 1
                    a( j+1, j ) = e( j )
                    d( j ) = real( a( j, j ),KIND=${ck}$)
                 end do
              end do
              ! use unblocked code to reduce the last or only block
              call stdlib_${ci}$hetd2( uplo, n-i+1, a( i, i ), lda, d( i ), e( i ),tau( i ), iinfo )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$hetrd

#:endif
#:endfor





     pure subroutine stdlib_sstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
     !! SSTEGR computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
     !! a well defined set of pairwise different real eigenvalues, the corresponding
     !! real eigenvectors are pairwise orthogonal.
     !! The spectrum may be computed either completely or partially by specifying
     !! either an interval (VL,VU] or a range of indices IL:IU for the desired
     !! eigenvalues.
     !! SSTEGR is a compatibility wrapper around the improved SSTEMR routine.
     !! See SSTEMR for further details.
     !! One important change is that the ABSTOL parameter no longer provides any
     !! benefit and hence is no longer used.
     !! Note : SSTEGR and SSTEMR work only on machines which follow
     !! IEEE-754 floating-point standard in their handling of infinities and
     !! NaNs.  Normal execution may create these exceptiona values and hence
     !! may abort due to a floating point exception in environments which
     !! do not conform to the IEEE-754 standard.
               isuppz, work, lwork, iwork,liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           integer(ilp), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: w(*), work(*)
           real(sp), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: tryrac
           ! Executable Statements 
           info = 0
           tryrac = .false.
           call stdlib_sstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, n, isuppz, &
                     tryrac, work, lwork,iwork, liwork, info )
     end subroutine stdlib_sstegr

     pure subroutine stdlib_dstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
     !! DSTEGR computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
     !! a well defined set of pairwise different real eigenvalues, the corresponding
     !! real eigenvectors are pairwise orthogonal.
     !! The spectrum may be computed either completely or partially by specifying
     !! either an interval (VL,VU] or a range of indices IL:IU for the desired
     !! eigenvalues.
     !! DSTEGR is a compatibility wrapper around the improved DSTEMR routine.
     !! See DSTEMR for further details.
     !! One important change is that the ABSTOL parameter no longer provides any
     !! benefit and hence is no longer used.
     !! Note : DSTEGR and DSTEMR work only on machines which follow
     !! IEEE-754 floating-point standard in their handling of infinities and
     !! NaNs.  Normal execution may create these exceptiona values and hence
     !! may abort due to a floating point exception in environments which
     !! do not conform to the IEEE-754 standard.
               isuppz, work, lwork, iwork,liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           integer(ilp), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: w(*), work(*)
           real(dp), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: tryrac
           ! Executable Statements 
           info = 0
           tryrac = .false.
           call stdlib_dstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, n, isuppz, &
                     tryrac, work, lwork,iwork, liwork, info )
     end subroutine stdlib_dstegr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$stegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
     !! DSTEGR: computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
     !! a well defined set of pairwise different real eigenvalues, the corresponding
     !! real eigenvectors are pairwise orthogonal.
     !! The spectrum may be computed either completely or partially by specifying
     !! either an interval (VL,VU] or a range of indices IL:IU for the desired
     !! eigenvalues.
     !! DSTEGR is a compatibility wrapper around the improved DSTEMR routine.
     !! See DSTEMR for further details.
     !! One important change is that the ABSTOL parameter no longer provides any
     !! benefit and hence is no longer used.
     !! Note : DSTEGR and DSTEMR work only on machines which follow
     !! IEEE-754 floating-point standard in their handling of infinities and
     !! NaNs.  Normal execution may create these exceptiona values and hence
     !! may abort due to a floating point exception in environments which
     !! do not conform to the IEEE-754 standard.
               isuppz, work, lwork, iwork,liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           integer(ilp), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: w(*), work(*)
           real(${rk}$), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: tryrac
           ! Executable Statements 
           info = 0
           tryrac = .false.
           call stdlib_${ri}$stemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, n, isuppz, &
                     tryrac, work, lwork,iwork, liwork, info )
     end subroutine stdlib_${ri}$stegr

#:endif
#:endfor

     pure subroutine stdlib_cstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
     !! CSTEGR computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
     !! a well defined set of pairwise different real eigenvalues, the corresponding
     !! real eigenvectors are pairwise orthogonal.
     !! The spectrum may be computed either completely or partially by specifying
     !! either an interval (VL,VU] or a range of indices IL:IU for the desired
     !! eigenvalues.
     !! CSTEGR is a compatibility wrapper around the improved CSTEMR routine.
     !! See SSTEMR for further details.
     !! One important change is that the ABSTOL parameter no longer provides any
     !! benefit and hence is no longer used.
     !! Note : CSTEGR and CSTEMR work only on machines which follow
     !! IEEE-754 floating-point standard in their handling of infinities and
     !! NaNs.  Normal execution may create these exceptiona values and hence
     !! may abort due to a floating point exception in environments which
     !! do not conform to the IEEE-754 standard.
               isuppz, work, lwork, iwork,liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           integer(ilp), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: w(*), work(*)
           complex(sp), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: tryrac
           ! Executable Statements 
           info = 0
           tryrac = .false.
           call stdlib_cstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, n, isuppz, &
                     tryrac, work, lwork,iwork, liwork, info )
     end subroutine stdlib_cstegr

     pure subroutine stdlib_zstegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
     !! ZSTEGR computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
     !! a well defined set of pairwise different real eigenvalues, the corresponding
     !! real eigenvectors are pairwise orthogonal.
     !! The spectrum may be computed either completely or partially by specifying
     !! either an interval (VL,VU] or a range of indices IL:IU for the desired
     !! eigenvalues.
     !! ZSTEGR is a compatibility wrapper around the improved ZSTEMR routine.
     !! See ZSTEMR for further details.
     !! One important change is that the ABSTOL parameter no longer provides any
     !! benefit and hence is no longer used.
     !! Note : ZSTEGR and ZSTEMR work only on machines which follow
     !! IEEE-754 floating-point standard in their handling of infinities and
     !! NaNs.  Normal execution may create these exceptiona values and hence
     !! may abort due to a floating point exception in environments which
     !! do not conform to the IEEE-754 standard.
               isuppz, work, lwork, iwork,liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           integer(ilp), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: w(*), work(*)
           complex(dp), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: tryrac
           ! Executable Statements 
           info = 0
           tryrac = .false.
           call stdlib_zstemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, n, isuppz, &
                     tryrac, work, lwork,iwork, liwork, info )
     end subroutine stdlib_zstegr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$stegr( jobz, range, n, d, e, vl, vu, il, iu,abstol, m, w, z, ldz, &
     !! ZSTEGR: computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix T. Any such unreduced matrix has
     !! a well defined set of pairwise different real eigenvalues, the corresponding
     !! real eigenvectors are pairwise orthogonal.
     !! The spectrum may be computed either completely or partially by specifying
     !! either an interval (VL,VU] or a range of indices IL:IU for the desired
     !! eigenvalues.
     !! ZSTEGR is a compatibility wrapper around the improved ZSTEMR routine.
     !! See ZSTEMR for further details.
     !! One important change is that the ABSTOL parameter no longer provides any
     !! benefit and hence is no longer used.
     !! Note : ZSTEGR and ZSTEMR work only on machines which follow
     !! IEEE-754 floating-point standard in their handling of infinities and
     !! NaNs.  Normal execution may create these exceptiona values and hence
     !! may abort due to a floating point exception in environments which
     !! do not conform to the IEEE-754 standard.
               isuppz, work, lwork, iwork,liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           integer(ilp), intent(in) :: il, iu, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(${ck}$), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(${ck}$), intent(inout) :: d(*), e(*)
           real(${ck}$), intent(out) :: w(*), work(*)
           complex(${ck}$), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: tryrac
           ! Executable Statements 
           info = 0
           tryrac = .false.
           call stdlib_${ci}$stemr( jobz, range, n, d, e, vl, vu, il, iu,m, w, z, ldz, n, isuppz, &
                     tryrac, work, lwork,iwork, liwork, info )
     end subroutine stdlib_${ci}$stegr

#:endif
#:endfor







     pure subroutine stdlib_ssteqr( compz, n, d, e, z, ldz, work, info )
     !! SSTEQR computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric tridiagonal matrix using the implicit QL or QR method.
     !! The eigenvectors of a full or band symmetric matrix can also be found
     !! if SSYTRD or SSPTRD or SSBTRD has been used to reduce this matrix to
     !! tridiagonal form.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(sp), intent(inout) :: d(*), e(*), z(ldz,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 30
           
           
           ! Local Scalars 
           integer(ilp) :: i, icompz, ii, iscale, j, jtot, k, l, l1, lend, lendm1, lendp1, lendsv,&
                      lm1, lsv, m, mm, mm1, nm1, nmaxit
           real(sp) :: anorm, b, c, eps, eps2, f, g, p, r, rt1, rt2, s, safmax, safmin, ssfmax, &
                     ssfmin, tst
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or. ( icompz>0 .and. ldz<max( 1,n ) ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSTEQR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz==2 )z( 1, 1 ) = one
              return
           end if
           ! determine the unit roundoff and over/underflow thresholds.
           eps = stdlib_slamch( 'E' )
           eps2 = eps**2
           safmin = stdlib_slamch( 'S' )
           safmax = one / safmin
           ssfmax = sqrt( safmax ) / three
           ssfmin = sqrt( safmin ) / eps2
           ! compute the eigenvalues and eigenvectors of the tridiagonal
           ! matrix.
           if( icompz==2 )call stdlib_slaset( 'FULL', n, n, zero, one, z, ldz )
           nmaxit = n*maxit
           jtot = 0
           ! determine where the matrix splits and choose ql or qr iteration
           ! for each block, according to whether top or bottom diagonal
           ! element is smaller.
           l1 = 1
           nm1 = n - 1
           10 continue
           if( l1>n )go to 160
           if( l1>1 )e( l1-1 ) = zero
           if( l1<=nm1 ) then
              do m = l1, nm1
                 tst = abs( e( m ) )
                 if( tst==zero )go to 30
                 if( tst<=( sqrt( abs( d( m ) ) )*sqrt( abs( d( m+1 ) ) ) )*eps ) then
                    e( m ) = zero
                    go to 30
                 end if
              end do
           end if
           m = n
           30 continue
           l = l1
           lsv = l
           lend = m
           lendsv = lend
           l1 = m + 1
           if( lend==l )go to 10
           ! scale submatrix in rows and columns l to lend
           anorm = stdlib_slanst( 'M', lend-l+1, d( l ), e( l ) )
           iscale = 0
           if( anorm==zero )go to 10
           if( anorm>ssfmax ) then
              iscale = 1
              call stdlib_slascl( 'G', 0, 0, anorm, ssfmax, lend-l+1, 1, d( l ), n,info )
              call stdlib_slascl( 'G', 0, 0, anorm, ssfmax, lend-l, 1, e( l ), n,info )
           else if( anorm<ssfmin ) then
              iscale = 2
              call stdlib_slascl( 'G', 0, 0, anorm, ssfmin, lend-l+1, 1, d( l ), n,info )
              call stdlib_slascl( 'G', 0, 0, anorm, ssfmin, lend-l, 1, e( l ), n,info )
           end if
           ! choose between ql and qr iteration
           if( abs( d( lend ) )<abs( d( l ) ) ) then
              lend = lsv
              l = lendsv
           end if
           if( lend>l ) then
              ! ql iteration
              ! look for small subdiagonal element.
              40 continue
              if( l/=lend ) then
                 lendm1 = lend - 1
                 do m = l, lendm1
                    tst = abs( e( m ) )**2
                    if( tst<=( eps2*abs( d( m ) ) )*abs( d( m+1 ) )+safmin )go to 60
                 end do
              end if
              m = lend
              60 continue
              if( m<lend )e( m ) = zero
              p = d( l )
              if( m==l )go to 80
              ! if remaining matrix is 2-by-2, use stdlib_slae2 or stdlib_slaev2
              ! to compute its eigensystem.
              if( m==l+1 ) then
                 if( icompz>0 ) then
                    call stdlib_slaev2( d( l ), e( l ), d( l+1 ), rt1, rt2, c, s )
                    work( l ) = c
                    work( n-1+l ) = s
                    call stdlib_slasr( 'R', 'V', 'B', n, 2, work( l ),work( n-1+l ), z( 1, l ), &
                              ldz )
                 else
                    call stdlib_slae2( d( l ), e( l ), d( l+1 ), rt1, rt2 )
                 end if
                 d( l ) = rt1
                 d( l+1 ) = rt2
                 e( l ) = zero
                 l = l + 2
                 if( l<=lend )go to 40
                 go to 140
              end if
              if( jtot==nmaxit )go to 140
              jtot = jtot + 1
              ! form shift.
              g = ( d( l+1 )-p ) / ( two*e( l ) )
              r = stdlib_slapy2( g, one )
              g = d( m ) - p + ( e( l ) / ( g+sign( r, g ) ) )
              s = one
              c = one
              p = zero
              ! inner loop
              mm1 = m - 1
              do i = mm1, l, -1
                 f = s*e( i )
                 b = c*e( i )
                 call stdlib_slartg( g, f, c, s, r )
                 if( i/=m-1 )e( i+1 ) = r
                 g = d( i+1 ) - p
                 r = ( d( i )-g )*s + two*c*b
                 p = s*r
                 d( i+1 ) = g + p
                 g = c*r - b
                 ! if eigenvectors are desired, then save rotations.
                 if( icompz>0 ) then
                    work( i ) = c
                    work( n-1+i ) = -s
                 end if
              end do
              ! if eigenvectors are desired, then apply saved rotations.
              if( icompz>0 ) then
                 mm = m - l + 1
                 call stdlib_slasr( 'R', 'V', 'B', n, mm, work( l ), work( n-1+l ),z( 1, l ), ldz &
                           )
              end if
              d( l ) = d( l ) - p
              e( l ) = g
              go to 40
              ! eigenvalue found.
              80 continue
              d( l ) = p
              l = l + 1
              if( l<=lend )go to 40
              go to 140
           else
              ! qr iteration
              ! look for small superdiagonal element.
              90 continue
              if( l/=lend ) then
                 lendp1 = lend + 1
                 do m = l, lendp1, -1
                    tst = abs( e( m-1 ) )**2
                    if( tst<=( eps2*abs( d( m ) ) )*abs( d( m-1 ) )+safmin )go to 110
                 end do
              end if
              m = lend
              110 continue
              if( m>lend )e( m-1 ) = zero
              p = d( l )
              if( m==l )go to 130
              ! if remaining matrix is 2-by-2, use stdlib_slae2 or stdlib_slaev2
              ! to compute its eigensystem.
              if( m==l-1 ) then
                 if( icompz>0 ) then
                    call stdlib_slaev2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2, c, s )
                    work( m ) = c
                    work( n-1+m ) = s
                    call stdlib_slasr( 'R', 'V', 'F', n, 2, work( m ),work( n-1+m ), z( 1, l-1 ), &
                              ldz )
                 else
                    call stdlib_slae2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2 )
                 end if
                 d( l-1 ) = rt1
                 d( l ) = rt2
                 e( l-1 ) = zero
                 l = l - 2
                 if( l>=lend )go to 90
                 go to 140
              end if
              if( jtot==nmaxit )go to 140
              jtot = jtot + 1
              ! form shift.
              g = ( d( l-1 )-p ) / ( two*e( l-1 ) )
              r = stdlib_slapy2( g, one )
              g = d( m ) - p + ( e( l-1 ) / ( g+sign( r, g ) ) )
              s = one
              c = one
              p = zero
              ! inner loop
              lm1 = l - 1
              do i = m, lm1
                 f = s*e( i )
                 b = c*e( i )
                 call stdlib_slartg( g, f, c, s, r )
                 if( i/=m )e( i-1 ) = r
                 g = d( i ) - p
                 r = ( d( i+1 )-g )*s + two*c*b
                 p = s*r
                 d( i ) = g + p
                 g = c*r - b
                 ! if eigenvectors are desired, then save rotations.
                 if( icompz>0 ) then
                    work( i ) = c
                    work( n-1+i ) = s
                 end if
              end do
              ! if eigenvectors are desired, then apply saved rotations.
              if( icompz>0 ) then
                 mm = l - m + 1
                 call stdlib_slasr( 'R', 'V', 'F', n, mm, work( m ), work( n-1+m ),z( 1, m ), ldz &
                           )
              end if
              d( l ) = d( l ) - p
              e( lm1 ) = g
              go to 90
              ! eigenvalue found.
              130 continue
              d( l ) = p
              l = l - 1
              if( l>=lend )go to 90
              go to 140
           end if
           ! undo scaling if necessary
           140 continue
           if( iscale==1 ) then
              call stdlib_slascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv+1, 1,d( lsv ), n, info )
                        
              call stdlib_slascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv, 1, e( lsv ),n, info )
                        
           else if( iscale==2 ) then
              call stdlib_slascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv+1, 1,d( lsv ), n, info )
                        
              call stdlib_slascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv, 1, e( lsv ),n, info )
                        
           end if
           ! check for no convergence to an eigenvalue after a total
           ! of n*maxit iterations.
           if( jtot<nmaxit )go to 10
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           go to 190
           ! order eigenvalues and eigenvectors.
           160 continue
           if( icompz==0 ) then
              ! use quick sort
              call stdlib_slasrt( 'I', n, d, info )
           else
              ! use selection sort to minimize swaps of eigenvectors
              do ii = 2, n
                 i = ii - 1
                 k = i
                 p = d( i )
                 do j = ii, n
                    if( d( j )<p ) then
                       k = j
                       p = d( j )
                    end if
                 end do
                 if( k/=i ) then
                    d( k ) = d( i )
                    d( i ) = p
                    call stdlib_sswap( n, z( 1, i ), 1, z( 1, k ), 1 )
                 end if
              end do
           end if
           190 continue
           return
     end subroutine stdlib_ssteqr

     pure subroutine stdlib_dsteqr( compz, n, d, e, z, ldz, work, info )
     !! DSTEQR computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric tridiagonal matrix using the implicit QL or QR method.
     !! The eigenvectors of a full or band symmetric matrix can also be found
     !! if DSYTRD or DSPTRD or DSBTRD has been used to reduce this matrix to
     !! tridiagonal form.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(dp), intent(inout) :: d(*), e(*), z(ldz,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 30
           
           
           ! Local Scalars 
           integer(ilp) :: i, icompz, ii, iscale, j, jtot, k, l, l1, lend, lendm1, lendp1, lendsv,&
                      lm1, lsv, m, mm, mm1, nm1, nmaxit
           real(dp) :: anorm, b, c, eps, eps2, f, g, p, r, rt1, rt2, s, safmax, safmin, ssfmax, &
                     ssfmin, tst
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or. ( icompz>0 .and. ldz<max( 1,n ) ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEQR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz==2 )z( 1, 1 ) = one
              return
           end if
           ! determine the unit roundoff and over/underflow thresholds.
           eps = stdlib_dlamch( 'E' )
           eps2 = eps**2
           safmin = stdlib_dlamch( 'S' )
           safmax = one / safmin
           ssfmax = sqrt( safmax ) / three
           ssfmin = sqrt( safmin ) / eps2
           ! compute the eigenvalues and eigenvectors of the tridiagonal
           ! matrix.
           if( icompz==2 )call stdlib_dlaset( 'FULL', n, n, zero, one, z, ldz )
           nmaxit = n*maxit
           jtot = 0
           ! determine where the matrix splits and choose ql or qr iteration
           ! for each block, according to whether top or bottom diagonal
           ! element is smaller.
           l1 = 1
           nm1 = n - 1
           10 continue
           if( l1>n )go to 160
           if( l1>1 )e( l1-1 ) = zero
           if( l1<=nm1 ) then
              do m = l1, nm1
                 tst = abs( e( m ) )
                 if( tst==zero )go to 30
                 if( tst<=( sqrt( abs( d( m ) ) )*sqrt( abs( d( m+1 ) ) ) )*eps ) then
                    e( m ) = zero
                    go to 30
                 end if
              end do
           end if
           m = n
           30 continue
           l = l1
           lsv = l
           lend = m
           lendsv = lend
           l1 = m + 1
           if( lend==l )go to 10
           ! scale submatrix in rows and columns l to lend
           anorm = stdlib_dlanst( 'M', lend-l+1, d( l ), e( l ) )
           iscale = 0
           if( anorm==zero )go to 10
           if( anorm>ssfmax ) then
              iscale = 1
              call stdlib_dlascl( 'G', 0, 0, anorm, ssfmax, lend-l+1, 1, d( l ), n,info )
              call stdlib_dlascl( 'G', 0, 0, anorm, ssfmax, lend-l, 1, e( l ), n,info )
           else if( anorm<ssfmin ) then
              iscale = 2
              call stdlib_dlascl( 'G', 0, 0, anorm, ssfmin, lend-l+1, 1, d( l ), n,info )
              call stdlib_dlascl( 'G', 0, 0, anorm, ssfmin, lend-l, 1, e( l ), n,info )
           end if
           ! choose between ql and qr iteration
           if( abs( d( lend ) )<abs( d( l ) ) ) then
              lend = lsv
              l = lendsv
           end if
           if( lend>l ) then
              ! ql iteration
              ! look for small subdiagonal element.
              40 continue
              if( l/=lend ) then
                 lendm1 = lend - 1
                 do m = l, lendm1
                    tst = abs( e( m ) )**2
                    if( tst<=( eps2*abs( d( m ) ) )*abs( d( m+1 ) )+safmin )go to 60
                 end do
              end if
              m = lend
              60 continue
              if( m<lend )e( m ) = zero
              p = d( l )
              if( m==l )go to 80
              ! if remaining matrix is 2-by-2, use stdlib_dlae2 or stdlib_slaev2
              ! to compute its eigensystem.
              if( m==l+1 ) then
                 if( icompz>0 ) then
                    call stdlib_dlaev2( d( l ), e( l ), d( l+1 ), rt1, rt2, c, s )
                    work( l ) = c
                    work( n-1+l ) = s
                    call stdlib_dlasr( 'R', 'V', 'B', n, 2, work( l ),work( n-1+l ), z( 1, l ), &
                              ldz )
                 else
                    call stdlib_dlae2( d( l ), e( l ), d( l+1 ), rt1, rt2 )
                 end if
                 d( l ) = rt1
                 d( l+1 ) = rt2
                 e( l ) = zero
                 l = l + 2
                 if( l<=lend )go to 40
                 go to 140
              end if
              if( jtot==nmaxit )go to 140
              jtot = jtot + 1
              ! form shift.
              g = ( d( l+1 )-p ) / ( two*e( l ) )
              r = stdlib_dlapy2( g, one )
              g = d( m ) - p + ( e( l ) / ( g+sign( r, g ) ) )
              s = one
              c = one
              p = zero
              ! inner loop
              mm1 = m - 1
              do i = mm1, l, -1
                 f = s*e( i )
                 b = c*e( i )
                 call stdlib_dlartg( g, f, c, s, r )
                 if( i/=m-1 )e( i+1 ) = r
                 g = d( i+1 ) - p
                 r = ( d( i )-g )*s + two*c*b
                 p = s*r
                 d( i+1 ) = g + p
                 g = c*r - b
                 ! if eigenvectors are desired, then save rotations.
                 if( icompz>0 ) then
                    work( i ) = c
                    work( n-1+i ) = -s
                 end if
              end do
              ! if eigenvectors are desired, then apply saved rotations.
              if( icompz>0 ) then
                 mm = m - l + 1
                 call stdlib_dlasr( 'R', 'V', 'B', n, mm, work( l ), work( n-1+l ),z( 1, l ), ldz &
                           )
              end if
              d( l ) = d( l ) - p
              e( l ) = g
              go to 40
              ! eigenvalue found.
              80 continue
              d( l ) = p
              l = l + 1
              if( l<=lend )go to 40
              go to 140
           else
              ! qr iteration
              ! look for small superdiagonal element.
              90 continue
              if( l/=lend ) then
                 lendp1 = lend + 1
                 do m = l, lendp1, -1
                    tst = abs( e( m-1 ) )**2
                    if( tst<=( eps2*abs( d( m ) ) )*abs( d( m-1 ) )+safmin )go to 110
                 end do
              end if
              m = lend
              110 continue
              if( m>lend )e( m-1 ) = zero
              p = d( l )
              if( m==l )go to 130
              ! if remaining matrix is 2-by-2, use stdlib_dlae2 or stdlib_slaev2
              ! to compute its eigensystem.
              if( m==l-1 ) then
                 if( icompz>0 ) then
                    call stdlib_dlaev2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2, c, s )
                    work( m ) = c
                    work( n-1+m ) = s
                    call stdlib_dlasr( 'R', 'V', 'F', n, 2, work( m ),work( n-1+m ), z( 1, l-1 ), &
                              ldz )
                 else
                    call stdlib_dlae2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2 )
                 end if
                 d( l-1 ) = rt1
                 d( l ) = rt2
                 e( l-1 ) = zero
                 l = l - 2
                 if( l>=lend )go to 90
                 go to 140
              end if
              if( jtot==nmaxit )go to 140
              jtot = jtot + 1
              ! form shift.
              g = ( d( l-1 )-p ) / ( two*e( l-1 ) )
              r = stdlib_dlapy2( g, one )
              g = d( m ) - p + ( e( l-1 ) / ( g+sign( r, g ) ) )
              s = one
              c = one
              p = zero
              ! inner loop
              lm1 = l - 1
              do i = m, lm1
                 f = s*e( i )
                 b = c*e( i )
                 call stdlib_dlartg( g, f, c, s, r )
                 if( i/=m )e( i-1 ) = r
                 g = d( i ) - p
                 r = ( d( i+1 )-g )*s + two*c*b
                 p = s*r
                 d( i ) = g + p
                 g = c*r - b
                 ! if eigenvectors are desired, then save rotations.
                 if( icompz>0 ) then
                    work( i ) = c
                    work( n-1+i ) = s
                 end if
              end do
              ! if eigenvectors are desired, then apply saved rotations.
              if( icompz>0 ) then
                 mm = l - m + 1
                 call stdlib_dlasr( 'R', 'V', 'F', n, mm, work( m ), work( n-1+m ),z( 1, m ), ldz &
                           )
              end if
              d( l ) = d( l ) - p
              e( lm1 ) = g
              go to 90
              ! eigenvalue found.
              130 continue
              d( l ) = p
              l = l - 1
              if( l>=lend )go to 90
              go to 140
           end if
           ! undo scaling if necessary
           140 continue
           if( iscale==1 ) then
              call stdlib_dlascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv+1, 1,d( lsv ), n, info )
                        
              call stdlib_dlascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv, 1, e( lsv ),n, info )
                        
           else if( iscale==2 ) then
              call stdlib_dlascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv+1, 1,d( lsv ), n, info )
                        
              call stdlib_dlascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv, 1, e( lsv ),n, info )
                        
           end if
           ! check for no convergence to an eigenvalue after a total
           ! of n*maxit iterations.
           if( jtot<nmaxit )go to 10
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           go to 190
           ! order eigenvalues and eigenvectors.
           160 continue
           if( icompz==0 ) then
              ! use quick sort
              call stdlib_dlasrt( 'I', n, d, info )
           else
              ! use selection sort to minimize swaps of eigenvectors
              do ii = 2, n
                 i = ii - 1
                 k = i
                 p = d( i )
                 do j = ii, n
                    if( d( j )<p ) then
                       k = j
                       p = d( j )
                    end if
                 end do
                 if( k/=i ) then
                    d( k ) = d( i )
                    d( i ) = p
                    call stdlib_dswap( n, z( 1, i ), 1, z( 1, k ), 1 )
                 end if
              end do
           end if
           190 continue
           return
     end subroutine stdlib_dsteqr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$steqr( compz, n, d, e, z, ldz, work, info )
     !! DSTEQR: computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric tridiagonal matrix using the implicit QL or QR method.
     !! The eigenvectors of a full or band symmetric matrix can also be found
     !! if DSYTRD or DSPTRD or DSBTRD has been used to reduce this matrix to
     !! tridiagonal form.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: d(*), e(*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 30
           
           
           ! Local Scalars 
           integer(ilp) :: i, icompz, ii, iscale, j, jtot, k, l, l1, lend, lendm1, lendp1, lendsv,&
                      lm1, lsv, m, mm, mm1, nm1, nmaxit
           real(${rk}$) :: anorm, b, c, eps, eps2, f, g, p, r, rt1, rt2, s, safmax, safmin, ssfmax, &
                     ssfmin, tst
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or. ( icompz>0 .and. ldz<max( 1,n ) ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEQR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz==2 )z( 1, 1 ) = one
              return
           end if
           ! determine the unit roundoff and over/underflow thresholds.
           eps = stdlib_${ri}$lamch( 'E' )
           eps2 = eps**2
           safmin = stdlib_${ri}$lamch( 'S' )
           safmax = one / safmin
           ssfmax = sqrt( safmax ) / three
           ssfmin = sqrt( safmin ) / eps2
           ! compute the eigenvalues and eigenvectors of the tridiagonal
           ! matrix.
           if( icompz==2 )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, z, ldz )
           nmaxit = n*maxit
           jtot = 0
           ! determine where the matrix splits and choose ql or qr iteration
           ! for each block, according to whether top or bottom diagonal
           ! element is smaller.
           l1 = 1
           nm1 = n - 1
           10 continue
           if( l1>n )go to 160
           if( l1>1 )e( l1-1 ) = zero
           if( l1<=nm1 ) then
              do m = l1, nm1
                 tst = abs( e( m ) )
                 if( tst==zero )go to 30
                 if( tst<=( sqrt( abs( d( m ) ) )*sqrt( abs( d( m+1 ) ) ) )*eps ) then
                    e( m ) = zero
                    go to 30
                 end if
              end do
           end if
           m = n
           30 continue
           l = l1
           lsv = l
           lend = m
           lendsv = lend
           l1 = m + 1
           if( lend==l )go to 10
           ! scale submatrix in rows and columns l to lend
           anorm = stdlib_${ri}$lanst( 'M', lend-l+1, d( l ), e( l ) )
           iscale = 0
           if( anorm==zero )go to 10
           if( anorm>ssfmax ) then
              iscale = 1
              call stdlib_${ri}$lascl( 'G', 0, 0, anorm, ssfmax, lend-l+1, 1, d( l ), n,info )
              call stdlib_${ri}$lascl( 'G', 0, 0, anorm, ssfmax, lend-l, 1, e( l ), n,info )
           else if( anorm<ssfmin ) then
              iscale = 2
              call stdlib_${ri}$lascl( 'G', 0, 0, anorm, ssfmin, lend-l+1, 1, d( l ), n,info )
              call stdlib_${ri}$lascl( 'G', 0, 0, anorm, ssfmin, lend-l, 1, e( l ), n,info )
           end if
           ! choose between ql and qr iteration
           if( abs( d( lend ) )<abs( d( l ) ) ) then
              lend = lsv
              l = lendsv
           end if
           if( lend>l ) then
              ! ql iteration
              ! look for small subdiagonal element.
              40 continue
              if( l/=lend ) then
                 lendm1 = lend - 1
                 do m = l, lendm1
                    tst = abs( e( m ) )**2
                    if( tst<=( eps2*abs( d( m ) ) )*abs( d( m+1 ) )+safmin )go to 60
                 end do
              end if
              m = lend
              60 continue
              if( m<lend )e( m ) = zero
              p = d( l )
              if( m==l )go to 80
              ! if remaining matrix is 2-by-2, use stdlib_${ri}$lae2 or stdlib_dlaev2
              ! to compute its eigensystem.
              if( m==l+1 ) then
                 if( icompz>0 ) then
                    call stdlib_${ri}$laev2( d( l ), e( l ), d( l+1 ), rt1, rt2, c, s )
                    work( l ) = c
                    work( n-1+l ) = s
                    call stdlib_${ri}$lasr( 'R', 'V', 'B', n, 2, work( l ),work( n-1+l ), z( 1, l ), &
                              ldz )
                 else
                    call stdlib_${ri}$lae2( d( l ), e( l ), d( l+1 ), rt1, rt2 )
                 end if
                 d( l ) = rt1
                 d( l+1 ) = rt2
                 e( l ) = zero
                 l = l + 2
                 if( l<=lend )go to 40
                 go to 140
              end if
              if( jtot==nmaxit )go to 140
              jtot = jtot + 1
              ! form shift.
              g = ( d( l+1 )-p ) / ( two*e( l ) )
              r = stdlib_${ri}$lapy2( g, one )
              g = d( m ) - p + ( e( l ) / ( g+sign( r, g ) ) )
              s = one
              c = one
              p = zero
              ! inner loop
              mm1 = m - 1
              do i = mm1, l, -1
                 f = s*e( i )
                 b = c*e( i )
                 call stdlib_${ri}$lartg( g, f, c, s, r )
                 if( i/=m-1 )e( i+1 ) = r
                 g = d( i+1 ) - p
                 r = ( d( i )-g )*s + two*c*b
                 p = s*r
                 d( i+1 ) = g + p
                 g = c*r - b
                 ! if eigenvectors are desired, then save rotations.
                 if( icompz>0 ) then
                    work( i ) = c
                    work( n-1+i ) = -s
                 end if
              end do
              ! if eigenvectors are desired, then apply saved rotations.
              if( icompz>0 ) then
                 mm = m - l + 1
                 call stdlib_${ri}$lasr( 'R', 'V', 'B', n, mm, work( l ), work( n-1+l ),z( 1, l ), ldz &
                           )
              end if
              d( l ) = d( l ) - p
              e( l ) = g
              go to 40
              ! eigenvalue found.
              80 continue
              d( l ) = p
              l = l + 1
              if( l<=lend )go to 40
              go to 140
           else
              ! qr iteration
              ! look for small superdiagonal element.
              90 continue
              if( l/=lend ) then
                 lendp1 = lend + 1
                 do m = l, lendp1, -1
                    tst = abs( e( m-1 ) )**2
                    if( tst<=( eps2*abs( d( m ) ) )*abs( d( m-1 ) )+safmin )go to 110
                 end do
              end if
              m = lend
              110 continue
              if( m>lend )e( m-1 ) = zero
              p = d( l )
              if( m==l )go to 130
              ! if remaining matrix is 2-by-2, use stdlib_${ri}$lae2 or stdlib_dlaev2
              ! to compute its eigensystem.
              if( m==l-1 ) then
                 if( icompz>0 ) then
                    call stdlib_${ri}$laev2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2, c, s )
                    work( m ) = c
                    work( n-1+m ) = s
                    call stdlib_${ri}$lasr( 'R', 'V', 'F', n, 2, work( m ),work( n-1+m ), z( 1, l-1 ), &
                              ldz )
                 else
                    call stdlib_${ri}$lae2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2 )
                 end if
                 d( l-1 ) = rt1
                 d( l ) = rt2
                 e( l-1 ) = zero
                 l = l - 2
                 if( l>=lend )go to 90
                 go to 140
              end if
              if( jtot==nmaxit )go to 140
              jtot = jtot + 1
              ! form shift.
              g = ( d( l-1 )-p ) / ( two*e( l-1 ) )
              r = stdlib_${ri}$lapy2( g, one )
              g = d( m ) - p + ( e( l-1 ) / ( g+sign( r, g ) ) )
              s = one
              c = one
              p = zero
              ! inner loop
              lm1 = l - 1
              do i = m, lm1
                 f = s*e( i )
                 b = c*e( i )
                 call stdlib_${ri}$lartg( g, f, c, s, r )
                 if( i/=m )e( i-1 ) = r
                 g = d( i ) - p
                 r = ( d( i+1 )-g )*s + two*c*b
                 p = s*r
                 d( i ) = g + p
                 g = c*r - b
                 ! if eigenvectors are desired, then save rotations.
                 if( icompz>0 ) then
                    work( i ) = c
                    work( n-1+i ) = s
                 end if
              end do
              ! if eigenvectors are desired, then apply saved rotations.
              if( icompz>0 ) then
                 mm = l - m + 1
                 call stdlib_${ri}$lasr( 'R', 'V', 'F', n, mm, work( m ), work( n-1+m ),z( 1, m ), ldz &
                           )
              end if
              d( l ) = d( l ) - p
              e( lm1 ) = g
              go to 90
              ! eigenvalue found.
              130 continue
              d( l ) = p
              l = l - 1
              if( l>=lend )go to 90
              go to 140
           end if
           ! undo scaling if necessary
           140 continue
           if( iscale==1 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv+1, 1,d( lsv ), n, info )
                        
              call stdlib_${ri}$lascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv, 1, e( lsv ),n, info )
                        
           else if( iscale==2 ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv+1, 1,d( lsv ), n, info )
                        
              call stdlib_${ri}$lascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv, 1, e( lsv ),n, info )
                        
           end if
           ! check for no convergence to an eigenvalue after a total
           ! of n*maxit iterations.
           if( jtot<nmaxit )go to 10
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           go to 190
           ! order eigenvalues and eigenvectors.
           160 continue
           if( icompz==0 ) then
              ! use quick sort
              call stdlib_${ri}$lasrt( 'I', n, d, info )
           else
              ! use selection sort to minimize swaps of eigenvectors
              do ii = 2, n
                 i = ii - 1
                 k = i
                 p = d( i )
                 do j = ii, n
                    if( d( j )<p ) then
                       k = j
                       p = d( j )
                    end if
                 end do
                 if( k/=i ) then
                    d( k ) = d( i )
                    d( i ) = p
                    call stdlib_${ri}$swap( n, z( 1, i ), 1, z( 1, k ), 1 )
                 end if
              end do
           end if
           190 continue
           return
     end subroutine stdlib_${ri}$steqr

#:endif
#:endfor

     pure subroutine stdlib_csteqr( compz, n, d, e, z, ldz, work, info )
     !! CSTEQR computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric tridiagonal matrix using the implicit QL or QR method.
     !! The eigenvectors of a full or band complex Hermitian matrix can also
     !! be found if CHETRD or CHPTRD or CHBTRD has been used to reduce this
     !! matrix to tridiagonal form.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 30
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, icompz, ii, iscale, j, jtot, k, l, l1, lend, lendm1, lendp1, lendsv,&
                      lm1, lsv, m, mm, mm1, nm1, nmaxit
           real(sp) :: anorm, b, c, eps, eps2, f, g, p, r, rt1, rt2, s, safmax, safmin, ssfmax, &
                     ssfmin, tst
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or. ( icompz>0 .and. ldz<max( 1,n ) ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSTEQR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz==2 )z( 1, 1 ) = cone
              return
           end if
           ! determine the unit roundoff and over/underflow thresholds.
           eps = stdlib_slamch( 'E' )
           eps2 = eps**2
           safmin = stdlib_slamch( 'S' )
           safmax = one / safmin
           ssfmax = sqrt( safmax ) / three
           ssfmin = sqrt( safmin ) / eps2
           ! compute the eigenvalues and eigenvectors of the tridiagonal
           ! matrix.
           if( icompz==2 )call stdlib_claset( 'FULL', n, n, czero, cone, z, ldz )
           nmaxit = n*maxit
           jtot = 0
           ! determine where the matrix splits and choose ql or qr iteration
           ! for each block, according to whether top or bottom diagonal
           ! element is smaller.
           l1 = 1
           nm1 = n - 1
           10 continue
           if( l1>n )go to 160
           if( l1>1 )e( l1-1 ) = zero
           if( l1<=nm1 ) then
              do m = l1, nm1
                 tst = abs( e( m ) )
                 if( tst==zero )go to 30
                 if( tst<=( sqrt( abs( d( m ) ) )*sqrt( abs( d( m+1 ) ) ) )*eps ) then
                    e( m ) = zero
                    go to 30
                 end if
              end do
           end if
           m = n
           30 continue
           l = l1
           lsv = l
           lend = m
           lendsv = lend
           l1 = m + 1
           if( lend==l )go to 10
           ! scale submatrix in rows and columns l to lend
           anorm = stdlib_slanst( 'I', lend-l+1, d( l ), e( l ) )
           iscale = 0
           if( anorm==zero )go to 10
           if( anorm>ssfmax ) then
              iscale = 1
              call stdlib_slascl( 'G', 0, 0, anorm, ssfmax, lend-l+1, 1, d( l ), n,info )
              call stdlib_slascl( 'G', 0, 0, anorm, ssfmax, lend-l, 1, e( l ), n,info )
           else if( anorm<ssfmin ) then
              iscale = 2
              call stdlib_slascl( 'G', 0, 0, anorm, ssfmin, lend-l+1, 1, d( l ), n,info )
              call stdlib_slascl( 'G', 0, 0, anorm, ssfmin, lend-l, 1, e( l ), n,info )
           end if
           ! choose between ql and qr iteration
           if( abs( d( lend ) )<abs( d( l ) ) ) then
              lend = lsv
              l = lendsv
           end if
           if( lend>l ) then
              ! ql iteration
              ! look for small subdiagonal element.
              40 continue
              if( l/=lend ) then
                 lendm1 = lend - 1
                 do m = l, lendm1
                    tst = abs( e( m ) )**2
                    if( tst<=( eps2*abs( d( m ) ) )*abs( d( m+1 ) )+safmin )go to 60
                 end do
              end if
              m = lend
              60 continue
              if( m<lend )e( m ) = zero
              p = d( l )
              if( m==l )go to 80
              ! if remaining matrix is 2-by-2, use stdlib_slae2 or stdlib_slaev2
              ! to compute its eigensystem.
              if( m==l+1 ) then
                 if( icompz>0 ) then
                    call stdlib_slaev2( d( l ), e( l ), d( l+1 ), rt1, rt2, c, s )
                    work( l ) = c
                    work( n-1+l ) = s
                    call stdlib_clasr( 'R', 'V', 'B', n, 2, work( l ),work( n-1+l ), z( 1, l ), &
                              ldz )
                 else
                    call stdlib_slae2( d( l ), e( l ), d( l+1 ), rt1, rt2 )
                 end if
                 d( l ) = rt1
                 d( l+1 ) = rt2
                 e( l ) = zero
                 l = l + 2
                 if( l<=lend )go to 40
                 go to 140
              end if
              if( jtot==nmaxit )go to 140
              jtot = jtot + 1
              ! form shift.
              g = ( d( l+1 )-p ) / ( two*e( l ) )
              r = stdlib_slapy2( g, one )
              g = d( m ) - p + ( e( l ) / ( g+sign( r, g ) ) )
              s = one
              c = one
              p = zero
              ! inner loop
              mm1 = m - 1
              do i = mm1, l, -1
                 f = s*e( i )
                 b = c*e( i )
                 call stdlib_slartg( g, f, c, s, r )
                 if( i/=m-1 )e( i+1 ) = r
                 g = d( i+1 ) - p
                 r = ( d( i )-g )*s + two*c*b
                 p = s*r
                 d( i+1 ) = g + p
                 g = c*r - b
                 ! if eigenvectors are desired, then save rotations.
                 if( icompz>0 ) then
                    work( i ) = c
                    work( n-1+i ) = -s
                 end if
              end do
              ! if eigenvectors are desired, then apply saved rotations.
              if( icompz>0 ) then
                 mm = m - l + 1
                 call stdlib_clasr( 'R', 'V', 'B', n, mm, work( l ), work( n-1+l ),z( 1, l ), ldz &
                           )
              end if
              d( l ) = d( l ) - p
              e( l ) = g
              go to 40
              ! eigenvalue found.
              80 continue
              d( l ) = p
              l = l + 1
              if( l<=lend )go to 40
              go to 140
           else
              ! qr iteration
              ! look for small superdiagonal element.
              90 continue
              if( l/=lend ) then
                 lendp1 = lend + 1
                 do m = l, lendp1, -1
                    tst = abs( e( m-1 ) )**2
                    if( tst<=( eps2*abs( d( m ) ) )*abs( d( m-1 ) )+safmin )go to 110
                 end do
              end if
              m = lend
              110 continue
              if( m>lend )e( m-1 ) = zero
              p = d( l )
              if( m==l )go to 130
              ! if remaining matrix is 2-by-2, use stdlib_slae2 or stdlib_slaev2
              ! to compute its eigensystem.
              if( m==l-1 ) then
                 if( icompz>0 ) then
                    call stdlib_slaev2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2, c, s )
                    work( m ) = c
                    work( n-1+m ) = s
                    call stdlib_clasr( 'R', 'V', 'F', n, 2, work( m ),work( n-1+m ), z( 1, l-1 ), &
                              ldz )
                 else
                    call stdlib_slae2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2 )
                 end if
                 d( l-1 ) = rt1
                 d( l ) = rt2
                 e( l-1 ) = zero
                 l = l - 2
                 if( l>=lend )go to 90
                 go to 140
              end if
              if( jtot==nmaxit )go to 140
              jtot = jtot + 1
              ! form shift.
              g = ( d( l-1 )-p ) / ( two*e( l-1 ) )
              r = stdlib_slapy2( g, one )
              g = d( m ) - p + ( e( l-1 ) / ( g+sign( r, g ) ) )
              s = one
              c = one
              p = zero
              ! inner loop
              lm1 = l - 1
              do i = m, lm1
                 f = s*e( i )
                 b = c*e( i )
                 call stdlib_slartg( g, f, c, s, r )
                 if( i/=m )e( i-1 ) = r
                 g = d( i ) - p
                 r = ( d( i+1 )-g )*s + two*c*b
                 p = s*r
                 d( i ) = g + p
                 g = c*r - b
                 ! if eigenvectors are desired, then save rotations.
                 if( icompz>0 ) then
                    work( i ) = c
                    work( n-1+i ) = s
                 end if
              end do
              ! if eigenvectors are desired, then apply saved rotations.
              if( icompz>0 ) then
                 mm = l - m + 1
                 call stdlib_clasr( 'R', 'V', 'F', n, mm, work( m ), work( n-1+m ),z( 1, m ), ldz &
                           )
              end if
              d( l ) = d( l ) - p
              e( lm1 ) = g
              go to 90
              ! eigenvalue found.
              130 continue
              d( l ) = p
              l = l - 1
              if( l>=lend )go to 90
              go to 140
           end if
           ! undo scaling if necessary
           140 continue
           if( iscale==1 ) then
              call stdlib_slascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv+1, 1,d( lsv ), n, info )
                        
              call stdlib_slascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv, 1, e( lsv ),n, info )
                        
           else if( iscale==2 ) then
              call stdlib_slascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv+1, 1,d( lsv ), n, info )
                        
              call stdlib_slascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv, 1, e( lsv ),n, info )
                        
           end if
           ! check for no convergence to an eigenvalue after a total
           ! of n*maxit iterations.
           if( jtot==nmaxit ) then
              do i = 1, n - 1
                 if( e( i )/=zero )info = info + 1
              end do
              return
           end if
           go to 10
           ! order eigenvalues and eigenvectors.
           160 continue
           if( icompz==0 ) then
              ! use quick sort
              call stdlib_slasrt( 'I', n, d, info )
           else
              ! use selection sort to minimize swaps of eigenvectors
              do ii = 2, n
                 i = ii - 1
                 k = i
                 p = d( i )
                 do j = ii, n
                    if( d( j )<p ) then
                       k = j
                       p = d( j )
                    end if
                 end do
                 if( k/=i ) then
                    d( k ) = d( i )
                    d( i ) = p
                    call stdlib_cswap( n, z( 1, i ), 1, z( 1, k ), 1 )
                 end if
              end do
           end if
           return
     end subroutine stdlib_csteqr

     pure subroutine stdlib_zsteqr( compz, n, d, e, z, ldz, work, info )
     !! ZSTEQR computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric tridiagonal matrix using the implicit QL or QR method.
     !! The eigenvectors of a full or band complex Hermitian matrix can also
     !! be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this
     !! matrix to tridiagonal form.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: work(*)
           complex(dp), intent(inout) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 30
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, icompz, ii, iscale, j, jtot, k, l, l1, lend, lendm1, lendp1, lendsv,&
                      lm1, lsv, m, mm, mm1, nm1, nmaxit
           real(dp) :: anorm, b, c, eps, eps2, f, g, p, r, rt1, rt2, s, safmax, safmin, ssfmax, &
                     ssfmin, tst
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or. ( icompz>0 .and. ldz<max( 1,n ) ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSTEQR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz==2 )z( 1, 1 ) = cone
              return
           end if
           ! determine the unit roundoff and over/underflow thresholds.
           eps = stdlib_dlamch( 'E' )
           eps2 = eps**2
           safmin = stdlib_dlamch( 'S' )
           safmax = one / safmin
           ssfmax = sqrt( safmax ) / three
           ssfmin = sqrt( safmin ) / eps2
           ! compute the eigenvalues and eigenvectors of the tridiagonal
           ! matrix.
           if( icompz==2 )call stdlib_zlaset( 'FULL', n, n, czero, cone, z, ldz )
           nmaxit = n*maxit
           jtot = 0
           ! determine where the matrix splits and choose ql or qr iteration
           ! for each block, according to whether top or bottom diagonal
           ! element is smaller.
           l1 = 1
           nm1 = n - 1
           10 continue
           if( l1>n )go to 160
           if( l1>1 )e( l1-1 ) = zero
           if( l1<=nm1 ) then
              do m = l1, nm1
                 tst = abs( e( m ) )
                 if( tst==zero )go to 30
                 if( tst<=( sqrt( abs( d( m ) ) )*sqrt( abs( d( m+1 ) ) ) )*eps ) then
                    e( m ) = zero
                    go to 30
                 end if
              end do
           end if
           m = n
           30 continue
           l = l1
           lsv = l
           lend = m
           lendsv = lend
           l1 = m + 1
           if( lend==l )go to 10
           ! scale submatrix in rows and columns l to lend
           anorm = stdlib_dlanst( 'I', lend-l+1, d( l ), e( l ) )
           iscale = 0
           if( anorm==zero )go to 10
           if( anorm>ssfmax ) then
              iscale = 1
              call stdlib_dlascl( 'G', 0, 0, anorm, ssfmax, lend-l+1, 1, d( l ), n,info )
              call stdlib_dlascl( 'G', 0, 0, anorm, ssfmax, lend-l, 1, e( l ), n,info )
           else if( anorm<ssfmin ) then
              iscale = 2
              call stdlib_dlascl( 'G', 0, 0, anorm, ssfmin, lend-l+1, 1, d( l ), n,info )
              call stdlib_dlascl( 'G', 0, 0, anorm, ssfmin, lend-l, 1, e( l ), n,info )
           end if
           ! choose between ql and qr iteration
           if( abs( d( lend ) )<abs( d( l ) ) ) then
              lend = lsv
              l = lendsv
           end if
           if( lend>l ) then
              ! ql iteration
              ! look for small subdiagonal element.
              40 continue
              if( l/=lend ) then
                 lendm1 = lend - 1
                 do m = l, lendm1
                    tst = abs( e( m ) )**2
                    if( tst<=( eps2*abs( d( m ) ) )*abs( d( m+1 ) )+safmin )go to 60
                 end do
              end if
              m = lend
              60 continue
              if( m<lend )e( m ) = zero
              p = d( l )
              if( m==l )go to 80
              ! if remaining matrix is 2-by-2, use stdlib_dlae2 or stdlib_slaev2
              ! to compute its eigensystem.
              if( m==l+1 ) then
                 if( icompz>0 ) then
                    call stdlib_dlaev2( d( l ), e( l ), d( l+1 ), rt1, rt2, c, s )
                    work( l ) = c
                    work( n-1+l ) = s
                    call stdlib_zlasr( 'R', 'V', 'B', n, 2, work( l ),work( n-1+l ), z( 1, l ), &
                              ldz )
                 else
                    call stdlib_dlae2( d( l ), e( l ), d( l+1 ), rt1, rt2 )
                 end if
                 d( l ) = rt1
                 d( l+1 ) = rt2
                 e( l ) = zero
                 l = l + 2
                 if( l<=lend )go to 40
                 go to 140
              end if
              if( jtot==nmaxit )go to 140
              jtot = jtot + 1
              ! form shift.
              g = ( d( l+1 )-p ) / ( two*e( l ) )
              r = stdlib_dlapy2( g, one )
              g = d( m ) - p + ( e( l ) / ( g+sign( r, g ) ) )
              s = one
              c = one
              p = zero
              ! inner loop
              mm1 = m - 1
              do i = mm1, l, -1
                 f = s*e( i )
                 b = c*e( i )
                 call stdlib_dlartg( g, f, c, s, r )
                 if( i/=m-1 )e( i+1 ) = r
                 g = d( i+1 ) - p
                 r = ( d( i )-g )*s + two*c*b
                 p = s*r
                 d( i+1 ) = g + p
                 g = c*r - b
                 ! if eigenvectors are desired, then save rotations.
                 if( icompz>0 ) then
                    work( i ) = c
                    work( n-1+i ) = -s
                 end if
              end do
              ! if eigenvectors are desired, then apply saved rotations.
              if( icompz>0 ) then
                 mm = m - l + 1
                 call stdlib_zlasr( 'R', 'V', 'B', n, mm, work( l ), work( n-1+l ),z( 1, l ), ldz &
                           )
              end if
              d( l ) = d( l ) - p
              e( l ) = g
              go to 40
              ! eigenvalue found.
              80 continue
              d( l ) = p
              l = l + 1
              if( l<=lend )go to 40
              go to 140
           else
              ! qr iteration
              ! look for small superdiagonal element.
              90 continue
              if( l/=lend ) then
                 lendp1 = lend + 1
                 do m = l, lendp1, -1
                    tst = abs( e( m-1 ) )**2
                    if( tst<=( eps2*abs( d( m ) ) )*abs( d( m-1 ) )+safmin )go to 110
                 end do
              end if
              m = lend
              110 continue
              if( m>lend )e( m-1 ) = zero
              p = d( l )
              if( m==l )go to 130
              ! if remaining matrix is 2-by-2, use stdlib_dlae2 or stdlib_slaev2
              ! to compute its eigensystem.
              if( m==l-1 ) then
                 if( icompz>0 ) then
                    call stdlib_dlaev2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2, c, s )
                    work( m ) = c
                    work( n-1+m ) = s
                    call stdlib_zlasr( 'R', 'V', 'F', n, 2, work( m ),work( n-1+m ), z( 1, l-1 ), &
                              ldz )
                 else
                    call stdlib_dlae2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2 )
                 end if
                 d( l-1 ) = rt1
                 d( l ) = rt2
                 e( l-1 ) = zero
                 l = l - 2
                 if( l>=lend )go to 90
                 go to 140
              end if
              if( jtot==nmaxit )go to 140
              jtot = jtot + 1
              ! form shift.
              g = ( d( l-1 )-p ) / ( two*e( l-1 ) )
              r = stdlib_dlapy2( g, one )
              g = d( m ) - p + ( e( l-1 ) / ( g+sign( r, g ) ) )
              s = one
              c = one
              p = zero
              ! inner loop
              lm1 = l - 1
              do i = m, lm1
                 f = s*e( i )
                 b = c*e( i )
                 call stdlib_dlartg( g, f, c, s, r )
                 if( i/=m )e( i-1 ) = r
                 g = d( i ) - p
                 r = ( d( i+1 )-g )*s + two*c*b
                 p = s*r
                 d( i ) = g + p
                 g = c*r - b
                 ! if eigenvectors are desired, then save rotations.
                 if( icompz>0 ) then
                    work( i ) = c
                    work( n-1+i ) = s
                 end if
              end do
              ! if eigenvectors are desired, then apply saved rotations.
              if( icompz>0 ) then
                 mm = l - m + 1
                 call stdlib_zlasr( 'R', 'V', 'F', n, mm, work( m ), work( n-1+m ),z( 1, m ), ldz &
                           )
              end if
              d( l ) = d( l ) - p
              e( lm1 ) = g
              go to 90
              ! eigenvalue found.
              130 continue
              d( l ) = p
              l = l - 1
              if( l>=lend )go to 90
              go to 140
           end if
           ! undo scaling if necessary
           140 continue
           if( iscale==1 ) then
              call stdlib_dlascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv+1, 1,d( lsv ), n, info )
                        
              call stdlib_dlascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv, 1, e( lsv ),n, info )
                        
           else if( iscale==2 ) then
              call stdlib_dlascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv+1, 1,d( lsv ), n, info )
                        
              call stdlib_dlascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv, 1, e( lsv ),n, info )
                        
           end if
           ! check for no convergence to an eigenvalue after a total
           ! of n*maxit iterations.
           if( jtot==nmaxit ) then
              do i = 1, n - 1
                 if( e( i )/=zero )info = info + 1
              end do
              return
           end if
           go to 10
           ! order eigenvalues and eigenvectors.
           160 continue
           if( icompz==0 ) then
              ! use quick sort
              call stdlib_dlasrt( 'I', n, d, info )
           else
              ! use selection sort to minimize swaps of eigenvectors
              do ii = 2, n
                 i = ii - 1
                 k = i
                 p = d( i )
                 do j = ii, n
                    if( d( j )<p ) then
                       k = j
                       p = d( j )
                    end if
                 end do
                 if( k/=i ) then
                    d( k ) = d( i )
                    d( i ) = p
                    call stdlib_zswap( n, z( 1, i ), 1, z( 1, k ), 1 )
                 end if
              end do
           end if
           return
     end subroutine stdlib_zsteqr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$steqr( compz, n, d, e, z, ldz, work, info )
     !! ZSTEQR: computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric tridiagonal matrix using the implicit QL or QR method.
     !! The eigenvectors of a full or band complex Hermitian matrix can also
     !! be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this
     !! matrix to tridiagonal form.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(${ck}$), intent(inout) :: d(*), e(*)
           real(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(inout) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 30
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, icompz, ii, iscale, j, jtot, k, l, l1, lend, lendm1, lendp1, lendsv,&
                      lm1, lsv, m, mm, mm1, nm1, nmaxit
           real(${ck}$) :: anorm, b, c, eps, eps2, f, g, p, r, rt1, rt2, s, safmax, safmin, ssfmax, &
                     ssfmin, tst
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or. ( icompz>0 .and. ldz<max( 1,n ) ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSTEQR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz==2 )z( 1, 1 ) = cone
              return
           end if
           ! determine the unit roundoff and over/underflow thresholds.
           eps = stdlib_${c2ri(ci)}$lamch( 'E' )
           eps2 = eps**2
           safmin = stdlib_${c2ri(ci)}$lamch( 'S' )
           safmax = one / safmin
           ssfmax = sqrt( safmax ) / three
           ssfmin = sqrt( safmin ) / eps2
           ! compute the eigenvalues and eigenvectors of the tridiagonal
           ! matrix.
           if( icompz==2 )call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, z, ldz )
           nmaxit = n*maxit
           jtot = 0
           ! determine where the matrix splits and choose ql or qr iteration
           ! for each block, according to whether top or bottom diagonal
           ! element is smaller.
           l1 = 1
           nm1 = n - 1
           10 continue
           if( l1>n )go to 160
           if( l1>1 )e( l1-1 ) = zero
           if( l1<=nm1 ) then
              do m = l1, nm1
                 tst = abs( e( m ) )
                 if( tst==zero )go to 30
                 if( tst<=( sqrt( abs( d( m ) ) )*sqrt( abs( d( m+1 ) ) ) )*eps ) then
                    e( m ) = zero
                    go to 30
                 end if
              end do
           end if
           m = n
           30 continue
           l = l1
           lsv = l
           lend = m
           lendsv = lend
           l1 = m + 1
           if( lend==l )go to 10
           ! scale submatrix in rows and columns l to lend
           anorm = stdlib_${c2ri(ci)}$lanst( 'I', lend-l+1, d( l ), e( l ) )
           iscale = 0
           if( anorm==zero )go to 10
           if( anorm>ssfmax ) then
              iscale = 1
              call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, anorm, ssfmax, lend-l+1, 1, d( l ), n,info )
              call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, anorm, ssfmax, lend-l, 1, e( l ), n,info )
           else if( anorm<ssfmin ) then
              iscale = 2
              call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, anorm, ssfmin, lend-l+1, 1, d( l ), n,info )
              call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, anorm, ssfmin, lend-l, 1, e( l ), n,info )
           end if
           ! choose between ql and qr iteration
           if( abs( d( lend ) )<abs( d( l ) ) ) then
              lend = lsv
              l = lendsv
           end if
           if( lend>l ) then
              ! ql iteration
              ! look for small subdiagonal element.
              40 continue
              if( l/=lend ) then
                 lendm1 = lend - 1
                 do m = l, lendm1
                    tst = abs( e( m ) )**2
                    if( tst<=( eps2*abs( d( m ) ) )*abs( d( m+1 ) )+safmin )go to 60
                 end do
              end if
              m = lend
              60 continue
              if( m<lend )e( m ) = zero
              p = d( l )
              if( m==l )go to 80
              ! if remaining matrix is 2-by-2, use stdlib_${c2ri(ci)}$lae2 or stdlib_dlaev2
              ! to compute its eigensystem.
              if( m==l+1 ) then
                 if( icompz>0 ) then
                    call stdlib_${c2ri(ci)}$laev2( d( l ), e( l ), d( l+1 ), rt1, rt2, c, s )
                    work( l ) = c
                    work( n-1+l ) = s
                    call stdlib_${ci}$lasr( 'R', 'V', 'B', n, 2, work( l ),work( n-1+l ), z( 1, l ), &
                              ldz )
                 else
                    call stdlib_${c2ri(ci)}$lae2( d( l ), e( l ), d( l+1 ), rt1, rt2 )
                 end if
                 d( l ) = rt1
                 d( l+1 ) = rt2
                 e( l ) = zero
                 l = l + 2
                 if( l<=lend )go to 40
                 go to 140
              end if
              if( jtot==nmaxit )go to 140
              jtot = jtot + 1
              ! form shift.
              g = ( d( l+1 )-p ) / ( two*e( l ) )
              r = stdlib_${c2ri(ci)}$lapy2( g, one )
              g = d( m ) - p + ( e( l ) / ( g+sign( r, g ) ) )
              s = one
              c = one
              p = zero
              ! inner loop
              mm1 = m - 1
              do i = mm1, l, -1
                 f = s*e( i )
                 b = c*e( i )
                 call stdlib_${c2ri(ci)}$lartg( g, f, c, s, r )
                 if( i/=m-1 )e( i+1 ) = r
                 g = d( i+1 ) - p
                 r = ( d( i )-g )*s + two*c*b
                 p = s*r
                 d( i+1 ) = g + p
                 g = c*r - b
                 ! if eigenvectors are desired, then save rotations.
                 if( icompz>0 ) then
                    work( i ) = c
                    work( n-1+i ) = -s
                 end if
              end do
              ! if eigenvectors are desired, then apply saved rotations.
              if( icompz>0 ) then
                 mm = m - l + 1
                 call stdlib_${ci}$lasr( 'R', 'V', 'B', n, mm, work( l ), work( n-1+l ),z( 1, l ), ldz &
                           )
              end if
              d( l ) = d( l ) - p
              e( l ) = g
              go to 40
              ! eigenvalue found.
              80 continue
              d( l ) = p
              l = l + 1
              if( l<=lend )go to 40
              go to 140
           else
              ! qr iteration
              ! look for small superdiagonal element.
              90 continue
              if( l/=lend ) then
                 lendp1 = lend + 1
                 do m = l, lendp1, -1
                    tst = abs( e( m-1 ) )**2
                    if( tst<=( eps2*abs( d( m ) ) )*abs( d( m-1 ) )+safmin )go to 110
                 end do
              end if
              m = lend
              110 continue
              if( m>lend )e( m-1 ) = zero
              p = d( l )
              if( m==l )go to 130
              ! if remaining matrix is 2-by-2, use stdlib_${c2ri(ci)}$lae2 or stdlib_dlaev2
              ! to compute its eigensystem.
              if( m==l-1 ) then
                 if( icompz>0 ) then
                    call stdlib_${c2ri(ci)}$laev2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2, c, s )
                    work( m ) = c
                    work( n-1+m ) = s
                    call stdlib_${ci}$lasr( 'R', 'V', 'F', n, 2, work( m ),work( n-1+m ), z( 1, l-1 ), &
                              ldz )
                 else
                    call stdlib_${c2ri(ci)}$lae2( d( l-1 ), e( l-1 ), d( l ), rt1, rt2 )
                 end if
                 d( l-1 ) = rt1
                 d( l ) = rt2
                 e( l-1 ) = zero
                 l = l - 2
                 if( l>=lend )go to 90
                 go to 140
              end if
              if( jtot==nmaxit )go to 140
              jtot = jtot + 1
              ! form shift.
              g = ( d( l-1 )-p ) / ( two*e( l-1 ) )
              r = stdlib_${c2ri(ci)}$lapy2( g, one )
              g = d( m ) - p + ( e( l-1 ) / ( g+sign( r, g ) ) )
              s = one
              c = one
              p = zero
              ! inner loop
              lm1 = l - 1
              do i = m, lm1
                 f = s*e( i )
                 b = c*e( i )
                 call stdlib_${c2ri(ci)}$lartg( g, f, c, s, r )
                 if( i/=m )e( i-1 ) = r
                 g = d( i ) - p
                 r = ( d( i+1 )-g )*s + two*c*b
                 p = s*r
                 d( i ) = g + p
                 g = c*r - b
                 ! if eigenvectors are desired, then save rotations.
                 if( icompz>0 ) then
                    work( i ) = c
                    work( n-1+i ) = s
                 end if
              end do
              ! if eigenvectors are desired, then apply saved rotations.
              if( icompz>0 ) then
                 mm = l - m + 1
                 call stdlib_${ci}$lasr( 'R', 'V', 'F', n, mm, work( m ), work( n-1+m ),z( 1, m ), ldz &
                           )
              end if
              d( l ) = d( l ) - p
              e( lm1 ) = g
              go to 90
              ! eigenvalue found.
              130 continue
              d( l ) = p
              l = l - 1
              if( l>=lend )go to 90
              go to 140
           end if
           ! undo scaling if necessary
           140 continue
           if( iscale==1 ) then
              call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv+1, 1,d( lsv ), n, info )
                        
              call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv, 1, e( lsv ),n, info )
                        
           else if( iscale==2 ) then
              call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv+1, 1,d( lsv ), n, info )
                        
              call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv, 1, e( lsv ),n, info )
                        
           end if
           ! check for no convergence to an eigenvalue after a total
           ! of n*maxit iterations.
           if( jtot==nmaxit ) then
              do i = 1, n - 1
                 if( e( i )/=zero )info = info + 1
              end do
              return
           end if
           go to 10
           ! order eigenvalues and eigenvectors.
           160 continue
           if( icompz==0 ) then
              ! use quick sort
              call stdlib_${c2ri(ci)}$lasrt( 'I', n, d, info )
           else
              ! use selection sort to minimize swaps of eigenvectors
              do ii = 2, n
                 i = ii - 1
                 k = i
                 p = d( i )
                 do j = ii, n
                    if( d( j )<p ) then
                       k = j
                       p = d( j )
                    end if
                 end do
                 if( k/=i ) then
                    d( k ) = d( i )
                    d( i ) = p
                    call stdlib_${ci}$swap( n, z( 1, i ), 1, z( 1, k ), 1 )
                 end if
              end do
           end if
           return
     end subroutine stdlib_${ci}$steqr

#:endif
#:endfor



     pure subroutine stdlib_slaed0( icompq, qsiz, n, d, e, q, ldq, qstore, ldqs,work, iwork, info &
     !! SLAED0 computes all eigenvalues and corresponding eigenvectors of a
     !! symmetric tridiagonal matrix using the divide and conquer method.
               )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: icompq, ldq, ldqs, n, qsiz
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: d(*), e(*), q(ldq,*)
           real(sp), intent(out) :: qstore(ldqs,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: curlvl, curprb, curr, i, igivcl, igivnm, igivpt, indxq, iperm, iprmpt, &
           iq, iqptr, iwrem, j, k, lgn, matsiz, msd2, smlsiz, smm1, spm1, spm2, submat, subpbs, &
                     tlvls
           real(sp) :: temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( icompq<0 .or. icompq>2 ) then
              info = -1
           else if( ( icompq==1 ) .and. ( qsiz<max( 0, n ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ldq<max( 1, n ) ) then
              info = -7
           else if( ldqs<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SLAED0', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           smlsiz = stdlib_ilaenv( 9, 'SLAED0', ' ', 0, 0, 0, 0 )
           ! determine the size and placement of the submatrices, and save in
           ! the leading elements of iwork.
           iwork( 1 ) = n
           subpbs = 1
           tlvls = 0
           10 continue
           if( iwork( subpbs )>smlsiz ) then
              do j = subpbs, 1, -1
                 iwork( 2*j ) = ( iwork( j )+1 ) / 2
                 iwork( 2*j-1 ) = iwork( j ) / 2
              end do
              tlvls = tlvls + 1
              subpbs = 2*subpbs
              go to 10
           end if
           do j = 2, subpbs
              iwork( j ) = iwork( j ) + iwork( j-1 )
           end do
           ! divide the matrix into subpbs submatrices of size at most smlsiz+1
           ! using rank-1 modifications (cuts).
           spm1 = subpbs - 1
           do i = 1, spm1
              submat = iwork( i ) + 1
              smm1 = submat - 1
              d( smm1 ) = d( smm1 ) - abs( e( smm1 ) )
              d( submat ) = d( submat ) - abs( e( smm1 ) )
           end do
           indxq = 4*n + 3
           if( icompq/=2 ) then
              ! set up workspaces for eigenvalues only/accumulate new vectors
              ! routine
              temp = log( real( n,KIND=sp) ) / log( two )
              lgn = int( temp,KIND=ilp)
              if( 2**lgn<n )lgn = lgn + 1
              if( 2**lgn<n )lgn = lgn + 1
              iprmpt = indxq + n + 1
              iperm = iprmpt + n*lgn
              iqptr = iperm + n*lgn
              igivpt = iqptr + n + 2
              igivcl = igivpt + n*lgn
              igivnm = 1
              iq = igivnm + 2*n*lgn
              iwrem = iq + n**2 + 1
              ! initialize pointers
              do i = 0, subpbs
                 iwork( iprmpt+i ) = 1
                 iwork( igivpt+i ) = 1
              end do
              iwork( iqptr ) = 1
           end if
           ! solve each submatrix eigenproblem at the bottom of the divide and
           ! conquer tree.
           curr = 0
           loop_70: do i = 0, spm1
              if( i==0 ) then
                 submat = 1
                 matsiz = iwork( 1 )
              else
                 submat = iwork( i ) + 1
                 matsiz = iwork( i+1 ) - iwork( i )
              end if
              if( icompq==2 ) then
                 call stdlib_ssteqr( 'I', matsiz, d( submat ), e( submat ),q( submat, submat ), &
                           ldq, work, info )
                 if( info/=0 )go to 130
              else
                 call stdlib_ssteqr( 'I', matsiz, d( submat ), e( submat ),work( iq-1+iwork( &
                           iqptr+curr ) ), matsiz, work,info )
                 if( info/=0 )go to 130
                 if( icompq==1 ) then
                    call stdlib_sgemm( 'N', 'N', qsiz, matsiz, matsiz, one,q( 1, submat ), ldq, &
                    work( iq-1+iwork( iqptr+curr ) ), matsiz, zero, qstore( 1, submat ),ldqs )
                              
                 end if
                 iwork( iqptr+curr+1 ) = iwork( iqptr+curr ) + matsiz**2
                 curr = curr + 1
              end if
              k = 1
              do j = submat, iwork( i+1 )
                 iwork( indxq+j ) = k
                 k = k + 1
              end do
           end do loop_70
           ! successively merge eigensystems of adjacent submatrices
           ! into eigensystem for the corresponding larger matrix.
           ! while ( subpbs > 1 )
           curlvl = 1
           80 continue
           if( subpbs>1 ) then
              spm2 = subpbs - 2
              loop_90: do i = 0, spm2, 2
                 if( i==0 ) then
                    submat = 1
                    matsiz = iwork( 2 )
                    msd2 = iwork( 1 )
                    curprb = 0
                 else
                    submat = iwork( i ) + 1
                    matsiz = iwork( i+2 ) - iwork( i )
                    msd2 = matsiz / 2
                    curprb = curprb + 1
                 end if
           ! merge lower order eigensystems (of size msd2 and matsiz - msd2)
           ! into an eigensystem of size matsiz.
           ! stdlib_slaed1 is used only for the full eigensystem of a tridiagonal
           ! matrix.
           ! stdlib_slaed7 handles the cases in which eigenvalues only or eigenvalues
           ! and eigenvectors of a full symmetric matrix (which was reduced to
           ! tridiagonal form) are desired.
                 if( icompq==2 ) then
                    call stdlib_slaed1( matsiz, d( submat ), q( submat, submat ),ldq, iwork( &
                    indxq+submat ),e( submat+msd2-1 ), msd2, work,iwork( subpbs+1 ), info )
                              
                 else
                    call stdlib_slaed7( icompq, matsiz, qsiz, tlvls, curlvl, curprb,d( submat ), &
                    qstore( 1, submat ), ldqs,iwork( indxq+submat ), e( submat+msd2-1 ),msd2, &
                    work( iq ), iwork( iqptr ),iwork( iprmpt ), iwork( iperm ),iwork( igivpt ), &
                    iwork( igivcl ),work( igivnm ), work( iwrem ),iwork( subpbs+1 ), info )
                              
                 end if
                 if( info/=0 )go to 130
                 iwork( i / 2+1 ) = iwork( i+2 )
              end do loop_90
              subpbs = subpbs / 2
              curlvl = curlvl + 1
              go to 80
           end if
           ! end while
           ! re-merge the eigenvalues/vectors which were deflated at the final
           ! merge step.
           if( icompq==1 ) then
              do i = 1, n
                 j = iwork( indxq+i )
                 work( i ) = d( j )
                 call stdlib_scopy( qsiz, qstore( 1, j ), 1, q( 1, i ), 1 )
              end do
              call stdlib_scopy( n, work, 1, d, 1 )
           else if( icompq==2 ) then
              do i = 1, n
                 j = iwork( indxq+i )
                 work( i ) = d( j )
                 call stdlib_scopy( n, q( 1, j ), 1, work( n*i+1 ), 1 )
              end do
              call stdlib_scopy( n, work, 1, d, 1 )
              call stdlib_slacpy( 'A', n, n, work( n+1 ), n, q, ldq )
           else
              do i = 1, n
                 j = iwork( indxq+i )
                 work( i ) = d( j )
              end do
              call stdlib_scopy( n, work, 1, d, 1 )
           end if
           go to 140
           130 continue
           info = submat*( n+1 ) + submat + matsiz - 1
           140 continue
           return
     end subroutine stdlib_slaed0

     pure subroutine stdlib_dlaed0( icompq, qsiz, n, d, e, q, ldq, qstore, ldqs,work, iwork, info &
     !! DLAED0 computes all eigenvalues and corresponding eigenvectors of a
     !! symmetric tridiagonal matrix using the divide and conquer method.
               )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: icompq, ldq, ldqs, n, qsiz
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(inout) :: d(*), e(*), q(ldq,*)
           real(dp), intent(out) :: qstore(ldqs,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: curlvl, curprb, curr, i, igivcl, igivnm, igivpt, indxq, iperm, iprmpt, &
           iq, iqptr, iwrem, j, k, lgn, matsiz, msd2, smlsiz, smm1, spm1, spm2, submat, subpbs, &
                     tlvls
           real(dp) :: temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( icompq<0 .or. icompq>2 ) then
              info = -1
           else if( ( icompq==1 ) .and. ( qsiz<max( 0, n ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ldq<max( 1, n ) ) then
              info = -7
           else if( ldqs<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED0', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           smlsiz = stdlib_ilaenv( 9, 'DLAED0', ' ', 0, 0, 0, 0 )
           ! determine the size and placement of the submatrices, and save in
           ! the leading elements of iwork.
           iwork( 1 ) = n
           subpbs = 1
           tlvls = 0
           10 continue
           if( iwork( subpbs )>smlsiz ) then
              do j = subpbs, 1, -1
                 iwork( 2*j ) = ( iwork( j )+1 ) / 2
                 iwork( 2*j-1 ) = iwork( j ) / 2
              end do
              tlvls = tlvls + 1
              subpbs = 2*subpbs
              go to 10
           end if
           do j = 2, subpbs
              iwork( j ) = iwork( j ) + iwork( j-1 )
           end do
           ! divide the matrix into subpbs submatrices of size at most smlsiz+1
           ! using rank-1 modifications (cuts).
           spm1 = subpbs - 1
           do i = 1, spm1
              submat = iwork( i ) + 1
              smm1 = submat - 1
              d( smm1 ) = d( smm1 ) - abs( e( smm1 ) )
              d( submat ) = d( submat ) - abs( e( smm1 ) )
           end do
           indxq = 4*n + 3
           if( icompq/=2 ) then
              ! set up workspaces for eigenvalues only/accumulate new vectors
              ! routine
              temp = log( real( n,KIND=dp) ) / log( two )
              lgn = int( temp,KIND=ilp)
              if( 2**lgn<n )lgn = lgn + 1
              if( 2**lgn<n )lgn = lgn + 1
              iprmpt = indxq + n + 1
              iperm = iprmpt + n*lgn
              iqptr = iperm + n*lgn
              igivpt = iqptr + n + 2
              igivcl = igivpt + n*lgn
              igivnm = 1
              iq = igivnm + 2*n*lgn
              iwrem = iq + n**2 + 1
              ! initialize pointers
              do i = 0, subpbs
                 iwork( iprmpt+i ) = 1
                 iwork( igivpt+i ) = 1
              end do
              iwork( iqptr ) = 1
           end if
           ! solve each submatrix eigenproblem at the bottom of the divide and
           ! conquer tree.
           curr = 0
           loop_70: do i = 0, spm1
              if( i==0 ) then
                 submat = 1
                 matsiz = iwork( 1 )
              else
                 submat = iwork( i ) + 1
                 matsiz = iwork( i+1 ) - iwork( i )
              end if
              if( icompq==2 ) then
                 call stdlib_dsteqr( 'I', matsiz, d( submat ), e( submat ),q( submat, submat ), &
                           ldq, work, info )
                 if( info/=0 )go to 130
              else
                 call stdlib_dsteqr( 'I', matsiz, d( submat ), e( submat ),work( iq-1+iwork( &
                           iqptr+curr ) ), matsiz, work,info )
                 if( info/=0 )go to 130
                 if( icompq==1 ) then
                    call stdlib_dgemm( 'N', 'N', qsiz, matsiz, matsiz, one,q( 1, submat ), ldq, &
                    work( iq-1+iwork( iqptr+curr ) ), matsiz, zero, qstore( 1, submat ),ldqs )
                              
                 end if
                 iwork( iqptr+curr+1 ) = iwork( iqptr+curr ) + matsiz**2
                 curr = curr + 1
              end if
              k = 1
              do j = submat, iwork( i+1 )
                 iwork( indxq+j ) = k
                 k = k + 1
              end do
           end do loop_70
           ! successively merge eigensystems of adjacent submatrices
           ! into eigensystem for the corresponding larger matrix.
           ! while ( subpbs > 1 )
           curlvl = 1
           80 continue
           if( subpbs>1 ) then
              spm2 = subpbs - 2
              loop_90: do i = 0, spm2, 2
                 if( i==0 ) then
                    submat = 1
                    matsiz = iwork( 2 )
                    msd2 = iwork( 1 )
                    curprb = 0
                 else
                    submat = iwork( i ) + 1
                    matsiz = iwork( i+2 ) - iwork( i )
                    msd2 = matsiz / 2
                    curprb = curprb + 1
                 end if
           ! merge lower order eigensystems (of size msd2 and matsiz - msd2)
           ! into an eigensystem of size matsiz.
           ! stdlib_dlaed1 is used only for the full eigensystem of a tridiagonal
           ! matrix.
           ! stdlib_dlaed7 handles the cases in which eigenvalues only or eigenvalues
           ! and eigenvectors of a full symmetric matrix (which was reduced to
           ! tridiagonal form) are desired.
                 if( icompq==2 ) then
                    call stdlib_dlaed1( matsiz, d( submat ), q( submat, submat ),ldq, iwork( &
                    indxq+submat ),e( submat+msd2-1 ), msd2, work,iwork( subpbs+1 ), info )
                              
                 else
                    call stdlib_dlaed7( icompq, matsiz, qsiz, tlvls, curlvl, curprb,d( submat ), &
                    qstore( 1, submat ), ldqs,iwork( indxq+submat ), e( submat+msd2-1 ),msd2, &
                    work( iq ), iwork( iqptr ),iwork( iprmpt ), iwork( iperm ),iwork( igivpt ), &
                    iwork( igivcl ),work( igivnm ), work( iwrem ),iwork( subpbs+1 ), info )
                              
                 end if
                 if( info/=0 )go to 130
                 iwork( i / 2+1 ) = iwork( i+2 )
              end do loop_90
              subpbs = subpbs / 2
              curlvl = curlvl + 1
              go to 80
           end if
           ! end while
           ! re-merge the eigenvalues/vectors which were deflated at the final
           ! merge step.
           if( icompq==1 ) then
              do i = 1, n
                 j = iwork( indxq+i )
                 work( i ) = d( j )
                 call stdlib_dcopy( qsiz, qstore( 1, j ), 1, q( 1, i ), 1 )
              end do
              call stdlib_dcopy( n, work, 1, d, 1 )
           else if( icompq==2 ) then
              do i = 1, n
                 j = iwork( indxq+i )
                 work( i ) = d( j )
                 call stdlib_dcopy( n, q( 1, j ), 1, work( n*i+1 ), 1 )
              end do
              call stdlib_dcopy( n, work, 1, d, 1 )
              call stdlib_dlacpy( 'A', n, n, work( n+1 ), n, q, ldq )
           else
              do i = 1, n
                 j = iwork( indxq+i )
                 work( i ) = d( j )
              end do
              call stdlib_dcopy( n, work, 1, d, 1 )
           end if
           go to 140
           130 continue
           info = submat*( n+1 ) + submat + matsiz - 1
           140 continue
           return
     end subroutine stdlib_dlaed0

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laed0( icompq, qsiz, n, d, e, q, ldq, qstore, ldqs,work, iwork, info &
     !! DLAED0: computes all eigenvalues and corresponding eigenvectors of a
     !! symmetric tridiagonal matrix using the divide and conquer method.
               )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: icompq, ldq, ldqs, n, qsiz
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*), q(ldq,*)
           real(${rk}$), intent(out) :: qstore(ldqs,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: curlvl, curprb, curr, i, igivcl, igivnm, igivpt, indxq, iperm, iprmpt, &
           iq, iqptr, iwrem, j, k, lgn, matsiz, msd2, smlsiz, smm1, spm1, spm2, submat, subpbs, &
                     tlvls
           real(${rk}$) :: temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( icompq<0 .or. icompq>2 ) then
              info = -1
           else if( ( icompq==1 ) .and. ( qsiz<max( 0, n ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ldq<max( 1, n ) ) then
              info = -7
           else if( ldqs<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED0', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           smlsiz = stdlib_ilaenv( 9, 'DLAED0', ' ', 0, 0, 0, 0 )
           ! determine the size and placement of the submatrices, and save in
           ! the leading elements of iwork.
           iwork( 1 ) = n
           subpbs = 1
           tlvls = 0
           10 continue
           if( iwork( subpbs )>smlsiz ) then
              do j = subpbs, 1, -1
                 iwork( 2*j ) = ( iwork( j )+1 ) / 2
                 iwork( 2*j-1 ) = iwork( j ) / 2
              end do
              tlvls = tlvls + 1
              subpbs = 2*subpbs
              go to 10
           end if
           do j = 2, subpbs
              iwork( j ) = iwork( j ) + iwork( j-1 )
           end do
           ! divide the matrix into subpbs submatrices of size at most smlsiz+1
           ! using rank-1 modifications (cuts).
           spm1 = subpbs - 1
           do i = 1, spm1
              submat = iwork( i ) + 1
              smm1 = submat - 1
              d( smm1 ) = d( smm1 ) - abs( e( smm1 ) )
              d( submat ) = d( submat ) - abs( e( smm1 ) )
           end do
           indxq = 4*n + 3
           if( icompq/=2 ) then
              ! set up workspaces for eigenvalues only/accumulate new vectors
              ! routine
              temp = log( real( n,KIND=${rk}$) ) / log( two )
              lgn = int( temp,KIND=ilp)
              if( 2**lgn<n )lgn = lgn + 1
              if( 2**lgn<n )lgn = lgn + 1
              iprmpt = indxq + n + 1
              iperm = iprmpt + n*lgn
              iqptr = iperm + n*lgn
              igivpt = iqptr + n + 2
              igivcl = igivpt + n*lgn
              igivnm = 1
              iq = igivnm + 2*n*lgn
              iwrem = iq + n**2 + 1
              ! initialize pointers
              do i = 0, subpbs
                 iwork( iprmpt+i ) = 1
                 iwork( igivpt+i ) = 1
              end do
              iwork( iqptr ) = 1
           end if
           ! solve each submatrix eigenproblem at the bottom of the divide and
           ! conquer tree.
           curr = 0
           loop_70: do i = 0, spm1
              if( i==0 ) then
                 submat = 1
                 matsiz = iwork( 1 )
              else
                 submat = iwork( i ) + 1
                 matsiz = iwork( i+1 ) - iwork( i )
              end if
              if( icompq==2 ) then
                 call stdlib_${ri}$steqr( 'I', matsiz, d( submat ), e( submat ),q( submat, submat ), &
                           ldq, work, info )
                 if( info/=0 )go to 130
              else
                 call stdlib_${ri}$steqr( 'I', matsiz, d( submat ), e( submat ),work( iq-1+iwork( &
                           iqptr+curr ) ), matsiz, work,info )
                 if( info/=0 )go to 130
                 if( icompq==1 ) then
                    call stdlib_${ri}$gemm( 'N', 'N', qsiz, matsiz, matsiz, one,q( 1, submat ), ldq, &
                    work( iq-1+iwork( iqptr+curr ) ), matsiz, zero, qstore( 1, submat ),ldqs )
                              
                 end if
                 iwork( iqptr+curr+1 ) = iwork( iqptr+curr ) + matsiz**2
                 curr = curr + 1
              end if
              k = 1
              do j = submat, iwork( i+1 )
                 iwork( indxq+j ) = k
                 k = k + 1
              end do
           end do loop_70
           ! successively merge eigensystems of adjacent submatrices
           ! into eigensystem for the corresponding larger matrix.
           ! while ( subpbs > 1 )
           curlvl = 1
           80 continue
           if( subpbs>1 ) then
              spm2 = subpbs - 2
              loop_90: do i = 0, spm2, 2
                 if( i==0 ) then
                    submat = 1
                    matsiz = iwork( 2 )
                    msd2 = iwork( 1 )
                    curprb = 0
                 else
                    submat = iwork( i ) + 1
                    matsiz = iwork( i+2 ) - iwork( i )
                    msd2 = matsiz / 2
                    curprb = curprb + 1
                 end if
           ! merge lower order eigensystems (of size msd2 and matsiz - msd2)
           ! into an eigensystem of size matsiz.
           ! stdlib_${ri}$laed1 is used only for the full eigensystem of a tridiagonal
           ! matrix.
           ! stdlib_${ri}$laed7 handles the cases in which eigenvalues only or eigenvalues
           ! and eigenvectors of a full symmetric matrix (which was reduced to
           ! tridiagonal form) are desired.
                 if( icompq==2 ) then
                    call stdlib_${ri}$laed1( matsiz, d( submat ), q( submat, submat ),ldq, iwork( &
                    indxq+submat ),e( submat+msd2-1 ), msd2, work,iwork( subpbs+1 ), info )
                              
                 else
                    call stdlib_${ri}$laed7( icompq, matsiz, qsiz, tlvls, curlvl, curprb,d( submat ), &
                    qstore( 1, submat ), ldqs,iwork( indxq+submat ), e( submat+msd2-1 ),msd2, &
                    work( iq ), iwork( iqptr ),iwork( iprmpt ), iwork( iperm ),iwork( igivpt ), &
                    iwork( igivcl ),work( igivnm ), work( iwrem ),iwork( subpbs+1 ), info )
                              
                 end if
                 if( info/=0 )go to 130
                 iwork( i / 2+1 ) = iwork( i+2 )
              end do loop_90
              subpbs = subpbs / 2
              curlvl = curlvl + 1
              go to 80
           end if
           ! end while
           ! re-merge the eigenvalues/vectors which were deflated at the final
           ! merge step.
           if( icompq==1 ) then
              do i = 1, n
                 j = iwork( indxq+i )
                 work( i ) = d( j )
                 call stdlib_${ri}$copy( qsiz, qstore( 1, j ), 1, q( 1, i ), 1 )
              end do
              call stdlib_${ri}$copy( n, work, 1, d, 1 )
           else if( icompq==2 ) then
              do i = 1, n
                 j = iwork( indxq+i )
                 work( i ) = d( j )
                 call stdlib_${ri}$copy( n, q( 1, j ), 1, work( n*i+1 ), 1 )
              end do
              call stdlib_${ri}$copy( n, work, 1, d, 1 )
              call stdlib_${ri}$lacpy( 'A', n, n, work( n+1 ), n, q, ldq )
           else
              do i = 1, n
                 j = iwork( indxq+i )
                 work( i ) = d( j )
              end do
              call stdlib_${ri}$copy( n, work, 1, d, 1 )
           end if
           go to 140
           130 continue
           info = submat*( n+1 ) + submat + matsiz - 1
           140 continue
           return
     end subroutine stdlib_${ri}$laed0

#:endif
#:endfor

     pure subroutine stdlib_claed0( qsiz, n, d, e, q, ldq, qstore, ldqs, rwork,iwork, info )
     !! Using the divide and conquer method, CLAED0: computes all eigenvalues
     !! of a symmetric tridiagonal matrix which is one diagonal block of
     !! those from reducing a dense or band Hermitian matrix and
     !! corresponding eigenvectors of the dense or band matrix.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldq, ldqs, n, qsiz
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: q(ldq,*)
           complex(sp), intent(out) :: qstore(ldqs,*)
        ! =====================================================================
        ! warning:      n could be as big as qsiz!
           
           ! Local Scalars 
           integer(ilp) :: curlvl, curprb, curr, i, igivcl, igivnm, igivpt, indxq, iperm, iprmpt, &
           iq, iqptr, iwrem, j, k, lgn, ll, matsiz, msd2, smlsiz, smm1, spm1, spm2, submat, &
                     subpbs, tlvls
           real(sp) :: temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           ! if( icompq < 0 .or. icompq > 2 ) then
              ! info = -1
           ! else if( ( icompq == 1 ) .and. ( qsiz < max( 0, n ) ) )
          ! $        then
           if( qsiz<max( 0, n ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           else if( ldqs<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAED0', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           smlsiz = stdlib_ilaenv( 9, 'CLAED0', ' ', 0, 0, 0, 0 )
           ! determine the size and placement of the submatrices, and save in
           ! the leading elements of iwork.
           iwork( 1 ) = n
           subpbs = 1
           tlvls = 0
           10 continue
           if( iwork( subpbs )>smlsiz ) then
              do j = subpbs, 1, -1
                 iwork( 2*j ) = ( iwork( j )+1 ) / 2
                 iwork( 2*j-1 ) = iwork( j ) / 2
              end do
              tlvls = tlvls + 1
              subpbs = 2*subpbs
              go to 10
           end if
           do j = 2, subpbs
              iwork( j ) = iwork( j ) + iwork( j-1 )
           end do
           ! divide the matrix into subpbs submatrices of size at most smlsiz+1
           ! using rank-1 modifications (cuts).
           spm1 = subpbs - 1
           do i = 1, spm1
              submat = iwork( i ) + 1
              smm1 = submat - 1
              d( smm1 ) = d( smm1 ) - abs( e( smm1 ) )
              d( submat ) = d( submat ) - abs( e( smm1 ) )
           end do
           indxq = 4*n + 3
           ! set up workspaces for eigenvalues only/accumulate new vectors
           ! routine
           temp = log( real( n,KIND=sp) ) / log( two )
           lgn = int( temp,KIND=ilp)
           if( 2**lgn<n )lgn = lgn + 1
           if( 2**lgn<n )lgn = lgn + 1
           iprmpt = indxq + n + 1
           iperm = iprmpt + n*lgn
           iqptr = iperm + n*lgn
           igivpt = iqptr + n + 2
           igivcl = igivpt + n*lgn
           igivnm = 1
           iq = igivnm + 2*n*lgn
           iwrem = iq + n**2 + 1
           ! initialize pointers
           do i = 0, subpbs
              iwork( iprmpt+i ) = 1
              iwork( igivpt+i ) = 1
           end do
           iwork( iqptr ) = 1
           ! solve each submatrix eigenproblem at the bottom of the divide and
           ! conquer tree.
           curr = 0
           do i = 0, spm1
              if( i==0 ) then
                 submat = 1
                 matsiz = iwork( 1 )
              else
                 submat = iwork( i ) + 1
                 matsiz = iwork( i+1 ) - iwork( i )
              end if
              ll = iq - 1 + iwork( iqptr+curr )
              call stdlib_ssteqr( 'I', matsiz, d( submat ), e( submat ),rwork( ll ), matsiz, &
                        rwork, info )
              call stdlib_clacrm( qsiz, matsiz, q( 1, submat ), ldq, rwork( ll ),matsiz, qstore( &
                        1, submat ), ldqs,rwork( iwrem ) )
              iwork( iqptr+curr+1 ) = iwork( iqptr+curr ) + matsiz**2
              curr = curr + 1
              if( info>0 ) then
                 info = submat*( n+1 ) + submat + matsiz - 1
                 return
              end if
              k = 1
              do j = submat, iwork( i+1 )
                 iwork( indxq+j ) = k
                 k = k + 1
              end do
           end do
           ! successively merge eigensystems of adjacent submatrices
           ! into eigensystem for the corresponding larger matrix.
           ! while ( subpbs > 1 )
           curlvl = 1
           80 continue
           if( subpbs>1 ) then
              spm2 = subpbs - 2
              do i = 0, spm2, 2
                 if( i==0 ) then
                    submat = 1
                    matsiz = iwork( 2 )
                    msd2 = iwork( 1 )
                    curprb = 0
                 else
                    submat = iwork( i ) + 1
                    matsiz = iwork( i+2 ) - iwork( i )
                    msd2 = matsiz / 2
                    curprb = curprb + 1
                 end if
           ! merge lower order eigensystems (of size msd2 and matsiz - msd2)
           ! into an eigensystem of size matsiz.  stdlib_claed7 handles the case
           ! when the eigenvectors of a full or band hermitian matrix (which
           ! was reduced to tridiagonal form) are desired.
           ! i am free to use q as a valuable working space until loop 150.
                 call stdlib_claed7( matsiz, msd2, qsiz, tlvls, curlvl, curprb,d( submat ), &
                 qstore( 1, submat ), ldqs,e( submat+msd2-1 ), iwork( indxq+submat ),rwork( iq ), &
                 iwork( iqptr ), iwork( iprmpt ),iwork( iperm ), iwork( igivpt ),iwork( igivcl ), &
                           rwork( igivnm ),q( 1, submat ), rwork( iwrem ),iwork( subpbs+1 ), info )
                 if( info>0 ) then
                    info = submat*( n+1 ) + submat + matsiz - 1
                    return
                 end if
                 iwork( i / 2+1 ) = iwork( i+2 )
              end do
              subpbs = subpbs / 2
              curlvl = curlvl + 1
              go to 80
           end if
           ! end while
           ! re-merge the eigenvalues/vectors which were deflated at the final
           ! merge step.
           do i = 1, n
              j = iwork( indxq+i )
              rwork( i ) = d( j )
              call stdlib_ccopy( qsiz, qstore( 1, j ), 1, q( 1, i ), 1 )
           end do
           call stdlib_scopy( n, rwork, 1, d, 1 )
           return
     end subroutine stdlib_claed0

     pure subroutine stdlib_zlaed0( qsiz, n, d, e, q, ldq, qstore, ldqs, rwork,iwork, info )
     !! Using the divide and conquer method, ZLAED0: computes all eigenvalues
     !! of a symmetric tridiagonal matrix which is one diagonal block of
     !! those from reducing a dense or band Hermitian matrix and
     !! corresponding eigenvectors of the dense or band matrix.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldq, ldqs, n, qsiz
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: q(ldq,*)
           complex(dp), intent(out) :: qstore(ldqs,*)
        ! =====================================================================
        ! warning:      n could be as big as qsiz!
           
           ! Local Scalars 
           integer(ilp) :: curlvl, curprb, curr, i, igivcl, igivnm, igivpt, indxq, iperm, iprmpt, &
           iq, iqptr, iwrem, j, k, lgn, ll, matsiz, msd2, smlsiz, smm1, spm1, spm2, submat, &
                     subpbs, tlvls
           real(dp) :: temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           ! if( icompq < 0 .or. icompq > 2 ) then
              ! info = -1
           ! else if( ( icompq == 1 ) .and. ( qsiz < max( 0, n ) ) )
          ! $        then
           if( qsiz<max( 0, n ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           else if( ldqs<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZLAED0', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           smlsiz = stdlib_ilaenv( 9, 'ZLAED0', ' ', 0, 0, 0, 0 )
           ! determine the size and placement of the submatrices, and save in
           ! the leading elements of iwork.
           iwork( 1 ) = n
           subpbs = 1
           tlvls = 0
           10 continue
           if( iwork( subpbs )>smlsiz ) then
              do j = subpbs, 1, -1
                 iwork( 2*j ) = ( iwork( j )+1 ) / 2
                 iwork( 2*j-1 ) = iwork( j ) / 2
              end do
              tlvls = tlvls + 1
              subpbs = 2*subpbs
              go to 10
           end if
           do j = 2, subpbs
              iwork( j ) = iwork( j ) + iwork( j-1 )
           end do
           ! divide the matrix into subpbs submatrices of size at most smlsiz+1
           ! using rank-1 modifications (cuts).
           spm1 = subpbs - 1
           do i = 1, spm1
              submat = iwork( i ) + 1
              smm1 = submat - 1
              d( smm1 ) = d( smm1 ) - abs( e( smm1 ) )
              d( submat ) = d( submat ) - abs( e( smm1 ) )
           end do
           indxq = 4*n + 3
           ! set up workspaces for eigenvalues only/accumulate new vectors
           ! routine
           temp = log( real( n,KIND=dp) ) / log( two )
           lgn = int( temp,KIND=ilp)
           if( 2**lgn<n )lgn = lgn + 1
           if( 2**lgn<n )lgn = lgn + 1
           iprmpt = indxq + n + 1
           iperm = iprmpt + n*lgn
           iqptr = iperm + n*lgn
           igivpt = iqptr + n + 2
           igivcl = igivpt + n*lgn
           igivnm = 1
           iq = igivnm + 2*n*lgn
           iwrem = iq + n**2 + 1
           ! initialize pointers
           do i = 0, subpbs
              iwork( iprmpt+i ) = 1
              iwork( igivpt+i ) = 1
           end do
           iwork( iqptr ) = 1
           ! solve each submatrix eigenproblem at the bottom of the divide and
           ! conquer tree.
           curr = 0
           do i = 0, spm1
              if( i==0 ) then
                 submat = 1
                 matsiz = iwork( 1 )
              else
                 submat = iwork( i ) + 1
                 matsiz = iwork( i+1 ) - iwork( i )
              end if
              ll = iq - 1 + iwork( iqptr+curr )
              call stdlib_dsteqr( 'I', matsiz, d( submat ), e( submat ),rwork( ll ), matsiz, &
                        rwork, info )
              call stdlib_zlacrm( qsiz, matsiz, q( 1, submat ), ldq, rwork( ll ),matsiz, qstore( &
                        1, submat ), ldqs,rwork( iwrem ) )
              iwork( iqptr+curr+1 ) = iwork( iqptr+curr ) + matsiz**2
              curr = curr + 1
              if( info>0 ) then
                 info = submat*( n+1 ) + submat + matsiz - 1
                 return
              end if
              k = 1
              do j = submat, iwork( i+1 )
                 iwork( indxq+j ) = k
                 k = k + 1
              end do
           end do
           ! successively merge eigensystems of adjacent submatrices
           ! into eigensystem for the corresponding larger matrix.
           ! while ( subpbs > 1 )
           curlvl = 1
           80 continue
           if( subpbs>1 ) then
              spm2 = subpbs - 2
              do i = 0, spm2, 2
                 if( i==0 ) then
                    submat = 1
                    matsiz = iwork( 2 )
                    msd2 = iwork( 1 )
                    curprb = 0
                 else
                    submat = iwork( i ) + 1
                    matsiz = iwork( i+2 ) - iwork( i )
                    msd2 = matsiz / 2
                    curprb = curprb + 1
                 end if
           ! merge lower order eigensystems (of size msd2 and matsiz - msd2)
           ! into an eigensystem of size matsiz.  stdlib_zlaed7 handles the case
           ! when the eigenvectors of a full or band hermitian matrix (which
           ! was reduced to tridiagonal form) are desired.
           ! i am free to use q as a valuable working space until loop 150.
                 call stdlib_zlaed7( matsiz, msd2, qsiz, tlvls, curlvl, curprb,d( submat ), &
                 qstore( 1, submat ), ldqs,e( submat+msd2-1 ), iwork( indxq+submat ),rwork( iq ), &
                 iwork( iqptr ), iwork( iprmpt ),iwork( iperm ), iwork( igivpt ),iwork( igivcl ), &
                           rwork( igivnm ),q( 1, submat ), rwork( iwrem ),iwork( subpbs+1 ), info )
                 if( info>0 ) then
                    info = submat*( n+1 ) + submat + matsiz - 1
                    return
                 end if
                 iwork( i / 2+1 ) = iwork( i+2 )
              end do
              subpbs = subpbs / 2
              curlvl = curlvl + 1
              go to 80
           end if
           ! end while
           ! re-merge the eigenvalues/vectors which were deflated at the final
           ! merge step.
           do i = 1, n
              j = iwork( indxq+i )
              rwork( i ) = d( j )
              call stdlib_zcopy( qsiz, qstore( 1, j ), 1, q( 1, i ), 1 )
           end do
           call stdlib_dcopy( n, rwork, 1, d, 1 )
           return
     end subroutine stdlib_zlaed0

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$laed0( qsiz, n, d, e, q, ldq, qstore, ldqs, rwork,iwork, info )
     !! Using the divide and conquer method, ZLAED0: computes all eigenvalues
     !! of a symmetric tridiagonal matrix which is one diagonal block of
     !! those from reducing a dense or band Hermitian matrix and
     !! corresponding eigenvectors of the dense or band matrix.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldq, ldqs, n, qsiz
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${ck}$), intent(inout) :: d(*), e(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: q(ldq,*)
           complex(${ck}$), intent(out) :: qstore(ldqs,*)
        ! =====================================================================
        ! warning:      n could be as big as qsiz!
           
           ! Local Scalars 
           integer(ilp) :: curlvl, curprb, curr, i, igivcl, igivnm, igivpt, indxq, iperm, iprmpt, &
           iq, iqptr, iwrem, j, k, lgn, ll, matsiz, msd2, smlsiz, smm1, spm1, spm2, submat, &
                     subpbs, tlvls
           real(${ck}$) :: temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           ! if( icompq < 0 .or. icompq > 2 ) then
              ! info = -1
           ! else if( ( icompq == 1 ) .and. ( qsiz < max( 0, n ) ) )
          ! $        then
           if( qsiz<max( 0, n ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           else if( ldqs<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZLAED0', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           smlsiz = stdlib_ilaenv( 9, 'ZLAED0', ' ', 0, 0, 0, 0 )
           ! determine the size and placement of the submatrices, and save in
           ! the leading elements of iwork.
           iwork( 1 ) = n
           subpbs = 1
           tlvls = 0
           10 continue
           if( iwork( subpbs )>smlsiz ) then
              do j = subpbs, 1, -1
                 iwork( 2*j ) = ( iwork( j )+1 ) / 2
                 iwork( 2*j-1 ) = iwork( j ) / 2
              end do
              tlvls = tlvls + 1
              subpbs = 2*subpbs
              go to 10
           end if
           do j = 2, subpbs
              iwork( j ) = iwork( j ) + iwork( j-1 )
           end do
           ! divide the matrix into subpbs submatrices of size at most smlsiz+1
           ! using rank-1 modifications (cuts).
           spm1 = subpbs - 1
           do i = 1, spm1
              submat = iwork( i ) + 1
              smm1 = submat - 1
              d( smm1 ) = d( smm1 ) - abs( e( smm1 ) )
              d( submat ) = d( submat ) - abs( e( smm1 ) )
           end do
           indxq = 4*n + 3
           ! set up workspaces for eigenvalues only/accumulate new vectors
           ! routine
           temp = log( real( n,KIND=${ck}$) ) / log( two )
           lgn = int( temp,KIND=ilp)
           if( 2**lgn<n )lgn = lgn + 1
           if( 2**lgn<n )lgn = lgn + 1
           iprmpt = indxq + n + 1
           iperm = iprmpt + n*lgn
           iqptr = iperm + n*lgn
           igivpt = iqptr + n + 2
           igivcl = igivpt + n*lgn
           igivnm = 1
           iq = igivnm + 2*n*lgn
           iwrem = iq + n**2 + 1
           ! initialize pointers
           do i = 0, subpbs
              iwork( iprmpt+i ) = 1
              iwork( igivpt+i ) = 1
           end do
           iwork( iqptr ) = 1
           ! solve each submatrix eigenproblem at the bottom of the divide and
           ! conquer tree.
           curr = 0
           do i = 0, spm1
              if( i==0 ) then
                 submat = 1
                 matsiz = iwork( 1 )
              else
                 submat = iwork( i ) + 1
                 matsiz = iwork( i+1 ) - iwork( i )
              end if
              ll = iq - 1 + iwork( iqptr+curr )
              call stdlib_${c2ri(ci)}$steqr( 'I', matsiz, d( submat ), e( submat ),rwork( ll ), matsiz, &
                        rwork, info )
              call stdlib_${ci}$lacrm( qsiz, matsiz, q( 1, submat ), ldq, rwork( ll ),matsiz, qstore( &
                        1, submat ), ldqs,rwork( iwrem ) )
              iwork( iqptr+curr+1 ) = iwork( iqptr+curr ) + matsiz**2
              curr = curr + 1
              if( info>0 ) then
                 info = submat*( n+1 ) + submat + matsiz - 1
                 return
              end if
              k = 1
              do j = submat, iwork( i+1 )
                 iwork( indxq+j ) = k
                 k = k + 1
              end do
           end do
           ! successively merge eigensystems of adjacent submatrices
           ! into eigensystem for the corresponding larger matrix.
           ! while ( subpbs > 1 )
           curlvl = 1
           80 continue
           if( subpbs>1 ) then
              spm2 = subpbs - 2
              do i = 0, spm2, 2
                 if( i==0 ) then
                    submat = 1
                    matsiz = iwork( 2 )
                    msd2 = iwork( 1 )
                    curprb = 0
                 else
                    submat = iwork( i ) + 1
                    matsiz = iwork( i+2 ) - iwork( i )
                    msd2 = matsiz / 2
                    curprb = curprb + 1
                 end if
           ! merge lower order eigensystems (of size msd2 and matsiz - msd2)
           ! into an eigensystem of size matsiz.  stdlib_${ci}$laed7 handles the case
           ! when the eigenvectors of a full or band hermitian matrix (which
           ! was reduced to tridiagonal form) are desired.
           ! i am free to use q as a valuable working space until loop 150.
                 call stdlib_${ci}$laed7( matsiz, msd2, qsiz, tlvls, curlvl, curprb,d( submat ), &
                 qstore( 1, submat ), ldqs,e( submat+msd2-1 ), iwork( indxq+submat ),rwork( iq ), &
                 iwork( iqptr ), iwork( iprmpt ),iwork( iperm ), iwork( igivpt ),iwork( igivcl ), &
                           rwork( igivnm ),q( 1, submat ), rwork( iwrem ),iwork( subpbs+1 ), info )
                 if( info>0 ) then
                    info = submat*( n+1 ) + submat + matsiz - 1
                    return
                 end if
                 iwork( i / 2+1 ) = iwork( i+2 )
              end do
              subpbs = subpbs / 2
              curlvl = curlvl + 1
              go to 80
           end if
           ! end while
           ! re-merge the eigenvalues/vectors which were deflated at the final
           ! merge step.
           do i = 1, n
              j = iwork( indxq+i )
              rwork( i ) = d( j )
              call stdlib_${ci}$copy( qsiz, qstore( 1, j ), 1, q( 1, i ), 1 )
           end do
           call stdlib_${c2ri(ci)}$copy( n, rwork, 1, d, 1 )
           return
     end subroutine stdlib_${ci}$laed0

#:endif
#:endfor



     pure subroutine stdlib_slarra( n, d, e, e2, spltol, tnrm,nsplit, isplit, info )
     !! Compute the splitting points with threshold SPLTOL.
     !! SLARRA sets any "small" off-diagonal elements to zero.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info, nsplit
           integer(ilp), intent(in) :: n
           real(sp), intent(in) :: spltol, tnrm
           ! Array Arguments 
           integer(ilp), intent(out) :: isplit(*)
           real(sp), intent(in) :: d(*)
           real(sp), intent(inout) :: e(*), e2(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(sp) :: eabs, tmp1
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           ! compute splitting points
           nsplit = 1
           if(spltol<zero) then
              ! criterion based on absolute off-diagonal value
              tmp1 = abs(spltol)* tnrm
              do i = 1, n-1
                 eabs = abs( e(i) )
                 if( eabs <= tmp1) then
                    e(i) = zero
                    e2(i) = zero
                    isplit( nsplit ) = i
                    nsplit = nsplit + 1
                 end if
              end do
           else
              ! criterion that guarantees relative accuracy
              do i = 1, n-1
                 eabs = abs( e(i) )
                 if( eabs <= spltol * sqrt(abs(d(i)))*sqrt(abs(d(i+1))) )then
                    e(i) = zero
                    e2(i) = zero
                    isplit( nsplit ) = i
                    nsplit = nsplit + 1
                 end if
              end do
           endif
           isplit( nsplit ) = n
           return
     end subroutine stdlib_slarra

     pure subroutine stdlib_dlarra( n, d, e, e2, spltol, tnrm,nsplit, isplit, info )
     !! Compute the splitting points with threshold SPLTOL.
     !! DLARRA sets any "small" off-diagonal elements to zero.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info, nsplit
           integer(ilp), intent(in) :: n
           real(dp), intent(in) :: spltol, tnrm
           ! Array Arguments 
           integer(ilp), intent(out) :: isplit(*)
           real(dp), intent(in) :: d(*)
           real(dp), intent(inout) :: e(*), e2(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(dp) :: eabs, tmp1
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           ! compute splitting points
           nsplit = 1
           if(spltol<zero) then
              ! criterion based on absolute off-diagonal value
              tmp1 = abs(spltol)* tnrm
              do i = 1, n-1
                 eabs = abs( e(i) )
                 if( eabs <= tmp1) then
                    e(i) = zero
                    e2(i) = zero
                    isplit( nsplit ) = i
                    nsplit = nsplit + 1
                 end if
              end do
           else
              ! criterion that guarantees relative accuracy
              do i = 1, n-1
                 eabs = abs( e(i) )
                 if( eabs <= spltol * sqrt(abs(d(i)))*sqrt(abs(d(i+1))) )then
                    e(i) = zero
                    e2(i) = zero
                    isplit( nsplit ) = i
                    nsplit = nsplit + 1
                 end if
              end do
           endif
           isplit( nsplit ) = n
           return
     end subroutine stdlib_dlarra

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$larra( n, d, e, e2, spltol, tnrm,nsplit, isplit, info )
     !! Compute the splitting points with threshold SPLTOL.
     !! DLARRA: sets any "small" off-diagonal elements to zero.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info, nsplit
           integer(ilp), intent(in) :: n
           real(${rk}$), intent(in) :: spltol, tnrm
           ! Array Arguments 
           integer(ilp), intent(out) :: isplit(*)
           real(${rk}$), intent(in) :: d(*)
           real(${rk}$), intent(inout) :: e(*), e2(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i
           real(${rk}$) :: eabs, tmp1
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           ! compute splitting points
           nsplit = 1
           if(spltol<zero) then
              ! criterion based on absolute off-diagonal value
              tmp1 = abs(spltol)* tnrm
              do i = 1, n-1
                 eabs = abs( e(i) )
                 if( eabs <= tmp1) then
                    e(i) = zero
                    e2(i) = zero
                    isplit( nsplit ) = i
                    nsplit = nsplit + 1
                 end if
              end do
           else
              ! criterion that guarantees relative accuracy
              do i = 1, n-1
                 eabs = abs( e(i) )
                 if( eabs <= spltol * sqrt(abs(d(i)))*sqrt(abs(d(i+1))) )then
                    e(i) = zero
                    e2(i) = zero
                    isplit( nsplit ) = i
                    nsplit = nsplit + 1
                 end if
              end do
           endif
           isplit( nsplit ) = n
           return
     end subroutine stdlib_${ri}$larra

#:endif
#:endfor











     pure subroutine stdlib_slagts( job, n, a, b, c, d, in, y, tol, info )
     !! SLAGTS may be used to solve one of the systems of equations
     !! (T - lambda*I)*x = y   or   (T - lambda*I)**T*x = y,
     !! where T is an n by n tridiagonal matrix, for x, following the
     !! factorization of (T - lambda*I) as
     !! (T - lambda*I) = P*L*U ,
     !! by routine SLAGTF. The choice of equation to be solved is
     !! controlled by the argument JOB, and in each case there is an option
     !! to perturb zero or very small diagonal elements of U, this option
     !! being intended for use in applications such as inverse iteration.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: job, n
           real(sp), intent(inout) :: tol
           ! Array Arguments 
           integer(ilp), intent(in) :: in(*)
           real(sp), intent(in) :: a(*), b(*), c(*), d(*)
           real(sp), intent(inout) :: y(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: k
           real(sp) :: absak, ak, bignum, eps, pert, sfmin, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           if( ( abs( job )>2 ) .or. ( job==0 ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SLAGTS', -info )
              return
           end if
           if( n==0 )return
           eps = stdlib_slamch( 'EPSILON' )
           sfmin = stdlib_slamch( 'SAFE MINIMUM' )
           bignum = one / sfmin
           if( job<0 ) then
              if( tol<=zero ) then
                 tol = abs( a( 1 ) )
                 if( n>1 )tol = max( tol, abs( a( 2 ) ), abs( b( 1 ) ) )
                 do k = 3, n
                    tol = max( tol, abs( a( k ) ), abs( b( k-1 ) ),abs( d( k-2 ) ) )
                 end do
                 tol = tol*eps
                 if( tol==zero )tol = eps
              end if
           end if
           if( abs( job )==1 ) then
              do k = 2, n
                 if( in( k-1 )==0 ) then
                    y( k ) = y( k ) - c( k-1 )*y( k-1 )
                 else
                    temp = y( k-1 )
                    y( k-1 ) = y( k )
                    y( k ) = temp - c( k-1 )*y( k )
                 end if
              end do
              if( job==1 ) then
                 loop_30: do k = n, 1, -1
                    if( k<=n-2 ) then
                       temp = y( k ) - b( k )*y( k+1 ) - d( k )*y( k+2 )
                    else if( k==n-1 ) then
                       temp = y( k ) - b( k )*y( k+1 )
                    else
                       temp = y( k )
                    end if
                    ak = a( k )
                    absak = abs( ak )
                    if( absak<one ) then
                       if( absak<sfmin ) then
                          if( absak==zero .or. abs( temp )*sfmin>absak )then
                             info = k
                             return
                          else
                             temp = temp*bignum
                             ak = ak*bignum
                          end if
                       else if( abs( temp )>absak*bignum ) then
                          info = k
                          return
                       end if
                    end if
                    y( k ) = temp / ak
                 end do loop_30
              else
                 loop_50: do k = n, 1, -1
                    if( k<=n-2 ) then
                       temp = y( k ) - b( k )*y( k+1 ) - d( k )*y( k+2 )
                    else if( k==n-1 ) then
                       temp = y( k ) - b( k )*y( k+1 )
                    else
                       temp = y( k )
                    end if
                    ak = a( k )
                    pert = sign( tol, ak )
                    40 continue
                    absak = abs( ak )
                    if( absak<one ) then
                       if( absak<sfmin ) then
                          if( absak==zero .or. abs( temp )*sfmin>absak )then
                             ak = ak + pert
                             pert = 2*pert
                             go to 40
                          else
                             temp = temp*bignum
                             ak = ak*bignum
                          end if
                       else if( abs( temp )>absak*bignum ) then
                          ak = ak + pert
                          pert = 2*pert
                          go to 40
                       end if
                    end if
                    y( k ) = temp / ak
                 end do loop_50
              end if
           else
              ! come to here if  job = 2 or -2
              if( job==2 ) then
                 loop_60: do k = 1, n
                    if( k>=3 ) then
                       temp = y( k ) - b( k-1 )*y( k-1 ) - d( k-2 )*y( k-2 )
                    else if( k==2 ) then
                       temp = y( k ) - b( k-1 )*y( k-1 )
                    else
                       temp = y( k )
                    end if
                    ak = a( k )
                    absak = abs( ak )
                    if( absak<one ) then
                       if( absak<sfmin ) then
                          if( absak==zero .or. abs( temp )*sfmin>absak )then
                             info = k
                             return
                          else
                             temp = temp*bignum
                             ak = ak*bignum
                          end if
                       else if( abs( temp )>absak*bignum ) then
                          info = k
                          return
                       end if
                    end if
                    y( k ) = temp / ak
                 end do loop_60
              else
                 loop_80: do k = 1, n
                    if( k>=3 ) then
                       temp = y( k ) - b( k-1 )*y( k-1 ) - d( k-2 )*y( k-2 )
                    else if( k==2 ) then
                       temp = y( k ) - b( k-1 )*y( k-1 )
                    else
                       temp = y( k )
                    end if
                    ak = a( k )
                    pert = sign( tol, ak )
                    70 continue
                    absak = abs( ak )
                    if( absak<one ) then
                       if( absak<sfmin ) then
                          if( absak==zero .or. abs( temp )*sfmin>absak )then
                             ak = ak + pert
                             pert = 2*pert
                             go to 70
                          else
                             temp = temp*bignum
                             ak = ak*bignum
                          end if
                       else if( abs( temp )>absak*bignum ) then
                          ak = ak + pert
                          pert = 2*pert
                          go to 70
                       end if
                    end if
                    y( k ) = temp / ak
                 end do loop_80
              end if
              do k = n, 2, -1
                 if( in( k-1 )==0 ) then
                    y( k-1 ) = y( k-1 ) - c( k-1 )*y( k )
                 else
                    temp = y( k-1 )
                    y( k-1 ) = y( k )
                    y( k ) = temp - c( k-1 )*y( k )
                 end if
              end do
           end if
     end subroutine stdlib_slagts

     pure subroutine stdlib_dlagts( job, n, a, b, c, d, in, y, tol, info )
     !! DLAGTS may be used to solve one of the systems of equations
     !! (T - lambda*I)*x = y   or   (T - lambda*I)**T*x = y,
     !! where T is an n by n tridiagonal matrix, for x, following the
     !! factorization of (T - lambda*I) as
     !! (T - lambda*I) = P*L*U ,
     !! by routine DLAGTF. The choice of equation to be solved is
     !! controlled by the argument JOB, and in each case there is an option
     !! to perturb zero or very small diagonal elements of U, this option
     !! being intended for use in applications such as inverse iteration.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: job, n
           real(dp), intent(inout) :: tol
           ! Array Arguments 
           integer(ilp), intent(in) :: in(*)
           real(dp), intent(in) :: a(*), b(*), c(*), d(*)
           real(dp), intent(inout) :: y(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: k
           real(dp) :: absak, ak, bignum, eps, pert, sfmin, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           if( ( abs( job )>2 ) .or. ( job==0 ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAGTS', -info )
              return
           end if
           if( n==0 )return
           eps = stdlib_dlamch( 'EPSILON' )
           sfmin = stdlib_dlamch( 'SAFE MINIMUM' )
           bignum = one / sfmin
           if( job<0 ) then
              if( tol<=zero ) then
                 tol = abs( a( 1 ) )
                 if( n>1 )tol = max( tol, abs( a( 2 ) ), abs( b( 1 ) ) )
                 do k = 3, n
                    tol = max( tol, abs( a( k ) ), abs( b( k-1 ) ),abs( d( k-2 ) ) )
                 end do
                 tol = tol*eps
                 if( tol==zero )tol = eps
              end if
           end if
           if( abs( job )==1 ) then
              do k = 2, n
                 if( in( k-1 )==0 ) then
                    y( k ) = y( k ) - c( k-1 )*y( k-1 )
                 else
                    temp = y( k-1 )
                    y( k-1 ) = y( k )
                    y( k ) = temp - c( k-1 )*y( k )
                 end if
              end do
              if( job==1 ) then
                 loop_30: do k = n, 1, -1
                    if( k<=n-2 ) then
                       temp = y( k ) - b( k )*y( k+1 ) - d( k )*y( k+2 )
                    else if( k==n-1 ) then
                       temp = y( k ) - b( k )*y( k+1 )
                    else
                       temp = y( k )
                    end if
                    ak = a( k )
                    absak = abs( ak )
                    if( absak<one ) then
                       if( absak<sfmin ) then
                          if( absak==zero .or. abs( temp )*sfmin>absak )then
                             info = k
                             return
                          else
                             temp = temp*bignum
                             ak = ak*bignum
                          end if
                       else if( abs( temp )>absak*bignum ) then
                          info = k
                          return
                       end if
                    end if
                    y( k ) = temp / ak
                 end do loop_30
              else
                 loop_50: do k = n, 1, -1
                    if( k<=n-2 ) then
                       temp = y( k ) - b( k )*y( k+1 ) - d( k )*y( k+2 )
                    else if( k==n-1 ) then
                       temp = y( k ) - b( k )*y( k+1 )
                    else
                       temp = y( k )
                    end if
                    ak = a( k )
                    pert = sign( tol, ak )
                    40 continue
                    absak = abs( ak )
                    if( absak<one ) then
                       if( absak<sfmin ) then
                          if( absak==zero .or. abs( temp )*sfmin>absak )then
                             ak = ak + pert
                             pert = 2*pert
                             go to 40
                          else
                             temp = temp*bignum
                             ak = ak*bignum
                          end if
                       else if( abs( temp )>absak*bignum ) then
                          ak = ak + pert
                          pert = 2*pert
                          go to 40
                       end if
                    end if
                    y( k ) = temp / ak
                 end do loop_50
              end if
           else
              ! come to here if  job = 2 or -2
              if( job==2 ) then
                 loop_60: do k = 1, n
                    if( k>=3 ) then
                       temp = y( k ) - b( k-1 )*y( k-1 ) - d( k-2 )*y( k-2 )
                    else if( k==2 ) then
                       temp = y( k ) - b( k-1 )*y( k-1 )
                    else
                       temp = y( k )
                    end if
                    ak = a( k )
                    absak = abs( ak )
                    if( absak<one ) then
                       if( absak<sfmin ) then
                          if( absak==zero .or. abs( temp )*sfmin>absak )then
                             info = k
                             return
                          else
                             temp = temp*bignum
                             ak = ak*bignum
                          end if
                       else if( abs( temp )>absak*bignum ) then
                          info = k
                          return
                       end if
                    end if
                    y( k ) = temp / ak
                 end do loop_60
              else
                 loop_80: do k = 1, n
                    if( k>=3 ) then
                       temp = y( k ) - b( k-1 )*y( k-1 ) - d( k-2 )*y( k-2 )
                    else if( k==2 ) then
                       temp = y( k ) - b( k-1 )*y( k-1 )
                    else
                       temp = y( k )
                    end if
                    ak = a( k )
                    pert = sign( tol, ak )
                    70 continue
                    absak = abs( ak )
                    if( absak<one ) then
                       if( absak<sfmin ) then
                          if( absak==zero .or. abs( temp )*sfmin>absak )then
                             ak = ak + pert
                             pert = 2*pert
                             go to 70
                          else
                             temp = temp*bignum
                             ak = ak*bignum
                          end if
                       else if( abs( temp )>absak*bignum ) then
                          ak = ak + pert
                          pert = 2*pert
                          go to 70
                       end if
                    end if
                    y( k ) = temp / ak
                 end do loop_80
              end if
              do k = n, 2, -1
                 if( in( k-1 )==0 ) then
                    y( k-1 ) = y( k-1 ) - c( k-1 )*y( k )
                 else
                    temp = y( k-1 )
                    y( k-1 ) = y( k )
                    y( k ) = temp - c( k-1 )*y( k )
                 end if
              end do
           end if
     end subroutine stdlib_dlagts

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$lagts( job, n, a, b, c, d, in, y, tol, info )
     !! DLAGTS: may be used to solve one of the systems of equations
     !! (T - lambda*I)*x = y   or   (T - lambda*I)**T*x = y,
     !! where T is an n by n tridiagonal matrix, for x, following the
     !! factorization of (T - lambda*I) as
     !! (T - lambda*I) = P*L*U ,
     !! by routine DLAGTF. The choice of equation to be solved is
     !! controlled by the argument JOB, and in each case there is an option
     !! to perturb zero or very small diagonal elements of U, this option
     !! being intended for use in applications such as inverse iteration.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: job, n
           real(${rk}$), intent(inout) :: tol
           ! Array Arguments 
           integer(ilp), intent(in) :: in(*)
           real(${rk}$), intent(in) :: a(*), b(*), c(*), d(*)
           real(${rk}$), intent(inout) :: y(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: k
           real(${rk}$) :: absak, ak, bignum, eps, pert, sfmin, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           if( ( abs( job )>2 ) .or. ( job==0 ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAGTS', -info )
              return
           end if
           if( n==0 )return
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           sfmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           bignum = one / sfmin
           if( job<0 ) then
              if( tol<=zero ) then
                 tol = abs( a( 1 ) )
                 if( n>1 )tol = max( tol, abs( a( 2 ) ), abs( b( 1 ) ) )
                 do k = 3, n
                    tol = max( tol, abs( a( k ) ), abs( b( k-1 ) ),abs( d( k-2 ) ) )
                 end do
                 tol = tol*eps
                 if( tol==zero )tol = eps
              end if
           end if
           if( abs( job )==1 ) then
              do k = 2, n
                 if( in( k-1 )==0 ) then
                    y( k ) = y( k ) - c( k-1 )*y( k-1 )
                 else
                    temp = y( k-1 )
                    y( k-1 ) = y( k )
                    y( k ) = temp - c( k-1 )*y( k )
                 end if
              end do
              if( job==1 ) then
                 loop_30: do k = n, 1, -1
                    if( k<=n-2 ) then
                       temp = y( k ) - b( k )*y( k+1 ) - d( k )*y( k+2 )
                    else if( k==n-1 ) then
                       temp = y( k ) - b( k )*y( k+1 )
                    else
                       temp = y( k )
                    end if
                    ak = a( k )
                    absak = abs( ak )
                    if( absak<one ) then
                       if( absak<sfmin ) then
                          if( absak==zero .or. abs( temp )*sfmin>absak )then
                             info = k
                             return
                          else
                             temp = temp*bignum
                             ak = ak*bignum
                          end if
                       else if( abs( temp )>absak*bignum ) then
                          info = k
                          return
                       end if
                    end if
                    y( k ) = temp / ak
                 end do loop_30
              else
                 loop_50: do k = n, 1, -1
                    if( k<=n-2 ) then
                       temp = y( k ) - b( k )*y( k+1 ) - d( k )*y( k+2 )
                    else if( k==n-1 ) then
                       temp = y( k ) - b( k )*y( k+1 )
                    else
                       temp = y( k )
                    end if
                    ak = a( k )
                    pert = sign( tol, ak )
                    40 continue
                    absak = abs( ak )
                    if( absak<one ) then
                       if( absak<sfmin ) then
                          if( absak==zero .or. abs( temp )*sfmin>absak )then
                             ak = ak + pert
                             pert = 2*pert
                             go to 40
                          else
                             temp = temp*bignum
                             ak = ak*bignum
                          end if
                       else if( abs( temp )>absak*bignum ) then
                          ak = ak + pert
                          pert = 2*pert
                          go to 40
                       end if
                    end if
                    y( k ) = temp / ak
                 end do loop_50
              end if
           else
              ! come to here if  job = 2 or -2
              if( job==2 ) then
                 loop_60: do k = 1, n
                    if( k>=3 ) then
                       temp = y( k ) - b( k-1 )*y( k-1 ) - d( k-2 )*y( k-2 )
                    else if( k==2 ) then
                       temp = y( k ) - b( k-1 )*y( k-1 )
                    else
                       temp = y( k )
                    end if
                    ak = a( k )
                    absak = abs( ak )
                    if( absak<one ) then
                       if( absak<sfmin ) then
                          if( absak==zero .or. abs( temp )*sfmin>absak )then
                             info = k
                             return
                          else
                             temp = temp*bignum
                             ak = ak*bignum
                          end if
                       else if( abs( temp )>absak*bignum ) then
                          info = k
                          return
                       end if
                    end if
                    y( k ) = temp / ak
                 end do loop_60
              else
                 loop_80: do k = 1, n
                    if( k>=3 ) then
                       temp = y( k ) - b( k-1 )*y( k-1 ) - d( k-2 )*y( k-2 )
                    else if( k==2 ) then
                       temp = y( k ) - b( k-1 )*y( k-1 )
                    else
                       temp = y( k )
                    end if
                    ak = a( k )
                    pert = sign( tol, ak )
                    70 continue
                    absak = abs( ak )
                    if( absak<one ) then
                       if( absak<sfmin ) then
                          if( absak==zero .or. abs( temp )*sfmin>absak )then
                             ak = ak + pert
                             pert = 2*pert
                             go to 70
                          else
                             temp = temp*bignum
                             ak = ak*bignum
                          end if
                       else if( abs( temp )>absak*bignum ) then
                          ak = ak + pert
                          pert = 2*pert
                          go to 70
                       end if
                    end if
                    y( k ) = temp / ak
                 end do loop_80
              end if
              do k = n, 2, -1
                 if( in( k-1 )==0 ) then
                    y( k-1 ) = y( k-1 ) - c( k-1 )*y( k )
                 else
                    temp = y( k-1 )
                    y( k-1 ) = y( k )
                    y( k ) = temp - c( k-1 )*y( k )
                 end if
              end do
           end if
     end subroutine stdlib_${ri}$lagts

#:endif
#:endfor



     pure subroutine stdlib_slae2( a, b, c, rt1, rt2 )
     !! SLAE2 computes the eigenvalues of a 2-by-2 symmetric matrix
     !! [  A   B  ]
     !! [  B   C  ].
     !! On return, RT1 is the eigenvalue of larger absolute value, and RT2
     !! is the eigenvalue of smaller absolute value.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(sp), intent(in) :: a, b, c
           real(sp), intent(out) :: rt1, rt2
       ! =====================================================================
           
           
           
           
           ! Local Scalars 
           real(sp) :: ab, acmn, acmx, adf, df, rt, sm, tb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! compute the eigenvalues
           sm = a + c
           df = a - c
           adf = abs( df )
           tb = b + b
           ab = abs( tb )
           if( abs( a )>abs( c ) ) then
              acmx = a
              acmn = c
           else
              acmx = c
              acmn = a
           end if
           if( adf>ab ) then
              rt = adf*sqrt( one+( ab / adf )**2 )
           else if( adf<ab ) then
              rt = ab*sqrt( one+( adf / ab )**2 )
           else
              ! includes case ab=adf=0
              rt = ab*sqrt( two )
           end if
           if( sm<zero ) then
              rt1 = half*( sm-rt )
              ! order of execution important.
              ! to get fully accurate smaller eigenvalue,
              ! next line needs to be executed in higher precision.
              rt2 = ( acmx / rt1 )*acmn - ( b / rt1 )*b
           else if( sm>zero ) then
              rt1 = half*( sm+rt )
              ! order of execution important.
              ! to get fully accurate smaller eigenvalue,
              ! next line needs to be executed in higher precision.
              rt2 = ( acmx / rt1 )*acmn - ( b / rt1 )*b
           else
              ! includes case rt1 = rt2 = 0
              rt1 = half*rt
              rt2 = -half*rt
           end if
           return
     end subroutine stdlib_slae2

     pure subroutine stdlib_dlae2( a, b, c, rt1, rt2 )
     !! DLAE2 computes the eigenvalues of a 2-by-2 symmetric matrix
     !! [  A   B  ]
     !! [  B   C  ].
     !! On return, RT1 is the eigenvalue of larger absolute value, and RT2
     !! is the eigenvalue of smaller absolute value.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(dp), intent(in) :: a, b, c
           real(dp), intent(out) :: rt1, rt2
       ! =====================================================================
           
           
           
           
           ! Local Scalars 
           real(dp) :: ab, acmn, acmx, adf, df, rt, sm, tb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! compute the eigenvalues
           sm = a + c
           df = a - c
           adf = abs( df )
           tb = b + b
           ab = abs( tb )
           if( abs( a )>abs( c ) ) then
              acmx = a
              acmn = c
           else
              acmx = c
              acmn = a
           end if
           if( adf>ab ) then
              rt = adf*sqrt( one+( ab / adf )**2 )
           else if( adf<ab ) then
              rt = ab*sqrt( one+( adf / ab )**2 )
           else
              ! includes case ab=adf=0
              rt = ab*sqrt( two )
           end if
           if( sm<zero ) then
              rt1 = half*( sm-rt )
              ! order of execution important.
              ! to get fully accurate smaller eigenvalue,
              ! next line needs to be executed in higher precision.
              rt2 = ( acmx / rt1 )*acmn - ( b / rt1 )*b
           else if( sm>zero ) then
              rt1 = half*( sm+rt )
              ! order of execution important.
              ! to get fully accurate smaller eigenvalue,
              ! next line needs to be executed in higher precision.
              rt2 = ( acmx / rt1 )*acmn - ( b / rt1 )*b
           else
              ! includes case rt1 = rt2 = 0
              rt1 = half*rt
              rt2 = -half*rt
           end if
           return
     end subroutine stdlib_dlae2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$lae2( a, b, c, rt1, rt2 )
     !! DLAE2:  computes the eigenvalues of a 2-by-2 symmetric matrix
     !! [  A   B  ]
     !! [  B   C  ].
     !! On return, RT1 is the eigenvalue of larger absolute value, and RT2
     !! is the eigenvalue of smaller absolute value.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: a, b, c
           real(${rk}$), intent(out) :: rt1, rt2
       ! =====================================================================
           
           
           
           
           ! Local Scalars 
           real(${rk}$) :: ab, acmn, acmx, adf, df, rt, sm, tb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! compute the eigenvalues
           sm = a + c
           df = a - c
           adf = abs( df )
           tb = b + b
           ab = abs( tb )
           if( abs( a )>abs( c ) ) then
              acmx = a
              acmn = c
           else
              acmx = c
              acmn = a
           end if
           if( adf>ab ) then
              rt = adf*sqrt( one+( ab / adf )**2 )
           else if( adf<ab ) then
              rt = ab*sqrt( one+( adf / ab )**2 )
           else
              ! includes case ab=adf=0
              rt = ab*sqrt( two )
           end if
           if( sm<zero ) then
              rt1 = half*( sm-rt )
              ! order of execution important.
              ! to get fully accurate smaller eigenvalue,
              ! next line needs to be executed in higher precision.
              rt2 = ( acmx / rt1 )*acmn - ( b / rt1 )*b
           else if( sm>zero ) then
              rt1 = half*( sm+rt )
              ! order of execution important.
              ! to get fully accurate smaller eigenvalue,
              ! next line needs to be executed in higher precision.
              rt2 = ( acmx / rt1 )*acmn - ( b / rt1 )*b
           else
              ! includes case rt1 = rt2 = 0
              rt1 = half*rt
              rt2 = -half*rt
           end if
           return
     end subroutine stdlib_${ri}$lae2

#:endif
#:endfor



     pure subroutine stdlib_slaed1( n, d, q, ldq, indxq, rho, cutpnt, work, iwork,info )
     !! SLAED1 computes the updated eigensystem of a diagonal
     !! matrix after modification by a rank-one symmetric matrix.  This
     !! routine is used only for the eigenproblem which requires all
     !! eigenvalues and eigenvectors of a tridiagonal matrix.  SLAED7 handles
     !! the case in which eigenvalues only or eigenvalues and eigenvectors
     !! of a full symmetric matrix (which was reduced to tridiagonal form)
     !! are desired.
     !! T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)
     !! where Z = Q**T*u, u is a vector of length N with ones in the
     !! CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
     !! The eigenvectors of the original matrix are stored in Q, and the
     !! eigenvalues are in D.  The algorithm consists of three stages:
     !! The first stage consists of deflating the size of the problem
     !! when there are multiple eigenvalues or if there is a zero in
     !! the Z vector.  For each such occurrence the dimension of the
     !! secular equation problem is reduced by one.  This stage is
     !! performed by the routine SLAED2.
     !! The second stage consists of calculating the updated
     !! eigenvalues. This is done by finding the roots of the secular
     !! equation via the routine SLAED4 (as called by SLAED3).
     !! This routine also calculates the eigenvectors of the current
     !! problem.
     !! The final stage consists of computing the updated eigenvectors
     !! directly using the updated eigenvalues.  The eigenvectors for
     !! the current problem are multiplied with the eigenvectors from
     !! the overall problem.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: cutpnt, ldq, n
           integer(ilp), intent(out) :: info
           real(sp), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(inout) :: indxq(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: d(*), q(ldq,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: coltyp, cpp1, i, idlmda, indx, indxc, indxp, iq2, is, iw, iz, k, n1, &
                     n2
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( ldq<max( 1, n ) ) then
              info = -4
           else if( min( 1, n / 2 )>cutpnt .or. ( n / 2 )<cutpnt ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SLAED1', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! the following values are integer pointers which indicate
           ! the portion of the workspace
           ! used by a particular array in stdlib_slaed2 and stdlib_slaed3.
           iz = 1
           idlmda = iz + n
           iw = idlmda + n
           iq2 = iw + n
           indx = 1
           indxc = indx + n
           coltyp = indxc + n
           indxp = coltyp + n
           ! form the z-vector which consists of the last row of q_1 and the
           ! first row of q_2.
           call stdlib_scopy( cutpnt, q( cutpnt, 1 ), ldq, work( iz ), 1 )
           cpp1 = cutpnt + 1
           call stdlib_scopy( n-cutpnt, q( cpp1, cpp1 ), ldq, work( iz+cutpnt ), 1 )
           ! deflate eigenvalues.
           call stdlib_slaed2( k, n, cutpnt, d, q, ldq, indxq, rho, work( iz ),work( idlmda ), &
           work( iw ), work( iq2 ),iwork( indx ), iwork( indxc ), iwork( indxp ),iwork( coltyp ), &
                     info )
           if( info/=0 )go to 20
           ! solve secular equation.
           if( k/=0 ) then
              is = ( iwork( coltyp )+iwork( coltyp+1 ) )*cutpnt +( iwork( coltyp+1 )+iwork( &
                        coltyp+2 ) )*( n-cutpnt ) + iq2
              call stdlib_slaed3( k, n, cutpnt, d, q, ldq, rho, work( idlmda ),work( iq2 ), iwork(&
                         indxc ), iwork( coltyp ),work( iw ), work( is ), info )
              if( info/=0 )go to 20
           ! prepare the indxq sorting permutation.
              n1 = k
              n2 = n - k
              call stdlib_slamrg( n1, n2, d, 1, -1, indxq )
           else
              do i = 1, n
                 indxq( i ) = i
              end do
           end if
           20 continue
           return
     end subroutine stdlib_slaed1

     pure subroutine stdlib_dlaed1( n, d, q, ldq, indxq, rho, cutpnt, work, iwork,info )
     !! DLAED1 computes the updated eigensystem of a diagonal
     !! matrix after modification by a rank-one symmetric matrix.  This
     !! routine is used only for the eigenproblem which requires all
     !! eigenvalues and eigenvectors of a tridiagonal matrix.  DLAED7 handles
     !! the case in which eigenvalues only or eigenvalues and eigenvectors
     !! of a full symmetric matrix (which was reduced to tridiagonal form)
     !! are desired.
     !! T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)
     !! where Z = Q**T*u, u is a vector of length N with ones in the
     !! CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
     !! The eigenvectors of the original matrix are stored in Q, and the
     !! eigenvalues are in D.  The algorithm consists of three stages:
     !! The first stage consists of deflating the size of the problem
     !! when there are multiple eigenvalues or if there is a zero in
     !! the Z vector.  For each such occurrence the dimension of the
     !! secular equation problem is reduced by one.  This stage is
     !! performed by the routine DLAED2.
     !! The second stage consists of calculating the updated
     !! eigenvalues. This is done by finding the roots of the secular
     !! equation via the routine DLAED4 (as called by DLAED3).
     !! This routine also calculates the eigenvectors of the current
     !! problem.
     !! The final stage consists of computing the updated eigenvectors
     !! directly using the updated eigenvalues.  The eigenvectors for
     !! the current problem are multiplied with the eigenvectors from
     !! the overall problem.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: cutpnt, ldq, n
           integer(ilp), intent(out) :: info
           real(dp), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(inout) :: indxq(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(inout) :: d(*), q(ldq,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: coltyp, i, idlmda, indx, indxc, indxp, iq2, is, iw, iz, k, n1, n2, &
                     zpp1
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( ldq<max( 1, n ) ) then
              info = -4
           else if( min( 1, n / 2 )>cutpnt .or. ( n / 2 )<cutpnt ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED1', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! the following values are integer pointers which indicate
           ! the portion of the workspace
           ! used by a particular array in stdlib_dlaed2 and stdlib_dlaed3.
           iz = 1
           idlmda = iz + n
           iw = idlmda + n
           iq2 = iw + n
           indx = 1
           indxc = indx + n
           coltyp = indxc + n
           indxp = coltyp + n
           ! form the z-vector which consists of the last row of q_1 and the
           ! first row of q_2.
           call stdlib_dcopy( cutpnt, q( cutpnt, 1 ), ldq, work( iz ), 1 )
           zpp1 = cutpnt + 1
           call stdlib_dcopy( n-cutpnt, q( zpp1, zpp1 ), ldq, work( iz+cutpnt ), 1 )
           ! deflate eigenvalues.
           call stdlib_dlaed2( k, n, cutpnt, d, q, ldq, indxq, rho, work( iz ),work( idlmda ), &
           work( iw ), work( iq2 ),iwork( indx ), iwork( indxc ), iwork( indxp ),iwork( coltyp ), &
                     info )
           if( info/=0 )go to 20
           ! solve secular equation.
           if( k/=0 ) then
              is = ( iwork( coltyp )+iwork( coltyp+1 ) )*cutpnt +( iwork( coltyp+1 )+iwork( &
                        coltyp+2 ) )*( n-cutpnt ) + iq2
              call stdlib_dlaed3( k, n, cutpnt, d, q, ldq, rho, work( idlmda ),work( iq2 ), iwork(&
                         indxc ), iwork( coltyp ),work( iw ), work( is ), info )
              if( info/=0 )go to 20
           ! prepare the indxq sorting permutation.
              n1 = k
              n2 = n - k
              call stdlib_dlamrg( n1, n2, d, 1, -1, indxq )
           else
              do i = 1, n
                 indxq( i ) = i
              end do
           end if
           20 continue
           return
     end subroutine stdlib_dlaed1

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laed1( n, d, q, ldq, indxq, rho, cutpnt, work, iwork,info )
     !! DLAED1: computes the updated eigensystem of a diagonal
     !! matrix after modification by a rank-one symmetric matrix.  This
     !! routine is used only for the eigenproblem which requires all
     !! eigenvalues and eigenvectors of a tridiagonal matrix.  DLAED7 handles
     !! the case in which eigenvalues only or eigenvalues and eigenvectors
     !! of a full symmetric matrix (which was reduced to tridiagonal form)
     !! are desired.
     !! T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)
     !! where Z = Q**T*u, u is a vector of length N with ones in the
     !! CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
     !! The eigenvectors of the original matrix are stored in Q, and the
     !! eigenvalues are in D.  The algorithm consists of three stages:
     !! The first stage consists of deflating the size of the problem
     !! when there are multiple eigenvalues or if there is a zero in
     !! the Z vector.  For each such occurrence the dimension of the
     !! secular equation problem is reduced by one.  This stage is
     !! performed by the routine DLAED2.
     !! The second stage consists of calculating the updated
     !! eigenvalues. This is done by finding the roots of the secular
     !! equation via the routine DLAED4 (as called by DLAED3).
     !! This routine also calculates the eigenvectors of the current
     !! problem.
     !! The final stage consists of computing the updated eigenvectors
     !! directly using the updated eigenvalues.  The eigenvectors for
     !! the current problem are multiplied with the eigenvectors from
     !! the overall problem.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: cutpnt, ldq, n
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(inout) :: indxq(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: d(*), q(ldq,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: coltyp, i, idlmda, indx, indxc, indxp, iq2, is, iw, iz, k, n1, n2, &
                     zpp1
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( ldq<max( 1, n ) ) then
              info = -4
           else if( min( 1, n / 2 )>cutpnt .or. ( n / 2 )<cutpnt ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED1', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! the following values are integer pointers which indicate
           ! the portion of the workspace
           ! used by a particular array in stdlib_${ri}$laed2 and stdlib_${ri}$laed3.
           iz = 1
           idlmda = iz + n
           iw = idlmda + n
           iq2 = iw + n
           indx = 1
           indxc = indx + n
           coltyp = indxc + n
           indxp = coltyp + n
           ! form the z-vector which consists of the last row of q_1 and the
           ! first row of q_2.
           call stdlib_${ri}$copy( cutpnt, q( cutpnt, 1 ), ldq, work( iz ), 1 )
           zpp1 = cutpnt + 1
           call stdlib_${ri}$copy( n-cutpnt, q( zpp1, zpp1 ), ldq, work( iz+cutpnt ), 1 )
           ! deflate eigenvalues.
           call stdlib_${ri}$laed2( k, n, cutpnt, d, q, ldq, indxq, rho, work( iz ),work( idlmda ), &
           work( iw ), work( iq2 ),iwork( indx ), iwork( indxc ), iwork( indxp ),iwork( coltyp ), &
                     info )
           if( info/=0 )go to 20
           ! solve secular equation.
           if( k/=0 ) then
              is = ( iwork( coltyp )+iwork( coltyp+1 ) )*cutpnt +( iwork( coltyp+1 )+iwork( &
                        coltyp+2 ) )*( n-cutpnt ) + iq2
              call stdlib_${ri}$laed3( k, n, cutpnt, d, q, ldq, rho, work( idlmda ),work( iq2 ), iwork(&
                         indxc ), iwork( coltyp ),work( iw ), work( is ), info )
              if( info/=0 )go to 20
           ! prepare the indxq sorting permutation.
              n1 = k
              n2 = n - k
              call stdlib_${ri}$lamrg( n1, n2, d, 1, -1, indxq )
           else
              do i = 1, n
                 indxq( i ) = i
              end do
           end if
           20 continue
           return
     end subroutine stdlib_${ri}$laed1

#:endif
#:endfor



     pure subroutine stdlib_slar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc, &
     !! SLAR1V computes the (scaled) r-th column of the inverse of
     !! the sumbmatrix in rows B1 through BN of the tridiagonal matrix
     !! L D L**T - sigma I. When sigma is close to an eigenvalue, the
     !! computed vector is an accurate eigenvector. Usually, r corresponds
     !! to the index where the eigenvector is largest in magnitude.
     !! The following steps accomplish this computation :
     !! (a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,
     !! (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,
     !! (c) Computation of the diagonal elements of the inverse of
     !! L D L**T - sigma I by combining the above transforms, and choosing
     !! r as the index where the diagonal of the inverse is (one of the)
     !! largest in magnitude.
     !! (d) Computation of the (scaled) r-th column of the inverse using the
     !! twisted factorization obtained by combining the top part of the
     !! the stationary and the bottom part of the progressive transform.
               negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantnc
           integer(ilp), intent(in) :: b1, bn, n
           integer(ilp), intent(out) :: negcnt
           integer(ilp), intent(inout) :: r
           real(sp), intent(in) :: gaptol, lambda, pivmin
           real(sp), intent(out) :: mingma, nrminv, resid, rqcorr, ztz
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*)
           real(sp), intent(in) :: d(*), l(*), ld(*), lld(*)
           real(sp), intent(out) :: work(*)
           real(sp), intent(inout) :: z(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: sawnan1, sawnan2
           integer(ilp) :: i, indlpl, indp, inds, indumn, neg1, neg2, r1, r2
           real(sp) :: dminus, dplus, eps, s, tmp
           ! Intrinsic Functions 
           ! Executable Statements 
           eps = stdlib_slamch( 'PRECISION' )
           if( r==0 ) then
              r1 = b1
              r2 = bn
           else
              r1 = r
              r2 = r
           end if
           ! storage for lplus
           indlpl = 0
           ! storage for uminus
           indumn = n
           inds = 2*n + 1
           indp = 3*n + 1
           if( b1==1 ) then
              work( inds ) = zero
           else
              work( inds+b1-1 ) = lld( b1-1 )
           end if
           ! compute the stationary transform (using the differential form)
           ! until the index r2.
           sawnan1 = .false.
           neg1 = 0
           s = work( inds+b1-1 ) - lambda
           do i = b1, r1 - 1
              dplus = d( i ) + s
              work( indlpl+i ) = ld( i ) / dplus
              if(dplus<zero) neg1 = neg1 + 1
              work( inds+i ) = s*work( indlpl+i )*l( i )
              s = work( inds+i ) - lambda
           end do
           sawnan1 = stdlib_sisnan( s )
           if( sawnan1 ) goto 60
           do i = r1, r2 - 1
              dplus = d( i ) + s
              work( indlpl+i ) = ld( i ) / dplus
              work( inds+i ) = s*work( indlpl+i )*l( i )
              s = work( inds+i ) - lambda
           end do
           sawnan1 = stdlib_sisnan( s )
           60 continue
           if( sawnan1 ) then
              ! runs a slower version of the above loop if a nan is detected
              neg1 = 0
              s = work( inds+b1-1 ) - lambda
              do i = b1, r1 - 1
                 dplus = d( i ) + s
                 if(abs(dplus)<pivmin) dplus = -pivmin
                 work( indlpl+i ) = ld( i ) / dplus
                 if(dplus<zero) neg1 = neg1 + 1
                 work( inds+i ) = s*work( indlpl+i )*l( i )
                 if( work( indlpl+i )==zero )work( inds+i ) = lld( i )
                 s = work( inds+i ) - lambda
              end do
              do i = r1, r2 - 1
                 dplus = d( i ) + s
                 if(abs(dplus)<pivmin) dplus = -pivmin
                 work( indlpl+i ) = ld( i ) / dplus
                 work( inds+i ) = s*work( indlpl+i )*l( i )
                 if( work( indlpl+i )==zero )work( inds+i ) = lld( i )
                 s = work( inds+i ) - lambda
              end do
           end if
           ! compute the progressive transform (using the differential form)
           ! until the index r1
           sawnan2 = .false.
           neg2 = 0
           work( indp+bn-1 ) = d( bn ) - lambda
           do i = bn - 1, r1, -1
              dminus = lld( i ) + work( indp+i )
              tmp = d( i ) / dminus
              if(dminus<zero) neg2 = neg2 + 1
              work( indumn+i ) = l( i )*tmp
              work( indp+i-1 ) = work( indp+i )*tmp - lambda
           end do
           tmp = work( indp+r1-1 )
           sawnan2 = stdlib_sisnan( tmp )
           if( sawnan2 ) then
              ! runs a slower version of the above loop if a nan is detected
              neg2 = 0
              do i = bn-1, r1, -1
                 dminus = lld( i ) + work( indp+i )
                 if(abs(dminus)<pivmin) dminus = -pivmin
                 tmp = d( i ) / dminus
                 if(dminus<zero) neg2 = neg2 + 1
                 work( indumn+i ) = l( i )*tmp
                 work( indp+i-1 ) = work( indp+i )*tmp - lambda
                 if( tmp==zero )work( indp+i-1 ) = d( i ) - lambda
              end do
           end if
           ! find the index (from r1 to r2) of the largest (in magnitude)
           ! diagonal element of the inverse
           mingma = work( inds+r1-1 ) + work( indp+r1-1 )
           if( mingma<zero ) neg1 = neg1 + 1
           if( wantnc ) then
              negcnt = neg1 + neg2
           else
              negcnt = -1
           endif
           if( abs(mingma)==zero )mingma = eps*work( inds+r1-1 )
           r = r1
           do i = r1, r2 - 1
              tmp = work( inds+i ) + work( indp+i )
              if( tmp==zero )tmp = eps*work( inds+i )
              if( abs( tmp )<=abs( mingma ) ) then
                 mingma = tmp
                 r = i + 1
              end if
           end do
           ! compute the fp vector: solve n^t v = e_r
           isuppz( 1 ) = b1
           isuppz( 2 ) = bn
           z( r ) = one
           ztz = one
           ! compute the fp vector upwards from r
           if( .not.sawnan1 .and. .not.sawnan2 ) then
              do i = r-1, b1, -1
                 z( i ) = -( work( indlpl+i )*z( i+1 ) )
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i ) = zero
                    isuppz( 1 ) = i + 1
                    goto 220
                 endif
                 ztz = ztz + z( i )*z( i )
              end do
              220 continue
           else
              ! run slower loop if nan occurred.
              do i = r - 1, b1, -1
                 if( z( i+1 )==zero ) then
                    z( i ) = -( ld( i+1 ) / ld( i ) )*z( i+2 )
                 else
                    z( i ) = -( work( indlpl+i )*z( i+1 ) )
                 end if
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i ) = zero
                    isuppz( 1 ) = i + 1
                    go to 240
                 end if
                 ztz = ztz + z( i )*z( i )
              end do
              240 continue
           endif
           ! compute the fp vector downwards from r in blocks of size blksiz
           if( .not.sawnan1 .and. .not.sawnan2 ) then
              do i = r, bn-1
                 z( i+1 ) = -( work( indumn+i )*z( i ) )
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i+1 ) = zero
                    isuppz( 2 ) = i
                    go to 260
                 end if
                 ztz = ztz + z( i+1 )*z( i+1 )
              end do
              260 continue
           else
              ! run slower loop if nan occurred.
              do i = r, bn - 1
                 if( z( i )==zero ) then
                    z( i+1 ) = -( ld( i-1 ) / ld( i ) )*z( i-1 )
                 else
                    z( i+1 ) = -( work( indumn+i )*z( i ) )
                 end if
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i+1 ) = zero
                    isuppz( 2 ) = i
                    go to 280
                 end if
                 ztz = ztz + z( i+1 )*z( i+1 )
              end do
              280 continue
           end if
           ! compute quantities for convergence test
           tmp = one / ztz
           nrminv = sqrt( tmp )
           resid = abs( mingma )*nrminv
           rqcorr = mingma*tmp
           return
     end subroutine stdlib_slar1v

     pure subroutine stdlib_dlar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc, &
     !! DLAR1V computes the (scaled) r-th column of the inverse of
     !! the sumbmatrix in rows B1 through BN of the tridiagonal matrix
     !! L D L**T - sigma I. When sigma is close to an eigenvalue, the
     !! computed vector is an accurate eigenvector. Usually, r corresponds
     !! to the index where the eigenvector is largest in magnitude.
     !! The following steps accomplish this computation :
     !! (a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,
     !! (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,
     !! (c) Computation of the diagonal elements of the inverse of
     !! L D L**T - sigma I by combining the above transforms, and choosing
     !! r as the index where the diagonal of the inverse is (one of the)
     !! largest in magnitude.
     !! (d) Computation of the (scaled) r-th column of the inverse using the
     !! twisted factorization obtained by combining the top part of the
     !! the stationary and the bottom part of the progressive transform.
               negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantnc
           integer(ilp), intent(in) :: b1, bn, n
           integer(ilp), intent(out) :: negcnt
           integer(ilp), intent(inout) :: r
           real(dp), intent(in) :: gaptol, lambda, pivmin
           real(dp), intent(out) :: mingma, nrminv, resid, rqcorr, ztz
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*)
           real(dp), intent(in) :: d(*), l(*), ld(*), lld(*)
           real(dp), intent(out) :: work(*)
           real(dp), intent(inout) :: z(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: sawnan1, sawnan2
           integer(ilp) :: i, indlpl, indp, inds, indumn, neg1, neg2, r1, r2
           real(dp) :: dminus, dplus, eps, s, tmp
           ! Intrinsic Functions 
           ! Executable Statements 
           eps = stdlib_dlamch( 'PRECISION' )
           if( r==0 ) then
              r1 = b1
              r2 = bn
           else
              r1 = r
              r2 = r
           end if
           ! storage for lplus
           indlpl = 0
           ! storage for uminus
           indumn = n
           inds = 2*n + 1
           indp = 3*n + 1
           if( b1==1 ) then
              work( inds ) = zero
           else
              work( inds+b1-1 ) = lld( b1-1 )
           end if
           ! compute the stationary transform (using the differential form)
           ! until the index r2.
           sawnan1 = .false.
           neg1 = 0
           s = work( inds+b1-1 ) - lambda
           do i = b1, r1 - 1
              dplus = d( i ) + s
              work( indlpl+i ) = ld( i ) / dplus
              if(dplus<zero) neg1 = neg1 + 1
              work( inds+i ) = s*work( indlpl+i )*l( i )
              s = work( inds+i ) - lambda
           end do
           sawnan1 = stdlib_disnan( s )
           if( sawnan1 ) goto 60
           do i = r1, r2 - 1
              dplus = d( i ) + s
              work( indlpl+i ) = ld( i ) / dplus
              work( inds+i ) = s*work( indlpl+i )*l( i )
              s = work( inds+i ) - lambda
           end do
           sawnan1 = stdlib_disnan( s )
           60 continue
           if( sawnan1 ) then
              ! runs a slower version of the above loop if a nan is detected
              neg1 = 0
              s = work( inds+b1-1 ) - lambda
              do i = b1, r1 - 1
                 dplus = d( i ) + s
                 if(abs(dplus)<pivmin) dplus = -pivmin
                 work( indlpl+i ) = ld( i ) / dplus
                 if(dplus<zero) neg1 = neg1 + 1
                 work( inds+i ) = s*work( indlpl+i )*l( i )
                 if( work( indlpl+i )==zero )work( inds+i ) = lld( i )
                 s = work( inds+i ) - lambda
              end do
              do i = r1, r2 - 1
                 dplus = d( i ) + s
                 if(abs(dplus)<pivmin) dplus = -pivmin
                 work( indlpl+i ) = ld( i ) / dplus
                 work( inds+i ) = s*work( indlpl+i )*l( i )
                 if( work( indlpl+i )==zero )work( inds+i ) = lld( i )
                 s = work( inds+i ) - lambda
              end do
           end if
           ! compute the progressive transform (using the differential form)
           ! until the index r1
           sawnan2 = .false.
           neg2 = 0
           work( indp+bn-1 ) = d( bn ) - lambda
           do i = bn - 1, r1, -1
              dminus = lld( i ) + work( indp+i )
              tmp = d( i ) / dminus
              if(dminus<zero) neg2 = neg2 + 1
              work( indumn+i ) = l( i )*tmp
              work( indp+i-1 ) = work( indp+i )*tmp - lambda
           end do
           tmp = work( indp+r1-1 )
           sawnan2 = stdlib_disnan( tmp )
           if( sawnan2 ) then
              ! runs a slower version of the above loop if a nan is detected
              neg2 = 0
              do i = bn-1, r1, -1
                 dminus = lld( i ) + work( indp+i )
                 if(abs(dminus)<pivmin) dminus = -pivmin
                 tmp = d( i ) / dminus
                 if(dminus<zero) neg2 = neg2 + 1
                 work( indumn+i ) = l( i )*tmp
                 work( indp+i-1 ) = work( indp+i )*tmp - lambda
                 if( tmp==zero )work( indp+i-1 ) = d( i ) - lambda
              end do
           end if
           ! find the index (from r1 to r2) of the largest (in magnitude)
           ! diagonal element of the inverse
           mingma = work( inds+r1-1 ) + work( indp+r1-1 )
           if( mingma<zero ) neg1 = neg1 + 1
           if( wantnc ) then
              negcnt = neg1 + neg2
           else
              negcnt = -1
           endif
           if( abs(mingma)==zero )mingma = eps*work( inds+r1-1 )
           r = r1
           do i = r1, r2 - 1
              tmp = work( inds+i ) + work( indp+i )
              if( tmp==zero )tmp = eps*work( inds+i )
              if( abs( tmp )<=abs( mingma ) ) then
                 mingma = tmp
                 r = i + 1
              end if
           end do
           ! compute the fp vector: solve n^t v = e_r
           isuppz( 1 ) = b1
           isuppz( 2 ) = bn
           z( r ) = one
           ztz = one
           ! compute the fp vector upwards from r
           if( .not.sawnan1 .and. .not.sawnan2 ) then
              do i = r-1, b1, -1
                 z( i ) = -( work( indlpl+i )*z( i+1 ) )
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i ) = zero
                    isuppz( 1 ) = i + 1
                    goto 220
                 endif
                 ztz = ztz + z( i )*z( i )
              end do
              220 continue
           else
              ! run slower loop if nan occurred.
              do i = r - 1, b1, -1
                 if( z( i+1 )==zero ) then
                    z( i ) = -( ld( i+1 ) / ld( i ) )*z( i+2 )
                 else
                    z( i ) = -( work( indlpl+i )*z( i+1 ) )
                 end if
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i ) = zero
                    isuppz( 1 ) = i + 1
                    go to 240
                 end if
                 ztz = ztz + z( i )*z( i )
              end do
              240 continue
           endif
           ! compute the fp vector downwards from r in blocks of size blksiz
           if( .not.sawnan1 .and. .not.sawnan2 ) then
              do i = r, bn-1
                 z( i+1 ) = -( work( indumn+i )*z( i ) )
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i+1 ) = zero
                    isuppz( 2 ) = i
                    go to 260
                 end if
                 ztz = ztz + z( i+1 )*z( i+1 )
              end do
              260 continue
           else
              ! run slower loop if nan occurred.
              do i = r, bn - 1
                 if( z( i )==zero ) then
                    z( i+1 ) = -( ld( i-1 ) / ld( i ) )*z( i-1 )
                 else
                    z( i+1 ) = -( work( indumn+i )*z( i ) )
                 end if
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i+1 ) = zero
                    isuppz( 2 ) = i
                    go to 280
                 end if
                 ztz = ztz + z( i+1 )*z( i+1 )
              end do
              280 continue
           end if
           ! compute quantities for convergence test
           tmp = one / ztz
           nrminv = sqrt( tmp )
           resid = abs( mingma )*nrminv
           rqcorr = mingma*tmp
           return
     end subroutine stdlib_dlar1v

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$lar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc, &
     !! DLAR1V: computes the (scaled) r-th column of the inverse of
     !! the sumbmatrix in rows B1 through BN of the tridiagonal matrix
     !! L D L**T - sigma I. When sigma is close to an eigenvalue, the
     !! computed vector is an accurate eigenvector. Usually, r corresponds
     !! to the index where the eigenvector is largest in magnitude.
     !! The following steps accomplish this computation :
     !! (a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,
     !! (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,
     !! (c) Computation of the diagonal elements of the inverse of
     !! L D L**T - sigma I by combining the above transforms, and choosing
     !! r as the index where the diagonal of the inverse is (one of the)
     !! largest in magnitude.
     !! (d) Computation of the (scaled) r-th column of the inverse using the
     !! twisted factorization obtained by combining the top part of the
     !! the stationary and the bottom part of the progressive transform.
               negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantnc
           integer(ilp), intent(in) :: b1, bn, n
           integer(ilp), intent(out) :: negcnt
           integer(ilp), intent(inout) :: r
           real(${rk}$), intent(in) :: gaptol, lambda, pivmin
           real(${rk}$), intent(out) :: mingma, nrminv, resid, rqcorr, ztz
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*)
           real(${rk}$), intent(in) :: d(*), l(*), ld(*), lld(*)
           real(${rk}$), intent(out) :: work(*)
           real(${rk}$), intent(inout) :: z(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: sawnan1, sawnan2
           integer(ilp) :: i, indlpl, indp, inds, indumn, neg1, neg2, r1, r2
           real(${rk}$) :: dminus, dplus, eps, s, tmp
           ! Intrinsic Functions 
           ! Executable Statements 
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           if( r==0 ) then
              r1 = b1
              r2 = bn
           else
              r1 = r
              r2 = r
           end if
           ! storage for lplus
           indlpl = 0
           ! storage for uminus
           indumn = n
           inds = 2*n + 1
           indp = 3*n + 1
           if( b1==1 ) then
              work( inds ) = zero
           else
              work( inds+b1-1 ) = lld( b1-1 )
           end if
           ! compute the stationary transform (using the differential form)
           ! until the index r2.
           sawnan1 = .false.
           neg1 = 0
           s = work( inds+b1-1 ) - lambda
           do i = b1, r1 - 1
              dplus = d( i ) + s
              work( indlpl+i ) = ld( i ) / dplus
              if(dplus<zero) neg1 = neg1 + 1
              work( inds+i ) = s*work( indlpl+i )*l( i )
              s = work( inds+i ) - lambda
           end do
           sawnan1 = stdlib_${ri}$isnan( s )
           if( sawnan1 ) goto 60
           do i = r1, r2 - 1
              dplus = d( i ) + s
              work( indlpl+i ) = ld( i ) / dplus
              work( inds+i ) = s*work( indlpl+i )*l( i )
              s = work( inds+i ) - lambda
           end do
           sawnan1 = stdlib_${ri}$isnan( s )
           60 continue
           if( sawnan1 ) then
              ! runs a slower version of the above loop if a nan is detected
              neg1 = 0
              s = work( inds+b1-1 ) - lambda
              do i = b1, r1 - 1
                 dplus = d( i ) + s
                 if(abs(dplus)<pivmin) dplus = -pivmin
                 work( indlpl+i ) = ld( i ) / dplus
                 if(dplus<zero) neg1 = neg1 + 1
                 work( inds+i ) = s*work( indlpl+i )*l( i )
                 if( work( indlpl+i )==zero )work( inds+i ) = lld( i )
                 s = work( inds+i ) - lambda
              end do
              do i = r1, r2 - 1
                 dplus = d( i ) + s
                 if(abs(dplus)<pivmin) dplus = -pivmin
                 work( indlpl+i ) = ld( i ) / dplus
                 work( inds+i ) = s*work( indlpl+i )*l( i )
                 if( work( indlpl+i )==zero )work( inds+i ) = lld( i )
                 s = work( inds+i ) - lambda
              end do
           end if
           ! compute the progressive transform (using the differential form)
           ! until the index r1
           sawnan2 = .false.
           neg2 = 0
           work( indp+bn-1 ) = d( bn ) - lambda
           do i = bn - 1, r1, -1
              dminus = lld( i ) + work( indp+i )
              tmp = d( i ) / dminus
              if(dminus<zero) neg2 = neg2 + 1
              work( indumn+i ) = l( i )*tmp
              work( indp+i-1 ) = work( indp+i )*tmp - lambda
           end do
           tmp = work( indp+r1-1 )
           sawnan2 = stdlib_${ri}$isnan( tmp )
           if( sawnan2 ) then
              ! runs a slower version of the above loop if a nan is detected
              neg2 = 0
              do i = bn-1, r1, -1
                 dminus = lld( i ) + work( indp+i )
                 if(abs(dminus)<pivmin) dminus = -pivmin
                 tmp = d( i ) / dminus
                 if(dminus<zero) neg2 = neg2 + 1
                 work( indumn+i ) = l( i )*tmp
                 work( indp+i-1 ) = work( indp+i )*tmp - lambda
                 if( tmp==zero )work( indp+i-1 ) = d( i ) - lambda
              end do
           end if
           ! find the index (from r1 to r2) of the largest (in magnitude)
           ! diagonal element of the inverse
           mingma = work( inds+r1-1 ) + work( indp+r1-1 )
           if( mingma<zero ) neg1 = neg1 + 1
           if( wantnc ) then
              negcnt = neg1 + neg2
           else
              negcnt = -1
           endif
           if( abs(mingma)==zero )mingma = eps*work( inds+r1-1 )
           r = r1
           do i = r1, r2 - 1
              tmp = work( inds+i ) + work( indp+i )
              if( tmp==zero )tmp = eps*work( inds+i )
              if( abs( tmp )<=abs( mingma ) ) then
                 mingma = tmp
                 r = i + 1
              end if
           end do
           ! compute the fp vector: solve n^t v = e_r
           isuppz( 1 ) = b1
           isuppz( 2 ) = bn
           z( r ) = one
           ztz = one
           ! compute the fp vector upwards from r
           if( .not.sawnan1 .and. .not.sawnan2 ) then
              do i = r-1, b1, -1
                 z( i ) = -( work( indlpl+i )*z( i+1 ) )
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i ) = zero
                    isuppz( 1 ) = i + 1
                    goto 220
                 endif
                 ztz = ztz + z( i )*z( i )
              end do
              220 continue
           else
              ! run slower loop if nan occurred.
              do i = r - 1, b1, -1
                 if( z( i+1 )==zero ) then
                    z( i ) = -( ld( i+1 ) / ld( i ) )*z( i+2 )
                 else
                    z( i ) = -( work( indlpl+i )*z( i+1 ) )
                 end if
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i ) = zero
                    isuppz( 1 ) = i + 1
                    go to 240
                 end if
                 ztz = ztz + z( i )*z( i )
              end do
              240 continue
           endif
           ! compute the fp vector downwards from r in blocks of size blksiz
           if( .not.sawnan1 .and. .not.sawnan2 ) then
              do i = r, bn-1
                 z( i+1 ) = -( work( indumn+i )*z( i ) )
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i+1 ) = zero
                    isuppz( 2 ) = i
                    go to 260
                 end if
                 ztz = ztz + z( i+1 )*z( i+1 )
              end do
              260 continue
           else
              ! run slower loop if nan occurred.
              do i = r, bn - 1
                 if( z( i )==zero ) then
                    z( i+1 ) = -( ld( i-1 ) / ld( i ) )*z( i-1 )
                 else
                    z( i+1 ) = -( work( indumn+i )*z( i ) )
                 end if
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i+1 ) = zero
                    isuppz( 2 ) = i
                    go to 280
                 end if
                 ztz = ztz + z( i+1 )*z( i+1 )
              end do
              280 continue
           end if
           ! compute quantities for convergence test
           tmp = one / ztz
           nrminv = sqrt( tmp )
           resid = abs( mingma )*nrminv
           rqcorr = mingma*tmp
           return
     end subroutine stdlib_${ri}$lar1v

#:endif
#:endfor

     pure subroutine stdlib_clar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc, &
     !! CLAR1V computes the (scaled) r-th column of the inverse of
     !! the sumbmatrix in rows B1 through BN of the tridiagonal matrix
     !! L D L**T - sigma I. When sigma is close to an eigenvalue, the
     !! computed vector is an accurate eigenvector. Usually, r corresponds
     !! to the index where the eigenvector is largest in magnitude.
     !! The following steps accomplish this computation :
     !! (a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,
     !! (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,
     !! (c) Computation of the diagonal elements of the inverse of
     !! L D L**T - sigma I by combining the above transforms, and choosing
     !! r as the index where the diagonal of the inverse is (one of the)
     !! largest in magnitude.
     !! (d) Computation of the (scaled) r-th column of the inverse using the
     !! twisted factorization obtained by combining the top part of the
     !! the stationary and the bottom part of the progressive transform.
               negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantnc
           integer(ilp), intent(in) :: b1, bn, n
           integer(ilp), intent(out) :: negcnt
           integer(ilp), intent(inout) :: r
           real(sp), intent(in) :: gaptol, lambda, pivmin
           real(sp), intent(out) :: mingma, nrminv, resid, rqcorr, ztz
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*)
           real(sp), intent(in) :: d(*), l(*), ld(*), lld(*)
           real(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: z(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: sawnan1, sawnan2
           integer(ilp) :: i, indlpl, indp, inds, indumn, neg1, neg2, r1, r2
           real(sp) :: dminus, dplus, eps, s, tmp
           ! Intrinsic Functions 
           ! Executable Statements 
           eps = stdlib_slamch( 'PRECISION' )
           if( r==0 ) then
              r1 = b1
              r2 = bn
           else
              r1 = r
              r2 = r
           end if
           ! storage for lplus
           indlpl = 0
           ! storage for uminus
           indumn = n
           inds = 2*n + 1
           indp = 3*n + 1
           if( b1==1 ) then
              work( inds ) = zero
           else
              work( inds+b1-1 ) = lld( b1-1 )
           end if
           ! compute the stationary transform (using the differential form)
           ! until the index r2.
           sawnan1 = .false.
           neg1 = 0
           s = work( inds+b1-1 ) - lambda
           do i = b1, r1 - 1
              dplus = d( i ) + s
              work( indlpl+i ) = ld( i ) / dplus
              if(dplus<zero) neg1 = neg1 + 1
              work( inds+i ) = s*work( indlpl+i )*l( i )
              s = work( inds+i ) - lambda
           end do
           sawnan1 = stdlib_sisnan( s )
           if( sawnan1 ) goto 60
           do i = r1, r2 - 1
              dplus = d( i ) + s
              work( indlpl+i ) = ld( i ) / dplus
              work( inds+i ) = s*work( indlpl+i )*l( i )
              s = work( inds+i ) - lambda
           end do
           sawnan1 = stdlib_sisnan( s )
           60 continue
           if( sawnan1 ) then
              ! runs a slower version of the above loop if a nan is detected
              neg1 = 0
              s = work( inds+b1-1 ) - lambda
              do i = b1, r1 - 1
                 dplus = d( i ) + s
                 if(abs(dplus)<pivmin) dplus = -pivmin
                 work( indlpl+i ) = ld( i ) / dplus
                 if(dplus<zero) neg1 = neg1 + 1
                 work( inds+i ) = s*work( indlpl+i )*l( i )
                 if( work( indlpl+i )==zero )work( inds+i ) = lld( i )
                 s = work( inds+i ) - lambda
              end do
              do i = r1, r2 - 1
                 dplus = d( i ) + s
                 if(abs(dplus)<pivmin) dplus = -pivmin
                 work( indlpl+i ) = ld( i ) / dplus
                 work( inds+i ) = s*work( indlpl+i )*l( i )
                 if( work( indlpl+i )==zero )work( inds+i ) = lld( i )
                 s = work( inds+i ) - lambda
              end do
           end if
           ! compute the progressive transform (using the differential form)
           ! until the index r1
           sawnan2 = .false.
           neg2 = 0
           work( indp+bn-1 ) = d( bn ) - lambda
           do i = bn - 1, r1, -1
              dminus = lld( i ) + work( indp+i )
              tmp = d( i ) / dminus
              if(dminus<zero) neg2 = neg2 + 1
              work( indumn+i ) = l( i )*tmp
              work( indp+i-1 ) = work( indp+i )*tmp - lambda
           end do
           tmp = work( indp+r1-1 )
           sawnan2 = stdlib_sisnan( tmp )
           if( sawnan2 ) then
              ! runs a slower version of the above loop if a nan is detected
              neg2 = 0
              do i = bn-1, r1, -1
                 dminus = lld( i ) + work( indp+i )
                 if(abs(dminus)<pivmin) dminus = -pivmin
                 tmp = d( i ) / dminus
                 if(dminus<zero) neg2 = neg2 + 1
                 work( indumn+i ) = l( i )*tmp
                 work( indp+i-1 ) = work( indp+i )*tmp - lambda
                 if( tmp==zero )work( indp+i-1 ) = d( i ) - lambda
              end do
           end if
           ! find the index (from r1 to r2) of the largest (in magnitude)
           ! diagonal element of the inverse
           mingma = work( inds+r1-1 ) + work( indp+r1-1 )
           if( mingma<zero ) neg1 = neg1 + 1
           if( wantnc ) then
              negcnt = neg1 + neg2
           else
              negcnt = -1
           endif
           if( abs(mingma)==zero )mingma = eps*work( inds+r1-1 )
           r = r1
           do i = r1, r2 - 1
              tmp = work( inds+i ) + work( indp+i )
              if( tmp==zero )tmp = eps*work( inds+i )
              if( abs( tmp )<=abs( mingma ) ) then
                 mingma = tmp
                 r = i + 1
              end if
           end do
           ! compute the fp vector: solve n^t v = e_r
           isuppz( 1 ) = b1
           isuppz( 2 ) = bn
           z( r ) = cone
           ztz = one
           ! compute the fp vector upwards from r
           if( .not.sawnan1 .and. .not.sawnan2 ) then
              do i = r-1, b1, -1
                 z( i ) = -( work( indlpl+i )*z( i+1 ) )
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i ) = zero
                    isuppz( 1 ) = i + 1
                    goto 220
                 endif
                 ztz = ztz + real( z( i )*z( i ),KIND=sp)
              end do
              220 continue
           else
              ! run slower loop if nan occurred.
              do i = r - 1, b1, -1
                 if( z( i+1 )==zero ) then
                    z( i ) = -( ld( i+1 ) / ld( i ) )*z( i+2 )
                 else
                    z( i ) = -( work( indlpl+i )*z( i+1 ) )
                 end if
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i ) = zero
                    isuppz( 1 ) = i + 1
                    go to 240
                 end if
                 ztz = ztz + real( z( i )*z( i ),KIND=sp)
              end do
              240 continue
           endif
           ! compute the fp vector downwards from r in blocks of size blksiz
           if( .not.sawnan1 .and. .not.sawnan2 ) then
              do i = r, bn-1
                 z( i+1 ) = -( work( indumn+i )*z( i ) )
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i+1 ) = zero
                    isuppz( 2 ) = i
                    go to 260
                 end if
                 ztz = ztz + real( z( i+1 )*z( i+1 ),KIND=sp)
              end do
              260 continue
           else
              ! run slower loop if nan occurred.
              do i = r, bn - 1
                 if( z( i )==zero ) then
                    z( i+1 ) = -( ld( i-1 ) / ld( i ) )*z( i-1 )
                 else
                    z( i+1 ) = -( work( indumn+i )*z( i ) )
                 end if
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i+1 ) = zero
                    isuppz( 2 ) = i
                    go to 280
                 end if
                 ztz = ztz + real( z( i+1 )*z( i+1 ),KIND=sp)
              end do
              280 continue
           end if
           ! compute quantities for convergence test
           tmp = one / ztz
           nrminv = sqrt( tmp )
           resid = abs( mingma )*nrminv
           rqcorr = mingma*tmp
           return
     end subroutine stdlib_clar1v

     pure subroutine stdlib_zlar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc, &
     !! ZLAR1V computes the (scaled) r-th column of the inverse of
     !! the sumbmatrix in rows B1 through BN of the tridiagonal matrix
     !! L D L**T - sigma I. When sigma is close to an eigenvalue, the
     !! computed vector is an accurate eigenvector. Usually, r corresponds
     !! to the index where the eigenvector is largest in magnitude.
     !! The following steps accomplish this computation :
     !! (a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,
     !! (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,
     !! (c) Computation of the diagonal elements of the inverse of
     !! L D L**T - sigma I by combining the above transforms, and choosing
     !! r as the index where the diagonal of the inverse is (one of the)
     !! largest in magnitude.
     !! (d) Computation of the (scaled) r-th column of the inverse using the
     !! twisted factorization obtained by combining the top part of the
     !! the stationary and the bottom part of the progressive transform.
               negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantnc
           integer(ilp), intent(in) :: b1, bn, n
           integer(ilp), intent(out) :: negcnt
           integer(ilp), intent(inout) :: r
           real(dp), intent(in) :: gaptol, lambda, pivmin
           real(dp), intent(out) :: mingma, nrminv, resid, rqcorr, ztz
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*)
           real(dp), intent(in) :: d(*), l(*), ld(*), lld(*)
           real(dp), intent(out) :: work(*)
           complex(dp), intent(inout) :: z(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: sawnan1, sawnan2
           integer(ilp) :: i, indlpl, indp, inds, indumn, neg1, neg2, r1, r2
           real(dp) :: dminus, dplus, eps, s, tmp
           ! Intrinsic Functions 
           ! Executable Statements 
           eps = stdlib_dlamch( 'PRECISION' )
           if( r==0 ) then
              r1 = b1
              r2 = bn
           else
              r1 = r
              r2 = r
           end if
           ! storage for lplus
           indlpl = 0
           ! storage for uminus
           indumn = n
           inds = 2*n + 1
           indp = 3*n + 1
           if( b1==1 ) then
              work( inds ) = zero
           else
              work( inds+b1-1 ) = lld( b1-1 )
           end if
           ! compute the stationary transform (using the differential form)
           ! until the index r2.
           sawnan1 = .false.
           neg1 = 0
           s = work( inds+b1-1 ) - lambda
           do i = b1, r1 - 1
              dplus = d( i ) + s
              work( indlpl+i ) = ld( i ) / dplus
              if(dplus<zero) neg1 = neg1 + 1
              work( inds+i ) = s*work( indlpl+i )*l( i )
              s = work( inds+i ) - lambda
           end do
           sawnan1 = stdlib_disnan( s )
           if( sawnan1 ) goto 60
           do i = r1, r2 - 1
              dplus = d( i ) + s
              work( indlpl+i ) = ld( i ) / dplus
              work( inds+i ) = s*work( indlpl+i )*l( i )
              s = work( inds+i ) - lambda
           end do
           sawnan1 = stdlib_disnan( s )
           60 continue
           if( sawnan1 ) then
              ! runs a slower version of the above loop if a nan is detected
              neg1 = 0
              s = work( inds+b1-1 ) - lambda
              do i = b1, r1 - 1
                 dplus = d( i ) + s
                 if(abs(dplus)<pivmin) dplus = -pivmin
                 work( indlpl+i ) = ld( i ) / dplus
                 if(dplus<zero) neg1 = neg1 + 1
                 work( inds+i ) = s*work( indlpl+i )*l( i )
                 if( work( indlpl+i )==zero )work( inds+i ) = lld( i )
                 s = work( inds+i ) - lambda
              end do
              do i = r1, r2 - 1
                 dplus = d( i ) + s
                 if(abs(dplus)<pivmin) dplus = -pivmin
                 work( indlpl+i ) = ld( i ) / dplus
                 work( inds+i ) = s*work( indlpl+i )*l( i )
                 if( work( indlpl+i )==zero )work( inds+i ) = lld( i )
                 s = work( inds+i ) - lambda
              end do
           end if
           ! compute the progressive transform (using the differential form)
           ! until the index r1
           sawnan2 = .false.
           neg2 = 0
           work( indp+bn-1 ) = d( bn ) - lambda
           do i = bn - 1, r1, -1
              dminus = lld( i ) + work( indp+i )
              tmp = d( i ) / dminus
              if(dminus<zero) neg2 = neg2 + 1
              work( indumn+i ) = l( i )*tmp
              work( indp+i-1 ) = work( indp+i )*tmp - lambda
           end do
           tmp = work( indp+r1-1 )
           sawnan2 = stdlib_disnan( tmp )
           if( sawnan2 ) then
              ! runs a slower version of the above loop if a nan is detected
              neg2 = 0
              do i = bn-1, r1, -1
                 dminus = lld( i ) + work( indp+i )
                 if(abs(dminus)<pivmin) dminus = -pivmin
                 tmp = d( i ) / dminus
                 if(dminus<zero) neg2 = neg2 + 1
                 work( indumn+i ) = l( i )*tmp
                 work( indp+i-1 ) = work( indp+i )*tmp - lambda
                 if( tmp==zero )work( indp+i-1 ) = d( i ) - lambda
              end do
           end if
           ! find the index (from r1 to r2) of the largest (in magnitude)
           ! diagonal element of the inverse
           mingma = work( inds+r1-1 ) + work( indp+r1-1 )
           if( mingma<zero ) neg1 = neg1 + 1
           if( wantnc ) then
              negcnt = neg1 + neg2
           else
              negcnt = -1
           endif
           if( abs(mingma)==zero )mingma = eps*work( inds+r1-1 )
           r = r1
           do i = r1, r2 - 1
              tmp = work( inds+i ) + work( indp+i )
              if( tmp==zero )tmp = eps*work( inds+i )
              if( abs( tmp )<=abs( mingma ) ) then
                 mingma = tmp
                 r = i + 1
              end if
           end do
           ! compute the fp vector: solve n^t v = e_r
           isuppz( 1 ) = b1
           isuppz( 2 ) = bn
           z( r ) = cone
           ztz = one
           ! compute the fp vector upwards from r
           if( .not.sawnan1 .and. .not.sawnan2 ) then
              do i = r-1, b1, -1
                 z( i ) = -( work( indlpl+i )*z( i+1 ) )
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i ) = zero
                    isuppz( 1 ) = i + 1
                    goto 220
                 endif
                 ztz = ztz + real( z( i )*z( i ),KIND=dp)
              end do
              220 continue
           else
              ! run slower loop if nan occurred.
              do i = r - 1, b1, -1
                 if( z( i+1 )==zero ) then
                    z( i ) = -( ld( i+1 ) / ld( i ) )*z( i+2 )
                 else
                    z( i ) = -( work( indlpl+i )*z( i+1 ) )
                 end if
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i ) = zero
                    isuppz( 1 ) = i + 1
                    go to 240
                 end if
                 ztz = ztz + real( z( i )*z( i ),KIND=dp)
              end do
              240 continue
           endif
           ! compute the fp vector downwards from r in blocks of size blksiz
           if( .not.sawnan1 .and. .not.sawnan2 ) then
              do i = r, bn-1
                 z( i+1 ) = -( work( indumn+i )*z( i ) )
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i+1 ) = zero
                    isuppz( 2 ) = i
                    go to 260
                 end if
                 ztz = ztz + real( z( i+1 )*z( i+1 ),KIND=dp)
              end do
              260 continue
           else
              ! run slower loop if nan occurred.
              do i = r, bn - 1
                 if( z( i )==zero ) then
                    z( i+1 ) = -( ld( i-1 ) / ld( i ) )*z( i-1 )
                 else
                    z( i+1 ) = -( work( indumn+i )*z( i ) )
                 end if
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i+1 ) = zero
                    isuppz( 2 ) = i
                    go to 280
                 end if
                 ztz = ztz + real( z( i+1 )*z( i+1 ),KIND=dp)
              end do
              280 continue
           end if
           ! compute quantities for convergence test
           tmp = one / ztz
           nrminv = sqrt( tmp )
           resid = abs( mingma )*nrminv
           rqcorr = mingma*tmp
           return
     end subroutine stdlib_zlar1v

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$lar1v( n, b1, bn, lambda, d, l, ld, lld,pivmin, gaptol, z, wantnc, &
     !! ZLAR1V: computes the (scaled) r-th column of the inverse of
     !! the sumbmatrix in rows B1 through BN of the tridiagonal matrix
     !! L D L**T - sigma I. When sigma is close to an eigenvalue, the
     !! computed vector is an accurate eigenvector. Usually, r corresponds
     !! to the index where the eigenvector is largest in magnitude.
     !! The following steps accomplish this computation :
     !! (a) Stationary qd transform,  L D L**T - sigma I = L(+) D(+) L(+)**T,
     !! (b) Progressive qd transform, L D L**T - sigma I = U(-) D(-) U(-)**T,
     !! (c) Computation of the diagonal elements of the inverse of
     !! L D L**T - sigma I by combining the above transforms, and choosing
     !! r as the index where the diagonal of the inverse is (one of the)
     !! largest in magnitude.
     !! (d) Computation of the (scaled) r-th column of the inverse using the
     !! twisted factorization obtained by combining the top part of the
     !! the stationary and the bottom part of the progressive transform.
               negcnt, ztz, mingma,r, isuppz, nrminv, resid, rqcorr, work )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantnc
           integer(ilp), intent(in) :: b1, bn, n
           integer(ilp), intent(out) :: negcnt
           integer(ilp), intent(inout) :: r
           real(${ck}$), intent(in) :: gaptol, lambda, pivmin
           real(${ck}$), intent(out) :: mingma, nrminv, resid, rqcorr, ztz
           ! Array Arguments 
           integer(ilp), intent(out) :: isuppz(*)
           real(${ck}$), intent(in) :: d(*), l(*), ld(*), lld(*)
           real(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(inout) :: z(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: sawnan1, sawnan2
           integer(ilp) :: i, indlpl, indp, inds, indumn, neg1, neg2, r1, r2
           real(${ck}$) :: dminus, dplus, eps, s, tmp
           ! Intrinsic Functions 
           ! Executable Statements 
           eps = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           if( r==0 ) then
              r1 = b1
              r2 = bn
           else
              r1 = r
              r2 = r
           end if
           ! storage for lplus
           indlpl = 0
           ! storage for uminus
           indumn = n
           inds = 2*n + 1
           indp = 3*n + 1
           if( b1==1 ) then
              work( inds ) = zero
           else
              work( inds+b1-1 ) = lld( b1-1 )
           end if
           ! compute the stationary transform (using the differential form)
           ! until the index r2.
           sawnan1 = .false.
           neg1 = 0
           s = work( inds+b1-1 ) - lambda
           do i = b1, r1 - 1
              dplus = d( i ) + s
              work( indlpl+i ) = ld( i ) / dplus
              if(dplus<zero) neg1 = neg1 + 1
              work( inds+i ) = s*work( indlpl+i )*l( i )
              s = work( inds+i ) - lambda
           end do
           sawnan1 = stdlib_${c2ri(ci)}$isnan( s )
           if( sawnan1 ) goto 60
           do i = r1, r2 - 1
              dplus = d( i ) + s
              work( indlpl+i ) = ld( i ) / dplus
              work( inds+i ) = s*work( indlpl+i )*l( i )
              s = work( inds+i ) - lambda
           end do
           sawnan1 = stdlib_${c2ri(ci)}$isnan( s )
           60 continue
           if( sawnan1 ) then
              ! runs a slower version of the above loop if a nan is detected
              neg1 = 0
              s = work( inds+b1-1 ) - lambda
              do i = b1, r1 - 1
                 dplus = d( i ) + s
                 if(abs(dplus)<pivmin) dplus = -pivmin
                 work( indlpl+i ) = ld( i ) / dplus
                 if(dplus<zero) neg1 = neg1 + 1
                 work( inds+i ) = s*work( indlpl+i )*l( i )
                 if( work( indlpl+i )==zero )work( inds+i ) = lld( i )
                 s = work( inds+i ) - lambda
              end do
              do i = r1, r2 - 1
                 dplus = d( i ) + s
                 if(abs(dplus)<pivmin) dplus = -pivmin
                 work( indlpl+i ) = ld( i ) / dplus
                 work( inds+i ) = s*work( indlpl+i )*l( i )
                 if( work( indlpl+i )==zero )work( inds+i ) = lld( i )
                 s = work( inds+i ) - lambda
              end do
           end if
           ! compute the progressive transform (using the differential form)
           ! until the index r1
           sawnan2 = .false.
           neg2 = 0
           work( indp+bn-1 ) = d( bn ) - lambda
           do i = bn - 1, r1, -1
              dminus = lld( i ) + work( indp+i )
              tmp = d( i ) / dminus
              if(dminus<zero) neg2 = neg2 + 1
              work( indumn+i ) = l( i )*tmp
              work( indp+i-1 ) = work( indp+i )*tmp - lambda
           end do
           tmp = work( indp+r1-1 )
           sawnan2 = stdlib_${c2ri(ci)}$isnan( tmp )
           if( sawnan2 ) then
              ! runs a slower version of the above loop if a nan is detected
              neg2 = 0
              do i = bn-1, r1, -1
                 dminus = lld( i ) + work( indp+i )
                 if(abs(dminus)<pivmin) dminus = -pivmin
                 tmp = d( i ) / dminus
                 if(dminus<zero) neg2 = neg2 + 1
                 work( indumn+i ) = l( i )*tmp
                 work( indp+i-1 ) = work( indp+i )*tmp - lambda
                 if( tmp==zero )work( indp+i-1 ) = d( i ) - lambda
              end do
           end if
           ! find the index (from r1 to r2) of the largest (in magnitude)
           ! diagonal element of the inverse
           mingma = work( inds+r1-1 ) + work( indp+r1-1 )
           if( mingma<zero ) neg1 = neg1 + 1
           if( wantnc ) then
              negcnt = neg1 + neg2
           else
              negcnt = -1
           endif
           if( abs(mingma)==zero )mingma = eps*work( inds+r1-1 )
           r = r1
           do i = r1, r2 - 1
              tmp = work( inds+i ) + work( indp+i )
              if( tmp==zero )tmp = eps*work( inds+i )
              if( abs( tmp )<=abs( mingma ) ) then
                 mingma = tmp
                 r = i + 1
              end if
           end do
           ! compute the fp vector: solve n^t v = e_r
           isuppz( 1 ) = b1
           isuppz( 2 ) = bn
           z( r ) = cone
           ztz = one
           ! compute the fp vector upwards from r
           if( .not.sawnan1 .and. .not.sawnan2 ) then
              do i = r-1, b1, -1
                 z( i ) = -( work( indlpl+i )*z( i+1 ) )
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i ) = zero
                    isuppz( 1 ) = i + 1
                    goto 220
                 endif
                 ztz = ztz + real( z( i )*z( i ),KIND=${ck}$)
              end do
              220 continue
           else
              ! run slower loop if nan occurred.
              do i = r - 1, b1, -1
                 if( z( i+1 )==zero ) then
                    z( i ) = -( ld( i+1 ) / ld( i ) )*z( i+2 )
                 else
                    z( i ) = -( work( indlpl+i )*z( i+1 ) )
                 end if
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i ) = zero
                    isuppz( 1 ) = i + 1
                    go to 240
                 end if
                 ztz = ztz + real( z( i )*z( i ),KIND=${ck}$)
              end do
              240 continue
           endif
           ! compute the fp vector downwards from r in blocks of size blksiz
           if( .not.sawnan1 .and. .not.sawnan2 ) then
              do i = r, bn-1
                 z( i+1 ) = -( work( indumn+i )*z( i ) )
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i+1 ) = zero
                    isuppz( 2 ) = i
                    go to 260
                 end if
                 ztz = ztz + real( z( i+1 )*z( i+1 ),KIND=${ck}$)
              end do
              260 continue
           else
              ! run slower loop if nan occurred.
              do i = r, bn - 1
                 if( z( i )==zero ) then
                    z( i+1 ) = -( ld( i-1 ) / ld( i ) )*z( i-1 )
                 else
                    z( i+1 ) = -( work( indumn+i )*z( i ) )
                 end if
                 if( (abs(z(i))+abs(z(i+1)))* abs(ld(i))<gaptol )then
                    z( i+1 ) = zero
                    isuppz( 2 ) = i
                    go to 280
                 end if
                 ztz = ztz + real( z( i+1 )*z( i+1 ),KIND=${ck}$)
              end do
              280 continue
           end if
           ! compute quantities for convergence test
           tmp = one / ztz
           nrminv = sqrt( tmp )
           resid = abs( mingma )*nrminv
           rqcorr = mingma*tmp
           return
     end subroutine stdlib_${ci}$lar1v

#:endif
#:endfor



     pure subroutine stdlib_sopgtr( uplo, n, ap, tau, q, ldq, work, info )
     !! SOPGTR generates a real orthogonal matrix Q which is defined as the
     !! product of n-1 elementary reflectors H(i) of order n, as returned by
     !! SSPTRD using packed storage:
     !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldq, n
           ! Array Arguments 
           real(sp), intent(in) :: ap(*), tau(*)
           real(sp), intent(out) :: q(ldq,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, ij, j
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SOPGTR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! q was determined by a call to stdlib_ssptrd with uplo = 'u'
              ! unpack the vectors which define the elementary reflectors and
              ! set the last row and column of q equal to those of the unit
              ! matrix
              ij = 2
              do j = 1, n - 1
                 do i = 1, j - 1
                    q( i, j ) = ap( ij )
                    ij = ij + 1
                 end do
                 ij = ij + 2
                 q( n, j ) = zero
              end do
              do i = 1, n - 1
                 q( i, n ) = zero
              end do
              q( n, n ) = one
              ! generate q(1:n-1,1:n-1)
              call stdlib_sorg2l( n-1, n-1, n-1, q, ldq, tau, work, iinfo )
           else
              ! q was determined by a call to stdlib_ssptrd with uplo = 'l'.
              ! unpack the vectors which define the elementary reflectors and
              ! set the first row and column of q equal to those of the unit
              ! matrix
              q( 1, 1 ) = one
              do i = 2, n
                 q( i, 1 ) = zero
              end do
              ij = 3
              do j = 2, n
                 q( 1, j ) = zero
                 do i = j + 1, n
                    q( i, j ) = ap( ij )
                    ij = ij + 1
                 end do
                 ij = ij + 2
              end do
              if( n>1 ) then
                 ! generate q(2:n,2:n)
                 call stdlib_sorg2r( n-1, n-1, n-1, q( 2, 2 ), ldq, tau, work,iinfo )
              end if
           end if
           return
     end subroutine stdlib_sopgtr

     pure subroutine stdlib_dopgtr( uplo, n, ap, tau, q, ldq, work, info )
     !! DOPGTR generates a real orthogonal matrix Q which is defined as the
     !! product of n-1 elementary reflectors H(i) of order n, as returned by
     !! DSPTRD using packed storage:
     !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldq, n
           ! Array Arguments 
           real(dp), intent(in) :: ap(*), tau(*)
           real(dp), intent(out) :: q(ldq,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, ij, j
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DOPGTR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! q was determined by a call to stdlib_dsptrd with uplo = 'u'
              ! unpack the vectors which define the elementary reflectors and
              ! set the last row and column of q equal to those of the unit
              ! matrix
              ij = 2
              do j = 1, n - 1
                 do i = 1, j - 1
                    q( i, j ) = ap( ij )
                    ij = ij + 1
                 end do
                 ij = ij + 2
                 q( n, j ) = zero
              end do
              do i = 1, n - 1
                 q( i, n ) = zero
              end do
              q( n, n ) = one
              ! generate q(1:n-1,1:n-1)
              call stdlib_dorg2l( n-1, n-1, n-1, q, ldq, tau, work, iinfo )
           else
              ! q was determined by a call to stdlib_dsptrd with uplo = 'l'.
              ! unpack the vectors which define the elementary reflectors and
              ! set the first row and column of q equal to those of the unit
              ! matrix
              q( 1, 1 ) = one
              do i = 2, n
                 q( i, 1 ) = zero
              end do
              ij = 3
              do j = 2, n
                 q( 1, j ) = zero
                 do i = j + 1, n
                    q( i, j ) = ap( ij )
                    ij = ij + 1
                 end do
                 ij = ij + 2
              end do
              if( n>1 ) then
                 ! generate q(2:n,2:n)
                 call stdlib_dorg2r( n-1, n-1, n-1, q( 2, 2 ), ldq, tau, work,iinfo )
              end if
           end if
           return
     end subroutine stdlib_dopgtr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$opgtr( uplo, n, ap, tau, q, ldq, work, info )
     !! DOPGTR: generates a real orthogonal matrix Q which is defined as the
     !! product of n-1 elementary reflectors H(i) of order n, as returned by
     !! DSPTRD using packed storage:
     !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldq, n
           ! Array Arguments 
           real(${rk}$), intent(in) :: ap(*), tau(*)
           real(${rk}$), intent(out) :: q(ldq,*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, iinfo, ij, j
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DOPGTR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( upper ) then
              ! q was determined by a call to stdlib_${ri}$sptrd with uplo = 'u'
              ! unpack the vectors which define the elementary reflectors and
              ! set the last row and column of q equal to those of the unit
              ! matrix
              ij = 2
              do j = 1, n - 1
                 do i = 1, j - 1
                    q( i, j ) = ap( ij )
                    ij = ij + 1
                 end do
                 ij = ij + 2
                 q( n, j ) = zero
              end do
              do i = 1, n - 1
                 q( i, n ) = zero
              end do
              q( n, n ) = one
              ! generate q(1:n-1,1:n-1)
              call stdlib_${ri}$org2l( n-1, n-1, n-1, q, ldq, tau, work, iinfo )
           else
              ! q was determined by a call to stdlib_${ri}$sptrd with uplo = 'l'.
              ! unpack the vectors which define the elementary reflectors and
              ! set the first row and column of q equal to those of the unit
              ! matrix
              q( 1, 1 ) = one
              do i = 2, n
                 q( i, 1 ) = zero
              end do
              ij = 3
              do j = 2, n
                 q( 1, j ) = zero
                 do i = j + 1, n
                    q( i, j ) = ap( ij )
                    ij = ij + 1
                 end do
                 ij = ij + 2
              end do
              if( n>1 ) then
                 ! generate q(2:n,2:n)
                 call stdlib_${ri}$org2r( n-1, n-1, n-1, q( 2, 2 ), ldq, tau, work,iinfo )
              end if
           end if
           return
     end subroutine stdlib_${ri}$opgtr

#:endif
#:endfor





     pure subroutine stdlib_sorgtr( uplo, n, a, lda, tau, work, lwork, info )
     !! SORGTR generates a real orthogonal matrix Q which is defined as the
     !! product of n-1 elementary reflectors of order N, as returned by
     !! SSYTRD:
     !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(in) :: tau(*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, j, lwkopt, nb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<max( 1, n-1 ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              if ( upper ) then
                nb = stdlib_ilaenv( 1, 'SORGQL', ' ', n-1, n-1, n-1, -1 )
              else
                nb = stdlib_ilaenv( 1, 'SORGQR', ' ', n-1, n-1, n-1, -1 )
              end if
              lwkopt = max( 1, n-1 )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SORGTR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           if( upper ) then
              ! q was determined by a call to stdlib_ssytrd with uplo = 'u'
              ! shift the vectors which define the elementary reflectors one
              ! column to the left, and set the last row and column of q to
              ! those of the unit matrix
              do j = 1, n - 1
                 do i = 1, j - 1
                    a( i, j ) = a( i, j+1 )
                 end do
                 a( n, j ) = zero
              end do
              do i = 1, n - 1
                 a( i, n ) = zero
              end do
              a( n, n ) = one
              ! generate q(1:n-1,1:n-1)
              call stdlib_sorgql( n-1, n-1, n-1, a, lda, tau, work, lwork, iinfo )
           else
              ! q was determined by a call to stdlib_ssytrd with uplo = 'l'.
              ! shift the vectors which define the elementary reflectors one
              ! column to the right, and set the first row and column of q to
              ! those of the unit matrix
              do j = n, 2, -1
                 a( 1, j ) = zero
                 do i = j + 1, n
                    a( i, j ) = a( i, j-1 )
                 end do
              end do
              a( 1, 1 ) = one
              do i = 2, n
                 a( i, 1 ) = zero
              end do
              if( n>1 ) then
                 ! generate q(2:n,2:n)
                 call stdlib_sorgqr( n-1, n-1, n-1, a( 2, 2 ), lda, tau, work,lwork, iinfo )
                           
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_sorgtr

     pure subroutine stdlib_dorgtr( uplo, n, a, lda, tau, work, lwork, info )
     !! DORGTR generates a real orthogonal matrix Q which is defined as the
     !! product of n-1 elementary reflectors of order N, as returned by
     !! DSYTRD:
     !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(in) :: tau(*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, j, lwkopt, nb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<max( 1, n-1 ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              if( upper ) then
                 nb = stdlib_ilaenv( 1, 'DORGQL', ' ', n-1, n-1, n-1, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'DORGQR', ' ', n-1, n-1, n-1, -1 )
              end if
              lwkopt = max( 1, n-1 )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORGTR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           if( upper ) then
              ! q was determined by a call to stdlib_dsytrd with uplo = 'u'
              ! shift the vectors which define the elementary reflectors one
              ! column to the left, and set the last row and column of q to
              ! those of the unit matrix
              do j = 1, n - 1
                 do i = 1, j - 1
                    a( i, j ) = a( i, j+1 )
                 end do
                 a( n, j ) = zero
              end do
              do i = 1, n - 1
                 a( i, n ) = zero
              end do
              a( n, n ) = one
              ! generate q(1:n-1,1:n-1)
              call stdlib_dorgql( n-1, n-1, n-1, a, lda, tau, work, lwork, iinfo )
           else
              ! q was determined by a call to stdlib_dsytrd with uplo = 'l'.
              ! shift the vectors which define the elementary reflectors one
              ! column to the right, and set the first row and column of q to
              ! those of the unit matrix
              do j = n, 2, -1
                 a( 1, j ) = zero
                 do i = j + 1, n
                    a( i, j ) = a( i, j-1 )
                 end do
              end do
              a( 1, 1 ) = one
              do i = 2, n
                 a( i, 1 ) = zero
              end do
              if( n>1 ) then
                 ! generate q(2:n,2:n)
                 call stdlib_dorgqr( n-1, n-1, n-1, a( 2, 2 ), lda, tau, work,lwork, iinfo )
                           
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dorgtr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$orgtr( uplo, n, a, lda, tau, work, lwork, info )
     !! DORGTR: generates a real orthogonal matrix Q which is defined as the
     !! product of n-1 elementary reflectors of order N, as returned by
     !! DSYTRD:
     !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, j, lwkopt, nb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<max( 1, n-1 ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              if( upper ) then
                 nb = stdlib_ilaenv( 1, 'DORGQL', ' ', n-1, n-1, n-1, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'DORGQR', ' ', n-1, n-1, n-1, -1 )
              end if
              lwkopt = max( 1, n-1 )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORGTR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           if( upper ) then
              ! q was determined by a call to stdlib_${ri}$sytrd with uplo = 'u'
              ! shift the vectors which define the elementary reflectors one
              ! column to the left, and set the last row and column of q to
              ! those of the unit matrix
              do j = 1, n - 1
                 do i = 1, j - 1
                    a( i, j ) = a( i, j+1 )
                 end do
                 a( n, j ) = zero
              end do
              do i = 1, n - 1
                 a( i, n ) = zero
              end do
              a( n, n ) = one
              ! generate q(1:n-1,1:n-1)
              call stdlib_${ri}$orgql( n-1, n-1, n-1, a, lda, tau, work, lwork, iinfo )
           else
              ! q was determined by a call to stdlib_${ri}$sytrd with uplo = 'l'.
              ! shift the vectors which define the elementary reflectors one
              ! column to the right, and set the first row and column of q to
              ! those of the unit matrix
              do j = n, 2, -1
                 a( 1, j ) = zero
                 do i = j + 1, n
                    a( i, j ) = a( i, j-1 )
                 end do
              end do
              a( 1, 1 ) = one
              do i = 2, n
                 a( i, 1 ) = zero
              end do
              if( n>1 ) then
                 ! generate q(2:n,2:n)
                 call stdlib_${ri}$orgqr( n-1, n-1, n-1, a( 2, 2 ), lda, tau, work,lwork, iinfo )
                           
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$orgtr

#:endif
#:endfor







     pure subroutine stdlib_slagtf( n, a, lambda, b, c, tol, d, in, info )
     !! SLAGTF factorizes the matrix (T - lambda*I), where T is an n by n
     !! tridiagonal matrix and lambda is a scalar, as
     !! T - lambda*I = PLU,
     !! where P is a permutation matrix, L is a unit lower tridiagonal matrix
     !! with at most one non-zero sub-diagonal elements per column and U is
     !! an upper triangular matrix with at most two non-zero super-diagonal
     !! elements per column.
     !! The factorization is obtained by Gaussian elimination with partial
     !! pivoting and implicit row scaling.
     !! The parameter LAMBDA is included in the routine so that SLAGTF may
     !! be used, in conjunction with SLAGTS, to obtain eigenvectors of T by
     !! inverse iteration.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(sp), intent(in) :: lambda, tol
           ! Array Arguments 
           integer(ilp), intent(out) :: in(*)
           real(sp), intent(inout) :: a(*), b(*), c(*)
           real(sp), intent(out) :: d(*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: k
           real(sp) :: eps, mult, piv1, piv2, scale1, scale2, temp, tl
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           if( n<0 ) then
              info = -1
              call stdlib_xerbla( 'SLAGTF', -info )
              return
           end if
           if( n==0 )return
           a( 1 ) = a( 1 ) - lambda
           in( n ) = 0
           if( n==1 ) then
              if( a( 1 )==zero )in( 1 ) = 1
              return
           end if
           eps = stdlib_slamch( 'EPSILON' )
           tl = max( tol, eps )
           scale1 = abs( a( 1 ) ) + abs( b( 1 ) )
           loop_10: do k = 1, n - 1
              a( k+1 ) = a( k+1 ) - lambda
              scale2 = abs( c( k ) ) + abs( a( k+1 ) )
              if( k<( n-1 ) )scale2 = scale2 + abs( b( k+1 ) )
              if( a( k )==zero ) then
                 piv1 = zero
              else
                 piv1 = abs( a( k ) ) / scale1
              end if
              if( c( k )==zero ) then
                 in( k ) = 0
                 piv2 = zero
                 scale1 = scale2
                 if( k<( n-1 ) )d( k ) = zero
              else
                 piv2 = abs( c( k ) ) / scale2
                 if( piv2<=piv1 ) then
                    in( k ) = 0
                    scale1 = scale2
                    c( k ) = c( k ) / a( k )
                    a( k+1 ) = a( k+1 ) - c( k )*b( k )
                    if( k<( n-1 ) )d( k ) = zero
                 else
                    in( k ) = 1
                    mult = a( k ) / c( k )
                    a( k ) = c( k )
                    temp = a( k+1 )
                    a( k+1 ) = b( k ) - mult*temp
                    if( k<( n-1 ) ) then
                       d( k ) = b( k+1 )
                       b( k+1 ) = -mult*d( k )
                    end if
                    b( k ) = temp
                    c( k ) = mult
                 end if
              end if
              if( ( max( piv1, piv2 )<=tl ) .and. ( in( n )==0 ) )in( n ) = k
           end do loop_10
           if( ( abs( a( n ) )<=scale1*tl ) .and. ( in( n )==0 ) )in( n ) = n
           return
     end subroutine stdlib_slagtf

     pure subroutine stdlib_dlagtf( n, a, lambda, b, c, tol, d, in, info )
     !! DLAGTF factorizes the matrix (T - lambda*I), where T is an n by n
     !! tridiagonal matrix and lambda is a scalar, as
     !! T - lambda*I = PLU,
     !! where P is a permutation matrix, L is a unit lower tridiagonal matrix
     !! with at most one non-zero sub-diagonal elements per column and U is
     !! an upper triangular matrix with at most two non-zero super-diagonal
     !! elements per column.
     !! The factorization is obtained by Gaussian elimination with partial
     !! pivoting and implicit row scaling.
     !! The parameter LAMBDA is included in the routine so that DLAGTF may
     !! be used, in conjunction with DLAGTS, to obtain eigenvectors of T by
     !! inverse iteration.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(dp), intent(in) :: lambda, tol
           ! Array Arguments 
           integer(ilp), intent(out) :: in(*)
           real(dp), intent(inout) :: a(*), b(*), c(*)
           real(dp), intent(out) :: d(*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: k
           real(dp) :: eps, mult, piv1, piv2, scale1, scale2, temp, tl
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           if( n<0 ) then
              info = -1
              call stdlib_xerbla( 'DLAGTF', -info )
              return
           end if
           if( n==0 )return
           a( 1 ) = a( 1 ) - lambda
           in( n ) = 0
           if( n==1 ) then
              if( a( 1 )==zero )in( 1 ) = 1
              return
           end if
           eps = stdlib_dlamch( 'EPSILON' )
           tl = max( tol, eps )
           scale1 = abs( a( 1 ) ) + abs( b( 1 ) )
           loop_10: do k = 1, n - 1
              a( k+1 ) = a( k+1 ) - lambda
              scale2 = abs( c( k ) ) + abs( a( k+1 ) )
              if( k<( n-1 ) )scale2 = scale2 + abs( b( k+1 ) )
              if( a( k )==zero ) then
                 piv1 = zero
              else
                 piv1 = abs( a( k ) ) / scale1
              end if
              if( c( k )==zero ) then
                 in( k ) = 0
                 piv2 = zero
                 scale1 = scale2
                 if( k<( n-1 ) )d( k ) = zero
              else
                 piv2 = abs( c( k ) ) / scale2
                 if( piv2<=piv1 ) then
                    in( k ) = 0
                    scale1 = scale2
                    c( k ) = c( k ) / a( k )
                    a( k+1 ) = a( k+1 ) - c( k )*b( k )
                    if( k<( n-1 ) )d( k ) = zero
                 else
                    in( k ) = 1
                    mult = a( k ) / c( k )
                    a( k ) = c( k )
                    temp = a( k+1 )
                    a( k+1 ) = b( k ) - mult*temp
                    if( k<( n-1 ) ) then
                       d( k ) = b( k+1 )
                       b( k+1 ) = -mult*d( k )
                    end if
                    b( k ) = temp
                    c( k ) = mult
                 end if
              end if
              if( ( max( piv1, piv2 )<=tl ) .and. ( in( n )==0 ) )in( n ) = k
           end do loop_10
           if( ( abs( a( n ) )<=scale1*tl ) .and. ( in( n )==0 ) )in( n ) = n
           return
     end subroutine stdlib_dlagtf

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$lagtf( n, a, lambda, b, c, tol, d, in, info )
     !! DLAGTF: factorizes the matrix (T - lambda*I), where T is an n by n
     !! tridiagonal matrix and lambda is a scalar, as
     !! T - lambda*I = PLU,
     !! where P is a permutation matrix, L is a unit lower tridiagonal matrix
     !! with at most one non-zero sub-diagonal elements per column and U is
     !! an upper triangular matrix with at most two non-zero super-diagonal
     !! elements per column.
     !! The factorization is obtained by Gaussian elimination with partial
     !! pivoting and implicit row scaling.
     !! The parameter LAMBDA is included in the routine so that DLAGTF may
     !! be used, in conjunction with DLAGTS, to obtain eigenvectors of T by
     !! inverse iteration.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           real(${rk}$), intent(in) :: lambda, tol
           ! Array Arguments 
           integer(ilp), intent(out) :: in(*)
           real(${rk}$), intent(inout) :: a(*), b(*), c(*)
           real(${rk}$), intent(out) :: d(*)
       ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: k
           real(${rk}$) :: eps, mult, piv1, piv2, scale1, scale2, temp, tl
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           if( n<0 ) then
              info = -1
              call stdlib_xerbla( 'DLAGTF', -info )
              return
           end if
           if( n==0 )return
           a( 1 ) = a( 1 ) - lambda
           in( n ) = 0
           if( n==1 ) then
              if( a( 1 )==zero )in( 1 ) = 1
              return
           end if
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           tl = max( tol, eps )
           scale1 = abs( a( 1 ) ) + abs( b( 1 ) )
           loop_10: do k = 1, n - 1
              a( k+1 ) = a( k+1 ) - lambda
              scale2 = abs( c( k ) ) + abs( a( k+1 ) )
              if( k<( n-1 ) )scale2 = scale2 + abs( b( k+1 ) )
              if( a( k )==zero ) then
                 piv1 = zero
              else
                 piv1 = abs( a( k ) ) / scale1
              end if
              if( c( k )==zero ) then
                 in( k ) = 0
                 piv2 = zero
                 scale1 = scale2
                 if( k<( n-1 ) )d( k ) = zero
              else
                 piv2 = abs( c( k ) ) / scale2
                 if( piv2<=piv1 ) then
                    in( k ) = 0
                    scale1 = scale2
                    c( k ) = c( k ) / a( k )
                    a( k+1 ) = a( k+1 ) - c( k )*b( k )
                    if( k<( n-1 ) )d( k ) = zero
                 else
                    in( k ) = 1
                    mult = a( k ) / c( k )
                    a( k ) = c( k )
                    temp = a( k+1 )
                    a( k+1 ) = b( k ) - mult*temp
                    if( k<( n-1 ) ) then
                       d( k ) = b( k+1 )
                       b( k+1 ) = -mult*d( k )
                    end if
                    b( k ) = temp
                    c( k ) = mult
                 end if
              end if
              if( ( max( piv1, piv2 )<=tl ) .and. ( in( n )==0 ) )in( n ) = k
           end do loop_10
           if( ( abs( a( n ) )<=scale1*tl ) .and. ( in( n )==0 ) )in( n ) = n
           return
     end subroutine stdlib_${ri}$lagtf

#:endif
#:endfor



     pure subroutine stdlib_sstevd( jobz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )
     !! SSTEVD computes all eigenvalues and, optionally, eigenvectors of a
     !! real symmetric tridiagonal matrix. If eigenvectors are desired, it
     !! uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, liwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wantz
           integer(ilp) :: iscale, liwmin, lwmin
           real(sp) :: bignum, eps, rmax, rmin, safmin, sigma, smlnum, tnrm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           info = 0
           liwmin = 1
           lwmin = 1
           if( n>1 .and. wantz ) then
              lwmin = 1 + 4*n + n**2
              liwmin = 3 + 5*n
           end if
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -6
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -8
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -10
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSTEVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           eps = stdlib_slamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           tnrm = stdlib_slanst( 'M', n, d, e )
           if( tnrm>zero .and. tnrm<rmin ) then
              iscale = 1
              sigma = rmin / tnrm
           else if( tnrm>rmax ) then
              iscale = 1
              sigma = rmax / tnrm
           end if
           if( iscale==1 ) then
              call stdlib_sscal( n, sigma, d, 1 )
              call stdlib_sscal( n-1, sigma, e( 1 ), 1 )
           end if
           ! for eigenvalues only, call stdlib_ssterf.  for eigenvalues and
           ! eigenvectors, call stdlib_sstedc.
           if( .not.wantz ) then
              call stdlib_ssterf( n, d, e, info )
           else
              call stdlib_sstedc( 'I', n, d, e, z, ldz, work, lwork, iwork, liwork,info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 )call stdlib_sscal( n, one / sigma, d, 1 )
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_sstevd

     pure subroutine stdlib_dstevd( jobz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )
     !! DSTEVD computes all eigenvalues and, optionally, eigenvectors of a
     !! real symmetric tridiagonal matrix. If eigenvectors are desired, it
     !! uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, liwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wantz
           integer(ilp) :: iscale, liwmin, lwmin
           real(dp) :: bignum, eps, rmax, rmin, safmin, sigma, smlnum, tnrm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           info = 0
           liwmin = 1
           lwmin = 1
           if( n>1 .and. wantz ) then
              lwmin = 1 + 4*n + n**2
              liwmin = 3 + 5*n
           end if
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -6
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -8
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -10
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           eps = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           tnrm = stdlib_dlanst( 'M', n, d, e )
           if( tnrm>zero .and. tnrm<rmin ) then
              iscale = 1
              sigma = rmin / tnrm
           else if( tnrm>rmax ) then
              iscale = 1
              sigma = rmax / tnrm
           end if
           if( iscale==1 ) then
              call stdlib_dscal( n, sigma, d, 1 )
              call stdlib_dscal( n-1, sigma, e( 1 ), 1 )
           end if
           ! for eigenvalues only, call stdlib_dsterf.  for eigenvalues and
           ! eigenvectors, call stdlib_dstedc.
           if( .not.wantz ) then
              call stdlib_dsterf( n, d, e, info )
           else
              call stdlib_dstedc( 'I', n, d, e, z, ldz, work, lwork, iwork, liwork,info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 )call stdlib_dscal( n, one / sigma, d, 1 )
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_dstevd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$stevd( jobz, n, d, e, z, ldz, work, lwork, iwork,liwork, info )
     !! DSTEVD: computes all eigenvalues and, optionally, eigenvectors of a
     !! real symmetric tridiagonal matrix. If eigenvectors are desired, it
     !! uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, liwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, wantz
           integer(ilp) :: iscale, liwmin, lwmin
           real(${rk}$) :: bignum, eps, rmax, rmin, safmin, sigma, smlnum, tnrm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           lquery = ( lwork==-1 .or. liwork==-1 )
           info = 0
           liwmin = 1
           lwmin = 1
           if( n>1 .and. wantz ) then
              lwmin = 1 + 4*n + n**2
              liwmin = 3 + 5*n
           end if
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -6
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -8
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -10
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = sqrt( bignum )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           tnrm = stdlib_${ri}$lanst( 'M', n, d, e )
           if( tnrm>zero .and. tnrm<rmin ) then
              iscale = 1
              sigma = rmin / tnrm
           else if( tnrm>rmax ) then
              iscale = 1
              sigma = rmax / tnrm
           end if
           if( iscale==1 ) then
              call stdlib_${ri}$scal( n, sigma, d, 1 )
              call stdlib_${ri}$scal( n-1, sigma, e( 1 ), 1 )
           end if
           ! for eigenvalues only, call stdlib_${ri}$sterf.  for eigenvalues and
           ! eigenvectors, call stdlib_${ri}$stedc.
           if( .not.wantz ) then
              call stdlib_${ri}$sterf( n, d, e, info )
           else
              call stdlib_${ri}$stedc( 'I', n, d, e, z, ldz, work, lwork, iwork, liwork,info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           if( iscale==1 )call stdlib_${ri}$scal( n, one / sigma, d, 1 )
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$stevd

#:endif
#:endfor



     pure subroutine stdlib_slaed6( kniter, orgati, rho, d, z, finit, tau, info )
     !! SLAED6 computes the positive or negative root (closest to the origin)
     !! of
     !! z(1)        z(2)        z(3)
     !! f(x) =   rho + --------- + ---------- + ---------
     !! d(1)-x      d(2)-x      d(3)-x
     !! It is assumed that
     !! if ORGATI = .true. the root is between d(2) and d(3);
     !! otherwise it is between d(1) and d(2)
     !! This routine will be called by SLAED4 when necessary. In most cases,
     !! the root sought is the smallest in magnitude, though it might not be
     !! in some extremely rare situations.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: orgati
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kniter
           real(sp), intent(in) :: finit, rho
           real(sp), intent(out) :: tau
           ! Array Arguments 
           real(sp), intent(in) :: d(3), z(3)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 40
           
           
           ! Local Arrays 
           real(sp) :: dscale(3), zscale(3)
           ! Local Scalars 
           logical(lk) :: scale
           integer(ilp) :: i, iter, niter
           real(sp) :: a, b, base, c, ddf, df, eps, erretm, eta, f, fc, sclfac, sclinv, small1, &
                     small2, sminv1, sminv2, temp, temp1, temp2, temp3, temp4, lbd, ubd
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           if( orgati ) then
              lbd = d(2)
              ubd = d(3)
           else
              lbd = d(1)
              ubd = d(2)
           end if
           if( finit < zero )then
              lbd = zero
           else
              ubd = zero
           end if
           niter = 1
           tau = zero
           if( kniter==2 ) then
              if( orgati ) then
                 temp = ( d( 3 )-d( 2 ) ) / two
                 c = rho + z( 1 ) / ( ( d( 1 )-d( 2 ) )-temp )
                 a = c*( d( 2 )+d( 3 ) ) + z( 2 ) + z( 3 )
                 b = c*d( 2 )*d( 3 ) + z( 2 )*d( 3 ) + z( 3 )*d( 2 )
              else
                 temp = ( d( 1 )-d( 2 ) ) / two
                 c = rho + z( 3 ) / ( ( d( 3 )-d( 2 ) )-temp )
                 a = c*( d( 1 )+d( 2 ) ) + z( 1 ) + z( 2 )
                 b = c*d( 1 )*d( 2 ) + z( 1 )*d( 2 ) + z( 2 )*d( 1 )
              end if
              temp = max( abs( a ), abs( b ), abs( c ) )
              a = a / temp
              b = b / temp
              c = c / temp
              if( c==zero ) then
                 tau = b / a
              else if( a<=zero ) then
                 tau = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
              else
                 tau = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
              end if
              if( tau < lbd .or. tau > ubd )tau = ( lbd+ubd )/two
              if( d(1)==tau .or. d(2)==tau .or. d(3)==tau ) then
                 tau = zero
              else
                 temp = finit + tau*z(1)/( d(1)*( d( 1 )-tau ) ) +tau*z(2)/( d(2)*( d( 2 )-tau ) )&
                            +tau*z(3)/( d(3)*( d( 3 )-tau ) )
                 if( temp <= zero )then
                    lbd = tau
                 else
                    ubd = tau
                 end if
                 if( abs( finit )<=abs( temp ) )tau = zero
              end if
           end if
           ! get machine parameters for possible scaling to avoid overflow
           ! modified by sven: parameters small1, sminv1, small2,
           ! sminv2, eps are not saved anymore between one call to the
           ! others but recomputed at each call
           eps = stdlib_slamch( 'EPSILON' )
           base = stdlib_slamch( 'BASE' )
           small1 = base**( int( log( stdlib_slamch( 'SAFMIN' ) ) / log( base ) /three,KIND=ilp) )
                     
           sminv1 = one / small1
           small2 = small1*small1
           sminv2 = sminv1*sminv1
           ! determine if scaling of inputs necessary to avoid overflow
           ! when computing 1/temp**3
           if( orgati ) then
              temp = min( abs( d( 2 )-tau ), abs( d( 3 )-tau ) )
           else
              temp = min( abs( d( 1 )-tau ), abs( d( 2 )-tau ) )
           end if
           scale = .false.
           if( temp<=small1 ) then
              scale = .true.
              if( temp<=small2 ) then
              ! scale up by power of radix nearest 1/safmin**(2/3)
                 sclfac = sminv2
                 sclinv = small2
              else
              ! scale up by power of radix nearest 1/safmin**(1/3)
                 sclfac = sminv1
                 sclinv = small1
              end if
              ! scaling up safe because d, z, tau scaled elsewhere to be o(1)
              do i = 1, 3
                 dscale( i ) = d( i )*sclfac
                 zscale( i ) = z( i )*sclfac
              end do
              tau = tau*sclfac
              lbd = lbd*sclfac
              ubd = ubd*sclfac
           else
              ! copy d and z to dscale and zscale
              do i = 1, 3
                 dscale( i ) = d( i )
                 zscale( i ) = z( i )
              end do
           end if
           fc = zero
           df = zero
           ddf = zero
           do i = 1, 3
              temp = one / ( dscale( i )-tau )
              temp1 = zscale( i )*temp
              temp2 = temp1*temp
              temp3 = temp2*temp
              fc = fc + temp1 / dscale( i )
              df = df + temp2
              ddf = ddf + temp3
           end do
           f = finit + tau*fc
           if( abs( f )<=zero )go to 60
           if( f <= zero )then
              lbd = tau
           else
              ubd = tau
           end if
              ! iteration begins -- use gragg-thornton-warner cubic convergent
                                  ! scheme
           ! it is not hard to see that
                 ! 1) iterations will go up monotonically
                    ! if finit < 0;
                 ! 2) iterations will go down monotonically
                    ! if finit > 0.
           iter = niter + 1
           loop_50: do niter = iter, maxit
              if( orgati ) then
                 temp1 = dscale( 2 ) - tau
                 temp2 = dscale( 3 ) - tau
              else
                 temp1 = dscale( 1 ) - tau
                 temp2 = dscale( 2 ) - tau
              end if
              a = ( temp1+temp2 )*f - temp1*temp2*df
              b = temp1*temp2*f
              c = f - ( temp1+temp2 )*df + temp1*temp2*ddf
              temp = max( abs( a ), abs( b ), abs( c ) )
              a = a / temp
              b = b / temp
              c = c / temp
              if( c==zero ) then
                 eta = b / a
              else if( a<=zero ) then
                 eta = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
              else
                 eta = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
              end if
              if( f*eta>=zero ) then
                 eta = -f / df
              end if
              tau = tau + eta
              if( tau < lbd .or. tau > ubd )tau = ( lbd + ubd )/two
              fc = zero
              erretm = zero
              df = zero
              ddf = zero
              do i = 1, 3
                 if ( ( dscale( i )-tau )/=zero ) then
                    temp = one / ( dscale( i )-tau )
                    temp1 = zscale( i )*temp
                    temp2 = temp1*temp
                    temp3 = temp2*temp
                    temp4 = temp1 / dscale( i )
                    fc = fc + temp4
                    erretm = erretm + abs( temp4 )
                    df = df + temp2
                    ddf = ddf + temp3
                 else
                    go to 60
                 end if
              end do
              f = finit + tau*fc
              erretm = eight*( abs( finit )+abs( tau )*erretm ) +abs( tau )*df
              if( ( abs( f )<=four*eps*erretm ) .or.( (ubd-lbd)<=four*eps*abs(tau) )  )go to &
                        60
              if( f <= zero )then
                 lbd = tau
              else
                 ubd = tau
              end if
           end do loop_50
           info = 1
           60 continue
           ! undo scaling
           if( scale )tau = tau*sclinv
           return
     end subroutine stdlib_slaed6

     pure subroutine stdlib_dlaed6( kniter, orgati, rho, d, z, finit, tau, info )
     !! DLAED6 computes the positive or negative root (closest to the origin)
     !! of
     !! z(1)        z(2)        z(3)
     !! f(x) =   rho + --------- + ---------- + ---------
     !! d(1)-x      d(2)-x      d(3)-x
     !! It is assumed that
     !! if ORGATI = .true. the root is between d(2) and d(3);
     !! otherwise it is between d(1) and d(2)
     !! This routine will be called by DLAED4 when necessary. In most cases,
     !! the root sought is the smallest in magnitude, though it might not be
     !! in some extremely rare situations.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: orgati
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kniter
           real(dp), intent(in) :: finit, rho
           real(dp), intent(out) :: tau
           ! Array Arguments 
           real(dp), intent(in) :: d(3), z(3)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 40
           
           
           ! Local Arrays 
           real(dp) :: dscale(3), zscale(3)
           ! Local Scalars 
           logical(lk) :: scale
           integer(ilp) :: i, iter, niter
           real(dp) :: a, b, base, c, ddf, df, eps, erretm, eta, f, fc, sclfac, sclinv, small1, &
                     small2, sminv1, sminv2, temp, temp1, temp2, temp3, temp4, lbd, ubd
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           if( orgati ) then
              lbd = d(2)
              ubd = d(3)
           else
              lbd = d(1)
              ubd = d(2)
           end if
           if( finit < zero )then
              lbd = zero
           else
              ubd = zero
           end if
           niter = 1
           tau = zero
           if( kniter==2 ) then
              if( orgati ) then
                 temp = ( d( 3 )-d( 2 ) ) / two
                 c = rho + z( 1 ) / ( ( d( 1 )-d( 2 ) )-temp )
                 a = c*( d( 2 )+d( 3 ) ) + z( 2 ) + z( 3 )
                 b = c*d( 2 )*d( 3 ) + z( 2 )*d( 3 ) + z( 3 )*d( 2 )
              else
                 temp = ( d( 1 )-d( 2 ) ) / two
                 c = rho + z( 3 ) / ( ( d( 3 )-d( 2 ) )-temp )
                 a = c*( d( 1 )+d( 2 ) ) + z( 1 ) + z( 2 )
                 b = c*d( 1 )*d( 2 ) + z( 1 )*d( 2 ) + z( 2 )*d( 1 )
              end if
              temp = max( abs( a ), abs( b ), abs( c ) )
              a = a / temp
              b = b / temp
              c = c / temp
              if( c==zero ) then
                 tau = b / a
              else if( a<=zero ) then
                 tau = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
              else
                 tau = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
              end if
              if( tau < lbd .or. tau > ubd )tau = ( lbd+ubd )/two
              if( d(1)==tau .or. d(2)==tau .or. d(3)==tau ) then
                 tau = zero
              else
                 temp = finit + tau*z(1)/( d(1)*( d( 1 )-tau ) ) +tau*z(2)/( d(2)*( d( 2 )-tau ) )&
                            +tau*z(3)/( d(3)*( d( 3 )-tau ) )
                 if( temp <= zero )then
                    lbd = tau
                 else
                    ubd = tau
                 end if
                 if( abs( finit )<=abs( temp ) )tau = zero
              end if
           end if
           ! get machine parameters for possible scaling to avoid overflow
           ! modified by sven: parameters small1, sminv1, small2,
           ! sminv2, eps are not saved anymore between one call to the
           ! others but recomputed at each call
           eps = stdlib_dlamch( 'EPSILON' )
           base = stdlib_dlamch( 'BASE' )
           small1 = base**( int( log( stdlib_dlamch( 'SAFMIN' ) ) / log( base ) /three,KIND=ilp) )
                     
           sminv1 = one / small1
           small2 = small1*small1
           sminv2 = sminv1*sminv1
           ! determine if scaling of inputs necessary to avoid overflow
           ! when computing 1/temp**3
           if( orgati ) then
              temp = min( abs( d( 2 )-tau ), abs( d( 3 )-tau ) )
           else
              temp = min( abs( d( 1 )-tau ), abs( d( 2 )-tau ) )
           end if
           scale = .false.
           if( temp<=small1 ) then
              scale = .true.
              if( temp<=small2 ) then
              ! scale up by power of radix nearest 1/safmin**(2/3)
                 sclfac = sminv2
                 sclinv = small2
              else
              ! scale up by power of radix nearest 1/safmin**(1/3)
                 sclfac = sminv1
                 sclinv = small1
              end if
              ! scaling up safe because d, z, tau scaled elsewhere to be o(1)
              do i = 1, 3
                 dscale( i ) = d( i )*sclfac
                 zscale( i ) = z( i )*sclfac
              end do
              tau = tau*sclfac
              lbd = lbd*sclfac
              ubd = ubd*sclfac
           else
              ! copy d and z to dscale and zscale
              do i = 1, 3
                 dscale( i ) = d( i )
                 zscale( i ) = z( i )
              end do
           end if
           fc = zero
           df = zero
           ddf = zero
           do i = 1, 3
              temp = one / ( dscale( i )-tau )
              temp1 = zscale( i )*temp
              temp2 = temp1*temp
              temp3 = temp2*temp
              fc = fc + temp1 / dscale( i )
              df = df + temp2
              ddf = ddf + temp3
           end do
           f = finit + tau*fc
           if( abs( f )<=zero )go to 60
           if( f <= zero )then
              lbd = tau
           else
              ubd = tau
           end if
              ! iteration begins -- use gragg-thornton-warner cubic convergent
                                  ! scheme
           ! it is not hard to see that
                 ! 1) iterations will go up monotonically
                    ! if finit < 0;
                 ! 2) iterations will go down monotonically
                    ! if finit > 0.
           iter = niter + 1
           loop_50: do niter = iter, maxit
              if( orgati ) then
                 temp1 = dscale( 2 ) - tau
                 temp2 = dscale( 3 ) - tau
              else
                 temp1 = dscale( 1 ) - tau
                 temp2 = dscale( 2 ) - tau
              end if
              a = ( temp1+temp2 )*f - temp1*temp2*df
              b = temp1*temp2*f
              c = f - ( temp1+temp2 )*df + temp1*temp2*ddf
              temp = max( abs( a ), abs( b ), abs( c ) )
              a = a / temp
              b = b / temp
              c = c / temp
              if( c==zero ) then
                 eta = b / a
              else if( a<=zero ) then
                 eta = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
              else
                 eta = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
              end if
              if( f*eta>=zero ) then
                 eta = -f / df
              end if
              tau = tau + eta
              if( tau < lbd .or. tau > ubd )tau = ( lbd + ubd )/two
              fc = zero
              erretm = zero
              df = zero
              ddf = zero
              do i = 1, 3
                 if ( ( dscale( i )-tau )/=zero ) then
                    temp = one / ( dscale( i )-tau )
                    temp1 = zscale( i )*temp
                    temp2 = temp1*temp
                    temp3 = temp2*temp
                    temp4 = temp1 / dscale( i )
                    fc = fc + temp4
                    erretm = erretm + abs( temp4 )
                    df = df + temp2
                    ddf = ddf + temp3
                 else
                    go to 60
                 end if
              end do
              f = finit + tau*fc
              erretm = eight*( abs( finit )+abs( tau )*erretm ) +abs( tau )*df
              if( ( abs( f )<=four*eps*erretm ) .or.( (ubd-lbd)<=four*eps*abs(tau) )  )go to &
                        60
              if( f <= zero )then
                 lbd = tau
              else
                 ubd = tau
              end if
           end do loop_50
           info = 1
           60 continue
           ! undo scaling
           if( scale )tau = tau*sclinv
           return
     end subroutine stdlib_dlaed6

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laed6( kniter, orgati, rho, d, z, finit, tau, info )
     !! DLAED6: computes the positive or negative root (closest to the origin)
     !! of
     !! z(1)        z(2)        z(3)
     !! f(x) =   rho + --------- + ---------- + ---------
     !! d(1)-x      d(2)-x      d(3)-x
     !! It is assumed that
     !! if ORGATI = .true. the root is between d(2) and d(3);
     !! otherwise it is between d(1) and d(2)
     !! This routine will be called by DLAED4 when necessary. In most cases,
     !! the root sought is the smallest in magnitude, though it might not be
     !! in some extremely rare situations.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: orgati
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kniter
           real(${rk}$), intent(in) :: finit, rho
           real(${rk}$), intent(out) :: tau
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(3), z(3)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 40
           
           
           ! Local Arrays 
           real(${rk}$) :: dscale(3), zscale(3)
           ! Local Scalars 
           logical(lk) :: scale
           integer(ilp) :: i, iter, niter
           real(${rk}$) :: a, b, base, c, ddf, df, eps, erretm, eta, f, fc, sclfac, sclinv, small1, &
                     small2, sminv1, sminv2, temp, temp1, temp2, temp3, temp4, lbd, ubd
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           if( orgati ) then
              lbd = d(2)
              ubd = d(3)
           else
              lbd = d(1)
              ubd = d(2)
           end if
           if( finit < zero )then
              lbd = zero
           else
              ubd = zero
           end if
           niter = 1
           tau = zero
           if( kniter==2 ) then
              if( orgati ) then
                 temp = ( d( 3 )-d( 2 ) ) / two
                 c = rho + z( 1 ) / ( ( d( 1 )-d( 2 ) )-temp )
                 a = c*( d( 2 )+d( 3 ) ) + z( 2 ) + z( 3 )
                 b = c*d( 2 )*d( 3 ) + z( 2 )*d( 3 ) + z( 3 )*d( 2 )
              else
                 temp = ( d( 1 )-d( 2 ) ) / two
                 c = rho + z( 3 ) / ( ( d( 3 )-d( 2 ) )-temp )
                 a = c*( d( 1 )+d( 2 ) ) + z( 1 ) + z( 2 )
                 b = c*d( 1 )*d( 2 ) + z( 1 )*d( 2 ) + z( 2 )*d( 1 )
              end if
              temp = max( abs( a ), abs( b ), abs( c ) )
              a = a / temp
              b = b / temp
              c = c / temp
              if( c==zero ) then
                 tau = b / a
              else if( a<=zero ) then
                 tau = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
              else
                 tau = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
              end if
              if( tau < lbd .or. tau > ubd )tau = ( lbd+ubd )/two
              if( d(1)==tau .or. d(2)==tau .or. d(3)==tau ) then
                 tau = zero
              else
                 temp = finit + tau*z(1)/( d(1)*( d( 1 )-tau ) ) +tau*z(2)/( d(2)*( d( 2 )-tau ) )&
                            +tau*z(3)/( d(3)*( d( 3 )-tau ) )
                 if( temp <= zero )then
                    lbd = tau
                 else
                    ubd = tau
                 end if
                 if( abs( finit )<=abs( temp ) )tau = zero
              end if
           end if
           ! get machine parameters for possible scaling to avoid overflow
           ! modified by sven: parameters small1, sminv1, small2,
           ! sminv2, eps are not saved anymore between one call to the
           ! others but recomputed at each call
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           base = stdlib_${ri}$lamch( 'BASE' )
           small1 = base**( int( log( stdlib_${ri}$lamch( 'SAFMIN' ) ) / log( base ) /three,KIND=ilp) )
                     
           sminv1 = one / small1
           small2 = small1*small1
           sminv2 = sminv1*sminv1
           ! determine if scaling of inputs necessary to avoid overflow
           ! when computing 1/temp**3
           if( orgati ) then
              temp = min( abs( d( 2 )-tau ), abs( d( 3 )-tau ) )
           else
              temp = min( abs( d( 1 )-tau ), abs( d( 2 )-tau ) )
           end if
           scale = .false.
           if( temp<=small1 ) then
              scale = .true.
              if( temp<=small2 ) then
              ! scale up by power of radix nearest 1/safmin**(2/3)
                 sclfac = sminv2
                 sclinv = small2
              else
              ! scale up by power of radix nearest 1/safmin**(1/3)
                 sclfac = sminv1
                 sclinv = small1
              end if
              ! scaling up safe because d, z, tau scaled elsewhere to be o(1)
              do i = 1, 3
                 dscale( i ) = d( i )*sclfac
                 zscale( i ) = z( i )*sclfac
              end do
              tau = tau*sclfac
              lbd = lbd*sclfac
              ubd = ubd*sclfac
           else
              ! copy d and z to dscale and zscale
              do i = 1, 3
                 dscale( i ) = d( i )
                 zscale( i ) = z( i )
              end do
           end if
           fc = zero
           df = zero
           ddf = zero
           do i = 1, 3
              temp = one / ( dscale( i )-tau )
              temp1 = zscale( i )*temp
              temp2 = temp1*temp
              temp3 = temp2*temp
              fc = fc + temp1 / dscale( i )
              df = df + temp2
              ddf = ddf + temp3
           end do
           f = finit + tau*fc
           if( abs( f )<=zero )go to 60
           if( f <= zero )then
              lbd = tau
           else
              ubd = tau
           end if
              ! iteration begins -- use gragg-thornton-warner cubic convergent
                                  ! scheme
           ! it is not hard to see that
                 ! 1) iterations will go up monotonically
                    ! if finit < 0;
                 ! 2) iterations will go down monotonically
                    ! if finit > 0.
           iter = niter + 1
           loop_50: do niter = iter, maxit
              if( orgati ) then
                 temp1 = dscale( 2 ) - tau
                 temp2 = dscale( 3 ) - tau
              else
                 temp1 = dscale( 1 ) - tau
                 temp2 = dscale( 2 ) - tau
              end if
              a = ( temp1+temp2 )*f - temp1*temp2*df
              b = temp1*temp2*f
              c = f - ( temp1+temp2 )*df + temp1*temp2*ddf
              temp = max( abs( a ), abs( b ), abs( c ) )
              a = a / temp
              b = b / temp
              c = c / temp
              if( c==zero ) then
                 eta = b / a
              else if( a<=zero ) then
                 eta = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
              else
                 eta = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
              end if
              if( f*eta>=zero ) then
                 eta = -f / df
              end if
              tau = tau + eta
              if( tau < lbd .or. tau > ubd )tau = ( lbd + ubd )/two
              fc = zero
              erretm = zero
              df = zero
              ddf = zero
              do i = 1, 3
                 if ( ( dscale( i )-tau )/=zero ) then
                    temp = one / ( dscale( i )-tau )
                    temp1 = zscale( i )*temp
                    temp2 = temp1*temp
                    temp3 = temp2*temp
                    temp4 = temp1 / dscale( i )
                    fc = fc + temp4
                    erretm = erretm + abs( temp4 )
                    df = df + temp2
                    ddf = ddf + temp3
                 else
                    go to 60
                 end if
              end do
              f = finit + tau*fc
              erretm = eight*( abs( finit )+abs( tau )*erretm ) +abs( tau )*df
              if( ( abs( f )<=four*eps*erretm ) .or.( (ubd-lbd)<=four*eps*abs(tau) )  )go to &
                        60
              if( f <= zero )then
                 lbd = tau
              else
                 ubd = tau
              end if
           end do loop_50
           info = 1
           60 continue
           ! undo scaling
           if( scale )tau = tau*sclinv
           return
     end subroutine stdlib_${ri}$laed6

#:endif
#:endfor



     pure subroutine stdlib_slaev2( a, b, c, rt1, rt2, cs1, sn1 )
     !! SLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix
     !! [  A   B  ]
     !! [  B   C  ].
     !! On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
     !! eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
     !! eigenvector for RT1, giving the decomposition
     !! [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
     !! [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(sp), intent(in) :: a, b, c
           real(sp), intent(out) :: cs1, rt1, rt2, sn1
       ! =====================================================================
           
           
           
           
           ! Local Scalars 
           integer(ilp) :: sgn1, sgn2
           real(sp) :: ab, acmn, acmx, acs, adf, cs, ct, df, rt, sm, tb, tn
           ! Intrinsic Functions 
           ! Executable Statements 
           ! compute the eigenvalues
           sm = a + c
           df = a - c
           adf = abs( df )
           tb = b + b
           ab = abs( tb )
           if( abs( a )>abs( c ) ) then
              acmx = a
              acmn = c
           else
              acmx = c
              acmn = a
           end if
           if( adf>ab ) then
              rt = adf*sqrt( one+( ab / adf )**2 )
           else if( adf<ab ) then
              rt = ab*sqrt( one+( adf / ab )**2 )
           else
              ! includes case ab=adf=0
              rt = ab*sqrt( two )
           end if
           if( sm<zero ) then
              rt1 = half*( sm-rt )
              sgn1 = -1
              ! order of execution important.
              ! to get fully accurate smaller eigenvalue,
              ! next line needs to be executed in higher precision.
              rt2 = ( acmx / rt1 )*acmn - ( b / rt1 )*b
           else if( sm>zero ) then
              rt1 = half*( sm+rt )
              sgn1 = 1
              ! order of execution important.
              ! to get fully accurate smaller eigenvalue,
              ! next line needs to be executed in higher precision.
              rt2 = ( acmx / rt1 )*acmn - ( b / rt1 )*b
           else
              ! includes case rt1 = rt2 = 0
              rt1 = half*rt
              rt2 = -half*rt
              sgn1 = 1
           end if
           ! compute the eigenvector
           if( df>=zero ) then
              cs = df + rt
              sgn2 = 1
           else
              cs = df - rt
              sgn2 = -1
           end if
           acs = abs( cs )
           if( acs>ab ) then
              ct = -tb / cs
              sn1 = one / sqrt( one+ct*ct )
              cs1 = ct*sn1
           else
              if( ab==zero ) then
                 cs1 = one
                 sn1 = zero
              else
                 tn = -cs / tb
                 cs1 = one / sqrt( one+tn*tn )
                 sn1 = tn*cs1
              end if
           end if
           if( sgn1==sgn2 ) then
              tn = cs1
              cs1 = -sn1
              sn1 = tn
           end if
           return
     end subroutine stdlib_slaev2

     pure subroutine stdlib_dlaev2( a, b, c, rt1, rt2, cs1, sn1 )
     !! DLAEV2 computes the eigendecomposition of a 2-by-2 symmetric matrix
     !! [  A   B  ]
     !! [  B   C  ].
     !! On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
     !! eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
     !! eigenvector for RT1, giving the decomposition
     !! [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
     !! [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(dp), intent(in) :: a, b, c
           real(dp), intent(out) :: cs1, rt1, rt2, sn1
       ! =====================================================================
           
           
           
           
           ! Local Scalars 
           integer(ilp) :: sgn1, sgn2
           real(dp) :: ab, acmn, acmx, acs, adf, cs, ct, df, rt, sm, tb, tn
           ! Intrinsic Functions 
           ! Executable Statements 
           ! compute the eigenvalues
           sm = a + c
           df = a - c
           adf = abs( df )
           tb = b + b
           ab = abs( tb )
           if( abs( a )>abs( c ) ) then
              acmx = a
              acmn = c
           else
              acmx = c
              acmn = a
           end if
           if( adf>ab ) then
              rt = adf*sqrt( one+( ab / adf )**2 )
           else if( adf<ab ) then
              rt = ab*sqrt( one+( adf / ab )**2 )
           else
              ! includes case ab=adf=0
              rt = ab*sqrt( two )
           end if
           if( sm<zero ) then
              rt1 = half*( sm-rt )
              sgn1 = -1
              ! order of execution important.
              ! to get fully accurate smaller eigenvalue,
              ! next line needs to be executed in higher precision.
              rt2 = ( acmx / rt1 )*acmn - ( b / rt1 )*b
           else if( sm>zero ) then
              rt1 = half*( sm+rt )
              sgn1 = 1
              ! order of execution important.
              ! to get fully accurate smaller eigenvalue,
              ! next line needs to be executed in higher precision.
              rt2 = ( acmx / rt1 )*acmn - ( b / rt1 )*b
           else
              ! includes case rt1 = rt2 = 0
              rt1 = half*rt
              rt2 = -half*rt
              sgn1 = 1
           end if
           ! compute the eigenvector
           if( df>=zero ) then
              cs = df + rt
              sgn2 = 1
           else
              cs = df - rt
              sgn2 = -1
           end if
           acs = abs( cs )
           if( acs>ab ) then
              ct = -tb / cs
              sn1 = one / sqrt( one+ct*ct )
              cs1 = ct*sn1
           else
              if( ab==zero ) then
                 cs1 = one
                 sn1 = zero
              else
                 tn = -cs / tb
                 cs1 = one / sqrt( one+tn*tn )
                 sn1 = tn*cs1
              end if
           end if
           if( sgn1==sgn2 ) then
              tn = cs1
              cs1 = -sn1
              sn1 = tn
           end if
           return
     end subroutine stdlib_dlaev2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laev2( a, b, c, rt1, rt2, cs1, sn1 )
     !! DLAEV2: computes the eigendecomposition of a 2-by-2 symmetric matrix
     !! [  A   B  ]
     !! [  B   C  ].
     !! On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
     !! eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
     !! eigenvector for RT1, giving the decomposition
     !! [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
     !! [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(${rk}$), intent(in) :: a, b, c
           real(${rk}$), intent(out) :: cs1, rt1, rt2, sn1
       ! =====================================================================
           
           
           
           
           ! Local Scalars 
           integer(ilp) :: sgn1, sgn2
           real(${rk}$) :: ab, acmn, acmx, acs, adf, cs, ct, df, rt, sm, tb, tn
           ! Intrinsic Functions 
           ! Executable Statements 
           ! compute the eigenvalues
           sm = a + c
           df = a - c
           adf = abs( df )
           tb = b + b
           ab = abs( tb )
           if( abs( a )>abs( c ) ) then
              acmx = a
              acmn = c
           else
              acmx = c
              acmn = a
           end if
           if( adf>ab ) then
              rt = adf*sqrt( one+( ab / adf )**2 )
           else if( adf<ab ) then
              rt = ab*sqrt( one+( adf / ab )**2 )
           else
              ! includes case ab=adf=0
              rt = ab*sqrt( two )
           end if
           if( sm<zero ) then
              rt1 = half*( sm-rt )
              sgn1 = -1
              ! order of execution important.
              ! to get fully accurate smaller eigenvalue,
              ! next line needs to be executed in higher precision.
              rt2 = ( acmx / rt1 )*acmn - ( b / rt1 )*b
           else if( sm>zero ) then
              rt1 = half*( sm+rt )
              sgn1 = 1
              ! order of execution important.
              ! to get fully accurate smaller eigenvalue,
              ! next line needs to be executed in higher precision.
              rt2 = ( acmx / rt1 )*acmn - ( b / rt1 )*b
           else
              ! includes case rt1 = rt2 = 0
              rt1 = half*rt
              rt2 = -half*rt
              sgn1 = 1
           end if
           ! compute the eigenvector
           if( df>=zero ) then
              cs = df + rt
              sgn2 = 1
           else
              cs = df - rt
              sgn2 = -1
           end if
           acs = abs( cs )
           if( acs>ab ) then
              ct = -tb / cs
              sn1 = one / sqrt( one+ct*ct )
              cs1 = ct*sn1
           else
              if( ab==zero ) then
                 cs1 = one
                 sn1 = zero
              else
                 tn = -cs / tb
                 cs1 = one / sqrt( one+tn*tn )
                 sn1 = tn*cs1
              end if
           end if
           if( sgn1==sgn2 ) then
              tn = cs1
              cs1 = -sn1
              sn1 = tn
           end if
           return
     end subroutine stdlib_${ri}$laev2

#:endif
#:endfor

     pure subroutine stdlib_claev2( a, b, c, rt1, rt2, cs1, sn1 )
     !! CLAEV2 computes the eigendecomposition of a 2-by-2 Hermitian matrix
     !! [  A         B  ]
     !! [  CONJG(B)  C  ].
     !! On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
     !! eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
     !! eigenvector for RT1, giving the decomposition
     !! [ CS1  CONJG(SN1) ] [    A     B ] [ CS1 -CONJG(SN1) ] = [ RT1  0  ]
     !! [-SN1     CS1     ] [ CONJG(B) C ] [ SN1     CS1     ]   [  0  RT2 ].
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(sp), intent(out) :: cs1, rt1, rt2
           complex(sp), intent(in) :: a, b, c
           complex(sp), intent(out) :: sn1
       ! =====================================================================
           
           
           ! Local Scalars 
           real(sp) :: t
           complex(sp) :: w
           ! Intrinsic Functions 
           ! Executable Statements 
           if( abs( b )==zero ) then
              w = one
           else
              w = conjg( b ) / abs( b )
           end if
           call stdlib_slaev2( real( a,KIND=sp), abs( b ), real( c,KIND=sp), rt1, rt2, cs1, t )
                     
           sn1 = w*t
           return
     end subroutine stdlib_claev2

     pure subroutine stdlib_zlaev2( a, b, c, rt1, rt2, cs1, sn1 )
     !! ZLAEV2 computes the eigendecomposition of a 2-by-2 Hermitian matrix
     !! [  A         B  ]
     !! [  CONJG(B)  C  ].
     !! On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
     !! eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
     !! eigenvector for RT1, giving the decomposition
     !! [ CS1  CONJG(SN1) ] [    A     B ] [ CS1 -CONJG(SN1) ] = [ RT1  0  ]
     !! [-SN1     CS1     ] [ CONJG(B) C ] [ SN1     CS1     ]   [  0  RT2 ].
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(dp), intent(out) :: cs1, rt1, rt2
           complex(dp), intent(in) :: a, b, c
           complex(dp), intent(out) :: sn1
       ! =====================================================================
           
           
           ! Local Scalars 
           real(dp) :: t
           complex(dp) :: w
           ! Intrinsic Functions 
           ! Executable Statements 
           if( abs( b )==zero ) then
              w = one
           else
              w = conjg( b ) / abs( b )
           end if
           call stdlib_dlaev2( real( a,KIND=dp), abs( b ), real( c,KIND=dp), rt1, rt2, cs1, t )
                     
           sn1 = w*t
           return
     end subroutine stdlib_zlaev2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$laev2( a, b, c, rt1, rt2, cs1, sn1 )
     !! ZLAEV2: computes the eigendecomposition of a 2-by-2 Hermitian matrix
     !! [  A         B  ]
     !! [  CONJG(B)  C  ].
     !! On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
     !! eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
     !! eigenvector for RT1, giving the decomposition
     !! [ CS1  CONJG(SN1) ] [    A     B ] [ CS1 -CONJG(SN1) ] = [ RT1  0  ]
     !! [-SN1     CS1     ] [ CONJG(B) C ] [ SN1     CS1     ]   [  0  RT2 ].
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           real(${ck}$), intent(out) :: cs1, rt1, rt2
           complex(${ck}$), intent(in) :: a, b, c
           complex(${ck}$), intent(out) :: sn1
       ! =====================================================================
           
           
           ! Local Scalars 
           real(${ck}$) :: t
           complex(${ck}$) :: w
           ! Intrinsic Functions 
           ! Executable Statements 
           if( abs( b )==zero ) then
              w = one
           else
              w = conjg( b ) / abs( b )
           end if
           call stdlib_${c2ri(ci)}$laev2( real( a,KIND=${ck}$), abs( b ), real( c,KIND=${ck}$), rt1, rt2, cs1, t )
                     
           sn1 = w*t
           return
     end subroutine stdlib_${ci}$laev2

#:endif
#:endfor







     pure subroutine stdlib_chbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
     !! CHBGV computes all the eigenvalues, and optionally, the eigenvectors
     !! of a complex generalized Hermitian-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
     !! and banded, and B is also positive definite.
               rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ka, kb, ldab, ldbb, ldz, n
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper, wantz
           character :: vect
           integer(ilp) :: iinfo, inde, indwrk
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ka<0 ) then
              info = -4
           else if( kb<0 .or. kb>ka ) then
              info = -5
           else if( ldab<ka+1 ) then
              info = -7
           else if( ldbb<kb+1 ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHBGV ', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_cpbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           inde = 1
           indwrk = inde + n
           call stdlib_chbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, z, ldz,work, rwork( &
                     indwrk ), iinfo )
           ! reduce to tridiagonal form.
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_chbtrd( vect, uplo, n, ka, ab, ldab, w, rwork( inde ), z,ldz, work, iinfo )
                     
           ! for eigenvalues only, call stdlib_ssterf.  for eigenvectors, call stdlib_csteqr.
           if( .not.wantz ) then
              call stdlib_ssterf( n, w, rwork( inde ), info )
           else
              call stdlib_csteqr( jobz, n, w, rwork( inde ), z, ldz,rwork( indwrk ), info )
                        
           end if
           return
     end subroutine stdlib_chbgv

     pure subroutine stdlib_zhbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
     !! ZHBGV computes all the eigenvalues, and optionally, the eigenvectors
     !! of a complex generalized Hermitian-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
     !! and banded, and B is also positive definite.
               rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ka, kb, ldab, ldbb, ldz, n
           ! Array Arguments 
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(dp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper, wantz
           character :: vect
           integer(ilp) :: iinfo, inde, indwrk
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ka<0 ) then
              info = -4
           else if( kb<0 .or. kb>ka ) then
              info = -5
           else if( ldab<ka+1 ) then
              info = -7
           else if( ldbb<kb+1 ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHBGV ', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_zpbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           inde = 1
           indwrk = inde + n
           call stdlib_zhbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, z, ldz,work, rwork( &
                     indwrk ), iinfo )
           ! reduce to tridiagonal form.
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_zhbtrd( vect, uplo, n, ka, ab, ldab, w, rwork( inde ), z,ldz, work, iinfo )
                     
           ! for eigenvalues only, call stdlib_dsterf.  for eigenvectors, call stdlib_zsteqr.
           if( .not.wantz ) then
              call stdlib_dsterf( n, w, rwork( inde ), info )
           else
              call stdlib_zsteqr( jobz, n, w, rwork( inde ), z, ldz,rwork( indwrk ), info )
                        
           end if
           return
     end subroutine stdlib_zhbgv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$hbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
     !! ZHBGV: computes all the eigenvalues, and optionally, the eigenvectors
     !! of a complex generalized Hermitian-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
     !! and banded, and B is also positive definite.
               rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ka, kb, ldab, ldbb, ldz, n
           ! Array Arguments 
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(${ck}$), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper, wantz
           character :: vect
           integer(ilp) :: iinfo, inde, indwrk
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ka<0 ) then
              info = -4
           else if( kb<0 .or. kb>ka ) then
              info = -5
           else if( ldab<ka+1 ) then
              info = -7
           else if( ldbb<kb+1 ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHBGV ', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_${ci}$pbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           inde = 1
           indwrk = inde + n
           call stdlib_${ci}$hbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, z, ldz,work, rwork( &
                     indwrk ), iinfo )
           ! reduce to tridiagonal form.
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_${ci}$hbtrd( vect, uplo, n, ka, ab, ldab, w, rwork( inde ), z,ldz, work, iinfo )
                     
           ! for eigenvalues only, call stdlib_${c2ri(ci)}$sterf.  for eigenvectors, call stdlib_${ci}$steqr.
           if( .not.wantz ) then
              call stdlib_${c2ri(ci)}$sterf( n, w, rwork( inde ), info )
           else
              call stdlib_${ci}$steqr( jobz, n, w, rwork( inde ), z, ldz,rwork( indwrk ), info )
                        
           end if
           return
     end subroutine stdlib_${ci}$hbgv

#:endif
#:endfor









     pure subroutine  stdlib_chb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, lda, &
     !! CHB2ST_KERNELS is an internal routine used by the CHETRD_HB2ST
     !! subroutine.
               v, tau, ldvt, work)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           logical(lk), intent(in) :: wantz
           integer(ilp), intent(in) :: ttype, st, ed, sweep, n, nb, ib, lda, ldvt
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: v(*), tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j1, j2, lm, ln, vpos, taupos, dpos, ofdpos, ajeter
           complex(sp) :: ctmp
           ! Intrinsic Functions 
           ! Executable Statements 
           ajeter = ib + ldvt
           upper = stdlib_lsame( uplo, 'U' )
           if( upper ) then
               dpos    = 2 * nb + 1
               ofdpos  = 2 * nb
           else
               dpos    = 1
               ofdpos  = 2
           endif
           ! upper case
           if( upper ) then
               if( wantz ) then
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               else
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               endif
               if( ttype==1 ) then
                   lm = ed - st + 1
                   v( vpos ) = cone
                   do i = 1, lm-1
                       v( vpos+i )         = conjg( a( ofdpos-i, st+i ) )
                       a( ofdpos-i, st+i ) = czero
                   end do
                   ctmp = conjg( a( ofdpos, st ) )
                   call stdlib_clarfg( lm, ctmp, v( vpos+1 ), 1,tau( taupos ) )
                   a( ofdpos, st ) = ctmp
                   lm = ed - st + 1
                   call stdlib_clarfy( uplo, lm, v( vpos ), 1,conjg( tau( taupos ) ),a( dpos, st )&
                             , lda-1, work)
               endif
               if( ttype==3 ) then
                   lm = ed - st + 1
                   call stdlib_clarfy( uplo, lm, v( vpos ), 1,conjg( tau( taupos ) ),a( dpos, st )&
                             , lda-1, work)
               endif
               if( ttype==2 ) then
                   j1 = ed+1
                   j2 = min( ed+nb, n )
                   ln = ed-st+1
                   lm = j2-j1+1
                   if( lm>0) then
                       call stdlib_clarfx( 'LEFT', ln, lm, v( vpos ),conjg( tau( taupos ) ),a( &
                                 dpos-nb, j1 ), lda-1, work)
                       if( wantz ) then
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       else
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       endif
                       v( vpos ) = cone
                       do i = 1, lm-1
                           v( vpos+i )          =conjg( a( dpos-nb-i, j1+i ) )
                           a( dpos-nb-i, j1+i ) = czero
                       end do
                       ctmp = conjg( a( dpos-nb, j1 ) )
                       call stdlib_clarfg( lm, ctmp, v( vpos+1 ), 1, tau( taupos ) )
                       a( dpos-nb, j1 ) = ctmp
                       call stdlib_clarfx( 'RIGHT', ln-1, lm, v( vpos ),tau( taupos ),a( dpos-nb+&
                                 1, j1 ), lda-1, work)
                   endif
               endif
           ! lower case
           else
               if( wantz ) then
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               else
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               endif
               if( ttype==1 ) then
                   lm = ed - st + 1
                   v( vpos ) = cone
                   do i = 1, lm-1
                       v( vpos+i )         = a( ofdpos+i, st-1 )
                       a( ofdpos+i, st-1 ) = czero
                   end do
                   call stdlib_clarfg( lm, a( ofdpos, st-1 ), v( vpos+1 ), 1,tau( taupos ) )
                             
                   lm = ed - st + 1
                   call stdlib_clarfy( uplo, lm, v( vpos ), 1,conjg( tau( taupos ) ),a( dpos, st )&
                             , lda-1, work)
               endif
               if( ttype==3 ) then
                   lm = ed - st + 1
                   call stdlib_clarfy( uplo, lm, v( vpos ), 1,conjg( tau( taupos ) ),a( dpos, st )&
                             , lda-1, work)
               endif
               if( ttype==2 ) then
                   j1 = ed+1
                   j2 = min( ed+nb, n )
                   ln = ed-st+1
                   lm = j2-j1+1
                   if( lm>0) then
                       call stdlib_clarfx( 'RIGHT', lm, ln, v( vpos ),tau( taupos ), a( dpos+nb, &
                                 st ),lda-1, work)
                       if( wantz ) then
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       else
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       endif
                       v( vpos ) = cone
                       do i = 1, lm-1
                           v( vpos+i )        = a( dpos+nb+i, st )
                           a( dpos+nb+i, st ) = czero
                       end do
                       call stdlib_clarfg( lm, a( dpos+nb, st ), v( vpos+1 ), 1,tau( taupos ) )
                                 
                       call stdlib_clarfx( 'LEFT', lm, ln-1, v( vpos ),conjg( tau( taupos ) ),a( &
                                 dpos+nb-1, st+1 ), lda-1, work)
                   endif
               endif
           endif
           return
     end subroutine stdlib_chb2st_kernels

     pure subroutine  stdlib_zhb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, lda, &
     !! ZHB2ST_KERNELS is an internal routine used by the ZHETRD_HB2ST
     !! subroutine.
               v, tau, ldvt, work)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           logical(lk), intent(in) :: wantz
           integer(ilp), intent(in) :: ttype, st, ed, sweep, n, nb, ib, lda, ldvt
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: v(*), tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j1, j2, lm, ln, vpos, taupos, dpos, ofdpos, ajeter
           complex(dp) :: ctmp
           ! Intrinsic Functions 
           ! Executable Statements 
           ajeter = ib + ldvt
           upper = stdlib_lsame( uplo, 'U' )
           if( upper ) then
               dpos    = 2 * nb + 1
               ofdpos  = 2 * nb
           else
               dpos    = 1
               ofdpos  = 2
           endif
           ! upper case
           if( upper ) then
               if( wantz ) then
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               else
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               endif
               if( ttype==1 ) then
                   lm = ed - st + 1
                   v( vpos ) = cone
                   do i = 1, lm-1
                       v( vpos+i )         = conjg( a( ofdpos-i, st+i ) )
                       a( ofdpos-i, st+i ) = czero
                   end do
                   ctmp = conjg( a( ofdpos, st ) )
                   call stdlib_zlarfg( lm, ctmp, v( vpos+1 ), 1,tau( taupos ) )
                   a( ofdpos, st ) = ctmp
                   lm = ed - st + 1
                   call stdlib_zlarfy( uplo, lm, v( vpos ), 1,conjg( tau( taupos ) ),a( dpos, st )&
                             , lda-1, work)
               endif
               if( ttype==3 ) then
                   lm = ed - st + 1
                   call stdlib_zlarfy( uplo, lm, v( vpos ), 1,conjg( tau( taupos ) ),a( dpos, st )&
                             , lda-1, work)
               endif
               if( ttype==2 ) then
                   j1 = ed+1
                   j2 = min( ed+nb, n )
                   ln = ed-st+1
                   lm = j2-j1+1
                   if( lm>0) then
                       call stdlib_zlarfx( 'LEFT', ln, lm, v( vpos ),conjg( tau( taupos ) ),a( &
                                 dpos-nb, j1 ), lda-1, work)
                       if( wantz ) then
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       else
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       endif
                       v( vpos ) = cone
                       do i = 1, lm-1
                           v( vpos+i )          =conjg( a( dpos-nb-i, j1+i ) )
                           a( dpos-nb-i, j1+i ) = czero
                       end do
                       ctmp = conjg( a( dpos-nb, j1 ) )
                       call stdlib_zlarfg( lm, ctmp, v( vpos+1 ), 1, tau( taupos ) )
                       a( dpos-nb, j1 ) = ctmp
                       call stdlib_zlarfx( 'RIGHT', ln-1, lm, v( vpos ),tau( taupos ),a( dpos-nb+&
                                 1, j1 ), lda-1, work)
                   endif
               endif
           ! lower case
           else
               if( wantz ) then
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               else
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               endif
               if( ttype==1 ) then
                   lm = ed - st + 1
                   v( vpos ) = cone
                   do i = 1, lm-1
                       v( vpos+i )         = a( ofdpos+i, st-1 )
                       a( ofdpos+i, st-1 ) = czero
                   end do
                   call stdlib_zlarfg( lm, a( ofdpos, st-1 ), v( vpos+1 ), 1,tau( taupos ) )
                             
                   lm = ed - st + 1
                   call stdlib_zlarfy( uplo, lm, v( vpos ), 1,conjg( tau( taupos ) ),a( dpos, st )&
                             , lda-1, work)
               endif
               if( ttype==3 ) then
                   lm = ed - st + 1
                   call stdlib_zlarfy( uplo, lm, v( vpos ), 1,conjg( tau( taupos ) ),a( dpos, st )&
                             , lda-1, work)
               endif
               if( ttype==2 ) then
                   j1 = ed+1
                   j2 = min( ed+nb, n )
                   ln = ed-st+1
                   lm = j2-j1+1
                   if( lm>0) then
                       call stdlib_zlarfx( 'RIGHT', lm, ln, v( vpos ),tau( taupos ), a( dpos+nb, &
                                 st ),lda-1, work)
                       if( wantz ) then
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       else
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       endif
                       v( vpos ) = cone
                       do i = 1, lm-1
                           v( vpos+i )        = a( dpos+nb+i, st )
                           a( dpos+nb+i, st ) = czero
                       end do
                       call stdlib_zlarfg( lm, a( dpos+nb, st ), v( vpos+1 ), 1,tau( taupos ) )
                                 
                       call stdlib_zlarfx( 'LEFT', lm, ln-1, v( vpos ),conjg( tau( taupos ) ),a( &
                                 dpos+nb-1, st+1 ), lda-1, work)
                   endif
               endif
           endif
           return
     end subroutine stdlib_zhb2st_kernels

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine  stdlib_${ci}$hb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, lda, &
     !! ZHB2ST_KERNELS: is an internal routine used by the ZHETRD_HB2ST
     !! subroutine.
               v, tau, ldvt, work)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           logical(lk), intent(in) :: wantz
           integer(ilp), intent(in) :: ttype, st, ed, sweep, n, nb, ib, lda, ldvt
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: v(*), tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j1, j2, lm, ln, vpos, taupos, dpos, ofdpos, ajeter
           complex(${ck}$) :: ctmp
           ! Intrinsic Functions 
           ! Executable Statements 
           ajeter = ib + ldvt
           upper = stdlib_lsame( uplo, 'U' )
           if( upper ) then
               dpos    = 2 * nb + 1
               ofdpos  = 2 * nb
           else
               dpos    = 1
               ofdpos  = 2
           endif
           ! upper case
           if( upper ) then
               if( wantz ) then
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               else
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               endif
               if( ttype==1 ) then
                   lm = ed - st + 1
                   v( vpos ) = cone
                   do i = 1, lm-1
                       v( vpos+i )         = conjg( a( ofdpos-i, st+i ) )
                       a( ofdpos-i, st+i ) = czero
                   end do
                   ctmp = conjg( a( ofdpos, st ) )
                   call stdlib_${ci}$larfg( lm, ctmp, v( vpos+1 ), 1,tau( taupos ) )
                   a( ofdpos, st ) = ctmp
                   lm = ed - st + 1
                   call stdlib_${ci}$larfy( uplo, lm, v( vpos ), 1,conjg( tau( taupos ) ),a( dpos, st )&
                             , lda-1, work)
               endif
               if( ttype==3 ) then
                   lm = ed - st + 1
                   call stdlib_${ci}$larfy( uplo, lm, v( vpos ), 1,conjg( tau( taupos ) ),a( dpos, st )&
                             , lda-1, work)
               endif
               if( ttype==2 ) then
                   j1 = ed+1
                   j2 = min( ed+nb, n )
                   ln = ed-st+1
                   lm = j2-j1+1
                   if( lm>0) then
                       call stdlib_${ci}$larfx( 'LEFT', ln, lm, v( vpos ),conjg( tau( taupos ) ),a( &
                                 dpos-nb, j1 ), lda-1, work)
                       if( wantz ) then
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       else
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       endif
                       v( vpos ) = cone
                       do i = 1, lm-1
                           v( vpos+i )          =conjg( a( dpos-nb-i, j1+i ) )
                           a( dpos-nb-i, j1+i ) = czero
                       end do
                       ctmp = conjg( a( dpos-nb, j1 ) )
                       call stdlib_${ci}$larfg( lm, ctmp, v( vpos+1 ), 1, tau( taupos ) )
                       a( dpos-nb, j1 ) = ctmp
                       call stdlib_${ci}$larfx( 'RIGHT', ln-1, lm, v( vpos ),tau( taupos ),a( dpos-nb+&
                                 1, j1 ), lda-1, work)
                   endif
               endif
           ! lower case
           else
               if( wantz ) then
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               else
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               endif
               if( ttype==1 ) then
                   lm = ed - st + 1
                   v( vpos ) = cone
                   do i = 1, lm-1
                       v( vpos+i )         = a( ofdpos+i, st-1 )
                       a( ofdpos+i, st-1 ) = czero
                   end do
                   call stdlib_${ci}$larfg( lm, a( ofdpos, st-1 ), v( vpos+1 ), 1,tau( taupos ) )
                             
                   lm = ed - st + 1
                   call stdlib_${ci}$larfy( uplo, lm, v( vpos ), 1,conjg( tau( taupos ) ),a( dpos, st )&
                             , lda-1, work)
               endif
               if( ttype==3 ) then
                   lm = ed - st + 1
                   call stdlib_${ci}$larfy( uplo, lm, v( vpos ), 1,conjg( tau( taupos ) ),a( dpos, st )&
                             , lda-1, work)
               endif
               if( ttype==2 ) then
                   j1 = ed+1
                   j2 = min( ed+nb, n )
                   ln = ed-st+1
                   lm = j2-j1+1
                   if( lm>0) then
                       call stdlib_${ci}$larfx( 'RIGHT', lm, ln, v( vpos ),tau( taupos ), a( dpos+nb, &
                                 st ),lda-1, work)
                       if( wantz ) then
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       else
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       endif
                       v( vpos ) = cone
                       do i = 1, lm-1
                           v( vpos+i )        = a( dpos+nb+i, st )
                           a( dpos+nb+i, st ) = czero
                       end do
                       call stdlib_${ci}$larfg( lm, a( dpos+nb, st ), v( vpos+1 ), 1,tau( taupos ) )
                                 
                       call stdlib_${ci}$larfx( 'LEFT', lm, ln-1, v( vpos ),conjg( tau( taupos ) ),a( &
                                 dpos+nb-1, st+1 ), lda-1, work)
                   endif
               endif
           endif
           return
     end subroutine stdlib_${ci}$hb2st_kernels

#:endif
#:endfor













     pure subroutine stdlib_ssterf( n, d, e, info )
     !! SSTERF computes all eigenvalues of a symmetric tridiagonal matrix
     !! using the Pal-Walker-Kahan variant of the QL or QR algorithm.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(sp), intent(inout) :: d(*), e(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 30
           
           
           ! Local Scalars 
           integer(ilp) :: i, iscale, jtot, l, l1, lend, lendsv, lsv, m, nmaxit
           real(sp) :: alpha, anorm, bb, c, eps, eps2, gamma, oldc, oldgam, p, r, rt1, rt2, rte, &
                     s, safmax, safmin, sigma, ssfmax, ssfmin
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           ! quick return if possible
           if( n<0 ) then
              info = -1
              call stdlib_xerbla( 'SSTERF', -info )
              return
           end if
           if( n<=1 )return
           ! determine the unit roundoff for this environment.
           eps = stdlib_slamch( 'E' )
           eps2 = eps**2
           safmin = stdlib_slamch( 'S' )
           safmax = one / safmin
           ssfmax = sqrt( safmax ) / three
           ssfmin = sqrt( safmin ) / eps2
           ! compute the eigenvalues of the tridiagonal matrix.
           nmaxit = n*maxit
           sigma = zero
           jtot = 0
           ! determine where the matrix splits and choose ql or qr iteration
           ! for each block, according to whether top or bottom diagonal
           ! element is smaller.
           l1 = 1
           10 continue
           if( l1>n )go to 170
           if( l1>1 )e( l1-1 ) = zero
           do m = l1, n - 1
              if( abs( e( m ) )<=( sqrt( abs( d( m ) ) )*sqrt( abs( d( m+1 ) ) ) )*eps ) &
                        then
                 e( m ) = zero
                 go to 30
              end if
           end do
           m = n
           30 continue
           l = l1
           lsv = l
           lend = m
           lendsv = lend
           l1 = m + 1
           if( lend==l )go to 10
           ! scale submatrix in rows and columns l to lend
           anorm = stdlib_slanst( 'M', lend-l+1, d( l ), e( l ) )
           iscale = 0
           if( anorm==zero )go to 10
           if( anorm>ssfmax ) then
              iscale = 1
              call stdlib_slascl( 'G', 0, 0, anorm, ssfmax, lend-l+1, 1, d( l ), n,info )
              call stdlib_slascl( 'G', 0, 0, anorm, ssfmax, lend-l, 1, e( l ), n,info )
           else if( anorm<ssfmin ) then
              iscale = 2
              call stdlib_slascl( 'G', 0, 0, anorm, ssfmin, lend-l+1, 1, d( l ), n,info )
              call stdlib_slascl( 'G', 0, 0, anorm, ssfmin, lend-l, 1, e( l ), n,info )
           end if
           do i = l, lend - 1
              e( i ) = e( i )**2
           end do
           ! choose between ql and qr iteration
           if( abs( d( lend ) )<abs( d( l ) ) ) then
              lend = lsv
              l = lendsv
           end if
           if( lend>=l ) then
              ! ql iteration
              ! look for small subdiagonal element.
              50 continue
              if( l/=lend ) then
                 do m = l, lend - 1
                    if( abs( e( m ) )<=eps2*abs( d( m )*d( m+1 ) ) )go to 70
                 end do
              end if
              m = lend
              70 continue
              if( m<lend )e( m ) = zero
              p = d( l )
              if( m==l )go to 90
              ! if remaining matrix is 2 by 2, use stdlib_slae2 to compute its
              ! eigenvalues.
              if( m==l+1 ) then
                 rte = sqrt( e( l ) )
                 call stdlib_slae2( d( l ), rte, d( l+1 ), rt1, rt2 )
                 d( l ) = rt1
                 d( l+1 ) = rt2
                 e( l ) = zero
                 l = l + 2
                 if( l<=lend )go to 50
                 go to 150
              end if
              if( jtot==nmaxit )go to 150
              jtot = jtot + 1
              ! form shift.
              rte = sqrt( e( l ) )
              sigma = ( d( l+1 )-p ) / ( two*rte )
              r = stdlib_slapy2( sigma, one )
              sigma = p - ( rte / ( sigma+sign( r, sigma ) ) )
              c = one
              s = zero
              gamma = d( m ) - sigma
              p = gamma*gamma
              ! inner loop
              do i = m - 1, l, -1
                 bb = e( i )
                 r = p + bb
                 if( i/=m-1 )e( i+1 ) = s*r
                 oldc = c
                 c = p / r
                 s = bb / r
                 oldgam = gamma
                 alpha = d( i )
                 gamma = c*( alpha-sigma ) - s*oldgam
                 d( i+1 ) = oldgam + ( alpha-gamma )
                 if( c/=zero ) then
                    p = ( gamma*gamma ) / c
                 else
                    p = oldc*bb
                 end if
              end do
              e( l ) = s*p
              d( l ) = sigma + gamma
              go to 50
              ! eigenvalue found.
              90 continue
              d( l ) = p
              l = l + 1
              if( l<=lend )go to 50
              go to 150
           else
              ! qr iteration
              ! look for small superdiagonal element.
              100 continue
              do m = l, lend + 1, -1
                 if( abs( e( m-1 ) )<=eps2*abs( d( m )*d( m-1 ) ) )go to 120
              end do
              m = lend
              120 continue
              if( m>lend )e( m-1 ) = zero
              p = d( l )
              if( m==l )go to 140
              ! if remaining matrix is 2 by 2, use stdlib_slae2 to compute its
              ! eigenvalues.
              if( m==l-1 ) then
                 rte = sqrt( e( l-1 ) )
                 call stdlib_slae2( d( l ), rte, d( l-1 ), rt1, rt2 )
                 d( l ) = rt1
                 d( l-1 ) = rt2
                 e( l-1 ) = zero
                 l = l - 2
                 if( l>=lend )go to 100
                 go to 150
              end if
              if( jtot==nmaxit )go to 150
              jtot = jtot + 1
              ! form shift.
              rte = sqrt( e( l-1 ) )
              sigma = ( d( l-1 )-p ) / ( two*rte )
              r = stdlib_slapy2( sigma, one )
              sigma = p - ( rte / ( sigma+sign( r, sigma ) ) )
              c = one
              s = zero
              gamma = d( m ) - sigma
              p = gamma*gamma
              ! inner loop
              do i = m, l - 1
                 bb = e( i )
                 r = p + bb
                 if( i/=m )e( i-1 ) = s*r
                 oldc = c
                 c = p / r
                 s = bb / r
                 oldgam = gamma
                 alpha = d( i+1 )
                 gamma = c*( alpha-sigma ) - s*oldgam
                 d( i ) = oldgam + ( alpha-gamma )
                 if( c/=zero ) then
                    p = ( gamma*gamma ) / c
                 else
                    p = oldc*bb
                 end if
              end do
              e( l-1 ) = s*p
              d( l ) = sigma + gamma
              go to 100
              ! eigenvalue found.
              140 continue
              d( l ) = p
              l = l - 1
              if( l>=lend )go to 100
              go to 150
           end if
           ! undo scaling if necessary
           150 continue
           if( iscale==1 )call stdlib_slascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv+1, 1,d( lsv ), &
                     n, info )
           if( iscale==2 )call stdlib_slascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv+1, 1,d( lsv ), &
                     n, info )
           ! check for no convergence to an eigenvalue after a total
           ! of n*maxit iterations.
           if( jtot<nmaxit )go to 10
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           go to 180
           ! sort eigenvalues in increasing order.
           170 continue
           call stdlib_slasrt( 'I', n, d, info )
           180 continue
           return
     end subroutine stdlib_ssterf

     pure subroutine stdlib_dsterf( n, d, e, info )
     !! DSTERF computes all eigenvalues of a symmetric tridiagonal matrix
     !! using the Pal-Walker-Kahan variant of the QL or QR algorithm.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(dp), intent(inout) :: d(*), e(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 30
           
           
           ! Local Scalars 
           integer(ilp) :: i, iscale, jtot, l, l1, lend, lendsv, lsv, m, nmaxit
           real(dp) :: alpha, anorm, bb, c, eps, eps2, gamma, oldc, oldgam, p, r, rt1, rt2, rte, &
                     s, safmax, safmin, sigma, ssfmax, ssfmin, rmax
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           ! quick return if possible
           if( n<0 ) then
              info = -1
              call stdlib_xerbla( 'DSTERF', -info )
              return
           end if
           if( n<=1 )return
           ! determine the unit roundoff for this environment.
           eps = stdlib_dlamch( 'E' )
           eps2 = eps**2
           safmin = stdlib_dlamch( 'S' )
           safmax = one / safmin
           ssfmax = sqrt( safmax ) / three
           ssfmin = sqrt( safmin ) / eps2
           rmax = stdlib_dlamch( 'O' )
           ! compute the eigenvalues of the tridiagonal matrix.
           nmaxit = n*maxit
           sigma = zero
           jtot = 0
           ! determine where the matrix splits and choose ql or qr iteration
           ! for each block, according to whether top or bottom diagonal
           ! element is smaller.
           l1 = 1
           10 continue
           if( l1>n )go to 170
           if( l1>1 )e( l1-1 ) = zero
           do m = l1, n - 1
              if( abs( e( m ) )<=( sqrt( abs( d( m ) ) )*sqrt( abs( d( m+1 ) ) ) )*eps ) &
                        then
                 e( m ) = zero
                 go to 30
              end if
           end do
           m = n
           30 continue
           l = l1
           lsv = l
           lend = m
           lendsv = lend
           l1 = m + 1
           if( lend==l )go to 10
           ! scale submatrix in rows and columns l to lend
           anorm = stdlib_dlanst( 'M', lend-l+1, d( l ), e( l ) )
           iscale = 0
           if( anorm==zero )go to 10
           if( (anorm>ssfmax) ) then
              iscale = 1
              call stdlib_dlascl( 'G', 0, 0, anorm, ssfmax, lend-l+1, 1, d( l ), n,info )
              call stdlib_dlascl( 'G', 0, 0, anorm, ssfmax, lend-l, 1, e( l ), n,info )
           else if( anorm<ssfmin ) then
              iscale = 2
              call stdlib_dlascl( 'G', 0, 0, anorm, ssfmin, lend-l+1, 1, d( l ), n,info )
              call stdlib_dlascl( 'G', 0, 0, anorm, ssfmin, lend-l, 1, e( l ), n,info )
           end if
           do i = l, lend - 1
              e( i ) = e( i )**2
           end do
           ! choose between ql and qr iteration
           if( abs( d( lend ) )<abs( d( l ) ) ) then
              lend = lsv
              l = lendsv
           end if
           if( lend>=l ) then
              ! ql iteration
              ! look for small subdiagonal element.
              50 continue
              if( l/=lend ) then
                 do m = l, lend - 1
                    if( abs( e( m ) )<=eps2*abs( d( m )*d( m+1 ) ) )go to 70
                 end do
              end if
              m = lend
              70 continue
              if( m<lend )e( m ) = zero
              p = d( l )
              if( m==l )go to 90
              ! if remaining matrix is 2 by 2, use stdlib_dlae2 to compute its
              ! eigenvalues.
              if( m==l+1 ) then
                 rte = sqrt( e( l ) )
                 call stdlib_dlae2( d( l ), rte, d( l+1 ), rt1, rt2 )
                 d( l ) = rt1
                 d( l+1 ) = rt2
                 e( l ) = zero
                 l = l + 2
                 if( l<=lend )go to 50
                 go to 150
              end if
              if( jtot==nmaxit )go to 150
              jtot = jtot + 1
              ! form shift.
              rte = sqrt( e( l ) )
              sigma = ( d( l+1 )-p ) / ( two*rte )
              r = stdlib_dlapy2( sigma, one )
              sigma = p - ( rte / ( sigma+sign( r, sigma ) ) )
              c = one
              s = zero
              gamma = d( m ) - sigma
              p = gamma*gamma
              ! inner loop
              do i = m - 1, l, -1
                 bb = e( i )
                 r = p + bb
                 if( i/=m-1 )e( i+1 ) = s*r
                 oldc = c
                 c = p / r
                 s = bb / r
                 oldgam = gamma
                 alpha = d( i )
                 gamma = c*( alpha-sigma ) - s*oldgam
                 d( i+1 ) = oldgam + ( alpha-gamma )
                 if( c/=zero ) then
                    p = ( gamma*gamma ) / c
                 else
                    p = oldc*bb
                 end if
              end do
              e( l ) = s*p
              d( l ) = sigma + gamma
              go to 50
              ! eigenvalue found.
              90 continue
              d( l ) = p
              l = l + 1
              if( l<=lend )go to 50
              go to 150
           else
              ! qr iteration
              ! look for small superdiagonal element.
              100 continue
              do m = l, lend + 1, -1
                 if( abs( e( m-1 ) )<=eps2*abs( d( m )*d( m-1 ) ) )go to 120
              end do
              m = lend
              120 continue
              if( m>lend )e( m-1 ) = zero
              p = d( l )
              if( m==l )go to 140
              ! if remaining matrix is 2 by 2, use stdlib_dlae2 to compute its
              ! eigenvalues.
              if( m==l-1 ) then
                 rte = sqrt( e( l-1 ) )
                 call stdlib_dlae2( d( l ), rte, d( l-1 ), rt1, rt2 )
                 d( l ) = rt1
                 d( l-1 ) = rt2
                 e( l-1 ) = zero
                 l = l - 2
                 if( l>=lend )go to 100
                 go to 150
              end if
              if( jtot==nmaxit )go to 150
              jtot = jtot + 1
              ! form shift.
              rte = sqrt( e( l-1 ) )
              sigma = ( d( l-1 )-p ) / ( two*rte )
              r = stdlib_dlapy2( sigma, one )
              sigma = p - ( rte / ( sigma+sign( r, sigma ) ) )
              c = one
              s = zero
              gamma = d( m ) - sigma
              p = gamma*gamma
              ! inner loop
              do i = m, l - 1
                 bb = e( i )
                 r = p + bb
                 if( i/=m )e( i-1 ) = s*r
                 oldc = c
                 c = p / r
                 s = bb / r
                 oldgam = gamma
                 alpha = d( i+1 )
                 gamma = c*( alpha-sigma ) - s*oldgam
                 d( i ) = oldgam + ( alpha-gamma )
                 if( c/=zero ) then
                    p = ( gamma*gamma ) / c
                 else
                    p = oldc*bb
                 end if
              end do
              e( l-1 ) = s*p
              d( l ) = sigma + gamma
              go to 100
              ! eigenvalue found.
              140 continue
              d( l ) = p
              l = l - 1
              if( l>=lend )go to 100
              go to 150
           end if
           ! undo scaling if necessary
           150 continue
           if( iscale==1 )call stdlib_dlascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv+1, 1,d( lsv ), &
                     n, info )
           if( iscale==2 )call stdlib_dlascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv+1, 1,d( lsv ), &
                     n, info )
           ! check for no convergence to an eigenvalue after a total
           ! of n*maxit iterations.
           if( jtot<nmaxit )go to 10
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           go to 180
           ! sort eigenvalues in increasing order.
           170 continue
           call stdlib_dlasrt( 'I', n, d, info )
           180 continue
           return
     end subroutine stdlib_dsterf

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$sterf( n, d, e, info )
     !! DSTERF: computes all eigenvalues of a symmetric tridiagonal matrix
     !! using the Pal-Walker-Kahan variant of the QL or QR algorithm.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: d(*), e(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 30
           
           
           ! Local Scalars 
           integer(ilp) :: i, iscale, jtot, l, l1, lend, lendsv, lsv, m, nmaxit
           real(${rk}$) :: alpha, anorm, bb, c, eps, eps2, gamma, oldc, oldgam, p, r, rt1, rt2, rte, &
                     s, safmax, safmin, sigma, ssfmax, ssfmin, rmax
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           ! quick return if possible
           if( n<0 ) then
              info = -1
              call stdlib_xerbla( 'DSTERF', -info )
              return
           end if
           if( n<=1 )return
           ! determine the unit roundoff for this environment.
           eps = stdlib_${ri}$lamch( 'E' )
           eps2 = eps**2
           safmin = stdlib_${ri}$lamch( 'S' )
           safmax = one / safmin
           ssfmax = sqrt( safmax ) / three
           ssfmin = sqrt( safmin ) / eps2
           rmax = stdlib_${ri}$lamch( 'O' )
           ! compute the eigenvalues of the tridiagonal matrix.
           nmaxit = n*maxit
           sigma = zero
           jtot = 0
           ! determine where the matrix splits and choose ql or qr iteration
           ! for each block, according to whether top or bottom diagonal
           ! element is smaller.
           l1 = 1
           10 continue
           if( l1>n )go to 170
           if( l1>1 )e( l1-1 ) = zero
           do m = l1, n - 1
              if( abs( e( m ) )<=( sqrt( abs( d( m ) ) )*sqrt( abs( d( m+1 ) ) ) )*eps ) &
                        then
                 e( m ) = zero
                 go to 30
              end if
           end do
           m = n
           30 continue
           l = l1
           lsv = l
           lend = m
           lendsv = lend
           l1 = m + 1
           if( lend==l )go to 10
           ! scale submatrix in rows and columns l to lend
           anorm = stdlib_${ri}$lanst( 'M', lend-l+1, d( l ), e( l ) )
           iscale = 0
           if( anorm==zero )go to 10
           if( (anorm>ssfmax) ) then
              iscale = 1
              call stdlib_${ri}$lascl( 'G', 0, 0, anorm, ssfmax, lend-l+1, 1, d( l ), n,info )
              call stdlib_${ri}$lascl( 'G', 0, 0, anorm, ssfmax, lend-l, 1, e( l ), n,info )
           else if( anorm<ssfmin ) then
              iscale = 2
              call stdlib_${ri}$lascl( 'G', 0, 0, anorm, ssfmin, lend-l+1, 1, d( l ), n,info )
              call stdlib_${ri}$lascl( 'G', 0, 0, anorm, ssfmin, lend-l, 1, e( l ), n,info )
           end if
           do i = l, lend - 1
              e( i ) = e( i )**2
           end do
           ! choose between ql and qr iteration
           if( abs( d( lend ) )<abs( d( l ) ) ) then
              lend = lsv
              l = lendsv
           end if
           if( lend>=l ) then
              ! ql iteration
              ! look for small subdiagonal element.
              50 continue
              if( l/=lend ) then
                 do m = l, lend - 1
                    if( abs( e( m ) )<=eps2*abs( d( m )*d( m+1 ) ) )go to 70
                 end do
              end if
              m = lend
              70 continue
              if( m<lend )e( m ) = zero
              p = d( l )
              if( m==l )go to 90
              ! if remaining matrix is 2 by 2, use stdlib_${ri}$lae2 to compute its
              ! eigenvalues.
              if( m==l+1 ) then
                 rte = sqrt( e( l ) )
                 call stdlib_${ri}$lae2( d( l ), rte, d( l+1 ), rt1, rt2 )
                 d( l ) = rt1
                 d( l+1 ) = rt2
                 e( l ) = zero
                 l = l + 2
                 if( l<=lend )go to 50
                 go to 150
              end if
              if( jtot==nmaxit )go to 150
              jtot = jtot + 1
              ! form shift.
              rte = sqrt( e( l ) )
              sigma = ( d( l+1 )-p ) / ( two*rte )
              r = stdlib_${ri}$lapy2( sigma, one )
              sigma = p - ( rte / ( sigma+sign( r, sigma ) ) )
              c = one
              s = zero
              gamma = d( m ) - sigma
              p = gamma*gamma
              ! inner loop
              do i = m - 1, l, -1
                 bb = e( i )
                 r = p + bb
                 if( i/=m-1 )e( i+1 ) = s*r
                 oldc = c
                 c = p / r
                 s = bb / r
                 oldgam = gamma
                 alpha = d( i )
                 gamma = c*( alpha-sigma ) - s*oldgam
                 d( i+1 ) = oldgam + ( alpha-gamma )
                 if( c/=zero ) then
                    p = ( gamma*gamma ) / c
                 else
                    p = oldc*bb
                 end if
              end do
              e( l ) = s*p
              d( l ) = sigma + gamma
              go to 50
              ! eigenvalue found.
              90 continue
              d( l ) = p
              l = l + 1
              if( l<=lend )go to 50
              go to 150
           else
              ! qr iteration
              ! look for small superdiagonal element.
              100 continue
              do m = l, lend + 1, -1
                 if( abs( e( m-1 ) )<=eps2*abs( d( m )*d( m-1 ) ) )go to 120
              end do
              m = lend
              120 continue
              if( m>lend )e( m-1 ) = zero
              p = d( l )
              if( m==l )go to 140
              ! if remaining matrix is 2 by 2, use stdlib_${ri}$lae2 to compute its
              ! eigenvalues.
              if( m==l-1 ) then
                 rte = sqrt( e( l-1 ) )
                 call stdlib_${ri}$lae2( d( l ), rte, d( l-1 ), rt1, rt2 )
                 d( l ) = rt1
                 d( l-1 ) = rt2
                 e( l-1 ) = zero
                 l = l - 2
                 if( l>=lend )go to 100
                 go to 150
              end if
              if( jtot==nmaxit )go to 150
              jtot = jtot + 1
              ! form shift.
              rte = sqrt( e( l-1 ) )
              sigma = ( d( l-1 )-p ) / ( two*rte )
              r = stdlib_${ri}$lapy2( sigma, one )
              sigma = p - ( rte / ( sigma+sign( r, sigma ) ) )
              c = one
              s = zero
              gamma = d( m ) - sigma
              p = gamma*gamma
              ! inner loop
              do i = m, l - 1
                 bb = e( i )
                 r = p + bb
                 if( i/=m )e( i-1 ) = s*r
                 oldc = c
                 c = p / r
                 s = bb / r
                 oldgam = gamma
                 alpha = d( i+1 )
                 gamma = c*( alpha-sigma ) - s*oldgam
                 d( i ) = oldgam + ( alpha-gamma )
                 if( c/=zero ) then
                    p = ( gamma*gamma ) / c
                 else
                    p = oldc*bb
                 end if
              end do
              e( l-1 ) = s*p
              d( l ) = sigma + gamma
              go to 100
              ! eigenvalue found.
              140 continue
              d( l ) = p
              l = l - 1
              if( l>=lend )go to 100
              go to 150
           end if
           ! undo scaling if necessary
           150 continue
           if( iscale==1 )call stdlib_${ri}$lascl( 'G', 0, 0, ssfmax, anorm, lendsv-lsv+1, 1,d( lsv ), &
                     n, info )
           if( iscale==2 )call stdlib_${ri}$lascl( 'G', 0, 0, ssfmin, anorm, lendsv-lsv+1, 1,d( lsv ), &
                     n, info )
           ! check for no convergence to an eigenvalue after a total
           ! of n*maxit iterations.
           if( jtot<nmaxit )go to 10
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           go to 180
           ! sort eigenvalues in increasing order.
           170 continue
           call stdlib_${ri}$lasrt( 'I', n, d, info )
           180 continue
           return
     end subroutine stdlib_${ri}$sterf

#:endif
#:endfor





     pure subroutine stdlib_claesy( a, b, c, rt1, rt2, evscal, cs1, sn1 )
     !! CLAESY computes the eigendecomposition of a 2-by-2 symmetric matrix
     !! ( ( A, B );( B, C ) )
     !! provided the norm of the matrix of eigenvectors is larger than
     !! some threshold value.
     !! RT1 is the eigenvalue of larger absolute value, and RT2 of
     !! smaller absolute value.  If the eigenvectors are computed, then
     !! on return ( CS1, SN1 ) is the unit eigenvector for RT1, hence
     !! [  CS1     SN1   ] . [ A  B ] . [ CS1    -SN1   ] = [ RT1  0  ]
     !! [ -SN1     CS1   ]   [ B  C ]   [ SN1     CS1   ]   [  0  RT2 ]
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           complex(sp), intent(in) :: a, b, c
           complex(sp), intent(out) :: cs1, evscal, rt1, rt2, sn1
       ! =====================================================================
           ! Parameters 
           real(sp), parameter :: thresh = 0.1_sp
           
           
           
           
           
           ! Local Scalars 
           real(sp) :: babs, evnorm, tabs, z
           complex(sp) :: s, t, tmp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! special case:  the matrix is actually diagonal.
           ! to avoid divide by zero later, we treat this case separately.
           if( abs( b )==zero ) then
              rt1 = a
              rt2 = c
              if( abs( rt1 )<abs( rt2 ) ) then
                 tmp = rt1
                 rt1 = rt2
                 rt2 = tmp
                 cs1 = zero
                 sn1 = one
              else
                 cs1 = one
                 sn1 = zero
              end if
           else
              ! compute the eigenvalues and eigenvectors.
              ! the characteristic equation is
                 ! lambda **2 - (a+c) lambda + (a*c - b*b)
              ! and we solve it using the quadratic formula.
              s = ( a+c )*half
              t = ( a-c )*half
              ! take the square root carefully to avoid over/under flow.
              babs = abs( b )
              tabs = abs( t )
              z = max( babs, tabs )
              if( z>zero )t = z*sqrt( ( t / z )**2+( b / z )**2 )
              ! compute the two eigenvalues.  rt1 and rt2 are exchanged
              ! if necessary so that rt1 will have the greater magnitude.
              rt1 = s + t
              rt2 = s - t
              if( abs( rt1 )<abs( rt2 ) ) then
                 tmp = rt1
                 rt1 = rt2
                 rt2 = tmp
              end if
              ! choose cs1 = 1 and sn1 to satisfy the first equation, then
              ! scale the components of this eigenvector so that the matrix
              ! of eigenvectors x satisfies  x * x**t = i .  (no scaling is
              ! done if the norm of the eigenvalue matrix is less than thresh.)
              sn1 = ( rt1-a ) / b
              tabs = abs( sn1 )
              if( tabs>one ) then
                 t = tabs*sqrt( ( one / tabs )**2+( sn1 / tabs )**2 )
              else
                 t = sqrt( cone+sn1*sn1 )
              end if
              evnorm = abs( t )
              if( evnorm>=thresh ) then
                 evscal = cone / t
                 cs1 = evscal
                 sn1 = sn1*evscal
              else
                 evscal = zero
              end if
           end if
           return
     end subroutine stdlib_claesy

     pure subroutine stdlib_zlaesy( a, b, c, rt1, rt2, evscal, cs1, sn1 )
     !! ZLAESY computes the eigendecomposition of a 2-by-2 symmetric matrix
     !! ( ( A, B );( B, C ) )
     !! provided the norm of the matrix of eigenvectors is larger than
     !! some threshold value.
     !! RT1 is the eigenvalue of larger absolute value, and RT2 of
     !! smaller absolute value.  If the eigenvectors are computed, then
     !! on return ( CS1, SN1 ) is the unit eigenvector for RT1, hence
     !! [  CS1     SN1   ] . [ A  B ] . [ CS1    -SN1   ] = [ RT1  0  ]
     !! [ -SN1     CS1   ]   [ B  C ]   [ SN1     CS1   ]   [  0  RT2 ]
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           complex(dp), intent(in) :: a, b, c
           complex(dp), intent(out) :: cs1, evscal, rt1, rt2, sn1
       ! =====================================================================
           ! Parameters 
           real(dp), parameter :: thresh = 0.1_dp
           
           
           
           
           
           ! Local Scalars 
           real(dp) :: babs, evnorm, tabs, z
           complex(dp) :: s, t, tmp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! special case:  the matrix is actually diagonal.
           ! to avoid divide by zero later, we treat this case separately.
           if( abs( b )==zero ) then
              rt1 = a
              rt2 = c
              if( abs( rt1 )<abs( rt2 ) ) then
                 tmp = rt1
                 rt1 = rt2
                 rt2 = tmp
                 cs1 = zero
                 sn1 = one
              else
                 cs1 = one
                 sn1 = zero
              end if
           else
              ! compute the eigenvalues and eigenvectors.
              ! the characteristic equation is
                 ! lambda **2 - (a+c) lambda + (a*c - b*b)
              ! and we solve it using the quadratic formula.
              s = ( a+c )*half
              t = ( a-c )*half
              ! take the square root carefully to avoid over/under flow.
              babs = abs( b )
              tabs = abs( t )
              z = max( babs, tabs )
              if( z>zero )t = z*sqrt( ( t / z )**2+( b / z )**2 )
              ! compute the two eigenvalues.  rt1 and rt2 are exchanged
              ! if necessary so that rt1 will have the greater magnitude.
              rt1 = s + t
              rt2 = s - t
              if( abs( rt1 )<abs( rt2 ) ) then
                 tmp = rt1
                 rt1 = rt2
                 rt2 = tmp
              end if
              ! choose cs1 = 1 and sn1 to satisfy the first equation, then
              ! scale the components of this eigenvector so that the matrix
              ! of eigenvectors x satisfies  x * x**t = i .  (no scaling is
              ! done if the norm of the eigenvalue matrix is less than thresh.)
              sn1 = ( rt1-a ) / b
              tabs = abs( sn1 )
              if( tabs>one ) then
                 t = tabs*sqrt( ( one / tabs )**2+( sn1 / tabs )**2 )
              else
                 t = sqrt( cone+sn1*sn1 )
              end if
              evnorm = abs( t )
              if( evnorm>=thresh ) then
                 evscal = cone / t
                 cs1 = evscal
                 sn1 = sn1*evscal
              else
                 evscal = zero
              end if
           end if
           return
     end subroutine stdlib_zlaesy

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$laesy( a, b, c, rt1, rt2, evscal, cs1, sn1 )
     !! ZLAESY: computes the eigendecomposition of a 2-by-2 symmetric matrix
     !! ( ( A, B );( B, C ) )
     !! provided the norm of the matrix of eigenvectors is larger than
     !! some threshold value.
     !! RT1 is the eigenvalue of larger absolute value, and RT2 of
     !! smaller absolute value.  If the eigenvectors are computed, then
     !! on return ( CS1, SN1 ) is the unit eigenvector for RT1, hence
     !! [  CS1     SN1   ] . [ A  B ] . [ CS1    -SN1   ] = [ RT1  0  ]
     !! [ -SN1     CS1   ]   [ B  C ]   [ SN1     CS1   ]   [  0  RT2 ]
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           complex(${ck}$), intent(in) :: a, b, c
           complex(${ck}$), intent(out) :: cs1, evscal, rt1, rt2, sn1
       ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: thresh = 0.1_${ck}$
           
           
           
           
           
           ! Local Scalars 
           real(${ck}$) :: babs, evnorm, tabs, z
           complex(${ck}$) :: s, t, tmp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! special case:  the matrix is actually diagonal.
           ! to avoid divide by zero later, we treat this case separately.
           if( abs( b )==zero ) then
              rt1 = a
              rt2 = c
              if( abs( rt1 )<abs( rt2 ) ) then
                 tmp = rt1
                 rt1 = rt2
                 rt2 = tmp
                 cs1 = zero
                 sn1 = one
              else
                 cs1 = one
                 sn1 = zero
              end if
           else
              ! compute the eigenvalues and eigenvectors.
              ! the characteristic equation is
                 ! lambda **2 - (a+c) lambda + (a*c - b*b)
              ! and we solve it using the quadratic formula.
              s = ( a+c )*half
              t = ( a-c )*half
              ! take the square root carefully to avoid over/under flow.
              babs = abs( b )
              tabs = abs( t )
              z = max( babs, tabs )
              if( z>zero )t = z*sqrt( ( t / z )**2+( b / z )**2 )
              ! compute the two eigenvalues.  rt1 and rt2 are exchanged
              ! if necessary so that rt1 will have the greater magnitude.
              rt1 = s + t
              rt2 = s - t
              if( abs( rt1 )<abs( rt2 ) ) then
                 tmp = rt1
                 rt1 = rt2
                 rt2 = tmp
              end if
              ! choose cs1 = 1 and sn1 to satisfy the first equation, then
              ! scale the components of this eigenvector so that the matrix
              ! of eigenvectors x satisfies  x * x**t = i .  (no scaling is
              ! done if the norm of the eigenvalue matrix is less than thresh.)
              sn1 = ( rt1-a ) / b
              tabs = abs( sn1 )
              if( tabs>one ) then
                 t = tabs*sqrt( ( one / tabs )**2+( sn1 / tabs )**2 )
              else
                 t = sqrt( cone+sn1*sn1 )
              end if
              evnorm = abs( t )
              if( evnorm>=thresh ) then
                 evscal = cone / t
                 cs1 = evscal
                 sn1 = sn1*evscal
              else
                 evscal = zero
              end if
           end if
           return
     end subroutine stdlib_${ci}$laesy

#:endif
#:endfor



     pure subroutine stdlib_slarre( range, n, vl, vu, il, iu, d, e, e2,rtol1, rtol2, spltol, &
     !! To find the desired eigenvalues of a given real symmetric
     !! tridiagonal matrix T, SLARRE: sets any "small" off-diagonal
     !! elements to zero, and for each unreduced block T_i, it finds
     !! (a) a suitable shift at one end of the block's spectrum,
     !! (b) the base representation, T_i - sigma_i I = L_i D_i L_i^T, and
     !! (c) eigenvalues of each L_i D_i L_i^T.
     !! The representations and eigenvalues found are then used by
     !! SSTEMR to compute the eigenvectors of T.
     !! The accuracy varies depending on whether bisection is used to
     !! find a few eigenvalues or the dqds algorithm (subroutine SLASQ2) to
     !! conpute all and then discard any unwanted one.
     !! As an added benefit, SLARRE also outputs the n
     !! Gerschgorin intervals for the matrices L_i D_i L_i^T.
               nsplit, isplit, m,w, werr, wgap, iblock, indexw, gers, pivmin,work, iwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: range
           integer(ilp), intent(in) :: il, iu, n
           integer(ilp), intent(out) :: info, m, nsplit
           real(sp), intent(out) :: pivmin
           real(sp), intent(in) :: rtol1, rtol2, spltol
           real(sp), intent(inout) :: vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: iblock(*), isplit(*), iwork(*), indexw(*)
           real(sp), intent(inout) :: d(*), e(*), e2(*)
           real(sp), intent(out) :: gers(*), w(*), werr(*), wgap(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: hndrd = 100.0_sp
           real(sp), parameter :: pert = 4.0_sp
           real(sp), parameter :: fourth = one/four
           real(sp), parameter :: fac = half
           real(sp), parameter :: maxgrowth = 64.0_sp
           real(sp), parameter :: fudge = 2.0_sp
           integer(ilp), parameter :: maxtry = 6
           integer(ilp), parameter :: allrng = 1
           integer(ilp), parameter :: indrng = 2
           integer(ilp), parameter :: valrng = 3
           
           
           ! Local Scalars 
           logical(lk) :: forceb, norep, usedqd
           integer(ilp) :: cnt, cnt1, cnt2, i, ibegin, idum, iend, iinfo, in, indl, indu, irange, &
                     j, jblk, mb, mm, wbegin, wend
           real(sp) :: avgap, bsrtol, clwdth, dmax, dpivot, eabs, emax, eold, eps, gl, gu, isleft,&
                      isrght, rtl, rtol, s1, s2, safmin, sgndef, sigma, spdiam, tau, tmp, tmp1
           ! Local Arrays 
           integer(ilp) :: iseed(4)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           ! decode range
           if( stdlib_lsame( range, 'A' ) ) then
              irange = allrng
           else if( stdlib_lsame( range, 'V' ) ) then
              irange = valrng
           else if( stdlib_lsame( range, 'I' ) ) then
              irange = indrng
           end if
           m = 0
           ! get machine constants
           safmin = stdlib_slamch( 'S' )
           eps = stdlib_slamch( 'P' )
           ! set parameters
           rtl = hndrd*eps
           ! if one were ever to ask for less initial precision in bsrtol,
           ! one should keep in mind that for the subset case, the extremal
           ! eigenvalues must be at least as accurate as the current setting
           ! (eigenvalues in the middle need not as much accuracy)
           bsrtol = sqrt(eps)*(0.5e-3_sp)
           ! treat case of 1x1 matrix for quick return
           if( n==1 ) then
              if( (irange==allrng).or.((irange==valrng).and.(d(1)>vl).and.(d(1)<=vu)).or.((&
                        irange==indrng).and.(il==1).and.(iu==1)) ) then
                 m = 1
                 w(1) = d(1)
                 ! the computation error of the eigenvalue is zero
                 werr(1) = zero
                 wgap(1) = zero
                 iblock( 1 ) = 1
                 indexw( 1 ) = 1
                 gers(1) = d( 1 )
                 gers(2) = d( 1 )
              endif
              ! store the shift for the initial rrr, which is zero in this case
              e(1) = zero
              return
           end if
           ! general case: tridiagonal matrix of order > 1
           ! init werr, wgap. compute gerschgorin intervals and spectral diameter.
           ! compute maximum off-diagonal entry and pivmin.
           gl = d(1)
           gu = d(1)
           eold = zero
           emax = zero
           e(n) = zero
           do i = 1,n
              werr(i) = zero
              wgap(i) = zero
              eabs = abs( e(i) )
              if( eabs >= emax ) then
                 emax = eabs
              end if
              tmp1 = eabs + eold
              gers( 2*i-1) = d(i) - tmp1
              gl =  min( gl, gers( 2*i - 1))
              gers( 2*i ) = d(i) + tmp1
              gu = max( gu, gers(2*i) )
              eold  = eabs
           end do
           ! the minimum pivot allowed in the sturm sequence for t
           pivmin = safmin * max( one, emax**2 )
           ! compute spectral diameter. the gerschgorin bounds give an
           ! estimate that is wrong by at most a factor of sqrt(2)
           spdiam = gu - gl
           ! compute splitting points
           call stdlib_slarra( n, d, e, e2, spltol, spdiam,nsplit, isplit, iinfo )
           ! can force use of bisection instead of faster dqds.
           ! option left in the code for future multisection work.
           forceb = .false.
           ! initialize usedqd, dqds should be used for allrng unless someone
           ! explicitly wants bisection.
           usedqd = (( irange==allrng ) .and. (.not.forceb))
           if( (irange==allrng) .and. (.not. forceb) ) then
              ! set interval [vl,vu] that contains all eigenvalues
              vl = gl
              vu = gu
           else
              ! we call stdlib_slarrd to find crude approximations to the eigenvalues
              ! in the desired range. in case irange = indrng, we also obtain the
              ! interval (vl,vu] that contains all the wanted eigenvalues.
              ! an interval [left,right] has converged if
              ! right-left<rtol*max(abs(left),abs(right))
              ! stdlib_slarrd needs a work of size 4*n, iwork of size 3*n
              call stdlib_slarrd( range, 'B', n, vl, vu, il, iu, gers,bsrtol, d, e, e2, pivmin, &
                        nsplit, isplit,mm, w, werr, vl, vu, iblock, indexw,work, iwork, iinfo )
              if( iinfo/=0 ) then
                 info = -1
                 return
              endif
              ! make sure that the entries m+1 to n in w, werr, iblock, indexw are 0
              do i = mm+1,n
                 w( i ) = zero
                 werr( i ) = zero
                 iblock( i ) = 0
                 indexw( i ) = 0
              end do
           end if
      ! **
           ! loop over unreduced blocks
           ibegin = 1
           wbegin = 1
           loop_170: do jblk = 1, nsplit
              iend = isplit( jblk )
              in = iend - ibegin + 1
              ! 1 x 1 block
              if( in==1 ) then
                 if( (irange==allrng).or.( (irange==valrng).and.( d( ibegin )>vl ).and.( d( &
                           ibegin )<=vu ) ).or. ( (irange==indrng).and.(iblock(wbegin)==jblk))) then
                    m = m + 1
                    w( m ) = d( ibegin )
                    werr(m) = zero
                    ! the gap for a single block doesn't matter for the later
                    ! algorithm and is assigned an arbitrary large value
                    wgap(m) = zero
                    iblock( m ) = jblk
                    indexw( m ) = 1
                    wbegin = wbegin + 1
                 endif
                 ! e( iend ) holds the shift for the initial rrr
                 e( iend ) = zero
                 ibegin = iend + 1
                 cycle loop_170
              end if
              ! blocks of size larger than 1x1
              ! e( iend ) will hold the shift for the initial rrr, for now set it =0
              e( iend ) = zero
              ! find local outer bounds gl,gu for the block
              gl = d(ibegin)
              gu = d(ibegin)
              do i = ibegin , iend
                 gl = min( gers( 2*i-1 ), gl )
                 gu = max( gers( 2*i ), gu )
              end do
              spdiam = gu - gl
              if(.not. ((irange==allrng).and.(.not.forceb)) ) then
                 ! count the number of eigenvalues in the current block.
                 mb = 0
                 do i = wbegin,mm
                    if( iblock(i)==jblk ) then
                       mb = mb+1
                    else
                       goto 21
                    endif
                 end do
                 21 continue
                 if( mb==0) then
                    ! no eigenvalue in the current block lies in the desired range
                    ! e( iend ) holds the shift for the initial rrr
                    e( iend ) = zero
                    ibegin = iend + 1
                    cycle loop_170
                 else
                    ! decide whether dqds or bisection is more efficient
                    usedqd = ( (mb > fac*in) .and. (.not.forceb) )
                    wend = wbegin + mb - 1
                    ! calculate gaps for the current block
                    ! in later stages, when representations for individual
                    ! eigenvalues are different, we use sigma = e( iend ).
                    sigma = zero
                    do i = wbegin, wend - 1
                       wgap( i ) = max( zero,w(i+1)-werr(i+1) - (w(i)+werr(i)) )
                    end do
                    wgap( wend ) = max( zero,vu - sigma - (w( wend )+werr( wend )))
                    ! find local index of the first and last desired evalue.
                    indl = indexw(wbegin)
                    indu = indexw( wend )
                 endif
              endif
              if(( (irange==allrng) .and. (.not. forceb) ).or.usedqd) then
                 ! case of dqds
                 ! find approximations to the extremal eigenvalues of the block
                 call stdlib_slarrk( in, 1, gl, gu, d(ibegin),e2(ibegin), pivmin, rtl, tmp, tmp1, &
                           iinfo )
                 if( iinfo/=0 ) then
                    info = -1
                    return
                 endif
                 isleft = max(gl, tmp - tmp1- hndrd * eps* abs(tmp - tmp1))
                 call stdlib_slarrk( in, in, gl, gu, d(ibegin),e2(ibegin), pivmin, rtl, tmp, tmp1,&
                            iinfo )
                 if( iinfo/=0 ) then
                    info = -1
                    return
                 endif
                 isrght = min(gu, tmp + tmp1+ hndrd * eps * abs(tmp + tmp1))
                 ! improve the estimate of the spectral diameter
                 spdiam = isrght - isleft
              else
                 ! case of bisection
                 ! find approximations to the wanted extremal eigenvalues
                 isleft = max(gl, w(wbegin) - werr(wbegin)- hndrd * eps*abs(w(wbegin)- werr(&
                           wbegin) ))
                 isrght = min(gu,w(wend) + werr(wend)+ hndrd * eps * abs(w(wend)+ werr(wend)))
                           
              endif
              ! decide whether the base representation for the current block
              ! l_jblk d_jblk l_jblk^t = t_jblk - sigma_jblk i
              ! should be on the left or the right end of the current block.
              ! the strategy is to shift to the end which is "more populated"
              ! furthermore, decide whether to use dqds for the computation of
              ! dqds is chosen if all eigenvalues are desired or the number of
              ! eigenvalues to be computed is large compared to the blocksize.
              if( ( irange==allrng ) .and. (.not.forceb) ) then
                 ! if all the eigenvalues have to be computed, we use dqd
                 usedqd = .true.
                 ! indl is the local index of the first eigenvalue to compute
                 indl = 1
                 indu = in
                 ! mb =  number of eigenvalues to compute
                 mb = in
                 wend = wbegin + mb - 1
                 ! define 1/4 and 3/4 points of the spectrum
                 s1 = isleft + fourth * spdiam
                 s2 = isrght - fourth * spdiam
              else
                 ! stdlib_slarrd has computed iblock and indexw for each eigenvalue
                 ! approximation.
                 ! choose sigma
                 if( usedqd ) then
                    s1 = isleft + fourth * spdiam
                    s2 = isrght - fourth * spdiam
                 else
                    tmp = min(isrght,vu) -  max(isleft,vl)
                    s1 =  max(isleft,vl) + fourth * tmp
                    s2 =  min(isrght,vu) - fourth * tmp
                 endif
              endif
              ! compute the negcount at the 1/4 and 3/4 points
              if(mb>1) then
                 call stdlib_slarrc( 'T', in, s1, s2, d(ibegin),e(ibegin), pivmin, cnt, cnt1, &
                           cnt2, iinfo)
              endif
              if(mb==1) then
                 sigma = gl
                 sgndef = one
              elseif( cnt1 - indl >= indu - cnt2 ) then
                 if( ( irange==allrng ) .and. (.not.forceb) ) then
                    sigma = max(isleft,gl)
                 elseif( usedqd ) then
                    ! use gerschgorin bound as shift to get pos def matrix
                    ! for dqds
                    sigma = isleft
                 else
                    ! use approximation of the first desired eigenvalue of the
                    ! block as shift
                    sigma = max(isleft,vl)
                 endif
                 sgndef = one
              else
                 if( ( irange==allrng ) .and. (.not.forceb) ) then
                    sigma = min(isrght,gu)
                 elseif( usedqd ) then
                    ! use gerschgorin bound as shift to get neg def matrix
                    ! for dqds
                    sigma = isrght
                 else
                    ! use approximation of the first desired eigenvalue of the
                    ! block as shift
                    sigma = min(isrght,vu)
                 endif
                 sgndef = -one
              endif
              ! an initial sigma has been chosen that will be used for computing
              ! t - sigma i = l d l^t
              ! define the increment tau of the shift in case the initial shift
              ! needs to be refined to obtain a factorization with not too much
              ! element growth.
              if( usedqd ) then
                 ! the initial sigma was to the outer end of the spectrum
                 ! the matrix is definite and we need not retreat.
                 tau = spdiam*eps*n + two*pivmin
                 tau = max( tau,two*eps*abs(sigma) )
              else
                 if(mb>1) then
                    clwdth = w(wend) + werr(wend) - w(wbegin) - werr(wbegin)
                    avgap = abs(clwdth / real(wend-wbegin,KIND=sp))
                    if( sgndef==one ) then
                       tau = half*max(wgap(wbegin),avgap)
                       tau = max(tau,werr(wbegin))
                    else
                       tau = half*max(wgap(wend-1),avgap)
                       tau = max(tau,werr(wend))
                    endif
                 else
                    tau = werr(wbegin)
                 endif
              endif
              loop_80: do idum = 1, maxtry
                 ! compute l d l^t factorization of tridiagonal matrix t - sigma i.
                 ! store d in work(1:in), l in work(in+1:2*in), and reciprocals of
                 ! pivots in work(2*in+1:3*in)
                 dpivot = d( ibegin ) - sigma
                 work( 1 ) = dpivot
                 dmax = abs( work(1) )
                 j = ibegin
                 do i = 1, in - 1
                    work( 2*in+i ) = one / work( i )
                    tmp = e( j )*work( 2*in+i )
                    work( in+i ) = tmp
                    dpivot = ( d( j+1 )-sigma ) - tmp*e( j )
                    work( i+1 ) = dpivot
                    dmax = max( dmax, abs(dpivot) )
                    j = j + 1
                 end do
                 ! check for element growth
                 if( dmax > maxgrowth*spdiam ) then
                    norep = .true.
                 else
                    norep = .false.
                 endif
                 if( usedqd .and. .not.norep ) then
                    ! ensure the definiteness of the representation
                    ! all entries of d (of l d l^t) must have the same sign
                    do i = 1, in
                       tmp = sgndef*work( i )
                       if( tmp<zero ) norep = .true.
                    end do
                 endif
                 if(norep) then
                    ! note that in the case of irange=allrng, we use the gerschgorin
                    ! shift which makes the matrix definite. so we should end up
                    ! here really only in the case of irange = valrng or indrng.
                    if( idum==maxtry-1 ) then
                       if( sgndef==one ) then
                          ! the fudged gerschgorin shift should succeed
                          sigma =gl - fudge*spdiam*eps*n - fudge*two*pivmin
                       else
                          sigma =gu + fudge*spdiam*eps*n + fudge*two*pivmin
                       end if
                    else
                       sigma = sigma - sgndef * tau
                       tau = two * tau
                    end if
                 else
                    ! an initial rrr is found
                    go to 83
                 end if
              end do loop_80
              ! if the program reaches this point, no base representation could be
              ! found in maxtry iterations.
              info = 2
              return
              83 continue
              ! at this point, we have found an initial base representation
              ! t - sigma i = l d l^t with not too much element growth.
              ! store the shift.
              e( iend ) = sigma
              ! store d and l.
              call stdlib_scopy( in, work, 1, d( ibegin ), 1 )
              call stdlib_scopy( in-1, work( in+1 ), 1, e( ibegin ), 1 )
              if(mb>1 ) then
                 ! perturb each entry of the base representation by a small
                 ! (but random) relative amount to overcome difficulties with
                 ! glued matrices.
                 do i = 1, 4
                    iseed( i ) = 1
                 end do
                 call stdlib_slarnv(2, iseed, 2*in-1, work(1))
                 do i = 1,in-1
                    d(ibegin+i-1) = d(ibegin+i-1)*(one+eps*pert*work(i))
                    e(ibegin+i-1) = e(ibegin+i-1)*(one+eps*pert*work(in+i))
                 end do
                 d(iend) = d(iend)*(one+eps*four*work(in))
              endif
              ! don't update the gerschgorin intervals because keeping track
              ! of the updates would be too much work in stdlib_slarrv.
              ! we update w instead and use it to locate the proper gerschgorin
              ! intervals.
              ! compute the required eigenvalues of l d l' by bisection or dqds
              if ( .not.usedqd ) then
                 ! if stdlib_slarrd has been used, shift the eigenvalue approximations
                 ! according to their representation. this is necessary for
                 ! a uniform stdlib_slarrv since dqds computes eigenvalues of the
                 ! shifted representation. in stdlib_slarrv, w will always hold the
                 ! unshifted eigenvalue approximation.
                 do j=wbegin,wend
                    w(j) = w(j) - sigma
                    werr(j) = werr(j) + abs(w(j)) * eps
                 end do
                 ! call stdlib_slarrb to reduce eigenvalue error of the approximations
                 ! from stdlib_slarrd
                 do i = ibegin, iend-1
                    work( i ) = d( i ) * e( i )**2
                 end do
                 ! use bisection to find ev from indl to indu
                 call stdlib_slarrb(in, d(ibegin), work(ibegin),indl, indu, rtol1, rtol2, indl-1,&
                 w(wbegin), wgap(wbegin), werr(wbegin),work( 2*n+1 ), iwork, pivmin, spdiam,in, &
                           iinfo )
                 if( iinfo /= 0 ) then
                    info = -4
                    return
                 end if
                 ! stdlib_slarrb computes all gaps correctly except for the last one
                 ! record distance to vu/gu
                 wgap( wend ) = max( zero,( vu-sigma ) - ( w( wend ) + werr( wend ) ) )
                 do i = indl, indu
                    m = m + 1
                    iblock(m) = jblk
                    indexw(m) = i
                 end do
              else
                 ! call dqds to get all eigs (and then possibly delete unwanted
                 ! eigenvalues).
                 ! note that dqds finds the eigenvalues of the l d l^t representation
                 ! of t to high relative accuracy. high relative accuracy
                 ! might be lost when the shift of the rrr is subtracted to obtain
                 ! the eigenvalues of t. however, t is not guaranteed to define its
                 ! eigenvalues to high relative accuracy anyway.
                 ! set rtol to the order of the tolerance used in stdlib_slasq2
                 ! this is an estimated error, the worst case bound is 4*n*eps
                 ! which is usually too large and requires unnecessary work to be
                 ! done by bisection when computing the eigenvectors
                 rtol = log(real(in,KIND=sp)) * four * eps
                 j = ibegin
                 do i = 1, in - 1
                    work( 2*i-1 ) = abs( d( j ) )
                    work( 2*i ) = e( j )*e( j )*work( 2*i-1 )
                    j = j + 1
                 end do
                 work( 2*in-1 ) = abs( d( iend ) )
                 work( 2*in ) = zero
                 call stdlib_slasq2( in, work, iinfo )
                 if( iinfo /= 0 ) then
                    ! if iinfo = -5 then an index is part of a tight cluster
                    ! and should be changed. the index is in iwork(1) and the
                    ! gap is in work(n+1)
                    info = -5
                    return
                 else
                    ! test that all eigenvalues are positive as expected
                    do i = 1, in
                       if( work( i )<zero ) then
                          info = -6
                          return
                       endif
                    end do
                 end if
                 if( sgndef>zero ) then
                    do i = indl, indu
                       m = m + 1
                       w( m ) = work( in-i+1 )
                       iblock( m ) = jblk
                       indexw( m ) = i
                    end do
                 else
                    do i = indl, indu
                       m = m + 1
                       w( m ) = -work( i )
                       iblock( m ) = jblk
                       indexw( m ) = i
                    end do
                 end if
                 do i = m - mb + 1, m
                    ! the value of rtol below should be the tolerance in stdlib_slasq2
                    werr( i ) = rtol * abs( w(i) )
                 end do
                 do i = m - mb + 1, m - 1
                    ! compute the right gap between the intervals
                    wgap( i ) = max( zero,w(i+1)-werr(i+1) - (w(i)+werr(i)) )
                 end do
                 wgap( m ) = max( zero,( vu-sigma ) - ( w( m ) + werr( m ) ) )
              end if
              ! proceed with next block
              ibegin = iend + 1
              wbegin = wend + 1
           end do loop_170
           return
     end subroutine stdlib_slarre

     pure subroutine stdlib_dlarre( range, n, vl, vu, il, iu, d, e, e2,rtol1, rtol2, spltol, &
     !! To find the desired eigenvalues of a given real symmetric
     !! tridiagonal matrix T, DLARRE: sets any "small" off-diagonal
     !! elements to zero, and for each unreduced block T_i, it finds
     !! (a) a suitable shift at one end of the block's spectrum,
     !! (b) the base representation, T_i - sigma_i I = L_i D_i L_i^T, and
     !! (c) eigenvalues of each L_i D_i L_i^T.
     !! The representations and eigenvalues found are then used by
     !! DSTEMR to compute the eigenvectors of T.
     !! The accuracy varies depending on whether bisection is used to
     !! find a few eigenvalues or the dqds algorithm (subroutine DLASQ2) to
     !! conpute all and then discard any unwanted one.
     !! As an added benefit, DLARRE also outputs the n
     !! Gerschgorin intervals for the matrices L_i D_i L_i^T.
               nsplit, isplit, m,w, werr, wgap, iblock, indexw, gers, pivmin,work, iwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: range
           integer(ilp), intent(in) :: il, iu, n
           integer(ilp), intent(out) :: info, m, nsplit
           real(dp), intent(out) :: pivmin
           real(dp), intent(in) :: rtol1, rtol2, spltol
           real(dp), intent(inout) :: vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: iblock(*), isplit(*), iwork(*), indexw(*)
           real(dp), intent(inout) :: d(*), e(*), e2(*)
           real(dp), intent(out) :: gers(*), w(*), werr(*), wgap(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: hndrd = 100.0_dp
           real(dp), parameter :: pert = 8.0_dp
           real(dp), parameter :: fourth = one/four
           real(dp), parameter :: fac = half
           real(dp), parameter :: maxgrowth = 64.0_dp
           real(dp), parameter :: fudge = 2.0_dp
           integer(ilp), parameter :: maxtry = 6
           integer(ilp), parameter :: allrng = 1
           integer(ilp), parameter :: indrng = 2
           integer(ilp), parameter :: valrng = 3
           
           
           ! Local Scalars 
           logical(lk) :: forceb, norep, usedqd
           integer(ilp) :: cnt, cnt1, cnt2, i, ibegin, idum, iend, iinfo, in, indl, indu, irange, &
                     j, jblk, mb, mm, wbegin, wend
           real(dp) :: avgap, bsrtol, clwdth, dmax, dpivot, eabs, emax, eold, eps, gl, gu, isleft,&
                      isrght, rtl, rtol, s1, s2, safmin, sgndef, sigma, spdiam, tau, tmp, tmp1
           ! Local Arrays 
           integer(ilp) :: iseed(4)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           ! decode range
           if( stdlib_lsame( range, 'A' ) ) then
              irange = allrng
           else if( stdlib_lsame( range, 'V' ) ) then
              irange = valrng
           else if( stdlib_lsame( range, 'I' ) ) then
              irange = indrng
           end if
           m = 0
           ! get machine constants
           safmin = stdlib_dlamch( 'S' )
           eps = stdlib_dlamch( 'P' )
           ! set parameters
           rtl = sqrt(eps)
           bsrtol = sqrt(eps)
           ! treat case of 1x1 matrix for quick return
           if( n==1 ) then
              if( (irange==allrng).or.((irange==valrng).and.(d(1)>vl).and.(d(1)<=vu)).or.((&
                        irange==indrng).and.(il==1).and.(iu==1)) ) then
                 m = 1
                 w(1) = d(1)
                 ! the computation error of the eigenvalue is zero
                 werr(1) = zero
                 wgap(1) = zero
                 iblock( 1 ) = 1
                 indexw( 1 ) = 1
                 gers(1) = d( 1 )
                 gers(2) = d( 1 )
              endif
              ! store the shift for the initial rrr, which is zero in this case
              e(1) = zero
              return
           end if
           ! general case: tridiagonal matrix of order > 1
           ! init werr, wgap. compute gerschgorin intervals and spectral diameter.
           ! compute maximum off-diagonal entry and pivmin.
           gl = d(1)
           gu = d(1)
           eold = zero
           emax = zero
           e(n) = zero
           do i = 1,n
              werr(i) = zero
              wgap(i) = zero
              eabs = abs( e(i) )
              if( eabs >= emax ) then
                 emax = eabs
              end if
              tmp1 = eabs + eold
              gers( 2*i-1) = d(i) - tmp1
              gl =  min( gl, gers( 2*i - 1))
              gers( 2*i ) = d(i) + tmp1
              gu = max( gu, gers(2*i) )
              eold  = eabs
           end do
           ! the minimum pivot allowed in the sturm sequence for t
           pivmin = safmin * max( one, emax**2 )
           ! compute spectral diameter. the gerschgorin bounds give an
           ! estimate that is wrong by at most a factor of sqrt(2)
           spdiam = gu - gl
           ! compute splitting points
           call stdlib_dlarra( n, d, e, e2, spltol, spdiam,nsplit, isplit, iinfo )
           ! can force use of bisection instead of faster dqds.
           ! option left in the code for future multisection work.
           forceb = .false.
           ! initialize usedqd, dqds should be used for allrng unless someone
           ! explicitly wants bisection.
           usedqd = (( irange==allrng ) .and. (.not.forceb))
           if( (irange==allrng) .and. (.not. forceb) ) then
              ! set interval [vl,vu] that contains all eigenvalues
              vl = gl
              vu = gu
           else
              ! we call stdlib_dlarrd to find crude approximations to the eigenvalues
              ! in the desired range. in case irange = indrng, we also obtain the
              ! interval (vl,vu] that contains all the wanted eigenvalues.
              ! an interval [left,right] has converged if
              ! right-left<rtol*max(abs(left),abs(right))
              ! stdlib_dlarrd needs a work of size 4*n, iwork of size 3*n
              call stdlib_dlarrd( range, 'B', n, vl, vu, il, iu, gers,bsrtol, d, e, e2, pivmin, &
                        nsplit, isplit,mm, w, werr, vl, vu, iblock, indexw,work, iwork, iinfo )
              if( iinfo/=0 ) then
                 info = -1
                 return
              endif
              ! make sure that the entries m+1 to n in w, werr, iblock, indexw are 0
              do i = mm+1,n
                 w( i ) = zero
                 werr( i ) = zero
                 iblock( i ) = 0
                 indexw( i ) = 0
              end do
           end if
      ! **
           ! loop over unreduced blocks
           ibegin = 1
           wbegin = 1
           loop_170: do jblk = 1, nsplit
              iend = isplit( jblk )
              in = iend - ibegin + 1
              ! 1 x 1 block
              if( in==1 ) then
                 if( (irange==allrng).or.( (irange==valrng).and.( d( ibegin )>vl ).and.( d( &
                           ibegin )<=vu ) ).or. ( (irange==indrng).and.(iblock(wbegin)==jblk))) then
                    m = m + 1
                    w( m ) = d( ibegin )
                    werr(m) = zero
                    ! the gap for a single block doesn't matter for the later
                    ! algorithm and is assigned an arbitrary large value
                    wgap(m) = zero
                    iblock( m ) = jblk
                    indexw( m ) = 1
                    wbegin = wbegin + 1
                 endif
                 ! e( iend ) holds the shift for the initial rrr
                 e( iend ) = zero
                 ibegin = iend + 1
                 cycle loop_170
              end if
              ! blocks of size larger than 1x1
              ! e( iend ) will hold the shift for the initial rrr, for now set it =0
              e( iend ) = zero
              ! find local outer bounds gl,gu for the block
              gl = d(ibegin)
              gu = d(ibegin)
              do i = ibegin , iend
                 gl = min( gers( 2*i-1 ), gl )
                 gu = max( gers( 2*i ), gu )
              end do
              spdiam = gu - gl
              if(.not. ((irange==allrng).and.(.not.forceb)) ) then
                 ! count the number of eigenvalues in the current block.
                 mb = 0
                 do i = wbegin,mm
                    if( iblock(i)==jblk ) then
                       mb = mb+1
                    else
                       goto 21
                    endif
                 end do
                 21 continue
                 if( mb==0) then
                    ! no eigenvalue in the current block lies in the desired range
                    ! e( iend ) holds the shift for the initial rrr
                    e( iend ) = zero
                    ibegin = iend + 1
                    cycle loop_170
                 else
                    ! decide whether dqds or bisection is more efficient
                    usedqd = ( (mb > fac*in) .and. (.not.forceb) )
                    wend = wbegin + mb - 1
                    ! calculate gaps for the current block
                    ! in later stages, when representations for individual
                    ! eigenvalues are different, we use sigma = e( iend ).
                    sigma = zero
                    do i = wbegin, wend - 1
                       wgap( i ) = max( zero,w(i+1)-werr(i+1) - (w(i)+werr(i)) )
                    end do
                    wgap( wend ) = max( zero,vu - sigma - (w( wend )+werr( wend )))
                    ! find local index of the first and last desired evalue.
                    indl = indexw(wbegin)
                    indu = indexw( wend )
                 endif
              endif
              if(( (irange==allrng) .and. (.not. forceb) ).or.usedqd) then
                 ! case of dqds
                 ! find approximations to the extremal eigenvalues of the block
                 call stdlib_dlarrk( in, 1, gl, gu, d(ibegin),e2(ibegin), pivmin, rtl, tmp, tmp1, &
                           iinfo )
                 if( iinfo/=0 ) then
                    info = -1
                    return
                 endif
                 isleft = max(gl, tmp - tmp1- hndrd * eps* abs(tmp - tmp1))
                 call stdlib_dlarrk( in, in, gl, gu, d(ibegin),e2(ibegin), pivmin, rtl, tmp, tmp1,&
                            iinfo )
                 if( iinfo/=0 ) then
                    info = -1
                    return
                 endif
                 isrght = min(gu, tmp + tmp1+ hndrd * eps * abs(tmp + tmp1))
                 ! improve the estimate of the spectral diameter
                 spdiam = isrght - isleft
              else
                 ! case of bisection
                 ! find approximations to the wanted extremal eigenvalues
                 isleft = max(gl, w(wbegin) - werr(wbegin)- hndrd * eps*abs(w(wbegin)- werr(&
                           wbegin) ))
                 isrght = min(gu,w(wend) + werr(wend)+ hndrd * eps * abs(w(wend)+ werr(wend)))
                           
              endif
              ! decide whether the base representation for the current block
              ! l_jblk d_jblk l_jblk^t = t_jblk - sigma_jblk i
              ! should be on the left or the right end of the current block.
              ! the strategy is to shift to the end which is "more populated"
              ! furthermore, decide whether to use dqds for the computation of
              ! dqds is chosen if all eigenvalues are desired or the number of
              ! eigenvalues to be computed is large compared to the blocksize.
              if( ( irange==allrng ) .and. (.not.forceb) ) then
                 ! if all the eigenvalues have to be computed, we use dqd
                 usedqd = .true.
                 ! indl is the local index of the first eigenvalue to compute
                 indl = 1
                 indu = in
                 ! mb =  number of eigenvalues to compute
                 mb = in
                 wend = wbegin + mb - 1
                 ! define 1/4 and 3/4 points of the spectrum
                 s1 = isleft + fourth * spdiam
                 s2 = isrght - fourth * spdiam
              else
                 ! stdlib_dlarrd has computed iblock and indexw for each eigenvalue
                 ! approximation.
                 ! choose sigma
                 if( usedqd ) then
                    s1 = isleft + fourth * spdiam
                    s2 = isrght - fourth * spdiam
                 else
                    tmp = min(isrght,vu) -  max(isleft,vl)
                    s1 =  max(isleft,vl) + fourth * tmp
                    s2 =  min(isrght,vu) - fourth * tmp
                 endif
              endif
              ! compute the negcount at the 1/4 and 3/4 points
              if(mb>1) then
                 call stdlib_dlarrc( 'T', in, s1, s2, d(ibegin),e(ibegin), pivmin, cnt, cnt1, &
                           cnt2, iinfo)
              endif
              if(mb==1) then
                 sigma = gl
                 sgndef = one
              elseif( cnt1 - indl >= indu - cnt2 ) then
                 if( ( irange==allrng ) .and. (.not.forceb) ) then
                    sigma = max(isleft,gl)
                 elseif( usedqd ) then
                    ! use gerschgorin bound as shift to get pos def matrix
                    ! for dqds
                    sigma = isleft
                 else
                    ! use approximation of the first desired eigenvalue of the
                    ! block as shift
                    sigma = max(isleft,vl)
                 endif
                 sgndef = one
              else
                 if( ( irange==allrng ) .and. (.not.forceb) ) then
                    sigma = min(isrght,gu)
                 elseif( usedqd ) then
                    ! use gerschgorin bound as shift to get neg def matrix
                    ! for dqds
                    sigma = isrght
                 else
                    ! use approximation of the first desired eigenvalue of the
                    ! block as shift
                    sigma = min(isrght,vu)
                 endif
                 sgndef = -one
              endif
              ! an initial sigma has been chosen that will be used for computing
              ! t - sigma i = l d l^t
              ! define the increment tau of the shift in case the initial shift
              ! needs to be refined to obtain a factorization with not too much
              ! element growth.
              if( usedqd ) then
                 ! the initial sigma was to the outer end of the spectrum
                 ! the matrix is definite and we need not retreat.
                 tau = spdiam*eps*n + two*pivmin
                 tau = max( tau,two*eps*abs(sigma) )
              else
                 if(mb>1) then
                    clwdth = w(wend) + werr(wend) - w(wbegin) - werr(wbegin)
                    avgap = abs(clwdth / real(wend-wbegin,KIND=dp))
                    if( sgndef==one ) then
                       tau = half*max(wgap(wbegin),avgap)
                       tau = max(tau,werr(wbegin))
                    else
                       tau = half*max(wgap(wend-1),avgap)
                       tau = max(tau,werr(wend))
                    endif
                 else
                    tau = werr(wbegin)
                 endif
              endif
              loop_80: do idum = 1, maxtry
                 ! compute l d l^t factorization of tridiagonal matrix t - sigma i.
                 ! store d in work(1:in), l in work(in+1:2*in), and reciprocals of
                 ! pivots in work(2*in+1:3*in)
                 dpivot = d( ibegin ) - sigma
                 work( 1 ) = dpivot
                 dmax = abs( work(1) )
                 j = ibegin
                 do i = 1, in - 1
                    work( 2*in+i ) = one / work( i )
                    tmp = e( j )*work( 2*in+i )
                    work( in+i ) = tmp
                    dpivot = ( d( j+1 )-sigma ) - tmp*e( j )
                    work( i+1 ) = dpivot
                    dmax = max( dmax, abs(dpivot) )
                    j = j + 1
                 end do
                 ! check for element growth
                 if( dmax > maxgrowth*spdiam ) then
                    norep = .true.
                 else
                    norep = .false.
                 endif
                 if( usedqd .and. .not.norep ) then
                    ! ensure the definiteness of the representation
                    ! all entries of d (of l d l^t) must have the same sign
                    do i = 1, in
                       tmp = sgndef*work( i )
                       if( tmp<zero ) norep = .true.
                    end do
                 endif
                 if(norep) then
                    ! note that in the case of irange=allrng, we use the gerschgorin
                    ! shift which makes the matrix definite. so we should end up
                    ! here really only in the case of irange = valrng or indrng.
                    if( idum==maxtry-1 ) then
                       if( sgndef==one ) then
                          ! the fudged gerschgorin shift should succeed
                          sigma =gl - fudge*spdiam*eps*n - fudge*two*pivmin
                       else
                          sigma =gu + fudge*spdiam*eps*n + fudge*two*pivmin
                       end if
                    else
                       sigma = sigma - sgndef * tau
                       tau = two * tau
                    end if
                 else
                    ! an initial rrr is found
                    go to 83
                 end if
              end do loop_80
              ! if the program reaches this point, no base representation could be
              ! found in maxtry iterations.
              info = 2
              return
              83 continue
              ! at this point, we have found an initial base representation
              ! t - sigma i = l d l^t with not too much element growth.
              ! store the shift.
              e( iend ) = sigma
              ! store d and l.
              call stdlib_dcopy( in, work, 1, d( ibegin ), 1 )
              call stdlib_dcopy( in-1, work( in+1 ), 1, e( ibegin ), 1 )
              if(mb>1 ) then
                 ! perturb each entry of the base representation by a small
                 ! (but random) relative amount to overcome difficulties with
                 ! glued matrices.
                 do i = 1, 4
                    iseed( i ) = 1
                 end do
                 call stdlib_dlarnv(2, iseed, 2*in-1, work(1))
                 do i = 1,in-1
                    d(ibegin+i-1) = d(ibegin+i-1)*(one+eps*pert*work(i))
                    e(ibegin+i-1) = e(ibegin+i-1)*(one+eps*pert*work(in+i))
                 end do
                 d(iend) = d(iend)*(one+eps*four*work(in))
              endif
              ! don't update the gerschgorin intervals because keeping track
              ! of the updates would be too much work in stdlib_dlarrv.
              ! we update w instead and use it to locate the proper gerschgorin
              ! intervals.
              ! compute the required eigenvalues of l d l' by bisection or dqds
              if ( .not.usedqd ) then
                 ! if stdlib_dlarrd has been used, shift the eigenvalue approximations
                 ! according to their representation. this is necessary for
                 ! a uniform stdlib_dlarrv since dqds computes eigenvalues of the
                 ! shifted representation. in stdlib_dlarrv, w will always hold the
                 ! unshifted eigenvalue approximation.
                 do j=wbegin,wend
                    w(j) = w(j) - sigma
                    werr(j) = werr(j) + abs(w(j)) * eps
                 end do
                 ! call stdlib_dlarrb to reduce eigenvalue error of the approximations
                 ! from stdlib_dlarrd
                 do i = ibegin, iend-1
                    work( i ) = d( i ) * e( i )**2
                 end do
                 ! use bisection to find ev from indl to indu
                 call stdlib_dlarrb(in, d(ibegin), work(ibegin),indl, indu, rtol1, rtol2, indl-1,&
                 w(wbegin), wgap(wbegin), werr(wbegin),work( 2*n+1 ), iwork, pivmin, spdiam,in, &
                           iinfo )
                 if( iinfo /= 0 ) then
                    info = -4
                    return
                 end if
                 ! stdlib_dlarrb computes all gaps correctly except for the last one
                 ! record distance to vu/gu
                 wgap( wend ) = max( zero,( vu-sigma ) - ( w( wend ) + werr( wend ) ) )
                 do i = indl, indu
                    m = m + 1
                    iblock(m) = jblk
                    indexw(m) = i
                 end do
              else
                 ! call dqds to get all eigs (and then possibly delete unwanted
                 ! eigenvalues).
                 ! note that dqds finds the eigenvalues of the l d l^t representation
                 ! of t to high relative accuracy. high relative accuracy
                 ! might be lost when the shift of the rrr is subtracted to obtain
                 ! the eigenvalues of t. however, t is not guaranteed to define its
                 ! eigenvalues to high relative accuracy anyway.
                 ! set rtol to the order of the tolerance used in stdlib_dlasq2
                 ! this is an estimated error, the worst case bound is 4*n*eps
                 ! which is usually too large and requires unnecessary work to be
                 ! done by bisection when computing the eigenvectors
                 rtol = log(real(in,KIND=dp)) * four * eps
                 j = ibegin
                 do i = 1, in - 1
                    work( 2*i-1 ) = abs( d( j ) )
                    work( 2*i ) = e( j )*e( j )*work( 2*i-1 )
                    j = j + 1
                 end do
                 work( 2*in-1 ) = abs( d( iend ) )
                 work( 2*in ) = zero
                 call stdlib_dlasq2( in, work, iinfo )
                 if( iinfo /= 0 ) then
                    ! if iinfo = -5 then an index is part of a tight cluster
                    ! and should be changed. the index is in iwork(1) and the
                    ! gap is in work(n+1)
                    info = -5
                    return
                 else
                    ! test that all eigenvalues are positive as expected
                    do i = 1, in
                       if( work( i )<zero ) then
                          info = -6
                          return
                       endif
                    end do
                 end if
                 if( sgndef>zero ) then
                    do i = indl, indu
                       m = m + 1
                       w( m ) = work( in-i+1 )
                       iblock( m ) = jblk
                       indexw( m ) = i
                    end do
                 else
                    do i = indl, indu
                       m = m + 1
                       w( m ) = -work( i )
                       iblock( m ) = jblk
                       indexw( m ) = i
                    end do
                 end if
                 do i = m - mb + 1, m
                    ! the value of rtol below should be the tolerance in stdlib_dlasq2
                    werr( i ) = rtol * abs( w(i) )
                 end do
                 do i = m - mb + 1, m - 1
                    ! compute the right gap between the intervals
                    wgap( i ) = max( zero,w(i+1)-werr(i+1) - (w(i)+werr(i)) )
                 end do
                 wgap( m ) = max( zero,( vu-sigma ) - ( w( m ) + werr( m ) ) )
              end if
              ! proceed with next block
              ibegin = iend + 1
              wbegin = wend + 1
           end do loop_170
           return
     end subroutine stdlib_dlarre

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$larre( range, n, vl, vu, il, iu, d, e, e2,rtol1, rtol2, spltol, &
     !! To find the desired eigenvalues of a given real symmetric
     !! tridiagonal matrix T, DLARRE: sets any "small" off-diagonal
     !! elements to zero, and for each unreduced block T_i, it finds
     !! (a) a suitable shift at one end of the block's spectrum,
     !! (b) the base representation, T_i - sigma_i I = L_i D_i L_i^T, and
     !! (c) eigenvalues of each L_i D_i L_i^T.
     !! The representations and eigenvalues found are then used by
     !! DSTEMR to compute the eigenvectors of T.
     !! The accuracy varies depending on whether bisection is used to
     !! find a few eigenvalues or the dqds algorithm (subroutine DLASQ2) to
     !! conpute all and then discard any unwanted one.
     !! As an added benefit, DLARRE also outputs the n
     !! Gerschgorin intervals for the matrices L_i D_i L_i^T.
               nsplit, isplit, m,w, werr, wgap, iblock, indexw, gers, pivmin,work, iwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: range
           integer(ilp), intent(in) :: il, iu, n
           integer(ilp), intent(out) :: info, m, nsplit
           real(${rk}$), intent(out) :: pivmin
           real(${rk}$), intent(in) :: rtol1, rtol2, spltol
           real(${rk}$), intent(inout) :: vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: iblock(*), isplit(*), iwork(*), indexw(*)
           real(${rk}$), intent(inout) :: d(*), e(*), e2(*)
           real(${rk}$), intent(out) :: gers(*), w(*), werr(*), wgap(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: hndrd = 100.0_${rk}$
           real(${rk}$), parameter :: pert = 8.0_${rk}$
           real(${rk}$), parameter :: fourth = one/four
           real(${rk}$), parameter :: fac = half
           real(${rk}$), parameter :: maxgrowth = 64.0_${rk}$
           real(${rk}$), parameter :: fudge = 2.0_${rk}$
           integer(ilp), parameter :: maxtry = 6
           integer(ilp), parameter :: allrng = 1
           integer(ilp), parameter :: indrng = 2
           integer(ilp), parameter :: valrng = 3
           
           
           ! Local Scalars 
           logical(lk) :: forceb, norep, usedqd
           integer(ilp) :: cnt, cnt1, cnt2, i, ibegin, idum, iend, iinfo, in, indl, indu, irange, &
                     j, jblk, mb, mm, wbegin, wend
           real(${rk}$) :: avgap, bsrtol, clwdth, dmax, dpivot, eabs, emax, eold, eps, gl, gu, isleft,&
                      isrght, rtl, rtol, s1, s2, safmin, sgndef, sigma, spdiam, tau, tmp, tmp1
           ! Local Arrays 
           integer(ilp) :: iseed(4)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           ! decode range
           if( stdlib_lsame( range, 'A' ) ) then
              irange = allrng
           else if( stdlib_lsame( range, 'V' ) ) then
              irange = valrng
           else if( stdlib_lsame( range, 'I' ) ) then
              irange = indrng
           end if
           m = 0
           ! get machine constants
           safmin = stdlib_${ri}$lamch( 'S' )
           eps = stdlib_${ri}$lamch( 'P' )
           ! set parameters
           rtl = sqrt(eps)
           bsrtol = sqrt(eps)
           ! treat case of 1x1 matrix for quick return
           if( n==1 ) then
              if( (irange==allrng).or.((irange==valrng).and.(d(1)>vl).and.(d(1)<=vu)).or.((&
                        irange==indrng).and.(il==1).and.(iu==1)) ) then
                 m = 1
                 w(1) = d(1)
                 ! the computation error of the eigenvalue is zero
                 werr(1) = zero
                 wgap(1) = zero
                 iblock( 1 ) = 1
                 indexw( 1 ) = 1
                 gers(1) = d( 1 )
                 gers(2) = d( 1 )
              endif
              ! store the shift for the initial rrr, which is zero in this case
              e(1) = zero
              return
           end if
           ! general case: tridiagonal matrix of order > 1
           ! init werr, wgap. compute gerschgorin intervals and spectral diameter.
           ! compute maximum off-diagonal entry and pivmin.
           gl = d(1)
           gu = d(1)
           eold = zero
           emax = zero
           e(n) = zero
           do i = 1,n
              werr(i) = zero
              wgap(i) = zero
              eabs = abs( e(i) )
              if( eabs >= emax ) then
                 emax = eabs
              end if
              tmp1 = eabs + eold
              gers( 2*i-1) = d(i) - tmp1
              gl =  min( gl, gers( 2*i - 1))
              gers( 2*i ) = d(i) + tmp1
              gu = max( gu, gers(2*i) )
              eold  = eabs
           end do
           ! the minimum pivot allowed in the sturm sequence for t
           pivmin = safmin * max( one, emax**2 )
           ! compute spectral diameter. the gerschgorin bounds give an
           ! estimate that is wrong by at most a factor of sqrt(2)
           spdiam = gu - gl
           ! compute splitting points
           call stdlib_${ri}$larra( n, d, e, e2, spltol, spdiam,nsplit, isplit, iinfo )
           ! can force use of bisection instead of faster dqds.
           ! option left in the code for future multisection work.
           forceb = .false.
           ! initialize usedqd, dqds should be used for allrng unless someone
           ! explicitly wants bisection.
           usedqd = (( irange==allrng ) .and. (.not.forceb))
           if( (irange==allrng) .and. (.not. forceb) ) then
              ! set interval [vl,vu] that contains all eigenvalues
              vl = gl
              vu = gu
           else
              ! we call stdlib_${ri}$larrd to find crude approximations to the eigenvalues
              ! in the desired range. in case irange = indrng, we also obtain the
              ! interval (vl,vu] that contains all the wanted eigenvalues.
              ! an interval [left,right] has converged if
              ! right-left<rtol*max(abs(left),abs(right))
              ! stdlib_${ri}$larrd needs a work of size 4*n, iwork of size 3*n
              call stdlib_${ri}$larrd( range, 'B', n, vl, vu, il, iu, gers,bsrtol, d, e, e2, pivmin, &
                        nsplit, isplit,mm, w, werr, vl, vu, iblock, indexw,work, iwork, iinfo )
              if( iinfo/=0 ) then
                 info = -1
                 return
              endif
              ! make sure that the entries m+1 to n in w, werr, iblock, indexw are 0
              do i = mm+1,n
                 w( i ) = zero
                 werr( i ) = zero
                 iblock( i ) = 0
                 indexw( i ) = 0
              end do
           end if
      ! **
           ! loop over unreduced blocks
           ibegin = 1
           wbegin = 1
           loop_170: do jblk = 1, nsplit
              iend = isplit( jblk )
              in = iend - ibegin + 1
              ! 1 x 1 block
              if( in==1 ) then
                 if( (irange==allrng).or.( (irange==valrng).and.( d( ibegin )>vl ).and.( d( &
                           ibegin )<=vu ) ).or. ( (irange==indrng).and.(iblock(wbegin)==jblk))) then
                    m = m + 1
                    w( m ) = d( ibegin )
                    werr(m) = zero
                    ! the gap for a single block doesn't matter for the later
                    ! algorithm and is assigned an arbitrary large value
                    wgap(m) = zero
                    iblock( m ) = jblk
                    indexw( m ) = 1
                    wbegin = wbegin + 1
                 endif
                 ! e( iend ) holds the shift for the initial rrr
                 e( iend ) = zero
                 ibegin = iend + 1
                 cycle loop_170
              end if
              ! blocks of size larger than 1x1
              ! e( iend ) will hold the shift for the initial rrr, for now set it =0
              e( iend ) = zero
              ! find local outer bounds gl,gu for the block
              gl = d(ibegin)
              gu = d(ibegin)
              do i = ibegin , iend
                 gl = min( gers( 2*i-1 ), gl )
                 gu = max( gers( 2*i ), gu )
              end do
              spdiam = gu - gl
              if(.not. ((irange==allrng).and.(.not.forceb)) ) then
                 ! count the number of eigenvalues in the current block.
                 mb = 0
                 do i = wbegin,mm
                    if( iblock(i)==jblk ) then
                       mb = mb+1
                    else
                       goto 21
                    endif
                 end do
                 21 continue
                 if( mb==0) then
                    ! no eigenvalue in the current block lies in the desired range
                    ! e( iend ) holds the shift for the initial rrr
                    e( iend ) = zero
                    ibegin = iend + 1
                    cycle loop_170
                 else
                    ! decide whether dqds or bisection is more efficient
                    usedqd = ( (mb > fac*in) .and. (.not.forceb) )
                    wend = wbegin + mb - 1
                    ! calculate gaps for the current block
                    ! in later stages, when representations for individual
                    ! eigenvalues are different, we use sigma = e( iend ).
                    sigma = zero
                    do i = wbegin, wend - 1
                       wgap( i ) = max( zero,w(i+1)-werr(i+1) - (w(i)+werr(i)) )
                    end do
                    wgap( wend ) = max( zero,vu - sigma - (w( wend )+werr( wend )))
                    ! find local index of the first and last desired evalue.
                    indl = indexw(wbegin)
                    indu = indexw( wend )
                 endif
              endif
              if(( (irange==allrng) .and. (.not. forceb) ).or.usedqd) then
                 ! case of dqds
                 ! find approximations to the extremal eigenvalues of the block
                 call stdlib_${ri}$larrk( in, 1, gl, gu, d(ibegin),e2(ibegin), pivmin, rtl, tmp, tmp1, &
                           iinfo )
                 if( iinfo/=0 ) then
                    info = -1
                    return
                 endif
                 isleft = max(gl, tmp - tmp1- hndrd * eps* abs(tmp - tmp1))
                 call stdlib_${ri}$larrk( in, in, gl, gu, d(ibegin),e2(ibegin), pivmin, rtl, tmp, tmp1,&
                            iinfo )
                 if( iinfo/=0 ) then
                    info = -1
                    return
                 endif
                 isrght = min(gu, tmp + tmp1+ hndrd * eps * abs(tmp + tmp1))
                 ! improve the estimate of the spectral diameter
                 spdiam = isrght - isleft
              else
                 ! case of bisection
                 ! find approximations to the wanted extremal eigenvalues
                 isleft = max(gl, w(wbegin) - werr(wbegin)- hndrd * eps*abs(w(wbegin)- werr(&
                           wbegin) ))
                 isrght = min(gu,w(wend) + werr(wend)+ hndrd * eps * abs(w(wend)+ werr(wend)))
                           
              endif
              ! decide whether the base representation for the current block
              ! l_jblk d_jblk l_jblk^t = t_jblk - sigma_jblk i
              ! should be on the left or the right end of the current block.
              ! the strategy is to shift to the end which is "more populated"
              ! furthermore, decide whether to use dqds for the computation of
              ! dqds is chosen if all eigenvalues are desired or the number of
              ! eigenvalues to be computed is large compared to the blocksize.
              if( ( irange==allrng ) .and. (.not.forceb) ) then
                 ! if all the eigenvalues have to be computed, we use dqd
                 usedqd = .true.
                 ! indl is the local index of the first eigenvalue to compute
                 indl = 1
                 indu = in
                 ! mb =  number of eigenvalues to compute
                 mb = in
                 wend = wbegin + mb - 1
                 ! define 1/4 and 3/4 points of the spectrum
                 s1 = isleft + fourth * spdiam
                 s2 = isrght - fourth * spdiam
              else
                 ! stdlib_${ri}$larrd has computed iblock and indexw for each eigenvalue
                 ! approximation.
                 ! choose sigma
                 if( usedqd ) then
                    s1 = isleft + fourth * spdiam
                    s2 = isrght - fourth * spdiam
                 else
                    tmp = min(isrght,vu) -  max(isleft,vl)
                    s1 =  max(isleft,vl) + fourth * tmp
                    s2 =  min(isrght,vu) - fourth * tmp
                 endif
              endif
              ! compute the negcount at the 1/4 and 3/4 points
              if(mb>1) then
                 call stdlib_${ri}$larrc( 'T', in, s1, s2, d(ibegin),e(ibegin), pivmin, cnt, cnt1, &
                           cnt2, iinfo)
              endif
              if(mb==1) then
                 sigma = gl
                 sgndef = one
              elseif( cnt1 - indl >= indu - cnt2 ) then
                 if( ( irange==allrng ) .and. (.not.forceb) ) then
                    sigma = max(isleft,gl)
                 elseif( usedqd ) then
                    ! use gerschgorin bound as shift to get pos def matrix
                    ! for dqds
                    sigma = isleft
                 else
                    ! use approximation of the first desired eigenvalue of the
                    ! block as shift
                    sigma = max(isleft,vl)
                 endif
                 sgndef = one
              else
                 if( ( irange==allrng ) .and. (.not.forceb) ) then
                    sigma = min(isrght,gu)
                 elseif( usedqd ) then
                    ! use gerschgorin bound as shift to get neg def matrix
                    ! for dqds
                    sigma = isrght
                 else
                    ! use approximation of the first desired eigenvalue of the
                    ! block as shift
                    sigma = min(isrght,vu)
                 endif
                 sgndef = -one
              endif
              ! an initial sigma has been chosen that will be used for computing
              ! t - sigma i = l d l^t
              ! define the increment tau of the shift in case the initial shift
              ! needs to be refined to obtain a factorization with not too much
              ! element growth.
              if( usedqd ) then
                 ! the initial sigma was to the outer end of the spectrum
                 ! the matrix is definite and we need not retreat.
                 tau = spdiam*eps*n + two*pivmin
                 tau = max( tau,two*eps*abs(sigma) )
              else
                 if(mb>1) then
                    clwdth = w(wend) + werr(wend) - w(wbegin) - werr(wbegin)
                    avgap = abs(clwdth / real(wend-wbegin,KIND=${rk}$))
                    if( sgndef==one ) then
                       tau = half*max(wgap(wbegin),avgap)
                       tau = max(tau,werr(wbegin))
                    else
                       tau = half*max(wgap(wend-1),avgap)
                       tau = max(tau,werr(wend))
                    endif
                 else
                    tau = werr(wbegin)
                 endif
              endif
              loop_80: do idum = 1, maxtry
                 ! compute l d l^t factorization of tridiagonal matrix t - sigma i.
                 ! store d in work(1:in), l in work(in+1:2*in), and reciprocals of
                 ! pivots in work(2*in+1:3*in)
                 dpivot = d( ibegin ) - sigma
                 work( 1 ) = dpivot
                 dmax = abs( work(1) )
                 j = ibegin
                 do i = 1, in - 1
                    work( 2*in+i ) = one / work( i )
                    tmp = e( j )*work( 2*in+i )
                    work( in+i ) = tmp
                    dpivot = ( d( j+1 )-sigma ) - tmp*e( j )
                    work( i+1 ) = dpivot
                    dmax = max( dmax, abs(dpivot) )
                    j = j + 1
                 end do
                 ! check for element growth
                 if( dmax > maxgrowth*spdiam ) then
                    norep = .true.
                 else
                    norep = .false.
                 endif
                 if( usedqd .and. .not.norep ) then
                    ! ensure the definiteness of the representation
                    ! all entries of d (of l d l^t) must have the same sign
                    do i = 1, in
                       tmp = sgndef*work( i )
                       if( tmp<zero ) norep = .true.
                    end do
                 endif
                 if(norep) then
                    ! note that in the case of irange=allrng, we use the gerschgorin
                    ! shift which makes the matrix definite. so we should end up
                    ! here really only in the case of irange = valrng or indrng.
                    if( idum==maxtry-1 ) then
                       if( sgndef==one ) then
                          ! the fudged gerschgorin shift should succeed
                          sigma =gl - fudge*spdiam*eps*n - fudge*two*pivmin
                       else
                          sigma =gu + fudge*spdiam*eps*n + fudge*two*pivmin
                       end if
                    else
                       sigma = sigma - sgndef * tau
                       tau = two * tau
                    end if
                 else
                    ! an initial rrr is found
                    go to 83
                 end if
              end do loop_80
              ! if the program reaches this point, no base representation could be
              ! found in maxtry iterations.
              info = 2
              return
              83 continue
              ! at this point, we have found an initial base representation
              ! t - sigma i = l d l^t with not too much element growth.
              ! store the shift.
              e( iend ) = sigma
              ! store d and l.
              call stdlib_${ri}$copy( in, work, 1, d( ibegin ), 1 )
              call stdlib_${ri}$copy( in-1, work( in+1 ), 1, e( ibegin ), 1 )
              if(mb>1 ) then
                 ! perturb each entry of the base representation by a small
                 ! (but random) relative amount to overcome difficulties with
                 ! glued matrices.
                 do i = 1, 4
                    iseed( i ) = 1
                 end do
                 call stdlib_${ri}$larnv(2, iseed, 2*in-1, work(1))
                 do i = 1,in-1
                    d(ibegin+i-1) = d(ibegin+i-1)*(one+eps*pert*work(i))
                    e(ibegin+i-1) = e(ibegin+i-1)*(one+eps*pert*work(in+i))
                 end do
                 d(iend) = d(iend)*(one+eps*four*work(in))
              endif
              ! don't update the gerschgorin intervals because keeping track
              ! of the updates would be too much work in stdlib_${ri}$larrv.
              ! we update w instead and use it to locate the proper gerschgorin
              ! intervals.
              ! compute the required eigenvalues of l d l' by bisection or dqds
              if ( .not.usedqd ) then
                 ! if stdlib_${ri}$larrd has been used, shift the eigenvalue approximations
                 ! according to their representation. this is necessary for
                 ! a uniform stdlib_${ri}$larrv since dqds computes eigenvalues of the
                 ! shifted representation. in stdlib_${ri}$larrv, w will always hold the
                 ! unshifted eigenvalue approximation.
                 do j=wbegin,wend
                    w(j) = w(j) - sigma
                    werr(j) = werr(j) + abs(w(j)) * eps
                 end do
                 ! call stdlib_${ri}$larrb to reduce eigenvalue error of the approximations
                 ! from stdlib_${ri}$larrd
                 do i = ibegin, iend-1
                    work( i ) = d( i ) * e( i )**2
                 end do
                 ! use bisection to find ev from indl to indu
                 call stdlib_${ri}$larrb(in, d(ibegin), work(ibegin),indl, indu, rtol1, rtol2, indl-1,&
                 w(wbegin), wgap(wbegin), werr(wbegin),work( 2*n+1 ), iwork, pivmin, spdiam,in, &
                           iinfo )
                 if( iinfo /= 0 ) then
                    info = -4
                    return
                 end if
                 ! stdlib_${ri}$larrb computes all gaps correctly except for the last one
                 ! record distance to vu/gu
                 wgap( wend ) = max( zero,( vu-sigma ) - ( w( wend ) + werr( wend ) ) )
                 do i = indl, indu
                    m = m + 1
                    iblock(m) = jblk
                    indexw(m) = i
                 end do
              else
                 ! call dqds to get all eigs (and then possibly delete unwanted
                 ! eigenvalues).
                 ! note that dqds finds the eigenvalues of the l d l^t representation
                 ! of t to high relative accuracy. high relative accuracy
                 ! might be lost when the shift of the rrr is subtracted to obtain
                 ! the eigenvalues of t. however, t is not guaranteed to define its
                 ! eigenvalues to high relative accuracy anyway.
                 ! set rtol to the order of the tolerance used in stdlib_${ri}$lasq2
                 ! this is an estimated error, the worst case bound is 4*n*eps
                 ! which is usually too large and requires unnecessary work to be
                 ! done by bisection when computing the eigenvectors
                 rtol = log(real(in,KIND=${rk}$)) * four * eps
                 j = ibegin
                 do i = 1, in - 1
                    work( 2*i-1 ) = abs( d( j ) )
                    work( 2*i ) = e( j )*e( j )*work( 2*i-1 )
                    j = j + 1
                 end do
                 work( 2*in-1 ) = abs( d( iend ) )
                 work( 2*in ) = zero
                 call stdlib_${ri}$lasq2( in, work, iinfo )
                 if( iinfo /= 0 ) then
                    ! if iinfo = -5 then an index is part of a tight cluster
                    ! and should be changed. the index is in iwork(1) and the
                    ! gap is in work(n+1)
                    info = -5
                    return
                 else
                    ! test that all eigenvalues are positive as expected
                    do i = 1, in
                       if( work( i )<zero ) then
                          info = -6
                          return
                       endif
                    end do
                 end if
                 if( sgndef>zero ) then
                    do i = indl, indu
                       m = m + 1
                       w( m ) = work( in-i+1 )
                       iblock( m ) = jblk
                       indexw( m ) = i
                    end do
                 else
                    do i = indl, indu
                       m = m + 1
                       w( m ) = -work( i )
                       iblock( m ) = jblk
                       indexw( m ) = i
                    end do
                 end if
                 do i = m - mb + 1, m
                    ! the value of rtol below should be the tolerance in stdlib_${ri}$lasq2
                    werr( i ) = rtol * abs( w(i) )
                 end do
                 do i = m - mb + 1, m - 1
                    ! compute the right gap between the intervals
                    wgap( i ) = max( zero,w(i+1)-werr(i+1) - (w(i)+werr(i)) )
                 end do
                 wgap( m ) = max( zero,( vu-sigma ) - ( w( m ) + werr( m ) ) )
              end if
              ! proceed with next block
              ibegin = iend + 1
              wbegin = wend + 1
           end do loop_170
           return
     end subroutine stdlib_${ri}$larre

#:endif
#:endfor





     pure subroutine stdlib_slatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
     !! SLATRD reduces NB rows and columns of a real symmetric matrix A to
     !! symmetric tridiagonal form by an orthogonal similarity
     !! transformation Q**T * A * Q, and returns the matrices V and W which are
     !! needed to apply the transformation to the unreduced part of A.
     !! If UPLO = 'U', SLATRD reduces the last NB rows and columns of a
     !! matrix, of which the upper triangle is supplied;
     !! if UPLO = 'L', SLATRD reduces the first NB rows and columns of a
     !! matrix, of which the lower triangle is supplied.
     !! This is an auxiliary routine called by SSYTRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: e(*), tau(*), w(ldw,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, iw
           real(sp) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 )return
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! reduce last nb columns of upper triangle
              loop_10: do i = n, n - nb + 1, -1
                 iw = i - n + nb
                 if( i<n ) then
                    ! update a(1:i,i)
                    call stdlib_sgemv( 'NO TRANSPOSE', i, n-i, -one, a( 1, i+1 ),lda, w( i, iw+1 )&
                              , ldw, one, a( 1, i ), 1 )
                    call stdlib_sgemv( 'NO TRANSPOSE', i, n-i, -one, w( 1, iw+1 ),ldw, a( i, i+1 )&
                              , lda, one, a( 1, i ), 1 )
                 end if
                 if( i>1 ) then
                    ! generate elementary reflector h(i) to annihilate
                    ! a(1:i-2,i)
                    call stdlib_slarfg( i-1, a( i-1, i ), a( 1, i ), 1, tau( i-1 ) )
                    e( i-1 ) = a( i-1, i )
                    a( i-1, i ) = one
                    ! compute w(1:i-1,i)
                    call stdlib_ssymv( 'UPPER', i-1, one, a, lda, a( 1, i ), 1,zero, w( 1, iw ), &
                              1 )
                    if( i<n ) then
                       call stdlib_sgemv( 'TRANSPOSE', i-1, n-i, one, w( 1, iw+1 ),ldw, a( 1, i ),&
                                  1, zero, w( i+1, iw ), 1 )
                       call stdlib_sgemv( 'NO TRANSPOSE', i-1, n-i, -one,a( 1, i+1 ), lda, w( i+1,&
                                  iw ), 1, one,w( 1, iw ), 1 )
                       call stdlib_sgemv( 'TRANSPOSE', i-1, n-i, one, a( 1, i+1 ),lda, a( 1, i ), &
                                 1, zero, w( i+1, iw ), 1 )
                       call stdlib_sgemv( 'NO TRANSPOSE', i-1, n-i, -one,w( 1, iw+1 ), ldw, w( i+&
                                 1, iw ), 1, one,w( 1, iw ), 1 )
                    end if
                    call stdlib_sscal( i-1, tau( i-1 ), w( 1, iw ), 1 )
                    alpha = -half*tau( i-1 )*stdlib_sdot( i-1, w( 1, iw ), 1,a( 1, i ), 1 )
                              
                    call stdlib_saxpy( i-1, alpha, a( 1, i ), 1, w( 1, iw ), 1 )
                 end if
              end do loop_10
           else
              ! reduce first nb columns of lower triangle
              do i = 1, nb
                 ! update a(i:n,i)
                 call stdlib_sgemv( 'NO TRANSPOSE', n-i+1, i-1, -one, a( i, 1 ),lda, w( i, 1 ), &
                           ldw, one, a( i, i ), 1 )
                 call stdlib_sgemv( 'NO TRANSPOSE', n-i+1, i-1, -one, w( i, 1 ),ldw, a( i, 1 ), &
                           lda, one, a( i, i ), 1 )
                 if( i<n ) then
                    ! generate elementary reflector h(i) to annihilate
                    ! a(i+2:n,i)
                    call stdlib_slarfg( n-i, a( i+1, i ), a( min( i+2, n ), i ), 1,tau( i ) )
                              
                    e( i ) = a( i+1, i )
                    a( i+1, i ) = one
                    ! compute w(i+1:n,i)
                    call stdlib_ssymv( 'LOWER', n-i, one, a( i+1, i+1 ), lda,a( i+1, i ), 1, zero,&
                               w( i+1, i ), 1 )
                    call stdlib_sgemv( 'TRANSPOSE', n-i, i-1, one, w( i+1, 1 ), ldw,a( i+1, i ), &
                              1, zero, w( 1, i ), 1 )
                    call stdlib_sgemv( 'NO TRANSPOSE', n-i, i-1, -one, a( i+1, 1 ),lda, w( 1, i ),&
                               1, one, w( i+1, i ), 1 )
                    call stdlib_sgemv( 'TRANSPOSE', n-i, i-1, one, a( i+1, 1 ), lda,a( i+1, i ), &
                              1, zero, w( 1, i ), 1 )
                    call stdlib_sgemv( 'NO TRANSPOSE', n-i, i-1, -one, w( i+1, 1 ),ldw, w( 1, i ),&
                               1, one, w( i+1, i ), 1 )
                    call stdlib_sscal( n-i, tau( i ), w( i+1, i ), 1 )
                    alpha = -half*tau( i )*stdlib_sdot( n-i, w( i+1, i ), 1,a( i+1, i ), 1 )
                              
                    call stdlib_saxpy( n-i, alpha, a( i+1, i ), 1, w( i+1, i ), 1 )
                 end if
              end do
           end if
           return
     end subroutine stdlib_slatrd

     pure subroutine stdlib_dlatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
     !! DLATRD reduces NB rows and columns of a real symmetric matrix A to
     !! symmetric tridiagonal form by an orthogonal similarity
     !! transformation Q**T * A * Q, and returns the matrices V and W which are
     !! needed to apply the transformation to the unreduced part of A.
     !! If UPLO = 'U', DLATRD reduces the last NB rows and columns of a
     !! matrix, of which the upper triangle is supplied;
     !! if UPLO = 'L', DLATRD reduces the first NB rows and columns of a
     !! matrix, of which the lower triangle is supplied.
     !! This is an auxiliary routine called by DSYTRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: e(*), tau(*), w(ldw,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, iw
           real(dp) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 )return
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! reduce last nb columns of upper triangle
              loop_10: do i = n, n - nb + 1, -1
                 iw = i - n + nb
                 if( i<n ) then
                    ! update a(1:i,i)
                    call stdlib_dgemv( 'NO TRANSPOSE', i, n-i, -one, a( 1, i+1 ),lda, w( i, iw+1 )&
                              , ldw, one, a( 1, i ), 1 )
                    call stdlib_dgemv( 'NO TRANSPOSE', i, n-i, -one, w( 1, iw+1 ),ldw, a( i, i+1 )&
                              , lda, one, a( 1, i ), 1 )
                 end if
                 if( i>1 ) then
                    ! generate elementary reflector h(i) to annihilate
                    ! a(1:i-2,i)
                    call stdlib_dlarfg( i-1, a( i-1, i ), a( 1, i ), 1, tau( i-1 ) )
                    e( i-1 ) = a( i-1, i )
                    a( i-1, i ) = one
                    ! compute w(1:i-1,i)
                    call stdlib_dsymv( 'UPPER', i-1, one, a, lda, a( 1, i ), 1,zero, w( 1, iw ), &
                              1 )
                    if( i<n ) then
                       call stdlib_dgemv( 'TRANSPOSE', i-1, n-i, one, w( 1, iw+1 ),ldw, a( 1, i ),&
                                  1, zero, w( i+1, iw ), 1 )
                       call stdlib_dgemv( 'NO TRANSPOSE', i-1, n-i, -one,a( 1, i+1 ), lda, w( i+1,&
                                  iw ), 1, one,w( 1, iw ), 1 )
                       call stdlib_dgemv( 'TRANSPOSE', i-1, n-i, one, a( 1, i+1 ),lda, a( 1, i ), &
                                 1, zero, w( i+1, iw ), 1 )
                       call stdlib_dgemv( 'NO TRANSPOSE', i-1, n-i, -one,w( 1, iw+1 ), ldw, w( i+&
                                 1, iw ), 1, one,w( 1, iw ), 1 )
                    end if
                    call stdlib_dscal( i-1, tau( i-1 ), w( 1, iw ), 1 )
                    alpha = -half*tau( i-1 )*stdlib_ddot( i-1, w( 1, iw ), 1,a( 1, i ), 1 )
                              
                    call stdlib_daxpy( i-1, alpha, a( 1, i ), 1, w( 1, iw ), 1 )
                 end if
              end do loop_10
           else
              ! reduce first nb columns of lower triangle
              do i = 1, nb
                 ! update a(i:n,i)
                 call stdlib_dgemv( 'NO TRANSPOSE', n-i+1, i-1, -one, a( i, 1 ),lda, w( i, 1 ), &
                           ldw, one, a( i, i ), 1 )
                 call stdlib_dgemv( 'NO TRANSPOSE', n-i+1, i-1, -one, w( i, 1 ),ldw, a( i, 1 ), &
                           lda, one, a( i, i ), 1 )
                 if( i<n ) then
                    ! generate elementary reflector h(i) to annihilate
                    ! a(i+2:n,i)
                    call stdlib_dlarfg( n-i, a( i+1, i ), a( min( i+2, n ), i ), 1,tau( i ) )
                              
                    e( i ) = a( i+1, i )
                    a( i+1, i ) = one
                    ! compute w(i+1:n,i)
                    call stdlib_dsymv( 'LOWER', n-i, one, a( i+1, i+1 ), lda,a( i+1, i ), 1, zero,&
                               w( i+1, i ), 1 )
                    call stdlib_dgemv( 'TRANSPOSE', n-i, i-1, one, w( i+1, 1 ), ldw,a( i+1, i ), &
                              1, zero, w( 1, i ), 1 )
                    call stdlib_dgemv( 'NO TRANSPOSE', n-i, i-1, -one, a( i+1, 1 ),lda, w( 1, i ),&
                               1, one, w( i+1, i ), 1 )
                    call stdlib_dgemv( 'TRANSPOSE', n-i, i-1, one, a( i+1, 1 ), lda,a( i+1, i ), &
                              1, zero, w( 1, i ), 1 )
                    call stdlib_dgemv( 'NO TRANSPOSE', n-i, i-1, -one, w( i+1, 1 ),ldw, w( 1, i ),&
                               1, one, w( i+1, i ), 1 )
                    call stdlib_dscal( n-i, tau( i ), w( i+1, i ), 1 )
                    alpha = -half*tau( i )*stdlib_ddot( n-i, w( i+1, i ), 1,a( i+1, i ), 1 )
                              
                    call stdlib_daxpy( n-i, alpha, a( i+1, i ), 1, w( i+1, i ), 1 )
                 end if
              end do
           end if
           return
     end subroutine stdlib_dlatrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$latrd( uplo, n, nb, a, lda, e, tau, w, ldw )
     !! DLATRD: reduces NB rows and columns of a real symmetric matrix A to
     !! symmetric tridiagonal form by an orthogonal similarity
     !! transformation Q**T * A * Q, and returns the matrices V and W which are
     !! needed to apply the transformation to the unreduced part of A.
     !! If UPLO = 'U', DLATRD reduces the last NB rows and columns of a
     !! matrix, of which the upper triangle is supplied;
     !! if UPLO = 'L', DLATRD reduces the first NB rows and columns of a
     !! matrix, of which the lower triangle is supplied.
     !! This is an auxiliary routine called by DSYTRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: e(*), tau(*), w(ldw,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, iw
           real(${rk}$) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 )return
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! reduce last nb columns of upper triangle
              loop_10: do i = n, n - nb + 1, -1
                 iw = i - n + nb
                 if( i<n ) then
                    ! update a(1:i,i)
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', i, n-i, -one, a( 1, i+1 ),lda, w( i, iw+1 )&
                              , ldw, one, a( 1, i ), 1 )
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', i, n-i, -one, w( 1, iw+1 ),ldw, a( i, i+1 )&
                              , lda, one, a( 1, i ), 1 )
                 end if
                 if( i>1 ) then
                    ! generate elementary reflector h(i) to annihilate
                    ! a(1:i-2,i)
                    call stdlib_${ri}$larfg( i-1, a( i-1, i ), a( 1, i ), 1, tau( i-1 ) )
                    e( i-1 ) = a( i-1, i )
                    a( i-1, i ) = one
                    ! compute w(1:i-1,i)
                    call stdlib_${ri}$symv( 'UPPER', i-1, one, a, lda, a( 1, i ), 1,zero, w( 1, iw ), &
                              1 )
                    if( i<n ) then
                       call stdlib_${ri}$gemv( 'TRANSPOSE', i-1, n-i, one, w( 1, iw+1 ),ldw, a( 1, i ),&
                                  1, zero, w( i+1, iw ), 1 )
                       call stdlib_${ri}$gemv( 'NO TRANSPOSE', i-1, n-i, -one,a( 1, i+1 ), lda, w( i+1,&
                                  iw ), 1, one,w( 1, iw ), 1 )
                       call stdlib_${ri}$gemv( 'TRANSPOSE', i-1, n-i, one, a( 1, i+1 ),lda, a( 1, i ), &
                                 1, zero, w( i+1, iw ), 1 )
                       call stdlib_${ri}$gemv( 'NO TRANSPOSE', i-1, n-i, -one,w( 1, iw+1 ), ldw, w( i+&
                                 1, iw ), 1, one,w( 1, iw ), 1 )
                    end if
                    call stdlib_${ri}$scal( i-1, tau( i-1 ), w( 1, iw ), 1 )
                    alpha = -half*tau( i-1 )*stdlib_${ri}$dot( i-1, w( 1, iw ), 1,a( 1, i ), 1 )
                              
                    call stdlib_${ri}$axpy( i-1, alpha, a( 1, i ), 1, w( 1, iw ), 1 )
                 end if
              end do loop_10
           else
              ! reduce first nb columns of lower triangle
              do i = 1, nb
                 ! update a(i:n,i)
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-i+1, i-1, -one, a( i, 1 ),lda, w( i, 1 ), &
                           ldw, one, a( i, i ), 1 )
                 call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-i+1, i-1, -one, w( i, 1 ),ldw, a( i, 1 ), &
                           lda, one, a( i, i ), 1 )
                 if( i<n ) then
                    ! generate elementary reflector h(i) to annihilate
                    ! a(i+2:n,i)
                    call stdlib_${ri}$larfg( n-i, a( i+1, i ), a( min( i+2, n ), i ), 1,tau( i ) )
                              
                    e( i ) = a( i+1, i )
                    a( i+1, i ) = one
                    ! compute w(i+1:n,i)
                    call stdlib_${ri}$symv( 'LOWER', n-i, one, a( i+1, i+1 ), lda,a( i+1, i ), 1, zero,&
                               w( i+1, i ), 1 )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-i, i-1, one, w( i+1, 1 ), ldw,a( i+1, i ), &
                              1, zero, w( 1, i ), 1 )
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-i, i-1, -one, a( i+1, 1 ),lda, w( 1, i ),&
                               1, one, w( i+1, i ), 1 )
                    call stdlib_${ri}$gemv( 'TRANSPOSE', n-i, i-1, one, a( i+1, 1 ), lda,a( i+1, i ), &
                              1, zero, w( 1, i ), 1 )
                    call stdlib_${ri}$gemv( 'NO TRANSPOSE', n-i, i-1, -one, w( i+1, 1 ),ldw, w( 1, i ),&
                               1, one, w( i+1, i ), 1 )
                    call stdlib_${ri}$scal( n-i, tau( i ), w( i+1, i ), 1 )
                    alpha = -half*tau( i )*stdlib_${ri}$dot( n-i, w( i+1, i ), 1,a( i+1, i ), 1 )
                              
                    call stdlib_${ri}$axpy( n-i, alpha, a( i+1, i ), 1, w( i+1, i ), 1 )
                 end if
              end do
           end if
           return
     end subroutine stdlib_${ri}$latrd

#:endif
#:endfor

     pure subroutine stdlib_clatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
     !! CLATRD reduces NB rows and columns of a complex Hermitian matrix A to
     !! Hermitian tridiagonal form by a unitary similarity
     !! transformation Q**H * A * Q, and returns the matrices V and W which are
     !! needed to apply the transformation to the unreduced part of A.
     !! If UPLO = 'U', CLATRD reduces the last NB rows and columns of a
     !! matrix, of which the upper triangle is supplied;
     !! if UPLO = 'L', CLATRD reduces the first NB rows and columns of a
     !! matrix, of which the lower triangle is supplied.
     !! This is an auxiliary routine called by CHETRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           real(sp), intent(out) :: e(*)
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(out) :: tau(*), w(ldw,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, iw
           complex(sp) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 )return
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! reduce last nb columns of upper triangle
              loop_10: do i = n, n - nb + 1, -1
                 iw = i - n + nb
                 if( i<n ) then
                    ! update a(1:i,i)
                    a( i, i ) = real( a( i, i ),KIND=sp)
                    call stdlib_clacgv( n-i, w( i, iw+1 ), ldw )
                    call stdlib_cgemv( 'NO TRANSPOSE', i, n-i, -cone, a( 1, i+1 ),lda, w( i, iw+1 &
                              ), ldw, cone, a( 1, i ), 1 )
                    call stdlib_clacgv( n-i, w( i, iw+1 ), ldw )
                    call stdlib_clacgv( n-i, a( i, i+1 ), lda )
                    call stdlib_cgemv( 'NO TRANSPOSE', i, n-i, -cone, w( 1, iw+1 ),ldw, a( i, i+1 &
                              ), lda, cone, a( 1, i ), 1 )
                    call stdlib_clacgv( n-i, a( i, i+1 ), lda )
                    a( i, i ) = real( a( i, i ),KIND=sp)
                 end if
                 if( i>1 ) then
                    ! generate elementary reflector h(i) to annihilate
                    ! a(1:i-2,i)
                    alpha = a( i-1, i )
                    call stdlib_clarfg( i-1, alpha, a( 1, i ), 1, tau( i-1 ) )
                    e( i-1 ) = real( alpha,KIND=sp)
                    a( i-1, i ) = cone
                    ! compute w(1:i-1,i)
                    call stdlib_chemv( 'UPPER', i-1, cone, a, lda, a( 1, i ), 1,czero, w( 1, iw ),&
                               1 )
                    if( i<n ) then
                       call stdlib_cgemv( 'CONJUGATE TRANSPOSE', i-1, n-i, cone,w( 1, iw+1 ), ldw,&
                                  a( 1, i ), 1, czero,w( i+1, iw ), 1 )
                       call stdlib_cgemv( 'NO TRANSPOSE', i-1, n-i, -cone,a( 1, i+1 ), lda, w( i+&
                                 1, iw ), 1, cone,w( 1, iw ), 1 )
                       call stdlib_cgemv( 'CONJUGATE TRANSPOSE', i-1, n-i, cone,a( 1, i+1 ), lda, &
                                 a( 1, i ), 1, czero,w( i+1, iw ), 1 )
                       call stdlib_cgemv( 'NO TRANSPOSE', i-1, n-i, -cone,w( 1, iw+1 ), ldw, w( i+&
                                 1, iw ), 1, cone,w( 1, iw ), 1 )
                    end if
                    call stdlib_cscal( i-1, tau( i-1 ), w( 1, iw ), 1 )
                    alpha = -chalf*tau( i-1 )*stdlib_cdotc( i-1, w( 1, iw ), 1,a( 1, i ), 1 )
                              
                    call stdlib_caxpy( i-1, alpha, a( 1, i ), 1, w( 1, iw ), 1 )
                 end if
              end do loop_10
           else
              ! reduce first nb columns of lower triangle
              loop_20: do i = 1, nb
                 ! update a(i:n,i)
                 a( i, i ) = real( a( i, i ),KIND=sp)
                 call stdlib_clacgv( i-1, w( i, 1 ), ldw )
                 call stdlib_cgemv( 'NO TRANSPOSE', n-i+1, i-1, -cone, a( i, 1 ),lda, w( i, 1 ), &
                           ldw, cone, a( i, i ), 1 )
                 call stdlib_clacgv( i-1, w( i, 1 ), ldw )
                 call stdlib_clacgv( i-1, a( i, 1 ), lda )
                 call stdlib_cgemv( 'NO TRANSPOSE', n-i+1, i-1, -cone, w( i, 1 ),ldw, a( i, 1 ), &
                           lda, cone, a( i, i ), 1 )
                 call stdlib_clacgv( i-1, a( i, 1 ), lda )
                 a( i, i ) = real( a( i, i ),KIND=sp)
                 if( i<n ) then
                    ! generate elementary reflector h(i) to annihilate
                    ! a(i+2:n,i)
                    alpha = a( i+1, i )
                    call stdlib_clarfg( n-i, alpha, a( min( i+2, n ), i ), 1,tau( i ) )
                    e( i ) = real( alpha,KIND=sp)
                    a( i+1, i ) = cone
                    ! compute w(i+1:n,i)
                    call stdlib_chemv( 'LOWER', n-i, cone, a( i+1, i+1 ), lda,a( i+1, i ), 1, &
                              czero, w( i+1, i ), 1 )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-i, i-1, cone,w( i+1, 1 ), ldw, a( &
                              i+1, i ), 1, czero,w( 1, i ), 1 )
                    call stdlib_cgemv( 'NO TRANSPOSE', n-i, i-1, -cone, a( i+1, 1 ),lda, w( 1, i )&
                              , 1, cone, w( i+1, i ), 1 )
                    call stdlib_cgemv( 'CONJUGATE TRANSPOSE', n-i, i-1, cone,a( i+1, 1 ), lda, a( &
                              i+1, i ), 1, czero,w( 1, i ), 1 )
                    call stdlib_cgemv( 'NO TRANSPOSE', n-i, i-1, -cone, w( i+1, 1 ),ldw, w( 1, i )&
                              , 1, cone, w( i+1, i ), 1 )
                    call stdlib_cscal( n-i, tau( i ), w( i+1, i ), 1 )
                    alpha = -chalf*tau( i )*stdlib_cdotc( n-i, w( i+1, i ), 1,a( i+1, i ), 1 )
                              
                    call stdlib_caxpy( n-i, alpha, a( i+1, i ), 1, w( i+1, i ), 1 )
                 end if
              end do loop_20
           end if
           return
     end subroutine stdlib_clatrd

     pure subroutine stdlib_zlatrd( uplo, n, nb, a, lda, e, tau, w, ldw )
     !! ZLATRD reduces NB rows and columns of a complex Hermitian matrix A to
     !! Hermitian tridiagonal form by a unitary similarity
     !! transformation Q**H * A * Q, and returns the matrices V and W which are
     !! needed to apply the transformation to the unreduced part of A.
     !! If UPLO = 'U', ZLATRD reduces the last NB rows and columns of a
     !! matrix, of which the upper triangle is supplied;
     !! if UPLO = 'L', ZLATRD reduces the first NB rows and columns of a
     !! matrix, of which the lower triangle is supplied.
     !! This is an auxiliary routine called by ZHETRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           real(dp), intent(out) :: e(*)
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(out) :: tau(*), w(ldw,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, iw
           complex(dp) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 )return
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! reduce last nb columns of upper triangle
              loop_10: do i = n, n - nb + 1, -1
                 iw = i - n + nb
                 if( i<n ) then
                    ! update a(1:i,i)
                    a( i, i ) = real( a( i, i ),KIND=dp)
                    call stdlib_zlacgv( n-i, w( i, iw+1 ), ldw )
                    call stdlib_zgemv( 'NO TRANSPOSE', i, n-i, -cone, a( 1, i+1 ),lda, w( i, iw+1 &
                              ), ldw, cone, a( 1, i ), 1 )
                    call stdlib_zlacgv( n-i, w( i, iw+1 ), ldw )
                    call stdlib_zlacgv( n-i, a( i, i+1 ), lda )
                    call stdlib_zgemv( 'NO TRANSPOSE', i, n-i, -cone, w( 1, iw+1 ),ldw, a( i, i+1 &
                              ), lda, cone, a( 1, i ), 1 )
                    call stdlib_zlacgv( n-i, a( i, i+1 ), lda )
                    a( i, i ) = real( a( i, i ),KIND=dp)
                 end if
                 if( i>1 ) then
                    ! generate elementary reflector h(i) to annihilate
                    ! a(1:i-2,i)
                    alpha = a( i-1, i )
                    call stdlib_zlarfg( i-1, alpha, a( 1, i ), 1, tau( i-1 ) )
                    e( i-1 ) = real( alpha,KIND=dp)
                    a( i-1, i ) = cone
                    ! compute w(1:i-1,i)
                    call stdlib_zhemv( 'UPPER', i-1, cone, a, lda, a( 1, i ), 1,czero, w( 1, iw ),&
                               1 )
                    if( i<n ) then
                       call stdlib_zgemv( 'CONJUGATE TRANSPOSE', i-1, n-i, cone,w( 1, iw+1 ), ldw,&
                                  a( 1, i ), 1, czero,w( i+1, iw ), 1 )
                       call stdlib_zgemv( 'NO TRANSPOSE', i-1, n-i, -cone,a( 1, i+1 ), lda, w( i+&
                                 1, iw ), 1, cone,w( 1, iw ), 1 )
                       call stdlib_zgemv( 'CONJUGATE TRANSPOSE', i-1, n-i, cone,a( 1, i+1 ), lda, &
                                 a( 1, i ), 1, czero,w( i+1, iw ), 1 )
                       call stdlib_zgemv( 'NO TRANSPOSE', i-1, n-i, -cone,w( 1, iw+1 ), ldw, w( i+&
                                 1, iw ), 1, cone,w( 1, iw ), 1 )
                    end if
                    call stdlib_zscal( i-1, tau( i-1 ), w( 1, iw ), 1 )
                    alpha = -chalf*tau( i-1 )*stdlib_zdotc( i-1, w( 1, iw ), 1,a( 1, i ), 1 )
                              
                    call stdlib_zaxpy( i-1, alpha, a( 1, i ), 1, w( 1, iw ), 1 )
                 end if
              end do loop_10
           else
              ! reduce first nb columns of lower triangle
              loop_20: do i = 1, nb
                 ! update a(i:n,i)
                 a( i, i ) = real( a( i, i ),KIND=dp)
                 call stdlib_zlacgv( i-1, w( i, 1 ), ldw )
                 call stdlib_zgemv( 'NO TRANSPOSE', n-i+1, i-1, -cone, a( i, 1 ),lda, w( i, 1 ), &
                           ldw, cone, a( i, i ), 1 )
                 call stdlib_zlacgv( i-1, w( i, 1 ), ldw )
                 call stdlib_zlacgv( i-1, a( i, 1 ), lda )
                 call stdlib_zgemv( 'NO TRANSPOSE', n-i+1, i-1, -cone, w( i, 1 ),ldw, a( i, 1 ), &
                           lda, cone, a( i, i ), 1 )
                 call stdlib_zlacgv( i-1, a( i, 1 ), lda )
                 a( i, i ) = real( a( i, i ),KIND=dp)
                 if( i<n ) then
                    ! generate elementary reflector h(i) to annihilate
                    ! a(i+2:n,i)
                    alpha = a( i+1, i )
                    call stdlib_zlarfg( n-i, alpha, a( min( i+2, n ), i ), 1,tau( i ) )
                    e( i ) = real( alpha,KIND=dp)
                    a( i+1, i ) = cone
                    ! compute w(i+1:n,i)
                    call stdlib_zhemv( 'LOWER', n-i, cone, a( i+1, i+1 ), lda,a( i+1, i ), 1, &
                              czero, w( i+1, i ), 1 )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', n-i, i-1, cone,w( i+1, 1 ), ldw, a( &
                              i+1, i ), 1, czero,w( 1, i ), 1 )
                    call stdlib_zgemv( 'NO TRANSPOSE', n-i, i-1, -cone, a( i+1, 1 ),lda, w( 1, i )&
                              , 1, cone, w( i+1, i ), 1 )
                    call stdlib_zgemv( 'CONJUGATE TRANSPOSE', n-i, i-1, cone,a( i+1, 1 ), lda, a( &
                              i+1, i ), 1, czero,w( 1, i ), 1 )
                    call stdlib_zgemv( 'NO TRANSPOSE', n-i, i-1, -cone, w( i+1, 1 ),ldw, w( 1, i )&
                              , 1, cone, w( i+1, i ), 1 )
                    call stdlib_zscal( n-i, tau( i ), w( i+1, i ), 1 )
                    alpha = -chalf*tau( i )*stdlib_zdotc( n-i, w( i+1, i ), 1,a( i+1, i ), 1 )
                              
                    call stdlib_zaxpy( n-i, alpha, a( i+1, i ), 1, w( i+1, i ), 1 )
                 end if
              end do loop_20
           end if
           return
     end subroutine stdlib_zlatrd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$latrd( uplo, n, nb, a, lda, e, tau, w, ldw )
     !! ZLATRD: reduces NB rows and columns of a complex Hermitian matrix A to
     !! Hermitian tridiagonal form by a unitary similarity
     !! transformation Q**H * A * Q, and returns the matrices V and W which are
     !! needed to apply the transformation to the unreduced part of A.
     !! If UPLO = 'U', ZLATRD reduces the last NB rows and columns of a
     !! matrix, of which the upper triangle is supplied;
     !! if UPLO = 'L', ZLATRD reduces the first NB rows and columns of a
     !! matrix, of which the lower triangle is supplied.
     !! This is an auxiliary routine called by ZHETRD.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: lda, ldw, n, nb
           ! Array Arguments 
           real(${ck}$), intent(out) :: e(*)
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(out) :: tau(*), w(ldw,*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, iw
           complex(${ck}$) :: alpha
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 )return
           if( stdlib_lsame( uplo, 'U' ) ) then
              ! reduce last nb columns of upper triangle
              loop_10: do i = n, n - nb + 1, -1
                 iw = i - n + nb
                 if( i<n ) then
                    ! update a(1:i,i)
                    a( i, i ) = real( a( i, i ),KIND=${ck}$)
                    call stdlib_${ci}$lacgv( n-i, w( i, iw+1 ), ldw )
                    call stdlib_${ci}$gemv( 'NO TRANSPOSE', i, n-i, -cone, a( 1, i+1 ),lda, w( i, iw+1 &
                              ), ldw, cone, a( 1, i ), 1 )
                    call stdlib_${ci}$lacgv( n-i, w( i, iw+1 ), ldw )
                    call stdlib_${ci}$lacgv( n-i, a( i, i+1 ), lda )
                    call stdlib_${ci}$gemv( 'NO TRANSPOSE', i, n-i, -cone, w( 1, iw+1 ),ldw, a( i, i+1 &
                              ), lda, cone, a( 1, i ), 1 )
                    call stdlib_${ci}$lacgv( n-i, a( i, i+1 ), lda )
                    a( i, i ) = real( a( i, i ),KIND=${ck}$)
                 end if
                 if( i>1 ) then
                    ! generate elementary reflector h(i) to annihilate
                    ! a(1:i-2,i)
                    alpha = a( i-1, i )
                    call stdlib_${ci}$larfg( i-1, alpha, a( 1, i ), 1, tau( i-1 ) )
                    e( i-1 ) = real( alpha,KIND=${ck}$)
                    a( i-1, i ) = cone
                    ! compute w(1:i-1,i)
                    call stdlib_${ci}$hemv( 'UPPER', i-1, cone, a, lda, a( 1, i ), 1,czero, w( 1, iw ),&
                               1 )
                    if( i<n ) then
                       call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', i-1, n-i, cone,w( 1, iw+1 ), ldw,&
                                  a( 1, i ), 1, czero,w( i+1, iw ), 1 )
                       call stdlib_${ci}$gemv( 'NO TRANSPOSE', i-1, n-i, -cone,a( 1, i+1 ), lda, w( i+&
                                 1, iw ), 1, cone,w( 1, iw ), 1 )
                       call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', i-1, n-i, cone,a( 1, i+1 ), lda, &
                                 a( 1, i ), 1, czero,w( i+1, iw ), 1 )
                       call stdlib_${ci}$gemv( 'NO TRANSPOSE', i-1, n-i, -cone,w( 1, iw+1 ), ldw, w( i+&
                                 1, iw ), 1, cone,w( 1, iw ), 1 )
                    end if
                    call stdlib_${ci}$scal( i-1, tau( i-1 ), w( 1, iw ), 1 )
                    alpha = -chalf*tau( i-1 )*stdlib_${ci}$dotc( i-1, w( 1, iw ), 1,a( 1, i ), 1 )
                              
                    call stdlib_${ci}$axpy( i-1, alpha, a( 1, i ), 1, w( 1, iw ), 1 )
                 end if
              end do loop_10
           else
              ! reduce first nb columns of lower triangle
              loop_20: do i = 1, nb
                 ! update a(i:n,i)
                 a( i, i ) = real( a( i, i ),KIND=${ck}$)
                 call stdlib_${ci}$lacgv( i-1, w( i, 1 ), ldw )
                 call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-i+1, i-1, -cone, a( i, 1 ),lda, w( i, 1 ), &
                           ldw, cone, a( i, i ), 1 )
                 call stdlib_${ci}$lacgv( i-1, w( i, 1 ), ldw )
                 call stdlib_${ci}$lacgv( i-1, a( i, 1 ), lda )
                 call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-i+1, i-1, -cone, w( i, 1 ),ldw, a( i, 1 ), &
                           lda, cone, a( i, i ), 1 )
                 call stdlib_${ci}$lacgv( i-1, a( i, 1 ), lda )
                 a( i, i ) = real( a( i, i ),KIND=${ck}$)
                 if( i<n ) then
                    ! generate elementary reflector h(i) to annihilate
                    ! a(i+2:n,i)
                    alpha = a( i+1, i )
                    call stdlib_${ci}$larfg( n-i, alpha, a( min( i+2, n ), i ), 1,tau( i ) )
                    e( i ) = real( alpha,KIND=${ck}$)
                    a( i+1, i ) = cone
                    ! compute w(i+1:n,i)
                    call stdlib_${ci}$hemv( 'LOWER', n-i, cone, a( i+1, i+1 ), lda,a( i+1, i ), 1, &
                              czero, w( i+1, i ), 1 )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', n-i, i-1, cone,w( i+1, 1 ), ldw, a( &
                              i+1, i ), 1, czero,w( 1, i ), 1 )
                    call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-i, i-1, -cone, a( i+1, 1 ),lda, w( 1, i )&
                              , 1, cone, w( i+1, i ), 1 )
                    call stdlib_${ci}$gemv( 'CONJUGATE TRANSPOSE', n-i, i-1, cone,a( i+1, 1 ), lda, a( &
                              i+1, i ), 1, czero,w( 1, i ), 1 )
                    call stdlib_${ci}$gemv( 'NO TRANSPOSE', n-i, i-1, -cone, w( i+1, 1 ),ldw, w( 1, i )&
                              , 1, cone, w( i+1, i ), 1 )
                    call stdlib_${ci}$scal( n-i, tau( i ), w( i+1, i ), 1 )
                    alpha = -chalf*tau( i )*stdlib_${ci}$dotc( n-i, w( i+1, i ), 1,a( i+1, i ), 1 )
                              
                    call stdlib_${ci}$axpy( n-i, alpha, a( i+1, i ), 1, w( i+1, i ), 1 )
                 end if
              end do loop_20
           end if
           return
     end subroutine stdlib_${ci}$latrd

#:endif
#:endfor







     pure subroutine stdlib_sopmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )
     !! SOPMTR overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! nq-1 elementary reflectors, as returned by SSPTRD using packed
     !! storage:
     !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, m, n
           ! Array Arguments 
           real(sp), intent(inout) :: ap(*), c(ldc,*)
           real(sp), intent(in) :: tau(*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: forwrd, left, notran, upper
           integer(ilp) :: i, i1, i2, i3, ic, ii, jc, mi, ni, nq
           real(sp) :: aii
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           upper = stdlib_lsame( uplo, 'U' )
           ! nq is the order of q
           if( left ) then
              nq = m
           else
              nq = n
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( ldc<max( 1, m ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SOPMTR', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           if( upper ) then
              ! q was determined by a call to stdlib_ssptrd with uplo = 'u'
              forwrd = ( left .and. notran ) .or.( .not.left .and. .not.notran )
              if( forwrd ) then
                 i1 = 1
                 i2 = nq - 1
                 i3 = 1
                 ii = 2
              else
                 i1 = nq - 1
                 i2 = 1
                 i3 = -1
                 ii = nq*( nq+1 ) / 2 - 1
              end if
              if( left ) then
                 ni = n
              else
                 mi = m
              end if
              do i = i1, i2, i3
                 if( left ) then
                    ! h(i) is applied to c(1:i,1:n)
                    mi = i
                 else
                    ! h(i) is applied to c(1:m,1:i)
                    ni = i
                 end if
                 ! apply h(i)
                 aii = ap( ii )
                 ap( ii ) = one
                 call stdlib_slarf( side, mi, ni, ap( ii-i+1 ), 1, tau( i ), c, ldc,work )
                 ap( ii ) = aii
                 if( forwrd ) then
                    ii = ii + i + 2
                 else
                    ii = ii - i - 1
                 end if
              end do
           else
              ! q was determined by a call to stdlib_ssptrd with uplo = 'l'.
              forwrd = ( left .and. .not.notran ) .or.( .not.left .and. notran )
              if( forwrd ) then
                 i1 = 1
                 i2 = nq - 1
                 i3 = 1
                 ii = 2
              else
                 i1 = nq - 1
                 i2 = 1
                 i3 = -1
                 ii = nq*( nq+1 ) / 2 - 1
              end if
              if( left ) then
                 ni = n
                 jc = 1
              else
                 mi = m
                 ic = 1
              end if
              do i = i1, i2, i3
                 aii = ap( ii )
                 ap( ii ) = one
                 if( left ) then
                    ! h(i) is applied to c(i+1:m,1:n)
                    mi = m - i
                    ic = i + 1
                 else
                    ! h(i) is applied to c(1:m,i+1:n)
                    ni = n - i
                    jc = i + 1
                 end if
                 ! apply h(i)
                 call stdlib_slarf( side, mi, ni, ap( ii ), 1, tau( i ),c( ic, jc ), ldc, work )
                           
                 ap( ii ) = aii
                 if( forwrd ) then
                    ii = ii + nq - i + 1
                 else
                    ii = ii - nq + i - 2
                 end if
              end do
           end if
           return
     end subroutine stdlib_sopmtr

     pure subroutine stdlib_dopmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )
     !! DOPMTR overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! nq-1 elementary reflectors, as returned by DSPTRD using packed
     !! storage:
     !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, m, n
           ! Array Arguments 
           real(dp), intent(inout) :: ap(*), c(ldc,*)
           real(dp), intent(in) :: tau(*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: forwrd, left, notran, upper
           integer(ilp) :: i, i1, i2, i3, ic, ii, jc, mi, ni, nq
           real(dp) :: aii
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           upper = stdlib_lsame( uplo, 'U' )
           ! nq is the order of q
           if( left ) then
              nq = m
           else
              nq = n
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( ldc<max( 1, m ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DOPMTR', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           if( upper ) then
              ! q was determined by a call to stdlib_dsptrd with uplo = 'u'
              forwrd = ( left .and. notran ) .or.( .not.left .and. .not.notran )
              if( forwrd ) then
                 i1 = 1
                 i2 = nq - 1
                 i3 = 1
                 ii = 2
              else
                 i1 = nq - 1
                 i2 = 1
                 i3 = -1
                 ii = nq*( nq+1 ) / 2 - 1
              end if
              if( left ) then
                 ni = n
              else
                 mi = m
              end if
              do i = i1, i2, i3
                 if( left ) then
                    ! h(i) is applied to c(1:i,1:n)
                    mi = i
                 else
                    ! h(i) is applied to c(1:m,1:i)
                    ni = i
                 end if
                 ! apply h(i)
                 aii = ap( ii )
                 ap( ii ) = one
                 call stdlib_dlarf( side, mi, ni, ap( ii-i+1 ), 1, tau( i ), c, ldc,work )
                 ap( ii ) = aii
                 if( forwrd ) then
                    ii = ii + i + 2
                 else
                    ii = ii - i - 1
                 end if
              end do
           else
              ! q was determined by a call to stdlib_dsptrd with uplo = 'l'.
              forwrd = ( left .and. .not.notran ) .or.( .not.left .and. notran )
              if( forwrd ) then
                 i1 = 1
                 i2 = nq - 1
                 i3 = 1
                 ii = 2
              else
                 i1 = nq - 1
                 i2 = 1
                 i3 = -1
                 ii = nq*( nq+1 ) / 2 - 1
              end if
              if( left ) then
                 ni = n
                 jc = 1
              else
                 mi = m
                 ic = 1
              end if
              do i = i1, i2, i3
                 aii = ap( ii )
                 ap( ii ) = one
                 if( left ) then
                    ! h(i) is applied to c(i+1:m,1:n)
                    mi = m - i
                    ic = i + 1
                 else
                    ! h(i) is applied to c(1:m,i+1:n)
                    ni = n - i
                    jc = i + 1
                 end if
                 ! apply h(i)
                 call stdlib_dlarf( side, mi, ni, ap( ii ), 1, tau( i ),c( ic, jc ), ldc, work )
                           
                 ap( ii ) = aii
                 if( forwrd ) then
                    ii = ii + nq - i + 1
                 else
                    ii = ii - nq + i - 2
                 end if
              end do
           end if
           return
     end subroutine stdlib_dopmtr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$opmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )
     !! DOPMTR: overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! nq-1 elementary reflectors, as returned by DSPTRD using packed
     !! storage:
     !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ap(*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: forwrd, left, notran, upper
           integer(ilp) :: i, i1, i2, i3, ic, ii, jc, mi, ni, nq
           real(${rk}$) :: aii
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           upper = stdlib_lsame( uplo, 'U' )
           ! nq is the order of q
           if( left ) then
              nq = m
           else
              nq = n
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( ldc<max( 1, m ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DOPMTR', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           if( upper ) then
              ! q was determined by a call to stdlib_${ri}$sptrd with uplo = 'u'
              forwrd = ( left .and. notran ) .or.( .not.left .and. .not.notran )
              if( forwrd ) then
                 i1 = 1
                 i2 = nq - 1
                 i3 = 1
                 ii = 2
              else
                 i1 = nq - 1
                 i2 = 1
                 i3 = -1
                 ii = nq*( nq+1 ) / 2 - 1
              end if
              if( left ) then
                 ni = n
              else
                 mi = m
              end if
              do i = i1, i2, i3
                 if( left ) then
                    ! h(i) is applied to c(1:i,1:n)
                    mi = i
                 else
                    ! h(i) is applied to c(1:m,1:i)
                    ni = i
                 end if
                 ! apply h(i)
                 aii = ap( ii )
                 ap( ii ) = one
                 call stdlib_${ri}$larf( side, mi, ni, ap( ii-i+1 ), 1, tau( i ), c, ldc,work )
                 ap( ii ) = aii
                 if( forwrd ) then
                    ii = ii + i + 2
                 else
                    ii = ii - i - 1
                 end if
              end do
           else
              ! q was determined by a call to stdlib_${ri}$sptrd with uplo = 'l'.
              forwrd = ( left .and. .not.notran ) .or.( .not.left .and. notran )
              if( forwrd ) then
                 i1 = 1
                 i2 = nq - 1
                 i3 = 1
                 ii = 2
              else
                 i1 = nq - 1
                 i2 = 1
                 i3 = -1
                 ii = nq*( nq+1 ) / 2 - 1
              end if
              if( left ) then
                 ni = n
                 jc = 1
              else
                 mi = m
                 ic = 1
              end if
              do i = i1, i2, i3
                 aii = ap( ii )
                 ap( ii ) = one
                 if( left ) then
                    ! h(i) is applied to c(i+1:m,1:n)
                    mi = m - i
                    ic = i + 1
                 else
                    ! h(i) is applied to c(1:m,i+1:n)
                    ni = n - i
                    jc = i + 1
                 end if
                 ! apply h(i)
                 call stdlib_${ri}$larf( side, mi, ni, ap( ii ), 1, tau( i ),c( ic, jc ), ldc, work )
                           
                 ap( ii ) = aii
                 if( forwrd ) then
                    ii = ii + nq - i + 1
                 else
                    ii = ii - nq + i - 2
                 end if
              end do
           end if
           return
     end subroutine stdlib_${ri}$opmtr

#:endif
#:endfor







     pure subroutine stdlib_sormtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
     !! SORMTR overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! nq-1 elementary reflectors, as returned by SSYTRD:
     !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldc, lwork, m, n
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), c(ldc,*)
           real(sp), intent(in) :: tau(*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery, upper
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, ni, nb, nq, nw
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'T' ) )&
                     then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, nq ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           else if( lwork<nw .and. .not.lquery ) then
              info = -12
           end if
           if( info==0 ) then
              if( upper ) then
                 if( left ) then
                    nb = stdlib_ilaenv( 1, 'SORMQL', side // trans, m-1, n, m-1,-1 )
                 else
                    nb = stdlib_ilaenv( 1, 'SORMQL', side // trans, m, n-1, n-1,-1 )
                 end if
              else
                 if( left ) then
                    nb = stdlib_ilaenv( 1, 'SORMQR', side // trans, m-1, n, m-1,-1 )
                 else
                    nb = stdlib_ilaenv( 1, 'SORMQR', side // trans, m, n-1, n-1,-1 )
                 end if
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SORMTR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nq==1 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = m - 1
              ni = n
           else
              mi = m
              ni = n - 1
           end if
           if( upper ) then
              ! q was determined by a call to stdlib_ssytrd with uplo = 'u'
              call stdlib_sormql( side, trans, mi, ni, nq-1, a( 1, 2 ), lda, tau, c,ldc, work, &
                        lwork, iinfo )
           else
              ! q was determined by a call to stdlib_ssytrd with uplo = 'l'
              if( left ) then
                 i1 = 2
                 i2 = 1
              else
                 i1 = 1
                 i2 = 2
              end if
              call stdlib_sormqr( side, trans, mi, ni, nq-1, a( 2, 1 ), lda, tau,c( i1, i2 ), ldc,&
                         work, lwork, iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_sormtr

     pure subroutine stdlib_dormtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
     !! DORMTR overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! nq-1 elementary reflectors, as returned by DSYTRD:
     !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldc, lwork, m, n
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), c(ldc,*)
           real(dp), intent(in) :: tau(*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery, upper
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, ni, nq, nw
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'T' ) )&
                     then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, nq ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           else if( lwork<nw .and. .not.lquery ) then
              info = -12
           end if
           if( info==0 ) then
              if( upper ) then
                 if( left ) then
                    nb = stdlib_ilaenv( 1, 'DORMQL', side // trans, m-1, n, m-1,-1 )
                 else
                    nb = stdlib_ilaenv( 1, 'DORMQL', side // trans, m, n-1, n-1,-1 )
                 end if
              else
                 if( left ) then
                    nb = stdlib_ilaenv( 1, 'DORMQR', side // trans, m-1, n, m-1,-1 )
                 else
                    nb = stdlib_ilaenv( 1, 'DORMQR', side // trans, m, n-1, n-1,-1 )
                 end if
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORMTR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nq==1 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = m - 1
              ni = n
           else
              mi = m
              ni = n - 1
           end if
           if( upper ) then
              ! q was determined by a call to stdlib_dsytrd with uplo = 'u'
              call stdlib_dormql( side, trans, mi, ni, nq-1, a( 1, 2 ), lda, tau, c,ldc, work, &
                        lwork, iinfo )
           else
              ! q was determined by a call to stdlib_dsytrd with uplo = 'l'
              if( left ) then
                 i1 = 2
                 i2 = 1
              else
                 i1 = 1
                 i2 = 2
              end if
              call stdlib_dormqr( side, trans, mi, ni, nq-1, a( 2, 1 ), lda, tau,c( i1, i2 ), ldc,&
                         work, lwork, iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dormtr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$ormtr( side, uplo, trans, m, n, a, lda, tau, c, ldc,work, lwork, &
     !! DORMTR: overwrites the general real M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'T':      Q**T * C       C * Q**T
     !! where Q is a real orthogonal matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! nq-1 elementary reflectors, as returned by DSYTRD:
     !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldc, lwork, m, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), c(ldc,*)
           real(${rk}$), intent(in) :: tau(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: left, lquery, upper
           integer(ilp) :: i1, i2, iinfo, lwkopt, mi, nb, ni, nq, nw
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           ! nq is the order of q and nw is the minimum dimension of work
           if( left ) then
              nq = m
              nw = max( 1, n )
           else
              nq = n
              nw = max( 1, m )
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.stdlib_lsame( trans, 'N' ) .and. .not.stdlib_lsame( trans, 'T' ) )&
                     then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, nq ) ) then
              info = -7
           else if( ldc<max( 1, m ) ) then
              info = -10
           else if( lwork<nw .and. .not.lquery ) then
              info = -12
           end if
           if( info==0 ) then
              if( upper ) then
                 if( left ) then
                    nb = stdlib_ilaenv( 1, 'DORMQL', side // trans, m-1, n, m-1,-1 )
                 else
                    nb = stdlib_ilaenv( 1, 'DORMQL', side // trans, m, n-1, n-1,-1 )
                 end if
              else
                 if( left ) then
                    nb = stdlib_ilaenv( 1, 'DORMQR', side // trans, m-1, n, m-1,-1 )
                 else
                    nb = stdlib_ilaenv( 1, 'DORMQR', side // trans, m, n-1, n-1,-1 )
                 end if
              end if
              lwkopt = nw*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DORMTR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 .or. nq==1 ) then
              work( 1 ) = 1
              return
           end if
           if( left ) then
              mi = m - 1
              ni = n
           else
              mi = m
              ni = n - 1
           end if
           if( upper ) then
              ! q was determined by a call to stdlib_${ri}$sytrd with uplo = 'u'
              call stdlib_${ri}$ormql( side, trans, mi, ni, nq-1, a( 1, 2 ), lda, tau, c,ldc, work, &
                        lwork, iinfo )
           else
              ! q was determined by a call to stdlib_${ri}$sytrd with uplo = 'l'
              if( left ) then
                 i1 = 2
                 i2 = 1
              else
                 i1 = 1
                 i2 = 2
              end if
              call stdlib_${ri}$ormqr( side, trans, mi, ni, nq-1, a( 2, 1 ), lda, tau,c( i1, i2 ), ldc,&
                         work, lwork, iinfo )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$ormtr

#:endif
#:endfor





     pure subroutine stdlib_slaed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho,cutpnt, z, dlamda, &
     !! SLAED8 merges the two sets of eigenvalues together into a single
     !! sorted set.  Then it tries to deflate the size of the problem.
     !! There are two ways in which deflation can occur:  when two or more
     !! eigenvalues are close together or if there is a tiny element in the
     !! Z vector.  For each such occurrence the order of the related secular
     !! equation problem is reduced by one.
               q2, ldq2, w, perm, givptr,givcol, givnum, indxp, indx, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: cutpnt, icompq, ldq, ldq2, n, qsiz
           integer(ilp), intent(out) :: givptr, info, k
           real(sp), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(out) :: givcol(2,*), indx(*), indxp(*), perm(*)
           integer(ilp), intent(inout) :: indxq(*)
           real(sp), intent(inout) :: d(*), q(ldq,*), z(*)
           real(sp), intent(out) :: dlamda(*), givnum(2,*), q2(ldq2,*), w(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: mone = -1.0_sp
           
           ! Local Scalars 
           integer(ilp) :: i, imax, j, jlam, jmax, jp, k2, n1, n1p1, n2
           real(sp) :: c, eps, s, t, tau, tol
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( icompq<0 .or. icompq>1 ) then
              info = -1
           else if( n<0 ) then
              info = -3
           else if( icompq==1 .and. qsiz<n ) then
              info = -4
           else if( ldq<max( 1, n ) ) then
              info = -7
           else if( cutpnt<min( 1, n ) .or. cutpnt>n ) then
              info = -10
           else if( ldq2<max( 1, n ) ) then
              info = -14
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SLAED8', -info )
              return
           end if
           ! need to initialize givptr to o here in case of quick exit
           ! to prevent an unspecified code behavior (usually sigfault)
           ! when iwork array on entry to *stedc is not zeroed
           ! (or at least some iwork entries which used in *laed7 for givptr).
           givptr = 0
           ! quick return if possible
           if( n==0 )return
           n1 = cutpnt
           n2 = n - n1
           n1p1 = n1 + 1
           if( rho<zero ) then
              call stdlib_sscal( n2, mone, z( n1p1 ), 1 )
           end if
           ! normalize z so that norm(z) = 1
           t = one / sqrt( two )
           do j = 1, n
              indx( j ) = j
           end do
           call stdlib_sscal( n, t, z, 1 )
           rho = abs( two*rho )
           ! sort the eigenvalues into increasing order
           do i = cutpnt + 1, n
              indxq( i ) = indxq( i ) + cutpnt
           end do
           do i = 1, n
              dlamda( i ) = d( indxq( i ) )
              w( i ) = z( indxq( i ) )
           end do
           i = 1
           j = cutpnt + 1
           call stdlib_slamrg( n1, n2, dlamda, 1, 1, indx )
           do i = 1, n
              d( i ) = dlamda( indx( i ) )
              z( i ) = w( indx( i ) )
           end do
           ! calculate the allowable deflation tolerance
           imax = stdlib_isamax( n, z, 1 )
           jmax = stdlib_isamax( n, d, 1 )
           eps = stdlib_slamch( 'EPSILON' )
           tol = eight*eps*abs( d( jmax ) )
           ! if the rank-1 modifier is small enough, no more needs to be done
           ! except to reorganize q so that its columns correspond with the
           ! elements in d.
           if( rho*abs( z( imax ) )<=tol ) then
              k = 0
              if( icompq==0 ) then
                 do j = 1, n
                    perm( j ) = indxq( indx( j ) )
                 end do
              else
                 do j = 1, n
                    perm( j ) = indxq( indx( j ) )
                    call stdlib_scopy( qsiz, q( 1, perm( j ) ), 1, q2( 1, j ), 1 )
                 end do
                 call stdlib_slacpy( 'A', qsiz, n, q2( 1, 1 ), ldq2, q( 1, 1 ),ldq )
              end if
              return
           end if
           ! if there are multiple eigenvalues then the problem deflates.  here
           ! the number of equal eigenvalues are found.  as each equal
           ! eigenvalue is found, an elementary reflector is computed to rotate
           ! the corresponding eigensubspace so that the corresponding
           ! components of z are zero in this new basis.
           k = 0
           k2 = n + 1
           do j = 1, n
              if( rho*abs( z( j ) )<=tol ) then
                 ! deflate due to small z component.
                 k2 = k2 - 1
                 indxp( k2 ) = j
                 if( j==n )go to 110
              else
                 jlam = j
                 go to 80
              end if
           end do
           80 continue
           j = j + 1
           if( j>n )go to 100
           if( rho*abs( z( j ) )<=tol ) then
              ! deflate due to small z component.
              k2 = k2 - 1
              indxp( k2 ) = j
           else
              ! check if eigenvalues are close enough to allow deflation.
              s = z( jlam )
              c = z( j )
              ! find sqrt(a**2+b**2) without overflow or
              ! destructive underflow.
              tau = stdlib_slapy2( c, s )
              t = d( j ) - d( jlam )
              c = c / tau
              s = -s / tau
              if( abs( t*c*s )<=tol ) then
                 ! deflation is possible.
                 z( j ) = tau
                 z( jlam ) = zero
                 ! record the appropriate givens rotation
                 givptr = givptr + 1
                 givcol( 1, givptr ) = indxq( indx( jlam ) )
                 givcol( 2, givptr ) = indxq( indx( j ) )
                 givnum( 1, givptr ) = c
                 givnum( 2, givptr ) = s
                 if( icompq==1 ) then
                    call stdlib_srot( qsiz, q( 1, indxq( indx( jlam ) ) ), 1,q( 1, indxq( indx( j &
                              ) ) ), 1, c, s )
                 end if
                 t = d( jlam )*c*c + d( j )*s*s
                 d( j ) = d( jlam )*s*s + d( j )*c*c
                 d( jlam ) = t
                 k2 = k2 - 1
                 i = 1
                 90 continue
                 if( k2+i<=n ) then
                    if( d( jlam )<d( indxp( k2+i ) ) ) then
                       indxp( k2+i-1 ) = indxp( k2+i )
                       indxp( k2+i ) = jlam
                       i = i + 1
                       go to 90
                    else
                       indxp( k2+i-1 ) = jlam
                    end if
                 else
                    indxp( k2+i-1 ) = jlam
                 end if
                 jlam = j
              else
                 k = k + 1
                 w( k ) = z( jlam )
                 dlamda( k ) = d( jlam )
                 indxp( k ) = jlam
                 jlam = j
              end if
           end if
           go to 80
           100 continue
           ! record the last eigenvalue.
           k = k + 1
           w( k ) = z( jlam )
           dlamda( k ) = d( jlam )
           indxp( k ) = jlam
           110 continue
           ! sort the eigenvalues and corresponding eigenvectors into dlamda
           ! and q2 respectively.  the eigenvalues/vectors which were not
           ! deflated go into the first k slots of dlamda and q2 respectively,
           ! while those which were deflated go into the last n - k slots.
           if( icompq==0 ) then
              do j = 1, n
                 jp = indxp( j )
                 dlamda( j ) = d( jp )
                 perm( j ) = indxq( indx( jp ) )
              end do
           else
              do j = 1, n
                 jp = indxp( j )
                 dlamda( j ) = d( jp )
                 perm( j ) = indxq( indx( jp ) )
                 call stdlib_scopy( qsiz, q( 1, perm( j ) ), 1, q2( 1, j ), 1 )
              end do
           end if
           ! the deflated eigenvalues and their corresponding vectors go back
           ! into the last n - k slots of d and q respectively.
           if( k<n ) then
              if( icompq==0 ) then
                 call stdlib_scopy( n-k, dlamda( k+1 ), 1, d( k+1 ), 1 )
              else
                 call stdlib_scopy( n-k, dlamda( k+1 ), 1, d( k+1 ), 1 )
                 call stdlib_slacpy( 'A', qsiz, n-k, q2( 1, k+1 ), ldq2,q( 1, k+1 ), ldq )
              end if
           end if
           return
     end subroutine stdlib_slaed8

     pure subroutine stdlib_dlaed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho,cutpnt, z, dlamda, &
     !! DLAED8 merges the two sets of eigenvalues together into a single
     !! sorted set.  Then it tries to deflate the size of the problem.
     !! There are two ways in which deflation can occur:  when two or more
     !! eigenvalues are close together or if there is a tiny element in the
     !! Z vector.  For each such occurrence the order of the related secular
     !! equation problem is reduced by one.
               q2, ldq2, w, perm, givptr,givcol, givnum, indxp, indx, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: cutpnt, icompq, ldq, ldq2, n, qsiz
           integer(ilp), intent(out) :: givptr, info, k
           real(dp), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(out) :: givcol(2,*), indx(*), indxp(*), perm(*)
           integer(ilp), intent(inout) :: indxq(*)
           real(dp), intent(inout) :: d(*), q(ldq,*), z(*)
           real(dp), intent(out) :: dlamda(*), givnum(2,*), q2(ldq2,*), w(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: mone = -1.0_dp
           
           ! Local Scalars 
           integer(ilp) :: i, imax, j, jlam, jmax, jp, k2, n1, n1p1, n2
           real(dp) :: c, eps, s, t, tau, tol
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( icompq<0 .or. icompq>1 ) then
              info = -1
           else if( n<0 ) then
              info = -3
           else if( icompq==1 .and. qsiz<n ) then
              info = -4
           else if( ldq<max( 1, n ) ) then
              info = -7
           else if( cutpnt<min( 1, n ) .or. cutpnt>n ) then
              info = -10
           else if( ldq2<max( 1, n ) ) then
              info = -14
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED8', -info )
              return
           end if
           ! need to initialize givptr to o here in case of quick exit
           ! to prevent an unspecified code behavior (usually sigfault)
           ! when iwork array on entry to *stedc is not zeroed
           ! (or at least some iwork entries which used in *laed7 for givptr).
           givptr = 0
           ! quick return if possible
           if( n==0 )return
           n1 = cutpnt
           n2 = n - n1
           n1p1 = n1 + 1
           if( rho<zero ) then
              call stdlib_dscal( n2, mone, z( n1p1 ), 1 )
           end if
           ! normalize z so that norm(z) = 1
           t = one / sqrt( two )
           do j = 1, n
              indx( j ) = j
           end do
           call stdlib_dscal( n, t, z, 1 )
           rho = abs( two*rho )
           ! sort the eigenvalues into increasing order
           do i = cutpnt + 1, n
              indxq( i ) = indxq( i ) + cutpnt
           end do
           do i = 1, n
              dlamda( i ) = d( indxq( i ) )
              w( i ) = z( indxq( i ) )
           end do
           i = 1
           j = cutpnt + 1
           call stdlib_dlamrg( n1, n2, dlamda, 1, 1, indx )
           do i = 1, n
              d( i ) = dlamda( indx( i ) )
              z( i ) = w( indx( i ) )
           end do
           ! calculate the allowable deflation tolerance
           imax = stdlib_idamax( n, z, 1 )
           jmax = stdlib_idamax( n, d, 1 )
           eps = stdlib_dlamch( 'EPSILON' )
           tol = eight*eps*abs( d( jmax ) )
           ! if the rank-1 modifier is small enough, no more needs to be done
           ! except to reorganize q so that its columns correspond with the
           ! elements in d.
           if( rho*abs( z( imax ) )<=tol ) then
              k = 0
              if( icompq==0 ) then
                 do j = 1, n
                    perm( j ) = indxq( indx( j ) )
                 end do
              else
                 do j = 1, n
                    perm( j ) = indxq( indx( j ) )
                    call stdlib_dcopy( qsiz, q( 1, perm( j ) ), 1, q2( 1, j ), 1 )
                 end do
                 call stdlib_dlacpy( 'A', qsiz, n, q2( 1, 1 ), ldq2, q( 1, 1 ),ldq )
              end if
              return
           end if
           ! if there are multiple eigenvalues then the problem deflates.  here
           ! the number of equal eigenvalues are found.  as each equal
           ! eigenvalue is found, an elementary reflector is computed to rotate
           ! the corresponding eigensubspace so that the corresponding
           ! components of z are zero in this new basis.
           k = 0
           k2 = n + 1
           do j = 1, n
              if( rho*abs( z( j ) )<=tol ) then
                 ! deflate due to small z component.
                 k2 = k2 - 1
                 indxp( k2 ) = j
                 if( j==n )go to 110
              else
                 jlam = j
                 go to 80
              end if
           end do
           80 continue
           j = j + 1
           if( j>n )go to 100
           if( rho*abs( z( j ) )<=tol ) then
              ! deflate due to small z component.
              k2 = k2 - 1
              indxp( k2 ) = j
           else
              ! check if eigenvalues are close enough to allow deflation.
              s = z( jlam )
              c = z( j )
              ! find sqrt(a**2+b**2) without overflow or
              ! destructive underflow.
              tau = stdlib_dlapy2( c, s )
              t = d( j ) - d( jlam )
              c = c / tau
              s = -s / tau
              if( abs( t*c*s )<=tol ) then
                 ! deflation is possible.
                 z( j ) = tau
                 z( jlam ) = zero
                 ! record the appropriate givens rotation
                 givptr = givptr + 1
                 givcol( 1, givptr ) = indxq( indx( jlam ) )
                 givcol( 2, givptr ) = indxq( indx( j ) )
                 givnum( 1, givptr ) = c
                 givnum( 2, givptr ) = s
                 if( icompq==1 ) then
                    call stdlib_drot( qsiz, q( 1, indxq( indx( jlam ) ) ), 1,q( 1, indxq( indx( j &
                              ) ) ), 1, c, s )
                 end if
                 t = d( jlam )*c*c + d( j )*s*s
                 d( j ) = d( jlam )*s*s + d( j )*c*c
                 d( jlam ) = t
                 k2 = k2 - 1
                 i = 1
                 90 continue
                 if( k2+i<=n ) then
                    if( d( jlam )<d( indxp( k2+i ) ) ) then
                       indxp( k2+i-1 ) = indxp( k2+i )
                       indxp( k2+i ) = jlam
                       i = i + 1
                       go to 90
                    else
                       indxp( k2+i-1 ) = jlam
                    end if
                 else
                    indxp( k2+i-1 ) = jlam
                 end if
                 jlam = j
              else
                 k = k + 1
                 w( k ) = z( jlam )
                 dlamda( k ) = d( jlam )
                 indxp( k ) = jlam
                 jlam = j
              end if
           end if
           go to 80
           100 continue
           ! record the last eigenvalue.
           k = k + 1
           w( k ) = z( jlam )
           dlamda( k ) = d( jlam )
           indxp( k ) = jlam
           110 continue
           ! sort the eigenvalues and corresponding eigenvectors into dlamda
           ! and q2 respectively.  the eigenvalues/vectors which were not
           ! deflated go into the first k slots of dlamda and q2 respectively,
           ! while those which were deflated go into the last n - k slots.
           if( icompq==0 ) then
              do j = 1, n
                 jp = indxp( j )
                 dlamda( j ) = d( jp )
                 perm( j ) = indxq( indx( jp ) )
              end do
           else
              do j = 1, n
                 jp = indxp( j )
                 dlamda( j ) = d( jp )
                 perm( j ) = indxq( indx( jp ) )
                 call stdlib_dcopy( qsiz, q( 1, perm( j ) ), 1, q2( 1, j ), 1 )
              end do
           end if
           ! the deflated eigenvalues and their corresponding vectors go back
           ! into the last n - k slots of d and q respectively.
           if( k<n ) then
              if( icompq==0 ) then
                 call stdlib_dcopy( n-k, dlamda( k+1 ), 1, d( k+1 ), 1 )
              else
                 call stdlib_dcopy( n-k, dlamda( k+1 ), 1, d( k+1 ), 1 )
                 call stdlib_dlacpy( 'A', qsiz, n-k, q2( 1, k+1 ), ldq2,q( 1, k+1 ), ldq )
              end if
           end if
           return
     end subroutine stdlib_dlaed8

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho,cutpnt, z, dlamda, &
     !! DLAED8: merges the two sets of eigenvalues together into a single
     !! sorted set.  Then it tries to deflate the size of the problem.
     !! There are two ways in which deflation can occur:  when two or more
     !! eigenvalues are close together or if there is a tiny element in the
     !! Z vector.  For each such occurrence the order of the related secular
     !! equation problem is reduced by one.
               q2, ldq2, w, perm, givptr,givcol, givnum, indxp, indx, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: cutpnt, icompq, ldq, ldq2, n, qsiz
           integer(ilp), intent(out) :: givptr, info, k
           real(${rk}$), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(out) :: givcol(2,*), indx(*), indxp(*), perm(*)
           integer(ilp), intent(inout) :: indxq(*)
           real(${rk}$), intent(inout) :: d(*), q(ldq,*), z(*)
           real(${rk}$), intent(out) :: dlamda(*), givnum(2,*), q2(ldq2,*), w(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: mone = -1.0_${rk}$
           
           ! Local Scalars 
           integer(ilp) :: i, imax, j, jlam, jmax, jp, k2, n1, n1p1, n2
           real(${rk}$) :: c, eps, s, t, tau, tol
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( icompq<0 .or. icompq>1 ) then
              info = -1
           else if( n<0 ) then
              info = -3
           else if( icompq==1 .and. qsiz<n ) then
              info = -4
           else if( ldq<max( 1, n ) ) then
              info = -7
           else if( cutpnt<min( 1, n ) .or. cutpnt>n ) then
              info = -10
           else if( ldq2<max( 1, n ) ) then
              info = -14
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED8', -info )
              return
           end if
           ! need to initialize givptr to o here in case of quick exit
           ! to prevent an unspecified code behavior (usually sigfault)
           ! when iwork array on entry to *stedc is not zeroed
           ! (or at least some iwork entries which used in *laed7 for givptr).
           givptr = 0
           ! quick return if possible
           if( n==0 )return
           n1 = cutpnt
           n2 = n - n1
           n1p1 = n1 + 1
           if( rho<zero ) then
              call stdlib_${ri}$scal( n2, mone, z( n1p1 ), 1 )
           end if
           ! normalize z so that norm(z) = 1
           t = one / sqrt( two )
           do j = 1, n
              indx( j ) = j
           end do
           call stdlib_${ri}$scal( n, t, z, 1 )
           rho = abs( two*rho )
           ! sort the eigenvalues into increasing order
           do i = cutpnt + 1, n
              indxq( i ) = indxq( i ) + cutpnt
           end do
           do i = 1, n
              dlamda( i ) = d( indxq( i ) )
              w( i ) = z( indxq( i ) )
           end do
           i = 1
           j = cutpnt + 1
           call stdlib_${ri}$lamrg( n1, n2, dlamda, 1, 1, indx )
           do i = 1, n
              d( i ) = dlamda( indx( i ) )
              z( i ) = w( indx( i ) )
           end do
           ! calculate the allowable deflation tolerance
           imax = stdlib_i${ri}$amax( n, z, 1 )
           jmax = stdlib_i${ri}$amax( n, d, 1 )
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           tol = eight*eps*abs( d( jmax ) )
           ! if the rank-1 modifier is small enough, no more needs to be done
           ! except to reorganize q so that its columns correspond with the
           ! elements in d.
           if( rho*abs( z( imax ) )<=tol ) then
              k = 0
              if( icompq==0 ) then
                 do j = 1, n
                    perm( j ) = indxq( indx( j ) )
                 end do
              else
                 do j = 1, n
                    perm( j ) = indxq( indx( j ) )
                    call stdlib_${ri}$copy( qsiz, q( 1, perm( j ) ), 1, q2( 1, j ), 1 )
                 end do
                 call stdlib_${ri}$lacpy( 'A', qsiz, n, q2( 1, 1 ), ldq2, q( 1, 1 ),ldq )
              end if
              return
           end if
           ! if there are multiple eigenvalues then the problem deflates.  here
           ! the number of equal eigenvalues are found.  as each equal
           ! eigenvalue is found, an elementary reflector is computed to rotate
           ! the corresponding eigensubspace so that the corresponding
           ! components of z are zero in this new basis.
           k = 0
           k2 = n + 1
           do j = 1, n
              if( rho*abs( z( j ) )<=tol ) then
                 ! deflate due to small z component.
                 k2 = k2 - 1
                 indxp( k2 ) = j
                 if( j==n )go to 110
              else
                 jlam = j
                 go to 80
              end if
           end do
           80 continue
           j = j + 1
           if( j>n )go to 100
           if( rho*abs( z( j ) )<=tol ) then
              ! deflate due to small z component.
              k2 = k2 - 1
              indxp( k2 ) = j
           else
              ! check if eigenvalues are close enough to allow deflation.
              s = z( jlam )
              c = z( j )
              ! find sqrt(a**2+b**2) without overflow or
              ! destructive underflow.
              tau = stdlib_${ri}$lapy2( c, s )
              t = d( j ) - d( jlam )
              c = c / tau
              s = -s / tau
              if( abs( t*c*s )<=tol ) then
                 ! deflation is possible.
                 z( j ) = tau
                 z( jlam ) = zero
                 ! record the appropriate givens rotation
                 givptr = givptr + 1
                 givcol( 1, givptr ) = indxq( indx( jlam ) )
                 givcol( 2, givptr ) = indxq( indx( j ) )
                 givnum( 1, givptr ) = c
                 givnum( 2, givptr ) = s
                 if( icompq==1 ) then
                    call stdlib_${ri}$rot( qsiz, q( 1, indxq( indx( jlam ) ) ), 1,q( 1, indxq( indx( j &
                              ) ) ), 1, c, s )
                 end if
                 t = d( jlam )*c*c + d( j )*s*s
                 d( j ) = d( jlam )*s*s + d( j )*c*c
                 d( jlam ) = t
                 k2 = k2 - 1
                 i = 1
                 90 continue
                 if( k2+i<=n ) then
                    if( d( jlam )<d( indxp( k2+i ) ) ) then
                       indxp( k2+i-1 ) = indxp( k2+i )
                       indxp( k2+i ) = jlam
                       i = i + 1
                       go to 90
                    else
                       indxp( k2+i-1 ) = jlam
                    end if
                 else
                    indxp( k2+i-1 ) = jlam
                 end if
                 jlam = j
              else
                 k = k + 1
                 w( k ) = z( jlam )
                 dlamda( k ) = d( jlam )
                 indxp( k ) = jlam
                 jlam = j
              end if
           end if
           go to 80
           100 continue
           ! record the last eigenvalue.
           k = k + 1
           w( k ) = z( jlam )
           dlamda( k ) = d( jlam )
           indxp( k ) = jlam
           110 continue
           ! sort the eigenvalues and corresponding eigenvectors into dlamda
           ! and q2 respectively.  the eigenvalues/vectors which were not
           ! deflated go into the first k slots of dlamda and q2 respectively,
           ! while those which were deflated go into the last n - k slots.
           if( icompq==0 ) then
              do j = 1, n
                 jp = indxp( j )
                 dlamda( j ) = d( jp )
                 perm( j ) = indxq( indx( jp ) )
              end do
           else
              do j = 1, n
                 jp = indxp( j )
                 dlamda( j ) = d( jp )
                 perm( j ) = indxq( indx( jp ) )
                 call stdlib_${ri}$copy( qsiz, q( 1, perm( j ) ), 1, q2( 1, j ), 1 )
              end do
           end if
           ! the deflated eigenvalues and their corresponding vectors go back
           ! into the last n - k slots of d and q respectively.
           if( k<n ) then
              if( icompq==0 ) then
                 call stdlib_${ri}$copy( n-k, dlamda( k+1 ), 1, d( k+1 ), 1 )
              else
                 call stdlib_${ri}$copy( n-k, dlamda( k+1 ), 1, d( k+1 ), 1 )
                 call stdlib_${ri}$lacpy( 'A', qsiz, n-k, q2( 1, k+1 ), ldq2,q( 1, k+1 ), ldq )
              end if
           end if
           return
     end subroutine stdlib_${ri}$laed8

#:endif
#:endfor

     pure subroutine stdlib_claed8( k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda,q2, ldq2, w, &
     !! CLAED8 merges the two sets of eigenvalues together into a single
     !! sorted set.  Then it tries to deflate the size of the problem.
     !! There are two ways in which deflation can occur:  when two or more
     !! eigenvalues are close together or if there is a tiny element in the
     !! Z vector.  For each such occurrence the order of the related secular
     !! equation problem is reduced by one.
               indxp, indx, indxq, perm, givptr,givcol, givnum, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: cutpnt, ldq, ldq2, n, qsiz
           integer(ilp), intent(out) :: givptr, info, k
           real(sp), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(out) :: givcol(2,*), indx(*), indxp(*), perm(*)
           integer(ilp), intent(inout) :: indxq(*)
           real(sp), intent(inout) :: d(*), z(*)
           real(sp), intent(out) :: dlamda(*), givnum(2,*), w(*)
           complex(sp), intent(inout) :: q(ldq,*)
           complex(sp), intent(out) :: q2(ldq2,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: mone = -1.0_sp
           
           ! Local Scalars 
           integer(ilp) :: i, imax, j, jlam, jmax, jp, k2, n1, n1p1, n2
           real(sp) :: c, eps, s, t, tau, tol
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -2
           else if( qsiz<n ) then
              info = -3
           else if( ldq<max( 1, n ) ) then
              info = -5
           else if( cutpnt<min( 1, n ) .or. cutpnt>n ) then
              info = -8
           else if( ldq2<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAED8', -info )
              return
           end if
           ! need to initialize givptr to o here in case of quick exit
           ! to prevent an unspecified code behavior (usually sigfault)
           ! when iwork array on entry to *stedc is not zeroed
           ! (or at least some iwork entries which used in *laed7 for givptr).
           givptr = 0
           ! quick return if possible
           if( n==0 )return
           n1 = cutpnt
           n2 = n - n1
           n1p1 = n1 + 1
           if( rho<zero ) then
              call stdlib_sscal( n2, mone, z( n1p1 ), 1 )
           end if
           ! normalize z so that norm(z) = 1
           t = one / sqrt( two )
           do j = 1, n
              indx( j ) = j
           end do
           call stdlib_sscal( n, t, z, 1 )
           rho = abs( two*rho )
           ! sort the eigenvalues into increasing order
           do i = cutpnt + 1, n
              indxq( i ) = indxq( i ) + cutpnt
           end do
           do i = 1, n
              dlamda( i ) = d( indxq( i ) )
              w( i ) = z( indxq( i ) )
           end do
           i = 1
           j = cutpnt + 1
           call stdlib_slamrg( n1, n2, dlamda, 1, 1, indx )
           do i = 1, n
              d( i ) = dlamda( indx( i ) )
              z( i ) = w( indx( i ) )
           end do
           ! calculate the allowable deflation tolerance
           imax = stdlib_isamax( n, z, 1 )
           jmax = stdlib_isamax( n, d, 1 )
           eps = stdlib_slamch( 'EPSILON' )
           tol = eight*eps*abs( d( jmax ) )
           ! if the rank-1 modifier is small enough, no more needs to be done
           ! -- except to reorganize q so that its columns correspond with the
           ! elements in d.
           if( rho*abs( z( imax ) )<=tol ) then
              k = 0
              do j = 1, n
                 perm( j ) = indxq( indx( j ) )
                 call stdlib_ccopy( qsiz, q( 1, perm( j ) ), 1, q2( 1, j ), 1 )
              end do
              call stdlib_clacpy( 'A', qsiz, n, q2( 1, 1 ), ldq2, q( 1, 1 ), ldq )
              return
           end if
           ! if there are multiple eigenvalues then the problem deflates.  here
           ! the number of equal eigenvalues are found.  as each equal
           ! eigenvalue is found, an elementary reflector is computed to rotate
           ! the corresponding eigensubspace so that the corresponding
           ! components of z are zero in this new basis.
           k = 0
           k2 = n + 1
           do j = 1, n
              if( rho*abs( z( j ) )<=tol ) then
                 ! deflate due to small z component.
                 k2 = k2 - 1
                 indxp( k2 ) = j
                 if( j==n )go to 100
              else
                 jlam = j
                 go to 70
              end if
           end do
           70 continue
           j = j + 1
           if( j>n )go to 90
           if( rho*abs( z( j ) )<=tol ) then
              ! deflate due to small z component.
              k2 = k2 - 1
              indxp( k2 ) = j
           else
              ! check if eigenvalues are close enough to allow deflation.
              s = z( jlam )
              c = z( j )
              ! find sqrt(a**2+b**2) without overflow or
              ! destructive underflow.
              tau = stdlib_slapy2( c, s )
              t = d( j ) - d( jlam )
              c = c / tau
              s = -s / tau
              if( abs( t*c*s )<=tol ) then
                 ! deflation is possible.
                 z( j ) = tau
                 z( jlam ) = zero
                 ! record the appropriate givens rotation
                 givptr = givptr + 1
                 givcol( 1, givptr ) = indxq( indx( jlam ) )
                 givcol( 2, givptr ) = indxq( indx( j ) )
                 givnum( 1, givptr ) = c
                 givnum( 2, givptr ) = s
                 call stdlib_csrot( qsiz, q( 1, indxq( indx( jlam ) ) ), 1,q( 1, indxq( indx( j ) &
                           ) ), 1, c, s )
                 t = d( jlam )*c*c + d( j )*s*s
                 d( j ) = d( jlam )*s*s + d( j )*c*c
                 d( jlam ) = t
                 k2 = k2 - 1
                 i = 1
                 80 continue
                 if( k2+i<=n ) then
                    if( d( jlam )<d( indxp( k2+i ) ) ) then
                       indxp( k2+i-1 ) = indxp( k2+i )
                       indxp( k2+i ) = jlam
                       i = i + 1
                       go to 80
                    else
                       indxp( k2+i-1 ) = jlam
                    end if
                 else
                    indxp( k2+i-1 ) = jlam
                 end if
                 jlam = j
              else
                 k = k + 1
                 w( k ) = z( jlam )
                 dlamda( k ) = d( jlam )
                 indxp( k ) = jlam
                 jlam = j
              end if
           end if
           go to 70
           90 continue
           ! record the last eigenvalue.
           k = k + 1
           w( k ) = z( jlam )
           dlamda( k ) = d( jlam )
           indxp( k ) = jlam
           100 continue
           ! sort the eigenvalues and corresponding eigenvectors into dlamda
           ! and q2 respectively.  the eigenvalues/vectors which were not
           ! deflated go into the first k slots of dlamda and q2 respectively,
           ! while those which were deflated go into the last n - k slots.
           do j = 1, n
              jp = indxp( j )
              dlamda( j ) = d( jp )
              perm( j ) = indxq( indx( jp ) )
              call stdlib_ccopy( qsiz, q( 1, perm( j ) ), 1, q2( 1, j ), 1 )
           end do
           ! the deflated eigenvalues and their corresponding vectors go back
           ! into the last n - k slots of d and q respectively.
           if( k<n ) then
              call stdlib_scopy( n-k, dlamda( k+1 ), 1, d( k+1 ), 1 )
              call stdlib_clacpy( 'A', qsiz, n-k, q2( 1, k+1 ), ldq2, q( 1, k+1 ),ldq )
           end if
           return
     end subroutine stdlib_claed8

     pure subroutine stdlib_zlaed8( k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda,q2, ldq2, w, &
     !! ZLAED8 merges the two sets of eigenvalues together into a single
     !! sorted set.  Then it tries to deflate the size of the problem.
     !! There are two ways in which deflation can occur:  when two or more
     !! eigenvalues are close together or if there is a tiny element in the
     !! Z vector.  For each such occurrence the order of the related secular
     !! equation problem is reduced by one.
               indxp, indx, indxq, perm, givptr,givcol, givnum, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: cutpnt, ldq, ldq2, n, qsiz
           integer(ilp), intent(out) :: givptr, info, k
           real(dp), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(out) :: givcol(2,*), indx(*), indxp(*), perm(*)
           integer(ilp), intent(inout) :: indxq(*)
           real(dp), intent(inout) :: d(*), z(*)
           real(dp), intent(out) :: dlamda(*), givnum(2,*), w(*)
           complex(dp), intent(inout) :: q(ldq,*)
           complex(dp), intent(out) :: q2(ldq2,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: mone = -1.0_dp
           
           ! Local Scalars 
           integer(ilp) :: i, imax, j, jlam, jmax, jp, k2, n1, n1p1, n2
           real(dp) :: c, eps, s, t, tau, tol
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -2
           else if( qsiz<n ) then
              info = -3
           else if( ldq<max( 1, n ) ) then
              info = -5
           else if( cutpnt<min( 1, n ) .or. cutpnt>n ) then
              info = -8
           else if( ldq2<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZLAED8', -info )
              return
           end if
           ! need to initialize givptr to o here in case of quick exit
           ! to prevent an unspecified code behavior (usually sigfault)
           ! when iwork array on entry to *stedc is not zeroed
           ! (or at least some iwork entries which used in *laed7 for givptr).
           givptr = 0
           ! quick return if possible
           if( n==0 )return
           n1 = cutpnt
           n2 = n - n1
           n1p1 = n1 + 1
           if( rho<zero ) then
              call stdlib_dscal( n2, mone, z( n1p1 ), 1 )
           end if
           ! normalize z so that norm(z) = 1
           t = one / sqrt( two )
           do j = 1, n
              indx( j ) = j
           end do
           call stdlib_dscal( n, t, z, 1 )
           rho = abs( two*rho )
           ! sort the eigenvalues into increasing order
           do i = cutpnt + 1, n
              indxq( i ) = indxq( i ) + cutpnt
           end do
           do i = 1, n
              dlamda( i ) = d( indxq( i ) )
              w( i ) = z( indxq( i ) )
           end do
           i = 1
           j = cutpnt + 1
           call stdlib_dlamrg( n1, n2, dlamda, 1, 1, indx )
           do i = 1, n
              d( i ) = dlamda( indx( i ) )
              z( i ) = w( indx( i ) )
           end do
           ! calculate the allowable deflation tolerance
           imax = stdlib_idamax( n, z, 1 )
           jmax = stdlib_idamax( n, d, 1 )
           eps = stdlib_dlamch( 'EPSILON' )
           tol = eight*eps*abs( d( jmax ) )
           ! if the rank-1 modifier is small enough, no more needs to be done
           ! -- except to reorganize q so that its columns correspond with the
           ! elements in d.
           if( rho*abs( z( imax ) )<=tol ) then
              k = 0
              do j = 1, n
                 perm( j ) = indxq( indx( j ) )
                 call stdlib_zcopy( qsiz, q( 1, perm( j ) ), 1, q2( 1, j ), 1 )
              end do
              call stdlib_zlacpy( 'A', qsiz, n, q2( 1, 1 ), ldq2, q( 1, 1 ), ldq )
              return
           end if
           ! if there are multiple eigenvalues then the problem deflates.  here
           ! the number of equal eigenvalues are found.  as each equal
           ! eigenvalue is found, an elementary reflector is computed to rotate
           ! the corresponding eigensubspace so that the corresponding
           ! components of z are zero in this new basis.
           k = 0
           k2 = n + 1
           do j = 1, n
              if( rho*abs( z( j ) )<=tol ) then
                 ! deflate due to small z component.
                 k2 = k2 - 1
                 indxp( k2 ) = j
                 if( j==n )go to 100
              else
                 jlam = j
                 go to 70
              end if
           end do
           70 continue
           j = j + 1
           if( j>n )go to 90
           if( rho*abs( z( j ) )<=tol ) then
              ! deflate due to small z component.
              k2 = k2 - 1
              indxp( k2 ) = j
           else
              ! check if eigenvalues are close enough to allow deflation.
              s = z( jlam )
              c = z( j )
              ! find sqrt(a**2+b**2) without overflow or
              ! destructive underflow.
              tau = stdlib_dlapy2( c, s )
              t = d( j ) - d( jlam )
              c = c / tau
              s = -s / tau
              if( abs( t*c*s )<=tol ) then
                 ! deflation is possible.
                 z( j ) = tau
                 z( jlam ) = zero
                 ! record the appropriate givens rotation
                 givptr = givptr + 1
                 givcol( 1, givptr ) = indxq( indx( jlam ) )
                 givcol( 2, givptr ) = indxq( indx( j ) )
                 givnum( 1, givptr ) = c
                 givnum( 2, givptr ) = s
                 call stdlib_zdrot( qsiz, q( 1, indxq( indx( jlam ) ) ), 1,q( 1, indxq( indx( j ) &
                           ) ), 1, c, s )
                 t = d( jlam )*c*c + d( j )*s*s
                 d( j ) = d( jlam )*s*s + d( j )*c*c
                 d( jlam ) = t
                 k2 = k2 - 1
                 i = 1
                 80 continue
                 if( k2+i<=n ) then
                    if( d( jlam )<d( indxp( k2+i ) ) ) then
                       indxp( k2+i-1 ) = indxp( k2+i )
                       indxp( k2+i ) = jlam
                       i = i + 1
                       go to 80
                    else
                       indxp( k2+i-1 ) = jlam
                    end if
                 else
                    indxp( k2+i-1 ) = jlam
                 end if
                 jlam = j
              else
                 k = k + 1
                 w( k ) = z( jlam )
                 dlamda( k ) = d( jlam )
                 indxp( k ) = jlam
                 jlam = j
              end if
           end if
           go to 70
           90 continue
           ! record the last eigenvalue.
           k = k + 1
           w( k ) = z( jlam )
           dlamda( k ) = d( jlam )
           indxp( k ) = jlam
           100 continue
           ! sort the eigenvalues and corresponding eigenvectors into dlamda
           ! and q2 respectively.  the eigenvalues/vectors which were not
           ! deflated go into the first k slots of dlamda and q2 respectively,
           ! while those which were deflated go into the last n - k slots.
           do j = 1, n
              jp = indxp( j )
              dlamda( j ) = d( jp )
              perm( j ) = indxq( indx( jp ) )
              call stdlib_zcopy( qsiz, q( 1, perm( j ) ), 1, q2( 1, j ), 1 )
           end do
           ! the deflated eigenvalues and their corresponding vectors go back
           ! into the last n - k slots of d and q respectively.
           if( k<n ) then
              call stdlib_dcopy( n-k, dlamda( k+1 ), 1, d( k+1 ), 1 )
              call stdlib_zlacpy( 'A', qsiz, n-k, q2( 1, k+1 ), ldq2, q( 1, k+1 ),ldq )
           end if
           return
     end subroutine stdlib_zlaed8

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$laed8( k, n, qsiz, q, ldq, d, rho, cutpnt, z, dlamda,q2, ldq2, w, &
     !! ZLAED8: merges the two sets of eigenvalues together into a single
     !! sorted set.  Then it tries to deflate the size of the problem.
     !! There are two ways in which deflation can occur:  when two or more
     !! eigenvalues are close together or if there is a tiny element in the
     !! Z vector.  For each such occurrence the order of the related secular
     !! equation problem is reduced by one.
               indxp, indx, indxq, perm, givptr,givcol, givnum, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: cutpnt, ldq, ldq2, n, qsiz
           integer(ilp), intent(out) :: givptr, info, k
           real(${ck}$), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(out) :: givcol(2,*), indx(*), indxp(*), perm(*)
           integer(ilp), intent(inout) :: indxq(*)
           real(${ck}$), intent(inout) :: d(*), z(*)
           real(${ck}$), intent(out) :: dlamda(*), givnum(2,*), w(*)
           complex(${ck}$), intent(inout) :: q(ldq,*)
           complex(${ck}$), intent(out) :: q2(ldq2,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: mone = -1.0_${ck}$
           
           ! Local Scalars 
           integer(ilp) :: i, imax, j, jlam, jmax, jp, k2, n1, n1p1, n2
           real(${ck}$) :: c, eps, s, t, tau, tol
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -2
           else if( qsiz<n ) then
              info = -3
           else if( ldq<max( 1, n ) ) then
              info = -5
           else if( cutpnt<min( 1, n ) .or. cutpnt>n ) then
              info = -8
           else if( ldq2<max( 1, n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZLAED8', -info )
              return
           end if
           ! need to initialize givptr to o here in case of quick exit
           ! to prevent an unspecified code behavior (usually sigfault)
           ! when iwork array on entry to *stedc is not zeroed
           ! (or at least some iwork entries which used in *laed7 for givptr).
           givptr = 0
           ! quick return if possible
           if( n==0 )return
           n1 = cutpnt
           n2 = n - n1
           n1p1 = n1 + 1
           if( rho<zero ) then
              call stdlib_${c2ri(ci)}$scal( n2, mone, z( n1p1 ), 1 )
           end if
           ! normalize z so that norm(z) = 1
           t = one / sqrt( two )
           do j = 1, n
              indx( j ) = j
           end do
           call stdlib_${c2ri(ci)}$scal( n, t, z, 1 )
           rho = abs( two*rho )
           ! sort the eigenvalues into increasing order
           do i = cutpnt + 1, n
              indxq( i ) = indxq( i ) + cutpnt
           end do
           do i = 1, n
              dlamda( i ) = d( indxq( i ) )
              w( i ) = z( indxq( i ) )
           end do
           i = 1
           j = cutpnt + 1
           call stdlib_${c2ri(ci)}$lamrg( n1, n2, dlamda, 1, 1, indx )
           do i = 1, n
              d( i ) = dlamda( indx( i ) )
              z( i ) = w( indx( i ) )
           end do
           ! calculate the allowable deflation tolerance
           imax = stdlib_i${c2ri(ci)}$amax( n, z, 1 )
           jmax = stdlib_i${c2ri(ci)}$amax( n, d, 1 )
           eps = stdlib_${c2ri(ci)}$lamch( 'EPSILON' )
           tol = eight*eps*abs( d( jmax ) )
           ! if the rank-1 modifier is small enough, no more needs to be done
           ! -- except to reorganize q so that its columns correspond with the
           ! elements in d.
           if( rho*abs( z( imax ) )<=tol ) then
              k = 0
              do j = 1, n
                 perm( j ) = indxq( indx( j ) )
                 call stdlib_${ci}$copy( qsiz, q( 1, perm( j ) ), 1, q2( 1, j ), 1 )
              end do
              call stdlib_${ci}$lacpy( 'A', qsiz, n, q2( 1, 1 ), ldq2, q( 1, 1 ), ldq )
              return
           end if
           ! if there are multiple eigenvalues then the problem deflates.  here
           ! the number of equal eigenvalues are found.  as each equal
           ! eigenvalue is found, an elementary reflector is computed to rotate
           ! the corresponding eigensubspace so that the corresponding
           ! components of z are zero in this new basis.
           k = 0
           k2 = n + 1
           do j = 1, n
              if( rho*abs( z( j ) )<=tol ) then
                 ! deflate due to small z component.
                 k2 = k2 - 1
                 indxp( k2 ) = j
                 if( j==n )go to 100
              else
                 jlam = j
                 go to 70
              end if
           end do
           70 continue
           j = j + 1
           if( j>n )go to 90
           if( rho*abs( z( j ) )<=tol ) then
              ! deflate due to small z component.
              k2 = k2 - 1
              indxp( k2 ) = j
           else
              ! check if eigenvalues are close enough to allow deflation.
              s = z( jlam )
              c = z( j )
              ! find sqrt(a**2+b**2) without overflow or
              ! destructive underflow.
              tau = stdlib_${c2ri(ci)}$lapy2( c, s )
              t = d( j ) - d( jlam )
              c = c / tau
              s = -s / tau
              if( abs( t*c*s )<=tol ) then
                 ! deflation is possible.
                 z( j ) = tau
                 z( jlam ) = zero
                 ! record the appropriate givens rotation
                 givptr = givptr + 1
                 givcol( 1, givptr ) = indxq( indx( jlam ) )
                 givcol( 2, givptr ) = indxq( indx( j ) )
                 givnum( 1, givptr ) = c
                 givnum( 2, givptr ) = s
                 call stdlib_${ci}$drot( qsiz, q( 1, indxq( indx( jlam ) ) ), 1,q( 1, indxq( indx( j ) &
                           ) ), 1, c, s )
                 t = d( jlam )*c*c + d( j )*s*s
                 d( j ) = d( jlam )*s*s + d( j )*c*c
                 d( jlam ) = t
                 k2 = k2 - 1
                 i = 1
                 80 continue
                 if( k2+i<=n ) then
                    if( d( jlam )<d( indxp( k2+i ) ) ) then
                       indxp( k2+i-1 ) = indxp( k2+i )
                       indxp( k2+i ) = jlam
                       i = i + 1
                       go to 80
                    else
                       indxp( k2+i-1 ) = jlam
                    end if
                 else
                    indxp( k2+i-1 ) = jlam
                 end if
                 jlam = j
              else
                 k = k + 1
                 w( k ) = z( jlam )
                 dlamda( k ) = d( jlam )
                 indxp( k ) = jlam
                 jlam = j
              end if
           end if
           go to 70
           90 continue
           ! record the last eigenvalue.
           k = k + 1
           w( k ) = z( jlam )
           dlamda( k ) = d( jlam )
           indxp( k ) = jlam
           100 continue
           ! sort the eigenvalues and corresponding eigenvectors into dlamda
           ! and q2 respectively.  the eigenvalues/vectors which were not
           ! deflated go into the first k slots of dlamda and q2 respectively,
           ! while those which were deflated go into the last n - k slots.
           do j = 1, n
              jp = indxp( j )
              dlamda( j ) = d( jp )
              perm( j ) = indxq( indx( jp ) )
              call stdlib_${ci}$copy( qsiz, q( 1, perm( j ) ), 1, q2( 1, j ), 1 )
           end do
           ! the deflated eigenvalues and their corresponding vectors go back
           ! into the last n - k slots of d and q respectively.
           if( k<n ) then
              call stdlib_${c2ri(ci)}$copy( n-k, dlamda( k+1 ), 1, d( k+1 ), 1 )
              call stdlib_${ci}$lacpy( 'A', qsiz, n-k, q2( 1, k+1 ), ldq2, q( 1, k+1 ),ldq )
           end if
           return
     end subroutine stdlib_${ci}$laed8

#:endif
#:endfor













     pure subroutine stdlib_slaebz( ijob, nitmax, n, mmax, minp, nbmin, abstol,reltol, pivmin, d, &
     e, e2, nval, ab, c, mout,nab, work, iwork, info )
     !! SLAEBZ contains the iteration loops which compute and use the
     !! function N(w), which is the count of eigenvalues of a symmetric
     !! tridiagonal matrix T less than or equal to its argument  w.  It
     !! performs a choice of two types of loops:
     !! IJOB=1, followed by
     !! IJOB=2: It takes as input a list of intervals and returns a list of
     !! sufficiently small intervals whose union contains the same
     !! eigenvalues as the union of the original intervals.
     !! The input intervals are (AB(j,1),AB(j,2)], j=1,...,MINP.
     !! The output interval (AB(j,1),AB(j,2)] will contain
     !! eigenvalues NAB(j,1)+1,...,NAB(j,2), where 1 <= j <= MOUT.
     !! IJOB=3: It performs a binary search in each input interval
     !! (AB(j,1),AB(j,2)] for a point  w(j)  such that
     !! N(w(j))=NVAL(j), and uses  C(j)  as the starting point of
     !! the search.  If such a w(j) is found, then on output
     !! AB(j,1)=AB(j,2)=w.  If no such w(j) is found, then on output
     !! (AB(j,1),AB(j,2)] will be a small interval containing the
     !! point where N(w) jumps through NVAL(j), unless that point
     !! lies outside the initial interval.
     !! Note that the intervals are in all cases half-open intervals,
     !! i.e., of the form  (a,b] , which includes  b  but not  a .
     !! To avoid underflow, the matrix should be scaled so that its largest
     !! element is no greater than  overflow**(1/2) * underflow**(1/4)
     !! in absolute value.  To assure the most accurate computation
     !! of small eigenvalues, the matrix should be scaled to be
     !! not much smaller than that, either.
     !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
     !! Matrix", Report CS41, Computer Science Dept., Stanford
     !! University, July 21, 1966
     !! Note: the arguments are, in general, *not* checked for unreasonable
     !! values.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ijob, minp, mmax, n, nbmin, nitmax
           integer(ilp), intent(out) :: info, mout
           real(sp), intent(in) :: abstol, pivmin, reltol
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           integer(ilp), intent(inout) :: nab(mmax,*), nval(*)
           real(sp), intent(inout) :: ab(mmax,*), c(*)
           real(sp), intent(in) :: d(*), e(*), e2(*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: itmp1, itmp2, j, ji, jit, jp, kf, kfnew, kl, klnew
           real(sp) :: tmp1, tmp2
           ! Intrinsic Functions 
           ! Executable Statements 
           ! check for errors
           info = 0
           if( ijob<1 .or. ijob>3 ) then
              info = -1
              return
           end if
           ! initialize nab
           if( ijob==1 ) then
              ! compute the number of eigenvalues in the initial intervals.
              mout = 0
              do ji = 1, minp
                 do jp = 1, 2
                    tmp1 = d( 1 ) - ab( ji, jp )
                    if( abs( tmp1 )<pivmin )tmp1 = -pivmin
                    nab( ji, jp ) = 0
                    if( tmp1<=zero )nab( ji, jp ) = 1
                    do j = 2, n
                       tmp1 = d( j ) - e2( j-1 ) / tmp1 - ab( ji, jp )
                       if( abs( tmp1 )<pivmin )tmp1 = -pivmin
                       if( tmp1<=zero )nab( ji, jp ) = nab( ji, jp ) + 1
                    end do
                 end do
                 mout = mout + nab( ji, 2 ) - nab( ji, 1 )
              end do
              return
           end if
           ! initialize for loop
           ! kf and kl have the following meaning:
              ! intervals 1,...,kf-1 have converged.
              ! intervals kf,...,kl  still need to be refined.
           kf = 1
           kl = minp
           ! if ijob=2, initialize c.
           ! if ijob=3, use the user-supplied starting point.
           if( ijob==2 ) then
              do ji = 1, minp
                 c( ji ) = half*( ab( ji, 1 )+ab( ji, 2 ) )
              end do
           end if
           ! iteration loop
           loop_130: do jit = 1, nitmax
              ! loop over intervals
              if( kl-kf+1>=nbmin .and. nbmin>0 ) then
                 ! begin of parallel version of the loop
                 do ji = kf, kl
                    ! compute n(c), the number of eigenvalues less than c
                    work( ji ) = d( 1 ) - c( ji )
                    iwork( ji ) = 0
                    if( work( ji )<=pivmin ) then
                       iwork( ji ) = 1
                       work( ji ) = min( work( ji ), -pivmin )
                    end if
                    do j = 2, n
                       work( ji ) = d( j ) - e2( j-1 ) / work( ji ) - c( ji )
                       if( work( ji )<=pivmin ) then
                          iwork( ji ) = iwork( ji ) + 1
                          work( ji ) = min( work( ji ), -pivmin )
                       end if
                    end do
                 end do
                 if( ijob<=2 ) then
                    ! ijob=2: choose all intervals containing eigenvalues.
                    klnew = kl
                    loop_70: do ji = kf, kl
                       ! insure that n(w) is monotone
                       iwork( ji ) = min( nab( ji, 2 ),max( nab( ji, 1 ), iwork( ji ) ) )
                       ! update the queue -- add intervals if both halves
                       ! contain eigenvalues.
                       if( iwork( ji )==nab( ji, 2 ) ) then
                          ! no eigenvalue in the upper interval:
                          ! just use the lower interval.
                          ab( ji, 2 ) = c( ji )
                       else if( iwork( ji )==nab( ji, 1 ) ) then
                          ! no eigenvalue in the lower interval:
                          ! just use the upper interval.
                          ab( ji, 1 ) = c( ji )
                       else
                          klnew = klnew + 1
                          if( klnew<=mmax ) then
                             ! eigenvalue in both intervals -- add upper to
                             ! queue.
                             ab( klnew, 2 ) = ab( ji, 2 )
                             nab( klnew, 2 ) = nab( ji, 2 )
                             ab( klnew, 1 ) = c( ji )
                             nab( klnew, 1 ) = iwork( ji )
                             ab( ji, 2 ) = c( ji )
                             nab( ji, 2 ) = iwork( ji )
                          else
                             info = mmax + 1
                          end if
                       end if
                    end do loop_70
                    if( info/=0 )return
                    kl = klnew
                 else
                    ! ijob=3: binary search.  keep only the interval containing
                            ! w   s.t. n(w) = nval
                    do ji = kf, kl
                       if( iwork( ji )<=nval( ji ) ) then
                          ab( ji, 1 ) = c( ji )
                          nab( ji, 1 ) = iwork( ji )
                       end if
                       if( iwork( ji )>=nval( ji ) ) then
                          ab( ji, 2 ) = c( ji )
                          nab( ji, 2 ) = iwork( ji )
                       end if
                    end do
                 end if
              else
                 ! end of parallel version of the loop
                 ! begin of serial version of the loop
                 klnew = kl
                 loop_100: do ji = kf, kl
                    ! compute n(w), the number of eigenvalues less than w
                    tmp1 = c( ji )
                    tmp2 = d( 1 ) - tmp1
                    itmp1 = 0
                    if( tmp2<=pivmin ) then
                       itmp1 = 1
                       tmp2 = min( tmp2, -pivmin )
                    end if
                    do j = 2, n
                       tmp2 = d( j ) - e2( j-1 ) / tmp2 - tmp1
                       if( tmp2<=pivmin ) then
                          itmp1 = itmp1 + 1
                          tmp2 = min( tmp2, -pivmin )
                       end if
                    end do
                    if( ijob<=2 ) then
                       ! ijob=2: choose all intervals containing eigenvalues.
                       ! insure that n(w) is monotone
                       itmp1 = min( nab( ji, 2 ),max( nab( ji, 1 ), itmp1 ) )
                       ! update the queue -- add intervals if both halves
                       ! contain eigenvalues.
                       if( itmp1==nab( ji, 2 ) ) then
                          ! no eigenvalue in the upper interval:
                          ! just use the lower interval.
                          ab( ji, 2 ) = tmp1
                       else if( itmp1==nab( ji, 1 ) ) then
                          ! no eigenvalue in the lower interval:
                          ! just use the upper interval.
                          ab( ji, 1 ) = tmp1
                       else if( klnew<mmax ) then
                          ! eigenvalue in both intervals -- add upper to queue.
                          klnew = klnew + 1
                          ab( klnew, 2 ) = ab( ji, 2 )
                          nab( klnew, 2 ) = nab( ji, 2 )
                          ab( klnew, 1 ) = tmp1
                          nab( klnew, 1 ) = itmp1
                          ab( ji, 2 ) = tmp1
                          nab( ji, 2 ) = itmp1
                       else
                          info = mmax + 1
                          return
                       end if
                    else
                       ! ijob=3: binary search.  keep only the interval
                               ! containing  w  s.t. n(w) = nval
                       if( itmp1<=nval( ji ) ) then
                          ab( ji, 1 ) = tmp1
                          nab( ji, 1 ) = itmp1
                       end if
                       if( itmp1>=nval( ji ) ) then
                          ab( ji, 2 ) = tmp1
                          nab( ji, 2 ) = itmp1
                       end if
                    end if
                 end do loop_100
                 kl = klnew
              end if
              ! check for convergence
              kfnew = kf
              loop_110: do ji = kf, kl
                 tmp1 = abs( ab( ji, 2 )-ab( ji, 1 ) )
                 tmp2 = max( abs( ab( ji, 2 ) ), abs( ab( ji, 1 ) ) )
                 if( tmp1<max( abstol, pivmin, reltol*tmp2 ) .or.nab( ji, 1 )>=nab( ji, 2 ) ) &
                           then
                    ! converged -- swap with position kfnew,
                                 ! then increment kfnew
                    if( ji>kfnew ) then
                       tmp1 = ab( ji, 1 )
                       tmp2 = ab( ji, 2 )
                       itmp1 = nab( ji, 1 )
                       itmp2 = nab( ji, 2 )
                       ab( ji, 1 ) = ab( kfnew, 1 )
                       ab( ji, 2 ) = ab( kfnew, 2 )
                       nab( ji, 1 ) = nab( kfnew, 1 )
                       nab( ji, 2 ) = nab( kfnew, 2 )
                       ab( kfnew, 1 ) = tmp1
                       ab( kfnew, 2 ) = tmp2
                       nab( kfnew, 1 ) = itmp1
                       nab( kfnew, 2 ) = itmp2
                       if( ijob==3 ) then
                          itmp1 = nval( ji )
                          nval( ji ) = nval( kfnew )
                          nval( kfnew ) = itmp1
                       end if
                    end if
                    kfnew = kfnew + 1
                 end if
              end do loop_110
              kf = kfnew
              ! choose midpoints
              do ji = kf, kl
                 c( ji ) = half*( ab( ji, 1 )+ab( ji, 2 ) )
              end do
              ! if no more intervals to refine, quit.
              if( kf>kl )go to 140
           end do loop_130
           ! converged
           140 continue
           info = max( kl+1-kf, 0 )
           mout = kl
           return
     end subroutine stdlib_slaebz

     pure subroutine stdlib_dlaebz( ijob, nitmax, n, mmax, minp, nbmin, abstol,reltol, pivmin, d, &
     e, e2, nval, ab, c, mout,nab, work, iwork, info )
     !! DLAEBZ contains the iteration loops which compute and use the
     !! function N(w), which is the count of eigenvalues of a symmetric
     !! tridiagonal matrix T less than or equal to its argument  w.  It
     !! performs a choice of two types of loops:
     !! IJOB=1, followed by
     !! IJOB=2: It takes as input a list of intervals and returns a list of
     !! sufficiently small intervals whose union contains the same
     !! eigenvalues as the union of the original intervals.
     !! The input intervals are (AB(j,1),AB(j,2)], j=1,...,MINP.
     !! The output interval (AB(j,1),AB(j,2)] will contain
     !! eigenvalues NAB(j,1)+1,...,NAB(j,2), where 1 <= j <= MOUT.
     !! IJOB=3: It performs a binary search in each input interval
     !! (AB(j,1),AB(j,2)] for a point  w(j)  such that
     !! N(w(j))=NVAL(j), and uses  C(j)  as the starting point of
     !! the search.  If such a w(j) is found, then on output
     !! AB(j,1)=AB(j,2)=w.  If no such w(j) is found, then on output
     !! (AB(j,1),AB(j,2)] will be a small interval containing the
     !! point where N(w) jumps through NVAL(j), unless that point
     !! lies outside the initial interval.
     !! Note that the intervals are in all cases half-open intervals,
     !! i.e., of the form  (a,b] , which includes  b  but not  a .
     !! To avoid underflow, the matrix should be scaled so that its largest
     !! element is no greater than  overflow**(1/2) * underflow**(1/4)
     !! in absolute value.  To assure the most accurate computation
     !! of small eigenvalues, the matrix should be scaled to be
     !! not much smaller than that, either.
     !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
     !! Matrix", Report CS41, Computer Science Dept., Stanford
     !! University, July 21, 1966
     !! Note: the arguments are, in general, *not* checked for unreasonable
     !! values.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ijob, minp, mmax, n, nbmin, nitmax
           integer(ilp), intent(out) :: info, mout
           real(dp), intent(in) :: abstol, pivmin, reltol
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           integer(ilp), intent(inout) :: nab(mmax,*), nval(*)
           real(dp), intent(inout) :: ab(mmax,*), c(*)
           real(dp), intent(in) :: d(*), e(*), e2(*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: itmp1, itmp2, j, ji, jit, jp, kf, kfnew, kl, klnew
           real(dp) :: tmp1, tmp2
           ! Intrinsic Functions 
           ! Executable Statements 
           ! check for errors
           info = 0
           if( ijob<1 .or. ijob>3 ) then
              info = -1
              return
           end if
           ! initialize nab
           if( ijob==1 ) then
              ! compute the number of eigenvalues in the initial intervals.
              mout = 0
              do ji = 1, minp
                 do jp = 1, 2
                    tmp1 = d( 1 ) - ab( ji, jp )
                    if( abs( tmp1 )<pivmin )tmp1 = -pivmin
                    nab( ji, jp ) = 0
                    if( tmp1<=zero )nab( ji, jp ) = 1
                    do j = 2, n
                       tmp1 = d( j ) - e2( j-1 ) / tmp1 - ab( ji, jp )
                       if( abs( tmp1 )<pivmin )tmp1 = -pivmin
                       if( tmp1<=zero )nab( ji, jp ) = nab( ji, jp ) + 1
                    end do
                 end do
                 mout = mout + nab( ji, 2 ) - nab( ji, 1 )
              end do
              return
           end if
           ! initialize for loop
           ! kf and kl have the following meaning:
              ! intervals 1,...,kf-1 have converged.
              ! intervals kf,...,kl  still need to be refined.
           kf = 1
           kl = minp
           ! if ijob=2, initialize c.
           ! if ijob=3, use the user-supplied starting point.
           if( ijob==2 ) then
              do ji = 1, minp
                 c( ji ) = half*( ab( ji, 1 )+ab( ji, 2 ) )
              end do
           end if
           ! iteration loop
           loop_130: do jit = 1, nitmax
              ! loop over intervals
              if( kl-kf+1>=nbmin .and. nbmin>0 ) then
                 ! begin of parallel version of the loop
                 do ji = kf, kl
                    ! compute n(c), the number of eigenvalues less than c
                    work( ji ) = d( 1 ) - c( ji )
                    iwork( ji ) = 0
                    if( work( ji )<=pivmin ) then
                       iwork( ji ) = 1
                       work( ji ) = min( work( ji ), -pivmin )
                    end if
                    do j = 2, n
                       work( ji ) = d( j ) - e2( j-1 ) / work( ji ) - c( ji )
                       if( work( ji )<=pivmin ) then
                          iwork( ji ) = iwork( ji ) + 1
                          work( ji ) = min( work( ji ), -pivmin )
                       end if
                    end do
                 end do
                 if( ijob<=2 ) then
                    ! ijob=2: choose all intervals containing eigenvalues.
                    klnew = kl
                    loop_70: do ji = kf, kl
                       ! insure that n(w) is monotone
                       iwork( ji ) = min( nab( ji, 2 ),max( nab( ji, 1 ), iwork( ji ) ) )
                       ! update the queue -- add intervals if both halves
                       ! contain eigenvalues.
                       if( iwork( ji )==nab( ji, 2 ) ) then
                          ! no eigenvalue in the upper interval:
                          ! just use the lower interval.
                          ab( ji, 2 ) = c( ji )
                       else if( iwork( ji )==nab( ji, 1 ) ) then
                          ! no eigenvalue in the lower interval:
                          ! just use the upper interval.
                          ab( ji, 1 ) = c( ji )
                       else
                          klnew = klnew + 1
                          if( klnew<=mmax ) then
                             ! eigenvalue in both intervals -- add upper to
                             ! queue.
                             ab( klnew, 2 ) = ab( ji, 2 )
                             nab( klnew, 2 ) = nab( ji, 2 )
                             ab( klnew, 1 ) = c( ji )
                             nab( klnew, 1 ) = iwork( ji )
                             ab( ji, 2 ) = c( ji )
                             nab( ji, 2 ) = iwork( ji )
                          else
                             info = mmax + 1
                          end if
                       end if
                    end do loop_70
                    if( info/=0 )return
                    kl = klnew
                 else
                    ! ijob=3: binary search.  keep only the interval containing
                            ! w   s.t. n(w) = nval
                    do ji = kf, kl
                       if( iwork( ji )<=nval( ji ) ) then
                          ab( ji, 1 ) = c( ji )
                          nab( ji, 1 ) = iwork( ji )
                       end if
                       if( iwork( ji )>=nval( ji ) ) then
                          ab( ji, 2 ) = c( ji )
                          nab( ji, 2 ) = iwork( ji )
                       end if
                    end do
                 end if
              else
                 ! end of parallel version of the loop
                 ! begin of serial version of the loop
                 klnew = kl
                 loop_100: do ji = kf, kl
                    ! compute n(w), the number of eigenvalues less than w
                    tmp1 = c( ji )
                    tmp2 = d( 1 ) - tmp1
                    itmp1 = 0
                    if( tmp2<=pivmin ) then
                       itmp1 = 1
                       tmp2 = min( tmp2, -pivmin )
                    end if
                    do j = 2, n
                       tmp2 = d( j ) - e2( j-1 ) / tmp2 - tmp1
                       if( tmp2<=pivmin ) then
                          itmp1 = itmp1 + 1
                          tmp2 = min( tmp2, -pivmin )
                       end if
                    end do
                    if( ijob<=2 ) then
                       ! ijob=2: choose all intervals containing eigenvalues.
                       ! insure that n(w) is monotone
                       itmp1 = min( nab( ji, 2 ),max( nab( ji, 1 ), itmp1 ) )
                       ! update the queue -- add intervals if both halves
                       ! contain eigenvalues.
                       if( itmp1==nab( ji, 2 ) ) then
                          ! no eigenvalue in the upper interval:
                          ! just use the lower interval.
                          ab( ji, 2 ) = tmp1
                       else if( itmp1==nab( ji, 1 ) ) then
                          ! no eigenvalue in the lower interval:
                          ! just use the upper interval.
                          ab( ji, 1 ) = tmp1
                       else if( klnew<mmax ) then
                          ! eigenvalue in both intervals -- add upper to queue.
                          klnew = klnew + 1
                          ab( klnew, 2 ) = ab( ji, 2 )
                          nab( klnew, 2 ) = nab( ji, 2 )
                          ab( klnew, 1 ) = tmp1
                          nab( klnew, 1 ) = itmp1
                          ab( ji, 2 ) = tmp1
                          nab( ji, 2 ) = itmp1
                       else
                          info = mmax + 1
                          return
                       end if
                    else
                       ! ijob=3: binary search.  keep only the interval
                               ! containing  w  s.t. n(w) = nval
                       if( itmp1<=nval( ji ) ) then
                          ab( ji, 1 ) = tmp1
                          nab( ji, 1 ) = itmp1
                       end if
                       if( itmp1>=nval( ji ) ) then
                          ab( ji, 2 ) = tmp1
                          nab( ji, 2 ) = itmp1
                       end if
                    end if
                 end do loop_100
                 kl = klnew
              end if
              ! check for convergence
              kfnew = kf
              loop_110: do ji = kf, kl
                 tmp1 = abs( ab( ji, 2 )-ab( ji, 1 ) )
                 tmp2 = max( abs( ab( ji, 2 ) ), abs( ab( ji, 1 ) ) )
                 if( tmp1<max( abstol, pivmin, reltol*tmp2 ) .or.nab( ji, 1 )>=nab( ji, 2 ) ) &
                           then
                    ! converged -- swap with position kfnew,
                                 ! then increment kfnew
                    if( ji>kfnew ) then
                       tmp1 = ab( ji, 1 )
                       tmp2 = ab( ji, 2 )
                       itmp1 = nab( ji, 1 )
                       itmp2 = nab( ji, 2 )
                       ab( ji, 1 ) = ab( kfnew, 1 )
                       ab( ji, 2 ) = ab( kfnew, 2 )
                       nab( ji, 1 ) = nab( kfnew, 1 )
                       nab( ji, 2 ) = nab( kfnew, 2 )
                       ab( kfnew, 1 ) = tmp1
                       ab( kfnew, 2 ) = tmp2
                       nab( kfnew, 1 ) = itmp1
                       nab( kfnew, 2 ) = itmp2
                       if( ijob==3 ) then
                          itmp1 = nval( ji )
                          nval( ji ) = nval( kfnew )
                          nval( kfnew ) = itmp1
                       end if
                    end if
                    kfnew = kfnew + 1
                 end if
              end do loop_110
              kf = kfnew
              ! choose midpoints
              do ji = kf, kl
                 c( ji ) = half*( ab( ji, 1 )+ab( ji, 2 ) )
              end do
              ! if no more intervals to refine, quit.
              if( kf>kl )go to 140
           end do loop_130
           ! converged
           140 continue
           info = max( kl+1-kf, 0 )
           mout = kl
           return
     end subroutine stdlib_dlaebz

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laebz( ijob, nitmax, n, mmax, minp, nbmin, abstol,reltol, pivmin, d, &
     e, e2, nval, ab, c, mout,nab, work, iwork, info )
     !! DLAEBZ: contains the iteration loops which compute and use the
     !! function N(w), which is the count of eigenvalues of a symmetric
     !! tridiagonal matrix T less than or equal to its argument  w.  It
     !! performs a choice of two types of loops:
     !! IJOB=1, followed by
     !! IJOB=2: It takes as input a list of intervals and returns a list of
     !! sufficiently small intervals whose union contains the same
     !! eigenvalues as the union of the original intervals.
     !! The input intervals are (AB(j,1),AB(j,2)], j=1,...,MINP.
     !! The output interval (AB(j,1),AB(j,2)] will contain
     !! eigenvalues NAB(j,1)+1,...,NAB(j,2), where 1 <= j <= MOUT.
     !! IJOB=3: It performs a binary search in each input interval
     !! (AB(j,1),AB(j,2)] for a point  w(j)  such that
     !! N(w(j))=NVAL(j), and uses  C(j)  as the starting point of
     !! the search.  If such a w(j) is found, then on output
     !! AB(j,1)=AB(j,2)=w.  If no such w(j) is found, then on output
     !! (AB(j,1),AB(j,2)] will be a small interval containing the
     !! point where N(w) jumps through NVAL(j), unless that point
     !! lies outside the initial interval.
     !! Note that the intervals are in all cases half-open intervals,
     !! i.e., of the form  (a,b] , which includes  b  but not  a .
     !! To avoid underflow, the matrix should be scaled so that its largest
     !! element is no greater than  overflow**(1/2) * underflow**(1/4)
     !! in absolute value.  To assure the most accurate computation
     !! of small eigenvalues, the matrix should be scaled to be
     !! not much smaller than that, either.
     !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
     !! Matrix", Report CS41, Computer Science Dept., Stanford
     !! University, July 21, 1966
     !! Note: the arguments are, in general, *not* checked for unreasonable
     !! values.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ijob, minp, mmax, n, nbmin, nitmax
           integer(ilp), intent(out) :: info, mout
           real(${rk}$), intent(in) :: abstol, pivmin, reltol
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           integer(ilp), intent(inout) :: nab(mmax,*), nval(*)
           real(${rk}$), intent(inout) :: ab(mmax,*), c(*)
           real(${rk}$), intent(in) :: d(*), e(*), e2(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: itmp1, itmp2, j, ji, jit, jp, kf, kfnew, kl, klnew
           real(${rk}$) :: tmp1, tmp2
           ! Intrinsic Functions 
           ! Executable Statements 
           ! check for errors
           info = 0
           if( ijob<1 .or. ijob>3 ) then
              info = -1
              return
           end if
           ! initialize nab
           if( ijob==1 ) then
              ! compute the number of eigenvalues in the initial intervals.
              mout = 0
              do ji = 1, minp
                 do jp = 1, 2
                    tmp1 = d( 1 ) - ab( ji, jp )
                    if( abs( tmp1 )<pivmin )tmp1 = -pivmin
                    nab( ji, jp ) = 0
                    if( tmp1<=zero )nab( ji, jp ) = 1
                    do j = 2, n
                       tmp1 = d( j ) - e2( j-1 ) / tmp1 - ab( ji, jp )
                       if( abs( tmp1 )<pivmin )tmp1 = -pivmin
                       if( tmp1<=zero )nab( ji, jp ) = nab( ji, jp ) + 1
                    end do
                 end do
                 mout = mout + nab( ji, 2 ) - nab( ji, 1 )
              end do
              return
           end if
           ! initialize for loop
           ! kf and kl have the following meaning:
              ! intervals 1,...,kf-1 have converged.
              ! intervals kf,...,kl  still need to be refined.
           kf = 1
           kl = minp
           ! if ijob=2, initialize c.
           ! if ijob=3, use the user-supplied starting point.
           if( ijob==2 ) then
              do ji = 1, minp
                 c( ji ) = half*( ab( ji, 1 )+ab( ji, 2 ) )
              end do
           end if
           ! iteration loop
           loop_130: do jit = 1, nitmax
              ! loop over intervals
              if( kl-kf+1>=nbmin .and. nbmin>0 ) then
                 ! begin of parallel version of the loop
                 do ji = kf, kl
                    ! compute n(c), the number of eigenvalues less than c
                    work( ji ) = d( 1 ) - c( ji )
                    iwork( ji ) = 0
                    if( work( ji )<=pivmin ) then
                       iwork( ji ) = 1
                       work( ji ) = min( work( ji ), -pivmin )
                    end if
                    do j = 2, n
                       work( ji ) = d( j ) - e2( j-1 ) / work( ji ) - c( ji )
                       if( work( ji )<=pivmin ) then
                          iwork( ji ) = iwork( ji ) + 1
                          work( ji ) = min( work( ji ), -pivmin )
                       end if
                    end do
                 end do
                 if( ijob<=2 ) then
                    ! ijob=2: choose all intervals containing eigenvalues.
                    klnew = kl
                    loop_70: do ji = kf, kl
                       ! insure that n(w) is monotone
                       iwork( ji ) = min( nab( ji, 2 ),max( nab( ji, 1 ), iwork( ji ) ) )
                       ! update the queue -- add intervals if both halves
                       ! contain eigenvalues.
                       if( iwork( ji )==nab( ji, 2 ) ) then
                          ! no eigenvalue in the upper interval:
                          ! just use the lower interval.
                          ab( ji, 2 ) = c( ji )
                       else if( iwork( ji )==nab( ji, 1 ) ) then
                          ! no eigenvalue in the lower interval:
                          ! just use the upper interval.
                          ab( ji, 1 ) = c( ji )
                       else
                          klnew = klnew + 1
                          if( klnew<=mmax ) then
                             ! eigenvalue in both intervals -- add upper to
                             ! queue.
                             ab( klnew, 2 ) = ab( ji, 2 )
                             nab( klnew, 2 ) = nab( ji, 2 )
                             ab( klnew, 1 ) = c( ji )
                             nab( klnew, 1 ) = iwork( ji )
                             ab( ji, 2 ) = c( ji )
                             nab( ji, 2 ) = iwork( ji )
                          else
                             info = mmax + 1
                          end if
                       end if
                    end do loop_70
                    if( info/=0 )return
                    kl = klnew
                 else
                    ! ijob=3: binary search.  keep only the interval containing
                            ! w   s.t. n(w) = nval
                    do ji = kf, kl
                       if( iwork( ji )<=nval( ji ) ) then
                          ab( ji, 1 ) = c( ji )
                          nab( ji, 1 ) = iwork( ji )
                       end if
                       if( iwork( ji )>=nval( ji ) ) then
                          ab( ji, 2 ) = c( ji )
                          nab( ji, 2 ) = iwork( ji )
                       end if
                    end do
                 end if
              else
                 ! end of parallel version of the loop
                 ! begin of serial version of the loop
                 klnew = kl
                 loop_100: do ji = kf, kl
                    ! compute n(w), the number of eigenvalues less than w
                    tmp1 = c( ji )
                    tmp2 = d( 1 ) - tmp1
                    itmp1 = 0
                    if( tmp2<=pivmin ) then
                       itmp1 = 1
                       tmp2 = min( tmp2, -pivmin )
                    end if
                    do j = 2, n
                       tmp2 = d( j ) - e2( j-1 ) / tmp2 - tmp1
                       if( tmp2<=pivmin ) then
                          itmp1 = itmp1 + 1
                          tmp2 = min( tmp2, -pivmin )
                       end if
                    end do
                    if( ijob<=2 ) then
                       ! ijob=2: choose all intervals containing eigenvalues.
                       ! insure that n(w) is monotone
                       itmp1 = min( nab( ji, 2 ),max( nab( ji, 1 ), itmp1 ) )
                       ! update the queue -- add intervals if both halves
                       ! contain eigenvalues.
                       if( itmp1==nab( ji, 2 ) ) then
                          ! no eigenvalue in the upper interval:
                          ! just use the lower interval.
                          ab( ji, 2 ) = tmp1
                       else if( itmp1==nab( ji, 1 ) ) then
                          ! no eigenvalue in the lower interval:
                          ! just use the upper interval.
                          ab( ji, 1 ) = tmp1
                       else if( klnew<mmax ) then
                          ! eigenvalue in both intervals -- add upper to queue.
                          klnew = klnew + 1
                          ab( klnew, 2 ) = ab( ji, 2 )
                          nab( klnew, 2 ) = nab( ji, 2 )
                          ab( klnew, 1 ) = tmp1
                          nab( klnew, 1 ) = itmp1
                          ab( ji, 2 ) = tmp1
                          nab( ji, 2 ) = itmp1
                       else
                          info = mmax + 1
                          return
                       end if
                    else
                       ! ijob=3: binary search.  keep only the interval
                               ! containing  w  s.t. n(w) = nval
                       if( itmp1<=nval( ji ) ) then
                          ab( ji, 1 ) = tmp1
                          nab( ji, 1 ) = itmp1
                       end if
                       if( itmp1>=nval( ji ) ) then
                          ab( ji, 2 ) = tmp1
                          nab( ji, 2 ) = itmp1
                       end if
                    end if
                 end do loop_100
                 kl = klnew
              end if
              ! check for convergence
              kfnew = kf
              loop_110: do ji = kf, kl
                 tmp1 = abs( ab( ji, 2 )-ab( ji, 1 ) )
                 tmp2 = max( abs( ab( ji, 2 ) ), abs( ab( ji, 1 ) ) )
                 if( tmp1<max( abstol, pivmin, reltol*tmp2 ) .or.nab( ji, 1 )>=nab( ji, 2 ) ) &
                           then
                    ! converged -- swap with position kfnew,
                                 ! then increment kfnew
                    if( ji>kfnew ) then
                       tmp1 = ab( ji, 1 )
                       tmp2 = ab( ji, 2 )
                       itmp1 = nab( ji, 1 )
                       itmp2 = nab( ji, 2 )
                       ab( ji, 1 ) = ab( kfnew, 1 )
                       ab( ji, 2 ) = ab( kfnew, 2 )
                       nab( ji, 1 ) = nab( kfnew, 1 )
                       nab( ji, 2 ) = nab( kfnew, 2 )
                       ab( kfnew, 1 ) = tmp1
                       ab( kfnew, 2 ) = tmp2
                       nab( kfnew, 1 ) = itmp1
                       nab( kfnew, 2 ) = itmp2
                       if( ijob==3 ) then
                          itmp1 = nval( ji )
                          nval( ji ) = nval( kfnew )
                          nval( kfnew ) = itmp1
                       end if
                    end if
                    kfnew = kfnew + 1
                 end if
              end do loop_110
              kf = kfnew
              ! choose midpoints
              do ji = kf, kl
                 c( ji ) = half*( ab( ji, 1 )+ab( ji, 2 ) )
              end do
              ! if no more intervals to refine, quit.
              if( kf>kl )go to 140
           end do loop_130
           ! converged
           140 continue
           info = max( kl+1-kf, 0 )
           mout = kl
           return
     end subroutine stdlib_${ri}$laebz

#:endif
#:endfor





     pure subroutine stdlib_sstebz( range, order, n, vl, vu, il, iu, abstol, d, e,m, nsplit, w, &
     !! SSTEBZ computes the eigenvalues of a symmetric tridiagonal
     !! matrix T.  The user may ask for all eigenvalues, all eigenvalues
     !! in the half-open interval (VL, VU], or the IL-th through IU-th
     !! eigenvalues.
     !! To avoid overflow, the matrix must be scaled so that its
     !! largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
     !! accuracy, it should not be much smaller than that.
     !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
     !! Matrix", Report CS41, Computer Science Dept., Stanford
     !! University, July 21, 1966.
               iblock, isplit, work, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: order, range
           integer(ilp), intent(in) :: il, iu, n
           integer(ilp), intent(out) :: info, m, nsplit
           real(sp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: iblock(*), isplit(*), iwork(*)
           real(sp), intent(in) :: d(*), e(*)
           real(sp), intent(out) :: w(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: fudge = 2.1_sp
           real(sp), parameter :: relfac = 2.0_sp
           
           
           ! Local Scalars 
           logical(lk) :: ncnvrg, toofew
           integer(ilp) :: ib, ibegin, idiscl, idiscu, ie, iend, iinfo, im, in, ioff, iorder, &
                     iout, irange, itmax, itmp1, iw, iwoff, j, jb, jdisc, je, nb, nwl, nwu
           real(sp) :: atoli, bnorm, gl, gu, pivmin, rtoli, safemn, tmp1, tmp2, tnorm, ulp, wkill,&
                      wl, wlu, wu, wul
           ! Local Arrays 
           integer(ilp) :: idumma(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! decode range
           if( stdlib_lsame( range, 'A' ) ) then
              irange = 1
           else if( stdlib_lsame( range, 'V' ) ) then
              irange = 2
           else if( stdlib_lsame( range, 'I' ) ) then
              irange = 3
           else
              irange = 0
           end if
           ! decode order
           if( stdlib_lsame( order, 'B' ) ) then
              iorder = 2
           else if( stdlib_lsame( order, 'E' ) ) then
              iorder = 1
           else
              iorder = 0
           end if
           ! check for errors
           if( irange<=0 ) then
              info = -1
           else if( iorder<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( irange==2 ) then
              if( vl>=vu ) info = -5
           else if( irange==3 .and. ( il<1 .or. il>max( 1, n ) ) )then
              info = -6
           else if( irange==3 .and. ( iu<min( n, il ) .or. iu>n ) )then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSTEBZ', -info )
              return
           end if
           ! initialize error flags
           info = 0
           ncnvrg = .false.
           toofew = .false.
           ! quick return if possible
           m = 0
           if( n==0 )return
           ! simplifications:
           if( irange==3 .and. il==1 .and. iu==n )irange = 1
           ! get machine constants
           ! nb is the minimum vector length for vector bisection, or 0
           ! if only scalar is to be done.
           safemn = stdlib_slamch( 'S' )
           ulp = stdlib_slamch( 'P' )
           rtoli = ulp*relfac
           nb = stdlib_ilaenv( 1, 'SSTEBZ', ' ', n, -1, -1, -1 )
           if( nb<=1 )nb = 0
           ! special case when n=1
           if( n==1 ) then
              nsplit = 1
              isplit( 1 ) = 1
              if( irange==2 .and. ( vl>=d( 1 ) .or. vu<d( 1 ) ) ) then
                 m = 0
              else
                 w( 1 ) = d( 1 )
                 iblock( 1 ) = 1
                 m = 1
              end if
              return
           end if
           ! compute splitting points
           nsplit = 1
           work( n ) = zero
           pivmin = one
           do j = 2, n
              tmp1 = e( j-1 )**2
              if( abs( d( j )*d( j-1 ) )*ulp**2+safemn>tmp1 ) then
                 isplit( nsplit ) = j - 1
                 nsplit = nsplit + 1
                 work( j-1 ) = zero
              else
                 work( j-1 ) = tmp1
                 pivmin = max( pivmin, tmp1 )
              end if
           end do
           isplit( nsplit ) = n
           pivmin = pivmin*safemn
           ! compute interval and atoli
           if( irange==3 ) then
              ! range='i': compute the interval containing eigenvalues
                         ! il through iu.
              ! compute gershgorin interval for entire (split) matrix
              ! and use it as the initial interval
              gu = d( 1 )
              gl = d( 1 )
              tmp1 = zero
              do j = 1, n - 1
                 tmp2 = sqrt( work( j ) )
                 gu = max( gu, d( j )+tmp1+tmp2 )
                 gl = min( gl, d( j )-tmp1-tmp2 )
                 tmp1 = tmp2
              end do
              gu = max( gu, d( n )+tmp1 )
              gl = min( gl, d( n )-tmp1 )
              tnorm = max( abs( gl ), abs( gu ) )
              gl = gl - fudge*tnorm*ulp*n - fudge*two*pivmin
              gu = gu + fudge*tnorm*ulp*n + fudge*pivmin
              ! compute iteration parameters
              itmax = int( ( log( tnorm+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
              if( abstol<=zero ) then
                 atoli = ulp*tnorm
              else
                 atoli = abstol
              end if
              work( n+1 ) = gl
              work( n+2 ) = gl
              work( n+3 ) = gu
              work( n+4 ) = gu
              work( n+5 ) = gl
              work( n+6 ) = gu
              iwork( 1 ) = -1
              iwork( 2 ) = -1
              iwork( 3 ) = n + 1
              iwork( 4 ) = n + 1
              iwork( 5 ) = il - 1
              iwork( 6 ) = iu
              call stdlib_slaebz( 3, itmax, n, 2, 2, nb, atoli, rtoli, pivmin, d, e,work, iwork( &
                        5 ), work( n+1 ), work( n+5 ), iout,iwork, w, iblock, iinfo )
              if( iwork( 6 )==iu ) then
                 wl = work( n+1 )
                 wlu = work( n+3 )
                 nwl = iwork( 1 )
                 wu = work( n+4 )
                 wul = work( n+2 )
                 nwu = iwork( 4 )
              else
                 wl = work( n+2 )
                 wlu = work( n+4 )
                 nwl = iwork( 2 )
                 wu = work( n+3 )
                 wul = work( n+1 )
                 nwu = iwork( 3 )
              end if
              if( nwl<0 .or. nwl>=n .or. nwu<1 .or. nwu>n ) then
                 info = 4
                 return
              end if
           else
              ! range='a' or 'v' -- set atoli
              tnorm = max( abs( d( 1 ) )+abs( e( 1 ) ),abs( d( n ) )+abs( e( n-1 ) ) )
              do j = 2, n - 1
                 tnorm = max( tnorm, abs( d( j ) )+abs( e( j-1 ) )+abs( e( j ) ) )
              end do
              if( abstol<=zero ) then
                 atoli = ulp*tnorm
              else
                 atoli = abstol
              end if
              if( irange==2 ) then
                 wl = vl
                 wu = vu
              else
                 wl = zero
                 wu = zero
              end if
           end if
           ! find eigenvalues -- loop over blocks and recompute nwl and nwu.
           ! nwl accumulates the number of eigenvalues .le. wl,
           ! nwu accumulates the number of eigenvalues .le. wu
           m = 0
           iend = 0
           info = 0
           nwl = 0
           nwu = 0
           loop_70: do jb = 1, nsplit
              ioff = iend
              ibegin = ioff + 1
              iend = isplit( jb )
              in = iend - ioff
              if( in==1 ) then
                 ! special case -- in=1
                 if( irange==1 .or. wl>=d( ibegin )-pivmin )nwl = nwl + 1
                 if( irange==1 .or. wu>=d( ibegin )-pivmin )nwu = nwu + 1
                 if( irange==1 .or. ( wl<d( ibegin )-pivmin .and. wu>=d( ibegin )-pivmin ) ) &
                           then
                    m = m + 1
                    w( m ) = d( ibegin )
                    iblock( m ) = jb
                 end if
              else
                 ! general case -- in > 1
                 ! compute gershgorin interval
                 ! and use it as the initial interval
                 gu = d( ibegin )
                 gl = d( ibegin )
                 tmp1 = zero
                 do j = ibegin, iend - 1
                    tmp2 = abs( e( j ) )
                    gu = max( gu, d( j )+tmp1+tmp2 )
                    gl = min( gl, d( j )-tmp1-tmp2 )
                    tmp1 = tmp2
                 end do
                 gu = max( gu, d( iend )+tmp1 )
                 gl = min( gl, d( iend )-tmp1 )
                 bnorm = max( abs( gl ), abs( gu ) )
                 gl = gl - fudge*bnorm*ulp*in - fudge*pivmin
                 gu = gu + fudge*bnorm*ulp*in + fudge*pivmin
                 ! compute atoli for the current submatrix
                 if( abstol<=zero ) then
                    atoli = ulp*max( abs( gl ), abs( gu ) )
                 else
                    atoli = abstol
                 end if
                 if( irange>1 ) then
                    if( gu<wl ) then
                       nwl = nwl + in
                       nwu = nwu + in
                       cycle loop_70
                    end if
                    gl = max( gl, wl )
                    gu = min( gu, wu )
                    if( gl>=gu )cycle loop_70
                 end if
                 ! set up initial interval
                 work( n+1 ) = gl
                 work( n+in+1 ) = gu
                 call stdlib_slaebz( 1, 0, in, in, 1, nb, atoli, rtoli, pivmin,d( ibegin ), e( &
                 ibegin ), work( ibegin ),idumma, work( n+1 ), work( n+2*in+1 ), im,iwork, w( m+1 &
                           ), iblock( m+1 ), iinfo )
                 nwl = nwl + iwork( 1 )
                 nwu = nwu + iwork( in+1 )
                 iwoff = m - iwork( 1 )
                 ! compute eigenvalues
                 itmax = int( ( log( gu-gl+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + &
                           2
                 call stdlib_slaebz( 2, itmax, in, in, 1, nb, atoli, rtoli, pivmin,d( ibegin ), e(&
                  ibegin ), work( ibegin ),idumma, work( n+1 ), work( n+2*in+1 ), iout,iwork, w( &
                            m+1 ), iblock( m+1 ), iinfo )
                 ! copy eigenvalues into w and iblock
                 ! use -jb for block number for unconverged eigenvalues.
                 do j = 1, iout
                    tmp1 = half*( work( j+n )+work( j+in+n ) )
                    ! flag non-convergence.
                    if( j>iout-iinfo ) then
                       ncnvrg = .true.
                       ib = -jb
                    else
                       ib = jb
                    end if
                    do je = iwork( j ) + 1 + iwoff,iwork( j+in ) + iwoff
                       w( je ) = tmp1
                       iblock( je ) = ib
                    end do
                 end do
                 m = m + im
              end if
           end do loop_70
           ! if range='i', then (wl,wu) contains eigenvalues nwl+1,...,nwu
           ! if nwl+1 < il or nwu > iu, discard extra eigenvalues.
           if( irange==3 ) then
              im = 0
              idiscl = il - 1 - nwl
              idiscu = nwu - iu
              if( idiscl>0 .or. idiscu>0 ) then
                 do je = 1, m
                    if( w( je )<=wlu .and. idiscl>0 ) then
                       idiscl = idiscl - 1
                    else if( w( je )>=wul .and. idiscu>0 ) then
                       idiscu = idiscu - 1
                    else
                       im = im + 1
                       w( im ) = w( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 m = im
              end if
              if( idiscl>0 .or. idiscu>0 ) then
                 ! code to deal with effects of bad arithmetic:
                 ! some low eigenvalues to be discarded are not in (wl,wlu],
                 ! or high eigenvalues to be discarded are not in (wul,wu]
                 ! so just kill off the smallest idiscl/largest idiscu
                 ! eigenvalues, by simply finding the smallest/largest
                 ! eigenvalue(s).
                 ! (if n(w) is monotone non-decreasing, this should never
                     ! happen.)
                 if( idiscl>0 ) then
                    wkill = wu
                    do jdisc = 1, idiscl
                       iw = 0
                       do je = 1, m
                          if( iblock( je )/=0 .and.( w( je )<wkill .or. iw==0 ) ) then
                             iw = je
                             wkill = w( je )
                          end if
                       end do
                       iblock( iw ) = 0
                    end do
                 end if
                 if( idiscu>0 ) then
                    wkill = wl
                    do jdisc = 1, idiscu
                       iw = 0
                       do je = 1, m
                          if( iblock( je )/=0 .and.( w( je )>wkill .or. iw==0 ) ) then
                             iw = je
                             wkill = w( je )
                          end if
                       end do
                       iblock( iw ) = 0
                    end do
                 end if
                 im = 0
                 do je = 1, m
                    if( iblock( je )/=0 ) then
                       im = im + 1
                       w( im ) = w( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 m = im
              end if
              if( idiscl<0 .or. idiscu<0 ) then
                 toofew = .true.
              end if
           end if
           ! if order='b', do nothing -- the eigenvalues are already sorted
              ! by block.
           ! if order='e', sort the eigenvalues from smallest to largest
           if( iorder==1 .and. nsplit>1 ) then
              do je = 1, m - 1
                 ie = 0
                 tmp1 = w( je )
                 do j = je + 1, m
                    if( w( j )<tmp1 ) then
                       ie = j
                       tmp1 = w( j )
                    end if
                 end do
                 if( ie/=0 ) then
                    itmp1 = iblock( ie )
                    w( ie ) = w( je )
                    iblock( ie ) = iblock( je )
                    w( je ) = tmp1
                    iblock( je ) = itmp1
                 end if
              end do
           end if
           info = 0
           if( ncnvrg )info = info + 1
           if( toofew )info = info + 2
           return
     end subroutine stdlib_sstebz

     pure subroutine stdlib_dstebz( range, order, n, vl, vu, il, iu, abstol, d, e,m, nsplit, w, &
     !! DSTEBZ computes the eigenvalues of a symmetric tridiagonal
     !! matrix T.  The user may ask for all eigenvalues, all eigenvalues
     !! in the half-open interval (VL, VU], or the IL-th through IU-th
     !! eigenvalues.
     !! To avoid overflow, the matrix must be scaled so that its
     !! largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
     !! accuracy, it should not be much smaller than that.
     !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
     !! Matrix", Report CS41, Computer Science Dept., Stanford
     !! University, July 21, 1966.
               iblock, isplit, work, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: order, range
           integer(ilp), intent(in) :: il, iu, n
           integer(ilp), intent(out) :: info, m, nsplit
           real(dp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: iblock(*), isplit(*), iwork(*)
           real(dp), intent(in) :: d(*), e(*)
           real(dp), intent(out) :: w(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: fudge = 2.1_dp
           real(dp), parameter :: relfac = 2.0_dp
           
           
           ! Local Scalars 
           logical(lk) :: ncnvrg, toofew
           integer(ilp) :: ib, ibegin, idiscl, idiscu, ie, iend, iinfo, im, in, ioff, iorder, &
                     iout, irange, itmax, itmp1, iw, iwoff, j, jb, jdisc, je, nb, nwl, nwu
           real(dp) :: atoli, bnorm, gl, gu, pivmin, rtoli, safemn, tmp1, tmp2, tnorm, ulp, wkill,&
                      wl, wlu, wu, wul
           ! Local Arrays 
           integer(ilp) :: idumma(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! decode range
           if( stdlib_lsame( range, 'A' ) ) then
              irange = 1
           else if( stdlib_lsame( range, 'V' ) ) then
              irange = 2
           else if( stdlib_lsame( range, 'I' ) ) then
              irange = 3
           else
              irange = 0
           end if
           ! decode order
           if( stdlib_lsame( order, 'B' ) ) then
              iorder = 2
           else if( stdlib_lsame( order, 'E' ) ) then
              iorder = 1
           else
              iorder = 0
           end if
           ! check for errors
           if( irange<=0 ) then
              info = -1
           else if( iorder<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( irange==2 ) then
              if( vl>=vu )info = -5
           else if( irange==3 .and. ( il<1 .or. il>max( 1, n ) ) )then
              info = -6
           else if( irange==3 .and. ( iu<min( n, il ) .or. iu>n ) )then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEBZ', -info )
              return
           end if
           ! initialize error flags
           info = 0
           ncnvrg = .false.
           toofew = .false.
           ! quick return if possible
           m = 0
           if( n==0 )return
           ! simplifications:
           if( irange==3 .and. il==1 .and. iu==n )irange = 1
           ! get machine constants
           ! nb is the minimum vector length for vector bisection, or 0
           ! if only scalar is to be done.
           safemn = stdlib_dlamch( 'S' )
           ulp = stdlib_dlamch( 'P' )
           rtoli = ulp*relfac
           nb = stdlib_ilaenv( 1, 'DSTEBZ', ' ', n, -1, -1, -1 )
           if( nb<=1 )nb = 0
           ! special case when n=1
           if( n==1 ) then
              nsplit = 1
              isplit( 1 ) = 1
              if( irange==2 .and. ( vl>=d( 1 ) .or. vu<d( 1 ) ) ) then
                 m = 0
              else
                 w( 1 ) = d( 1 )
                 iblock( 1 ) = 1
                 m = 1
              end if
              return
           end if
           ! compute splitting points
           nsplit = 1
           work( n ) = zero
           pivmin = one
           do j = 2, n
              tmp1 = e( j-1 )**2
              if( abs( d( j )*d( j-1 ) )*ulp**2+safemn>tmp1 ) then
                 isplit( nsplit ) = j - 1
                 nsplit = nsplit + 1
                 work( j-1 ) = zero
              else
                 work( j-1 ) = tmp1
                 pivmin = max( pivmin, tmp1 )
              end if
           end do
           isplit( nsplit ) = n
           pivmin = pivmin*safemn
           ! compute interval and atoli
           if( irange==3 ) then
              ! range='i': compute the interval containing eigenvalues
                         ! il through iu.
              ! compute gershgorin interval for entire (split) matrix
              ! and use it as the initial interval
              gu = d( 1 )
              gl = d( 1 )
              tmp1 = zero
              do j = 1, n - 1
                 tmp2 = sqrt( work( j ) )
                 gu = max( gu, d( j )+tmp1+tmp2 )
                 gl = min( gl, d( j )-tmp1-tmp2 )
                 tmp1 = tmp2
              end do
              gu = max( gu, d( n )+tmp1 )
              gl = min( gl, d( n )-tmp1 )
              tnorm = max( abs( gl ), abs( gu ) )
              gl = gl - fudge*tnorm*ulp*n - fudge*two*pivmin
              gu = gu + fudge*tnorm*ulp*n + fudge*pivmin
              ! compute iteration parameters
              itmax = int( ( log( tnorm+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
              if( abstol<=zero ) then
                 atoli = ulp*tnorm
              else
                 atoli = abstol
              end if
              work( n+1 ) = gl
              work( n+2 ) = gl
              work( n+3 ) = gu
              work( n+4 ) = gu
              work( n+5 ) = gl
              work( n+6 ) = gu
              iwork( 1 ) = -1
              iwork( 2 ) = -1
              iwork( 3 ) = n + 1
              iwork( 4 ) = n + 1
              iwork( 5 ) = il - 1
              iwork( 6 ) = iu
              call stdlib_dlaebz( 3, itmax, n, 2, 2, nb, atoli, rtoli, pivmin, d, e,work, iwork( &
                        5 ), work( n+1 ), work( n+5 ), iout,iwork, w, iblock, iinfo )
              if( iwork( 6 )==iu ) then
                 wl = work( n+1 )
                 wlu = work( n+3 )
                 nwl = iwork( 1 )
                 wu = work( n+4 )
                 wul = work( n+2 )
                 nwu = iwork( 4 )
              else
                 wl = work( n+2 )
                 wlu = work( n+4 )
                 nwl = iwork( 2 )
                 wu = work( n+3 )
                 wul = work( n+1 )
                 nwu = iwork( 3 )
              end if
              if( nwl<0 .or. nwl>=n .or. nwu<1 .or. nwu>n ) then
                 info = 4
                 return
              end if
           else
              ! range='a' or 'v' -- set atoli
              tnorm = max( abs( d( 1 ) )+abs( e( 1 ) ),abs( d( n ) )+abs( e( n-1 ) ) )
              do j = 2, n - 1
                 tnorm = max( tnorm, abs( d( j ) )+abs( e( j-1 ) )+abs( e( j ) ) )
              end do
              if( abstol<=zero ) then
                 atoli = ulp*tnorm
              else
                 atoli = abstol
              end if
              if( irange==2 ) then
                 wl = vl
                 wu = vu
              else
                 wl = zero
                 wu = zero
              end if
           end if
           ! find eigenvalues -- loop over blocks and recompute nwl and nwu.
           ! nwl accumulates the number of eigenvalues .le. wl,
           ! nwu accumulates the number of eigenvalues .le. wu
           m = 0
           iend = 0
           info = 0
           nwl = 0
           nwu = 0
           loop_70: do jb = 1, nsplit
              ioff = iend
              ibegin = ioff + 1
              iend = isplit( jb )
              in = iend - ioff
              if( in==1 ) then
                 ! special case -- in=1
                 if( irange==1 .or. wl>=d( ibegin )-pivmin )nwl = nwl + 1
                 if( irange==1 .or. wu>=d( ibegin )-pivmin )nwu = nwu + 1
                 if( irange==1 .or. ( wl<d( ibegin )-pivmin .and. wu>=d( ibegin )-pivmin ) ) &
                           then
                    m = m + 1
                    w( m ) = d( ibegin )
                    iblock( m ) = jb
                 end if
              else
                 ! general case -- in > 1
                 ! compute gershgorin interval
                 ! and use it as the initial interval
                 gu = d( ibegin )
                 gl = d( ibegin )
                 tmp1 = zero
                 do j = ibegin, iend - 1
                    tmp2 = abs( e( j ) )
                    gu = max( gu, d( j )+tmp1+tmp2 )
                    gl = min( gl, d( j )-tmp1-tmp2 )
                    tmp1 = tmp2
                 end do
                 gu = max( gu, d( iend )+tmp1 )
                 gl = min( gl, d( iend )-tmp1 )
                 bnorm = max( abs( gl ), abs( gu ) )
                 gl = gl - fudge*bnorm*ulp*in - fudge*pivmin
                 gu = gu + fudge*bnorm*ulp*in + fudge*pivmin
                 ! compute atoli for the current submatrix
                 if( abstol<=zero ) then
                    atoli = ulp*max( abs( gl ), abs( gu ) )
                 else
                    atoli = abstol
                 end if
                 if( irange>1 ) then
                    if( gu<wl ) then
                       nwl = nwl + in
                       nwu = nwu + in
                       cycle loop_70
                    end if
                    gl = max( gl, wl )
                    gu = min( gu, wu )
                    if( gl>=gu )cycle loop_70
                 end if
                 ! set up initial interval
                 work( n+1 ) = gl
                 work( n+in+1 ) = gu
                 call stdlib_dlaebz( 1, 0, in, in, 1, nb, atoli, rtoli, pivmin,d( ibegin ), e( &
                 ibegin ), work( ibegin ),idumma, work( n+1 ), work( n+2*in+1 ), im,iwork, w( m+1 &
                           ), iblock( m+1 ), iinfo )
                 nwl = nwl + iwork( 1 )
                 nwu = nwu + iwork( in+1 )
                 iwoff = m - iwork( 1 )
                 ! compute eigenvalues
                 itmax = int( ( log( gu-gl+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + &
                           2
                 call stdlib_dlaebz( 2, itmax, in, in, 1, nb, atoli, rtoli, pivmin,d( ibegin ), e(&
                  ibegin ), work( ibegin ),idumma, work( n+1 ), work( n+2*in+1 ), iout,iwork, w( &
                            m+1 ), iblock( m+1 ), iinfo )
                 ! copy eigenvalues into w and iblock
                 ! use -jb for block number for unconverged eigenvalues.
                 do j = 1, iout
                    tmp1 = half*( work( j+n )+work( j+in+n ) )
                    ! flag non-convergence.
                    if( j>iout-iinfo ) then
                       ncnvrg = .true.
                       ib = -jb
                    else
                       ib = jb
                    end if
                    do je = iwork( j ) + 1 + iwoff,iwork( j+in ) + iwoff
                       w( je ) = tmp1
                       iblock( je ) = ib
                    end do
                 end do
                 m = m + im
              end if
           end do loop_70
           ! if range='i', then (wl,wu) contains eigenvalues nwl+1,...,nwu
           ! if nwl+1 < il or nwu > iu, discard extra eigenvalues.
           if( irange==3 ) then
              im = 0
              idiscl = il - 1 - nwl
              idiscu = nwu - iu
              if( idiscl>0 .or. idiscu>0 ) then
                 do je = 1, m
                    if( w( je )<=wlu .and. idiscl>0 ) then
                       idiscl = idiscl - 1
                    else if( w( je )>=wul .and. idiscu>0 ) then
                       idiscu = idiscu - 1
                    else
                       im = im + 1
                       w( im ) = w( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 m = im
              end if
              if( idiscl>0 .or. idiscu>0 ) then
                 ! code to deal with effects of bad arithmetic:
                 ! some low eigenvalues to be discarded are not in (wl,wlu],
                 ! or high eigenvalues to be discarded are not in (wul,wu]
                 ! so just kill off the smallest idiscl/largest idiscu
                 ! eigenvalues, by simply finding the smallest/largest
                 ! eigenvalue(s).
                 ! (if n(w) is monotone non-decreasing, this should never
                     ! happen.)
                 if( idiscl>0 ) then
                    wkill = wu
                    do jdisc = 1, idiscl
                       iw = 0
                       do je = 1, m
                          if( iblock( je )/=0 .and.( w( je )<wkill .or. iw==0 ) ) then
                             iw = je
                             wkill = w( je )
                          end if
                       end do
                       iblock( iw ) = 0
                    end do
                 end if
                 if( idiscu>0 ) then
                    wkill = wl
                    do jdisc = 1, idiscu
                       iw = 0
                       do je = 1, m
                          if( iblock( je )/=0 .and.( w( je )>wkill .or. iw==0 ) ) then
                             iw = je
                             wkill = w( je )
                          end if
                       end do
                       iblock( iw ) = 0
                    end do
                 end if
                 im = 0
                 do je = 1, m
                    if( iblock( je )/=0 ) then
                       im = im + 1
                       w( im ) = w( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 m = im
              end if
              if( idiscl<0 .or. idiscu<0 ) then
                 toofew = .true.
              end if
           end if
           ! if order='b', do nothing -- the eigenvalues are already sorted
              ! by block.
           ! if order='e', sort the eigenvalues from smallest to largest
           if( iorder==1 .and. nsplit>1 ) then
              do je = 1, m - 1
                 ie = 0
                 tmp1 = w( je )
                 do j = je + 1, m
                    if( w( j )<tmp1 ) then
                       ie = j
                       tmp1 = w( j )
                    end if
                 end do
                 if( ie/=0 ) then
                    itmp1 = iblock( ie )
                    w( ie ) = w( je )
                    iblock( ie ) = iblock( je )
                    w( je ) = tmp1
                    iblock( je ) = itmp1
                 end if
              end do
           end if
           info = 0
           if( ncnvrg )info = info + 1
           if( toofew )info = info + 2
           return
     end subroutine stdlib_dstebz

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$stebz( range, order, n, vl, vu, il, iu, abstol, d, e,m, nsplit, w, &
     !! DSTEBZ: computes the eigenvalues of a symmetric tridiagonal
     !! matrix T.  The user may ask for all eigenvalues, all eigenvalues
     !! in the half-open interval (VL, VU], or the IL-th through IU-th
     !! eigenvalues.
     !! To avoid overflow, the matrix must be scaled so that its
     !! largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
     !! accuracy, it should not be much smaller than that.
     !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
     !! Matrix", Report CS41, Computer Science Dept., Stanford
     !! University, July 21, 1966.
               iblock, isplit, work, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: order, range
           integer(ilp), intent(in) :: il, iu, n
           integer(ilp), intent(out) :: info, m, nsplit
           real(${rk}$), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: iblock(*), isplit(*), iwork(*)
           real(${rk}$), intent(in) :: d(*), e(*)
           real(${rk}$), intent(out) :: w(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: fudge = 2.1_${rk}$
           real(${rk}$), parameter :: relfac = 2.0_${rk}$
           
           
           ! Local Scalars 
           logical(lk) :: ncnvrg, toofew
           integer(ilp) :: ib, ibegin, idiscl, idiscu, ie, iend, iinfo, im, in, ioff, iorder, &
                     iout, irange, itmax, itmp1, iw, iwoff, j, jb, jdisc, je, nb, nwl, nwu
           real(${rk}$) :: atoli, bnorm, gl, gu, pivmin, rtoli, safemn, tmp1, tmp2, tnorm, ulp, wkill,&
                      wl, wlu, wu, wul
           ! Local Arrays 
           integer(ilp) :: idumma(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! decode range
           if( stdlib_lsame( range, 'A' ) ) then
              irange = 1
           else if( stdlib_lsame( range, 'V' ) ) then
              irange = 2
           else if( stdlib_lsame( range, 'I' ) ) then
              irange = 3
           else
              irange = 0
           end if
           ! decode order
           if( stdlib_lsame( order, 'B' ) ) then
              iorder = 2
           else if( stdlib_lsame( order, 'E' ) ) then
              iorder = 1
           else
              iorder = 0
           end if
           ! check for errors
           if( irange<=0 ) then
              info = -1
           else if( iorder<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( irange==2 ) then
              if( vl>=vu )info = -5
           else if( irange==3 .and. ( il<1 .or. il>max( 1, n ) ) )then
              info = -6
           else if( irange==3 .and. ( iu<min( n, il ) .or. iu>n ) )then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEBZ', -info )
              return
           end if
           ! initialize error flags
           info = 0
           ncnvrg = .false.
           toofew = .false.
           ! quick return if possible
           m = 0
           if( n==0 )return
           ! simplifications:
           if( irange==3 .and. il==1 .and. iu==n )irange = 1
           ! get machine constants
           ! nb is the minimum vector length for vector bisection, or 0
           ! if only scalar is to be done.
           safemn = stdlib_${ri}$lamch( 'S' )
           ulp = stdlib_${ri}$lamch( 'P' )
           rtoli = ulp*relfac
           nb = stdlib_ilaenv( 1, 'DSTEBZ', ' ', n, -1, -1, -1 )
           if( nb<=1 )nb = 0
           ! special case when n=1
           if( n==1 ) then
              nsplit = 1
              isplit( 1 ) = 1
              if( irange==2 .and. ( vl>=d( 1 ) .or. vu<d( 1 ) ) ) then
                 m = 0
              else
                 w( 1 ) = d( 1 )
                 iblock( 1 ) = 1
                 m = 1
              end if
              return
           end if
           ! compute splitting points
           nsplit = 1
           work( n ) = zero
           pivmin = one
           do j = 2, n
              tmp1 = e( j-1 )**2
              if( abs( d( j )*d( j-1 ) )*ulp**2+safemn>tmp1 ) then
                 isplit( nsplit ) = j - 1
                 nsplit = nsplit + 1
                 work( j-1 ) = zero
              else
                 work( j-1 ) = tmp1
                 pivmin = max( pivmin, tmp1 )
              end if
           end do
           isplit( nsplit ) = n
           pivmin = pivmin*safemn
           ! compute interval and atoli
           if( irange==3 ) then
              ! range='i': compute the interval containing eigenvalues
                         ! il through iu.
              ! compute gershgorin interval for entire (split) matrix
              ! and use it as the initial interval
              gu = d( 1 )
              gl = d( 1 )
              tmp1 = zero
              do j = 1, n - 1
                 tmp2 = sqrt( work( j ) )
                 gu = max( gu, d( j )+tmp1+tmp2 )
                 gl = min( gl, d( j )-tmp1-tmp2 )
                 tmp1 = tmp2
              end do
              gu = max( gu, d( n )+tmp1 )
              gl = min( gl, d( n )-tmp1 )
              tnorm = max( abs( gl ), abs( gu ) )
              gl = gl - fudge*tnorm*ulp*n - fudge*two*pivmin
              gu = gu + fudge*tnorm*ulp*n + fudge*pivmin
              ! compute iteration parameters
              itmax = int( ( log( tnorm+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
              if( abstol<=zero ) then
                 atoli = ulp*tnorm
              else
                 atoli = abstol
              end if
              work( n+1 ) = gl
              work( n+2 ) = gl
              work( n+3 ) = gu
              work( n+4 ) = gu
              work( n+5 ) = gl
              work( n+6 ) = gu
              iwork( 1 ) = -1
              iwork( 2 ) = -1
              iwork( 3 ) = n + 1
              iwork( 4 ) = n + 1
              iwork( 5 ) = il - 1
              iwork( 6 ) = iu
              call stdlib_${ri}$laebz( 3, itmax, n, 2, 2, nb, atoli, rtoli, pivmin, d, e,work, iwork( &
                        5 ), work( n+1 ), work( n+5 ), iout,iwork, w, iblock, iinfo )
              if( iwork( 6 )==iu ) then
                 wl = work( n+1 )
                 wlu = work( n+3 )
                 nwl = iwork( 1 )
                 wu = work( n+4 )
                 wul = work( n+2 )
                 nwu = iwork( 4 )
              else
                 wl = work( n+2 )
                 wlu = work( n+4 )
                 nwl = iwork( 2 )
                 wu = work( n+3 )
                 wul = work( n+1 )
                 nwu = iwork( 3 )
              end if
              if( nwl<0 .or. nwl>=n .or. nwu<1 .or. nwu>n ) then
                 info = 4
                 return
              end if
           else
              ! range='a' or 'v' -- set atoli
              tnorm = max( abs( d( 1 ) )+abs( e( 1 ) ),abs( d( n ) )+abs( e( n-1 ) ) )
              do j = 2, n - 1
                 tnorm = max( tnorm, abs( d( j ) )+abs( e( j-1 ) )+abs( e( j ) ) )
              end do
              if( abstol<=zero ) then
                 atoli = ulp*tnorm
              else
                 atoli = abstol
              end if
              if( irange==2 ) then
                 wl = vl
                 wu = vu
              else
                 wl = zero
                 wu = zero
              end if
           end if
           ! find eigenvalues -- loop over blocks and recompute nwl and nwu.
           ! nwl accumulates the number of eigenvalues .le. wl,
           ! nwu accumulates the number of eigenvalues .le. wu
           m = 0
           iend = 0
           info = 0
           nwl = 0
           nwu = 0
           loop_70: do jb = 1, nsplit
              ioff = iend
              ibegin = ioff + 1
              iend = isplit( jb )
              in = iend - ioff
              if( in==1 ) then
                 ! special case -- in=1
                 if( irange==1 .or. wl>=d( ibegin )-pivmin )nwl = nwl + 1
                 if( irange==1 .or. wu>=d( ibegin )-pivmin )nwu = nwu + 1
                 if( irange==1 .or. ( wl<d( ibegin )-pivmin .and. wu>=d( ibegin )-pivmin ) ) &
                           then
                    m = m + 1
                    w( m ) = d( ibegin )
                    iblock( m ) = jb
                 end if
              else
                 ! general case -- in > 1
                 ! compute gershgorin interval
                 ! and use it as the initial interval
                 gu = d( ibegin )
                 gl = d( ibegin )
                 tmp1 = zero
                 do j = ibegin, iend - 1
                    tmp2 = abs( e( j ) )
                    gu = max( gu, d( j )+tmp1+tmp2 )
                    gl = min( gl, d( j )-tmp1-tmp2 )
                    tmp1 = tmp2
                 end do
                 gu = max( gu, d( iend )+tmp1 )
                 gl = min( gl, d( iend )-tmp1 )
                 bnorm = max( abs( gl ), abs( gu ) )
                 gl = gl - fudge*bnorm*ulp*in - fudge*pivmin
                 gu = gu + fudge*bnorm*ulp*in + fudge*pivmin
                 ! compute atoli for the current submatrix
                 if( abstol<=zero ) then
                    atoli = ulp*max( abs( gl ), abs( gu ) )
                 else
                    atoli = abstol
                 end if
                 if( irange>1 ) then
                    if( gu<wl ) then
                       nwl = nwl + in
                       nwu = nwu + in
                       cycle loop_70
                    end if
                    gl = max( gl, wl )
                    gu = min( gu, wu )
                    if( gl>=gu )cycle loop_70
                 end if
                 ! set up initial interval
                 work( n+1 ) = gl
                 work( n+in+1 ) = gu
                 call stdlib_${ri}$laebz( 1, 0, in, in, 1, nb, atoli, rtoli, pivmin,d( ibegin ), e( &
                 ibegin ), work( ibegin ),idumma, work( n+1 ), work( n+2*in+1 ), im,iwork, w( m+1 &
                           ), iblock( m+1 ), iinfo )
                 nwl = nwl + iwork( 1 )
                 nwu = nwu + iwork( in+1 )
                 iwoff = m - iwork( 1 )
                 ! compute eigenvalues
                 itmax = int( ( log( gu-gl+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + &
                           2
                 call stdlib_${ri}$laebz( 2, itmax, in, in, 1, nb, atoli, rtoli, pivmin,d( ibegin ), e(&
                  ibegin ), work( ibegin ),idumma, work( n+1 ), work( n+2*in+1 ), iout,iwork, w( &
                            m+1 ), iblock( m+1 ), iinfo )
                 ! copy eigenvalues into w and iblock
                 ! use -jb for block number for unconverged eigenvalues.
                 do j = 1, iout
                    tmp1 = half*( work( j+n )+work( j+in+n ) )
                    ! flag non-convergence.
                    if( j>iout-iinfo ) then
                       ncnvrg = .true.
                       ib = -jb
                    else
                       ib = jb
                    end if
                    do je = iwork( j ) + 1 + iwoff,iwork( j+in ) + iwoff
                       w( je ) = tmp1
                       iblock( je ) = ib
                    end do
                 end do
                 m = m + im
              end if
           end do loop_70
           ! if range='i', then (wl,wu) contains eigenvalues nwl+1,...,nwu
           ! if nwl+1 < il or nwu > iu, discard extra eigenvalues.
           if( irange==3 ) then
              im = 0
              idiscl = il - 1 - nwl
              idiscu = nwu - iu
              if( idiscl>0 .or. idiscu>0 ) then
                 do je = 1, m
                    if( w( je )<=wlu .and. idiscl>0 ) then
                       idiscl = idiscl - 1
                    else if( w( je )>=wul .and. idiscu>0 ) then
                       idiscu = idiscu - 1
                    else
                       im = im + 1
                       w( im ) = w( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 m = im
              end if
              if( idiscl>0 .or. idiscu>0 ) then
                 ! code to deal with effects of bad arithmetic:
                 ! some low eigenvalues to be discarded are not in (wl,wlu],
                 ! or high eigenvalues to be discarded are not in (wul,wu]
                 ! so just kill off the smallest idiscl/largest idiscu
                 ! eigenvalues, by simply finding the smallest/largest
                 ! eigenvalue(s).
                 ! (if n(w) is monotone non-decreasing, this should never
                     ! happen.)
                 if( idiscl>0 ) then
                    wkill = wu
                    do jdisc = 1, idiscl
                       iw = 0
                       do je = 1, m
                          if( iblock( je )/=0 .and.( w( je )<wkill .or. iw==0 ) ) then
                             iw = je
                             wkill = w( je )
                          end if
                       end do
                       iblock( iw ) = 0
                    end do
                 end if
                 if( idiscu>0 ) then
                    wkill = wl
                    do jdisc = 1, idiscu
                       iw = 0
                       do je = 1, m
                          if( iblock( je )/=0 .and.( w( je )>wkill .or. iw==0 ) ) then
                             iw = je
                             wkill = w( je )
                          end if
                       end do
                       iblock( iw ) = 0
                    end do
                 end if
                 im = 0
                 do je = 1, m
                    if( iblock( je )/=0 ) then
                       im = im + 1
                       w( im ) = w( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 m = im
              end if
              if( idiscl<0 .or. idiscu<0 ) then
                 toofew = .true.
              end if
           end if
           ! if order='b', do nothing -- the eigenvalues are already sorted
              ! by block.
           ! if order='e', sort the eigenvalues from smallest to largest
           if( iorder==1 .and. nsplit>1 ) then
              do je = 1, m - 1
                 ie = 0
                 tmp1 = w( je )
                 do j = je + 1, m
                    if( w( j )<tmp1 ) then
                       ie = j
                       tmp1 = w( j )
                    end if
                 end do
                 if( ie/=0 ) then
                    itmp1 = iblock( ie )
                    w( ie ) = w( je )
                    iblock( ie ) = iblock( je )
                    w( je ) = tmp1
                    iblock( je ) = itmp1
                 end if
              end do
           end if
           info = 0
           if( ncnvrg )info = info + 1
           if( toofew )info = info + 2
           return
     end subroutine stdlib_${ri}$stebz

#:endif
#:endfor





     pure subroutine stdlib_slaed5( i, d, z, delta, rho, dlam )
     !! This subroutine computes the I-th eigenvalue of a symmetric rank-one
     !! modification of a 2-by-2 diagonal matrix
     !! diag( D )  +  RHO * Z * transpose(Z) .
     !! The diagonal elements in the array D are assumed to satisfy
     !! D(i) < D(j)  for  i < j .
     !! We also assume RHO > 0 and that the Euclidean norm of the vector
     !! Z is one.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: i
           real(sp), intent(out) :: dlam
           real(sp), intent(in) :: rho
           ! Array Arguments 
           real(sp), intent(in) :: d(2), z(2)
           real(sp), intent(out) :: delta(2)
        ! =====================================================================
           
           ! Local Scalars 
           real(sp) :: b, c, del, tau, temp, w
           ! Intrinsic Functions 
           ! Executable Statements 
           del = d( 2 ) - d( 1 )
           if( i==1 ) then
              w = one + two*rho*( z( 2 )*z( 2 )-z( 1 )*z( 1 ) ) / del
              if( w>zero ) then
                 b = del + rho*( z( 1 )*z( 1 )+z( 2 )*z( 2 ) )
                 c = rho*z( 1 )*z( 1 )*del
                 ! b > zero, always
                 tau = two*c / ( b+sqrt( abs( b*b-four*c ) ) )
                 dlam = d( 1 ) + tau
                 delta( 1 ) = -z( 1 ) / tau
                 delta( 2 ) = z( 2 ) / ( del-tau )
              else
                 b = -del + rho*( z( 1 )*z( 1 )+z( 2 )*z( 2 ) )
                 c = rho*z( 2 )*z( 2 )*del
                 if( b>zero ) then
                    tau = -two*c / ( b+sqrt( b*b+four*c ) )
                 else
                    tau = ( b-sqrt( b*b+four*c ) ) / two
                 end if
                 dlam = d( 2 ) + tau
                 delta( 1 ) = -z( 1 ) / ( del+tau )
                 delta( 2 ) = -z( 2 ) / tau
              end if
              temp = sqrt( delta( 1 )*delta( 1 )+delta( 2 )*delta( 2 ) )
              delta( 1 ) = delta( 1 ) / temp
              delta( 2 ) = delta( 2 ) / temp
           else
           ! now i=2
              b = -del + rho*( z( 1 )*z( 1 )+z( 2 )*z( 2 ) )
              c = rho*z( 2 )*z( 2 )*del
              if( b>zero ) then
                 tau = ( b+sqrt( b*b+four*c ) ) / two
              else
                 tau = two*c / ( -b+sqrt( b*b+four*c ) )
              end if
              dlam = d( 2 ) + tau
              delta( 1 ) = -z( 1 ) / ( del+tau )
              delta( 2 ) = -z( 2 ) / tau
              temp = sqrt( delta( 1 )*delta( 1 )+delta( 2 )*delta( 2 ) )
              delta( 1 ) = delta( 1 ) / temp
              delta( 2 ) = delta( 2 ) / temp
           end if
           return
     end subroutine stdlib_slaed5

     pure subroutine stdlib_dlaed5( i, d, z, delta, rho, dlam )
     !! This subroutine computes the I-th eigenvalue of a symmetric rank-one
     !! modification of a 2-by-2 diagonal matrix
     !! diag( D )  +  RHO * Z * transpose(Z) .
     !! The diagonal elements in the array D are assumed to satisfy
     !! D(i) < D(j)  for  i < j .
     !! We also assume RHO > 0 and that the Euclidean norm of the vector
     !! Z is one.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: i
           real(dp), intent(out) :: dlam
           real(dp), intent(in) :: rho
           ! Array Arguments 
           real(dp), intent(in) :: d(2), z(2)
           real(dp), intent(out) :: delta(2)
        ! =====================================================================
           
           ! Local Scalars 
           real(dp) :: b, c, del, tau, temp, w
           ! Intrinsic Functions 
           ! Executable Statements 
           del = d( 2 ) - d( 1 )
           if( i==1 ) then
              w = one + two*rho*( z( 2 )*z( 2 )-z( 1 )*z( 1 ) ) / del
              if( w>zero ) then
                 b = del + rho*( z( 1 )*z( 1 )+z( 2 )*z( 2 ) )
                 c = rho*z( 1 )*z( 1 )*del
                 ! b > zero, always
                 tau = two*c / ( b+sqrt( abs( b*b-four*c ) ) )
                 dlam = d( 1 ) + tau
                 delta( 1 ) = -z( 1 ) / tau
                 delta( 2 ) = z( 2 ) / ( del-tau )
              else
                 b = -del + rho*( z( 1 )*z( 1 )+z( 2 )*z( 2 ) )
                 c = rho*z( 2 )*z( 2 )*del
                 if( b>zero ) then
                    tau = -two*c / ( b+sqrt( b*b+four*c ) )
                 else
                    tau = ( b-sqrt( b*b+four*c ) ) / two
                 end if
                 dlam = d( 2 ) + tau
                 delta( 1 ) = -z( 1 ) / ( del+tau )
                 delta( 2 ) = -z( 2 ) / tau
              end if
              temp = sqrt( delta( 1 )*delta( 1 )+delta( 2 )*delta( 2 ) )
              delta( 1 ) = delta( 1 ) / temp
              delta( 2 ) = delta( 2 ) / temp
           else
           ! now i=2
              b = -del + rho*( z( 1 )*z( 1 )+z( 2 )*z( 2 ) )
              c = rho*z( 2 )*z( 2 )*del
              if( b>zero ) then
                 tau = ( b+sqrt( b*b+four*c ) ) / two
              else
                 tau = two*c / ( -b+sqrt( b*b+four*c ) )
              end if
              dlam = d( 2 ) + tau
              delta( 1 ) = -z( 1 ) / ( del+tau )
              delta( 2 ) = -z( 2 ) / tau
              temp = sqrt( delta( 1 )*delta( 1 )+delta( 2 )*delta( 2 ) )
              delta( 1 ) = delta( 1 ) / temp
              delta( 2 ) = delta( 2 ) / temp
           end if
           return
     end subroutine stdlib_dlaed5

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laed5( i, d, z, delta, rho, dlam )
     !! This subroutine computes the I-th eigenvalue of a symmetric rank-one
     !! modification of a 2-by-2 diagonal matrix
     !! diag( D )  +  RHO * Z * transpose(Z) .
     !! The diagonal elements in the array D are assumed to satisfy
     !! D(i) < D(j)  for  i < j .
     !! We also assume RHO > 0 and that the Euclidean norm of the vector
     !! Z is one.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: i
           real(${rk}$), intent(out) :: dlam
           real(${rk}$), intent(in) :: rho
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(2), z(2)
           real(${rk}$), intent(out) :: delta(2)
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: b, c, del, tau, temp, w
           ! Intrinsic Functions 
           ! Executable Statements 
           del = d( 2 ) - d( 1 )
           if( i==1 ) then
              w = one + two*rho*( z( 2 )*z( 2 )-z( 1 )*z( 1 ) ) / del
              if( w>zero ) then
                 b = del + rho*( z( 1 )*z( 1 )+z( 2 )*z( 2 ) )
                 c = rho*z( 1 )*z( 1 )*del
                 ! b > zero, always
                 tau = two*c / ( b+sqrt( abs( b*b-four*c ) ) )
                 dlam = d( 1 ) + tau
                 delta( 1 ) = -z( 1 ) / tau
                 delta( 2 ) = z( 2 ) / ( del-tau )
              else
                 b = -del + rho*( z( 1 )*z( 1 )+z( 2 )*z( 2 ) )
                 c = rho*z( 2 )*z( 2 )*del
                 if( b>zero ) then
                    tau = -two*c / ( b+sqrt( b*b+four*c ) )
                 else
                    tau = ( b-sqrt( b*b+four*c ) ) / two
                 end if
                 dlam = d( 2 ) + tau
                 delta( 1 ) = -z( 1 ) / ( del+tau )
                 delta( 2 ) = -z( 2 ) / tau
              end if
              temp = sqrt( delta( 1 )*delta( 1 )+delta( 2 )*delta( 2 ) )
              delta( 1 ) = delta( 1 ) / temp
              delta( 2 ) = delta( 2 ) / temp
           else
           ! now i=2
              b = -del + rho*( z( 1 )*z( 1 )+z( 2 )*z( 2 ) )
              c = rho*z( 2 )*z( 2 )*del
              if( b>zero ) then
                 tau = ( b+sqrt( b*b+four*c ) ) / two
              else
                 tau = two*c / ( -b+sqrt( b*b+four*c ) )
              end if
              dlam = d( 2 ) + tau
              delta( 1 ) = -z( 1 ) / ( del+tau )
              delta( 2 ) = -z( 2 ) / tau
              temp = sqrt( delta( 1 )*delta( 1 )+delta( 2 )*delta( 2 ) )
              delta( 1 ) = delta( 1 ) / temp
              delta( 2 ) = delta( 2 ) / temp
           end if
           return
     end subroutine stdlib_${ri}$laed5

#:endif
#:endfor



     pure subroutine stdlib_sdisna( job, m, n, d, sep, info )
     !! SDISNA computes the reciprocal condition numbers for the eigenvectors
     !! of a real symmetric or complex Hermitian matrix or for the left or
     !! right singular vectors of a general m-by-n matrix. The reciprocal
     !! condition number is the 'gap' between the corresponding eigenvalue or
     !! singular value and the nearest other one.
     !! The bound on the error, measured by angle in radians, in the I-th
     !! computed vector is given by
     !! SLAMCH( 'E' ) * ( ANORM / SEP( I ) )
     !! where ANORM = 2-norm(A) = max( abs( D(j) ) ).  SEP(I) is not allowed
     !! to be smaller than SLAMCH( 'E' )*ANORM in order to limit the size of
     !! the error bound.
     !! SDISNA may also be used to compute error bounds for eigenvectors of
     !! the generalized symmetric definite eigenproblem.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: m, n
           ! Array Arguments 
           real(sp), intent(in) :: d(*)
           real(sp), intent(out) :: sep(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: decr, eigen, incr, left, right, sing
           integer(ilp) :: i, k
           real(sp) :: anorm, eps, newgap, oldgap, safmin, thresh
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           eigen = stdlib_lsame( job, 'E' )
           left = stdlib_lsame( job, 'L' )
           right = stdlib_lsame( job, 'R' )
           sing = left .or. right
           if( eigen ) then
              k = m
           else if( sing ) then
              k = min( m, n )
           end if
           if( .not.eigen .and. .not.sing ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( k<0 ) then
              info = -3
           else
              incr = .true.
              decr = .true.
              do i = 1, k - 1
                 if( incr )incr = incr .and. d( i )<=d( i+1 )
                 if( decr )decr = decr .and. d( i )>=d( i+1 )
              end do
              if( sing .and. k>0 ) then
                 if( incr )incr = incr .and. zero<=d( 1 )
                 if( decr )decr = decr .and. d( k )>=zero
              end if
              if( .not.( incr .or. decr ) )info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SDISNA', -info )
              return
           end if
           ! quick return if possible
           if( k==0 )return
           ! compute reciprocal condition numbers
           if( k==1 ) then
              sep( 1 ) = stdlib_slamch( 'O' )
           else
              oldgap = abs( d( 2 )-d( 1 ) )
              sep( 1 ) = oldgap
              do i = 2, k - 1
                 newgap = abs( d( i+1 )-d( i ) )
                 sep( i ) = min( oldgap, newgap )
                 oldgap = newgap
              end do
              sep( k ) = oldgap
           end if
           if( sing ) then
              if( ( left .and. m>n ) .or. ( right .and. m<n ) ) then
                 if( incr )sep( 1 ) = min( sep( 1 ), d( 1 ) )
                 if( decr )sep( k ) = min( sep( k ), d( k ) )
              end if
           end if
           ! ensure that reciprocal condition numbers are not less than
           ! threshold, in order to limit the size of the error bound
           eps = stdlib_slamch( 'E' )
           safmin = stdlib_slamch( 'S' )
           anorm = max( abs( d( 1 ) ), abs( d( k ) ) )
           if( anorm==zero ) then
              thresh = eps
           else
              thresh = max( eps*anorm, safmin )
           end if
           do i = 1, k
              sep( i ) = max( sep( i ), thresh )
           end do
           return
     end subroutine stdlib_sdisna

     pure subroutine stdlib_ddisna( job, m, n, d, sep, info )
     !! DDISNA computes the reciprocal condition numbers for the eigenvectors
     !! of a real symmetric or complex Hermitian matrix or for the left or
     !! right singular vectors of a general m-by-n matrix. The reciprocal
     !! condition number is the 'gap' between the corresponding eigenvalue or
     !! singular value and the nearest other one.
     !! The bound on the error, measured by angle in radians, in the I-th
     !! computed vector is given by
     !! DLAMCH( 'E' ) * ( ANORM / SEP( I ) )
     !! where ANORM = 2-norm(A) = max( abs( D(j) ) ).  SEP(I) is not allowed
     !! to be smaller than DLAMCH( 'E' )*ANORM in order to limit the size of
     !! the error bound.
     !! DDISNA may also be used to compute error bounds for eigenvectors of
     !! the generalized symmetric definite eigenproblem.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: m, n
           ! Array Arguments 
           real(dp), intent(in) :: d(*)
           real(dp), intent(out) :: sep(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: decr, eigen, incr, left, right, sing
           integer(ilp) :: i, k
           real(dp) :: anorm, eps, newgap, oldgap, safmin, thresh
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           eigen = stdlib_lsame( job, 'E' )
           left = stdlib_lsame( job, 'L' )
           right = stdlib_lsame( job, 'R' )
           sing = left .or. right
           if( eigen ) then
              k = m
           else if( sing ) then
              k = min( m, n )
           end if
           if( .not.eigen .and. .not.sing ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( k<0 ) then
              info = -3
           else
              incr = .true.
              decr = .true.
              do i = 1, k - 1
                 if( incr )incr = incr .and. d( i )<=d( i+1 )
                 if( decr )decr = decr .and. d( i )>=d( i+1 )
              end do
              if( sing .and. k>0 ) then
                 if( incr )incr = incr .and. zero<=d( 1 )
                 if( decr )decr = decr .and. d( k )>=zero
              end if
              if( .not.( incr .or. decr ) )info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DDISNA', -info )
              return
           end if
           ! quick return if possible
           if( k==0 )return
           ! compute reciprocal condition numbers
           if( k==1 ) then
              sep( 1 ) = stdlib_dlamch( 'O' )
           else
              oldgap = abs( d( 2 )-d( 1 ) )
              sep( 1 ) = oldgap
              do i = 2, k - 1
                 newgap = abs( d( i+1 )-d( i ) )
                 sep( i ) = min( oldgap, newgap )
                 oldgap = newgap
              end do
              sep( k ) = oldgap
           end if
           if( sing ) then
              if( ( left .and. m>n ) .or. ( right .and. m<n ) ) then
                 if( incr )sep( 1 ) = min( sep( 1 ), d( 1 ) )
                 if( decr )sep( k ) = min( sep( k ), d( k ) )
              end if
           end if
           ! ensure that reciprocal condition numbers are not less than
           ! threshold, in order to limit the size of the error bound
           eps = stdlib_dlamch( 'E' )
           safmin = stdlib_dlamch( 'S' )
           anorm = max( abs( d( 1 ) ), abs( d( k ) ) )
           if( anorm==zero ) then
              thresh = eps
           else
              thresh = max( eps*anorm, safmin )
           end if
           do i = 1, k
              sep( i ) = max( sep( i ), thresh )
           end do
           return
     end subroutine stdlib_ddisna

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$disna( job, m, n, d, sep, info )
     !! DDISNA: computes the reciprocal condition numbers for the eigenvectors
     !! of a real symmetric or complex Hermitian matrix or for the left or
     !! right singular vectors of a general m-by-n matrix. The reciprocal
     !! condition number is the 'gap' between the corresponding eigenvalue or
     !! singular value and the nearest other one.
     !! The bound on the error, measured by angle in radians, in the I-th
     !! computed vector is given by
     !! DLAMCH( 'E' ) * ( ANORM / SEP( I ) )
     !! where ANORM = 2-norm(A) = max( abs( D(j) ) ).  SEP(I) is not allowed
     !! to be smaller than DLAMCH( 'E' )*ANORM in order to limit the size of
     !! the error bound.
     !! DDISNA may also be used to compute error bounds for eigenvectors of
     !! the generalized symmetric definite eigenproblem.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: m, n
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(*)
           real(${rk}$), intent(out) :: sep(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: decr, eigen, incr, left, right, sing
           integer(ilp) :: i, k
           real(${rk}$) :: anorm, eps, newgap, oldgap, safmin, thresh
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           eigen = stdlib_lsame( job, 'E' )
           left = stdlib_lsame( job, 'L' )
           right = stdlib_lsame( job, 'R' )
           sing = left .or. right
           if( eigen ) then
              k = m
           else if( sing ) then
              k = min( m, n )
           end if
           if( .not.eigen .and. .not.sing ) then
              info = -1
           else if( m<0 ) then
              info = -2
           else if( k<0 ) then
              info = -3
           else
              incr = .true.
              decr = .true.
              do i = 1, k - 1
                 if( incr )incr = incr .and. d( i )<=d( i+1 )
                 if( decr )decr = decr .and. d( i )>=d( i+1 )
              end do
              if( sing .and. k>0 ) then
                 if( incr )incr = incr .and. zero<=d( 1 )
                 if( decr )decr = decr .and. d( k )>=zero
              end if
              if( .not.( incr .or. decr ) )info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DDISNA', -info )
              return
           end if
           ! quick return if possible
           if( k==0 )return
           ! compute reciprocal condition numbers
           if( k==1 ) then
              sep( 1 ) = stdlib_${ri}$lamch( 'O' )
           else
              oldgap = abs( d( 2 )-d( 1 ) )
              sep( 1 ) = oldgap
              do i = 2, k - 1
                 newgap = abs( d( i+1 )-d( i ) )
                 sep( i ) = min( oldgap, newgap )
                 oldgap = newgap
              end do
              sep( k ) = oldgap
           end if
           if( sing ) then
              if( ( left .and. m>n ) .or. ( right .and. m<n ) ) then
                 if( incr )sep( 1 ) = min( sep( 1 ), d( 1 ) )
                 if( decr )sep( k ) = min( sep( k ), d( k ) )
              end if
           end if
           ! ensure that reciprocal condition numbers are not less than
           ! threshold, in order to limit the size of the error bound
           eps = stdlib_${ri}$lamch( 'E' )
           safmin = stdlib_${ri}$lamch( 'S' )
           anorm = max( abs( d( 1 ) ), abs( d( k ) ) )
           if( anorm==zero ) then
              thresh = eps
           else
              thresh = max( eps*anorm, safmin )
           end if
           do i = 1, k
              sep( i ) = max( sep( i ), thresh )
           end do
           return
     end subroutine stdlib_${ri}$disna

#:endif
#:endfor



     pure subroutine stdlib_slaed9( k, kstart, kstop, n, d, q, ldq, rho, dlamda, w,s, lds, info )
     !! SLAED9 finds the roots of the secular equation, as defined by the
     !! values in D, Z, and RHO, between KSTART and KSTOP.  It makes the
     !! appropriate calls to SLAED4 and then stores the new matrix of
     !! eigenvectors for use in calculating the next level of Z vectors.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, kstart, kstop, ldq, lds, n
           real(sp), intent(in) :: rho
           ! Array Arguments 
           real(sp), intent(out) :: d(*), q(ldq,*), s(lds,*)
           real(sp), intent(inout) :: dlamda(*), w(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           real(sp) :: temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( k<0 ) then
              info = -1
           else if( kstart<1 .or. kstart>max( 1, k ) ) then
              info = -2
           else if( max( 1, kstop )<kstart .or. kstop>max( 1, k ) )then
              info = -3
           else if( n<k ) then
              info = -4
           else if( ldq<max( 1, k ) ) then
              info = -7
           else if( lds<max( 1, k ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SLAED9', -info )
              return
           end if
           ! quick return if possible
           if( k==0 )return
           ! modify values dlamda(i) to make sure all dlamda(i)-dlamda(j) can
           ! be computed with high relative accuracy (barring over/underflow).
           ! this is a problem on machines without a guard digit in
           ! add/subtract (cray xmp, cray ymp, cray c 90 and cray 2).
           ! the following code replaces dlamda(i) by 2*dlamda(i)-dlamda(i),
           ! which on any of these machines zeros out the bottommost
           ! bit of dlamda(i) if it is 1; this makes the subsequent
           ! subtractions dlamda(i)-dlamda(j) unproblematic when cancellation
           ! occurs. on binary machines with a guard digit (almost all
           ! machines) it does not change dlamda(i) at all. on hexadecimal
           ! and decimal machines with a guard digit, it slightly
           ! changes the bottommost bits of dlamda(i). it does not account
           ! for hexadecimal or decimal machines without guard digits
           ! (we know of none). we use a subroutine call to compute
           ! 2*dlambda(i) to prevent optimizing compilers from eliminating
           ! this code.
           do i = 1, n
              dlamda( i ) = stdlib_slamc3( dlamda( i ), dlamda( i ) ) - dlamda( i )
           end do
           do j = kstart, kstop
              call stdlib_slaed4( k, j, dlamda, w, q( 1, j ), rho, d( j ), info )
              ! if the zero finder fails, the computation is terminated.
              if( info/=0 )go to 120
           end do
           if( k==1 .or. k==2 ) then
              do i = 1, k
                 do j = 1, k
                    s( j, i ) = q( j, i )
                 end do
              end do
              go to 120
           end if
           ! compute updated w.
           call stdlib_scopy( k, w, 1, s, 1 )
           ! initialize w(i) = q(i,i)
           call stdlib_scopy( k, q, ldq+1, w, 1 )
           do j = 1, k
              do i = 1, j - 1
                 w( i ) = w( i )*( q( i, j ) / ( dlamda( i )-dlamda( j ) ) )
              end do
              do i = j + 1, k
                 w( i ) = w( i )*( q( i, j ) / ( dlamda( i )-dlamda( j ) ) )
              end do
           end do
           do i = 1, k
              w( i ) = sign( sqrt( -w( i ) ), s( i, 1 ) )
           end do
           ! compute eigenvectors of the modified rank-1 modification.
           do j = 1, k
              do i = 1, k
                 q( i, j ) = w( i ) / q( i, j )
              end do
              temp = stdlib_snrm2( k, q( 1, j ), 1 )
              do i = 1, k
                 s( i, j ) = q( i, j ) / temp
              end do
           end do
           120 continue
           return
     end subroutine stdlib_slaed9

     pure subroutine stdlib_dlaed9( k, kstart, kstop, n, d, q, ldq, rho, dlamda, w,s, lds, info )
     !! DLAED9 finds the roots of the secular equation, as defined by the
     !! values in D, Z, and RHO, between KSTART and KSTOP.  It makes the
     !! appropriate calls to DLAED4 and then stores the new matrix of
     !! eigenvectors for use in calculating the next level of Z vectors.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, kstart, kstop, ldq, lds, n
           real(dp), intent(in) :: rho
           ! Array Arguments 
           real(dp), intent(out) :: d(*), q(ldq,*), s(lds,*)
           real(dp), intent(inout) :: dlamda(*), w(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           real(dp) :: temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( k<0 ) then
              info = -1
           else if( kstart<1 .or. kstart>max( 1, k ) ) then
              info = -2
           else if( max( 1, kstop )<kstart .or. kstop>max( 1, k ) )then
              info = -3
           else if( n<k ) then
              info = -4
           else if( ldq<max( 1, k ) ) then
              info = -7
           else if( lds<max( 1, k ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED9', -info )
              return
           end if
           ! quick return if possible
           if( k==0 )return
           ! modify values dlamda(i) to make sure all dlamda(i)-dlamda(j) can
           ! be computed with high relative accuracy (barring over/underflow).
           ! this is a problem on machines without a guard digit in
           ! add/subtract (cray xmp, cray ymp, cray c 90 and cray 2).
           ! the following code replaces dlamda(i) by 2*dlamda(i)-dlamda(i),
           ! which on any of these machines zeros out the bottommost
           ! bit of dlamda(i) if it is 1; this makes the subsequent
           ! subtractions dlamda(i)-dlamda(j) unproblematic when cancellation
           ! occurs. on binary machines with a guard digit (almost all
           ! machines) it does not change dlamda(i) at all. on hexadecimal
           ! and decimal machines with a guard digit, it slightly
           ! changes the bottommost bits of dlamda(i). it does not account
           ! for hexadecimal or decimal machines without guard digits
           ! (we know of none). we use a subroutine call to compute
           ! 2*dlambda(i) to prevent optimizing compilers from eliminating
           ! this code.
           do i = 1, n
              dlamda( i ) = stdlib_dlamc3( dlamda( i ), dlamda( i ) ) - dlamda( i )
           end do
           do j = kstart, kstop
              call stdlib_dlaed4( k, j, dlamda, w, q( 1, j ), rho, d( j ), info )
              ! if the zero finder fails, the computation is terminated.
              if( info/=0 )go to 120
           end do
           if( k==1 .or. k==2 ) then
              do i = 1, k
                 do j = 1, k
                    s( j, i ) = q( j, i )
                 end do
              end do
              go to 120
           end if
           ! compute updated w.
           call stdlib_dcopy( k, w, 1, s, 1 )
           ! initialize w(i) = q(i,i)
           call stdlib_dcopy( k, q, ldq+1, w, 1 )
           do j = 1, k
              do i = 1, j - 1
                 w( i ) = w( i )*( q( i, j ) / ( dlamda( i )-dlamda( j ) ) )
              end do
              do i = j + 1, k
                 w( i ) = w( i )*( q( i, j ) / ( dlamda( i )-dlamda( j ) ) )
              end do
           end do
           do i = 1, k
              w( i ) = sign( sqrt( -w( i ) ), s( i, 1 ) )
           end do
           ! compute eigenvectors of the modified rank-1 modification.
           do j = 1, k
              do i = 1, k
                 q( i, j ) = w( i ) / q( i, j )
              end do
              temp = stdlib_dnrm2( k, q( 1, j ), 1 )
              do i = 1, k
                 s( i, j ) = q( i, j ) / temp
              end do
           end do
           120 continue
           return
     end subroutine stdlib_dlaed9

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laed9( k, kstart, kstop, n, d, q, ldq, rho, dlamda, w,s, lds, info )
     !! DLAED9: finds the roots of the secular equation, as defined by the
     !! values in D, Z, and RHO, between KSTART and KSTOP.  It makes the
     !! appropriate calls to DLAED4 and then stores the new matrix of
     !! eigenvectors for use in calculating the next level of Z vectors.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, kstart, kstop, ldq, lds, n
           real(${rk}$), intent(in) :: rho
           ! Array Arguments 
           real(${rk}$), intent(out) :: d(*), q(ldq,*), s(lds,*)
           real(${rk}$), intent(inout) :: dlamda(*), w(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, j
           real(${rk}$) :: temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( k<0 ) then
              info = -1
           else if( kstart<1 .or. kstart>max( 1, k ) ) then
              info = -2
           else if( max( 1, kstop )<kstart .or. kstop>max( 1, k ) )then
              info = -3
           else if( n<k ) then
              info = -4
           else if( ldq<max( 1, k ) ) then
              info = -7
           else if( lds<max( 1, k ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED9', -info )
              return
           end if
           ! quick return if possible
           if( k==0 )return
           ! modify values dlamda(i) to make sure all dlamda(i)-dlamda(j) can
           ! be computed with high relative accuracy (barring over/underflow).
           ! this is a problem on machines without a guard digit in
           ! add/subtract (cray xmp, cray ymp, cray c 90 and cray 2).
           ! the following code replaces dlamda(i) by 2*dlamda(i)-dlamda(i),
           ! which on any of these machines zeros out the bottommost
           ! bit of dlamda(i) if it is 1; this makes the subsequent
           ! subtractions dlamda(i)-dlamda(j) unproblematic when cancellation
           ! occurs. on binary machines with a guard digit (almost all
           ! machines) it does not change dlamda(i) at all. on hexadecimal
           ! and decimal machines with a guard digit, it slightly
           ! changes the bottommost bits of dlamda(i). it does not account
           ! for hexadecimal or decimal machines without guard digits
           ! (we know of none). we use a subroutine call to compute
           ! 2*dlambda(i) to prevent optimizing compilers from eliminating
           ! this code.
           do i = 1, n
              dlamda( i ) = stdlib_${ri}$lamc3( dlamda( i ), dlamda( i ) ) - dlamda( i )
           end do
           do j = kstart, kstop
              call stdlib_${ri}$laed4( k, j, dlamda, w, q( 1, j ), rho, d( j ), info )
              ! if the zero finder fails, the computation is terminated.
              if( info/=0 )go to 120
           end do
           if( k==1 .or. k==2 ) then
              do i = 1, k
                 do j = 1, k
                    s( j, i ) = q( j, i )
                 end do
              end do
              go to 120
           end if
           ! compute updated w.
           call stdlib_${ri}$copy( k, w, 1, s, 1 )
           ! initialize w(i) = q(i,i)
           call stdlib_${ri}$copy( k, q, ldq+1, w, 1 )
           do j = 1, k
              do i = 1, j - 1
                 w( i ) = w( i )*( q( i, j ) / ( dlamda( i )-dlamda( j ) ) )
              end do
              do i = j + 1, k
                 w( i ) = w( i )*( q( i, j ) / ( dlamda( i )-dlamda( j ) ) )
              end do
           end do
           do i = 1, k
              w( i ) = sign( sqrt( -w( i ) ), s( i, 1 ) )
           end do
           ! compute eigenvectors of the modified rank-1 modification.
           do j = 1, k
              do i = 1, k
                 q( i, j ) = w( i ) / q( i, j )
              end do
              temp = stdlib_${ri}$nrm2( k, q( 1, j ), 1 )
              do i = 1, k
                 s( i, j ) = q( i, j ) / temp
              end do
           end do
           120 continue
           return
     end subroutine stdlib_${ri}$laed9

#:endif
#:endfor



     pure subroutine stdlib_ssytd2( uplo, n, a, lda, d, e, tau, info )
     !! SSYTD2 reduces a real symmetric matrix A to symmetric tridiagonal
     !! form T by an orthogonal similarity transformation: Q**T * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: d(*), e(*), tau(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           real(sp) :: alpha, taui
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYTD2', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           if( upper ) then
              ! reduce the upper triangle of a
              do i = n - 1, 1, -1
                 ! generate elementary reflector h(i) = i - tau * v * v**t
                 ! to annihilate a(1:i-1,i+1)
                 call stdlib_slarfg( i, a( i, i+1 ), a( 1, i+1 ), 1, taui )
                 e( i ) = a( i, i+1 )
                 if( taui/=zero ) then
                    ! apply h(i) from both sides to a(1:i,1:i)
                    a( i, i+1 ) = one
                    ! compute  x := tau * a * v  storing x in tau(1:i)
                    call stdlib_ssymv( uplo, i, taui, a, lda, a( 1, i+1 ), 1, zero,tau, 1 )
                              
                    ! compute  w := x - 1/2 * tau * (x**t * v) * v
                    alpha = -half*taui*stdlib_sdot( i, tau, 1, a( 1, i+1 ), 1 )
                    call stdlib_saxpy( i, alpha, a( 1, i+1 ), 1, tau, 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**t - w * v**t
                    call stdlib_ssyr2( uplo, i, -one, a( 1, i+1 ), 1, tau, 1, a,lda )
                    a( i, i+1 ) = e( i )
                 end if
                 d( i+1 ) = a( i+1, i+1 )
                 tau( i ) = taui
              end do
              d( 1 ) = a( 1, 1 )
           else
              ! reduce the lower triangle of a
              do i = 1, n - 1
                 ! generate elementary reflector h(i) = i - tau * v * v**t
                 ! to annihilate a(i+2:n,i)
                 call stdlib_slarfg( n-i, a( i+1, i ), a( min( i+2, n ), i ), 1,taui )
                 e( i ) = a( i+1, i )
                 if( taui/=zero ) then
                    ! apply h(i) from both sides to a(i+1:n,i+1:n)
                    a( i+1, i ) = one
                    ! compute  x := tau * a * v  storing y in tau(i:n-1)
                    call stdlib_ssymv( uplo, n-i, taui, a( i+1, i+1 ), lda,a( i+1, i ), 1, zero, &
                              tau( i ), 1 )
                    ! compute  w := x - 1/2 * tau * (x**t * v) * v
                    alpha = -half*taui*stdlib_sdot( n-i, tau( i ), 1, a( i+1, i ),1 )
                    call stdlib_saxpy( n-i, alpha, a( i+1, i ), 1, tau( i ), 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**t - w * v**t
                    call stdlib_ssyr2( uplo, n-i, -one, a( i+1, i ), 1, tau( i ), 1,a( i+1, i+1 ),&
                               lda )
                    a( i+1, i ) = e( i )
                 end if
                 d( i ) = a( i, i )
                 tau( i ) = taui
              end do
              d( n ) = a( n, n )
           end if
           return
     end subroutine stdlib_ssytd2

     pure subroutine stdlib_dsytd2( uplo, n, a, lda, d, e, tau, info )
     !! DSYTD2 reduces a real symmetric matrix A to symmetric tridiagonal
     !! form T by an orthogonal similarity transformation: Q**T * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: d(*), e(*), tau(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           real(dp) :: alpha, taui
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTD2', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           if( upper ) then
              ! reduce the upper triangle of a
              do i = n - 1, 1, -1
                 ! generate elementary reflector h(i) = i - tau * v * v**t
                 ! to annihilate a(1:i-1,i+1)
                 call stdlib_dlarfg( i, a( i, i+1 ), a( 1, i+1 ), 1, taui )
                 e( i ) = a( i, i+1 )
                 if( taui/=zero ) then
                    ! apply h(i) from both sides to a(1:i,1:i)
                    a( i, i+1 ) = one
                    ! compute  x := tau * a * v  storing x in tau(1:i)
                    call stdlib_dsymv( uplo, i, taui, a, lda, a( 1, i+1 ), 1, zero,tau, 1 )
                              
                    ! compute  w := x - 1/2 * tau * (x**t * v) * v
                    alpha = -half*taui*stdlib_ddot( i, tau, 1, a( 1, i+1 ), 1 )
                    call stdlib_daxpy( i, alpha, a( 1, i+1 ), 1, tau, 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**t - w * v**t
                    call stdlib_dsyr2( uplo, i, -one, a( 1, i+1 ), 1, tau, 1, a,lda )
                    a( i, i+1 ) = e( i )
                 end if
                 d( i+1 ) = a( i+1, i+1 )
                 tau( i ) = taui
              end do
              d( 1 ) = a( 1, 1 )
           else
              ! reduce the lower triangle of a
              do i = 1, n - 1
                 ! generate elementary reflector h(i) = i - tau * v * v**t
                 ! to annihilate a(i+2:n,i)
                 call stdlib_dlarfg( n-i, a( i+1, i ), a( min( i+2, n ), i ), 1,taui )
                 e( i ) = a( i+1, i )
                 if( taui/=zero ) then
                    ! apply h(i) from both sides to a(i+1:n,i+1:n)
                    a( i+1, i ) = one
                    ! compute  x := tau * a * v  storing y in tau(i:n-1)
                    call stdlib_dsymv( uplo, n-i, taui, a( i+1, i+1 ), lda,a( i+1, i ), 1, zero, &
                              tau( i ), 1 )
                    ! compute  w := x - 1/2 * tau * (x**t * v) * v
                    alpha = -half*taui*stdlib_ddot( n-i, tau( i ), 1, a( i+1, i ),1 )
                    call stdlib_daxpy( n-i, alpha, a( i+1, i ), 1, tau( i ), 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**t - w * v**t
                    call stdlib_dsyr2( uplo, n-i, -one, a( i+1, i ), 1, tau( i ), 1,a( i+1, i+1 ),&
                               lda )
                    a( i+1, i ) = e( i )
                 end if
                 d( i ) = a( i, i )
                 tau( i ) = taui
              end do
              d( n ) = a( n, n )
           end if
           return
     end subroutine stdlib_dsytd2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$sytd2( uplo, n, a, lda, d, e, tau, info )
     !! DSYTD2: reduces a real symmetric matrix A to symmetric tridiagonal
     !! form T by an orthogonal similarity transformation: Q**T * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: d(*), e(*), tau(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i
           real(${rk}$) :: alpha, taui
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTD2', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           if( upper ) then
              ! reduce the upper triangle of a
              do i = n - 1, 1, -1
                 ! generate elementary reflector h(i) = i - tau * v * v**t
                 ! to annihilate a(1:i-1,i+1)
                 call stdlib_${ri}$larfg( i, a( i, i+1 ), a( 1, i+1 ), 1, taui )
                 e( i ) = a( i, i+1 )
                 if( taui/=zero ) then
                    ! apply h(i) from both sides to a(1:i,1:i)
                    a( i, i+1 ) = one
                    ! compute  x := tau * a * v  storing x in tau(1:i)
                    call stdlib_${ri}$symv( uplo, i, taui, a, lda, a( 1, i+1 ), 1, zero,tau, 1 )
                              
                    ! compute  w := x - 1/2 * tau * (x**t * v) * v
                    alpha = -half*taui*stdlib_${ri}$dot( i, tau, 1, a( 1, i+1 ), 1 )
                    call stdlib_${ri}$axpy( i, alpha, a( 1, i+1 ), 1, tau, 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**t - w * v**t
                    call stdlib_${ri}$syr2( uplo, i, -one, a( 1, i+1 ), 1, tau, 1, a,lda )
                    a( i, i+1 ) = e( i )
                 end if
                 d( i+1 ) = a( i+1, i+1 )
                 tau( i ) = taui
              end do
              d( 1 ) = a( 1, 1 )
           else
              ! reduce the lower triangle of a
              do i = 1, n - 1
                 ! generate elementary reflector h(i) = i - tau * v * v**t
                 ! to annihilate a(i+2:n,i)
                 call stdlib_${ri}$larfg( n-i, a( i+1, i ), a( min( i+2, n ), i ), 1,taui )
                 e( i ) = a( i+1, i )
                 if( taui/=zero ) then
                    ! apply h(i) from both sides to a(i+1:n,i+1:n)
                    a( i+1, i ) = one
                    ! compute  x := tau * a * v  storing y in tau(i:n-1)
                    call stdlib_${ri}$symv( uplo, n-i, taui, a( i+1, i+1 ), lda,a( i+1, i ), 1, zero, &
                              tau( i ), 1 )
                    ! compute  w := x - 1/2 * tau * (x**t * v) * v
                    alpha = -half*taui*stdlib_${ri}$dot( n-i, tau( i ), 1, a( i+1, i ),1 )
                    call stdlib_${ri}$axpy( n-i, alpha, a( i+1, i ), 1, tau( i ), 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**t - w * v**t
                    call stdlib_${ri}$syr2( uplo, n-i, -one, a( i+1, i ), 1, tau( i ), 1,a( i+1, i+1 ),&
                               lda )
                    a( i+1, i ) = e( i )
                 end if
                 d( i ) = a( i, i )
                 tau( i ) = taui
              end do
              d( n ) = a( n, n )
           end if
           return
     end subroutine stdlib_${ri}$sytd2

#:endif
#:endfor



     pure subroutine stdlib_chptrd( uplo, n, ap, d, e, tau, info )
     !! CHPTRD reduces a complex Hermitian matrix A stored in packed form to
     !! real symmetric tridiagonal form T by a unitary similarity
     !! transformation: Q**H * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: ap(*)
           complex(sp), intent(out) :: tau(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, i1, i1i1, ii
           complex(sp) :: alpha, taui
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPTRD', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           if( upper ) then
              ! reduce the upper triangle of a.
              ! i1 is the index in ap of a(1,i+1).
              i1 = n*( n-1 ) / 2 + 1
              ap( i1+n-1 ) = real( ap( i1+n-1 ),KIND=sp)
              do i = n - 1, 1, -1
                 ! generate elementary reflector h(i) = i - tau * v * v**h
                 ! to annihilate a(1:i-1,i+1)
                 alpha = ap( i1+i-1 )
                 call stdlib_clarfg( i, alpha, ap( i1 ), 1, taui )
                 e( i ) = real( alpha,KIND=sp)
                 if( taui/=czero ) then
                    ! apply h(i) from both sides to a(1:i,1:i)
                    ap( i1+i-1 ) = cone
                    ! compute  y := tau * a * v  storing y in tau(1:i)
                    call stdlib_chpmv( uplo, i, taui, ap, ap( i1 ), 1, czero, tau,1 )
                    ! compute  w := y - 1/2 * tau * (y**h *v) * v
                    alpha = -chalf*taui*stdlib_cdotc( i, tau, 1, ap( i1 ), 1 )
                    call stdlib_caxpy( i, alpha, ap( i1 ), 1, tau, 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**h - w * v**h
                    call stdlib_chpr2( uplo, i, -cone, ap( i1 ), 1, tau, 1, ap )
                 end if
                 ap( i1+i-1 ) = e( i )
                 d( i+1 ) = real( ap( i1+i ),KIND=sp)
                 tau( i ) = taui
                 i1 = i1 - i
              end do
              d( 1 ) = real( ap( 1 ),KIND=sp)
           else
              ! reduce the lower triangle of a. ii is the index in ap of
              ! a(i,i) and i1i1 is the index of a(i+1,i+1).
              ii = 1
              ap( 1 ) = real( ap( 1 ),KIND=sp)
              do i = 1, n - 1
                 i1i1 = ii + n - i + 1
                 ! generate elementary reflector h(i) = i - tau * v * v**h
                 ! to annihilate a(i+2:n,i)
                 alpha = ap( ii+1 )
                 call stdlib_clarfg( n-i, alpha, ap( ii+2 ), 1, taui )
                 e( i ) = real( alpha,KIND=sp)
                 if( taui/=czero ) then
                    ! apply h(i) from both sides to a(i+1:n,i+1:n)
                    ap( ii+1 ) = cone
                    ! compute  y := tau * a * v  storing y in tau(i:n-1)
                    call stdlib_chpmv( uplo, n-i, taui, ap( i1i1 ), ap( ii+1 ), 1,czero, tau( i ),&
                               1 )
                    ! compute  w := y - 1/2 * tau * (y**h *v) * v
                    alpha = -chalf*taui*stdlib_cdotc( n-i, tau( i ), 1, ap( ii+1 ),1 )
                    call stdlib_caxpy( n-i, alpha, ap( ii+1 ), 1, tau( i ), 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**h - w * v**h
                    call stdlib_chpr2( uplo, n-i, -cone, ap( ii+1 ), 1, tau( i ), 1,ap( i1i1 ) )
                              
                 end if
                 ap( ii+1 ) = e( i )
                 d( i ) = real( ap( ii ),KIND=sp)
                 tau( i ) = taui
                 ii = i1i1
              end do
              d( n ) = real( ap( ii ),KIND=sp)
           end if
           return
     end subroutine stdlib_chptrd

     pure subroutine stdlib_zhptrd( uplo, n, ap, d, e, tau, info )
     !! ZHPTRD reduces a complex Hermitian matrix A stored in packed form to
     !! real symmetric tridiagonal form T by a unitary similarity
     !! transformation: Q**H * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(dp), intent(out) :: d(*), e(*)
           complex(dp), intent(inout) :: ap(*)
           complex(dp), intent(out) :: tau(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, i1, i1i1, ii
           complex(dp) :: alpha, taui
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHPTRD', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           if( upper ) then
              ! reduce the upper triangle of a.
              ! i1 is the index in ap of a(1,i+1).
              i1 = n*( n-1 ) / 2 + 1
              ap( i1+n-1 ) = real( ap( i1+n-1 ),KIND=dp)
              do i = n - 1, 1, -1
                 ! generate elementary reflector h(i) = i - tau * v * v**h
                 ! to annihilate a(1:i-1,i+1)
                 alpha = ap( i1+i-1 )
                 call stdlib_zlarfg( i, alpha, ap( i1 ), 1, taui )
                 e( i ) = real( alpha,KIND=dp)
                 if( taui/=czero ) then
                    ! apply h(i) from both sides to a(1:i,1:i)
                    ap( i1+i-1 ) = cone
                    ! compute  y := tau * a * v  storing y in tau(1:i)
                    call stdlib_zhpmv( uplo, i, taui, ap, ap( i1 ), 1, czero, tau,1 )
                    ! compute  w := y - 1/2 * tau * (y**h *v) * v
                    alpha = -chalf*taui*stdlib_zdotc( i, tau, 1, ap( i1 ), 1 )
                    call stdlib_zaxpy( i, alpha, ap( i1 ), 1, tau, 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**h - w * v**h
                    call stdlib_zhpr2( uplo, i, -cone, ap( i1 ), 1, tau, 1, ap )
                 end if
                 ap( i1+i-1 ) = e( i )
                 d( i+1 ) = real( ap( i1+i ),KIND=dp)
                 tau( i ) = taui
                 i1 = i1 - i
              end do
              d( 1 ) = real( ap( 1 ),KIND=dp)
           else
              ! reduce the lower triangle of a. ii is the index in ap of
              ! a(i,i) and i1i1 is the index of a(i+1,i+1).
              ii = 1
              ap( 1 ) = real( ap( 1 ),KIND=dp)
              do i = 1, n - 1
                 i1i1 = ii + n - i + 1
                 ! generate elementary reflector h(i) = i - tau * v * v**h
                 ! to annihilate a(i+2:n,i)
                 alpha = ap( ii+1 )
                 call stdlib_zlarfg( n-i, alpha, ap( ii+2 ), 1, taui )
                 e( i ) = real( alpha,KIND=dp)
                 if( taui/=czero ) then
                    ! apply h(i) from both sides to a(i+1:n,i+1:n)
                    ap( ii+1 ) = cone
                    ! compute  y := tau * a * v  storing y in tau(i:n-1)
                    call stdlib_zhpmv( uplo, n-i, taui, ap( i1i1 ), ap( ii+1 ), 1,czero, tau( i ),&
                               1 )
                    ! compute  w := y - 1/2 * tau * (y**h *v) * v
                    alpha = -chalf*taui*stdlib_zdotc( n-i, tau( i ), 1, ap( ii+1 ),1 )
                    call stdlib_zaxpy( n-i, alpha, ap( ii+1 ), 1, tau( i ), 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**h - w * v**h
                    call stdlib_zhpr2( uplo, n-i, -cone, ap( ii+1 ), 1, tau( i ), 1,ap( i1i1 ) )
                              
                 end if
                 ap( ii+1 ) = e( i )
                 d( i ) = real( ap( ii ),KIND=dp)
                 tau( i ) = taui
                 ii = i1i1
              end do
              d( n ) = real( ap( ii ),KIND=dp)
           end if
           return
     end subroutine stdlib_zhptrd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$hptrd( uplo, n, ap, d, e, tau, info )
     !! ZHPTRD: reduces a complex Hermitian matrix A stored in packed form to
     !! real symmetric tridiagonal form T by a unitary similarity
     !! transformation: Q**H * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${ck}$), intent(out) :: d(*), e(*)
           complex(${ck}$), intent(inout) :: ap(*)
           complex(${ck}$), intent(out) :: tau(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, i1, i1i1, ii
           complex(${ck}$) :: alpha, taui
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHPTRD', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           if( upper ) then
              ! reduce the upper triangle of a.
              ! i1 is the index in ap of a(1,i+1).
              i1 = n*( n-1 ) / 2 + 1
              ap( i1+n-1 ) = real( ap( i1+n-1 ),KIND=${ck}$)
              do i = n - 1, 1, -1
                 ! generate elementary reflector h(i) = i - tau * v * v**h
                 ! to annihilate a(1:i-1,i+1)
                 alpha = ap( i1+i-1 )
                 call stdlib_${ci}$larfg( i, alpha, ap( i1 ), 1, taui )
                 e( i ) = real( alpha,KIND=${ck}$)
                 if( taui/=czero ) then
                    ! apply h(i) from both sides to a(1:i,1:i)
                    ap( i1+i-1 ) = cone
                    ! compute  y := tau * a * v  storing y in tau(1:i)
                    call stdlib_${ci}$hpmv( uplo, i, taui, ap, ap( i1 ), 1, czero, tau,1 )
                    ! compute  w := y - 1/2 * tau * (y**h *v) * v
                    alpha = -chalf*taui*stdlib_${ci}$dotc( i, tau, 1, ap( i1 ), 1 )
                    call stdlib_${ci}$axpy( i, alpha, ap( i1 ), 1, tau, 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**h - w * v**h
                    call stdlib_${ci}$hpr2( uplo, i, -cone, ap( i1 ), 1, tau, 1, ap )
                 end if
                 ap( i1+i-1 ) = e( i )
                 d( i+1 ) = real( ap( i1+i ),KIND=${ck}$)
                 tau( i ) = taui
                 i1 = i1 - i
              end do
              d( 1 ) = real( ap( 1 ),KIND=${ck}$)
           else
              ! reduce the lower triangle of a. ii is the index in ap of
              ! a(i,i) and i1i1 is the index of a(i+1,i+1).
              ii = 1
              ap( 1 ) = real( ap( 1 ),KIND=${ck}$)
              do i = 1, n - 1
                 i1i1 = ii + n - i + 1
                 ! generate elementary reflector h(i) = i - tau * v * v**h
                 ! to annihilate a(i+2:n,i)
                 alpha = ap( ii+1 )
                 call stdlib_${ci}$larfg( n-i, alpha, ap( ii+2 ), 1, taui )
                 e( i ) = real( alpha,KIND=${ck}$)
                 if( taui/=czero ) then
                    ! apply h(i) from both sides to a(i+1:n,i+1:n)
                    ap( ii+1 ) = cone
                    ! compute  y := tau * a * v  storing y in tau(i:n-1)
                    call stdlib_${ci}$hpmv( uplo, n-i, taui, ap( i1i1 ), ap( ii+1 ), 1,czero, tau( i ),&
                               1 )
                    ! compute  w := y - 1/2 * tau * (y**h *v) * v
                    alpha = -chalf*taui*stdlib_${ci}$dotc( n-i, tau( i ), 1, ap( ii+1 ),1 )
                    call stdlib_${ci}$axpy( n-i, alpha, ap( ii+1 ), 1, tau( i ), 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**h - w * v**h
                    call stdlib_${ci}$hpr2( uplo, n-i, -cone, ap( ii+1 ), 1, tau( i ), 1,ap( i1i1 ) )
                              
                 end if
                 ap( ii+1 ) = e( i )
                 d( i ) = real( ap( ii ),KIND=${ck}$)
                 tau( i ) = taui
                 ii = i1i1
              end do
              d( n ) = real( ap( ii ),KIND=${ck}$)
           end if
           return
     end subroutine stdlib_${ci}$hptrd

#:endif
#:endfor



     pure subroutine stdlib_slarrf( n, d, l, ld, clstrt, clend,w, wgap, werr,spdiam, clgapl, &
     !! Given the initial representation L D L^T and its cluster of close
     !! eigenvalues (in a relative measure), W( CLSTRT ), W( CLSTRT+1 ), ...
     !! W( CLEND ), SLARRF: finds a new relatively robust representation
     !! L D L^T - SIGMA I = L(+) D(+) L(+)^T such that at least one of the
     !! eigenvalues of L(+) D(+) L(+)^T is relatively isolated.
               clgapr, pivmin, sigma,dplus, lplus, work, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: clstrt, clend, n
           integer(ilp), intent(out) :: info
           real(sp), intent(in) :: clgapl, clgapr, pivmin, spdiam
           real(sp), intent(out) :: sigma
           ! Array Arguments 
           real(sp), intent(in) :: d(*), l(*), ld(*), w(*), werr(*)
           real(sp), intent(out) :: dplus(*), lplus(*), work(*)
           real(sp), intent(inout) :: wgap(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: quart = 0.25_sp
           real(sp), parameter :: maxgrowth1 = 8._sp
           real(sp), parameter :: maxgrowth2 = 8._sp
           integer(ilp), parameter :: ktrymax = 1
           integer(ilp), parameter :: sleft = 1
           integer(ilp), parameter :: sright = 2
           
           ! Local Scalars 
           logical(lk) :: dorrr1, forcer, nofail, sawnan1, sawnan2, tryrrr1
           integer(ilp) :: i, indx, ktry,    shift
           real(sp) :: avgap, bestshift, clwdth, eps, fact, fail, fail2, growthbound, ldelta, &
           ldmax, lsigma, max1, max2, mingap, oldp, prod, rdelta, rdmax, rrr1, rrr2, rsigma, s, &
                     smlgrowth, tmp, znm2
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           fact = real(2**ktrymax,KIND=sp)
           eps = stdlib_slamch( 'PRECISION' )
           shift = 0
           forcer = .false.
           ! note that we cannot guarantee that for any of the shifts tried,
           ! the factorization has a small or even moderate element growth.
           ! there could be ritz values at both ends of the cluster and despite
           ! backing off, there are examples where all factorizations tried
           ! (in ieee mode, allowing zero pivots
           ! element growth.
           ! for this reason, we should use pivmin in this subroutine so that at
           ! least the l d l^t factorization exists. it can be checked afterwards
           ! whether the element growth caused bad residuals/orthogonality.
           ! decide whether the code should accept the best among all
           ! representations despite large element growth or signal info=1
           ! setting nofail to .false. for quick fix for bug 113
           nofail = .false.
           ! compute the average gap length of the cluster
           clwdth = abs(w(clend)-w(clstrt)) + werr(clend) + werr(clstrt)
           avgap = clwdth / real(clend-clstrt,KIND=sp)
           mingap = min(clgapl, clgapr)
           ! initial values for shifts to both ends of cluster
           lsigma = min(w( clstrt ),w( clend )) - werr( clstrt )
           rsigma = max(w( clstrt ),w( clend )) + werr( clend )
           ! use a small fudge to make sure that we really shift to the outside
           lsigma = lsigma - abs(lsigma)* two * eps
           rsigma = rsigma + abs(rsigma)* two * eps
           ! compute upper bounds for how much to back off the initial shifts
           ldmax = quart * mingap + two * pivmin
           rdmax = quart * mingap + two * pivmin
           ldelta = max(avgap,wgap( clstrt ))/fact
           rdelta = max(avgap,wgap( clend-1 ))/fact
           ! initialize the record of the best representation found
           s = stdlib_slamch( 'S' )
           smlgrowth = one / s
           fail = real(n-1,KIND=sp)*mingap/(spdiam*eps)
           fail2 = real(n-1,KIND=sp)*mingap/(spdiam*sqrt(eps))
           bestshift = lsigma
           ! while (ktry <= ktrymax)
           ktry = 0
           growthbound = maxgrowth1*spdiam
           5 continue
           sawnan1 = .false.
           sawnan2 = .false.
           ! ensure that we do not back off too much of the initial shifts
           ldelta = min(ldmax,ldelta)
           rdelta = min(rdmax,rdelta)
           ! compute the element growth when shifting to both ends of the cluster
           ! accept the shift if there is no element growth at one of the two ends
           ! left end
           s = -lsigma
           dplus( 1 ) = d( 1 ) + s
           if(abs(dplus(1))<pivmin) then
              dplus(1) = -pivmin
              ! need to set sawnan1 because refined rrr test should not be used
              ! in this case
              sawnan1 = .true.
           endif
           max1 = abs( dplus( 1 ) )
           do i = 1, n - 1
              lplus( i ) = ld( i ) / dplus( i )
              s = s*lplus( i )*l( i ) - lsigma
              dplus( i+1 ) = d( i+1 ) + s
              if(abs(dplus(i+1))<pivmin) then
                 dplus(i+1) = -pivmin
                 ! need to set sawnan1 because refined rrr test should not be used
                 ! in this case
                 sawnan1 = .true.
              endif
              max1 = max( max1,abs(dplus(i+1)) )
           end do
           sawnan1 = sawnan1 .or.  stdlib_sisnan( max1 )
           if( forcer .or.(max1<=growthbound .and. .not.sawnan1 ) ) then
              sigma = lsigma
              shift = sleft
              goto 100
           endif
           ! right end
           s = -rsigma
           work( 1 ) = d( 1 ) + s
           if(abs(work(1))<pivmin) then
              work(1) = -pivmin
              ! need to set sawnan2 because refined rrr test should not be used
              ! in this case
              sawnan2 = .true.
           endif
           max2 = abs( work( 1 ) )
           do i = 1, n - 1
              work( n+i ) = ld( i ) / work( i )
              s = s*work( n+i )*l( i ) - rsigma
              work( i+1 ) = d( i+1 ) + s
              if(abs(work(i+1))<pivmin) then
                 work(i+1) = -pivmin
                 ! need to set sawnan2 because refined rrr test should not be used
                 ! in this case
                 sawnan2 = .true.
              endif
              max2 = max( max2,abs(work(i+1)) )
           end do
           sawnan2 = sawnan2 .or.  stdlib_sisnan( max2 )
           if( forcer .or.(max2<=growthbound .and. .not.sawnan2 ) ) then
              sigma = rsigma
              shift = sright
              goto 100
           endif
           ! if we are at this point, both shifts led to too much element growth
           ! record the better of the two shifts (provided it didn't lead to nan)
           if(sawnan1.and.sawnan2) then
              ! both max1 and max2 are nan
              goto 50
           else
              if( .not.sawnan1 ) then
                 indx = 1
                 if(max1<=smlgrowth) then
                    smlgrowth = max1
                    bestshift = lsigma
                 endif
              endif
              if( .not.sawnan2 ) then
                 if(sawnan1 .or. max2<=max1) indx = 2
                 if(max2<=smlgrowth) then
                    smlgrowth = max2
                    bestshift = rsigma
                 endif
              endif
           endif
           ! if we are here, both the left and the right shift led to
           ! element growth. if the element growth is moderate, then
           ! we may still accept the representation, if it passes a
           ! refined test for rrr. this test supposes that no nan occurred.
           ! moreover, we use the refined rrr test only for isolated clusters.
           if((clwdth<mingap/real(128,KIND=sp)) .and.(min(max1,max2)<fail2).and.(.not.sawnan1)&
                     .and.(.not.sawnan2)) then
              dorrr1 = .true.
           else
              dorrr1 = .false.
           endif
           tryrrr1 = .true.
           if( tryrrr1 .and. dorrr1 ) then
           if(indx==1) then
              tmp = abs( dplus( n ) )
              znm2 = one
              prod = one
              oldp = one
              do i = n-1, 1, -1
                 if( prod <= eps ) then
                    prod =((dplus(i+1)*work(n+i+1))/(dplus(i)*work(n+i)))*oldp
                 else
                    prod = prod*abs(work(n+i))
                 end if
                 oldp = prod
                 znm2 = znm2 + prod**2
                 tmp = max( tmp, abs( dplus( i ) * prod ))
              end do
              rrr1 = tmp/( spdiam * sqrt( znm2 ) )
              if (rrr1<=maxgrowth2) then
                 sigma = lsigma
                 shift = sleft
                 goto 100
              endif
           else if(indx==2) then
              tmp = abs( work( n ) )
              znm2 = one
              prod = one
              oldp = one
              do i = n-1, 1, -1
                 if( prod <= eps ) then
                    prod = ((work(i+1)*lplus(i+1))/(work(i)*lplus(i)))*oldp
                 else
                    prod = prod*abs(lplus(i))
                 end if
                 oldp = prod
                 znm2 = znm2 + prod**2
                 tmp = max( tmp, abs( work( i ) * prod ))
              end do
              rrr2 = tmp/( spdiam * sqrt( znm2 ) )
              if (rrr2<=maxgrowth2) then
                 sigma = rsigma
                 shift = sright
                 goto 100
              endif
           end if
           endif
           50 continue
           if (ktry<ktrymax) then
              ! if we are here, both shifts failed also the rrr test.
              ! back off to the outside
              lsigma = max( lsigma - ldelta,lsigma - ldmax)
              rsigma = min( rsigma + rdelta,rsigma + rdmax )
              ldelta = two * ldelta
              rdelta = two * rdelta
              ktry = ktry + 1
              goto 5
           else
              ! none of the representations investigated satisfied our
              ! criteria. take the best one we found.
              if((smlgrowth<fail).or.nofail) then
                 lsigma = bestshift
                 rsigma = bestshift
                 forcer = .true.
                 goto 5
              else
                 info = 1
                 return
              endif
           end if
           100 continue
           if (shift==sleft) then
           elseif (shift==sright) then
              ! store new l and d back into dplus, lplus
              call stdlib_scopy( n, work, 1, dplus, 1 )
              call stdlib_scopy( n-1, work(n+1), 1, lplus, 1 )
           endif
           return
     end subroutine stdlib_slarrf

     pure subroutine stdlib_dlarrf( n, d, l, ld, clstrt, clend,w, wgap, werr,spdiam, clgapl, &
     !! Given the initial representation L D L^T and its cluster of close
     !! eigenvalues (in a relative measure), W( CLSTRT ), W( CLSTRT+1 ), ...
     !! W( CLEND ), DLARRF: finds a new relatively robust representation
     !! L D L^T - SIGMA I = L(+) D(+) L(+)^T such that at least one of the
     !! eigenvalues of L(+) D(+) L(+)^T is relatively isolated.
               clgapr, pivmin, sigma,dplus, lplus, work, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: clstrt, clend, n
           integer(ilp), intent(out) :: info
           real(dp), intent(in) :: clgapl, clgapr, pivmin, spdiam
           real(dp), intent(out) :: sigma
           ! Array Arguments 
           real(dp), intent(in) :: d(*), l(*), ld(*), w(*), werr(*)
           real(dp), intent(out) :: dplus(*), lplus(*), work(*)
           real(dp), intent(inout) :: wgap(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: quart = 0.25_dp
           real(dp), parameter :: maxgrowth1 = 8._dp
           real(dp), parameter :: maxgrowth2 = 8._dp
           integer(ilp), parameter :: ktrymax = 1
           integer(ilp), parameter :: sleft = 1
           integer(ilp), parameter :: sright = 2
           
           ! Local Scalars 
           logical(lk) :: dorrr1, forcer, nofail, sawnan1, sawnan2, tryrrr1
           integer(ilp) :: i, indx, ktry,    shift
           real(dp) :: avgap, bestshift, clwdth, eps, fact, fail, fail2, growthbound, ldelta, &
           ldmax, lsigma, max1, max2, mingap, oldp, prod, rdelta, rdmax, rrr1, rrr2, rsigma, s, &
                     smlgrowth, tmp, znm2
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           fact = real(2**ktrymax,KIND=dp)
           eps = stdlib_dlamch( 'PRECISION' )
           shift = 0
           forcer = .false.
           ! note that we cannot guarantee that for any of the shifts tried,
           ! the factorization has a small or even moderate element growth.
           ! there could be ritz values at both ends of the cluster and despite
           ! backing off, there are examples where all factorizations tried
           ! (in ieee mode, allowing zero pivots
           ! element growth.
           ! for this reason, we should use pivmin in this subroutine so that at
           ! least the l d l^t factorization exists. it can be checked afterwards
           ! whether the element growth caused bad residuals/orthogonality.
           ! decide whether the code should accept the best among all
           ! representations despite large element growth or signal info=1
           ! setting nofail to .false. for quick fix for bug 113
           nofail = .false.
           ! compute the average gap length of the cluster
           clwdth = abs(w(clend)-w(clstrt)) + werr(clend) + werr(clstrt)
           avgap = clwdth / real(clend-clstrt,KIND=dp)
           mingap = min(clgapl, clgapr)
           ! initial values for shifts to both ends of cluster
           lsigma = min(w( clstrt ),w( clend )) - werr( clstrt )
           rsigma = max(w( clstrt ),w( clend )) + werr( clend )
           ! use a small fudge to make sure that we really shift to the outside
           lsigma = lsigma - abs(lsigma)* four * eps
           rsigma = rsigma + abs(rsigma)* four * eps
           ! compute upper bounds for how much to back off the initial shifts
           ldmax = quart * mingap + two * pivmin
           rdmax = quart * mingap + two * pivmin
           ldelta = max(avgap,wgap( clstrt ))/fact
           rdelta = max(avgap,wgap( clend-1 ))/fact
           ! initialize the record of the best representation found
           s = stdlib_dlamch( 'S' )
           smlgrowth = one / s
           fail = real(n-1,KIND=dp)*mingap/(spdiam*eps)
           fail2 = real(n-1,KIND=dp)*mingap/(spdiam*sqrt(eps))
           bestshift = lsigma
           ! while (ktry <= ktrymax)
           ktry = 0
           growthbound = maxgrowth1*spdiam
           5 continue
           sawnan1 = .false.
           sawnan2 = .false.
           ! ensure that we do not back off too much of the initial shifts
           ldelta = min(ldmax,ldelta)
           rdelta = min(rdmax,rdelta)
           ! compute the element growth when shifting to both ends of the cluster
           ! accept the shift if there is no element growth at one of the two ends
           ! left end
           s = -lsigma
           dplus( 1 ) = d( 1 ) + s
           if(abs(dplus(1))<pivmin) then
              dplus(1) = -pivmin
              ! need to set sawnan1 because refined rrr test should not be used
              ! in this case
              sawnan1 = .true.
           endif
           max1 = abs( dplus( 1 ) )
           do i = 1, n - 1
              lplus( i ) = ld( i ) / dplus( i )
              s = s*lplus( i )*l( i ) - lsigma
              dplus( i+1 ) = d( i+1 ) + s
              if(abs(dplus(i+1))<pivmin) then
                 dplus(i+1) = -pivmin
                 ! need to set sawnan1 because refined rrr test should not be used
                 ! in this case
                 sawnan1 = .true.
              endif
              max1 = max( max1,abs(dplus(i+1)) )
           end do
           sawnan1 = sawnan1 .or.  stdlib_disnan( max1 )
           if( forcer .or.(max1<=growthbound .and. .not.sawnan1 ) ) then
              sigma = lsigma
              shift = sleft
              goto 100
           endif
           ! right end
           s = -rsigma
           work( 1 ) = d( 1 ) + s
           if(abs(work(1))<pivmin) then
              work(1) = -pivmin
              ! need to set sawnan2 because refined rrr test should not be used
              ! in this case
              sawnan2 = .true.
           endif
           max2 = abs( work( 1 ) )
           do i = 1, n - 1
              work( n+i ) = ld( i ) / work( i )
              s = s*work( n+i )*l( i ) - rsigma
              work( i+1 ) = d( i+1 ) + s
              if(abs(work(i+1))<pivmin) then
                 work(i+1) = -pivmin
                 ! need to set sawnan2 because refined rrr test should not be used
                 ! in this case
                 sawnan2 = .true.
              endif
              max2 = max( max2,abs(work(i+1)) )
           end do
           sawnan2 = sawnan2 .or.  stdlib_disnan( max2 )
           if( forcer .or.(max2<=growthbound .and. .not.sawnan2 ) ) then
              sigma = rsigma
              shift = sright
              goto 100
           endif
           ! if we are at this point, both shifts led to too much element growth
           ! record the better of the two shifts (provided it didn't lead to nan)
           if(sawnan1.and.sawnan2) then
              ! both max1 and max2 are nan
              goto 50
           else
              if( .not.sawnan1 ) then
                 indx = 1
                 if(max1<=smlgrowth) then
                    smlgrowth = max1
                    bestshift = lsigma
                 endif
              endif
              if( .not.sawnan2 ) then
                 if(sawnan1 .or. max2<=max1) indx = 2
                 if(max2<=smlgrowth) then
                    smlgrowth = max2
                    bestshift = rsigma
                 endif
              endif
           endif
           ! if we are here, both the left and the right shift led to
           ! element growth. if the element growth is moderate, then
           ! we may still accept the representation, if it passes a
           ! refined test for rrr. this test supposes that no nan occurred.
           ! moreover, we use the refined rrr test only for isolated clusters.
           if((clwdth<mingap/real(128,KIND=dp)) .and.(min(max1,max2)<fail2).and.(.not.sawnan1)&
                     .and.(.not.sawnan2)) then
              dorrr1 = .true.
           else
              dorrr1 = .false.
           endif
           tryrrr1 = .true.
           if( tryrrr1 .and. dorrr1 ) then
           if(indx==1) then
              tmp = abs( dplus( n ) )
              znm2 = one
              prod = one
              oldp = one
              do i = n-1, 1, -1
                 if( prod <= eps ) then
                    prod =((dplus(i+1)*work(n+i+1))/(dplus(i)*work(n+i)))*oldp
                 else
                    prod = prod*abs(work(n+i))
                 end if
                 oldp = prod
                 znm2 = znm2 + prod**2
                 tmp = max( tmp, abs( dplus( i ) * prod ))
              end do
              rrr1 = tmp/( spdiam * sqrt( znm2 ) )
              if (rrr1<=maxgrowth2) then
                 sigma = lsigma
                 shift = sleft
                 goto 100
              endif
           else if(indx==2) then
              tmp = abs( work( n ) )
              znm2 = one
              prod = one
              oldp = one
              do i = n-1, 1, -1
                 if( prod <= eps ) then
                    prod = ((work(i+1)*lplus(i+1))/(work(i)*lplus(i)))*oldp
                 else
                    prod = prod*abs(lplus(i))
                 end if
                 oldp = prod
                 znm2 = znm2 + prod**2
                 tmp = max( tmp, abs( work( i ) * prod ))
              end do
              rrr2 = tmp/( spdiam * sqrt( znm2 ) )
              if (rrr2<=maxgrowth2) then
                 sigma = rsigma
                 shift = sright
                 goto 100
              endif
           end if
           endif
           50 continue
           if (ktry<ktrymax) then
              ! if we are here, both shifts failed also the rrr test.
              ! back off to the outside
              lsigma = max( lsigma - ldelta,lsigma - ldmax)
              rsigma = min( rsigma + rdelta,rsigma + rdmax )
              ldelta = two * ldelta
              rdelta = two * rdelta
              ktry = ktry + 1
              goto 5
           else
              ! none of the representations investigated satisfied our
              ! criteria. take the best one we found.
              if((smlgrowth<fail).or.nofail) then
                 lsigma = bestshift
                 rsigma = bestshift
                 forcer = .true.
                 goto 5
              else
                 info = 1
                 return
              endif
           end if
           100 continue
           if (shift==sleft) then
           elseif (shift==sright) then
              ! store new l and d back into dplus, lplus
              call stdlib_dcopy( n, work, 1, dplus, 1 )
              call stdlib_dcopy( n-1, work(n+1), 1, lplus, 1 )
           endif
           return
     end subroutine stdlib_dlarrf

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$larrf( n, d, l, ld, clstrt, clend,w, wgap, werr,spdiam, clgapl, &
     !! Given the initial representation L D L^T and its cluster of close
     !! eigenvalues (in a relative measure), W( CLSTRT ), W( CLSTRT+1 ), ...
     !! W( CLEND ), DLARRF: finds a new relatively robust representation
     !! L D L^T - SIGMA I = L(+) D(+) L(+)^T such that at least one of the
     !! eigenvalues of L(+) D(+) L(+)^T is relatively isolated.
               clgapr, pivmin, sigma,dplus, lplus, work, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: clstrt, clend, n
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(in) :: clgapl, clgapr, pivmin, spdiam
           real(${rk}$), intent(out) :: sigma
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(*), l(*), ld(*), w(*), werr(*)
           real(${rk}$), intent(out) :: dplus(*), lplus(*), work(*)
           real(${rk}$), intent(inout) :: wgap(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: quart = 0.25_${rk}$
           real(${rk}$), parameter :: maxgrowth1 = 8._${rk}$
           real(${rk}$), parameter :: maxgrowth2 = 8._${rk}$
           integer(ilp), parameter :: ktrymax = 1
           integer(ilp), parameter :: sleft = 1
           integer(ilp), parameter :: sright = 2
           
           ! Local Scalars 
           logical(lk) :: dorrr1, forcer, nofail, sawnan1, sawnan2, tryrrr1
           integer(ilp) :: i, indx, ktry,    shift
           real(${rk}$) :: avgap, bestshift, clwdth, eps, fact, fail, fail2, growthbound, ldelta, &
           ldmax, lsigma, max1, max2, mingap, oldp, prod, rdelta, rdmax, rrr1, rrr2, rsigma, s, &
                     smlgrowth, tmp, znm2
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           fact = real(2**ktrymax,KIND=${rk}$)
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           shift = 0
           forcer = .false.
           ! note that we cannot guarantee that for any of the shifts tried,
           ! the factorization has a small or even moderate element growth.
           ! there could be ritz values at both ends of the cluster and despite
           ! backing off, there are examples where all factorizations tried
           ! (in ieee mode, allowing zero pivots
           ! element growth.
           ! for this reason, we should use pivmin in this subroutine so that at
           ! least the l d l^t factorization exists. it can be checked afterwards
           ! whether the element growth caused bad residuals/orthogonality.
           ! decide whether the code should accept the best among all
           ! representations despite large element growth or signal info=1
           ! setting nofail to .false. for quick fix for bug 113
           nofail = .false.
           ! compute the average gap length of the cluster
           clwdth = abs(w(clend)-w(clstrt)) + werr(clend) + werr(clstrt)
           avgap = clwdth / real(clend-clstrt,KIND=${rk}$)
           mingap = min(clgapl, clgapr)
           ! initial values for shifts to both ends of cluster
           lsigma = min(w( clstrt ),w( clend )) - werr( clstrt )
           rsigma = max(w( clstrt ),w( clend )) + werr( clend )
           ! use a small fudge to make sure that we really shift to the outside
           lsigma = lsigma - abs(lsigma)* four * eps
           rsigma = rsigma + abs(rsigma)* four * eps
           ! compute upper bounds for how much to back off the initial shifts
           ldmax = quart * mingap + two * pivmin
           rdmax = quart * mingap + two * pivmin
           ldelta = max(avgap,wgap( clstrt ))/fact
           rdelta = max(avgap,wgap( clend-1 ))/fact
           ! initialize the record of the best representation found
           s = stdlib_${ri}$lamch( 'S' )
           smlgrowth = one / s
           fail = real(n-1,KIND=${rk}$)*mingap/(spdiam*eps)
           fail2 = real(n-1,KIND=${rk}$)*mingap/(spdiam*sqrt(eps))
           bestshift = lsigma
           ! while (ktry <= ktrymax)
           ktry = 0
           growthbound = maxgrowth1*spdiam
           5 continue
           sawnan1 = .false.
           sawnan2 = .false.
           ! ensure that we do not back off too much of the initial shifts
           ldelta = min(ldmax,ldelta)
           rdelta = min(rdmax,rdelta)
           ! compute the element growth when shifting to both ends of the cluster
           ! accept the shift if there is no element growth at one of the two ends
           ! left end
           s = -lsigma
           dplus( 1 ) = d( 1 ) + s
           if(abs(dplus(1))<pivmin) then
              dplus(1) = -pivmin
              ! need to set sawnan1 because refined rrr test should not be used
              ! in this case
              sawnan1 = .true.
           endif
           max1 = abs( dplus( 1 ) )
           do i = 1, n - 1
              lplus( i ) = ld( i ) / dplus( i )
              s = s*lplus( i )*l( i ) - lsigma
              dplus( i+1 ) = d( i+1 ) + s
              if(abs(dplus(i+1))<pivmin) then
                 dplus(i+1) = -pivmin
                 ! need to set sawnan1 because refined rrr test should not be used
                 ! in this case
                 sawnan1 = .true.
              endif
              max1 = max( max1,abs(dplus(i+1)) )
           end do
           sawnan1 = sawnan1 .or.  stdlib_${ri}$isnan( max1 )
           if( forcer .or.(max1<=growthbound .and. .not.sawnan1 ) ) then
              sigma = lsigma
              shift = sleft
              goto 100
           endif
           ! right end
           s = -rsigma
           work( 1 ) = d( 1 ) + s
           if(abs(work(1))<pivmin) then
              work(1) = -pivmin
              ! need to set sawnan2 because refined rrr test should not be used
              ! in this case
              sawnan2 = .true.
           endif
           max2 = abs( work( 1 ) )
           do i = 1, n - 1
              work( n+i ) = ld( i ) / work( i )
              s = s*work( n+i )*l( i ) - rsigma
              work( i+1 ) = d( i+1 ) + s
              if(abs(work(i+1))<pivmin) then
                 work(i+1) = -pivmin
                 ! need to set sawnan2 because refined rrr test should not be used
                 ! in this case
                 sawnan2 = .true.
              endif
              max2 = max( max2,abs(work(i+1)) )
           end do
           sawnan2 = sawnan2 .or.  stdlib_${ri}$isnan( max2 )
           if( forcer .or.(max2<=growthbound .and. .not.sawnan2 ) ) then
              sigma = rsigma
              shift = sright
              goto 100
           endif
           ! if we are at this point, both shifts led to too much element growth
           ! record the better of the two shifts (provided it didn't lead to nan)
           if(sawnan1.and.sawnan2) then
              ! both max1 and max2 are nan
              goto 50
           else
              if( .not.sawnan1 ) then
                 indx = 1
                 if(max1<=smlgrowth) then
                    smlgrowth = max1
                    bestshift = lsigma
                 endif
              endif
              if( .not.sawnan2 ) then
                 if(sawnan1 .or. max2<=max1) indx = 2
                 if(max2<=smlgrowth) then
                    smlgrowth = max2
                    bestshift = rsigma
                 endif
              endif
           endif
           ! if we are here, both the left and the right shift led to
           ! element growth. if the element growth is moderate, then
           ! we may still accept the representation, if it passes a
           ! refined test for rrr. this test supposes that no nan occurred.
           ! moreover, we use the refined rrr test only for isolated clusters.
           if((clwdth<mingap/real(128,KIND=${rk}$)) .and.(min(max1,max2)<fail2).and.(.not.sawnan1)&
                     .and.(.not.sawnan2)) then
              dorrr1 = .true.
           else
              dorrr1 = .false.
           endif
           tryrrr1 = .true.
           if( tryrrr1 .and. dorrr1 ) then
           if(indx==1) then
              tmp = abs( dplus( n ) )
              znm2 = one
              prod = one
              oldp = one
              do i = n-1, 1, -1
                 if( prod <= eps ) then
                    prod =((dplus(i+1)*work(n+i+1))/(dplus(i)*work(n+i)))*oldp
                 else
                    prod = prod*abs(work(n+i))
                 end if
                 oldp = prod
                 znm2 = znm2 + prod**2
                 tmp = max( tmp, abs( dplus( i ) * prod ))
              end do
              rrr1 = tmp/( spdiam * sqrt( znm2 ) )
              if (rrr1<=maxgrowth2) then
                 sigma = lsigma
                 shift = sleft
                 goto 100
              endif
           else if(indx==2) then
              tmp = abs( work( n ) )
              znm2 = one
              prod = one
              oldp = one
              do i = n-1, 1, -1
                 if( prod <= eps ) then
                    prod = ((work(i+1)*lplus(i+1))/(work(i)*lplus(i)))*oldp
                 else
                    prod = prod*abs(lplus(i))
                 end if
                 oldp = prod
                 znm2 = znm2 + prod**2
                 tmp = max( tmp, abs( work( i ) * prod ))
              end do
              rrr2 = tmp/( spdiam * sqrt( znm2 ) )
              if (rrr2<=maxgrowth2) then
                 sigma = rsigma
                 shift = sright
                 goto 100
              endif
           end if
           endif
           50 continue
           if (ktry<ktrymax) then
              ! if we are here, both shifts failed also the rrr test.
              ! back off to the outside
              lsigma = max( lsigma - ldelta,lsigma - ldmax)
              rsigma = min( rsigma + rdelta,rsigma + rdmax )
              ldelta = two * ldelta
              rdelta = two * rdelta
              ktry = ktry + 1
              goto 5
           else
              ! none of the representations investigated satisfied our
              ! criteria. take the best one we found.
              if((smlgrowth<fail).or.nofail) then
                 lsigma = bestshift
                 rsigma = bestshift
                 forcer = .true.
                 goto 5
              else
                 info = 1
                 return
              endif
           end if
           100 continue
           if (shift==sleft) then
           elseif (shift==sright) then
              ! store new l and d back into dplus, lplus
              call stdlib_${ri}$copy( n, work, 1, dplus, 1 )
              call stdlib_${ri}$copy( n-1, work(n+1), 1, lplus, 1 )
           endif
           return
     end subroutine stdlib_${ri}$larrf

#:endif
#:endfor



     pure subroutine stdlib_sstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
     !! SSTEIN computes the eigenvectors of a real symmetric tridiagonal
     !! matrix T corresponding to specified eigenvalues, using inverse
     !! iteration.
     !! The maximum number of iterations allowed for each eigenvector is
     !! specified by an internal parameter MAXITS (currently set to 5).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, m, n
           ! Array Arguments 
           integer(ilp), intent(in) :: iblock(*), isplit(*)
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(in) :: d(*), e(*), w(*)
           real(sp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: odm3 = 1.0e-3_sp
           real(sp), parameter :: odm1 = 1.0e-1_sp
           integer(ilp), parameter :: maxits = 5
           integer(ilp), parameter :: extra = 2
           
           
           ! Local Scalars 
           integer(ilp) :: b1, blksiz, bn, gpind, i, iinfo, indrv1, indrv2, indrv3, indrv4, &
                     indrv5, its, j, j1, jblk, jmax, nblk, nrmchk
           real(sp) :: ctr, eps, eps1, nrm, onenrm, ortol, pertol, scl, sep, stpcrt, tol, xj, &
                     xjm
           ! Local Arrays 
           integer(ilp) :: iseed(4)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           do i = 1, m
              ifail( i ) = 0
           end do
           if( n<0 ) then
              info = -1
           else if( m<0 .or. m>n ) then
              info = -4
           else if( ldz<max( 1, n ) ) then
              info = -9
           else
              do j = 2, m
                 if( iblock( j )<iblock( j-1 ) ) then
                    info = -6
                    go to 30
                 end if
                 if( iblock( j )==iblock( j-1 ) .and. w( j )<w( j-1 ) )then
                    info = -5
                    go to 30
                 end if
              end do
              30 continue
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSTEIN', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. m==0 ) then
              return
           else if( n==1 ) then
              z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           eps = stdlib_slamch( 'PRECISION' )
           ! initialize seed for random number generator stdlib_slarnv.
           do i = 1, 4
              iseed( i ) = 1
           end do
           ! initialize pointers.
           indrv1 = 0
           indrv2 = indrv1 + n
           indrv3 = indrv2 + n
           indrv4 = indrv3 + n
           indrv5 = indrv4 + n
           ! compute eigenvectors of matrix blocks.
           j1 = 1
           loop_160: do nblk = 1, iblock( m )
              ! find starting and ending indices of block nblk.
              if( nblk==1 ) then
                 b1 = 1
              else
                 b1 = isplit( nblk-1 ) + 1
              end if
              bn = isplit( nblk )
              blksiz = bn - b1 + 1
              if( blksiz==1 )go to 60
              gpind = j1
              ! compute reorthogonalization criterion and stopping criterion.
              onenrm = abs( d( b1 ) ) + abs( e( b1 ) )
              onenrm = max( onenrm, abs( d( bn ) )+abs( e( bn-1 ) ) )
              do i = b1 + 1, bn - 1
                 onenrm = max( onenrm, abs( d( i ) )+abs( e( i-1 ) )+abs( e( i ) ) )
              end do
              ortol = odm3*onenrm
              stpcrt = sqrt( odm1 / blksiz )
              ! loop through eigenvalues of block nblk.
              60 continue
              jblk = 0
              loop_150: do j = j1, m
                 if( iblock( j )/=nblk ) then
                    j1 = j
                    cycle loop_160
                 end if
                 jblk = jblk + 1
                 xj = w( j )
                 ! skip all the work if the block size is one.
                 if( blksiz==1 ) then
                    work( indrv1+1 ) = one
                    go to 120
                 end if
                 ! if eigenvalues j and j-1 are too close, add a relatively
                 ! small perturbation.
                 if( jblk>1 ) then
                    eps1 = abs( eps*xj )
                    pertol = ten*eps1
                    sep = xj - xjm
                    if( sep<pertol )xj = xjm + pertol
                 end if
                 its = 0
                 nrmchk = 0
                 ! get random starting vector.
                 call stdlib_slarnv( 2, iseed, blksiz, work( indrv1+1 ) )
                 ! copy the matrix t so it won't be destroyed in factorization.
                 call stdlib_scopy( blksiz, d( b1 ), 1, work( indrv4+1 ), 1 )
                 call stdlib_scopy( blksiz-1, e( b1 ), 1, work( indrv2+2 ), 1 )
                 call stdlib_scopy( blksiz-1, e( b1 ), 1, work( indrv3+1 ), 1 )
                 ! compute lu factors with partial pivoting  ( pt = lu )
                 tol = zero
                 call stdlib_slagtf( blksiz, work( indrv4+1 ), xj, work( indrv2+2 ),work( indrv3+&
                           1 ), tol, work( indrv5+1 ), iwork,iinfo )
                 ! update iteration count.
                 70 continue
                 its = its + 1
                 if( its>maxits )go to 100
                 ! normalize and scale the righthand side vector pb.
                 jmax = stdlib_isamax( blksiz, work( indrv1+1 ), 1 )
                 scl = blksiz*onenrm*max( eps,abs( work( indrv4+blksiz ) ) ) /abs( work( indrv1+&
                           jmax ) )
                 call stdlib_sscal( blksiz, scl, work( indrv1+1 ), 1 )
                 ! solve the system lu = pb.
                 call stdlib_slagts( -1, blksiz, work( indrv4+1 ), work( indrv2+2 ),work( indrv3+&
                           1 ), work( indrv5+1 ), iwork,work( indrv1+1 ), tol, iinfo )
                 ! reorthogonalize by modified gram-schmidt if eigenvalues are
                 ! close enough.
                 if( jblk==1 )go to 90
                 if( abs( xj-xjm )>ortol )gpind = j
                 if( gpind/=j ) then
                    do i = gpind, j - 1
                       ctr = -stdlib_sdot( blksiz, work( indrv1+1 ), 1, z( b1, i ),1 )
                       call stdlib_saxpy( blksiz, ctr, z( b1, i ), 1,work( indrv1+1 ), 1 )
                    end do
                 end if
                 ! check the infinity norm of the iterate.
                 90 continue
                 jmax = stdlib_isamax( blksiz, work( indrv1+1 ), 1 )
                 nrm = abs( work( indrv1+jmax ) )
                 ! continue for additional iterations after norm reaches
                 ! stopping criterion.
                 if( nrm<stpcrt )go to 70
                 nrmchk = nrmchk + 1
                 if( nrmchk<extra+1 )go to 70
                 go to 110
                 ! if stopping criterion was not satisfied, update info and
                 ! store eigenvector number in array ifail.
                 100 continue
                 info = info + 1
                 ifail( info ) = j
                 ! accept iterate as jth eigenvector.
                 110 continue
                 scl = one / stdlib_snrm2( blksiz, work( indrv1+1 ), 1 )
                 jmax = stdlib_isamax( blksiz, work( indrv1+1 ), 1 )
                 if( work( indrv1+jmax )<zero )scl = -scl
                 call stdlib_sscal( blksiz, scl, work( indrv1+1 ), 1 )
                 120 continue
                 do i = 1, n
                    z( i, j ) = zero
                 end do
                 do i = 1, blksiz
                    z( b1+i-1, j ) = work( indrv1+i )
                 end do
                 ! save the shift to check eigenvalue spacing at next
                 ! iteration.
                 xjm = xj
              end do loop_150
           end do loop_160
           return
     end subroutine stdlib_sstein

     pure subroutine stdlib_dstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
     !! DSTEIN computes the eigenvectors of a real symmetric tridiagonal
     !! matrix T corresponding to specified eigenvalues, using inverse
     !! iteration.
     !! The maximum number of iterations allowed for each eigenvector is
     !! specified by an internal parameter MAXITS (currently set to 5).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, m, n
           ! Array Arguments 
           integer(ilp), intent(in) :: iblock(*), isplit(*)
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(in) :: d(*), e(*), w(*)
           real(dp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: odm3 = 1.0e-3_dp
           real(dp), parameter :: odm1 = 1.0e-1_dp
           integer(ilp), parameter :: maxits = 5
           integer(ilp), parameter :: extra = 2
           
           
           ! Local Scalars 
           integer(ilp) :: b1, blksiz, bn, gpind, i, iinfo, indrv1, indrv2, indrv3, indrv4, &
                     indrv5, its, j, j1, jblk, jmax, nblk, nrmchk
           real(dp) :: dtpcrt, eps, eps1, nrm, onenrm, ortol, pertol, scl, sep, tol, xj, xjm, &
                     ztr
           ! Local Arrays 
           integer(ilp) :: iseed(4)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           do i = 1, m
              ifail( i ) = 0
           end do
           if( n<0 ) then
              info = -1
           else if( m<0 .or. m>n ) then
              info = -4
           else if( ldz<max( 1, n ) ) then
              info = -9
           else
              do j = 2, m
                 if( iblock( j )<iblock( j-1 ) ) then
                    info = -6
                    go to 30
                 end if
                 if( iblock( j )==iblock( j-1 ) .and. w( j )<w( j-1 ) )then
                    info = -5
                    go to 30
                 end if
              end do
              30 continue
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEIN', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. m==0 ) then
              return
           else if( n==1 ) then
              z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           eps = stdlib_dlamch( 'PRECISION' )
           ! initialize seed for random number generator stdlib_dlarnv.
           do i = 1, 4
              iseed( i ) = 1
           end do
           ! initialize pointers.
           indrv1 = 0
           indrv2 = indrv1 + n
           indrv3 = indrv2 + n
           indrv4 = indrv3 + n
           indrv5 = indrv4 + n
           ! compute eigenvectors of matrix blocks.
           j1 = 1
           loop_160: do nblk = 1, iblock( m )
              ! find starting and ending indices of block nblk.
              if( nblk==1 ) then
                 b1 = 1
              else
                 b1 = isplit( nblk-1 ) + 1
              end if
              bn = isplit( nblk )
              blksiz = bn - b1 + 1
              if( blksiz==1 )go to 60
              gpind = j1
              ! compute reorthogonalization criterion and stopping criterion.
              onenrm = abs( d( b1 ) ) + abs( e( b1 ) )
              onenrm = max( onenrm, abs( d( bn ) )+abs( e( bn-1 ) ) )
              do i = b1 + 1, bn - 1
                 onenrm = max( onenrm, abs( d( i ) )+abs( e( i-1 ) )+abs( e( i ) ) )
              end do
              ortol = odm3*onenrm
              dtpcrt = sqrt( odm1 / blksiz )
              ! loop through eigenvalues of block nblk.
              60 continue
              jblk = 0
              loop_150: do j = j1, m
                 if( iblock( j )/=nblk ) then
                    j1 = j
                    cycle loop_160
                 end if
                 jblk = jblk + 1
                 xj = w( j )
                 ! skip all the work if the block size is one.
                 if( blksiz==1 ) then
                    work( indrv1+1 ) = one
                    go to 120
                 end if
                 ! if eigenvalues j and j-1 are too close, add a relatively
                 ! small perturbation.
                 if( jblk>1 ) then
                    eps1 = abs( eps*xj )
                    pertol = ten*eps1
                    sep = xj - xjm
                    if( sep<pertol )xj = xjm + pertol
                 end if
                 its = 0
                 nrmchk = 0
                 ! get random starting vector.
                 call stdlib_dlarnv( 2, iseed, blksiz, work( indrv1+1 ) )
                 ! copy the matrix t so it won't be destroyed in factorization.
                 call stdlib_dcopy( blksiz, d( b1 ), 1, work( indrv4+1 ), 1 )
                 call stdlib_dcopy( blksiz-1, e( b1 ), 1, work( indrv2+2 ), 1 )
                 call stdlib_dcopy( blksiz-1, e( b1 ), 1, work( indrv3+1 ), 1 )
                 ! compute lu factors with partial pivoting  ( pt = lu )
                 tol = zero
                 call stdlib_dlagtf( blksiz, work( indrv4+1 ), xj, work( indrv2+2 ),work( indrv3+&
                           1 ), tol, work( indrv5+1 ), iwork,iinfo )
                 ! update iteration count.
                 70 continue
                 its = its + 1
                 if( its>maxits )go to 100
                 ! normalize and scale the righthand side vector pb.
                 jmax = stdlib_idamax( blksiz, work( indrv1+1 ), 1 )
                 scl = blksiz*onenrm*max( eps,abs( work( indrv4+blksiz ) ) ) /abs( work( indrv1+&
                           jmax ) )
                 call stdlib_dscal( blksiz, scl, work( indrv1+1 ), 1 )
                 ! solve the system lu = pb.
                 call stdlib_dlagts( -1, blksiz, work( indrv4+1 ), work( indrv2+2 ),work( indrv3+&
                           1 ), work( indrv5+1 ), iwork,work( indrv1+1 ), tol, iinfo )
                 ! reorthogonalize by modified gram-schmidt if eigenvalues are
                 ! close enough.
                 if( jblk==1 )go to 90
                 if( abs( xj-xjm )>ortol )gpind = j
                 if( gpind/=j ) then
                    do i = gpind, j - 1
                       ztr = -stdlib_ddot( blksiz, work( indrv1+1 ), 1, z( b1, i ),1 )
                       call stdlib_daxpy( blksiz, ztr, z( b1, i ), 1,work( indrv1+1 ), 1 )
                    end do
                 end if
                 ! check the infinity norm of the iterate.
                 90 continue
                 jmax = stdlib_idamax( blksiz, work( indrv1+1 ), 1 )
                 nrm = abs( work( indrv1+jmax ) )
                 ! continue for additional iterations after norm reaches
                 ! stopping criterion.
                 if( nrm<dtpcrt )go to 70
                 nrmchk = nrmchk + 1
                 if( nrmchk<extra+1 )go to 70
                 go to 110
                 ! if stopping criterion was not satisfied, update info and
                 ! store eigenvector number in array ifail.
                 100 continue
                 info = info + 1
                 ifail( info ) = j
                 ! accept iterate as jth eigenvector.
                 110 continue
                 scl = one / stdlib_dnrm2( blksiz, work( indrv1+1 ), 1 )
                 jmax = stdlib_idamax( blksiz, work( indrv1+1 ), 1 )
                 if( work( indrv1+jmax )<zero )scl = -scl
                 call stdlib_dscal( blksiz, scl, work( indrv1+1 ), 1 )
                 120 continue
                 do i = 1, n
                    z( i, j ) = zero
                 end do
                 do i = 1, blksiz
                    z( b1+i-1, j ) = work( indrv1+i )
                 end do
                 ! save the shift to check eigenvalue spacing at next
                 ! iteration.
                 xjm = xj
              end do loop_150
           end do loop_160
           return
     end subroutine stdlib_dstein

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$stein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
     !! DSTEIN: computes the eigenvectors of a real symmetric tridiagonal
     !! matrix T corresponding to specified eigenvalues, using inverse
     !! iteration.
     !! The maximum number of iterations allowed for each eigenvector is
     !! specified by an internal parameter MAXITS (currently set to 5).
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, m, n
           ! Array Arguments 
           integer(ilp), intent(in) :: iblock(*), isplit(*)
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(in) :: d(*), e(*), w(*)
           real(${rk}$), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: odm3 = 1.0e-3_${rk}$
           real(${rk}$), parameter :: odm1 = 1.0e-1_${rk}$
           integer(ilp), parameter :: maxits = 5
           integer(ilp), parameter :: extra = 2
           
           
           ! Local Scalars 
           integer(ilp) :: b1, blksiz, bn, gpind, i, iinfo, indrv1, indrv2, indrv3, indrv4, &
                     indrv5, its, j, j1, jblk, jmax, nblk, nrmchk
           real(${rk}$) :: dtpcrt, eps, eps1, nrm, onenrm, ortol, pertol, scl, sep, tol, xj, xjm, &
                     ztr
           ! Local Arrays 
           integer(ilp) :: iseed(4)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           do i = 1, m
              ifail( i ) = 0
           end do
           if( n<0 ) then
              info = -1
           else if( m<0 .or. m>n ) then
              info = -4
           else if( ldz<max( 1, n ) ) then
              info = -9
           else
              do j = 2, m
                 if( iblock( j )<iblock( j-1 ) ) then
                    info = -6
                    go to 30
                 end if
                 if( iblock( j )==iblock( j-1 ) .and. w( j )<w( j-1 ) )then
                    info = -5
                    go to 30
                 end if
              end do
              30 continue
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEIN', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. m==0 ) then
              return
           else if( n==1 ) then
              z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           ! initialize seed for random number generator stdlib_${ri}$larnv.
           do i = 1, 4
              iseed( i ) = 1
           end do
           ! initialize pointers.
           indrv1 = 0
           indrv2 = indrv1 + n
           indrv3 = indrv2 + n
           indrv4 = indrv3 + n
           indrv5 = indrv4 + n
           ! compute eigenvectors of matrix blocks.
           j1 = 1
           loop_160: do nblk = 1, iblock( m )
              ! find starting and ending indices of block nblk.
              if( nblk==1 ) then
                 b1 = 1
              else
                 b1 = isplit( nblk-1 ) + 1
              end if
              bn = isplit( nblk )
              blksiz = bn - b1 + 1
              if( blksiz==1 )go to 60
              gpind = j1
              ! compute reorthogonalization criterion and stopping criterion.
              onenrm = abs( d( b1 ) ) + abs( e( b1 ) )
              onenrm = max( onenrm, abs( d( bn ) )+abs( e( bn-1 ) ) )
              do i = b1 + 1, bn - 1
                 onenrm = max( onenrm, abs( d( i ) )+abs( e( i-1 ) )+abs( e( i ) ) )
              end do
              ortol = odm3*onenrm
              dtpcrt = sqrt( odm1 / blksiz )
              ! loop through eigenvalues of block nblk.
              60 continue
              jblk = 0
              loop_150: do j = j1, m
                 if( iblock( j )/=nblk ) then
                    j1 = j
                    cycle loop_160
                 end if
                 jblk = jblk + 1
                 xj = w( j )
                 ! skip all the work if the block size is one.
                 if( blksiz==1 ) then
                    work( indrv1+1 ) = one
                    go to 120
                 end if
                 ! if eigenvalues j and j-1 are too close, add a relatively
                 ! small perturbation.
                 if( jblk>1 ) then
                    eps1 = abs( eps*xj )
                    pertol = ten*eps1
                    sep = xj - xjm
                    if( sep<pertol )xj = xjm + pertol
                 end if
                 its = 0
                 nrmchk = 0
                 ! get random starting vector.
                 call stdlib_${ri}$larnv( 2, iseed, blksiz, work( indrv1+1 ) )
                 ! copy the matrix t so it won't be destroyed in factorization.
                 call stdlib_${ri}$copy( blksiz, d( b1 ), 1, work( indrv4+1 ), 1 )
                 call stdlib_${ri}$copy( blksiz-1, e( b1 ), 1, work( indrv2+2 ), 1 )
                 call stdlib_${ri}$copy( blksiz-1, e( b1 ), 1, work( indrv3+1 ), 1 )
                 ! compute lu factors with partial pivoting  ( pt = lu )
                 tol = zero
                 call stdlib_${ri}$lagtf( blksiz, work( indrv4+1 ), xj, work( indrv2+2 ),work( indrv3+&
                           1 ), tol, work( indrv5+1 ), iwork,iinfo )
                 ! update iteration count.
                 70 continue
                 its = its + 1
                 if( its>maxits )go to 100
                 ! normalize and scale the righthand side vector pb.
                 jmax = stdlib_i${ri}$amax( blksiz, work( indrv1+1 ), 1 )
                 scl = blksiz*onenrm*max( eps,abs( work( indrv4+blksiz ) ) ) /abs( work( indrv1+&
                           jmax ) )
                 call stdlib_${ri}$scal( blksiz, scl, work( indrv1+1 ), 1 )
                 ! solve the system lu = pb.
                 call stdlib_${ri}$lagts( -1, blksiz, work( indrv4+1 ), work( indrv2+2 ),work( indrv3+&
                           1 ), work( indrv5+1 ), iwork,work( indrv1+1 ), tol, iinfo )
                 ! reorthogonalize by modified gram-schmidt if eigenvalues are
                 ! close enough.
                 if( jblk==1 )go to 90
                 if( abs( xj-xjm )>ortol )gpind = j
                 if( gpind/=j ) then
                    do i = gpind, j - 1
                       ztr = -stdlib_${ri}$dot( blksiz, work( indrv1+1 ), 1, z( b1, i ),1 )
                       call stdlib_${ri}$axpy( blksiz, ztr, z( b1, i ), 1,work( indrv1+1 ), 1 )
                    end do
                 end if
                 ! check the infinity norm of the iterate.
                 90 continue
                 jmax = stdlib_i${ri}$amax( blksiz, work( indrv1+1 ), 1 )
                 nrm = abs( work( indrv1+jmax ) )
                 ! continue for additional iterations after norm reaches
                 ! stopping criterion.
                 if( nrm<dtpcrt )go to 70
                 nrmchk = nrmchk + 1
                 if( nrmchk<extra+1 )go to 70
                 go to 110
                 ! if stopping criterion was not satisfied, update info and
                 ! store eigenvector number in array ifail.
                 100 continue
                 info = info + 1
                 ifail( info ) = j
                 ! accept iterate as jth eigenvector.
                 110 continue
                 scl = one / stdlib_${ri}$nrm2( blksiz, work( indrv1+1 ), 1 )
                 jmax = stdlib_i${ri}$amax( blksiz, work( indrv1+1 ), 1 )
                 if( work( indrv1+jmax )<zero )scl = -scl
                 call stdlib_${ri}$scal( blksiz, scl, work( indrv1+1 ), 1 )
                 120 continue
                 do i = 1, n
                    z( i, j ) = zero
                 end do
                 do i = 1, blksiz
                    z( b1+i-1, j ) = work( indrv1+i )
                 end do
                 ! save the shift to check eigenvalue spacing at next
                 ! iteration.
                 xjm = xj
              end do loop_150
           end do loop_160
           return
     end subroutine stdlib_${ri}$stein

#:endif
#:endfor

     pure subroutine stdlib_cstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
     !! CSTEIN computes the eigenvectors of a real symmetric tridiagonal
     !! matrix T corresponding to specified eigenvalues, using inverse
     !! iteration.
     !! The maximum number of iterations allowed for each eigenvector is
     !! specified by an internal parameter MAXITS (currently set to 5).
     !! Although the eigenvectors are real, they are stored in a complex
     !! array, which may be passed to CUNMTR or CUPMTR for back
     !! transformation to the eigenvectors of a complex Hermitian matrix
     !! which was reduced to tridiagonal form.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, m, n
           ! Array Arguments 
           integer(ilp), intent(in) :: iblock(*), isplit(*)
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(in) :: d(*), e(*), w(*)
           real(sp), intent(out) :: work(*)
           complex(sp), intent(out) :: z(ldz,*)
       ! =====================================================================
           ! Parameters 
           real(sp), parameter :: odm3 = 1.0e-3_sp
           real(sp), parameter :: odm1 = 1.0e-1_sp
           integer(ilp), parameter :: maxits = 5
           integer(ilp), parameter :: extra = 2
           
           
           
           ! Local Scalars 
           integer(ilp) :: b1, blksiz, bn, gpind, i, iinfo, indrv1, indrv2, indrv3, indrv4, &
                     indrv5, its, j, j1, jblk, jmax, jr, nblk, nrmchk
           real(sp) :: ctr, eps, eps1, nrm, onenrm, ortol, pertol, scl, sep, stpcrt, tol, xj, &
                     xjm
           ! Local Arrays 
           integer(ilp) :: iseed(4)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           do i = 1, m
              ifail( i ) = 0
           end do
           if( n<0 ) then
              info = -1
           else if( m<0 .or. m>n ) then
              info = -4
           else if( ldz<max( 1, n ) ) then
              info = -9
           else
              do j = 2, m
                 if( iblock( j )<iblock( j-1 ) ) then
                    info = -6
                    go to 30
                 end if
                 if( iblock( j )==iblock( j-1 ) .and. w( j )<w( j-1 ) )then
                    info = -5
                    go to 30
                 end if
              end do
              30 continue
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSTEIN', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. m==0 ) then
              return
           else if( n==1 ) then
              z( 1, 1 ) = cone
              return
           end if
           ! get machine constants.
           eps = stdlib_slamch( 'PRECISION' )
           ! initialize seed for random number generator stdlib_slarnv.
           do i = 1, 4
              iseed( i ) = 1
           end do
           ! initialize pointers.
           indrv1 = 0
           indrv2 = indrv1 + n
           indrv3 = indrv2 + n
           indrv4 = indrv3 + n
           indrv5 = indrv4 + n
           ! compute eigenvectors of matrix blocks.
           j1 = 1
           loop_180: do nblk = 1, iblock( m )
              ! find starting and ending indices of block nblk.
              if( nblk==1 ) then
                 b1 = 1
              else
                 b1 = isplit( nblk-1 ) + 1
              end if
              bn = isplit( nblk )
              blksiz = bn - b1 + 1
              if( blksiz==1 )go to 60
              gpind = j1
              ! compute reorthogonalization criterion and stopping criterion.
              onenrm = abs( d( b1 ) ) + abs( e( b1 ) )
              onenrm = max( onenrm, abs( d( bn ) )+abs( e( bn-1 ) ) )
              do i = b1 + 1, bn - 1
                 onenrm = max( onenrm, abs( d( i ) )+abs( e( i-1 ) )+abs( e( i ) ) )
              end do
              ortol = odm3*onenrm
              stpcrt = sqrt( odm1 / blksiz )
              ! loop through eigenvalues of block nblk.
              60 continue
              jblk = 0
              loop_170: do j = j1, m
                 if( iblock( j )/=nblk ) then
                    j1 = j
                    cycle loop_180
                 end if
                 jblk = jblk + 1
                 xj = w( j )
                 ! skip all the work if the block size is one.
                 if( blksiz==1 ) then
                    work( indrv1+1 ) = one
                    go to 140
                 end if
                 ! if eigenvalues j and j-1 are too close, add a relatively
                 ! small perturbation.
                 if( jblk>1 ) then
                    eps1 = abs( eps*xj )
                    pertol = ten*eps1
                    sep = xj - xjm
                    if( sep<pertol )xj = xjm + pertol
                 end if
                 its = 0
                 nrmchk = 0
                 ! get random starting vector.
                 call stdlib_slarnv( 2, iseed, blksiz, work( indrv1+1 ) )
                 ! copy the matrix t so it won't be destroyed in factorization.
                 call stdlib_scopy( blksiz, d( b1 ), 1, work( indrv4+1 ), 1 )
                 call stdlib_scopy( blksiz-1, e( b1 ), 1, work( indrv2+2 ), 1 )
                 call stdlib_scopy( blksiz-1, e( b1 ), 1, work( indrv3+1 ), 1 )
                 ! compute lu factors with partial pivoting  ( pt = lu )
                 tol = zero
                 call stdlib_slagtf( blksiz, work( indrv4+1 ), xj, work( indrv2+2 ),work( indrv3+&
                           1 ), tol, work( indrv5+1 ), iwork,iinfo )
                 ! update iteration count.
                 70 continue
                 its = its + 1
                 if( its>maxits )go to 120
                 ! normalize and scale the righthand side vector pb.
                 jmax = stdlib_isamax( blksiz, work( indrv1+1 ), 1 )
                 scl = blksiz*onenrm*max( eps,abs( work( indrv4+blksiz ) ) ) /abs( work( indrv1+&
                           jmax ) )
                 call stdlib_sscal( blksiz, scl, work( indrv1+1 ), 1 )
                 ! solve the system lu = pb.
                 call stdlib_slagts( -1, blksiz, work( indrv4+1 ), work( indrv2+2 ),work( indrv3+&
                           1 ), work( indrv5+1 ), iwork,work( indrv1+1 ), tol, iinfo )
                 ! reorthogonalize by modified gram-schmidt if eigenvalues are
                 ! close enough.
                 if( jblk==1 )go to 110
                 if( abs( xj-xjm )>ortol )gpind = j
                 if( gpind/=j ) then
                    do i = gpind, j - 1
                       ctr = zero
                       do jr = 1, blksiz
                          ctr = ctr + work( indrv1+jr )*real( z( b1-1+jr, i ),KIND=sp)
                       end do
                       do jr = 1, blksiz
                          work( indrv1+jr ) = work( indrv1+jr ) -ctr*real( z( b1-1+jr, i ),&
                                    KIND=sp)
                       end do
                    end do
                 end if
                 ! check the infinity norm of the iterate.
                 110 continue
                 jmax = stdlib_isamax( blksiz, work( indrv1+1 ), 1 )
                 nrm = abs( work( indrv1+jmax ) )
                 ! continue for additional iterations after norm reaches
                 ! stopping criterion.
                 if( nrm<stpcrt )go to 70
                 nrmchk = nrmchk + 1
                 if( nrmchk<extra+1 )go to 70
                 go to 130
                 ! if stopping criterion was not satisfied, update info and
                 ! store eigenvector number in array ifail.
                 120 continue
                 info = info + 1
                 ifail( info ) = j
                 ! accept iterate as jth eigenvector.
                 130 continue
                 scl = one / stdlib_snrm2( blksiz, work( indrv1+1 ), 1 )
                 jmax = stdlib_isamax( blksiz, work( indrv1+1 ), 1 )
                 if( work( indrv1+jmax )<zero )scl = -scl
                 call stdlib_sscal( blksiz, scl, work( indrv1+1 ), 1 )
                 140 continue
                 do i = 1, n
                    z( i, j ) = czero
                 end do
                 do i = 1, blksiz
                    z( b1+i-1, j ) = cmplx( work( indrv1+i ), zero,KIND=sp)
                 end do
                 ! save the shift to check eigenvalue spacing at next
                 ! iteration.
                 xjm = xj
              end do loop_170
           end do loop_180
           return
     end subroutine stdlib_cstein

     pure subroutine stdlib_zstein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
     !! ZSTEIN computes the eigenvectors of a real symmetric tridiagonal
     !! matrix T corresponding to specified eigenvalues, using inverse
     !! iteration.
     !! The maximum number of iterations allowed for each eigenvector is
     !! specified by an internal parameter MAXITS (currently set to 5).
     !! Although the eigenvectors are real, they are stored in a complex
     !! array, which may be passed to ZUNMTR or ZUPMTR for back
     !! transformation to the eigenvectors of a complex Hermitian matrix
     !! which was reduced to tridiagonal form.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, m, n
           ! Array Arguments 
           integer(ilp), intent(in) :: iblock(*), isplit(*)
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(in) :: d(*), e(*), w(*)
           real(dp), intent(out) :: work(*)
           complex(dp), intent(out) :: z(ldz,*)
       ! =====================================================================
           ! Parameters 
           real(dp), parameter :: odm3 = 1.0e-3_dp
           real(dp), parameter :: odm1 = 1.0e-1_dp
           integer(ilp), parameter :: maxits = 5
           integer(ilp), parameter :: extra = 2
           
           
           
           ! Local Scalars 
           integer(ilp) :: b1, blksiz, bn, gpind, i, iinfo, indrv1, indrv2, indrv3, indrv4, &
                     indrv5, its, j, j1, jblk, jmax, jr, nblk, nrmchk
           real(dp) :: dtpcrt, eps, eps1, nrm, onenrm, ortol, pertol, scl, sep, tol, xj, xjm, &
                     ztr
           ! Local Arrays 
           integer(ilp) :: iseed(4)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           do i = 1, m
              ifail( i ) = 0
           end do
           if( n<0 ) then
              info = -1
           else if( m<0 .or. m>n ) then
              info = -4
           else if( ldz<max( 1, n ) ) then
              info = -9
           else
              do j = 2, m
                 if( iblock( j )<iblock( j-1 ) ) then
                    info = -6
                    go to 30
                 end if
                 if( iblock( j )==iblock( j-1 ) .and. w( j )<w( j-1 ) )then
                    info = -5
                    go to 30
                 end if
              end do
              30 continue
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSTEIN', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. m==0 ) then
              return
           else if( n==1 ) then
              z( 1, 1 ) = cone
              return
           end if
           ! get machine constants.
           eps = stdlib_dlamch( 'PRECISION' )
           ! initialize seed for random number generator stdlib_dlarnv.
           do i = 1, 4
              iseed( i ) = 1
           end do
           ! initialize pointers.
           indrv1 = 0
           indrv2 = indrv1 + n
           indrv3 = indrv2 + n
           indrv4 = indrv3 + n
           indrv5 = indrv4 + n
           ! compute eigenvectors of matrix blocks.
           j1 = 1
           loop_180: do nblk = 1, iblock( m )
              ! find starting and ending indices of block nblk.
              if( nblk==1 ) then
                 b1 = 1
              else
                 b1 = isplit( nblk-1 ) + 1
              end if
              bn = isplit( nblk )
              blksiz = bn - b1 + 1
              if( blksiz==1 )go to 60
              gpind = j1
              ! compute reorthogonalization criterion and stopping criterion.
              onenrm = abs( d( b1 ) ) + abs( e( b1 ) )
              onenrm = max( onenrm, abs( d( bn ) )+abs( e( bn-1 ) ) )
              do i = b1 + 1, bn - 1
                 onenrm = max( onenrm, abs( d( i ) )+abs( e( i-1 ) )+abs( e( i ) ) )
              end do
              ortol = odm3*onenrm
              dtpcrt = sqrt( odm1 / blksiz )
              ! loop through eigenvalues of block nblk.
              60 continue
              jblk = 0
              loop_170: do j = j1, m
                 if( iblock( j )/=nblk ) then
                    j1 = j
                    cycle loop_180
                 end if
                 jblk = jblk + 1
                 xj = w( j )
                 ! skip all the work if the block size is one.
                 if( blksiz==1 ) then
                    work( indrv1+1 ) = one
                    go to 140
                 end if
                 ! if eigenvalues j and j-1 are too close, add a relatively
                 ! small perturbation.
                 if( jblk>1 ) then
                    eps1 = abs( eps*xj )
                    pertol = ten*eps1
                    sep = xj - xjm
                    if( sep<pertol )xj = xjm + pertol
                 end if
                 its = 0
                 nrmchk = 0
                 ! get random starting vector.
                 call stdlib_dlarnv( 2, iseed, blksiz, work( indrv1+1 ) )
                 ! copy the matrix t so it won't be destroyed in factorization.
                 call stdlib_dcopy( blksiz, d( b1 ), 1, work( indrv4+1 ), 1 )
                 call stdlib_dcopy( blksiz-1, e( b1 ), 1, work( indrv2+2 ), 1 )
                 call stdlib_dcopy( blksiz-1, e( b1 ), 1, work( indrv3+1 ), 1 )
                 ! compute lu factors with partial pivoting  ( pt = lu )
                 tol = zero
                 call stdlib_dlagtf( blksiz, work( indrv4+1 ), xj, work( indrv2+2 ),work( indrv3+&
                           1 ), tol, work( indrv5+1 ), iwork,iinfo )
                 ! update iteration count.
                 70 continue
                 its = its + 1
                 if( its>maxits )go to 120
                 ! normalize and scale the righthand side vector pb.
                 jmax = stdlib_idamax( blksiz, work( indrv1+1 ), 1 )
                 scl = blksiz*onenrm*max( eps,abs( work( indrv4+blksiz ) ) ) /abs( work( indrv1+&
                           jmax ) )
                 call stdlib_dscal( blksiz, scl, work( indrv1+1 ), 1 )
                 ! solve the system lu = pb.
                 call stdlib_dlagts( -1, blksiz, work( indrv4+1 ), work( indrv2+2 ),work( indrv3+&
                           1 ), work( indrv5+1 ), iwork,work( indrv1+1 ), tol, iinfo )
                 ! reorthogonalize by modified gram-schmidt if eigenvalues are
                 ! close enough.
                 if( jblk==1 )go to 110
                 if( abs( xj-xjm )>ortol )gpind = j
                 if( gpind/=j ) then
                    do i = gpind, j - 1
                       ztr = zero
                       do jr = 1, blksiz
                          ztr = ztr + work( indrv1+jr )*real( z( b1-1+jr, i ),KIND=dp)
                       end do
                       do jr = 1, blksiz
                          work( indrv1+jr ) = work( indrv1+jr ) -ztr*real( z( b1-1+jr, i ),&
                                    KIND=dp)
                       end do
                    end do
                 end if
                 ! check the infinity norm of the iterate.
                 110 continue
                 jmax = stdlib_idamax( blksiz, work( indrv1+1 ), 1 )
                 nrm = abs( work( indrv1+jmax ) )
                 ! continue for additional iterations after norm reaches
                 ! stopping criterion.
                 if( nrm<dtpcrt )go to 70
                 nrmchk = nrmchk + 1
                 if( nrmchk<extra+1 )go to 70
                 go to 130
                 ! if stopping criterion was not satisfied, update info and
                 ! store eigenvector number in array ifail.
                 120 continue
                 info = info + 1
                 ifail( info ) = j
                 ! accept iterate as jth eigenvector.
                 130 continue
                 scl = one / stdlib_dnrm2( blksiz, work( indrv1+1 ), 1 )
                 jmax = stdlib_idamax( blksiz, work( indrv1+1 ), 1 )
                 if( work( indrv1+jmax )<zero )scl = -scl
                 call stdlib_dscal( blksiz, scl, work( indrv1+1 ), 1 )
                 140 continue
                 do i = 1, n
                    z( i, j ) = czero
                 end do
                 do i = 1, blksiz
                    z( b1+i-1, j ) = cmplx( work( indrv1+i ), zero,KIND=dp)
                 end do
                 ! save the shift to check eigenvalue spacing at next
                 ! iteration.
                 xjm = xj
              end do loop_170
           end do loop_180
           return
     end subroutine stdlib_zstein

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$stein( n, d, e, m, w, iblock, isplit, z, ldz, work,iwork, ifail, &
     !! ZSTEIN: computes the eigenvectors of a real symmetric tridiagonal
     !! matrix T corresponding to specified eigenvalues, using inverse
     !! iteration.
     !! The maximum number of iterations allowed for each eigenvector is
     !! specified by an internal parameter MAXITS (currently set to 5).
     !! Although the eigenvectors are real, they are stored in a complex
     !! array, which may be passed to ZUNMTR or ZUPMTR for back
     !! transformation to the eigenvectors of a complex Hermitian matrix
     !! which was reduced to tridiagonal form.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, m, n
           ! Array Arguments 
           integer(ilp), intent(in) :: iblock(*), isplit(*)
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(${ck}$), intent(in) :: d(*), e(*), w(*)
           real(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(out) :: z(ldz,*)
       ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: odm3 = 1.0e-3_${ck}$
           real(${ck}$), parameter :: odm1 = 1.0e-1_${ck}$
           integer(ilp), parameter :: maxits = 5
           integer(ilp), parameter :: extra = 2
           
           
           
           ! Local Scalars 
           integer(ilp) :: b1, blksiz, bn, gpind, i, iinfo, indrv1, indrv2, indrv3, indrv4, &
                     indrv5, its, j, j1, jblk, jmax, jr, nblk, nrmchk
           real(${ck}$) :: dtpcrt, eps, eps1, nrm, onenrm, ortol, pertol, scl, sep, tol, xj, xjm, &
                     ztr
           ! Local Arrays 
           integer(ilp) :: iseed(4)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           do i = 1, m
              ifail( i ) = 0
           end do
           if( n<0 ) then
              info = -1
           else if( m<0 .or. m>n ) then
              info = -4
           else if( ldz<max( 1, n ) ) then
              info = -9
           else
              do j = 2, m
                 if( iblock( j )<iblock( j-1 ) ) then
                    info = -6
                    go to 30
                 end if
                 if( iblock( j )==iblock( j-1 ) .and. w( j )<w( j-1 ) )then
                    info = -5
                    go to 30
                 end if
              end do
              30 continue
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSTEIN', -info )
              return
           end if
           ! quick return if possible
           if( n==0 .or. m==0 ) then
              return
           else if( n==1 ) then
              z( 1, 1 ) = cone
              return
           end if
           ! get machine constants.
           eps = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           ! initialize seed for random number generator stdlib_${c2ri(ci)}$larnv.
           do i = 1, 4
              iseed( i ) = 1
           end do
           ! initialize pointers.
           indrv1 = 0
           indrv2 = indrv1 + n
           indrv3 = indrv2 + n
           indrv4 = indrv3 + n
           indrv5 = indrv4 + n
           ! compute eigenvectors of matrix blocks.
           j1 = 1
           loop_180: do nblk = 1, iblock( m )
              ! find starting and ending indices of block nblk.
              if( nblk==1 ) then
                 b1 = 1
              else
                 b1 = isplit( nblk-1 ) + 1
              end if
              bn = isplit( nblk )
              blksiz = bn - b1 + 1
              if( blksiz==1 )go to 60
              gpind = j1
              ! compute reorthogonalization criterion and stopping criterion.
              onenrm = abs( d( b1 ) ) + abs( e( b1 ) )
              onenrm = max( onenrm, abs( d( bn ) )+abs( e( bn-1 ) ) )
              do i = b1 + 1, bn - 1
                 onenrm = max( onenrm, abs( d( i ) )+abs( e( i-1 ) )+abs( e( i ) ) )
              end do
              ortol = odm3*onenrm
              dtpcrt = sqrt( odm1 / blksiz )
              ! loop through eigenvalues of block nblk.
              60 continue
              jblk = 0
              loop_170: do j = j1, m
                 if( iblock( j )/=nblk ) then
                    j1 = j
                    cycle loop_180
                 end if
                 jblk = jblk + 1
                 xj = w( j )
                 ! skip all the work if the block size is one.
                 if( blksiz==1 ) then
                    work( indrv1+1 ) = one
                    go to 140
                 end if
                 ! if eigenvalues j and j-1 are too close, add a relatively
                 ! small perturbation.
                 if( jblk>1 ) then
                    eps1 = abs( eps*xj )
                    pertol = ten*eps1
                    sep = xj - xjm
                    if( sep<pertol )xj = xjm + pertol
                 end if
                 its = 0
                 nrmchk = 0
                 ! get random starting vector.
                 call stdlib_${c2ri(ci)}$larnv( 2, iseed, blksiz, work( indrv1+1 ) )
                 ! copy the matrix t so it won't be destroyed in factorization.
                 call stdlib_${c2ri(ci)}$copy( blksiz, d( b1 ), 1, work( indrv4+1 ), 1 )
                 call stdlib_${c2ri(ci)}$copy( blksiz-1, e( b1 ), 1, work( indrv2+2 ), 1 )
                 call stdlib_${c2ri(ci)}$copy( blksiz-1, e( b1 ), 1, work( indrv3+1 ), 1 )
                 ! compute lu factors with partial pivoting  ( pt = lu )
                 tol = zero
                 call stdlib_${c2ri(ci)}$lagtf( blksiz, work( indrv4+1 ), xj, work( indrv2+2 ),work( indrv3+&
                           1 ), tol, work( indrv5+1 ), iwork,iinfo )
                 ! update iteration count.
                 70 continue
                 its = its + 1
                 if( its>maxits )go to 120
                 ! normalize and scale the righthand side vector pb.
                 jmax = stdlib_i${c2ri(ci)}$amax( blksiz, work( indrv1+1 ), 1 )
                 scl = blksiz*onenrm*max( eps,abs( work( indrv4+blksiz ) ) ) /abs( work( indrv1+&
                           jmax ) )
                 call stdlib_${c2ri(ci)}$scal( blksiz, scl, work( indrv1+1 ), 1 )
                 ! solve the system lu = pb.
                 call stdlib_${c2ri(ci)}$lagts( -1, blksiz, work( indrv4+1 ), work( indrv2+2 ),work( indrv3+&
                           1 ), work( indrv5+1 ), iwork,work( indrv1+1 ), tol, iinfo )
                 ! reorthogonalize by modified gram-schmidt if eigenvalues are
                 ! close enough.
                 if( jblk==1 )go to 110
                 if( abs( xj-xjm )>ortol )gpind = j
                 if( gpind/=j ) then
                    do i = gpind, j - 1
                       ztr = zero
                       do jr = 1, blksiz
                          ztr = ztr + work( indrv1+jr )*real( z( b1-1+jr, i ),KIND=${ck}$)
                       end do
                       do jr = 1, blksiz
                          work( indrv1+jr ) = work( indrv1+jr ) -ztr*real( z( b1-1+jr, i ),&
                                    KIND=${ck}$)
                       end do
                    end do
                 end if
                 ! check the infinity norm of the iterate.
                 110 continue
                 jmax = stdlib_i${c2ri(ci)}$amax( blksiz, work( indrv1+1 ), 1 )
                 nrm = abs( work( indrv1+jmax ) )
                 ! continue for additional iterations after norm reaches
                 ! stopping criterion.
                 if( nrm<dtpcrt )go to 70
                 nrmchk = nrmchk + 1
                 if( nrmchk<extra+1 )go to 70
                 go to 130
                 ! if stopping criterion was not satisfied, update info and
                 ! store eigenvector number in array ifail.
                 120 continue
                 info = info + 1
                 ifail( info ) = j
                 ! accept iterate as jth eigenvector.
                 130 continue
                 scl = one / stdlib_${c2ri(ci)}$nrm2( blksiz, work( indrv1+1 ), 1 )
                 jmax = stdlib_i${c2ri(ci)}$amax( blksiz, work( indrv1+1 ), 1 )
                 if( work( indrv1+jmax )<zero )scl = -scl
                 call stdlib_${c2ri(ci)}$scal( blksiz, scl, work( indrv1+1 ), 1 )
                 140 continue
                 do i = 1, n
                    z( i, j ) = czero
                 end do
                 do i = 1, blksiz
                    z( b1+i-1, j ) = cmplx( work( indrv1+i ), zero,KIND=${ck}$)
                 end do
                 ! save the shift to check eigenvalue spacing at next
                 ! iteration.
                 xjm = xj
              end do loop_170
           end do loop_180
           return
     end subroutine stdlib_${ci}$stein

#:endif
#:endfor



     pure subroutine stdlib_slarrj( n, d, e2, ifirst, ilast,rtol, offset, w, werr, work, iwork,&
     pivmin, spdiam, info )
     !! Given the initial eigenvalue approximations of T, SLARRJ:
     !! does  bisection to refine the eigenvalues of T,
     !! W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial
     !! guesses for these eigenvalues are input in W, the corresponding estimate
     !! of the error in these guesses in WERR. During bisection, intervals
     !! [left, right] are maintained by storing their mid-points and
     !! semi-widths in the arrays W and WERR respectively.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ifirst, ilast, n, offset
           integer(ilp), intent(out) :: info
           real(sp), intent(in) :: pivmin, rtol, spdiam
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(in) :: d(*), e2(*)
           real(sp), intent(inout) :: w(*), werr(*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           integer(ilp) :: maxitr
           ! Local Scalars 
           integer(ilp) :: cnt, i, i1, i2, ii, iter, j, k, next, nint, olnint, p, prev, &
                     savi1
           real(sp) :: dplus, fac, left, mid, right, s, tmp, width
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           maxitr = int( ( log( spdiam+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
           ! initialize unconverged intervals in [ work(2*i-1), work(2*i) ].
           ! the sturm count, count( work(2*i-1) ) is arranged to be i-1, while
           ! count( work(2*i) ) is stored in iwork( 2*i ). the integer iwork( 2*i-1 )
           ! for an unconverged interval is set to the index of the next unconverged
           ! interval, and is -1 or 0 for a converged interval. thus a linked
           ! list of unconverged intervals is set up.
           i1 = ifirst
           i2 = ilast
           ! the number of unconverged intervals
           nint = 0
           ! the last unconverged interval found
           prev = 0
           loop_75: do i = i1, i2
              k = 2*i
              ii = i - offset
              left = w( ii ) - werr( ii )
              mid = w(ii)
              right = w( ii ) + werr( ii )
              width = right - mid
              tmp = max( abs( left ), abs( right ) )
              ! the following test prevents the test of converged intervals
              if( width<rtol*tmp ) then
                 ! this interval has already converged and does not need refinement.
                 ! (note that the gaps might change through refining the
                  ! eigenvalues, however, they can only get bigger.)
                 ! remove it from the list.
                 iwork( k-1 ) = -1
                 ! make sure that i1 always points to the first unconverged interval
                 if((i==i1).and.(i<i2)) i1 = i + 1
                 if((prev>=i1).and.(i<=i2)) iwork( 2*prev-1 ) = i + 1
              else
                 ! unconverged interval found
                 prev = i
                 ! make sure that [left,right] contains the desired eigenvalue
                 ! do while( cnt(left)>i-1 )
                 fac = one
                 20 continue
                 cnt = 0
                 s = left
                 dplus = d( 1 ) - s
                 if( dplus<zero ) cnt = cnt + 1
                 do j = 2, n
                    dplus = d( j ) - s - e2( j-1 )/dplus
                    if( dplus<zero ) cnt = cnt + 1
                 end do
                 if( cnt>i-1 ) then
                    left = left - werr( ii )*fac
                    fac = two*fac
                    go to 20
                 end if
                 ! do while( cnt(right)<i )
                 fac = one
                 50 continue
                 cnt = 0
                 s = right
                 dplus = d( 1 ) - s
                 if( dplus<zero ) cnt = cnt + 1
                 do j = 2, n
                    dplus = d( j ) - s - e2( j-1 )/dplus
                    if( dplus<zero ) cnt = cnt + 1
                 end do
                 if( cnt<i ) then
                    right = right + werr( ii )*fac
                    fac = two*fac
                    go to 50
                 end if
                 nint = nint + 1
                 iwork( k-1 ) = i + 1
                 iwork( k ) = cnt
              end if
              work( k-1 ) = left
              work( k ) = right
           end do loop_75
           savi1 = i1
           ! do while( nint>0 ), i.e. there are still unconverged intervals
           ! and while (iter<maxitr)
           iter = 0
           80 continue
           prev = i1 - 1
           i = i1
           olnint = nint
           loop_100: do p = 1, olnint
              k = 2*i
              ii = i - offset
              next = iwork( k-1 )
              left = work( k-1 )
              right = work( k )
              mid = half*( left + right )
              ! semiwidth of interval
              width = right - mid
              tmp = max( abs( left ), abs( right ) )
              if( ( width<rtol*tmp ) .or.(iter==maxitr) )then
                 ! reduce number of unconverged intervals
                 nint = nint - 1
                 ! mark interval as converged.
                 iwork( k-1 ) = 0
                 if( i1==i ) then
                    i1 = next
                 else
                    ! prev holds the last unconverged interval previously examined
                    if(prev>=i1) iwork( 2*prev-1 ) = next
                 end if
                 i = next
                 cycle loop_100
              end if
              prev = i
              ! perform one bisection step
              cnt = 0
              s = mid
              dplus = d( 1 ) - s
              if( dplus<zero ) cnt = cnt + 1
              do j = 2, n
                 dplus = d( j ) - s - e2( j-1 )/dplus
                 if( dplus<zero ) cnt = cnt + 1
              end do
              if( cnt<=i-1 ) then
                 work( k-1 ) = mid
              else
                 work( k ) = mid
              end if
              i = next
           end do loop_100
           iter = iter + 1
           ! do another loop if there are still unconverged intervals
           ! however, in the last iteration, all intervals are accepted
           ! since this is the best we can do.
           if( ( nint>0 ).and.(iter<=maxitr) ) go to 80
           ! at this point, all the intervals have converged
           do i = savi1, ilast
              k = 2*i
              ii = i - offset
              ! all intervals marked by '0' have been refined.
              if( iwork( k-1 )==0 ) then
                 w( ii ) = half*( work( k-1 )+work( k ) )
                 werr( ii ) = work( k ) - w( ii )
              end if
           end do
           return
     end subroutine stdlib_slarrj

     pure subroutine stdlib_dlarrj( n, d, e2, ifirst, ilast,rtol, offset, w, werr, work, iwork,&
     pivmin, spdiam, info )
     !! Given the initial eigenvalue approximations of T, DLARRJ:
     !! does  bisection to refine the eigenvalues of T,
     !! W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial
     !! guesses for these eigenvalues are input in W, the corresponding estimate
     !! of the error in these guesses in WERR. During bisection, intervals
     !! [left, right] are maintained by storing their mid-points and
     !! semi-widths in the arrays W and WERR respectively.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ifirst, ilast, n, offset
           integer(ilp), intent(out) :: info
           real(dp), intent(in) :: pivmin, rtol, spdiam
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(in) :: d(*), e2(*)
           real(dp), intent(inout) :: w(*), werr(*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           integer(ilp) :: maxitr
           ! Local Scalars 
           integer(ilp) :: cnt, i, i1, i2, ii, iter, j, k, next, nint, olnint, p, prev, &
                     savi1
           real(dp) :: dplus, fac, left, mid, right, s, tmp, width
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           maxitr = int( ( log( spdiam+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
           ! initialize unconverged intervals in [ work(2*i-1), work(2*i) ].
           ! the sturm count, count( work(2*i-1) ) is arranged to be i-1, while
           ! count( work(2*i) ) is stored in iwork( 2*i ). the integer iwork( 2*i-1 )
           ! for an unconverged interval is set to the index of the next unconverged
           ! interval, and is -1 or 0 for a converged interval. thus a linked
           ! list of unconverged intervals is set up.
           i1 = ifirst
           i2 = ilast
           ! the number of unconverged intervals
           nint = 0
           ! the last unconverged interval found
           prev = 0
           loop_75: do i = i1, i2
              k = 2*i
              ii = i - offset
              left = w( ii ) - werr( ii )
              mid = w(ii)
              right = w( ii ) + werr( ii )
              width = right - mid
              tmp = max( abs( left ), abs( right ) )
              ! the following test prevents the test of converged intervals
              if( width<rtol*tmp ) then
                 ! this interval has already converged and does not need refinement.
                 ! (note that the gaps might change through refining the
                  ! eigenvalues, however, they can only get bigger.)
                 ! remove it from the list.
                 iwork( k-1 ) = -1
                 ! make sure that i1 always points to the first unconverged interval
                 if((i==i1).and.(i<i2)) i1 = i + 1
                 if((prev>=i1).and.(i<=i2)) iwork( 2*prev-1 ) = i + 1
              else
                 ! unconverged interval found
                 prev = i
                 ! make sure that [left,right] contains the desired eigenvalue
                 ! do while( cnt(left)>i-1 )
                 fac = one
                 20 continue
                 cnt = 0
                 s = left
                 dplus = d( 1 ) - s
                 if( dplus<zero ) cnt = cnt + 1
                 do j = 2, n
                    dplus = d( j ) - s - e2( j-1 )/dplus
                    if( dplus<zero ) cnt = cnt + 1
                 end do
                 if( cnt>i-1 ) then
                    left = left - werr( ii )*fac
                    fac = two*fac
                    go to 20
                 end if
                 ! do while( cnt(right)<i )
                 fac = one
                 50 continue
                 cnt = 0
                 s = right
                 dplus = d( 1 ) - s
                 if( dplus<zero ) cnt = cnt + 1
                 do j = 2, n
                    dplus = d( j ) - s - e2( j-1 )/dplus
                    if( dplus<zero ) cnt = cnt + 1
                 end do
                 if( cnt<i ) then
                    right = right + werr( ii )*fac
                    fac = two*fac
                    go to 50
                 end if
                 nint = nint + 1
                 iwork( k-1 ) = i + 1
                 iwork( k ) = cnt
              end if
              work( k-1 ) = left
              work( k ) = right
           end do loop_75
           savi1 = i1
           ! do while( nint>0 ), i.e. there are still unconverged intervals
           ! and while (iter<maxitr)
           iter = 0
           80 continue
           prev = i1 - 1
           i = i1
           olnint = nint
           loop_100: do p = 1, olnint
              k = 2*i
              ii = i - offset
              next = iwork( k-1 )
              left = work( k-1 )
              right = work( k )
              mid = half*( left + right )
              ! semiwidth of interval
              width = right - mid
              tmp = max( abs( left ), abs( right ) )
              if( ( width<rtol*tmp ) .or.(iter==maxitr) )then
                 ! reduce number of unconverged intervals
                 nint = nint - 1
                 ! mark interval as converged.
                 iwork( k-1 ) = 0
                 if( i1==i ) then
                    i1 = next
                 else
                    ! prev holds the last unconverged interval previously examined
                    if(prev>=i1) iwork( 2*prev-1 ) = next
                 end if
                 i = next
                 cycle loop_100
              end if
              prev = i
              ! perform one bisection step
              cnt = 0
              s = mid
              dplus = d( 1 ) - s
              if( dplus<zero ) cnt = cnt + 1
              do j = 2, n
                 dplus = d( j ) - s - e2( j-1 )/dplus
                 if( dplus<zero ) cnt = cnt + 1
              end do
              if( cnt<=i-1 ) then
                 work( k-1 ) = mid
              else
                 work( k ) = mid
              end if
              i = next
           end do loop_100
           iter = iter + 1
           ! do another loop if there are still unconverged intervals
           ! however, in the last iteration, all intervals are accepted
           ! since this is the best we can do.
           if( ( nint>0 ).and.(iter<=maxitr) ) go to 80
           ! at this point, all the intervals have converged
           do i = savi1, ilast
              k = 2*i
              ii = i - offset
              ! all intervals marked by '0' have been refined.
              if( iwork( k-1 )==0 ) then
                 w( ii ) = half*( work( k-1 )+work( k ) )
                 werr( ii ) = work( k ) - w( ii )
              end if
           end do
           return
     end subroutine stdlib_dlarrj

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$larrj( n, d, e2, ifirst, ilast,rtol, offset, w, werr, work, iwork,&
     !! Given the initial eigenvalue approximations of T, DLARRJ:
     !! does  bisection to refine the eigenvalues of T,
     !! W( IFIRST-OFFSET ) through W( ILAST-OFFSET ), to more accuracy. Initial
     !! guesses for these eigenvalues are input in W, the corresponding estimate
     !! of the error in these guesses in WERR. During bisection, intervals
     !! [left, right] are maintained by storing their mid-points and
     !! semi-widths in the arrays W and WERR respectively.
               pivmin, spdiam, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: ifirst, ilast, n, offset
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(in) :: pivmin, rtol, spdiam
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: d(*), e2(*)
           real(${rk}$), intent(inout) :: w(*), werr(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           integer(ilp) :: maxitr
           ! Local Scalars 
           integer(ilp) :: cnt, i, i1, i2, ii, iter, j, k, next, nint, olnint, p, prev, &
                     savi1
           real(${rk}$) :: dplus, fac, left, mid, right, s, tmp, width
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           maxitr = int( ( log( spdiam+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
           ! initialize unconverged intervals in [ work(2*i-1), work(2*i) ].
           ! the sturm count, count( work(2*i-1) ) is arranged to be i-1, while
           ! count( work(2*i) ) is stored in iwork( 2*i ). the integer iwork( 2*i-1 )
           ! for an unconverged interval is set to the index of the next unconverged
           ! interval, and is -1 or 0 for a converged interval. thus a linked
           ! list of unconverged intervals is set up.
           i1 = ifirst
           i2 = ilast
           ! the number of unconverged intervals
           nint = 0
           ! the last unconverged interval found
           prev = 0
           loop_75: do i = i1, i2
              k = 2*i
              ii = i - offset
              left = w( ii ) - werr( ii )
              mid = w(ii)
              right = w( ii ) + werr( ii )
              width = right - mid
              tmp = max( abs( left ), abs( right ) )
              ! the following test prevents the test of converged intervals
              if( width<rtol*tmp ) then
                 ! this interval has already converged and does not need refinement.
                 ! (note that the gaps might change through refining the
                  ! eigenvalues, however, they can only get bigger.)
                 ! remove it from the list.
                 iwork( k-1 ) = -1
                 ! make sure that i1 always points to the first unconverged interval
                 if((i==i1).and.(i<i2)) i1 = i + 1
                 if((prev>=i1).and.(i<=i2)) iwork( 2*prev-1 ) = i + 1
              else
                 ! unconverged interval found
                 prev = i
                 ! make sure that [left,right] contains the desired eigenvalue
                 ! do while( cnt(left)>i-1 )
                 fac = one
                 20 continue
                 cnt = 0
                 s = left
                 dplus = d( 1 ) - s
                 if( dplus<zero ) cnt = cnt + 1
                 do j = 2, n
                    dplus = d( j ) - s - e2( j-1 )/dplus
                    if( dplus<zero ) cnt = cnt + 1
                 end do
                 if( cnt>i-1 ) then
                    left = left - werr( ii )*fac
                    fac = two*fac
                    go to 20
                 end if
                 ! do while( cnt(right)<i )
                 fac = one
                 50 continue
                 cnt = 0
                 s = right
                 dplus = d( 1 ) - s
                 if( dplus<zero ) cnt = cnt + 1
                 do j = 2, n
                    dplus = d( j ) - s - e2( j-1 )/dplus
                    if( dplus<zero ) cnt = cnt + 1
                 end do
                 if( cnt<i ) then
                    right = right + werr( ii )*fac
                    fac = two*fac
                    go to 50
                 end if
                 nint = nint + 1
                 iwork( k-1 ) = i + 1
                 iwork( k ) = cnt
              end if
              work( k-1 ) = left
              work( k ) = right
           end do loop_75
           savi1 = i1
           ! do while( nint>0 ), i.e. there are still unconverged intervals
           ! and while (iter<maxitr)
           iter = 0
           80 continue
           prev = i1 - 1
           i = i1
           olnint = nint
           loop_100: do p = 1, olnint
              k = 2*i
              ii = i - offset
              next = iwork( k-1 )
              left = work( k-1 )
              right = work( k )
              mid = half*( left + right )
              ! semiwidth of interval
              width = right - mid
              tmp = max( abs( left ), abs( right ) )
              if( ( width<rtol*tmp ) .or.(iter==maxitr) )then
                 ! reduce number of unconverged intervals
                 nint = nint - 1
                 ! mark interval as converged.
                 iwork( k-1 ) = 0
                 if( i1==i ) then
                    i1 = next
                 else
                    ! prev holds the last unconverged interval previously examined
                    if(prev>=i1) iwork( 2*prev-1 ) = next
                 end if
                 i = next
                 cycle loop_100
              end if
              prev = i
              ! perform one bisection step
              cnt = 0
              s = mid
              dplus = d( 1 ) - s
              if( dplus<zero ) cnt = cnt + 1
              do j = 2, n
                 dplus = d( j ) - s - e2( j-1 )/dplus
                 if( dplus<zero ) cnt = cnt + 1
              end do
              if( cnt<=i-1 ) then
                 work( k-1 ) = mid
              else
                 work( k ) = mid
              end if
              i = next
           end do loop_100
           iter = iter + 1
           ! do another loop if there are still unconverged intervals
           ! however, in the last iteration, all intervals are accepted
           ! since this is the best we can do.
           if( ( nint>0 ).and.(iter<=maxitr) ) go to 80
           ! at this point, all the intervals have converged
           do i = savi1, ilast
              k = 2*i
              ii = i - offset
              ! all intervals marked by '0' have been refined.
              if( iwork( k-1 )==0 ) then
                 w( ii ) = half*( work( k-1 )+work( k ) )
                 werr( ii ) = work( k ) - w( ii )
              end if
           end do
           return
     end subroutine stdlib_${ri}$larrj

#:endif
#:endfor



     pure subroutine stdlib_spteqr( compz, n, d, e, z, ldz, work, info )
     !! SPTEQR computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric positive definite tridiagonal matrix by first factoring the
     !! matrix using SPTTRF, and then calling SBDSQR to compute the singular
     !! values of the bidiagonal factor.
     !! This routine computes the eigenvalues of the positive definite
     !! tridiagonal matrix to high relative accuracy.  This means that if the
     !! eigenvalues range over many orders of magnitude in size, then the
     !! small eigenvalues and corresponding eigenvectors will be computed
     !! more accurately than, for example, with the standard QR method.
     !! The eigenvectors of a full or band symmetric positive definite matrix
     !! can also be found if SSYTRD, SSPTRD, or SSBTRD has been used to
     !! reduce this matrix to tridiagonal form. (The reduction to tridiagonal
     !! form, however, may preclude the possibility of obtaining high
     !! relative accuracy in the small eigenvalues of the original matrix, if
     !! these eigenvalues range over many orders of magnitude.)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(sp), intent(inout) :: d(*), e(*), z(ldz,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Arrays 
           real(sp) :: c(1,1), vt(1,1)
           ! Local Scalars 
           integer(ilp) :: i, icompz, nru
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or. ( icompz>0 .and. ldz<max( 1,n ) ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SPTEQR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz>0 )z( 1, 1 ) = one
              return
           end if
           if( icompz==2 )call stdlib_slaset( 'FULL', n, n, zero, one, z, ldz )
           ! call stdlib_spttrf to factor the matrix.
           call stdlib_spttrf( n, d, e, info )
           if( info/=0 )return
           do i = 1, n
              d( i ) = sqrt( d( i ) )
           end do
           do i = 1, n - 1
              e( i ) = e( i )*d( i )
           end do
           ! call stdlib_sbdsqr to compute the singular values/vectors of the
           ! bidiagonal factor.
           if( icompz>0 ) then
              nru = n
           else
              nru = 0
           end if
           call stdlib_sbdsqr( 'LOWER', n, 0, nru, 0, d, e, vt, 1, z, ldz, c, 1,work, info )
                     
           ! square the singular values.
           if( info==0 ) then
              do i = 1, n
                 d( i ) = d( i )*d( i )
              end do
           else
              info = n + info
           end if
           return
     end subroutine stdlib_spteqr

     pure subroutine stdlib_dpteqr( compz, n, d, e, z, ldz, work, info )
     !! DPTEQR computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric positive definite tridiagonal matrix by first factoring the
     !! matrix using DPTTRF, and then calling DBDSQR to compute the singular
     !! values of the bidiagonal factor.
     !! This routine computes the eigenvalues of the positive definite
     !! tridiagonal matrix to high relative accuracy.  This means that if the
     !! eigenvalues range over many orders of magnitude in size, then the
     !! small eigenvalues and corresponding eigenvectors will be computed
     !! more accurately than, for example, with the standard QR method.
     !! The eigenvectors of a full or band symmetric positive definite matrix
     !! can also be found if DSYTRD, DSPTRD, or DSBTRD has been used to
     !! reduce this matrix to tridiagonal form. (The reduction to tridiagonal
     !! form, however, may preclude the possibility of obtaining high
     !! relative accuracy in the small eigenvalues of the original matrix, if
     !! these eigenvalues range over many orders of magnitude.)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(dp), intent(inout) :: d(*), e(*), z(ldz,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Arrays 
           real(dp) :: c(1,1), vt(1,1)
           ! Local Scalars 
           integer(ilp) :: i, icompz, nru
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or. ( icompz>0 .and. ldz<max( 1,n ) ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPTEQR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz>0 )z( 1, 1 ) = one
              return
           end if
           if( icompz==2 )call stdlib_dlaset( 'FULL', n, n, zero, one, z, ldz )
           ! call stdlib_dpttrf to factor the matrix.
           call stdlib_dpttrf( n, d, e, info )
           if( info/=0 )return
           do i = 1, n
              d( i ) = sqrt( d( i ) )
           end do
           do i = 1, n - 1
              e( i ) = e( i )*d( i )
           end do
           ! call stdlib_dbdsqr to compute the singular values/vectors of the
           ! bidiagonal factor.
           if( icompz>0 ) then
              nru = n
           else
              nru = 0
           end if
           call stdlib_dbdsqr( 'LOWER', n, 0, nru, 0, d, e, vt, 1, z, ldz, c, 1,work, info )
                     
           ! square the singular values.
           if( info==0 ) then
              do i = 1, n
                 d( i ) = d( i )*d( i )
              end do
           else
              info = n + info
           end if
           return
     end subroutine stdlib_dpteqr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$pteqr( compz, n, d, e, z, ldz, work, info )
     !! DPTEQR: computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric positive definite tridiagonal matrix by first factoring the
     !! matrix using DPTTRF, and then calling DBDSQR to compute the singular
     !! values of the bidiagonal factor.
     !! This routine computes the eigenvalues of the positive definite
     !! tridiagonal matrix to high relative accuracy.  This means that if the
     !! eigenvalues range over many orders of magnitude in size, then the
     !! small eigenvalues and corresponding eigenvectors will be computed
     !! more accurately than, for example, with the standard QR method.
     !! The eigenvectors of a full or band symmetric positive definite matrix
     !! can also be found if DSYTRD, DSPTRD, or DSBTRD has been used to
     !! reduce this matrix to tridiagonal form. (The reduction to tridiagonal
     !! form, however, may preclude the possibility of obtaining high
     !! relative accuracy in the small eigenvalues of the original matrix, if
     !! these eigenvalues range over many orders of magnitude.)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: d(*), e(*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Arrays 
           real(${rk}$) :: c(1,1), vt(1,1)
           ! Local Scalars 
           integer(ilp) :: i, icompz, nru
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or. ( icompz>0 .and. ldz<max( 1,n ) ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPTEQR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz>0 )z( 1, 1 ) = one
              return
           end if
           if( icompz==2 )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, z, ldz )
           ! call stdlib_${ri}$pttrf to factor the matrix.
           call stdlib_${ri}$pttrf( n, d, e, info )
           if( info/=0 )return
           do i = 1, n
              d( i ) = sqrt( d( i ) )
           end do
           do i = 1, n - 1
              e( i ) = e( i )*d( i )
           end do
           ! call stdlib_${ri}$bdsqr to compute the singular values/vectors of the
           ! bidiagonal factor.
           if( icompz>0 ) then
              nru = n
           else
              nru = 0
           end if
           call stdlib_${ri}$bdsqr( 'LOWER', n, 0, nru, 0, d, e, vt, 1, z, ldz, c, 1,work, info )
                     
           ! square the singular values.
           if( info==0 ) then
              do i = 1, n
                 d( i ) = d( i )*d( i )
              end do
           else
              info = n + info
           end if
           return
     end subroutine stdlib_${ri}$pteqr

#:endif
#:endfor

     pure subroutine stdlib_cpteqr( compz, n, d, e, z, ldz, work, info )
     !! CPTEQR computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric positive definite tridiagonal matrix by first factoring the
     !! matrix using SPTTRF and then calling CBDSQR to compute the singular
     !! values of the bidiagonal factor.
     !! This routine computes the eigenvalues of the positive definite
     !! tridiagonal matrix to high relative accuracy.  This means that if the
     !! eigenvalues range over many orders of magnitude in size, then the
     !! small eigenvalues and corresponding eigenvectors will be computed
     !! more accurately than, for example, with the standard QR method.
     !! The eigenvectors of a full or band positive definite Hermitian matrix
     !! can also be found if CHETRD, CHPTRD, or CHBTRD has been used to
     !! reduce this matrix to tridiagonal form.  (The reduction to
     !! tridiagonal form, however, may preclude the possibility of obtaining
     !! high relative accuracy in the small eigenvalues of the original
     !! matrix, if these eigenvalues range over many orders of magnitude.)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: z(ldz,*)
        ! ====================================================================
           
           ! Local Arrays 
           complex(sp) :: c(1,1), vt(1,1)
           ! Local Scalars 
           integer(ilp) :: i, icompz, nru
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or. ( icompz>0 .and. ldz<max( 1,n ) ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPTEQR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz>0 )z( 1, 1 ) = cone
              return
           end if
           if( icompz==2 )call stdlib_claset( 'FULL', n, n, czero, cone, z, ldz )
           ! call stdlib_spttrf to factor the matrix.
           call stdlib_spttrf( n, d, e, info )
           if( info/=0 )return
           do i = 1, n
              d( i ) = sqrt( d( i ) )
           end do
           do i = 1, n - 1
              e( i ) = e( i )*d( i )
           end do
           ! call stdlib_cbdsqr to compute the singular values/vectors of the
           ! bidiagonal factor.
           if( icompz>0 ) then
              nru = n
           else
              nru = 0
           end if
           call stdlib_cbdsqr( 'LOWER', n, 0, nru, 0, d, e, vt, 1, z, ldz, c, 1,work, info )
                     
           ! square the singular values.
           if( info==0 ) then
              do i = 1, n
                 d( i ) = d( i )*d( i )
              end do
           else
              info = n + info
           end if
           return
     end subroutine stdlib_cpteqr

     pure subroutine stdlib_zpteqr( compz, n, d, e, z, ldz, work, info )
     !! ZPTEQR computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric positive definite tridiagonal matrix by first factoring the
     !! matrix using DPTTRF and then calling ZBDSQR to compute the singular
     !! values of the bidiagonal factor.
     !! This routine computes the eigenvalues of the positive definite
     !! tridiagonal matrix to high relative accuracy.  This means that if the
     !! eigenvalues range over many orders of magnitude in size, then the
     !! small eigenvalues and corresponding eigenvectors will be computed
     !! more accurately than, for example, with the standard QR method.
     !! The eigenvectors of a full or band positive definite Hermitian matrix
     !! can also be found if ZHETRD, ZHPTRD, or ZHBTRD has been used to
     !! reduce this matrix to tridiagonal form.  (The reduction to
     !! tridiagonal form, however, may preclude the possibility of obtaining
     !! high relative accuracy in the small eigenvalues of the original
     !! matrix, if these eigenvalues range over many orders of magnitude.)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: work(*)
           complex(dp), intent(inout) :: z(ldz,*)
        ! ====================================================================
           
           ! Local Arrays 
           complex(dp) :: c(1,1), vt(1,1)
           ! Local Scalars 
           integer(ilp) :: i, icompz, nru
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or. ( icompz>0 .and. ldz<max( 1,n ) ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZPTEQR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz>0 )z( 1, 1 ) = cone
              return
           end if
           if( icompz==2 )call stdlib_zlaset( 'FULL', n, n, czero, cone, z, ldz )
           ! call stdlib_dpttrf to factor the matrix.
           call stdlib_dpttrf( n, d, e, info )
           if( info/=0 )return
           do i = 1, n
              d( i ) = sqrt( d( i ) )
           end do
           do i = 1, n - 1
              e( i ) = e( i )*d( i )
           end do
           ! call stdlib_zbdsqr to compute the singular values/vectors of the
           ! bidiagonal factor.
           if( icompz>0 ) then
              nru = n
           else
              nru = 0
           end if
           call stdlib_zbdsqr( 'LOWER', n, 0, nru, 0, d, e, vt, 1, z, ldz, c, 1,work, info )
                     
           ! square the singular values.
           if( info==0 ) then
              do i = 1, n
                 d( i ) = d( i )*d( i )
              end do
           else
              info = n + info
           end if
           return
     end subroutine stdlib_zpteqr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$pteqr( compz, n, d, e, z, ldz, work, info )
     !! ZPTEQR: computes all eigenvalues and, optionally, eigenvectors of a
     !! symmetric positive definite tridiagonal matrix by first factoring the
     !! matrix using DPTTRF and then calling ZBDSQR to compute the singular
     !! values of the bidiagonal factor.
     !! This routine computes the eigenvalues of the positive definite
     !! tridiagonal matrix to high relative accuracy.  This means that if the
     !! eigenvalues range over many orders of magnitude in size, then the
     !! small eigenvalues and corresponding eigenvectors will be computed
     !! more accurately than, for example, with the standard QR method.
     !! The eigenvectors of a full or band positive definite Hermitian matrix
     !! can also be found if ZHETRD, ZHPTRD, or ZHBTRD has been used to
     !! reduce this matrix to tridiagonal form.  (The reduction to
     !! tridiagonal form, however, may preclude the possibility of obtaining
     !! high relative accuracy in the small eigenvalues of the original
     !! matrix, if these eigenvalues range over many orders of magnitude.)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldz, n
           ! Array Arguments 
           real(${ck}$), intent(inout) :: d(*), e(*)
           real(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(inout) :: z(ldz,*)
        ! ====================================================================
           
           ! Local Arrays 
           complex(${ck}$) :: c(1,1), vt(1,1)
           ! Local Scalars 
           integer(ilp) :: i, icompz, nru
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( stdlib_lsame( compz, 'N' ) ) then
              icompz = 0
           else if( stdlib_lsame( compz, 'V' ) ) then
              icompz = 1
           else if( stdlib_lsame( compz, 'I' ) ) then
              icompz = 2
           else
              icompz = -1
           end if
           if( icompz<0 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ( ldz<1 ) .or. ( icompz>0 .and. ldz<max( 1,n ) ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZPTEQR', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( n==1 ) then
              if( icompz>0 )z( 1, 1 ) = cone
              return
           end if
           if( icompz==2 )call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, z, ldz )
           ! call stdlib_${c2ri(ci)}$pttrf to factor the matrix.
           call stdlib_${c2ri(ci)}$pttrf( n, d, e, info )
           if( info/=0 )return
           do i = 1, n
              d( i ) = sqrt( d( i ) )
           end do
           do i = 1, n - 1
              e( i ) = e( i )*d( i )
           end do
           ! call stdlib_${ci}$bdsqr to compute the singular values/vectors of the
           ! bidiagonal factor.
           if( icompz>0 ) then
              nru = n
           else
              nru = 0
           end if
           call stdlib_${ci}$bdsqr( 'LOWER', n, 0, nru, 0, d, e, vt, 1, z, ldz, c, 1,work, info )
                     
           ! square the singular values.
           if( info==0 ) then
              do i = 1, n
                 d( i ) = d( i )*d( i )
              end do
           else
              info = n + info
           end if
           return
     end subroutine stdlib_${ci}$pteqr

#:endif
#:endfor



     pure subroutine stdlib_chbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )
     !! CHBTRD reduces a complex Hermitian band matrix A to real symmetric
     !! tridiagonal form T by a unitary similarity transformation:
     !! Q**H * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, vect
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldq, n
           ! Array Arguments 
           real(sp), intent(out) :: d(*), e(*)
           complex(sp), intent(inout) :: ab(ldab,*), q(ldq,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: initq, upper, wantq
           integer(ilp) :: i, i2, ibl, inca, incx, iqaend, iqb, iqend, j, j1, j1end, j1inc, j2, &
                     jend, jin, jinc, k, kd1, kdm1, kdn, l, last, lend, nq, nr, nrt
           real(sp) :: abst
           complex(sp) :: t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           initq = stdlib_lsame( vect, 'V' )
           wantq = initq .or. stdlib_lsame( vect, 'U' )
           upper = stdlib_lsame( uplo, 'U' )
           kd1 = kd + 1
           kdm1 = kd - 1
           incx = ldab - 1
           iqend = 1
           info = 0
           if( .not.wantq .and. .not.stdlib_lsame( vect, 'N' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( kd<0 ) then
              info = -4
           else if( ldab<kd1 ) then
              info = -6
           else if( ldq<max( 1, n ) .and. wantq ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHBTRD', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! initialize q to the unit matrix, if needed
           if( initq )call stdlib_claset( 'FULL', n, n, czero, cone, q, ldq )
           ! wherever possible, plane rotations are generated and applied in
           ! vector operations of length nr over the index set j1:j2:kd1.
           ! the real cosines and complex sines of the plane rotations are
           ! stored in the arrays d and work.
           inca = kd1*ldab
           kdn = min( n-1, kd )
           if( upper ) then
              if( kd>1 ) then
                 ! reduce to complex hermitian tridiagonal form, working with
                 ! the upper triangle
                 nr = 0
                 j1 = kdn + 2
                 j2 = 1
                 ab( kd1, 1 ) = real( ab( kd1, 1 ),KIND=sp)
                 loop_90: do i = 1, n - 2
                    ! reduce i-th row of matrix to tridiagonal form
                    loop_80: do k = kdn + 1, 2, -1
                       j1 = j1 + kdn
                       j2 = j2 + kdn
                       if( nr>0 ) then
                          ! generate plane rotations to annihilate nonzero
                          ! elements which have been created outside the band
                          call stdlib_clargv( nr, ab( 1, j1-1 ), inca, work( j1 ),kd1, d( j1 ), &
                                    kd1 )
                          ! apply rotations from the right
                          ! dependent on the the number of diagonals either
                          ! stdlib_clartv or stdlib_crot is used
                          if( nr>=2*kd-1 ) then
                             do l = 1, kd - 1
                                call stdlib_clartv( nr, ab( l+1, j1-1 ), inca,ab( l, j1 ), inca, &
                                          d( j1 ),work( j1 ), kd1 )
                             end do
                          else
                             jend = j1 + ( nr-1 )*kd1
                             do jinc = j1, jend, kd1
                                call stdlib_crot( kdm1, ab( 2, jinc-1 ), 1,ab( 1, jinc ), 1, d( &
                                          jinc ),work( jinc ) )
                             end do
                          end if
                       end if
                       if( k>2 ) then
                          if( k<=n-i+1 ) then
                             ! generate plane rotation to annihilate a(i,i+k-1)
                             ! within the band
                             call stdlib_clartg( ab( kd-k+3, i+k-2 ),ab( kd-k+2, i+k-1 ), d( i+k-&
                                       1 ),work( i+k-1 ), temp )
                             ab( kd-k+3, i+k-2 ) = temp
                             ! apply rotation from the right
                             call stdlib_crot( k-3, ab( kd-k+4, i+k-2 ), 1,ab( kd-k+3, i+k-1 ), 1,&
                                        d( i+k-1 ),work( i+k-1 ) )
                          end if
                          nr = nr + 1
                          j1 = j1 - kdn - 1
                       end if
                       ! apply plane rotations from both sides to diagonal
                       ! blocks
                       if( nr>0 )call stdlib_clar2v( nr, ab( kd1, j1-1 ), ab( kd1, j1 ),ab( kd, &
                                 j1 ), inca, d( j1 ),work( j1 ), kd1 )
                       ! apply plane rotations from the left
                       if( nr>0 ) then
                          call stdlib_clacgv( nr, work( j1 ), kd1 )
                          if( 2*kd-1<nr ) then
                          ! dependent on the the number of diagonals either
                          ! stdlib_clartv or stdlib_crot is used
                             do l = 1, kd - 1
                                if( j2+l>n ) then
                                   nrt = nr - 1
                                else
                                   nrt = nr
                                end if
                                if( nrt>0 )call stdlib_clartv( nrt, ab( kd-l, j1+l ), inca,ab( kd-&
                                          l+1, j1+l ), inca,d( j1 ), work( j1 ), kd1 )
                             end do
                          else
                             j1end = j1 + kd1*( nr-2 )
                             if( j1end>=j1 ) then
                                do jin = j1, j1end, kd1
                                   call stdlib_crot( kd-1, ab( kd-1, jin+1 ), incx,ab( kd, jin+1 )&
                                             , incx,d( jin ), work( jin ) )
                                end do
                             end if
                             lend = min( kdm1, n-j2 )
                             last = j1end + kd1
                             if( lend>0 )call stdlib_crot( lend, ab( kd-1, last+1 ), incx,ab( kd, &
                                       last+1 ), incx, d( last ),work( last ) )
                          end if
                       end if
                       if( wantq ) then
                          ! accumulate product of plane rotations in q
                          if( initq ) then
                       ! take advantage of the fact that q was
                       ! initially the identity matrix
                             iqend = max( iqend, j2 )
                             i2 = max( 0, k-3 )
                             iqaend = 1 + i*kd
                             if( k==2 )iqaend = iqaend + kd
                             iqaend = min( iqaend, iqend )
                             do j = j1, j2, kd1
                                ibl = i - i2 / kdm1
                                i2 = i2 + 1
                                iqb = max( 1, j-ibl )
                                nq = 1 + iqaend - iqb
                                iqaend = min( iqaend+kd, iqend )
                                call stdlib_crot( nq, q( iqb, j-1 ), 1, q( iqb, j ),1, d( j ), &
                                          conjg( work( j ) ) )
                             end do
                          else
                             do j = j1, j2, kd1
                                call stdlib_crot( n, q( 1, j-1 ), 1, q( 1, j ), 1,d( j ), conjg( &
                                          work( j ) ) )
                             end do
                          end if
                       end if
                       if( j2+kdn>n ) then
                          ! adjust j2 to keep within the bounds of the matrix
                          nr = nr - 1
                          j2 = j2 - kdn - 1
                       end if
                       do j = j1, j2, kd1
                          ! create nonzero element a(j-1,j+kd) outside the band
                          ! and store it in work
                          work( j+kd ) = work( j )*ab( 1, j+kd )
                          ab( 1, j+kd ) = d( j )*ab( 1, j+kd )
                       end do
                    end do loop_80
                 end do loop_90
              end if
              if( kd>0 ) then
                 ! make off-diagonal elements real and copy them to e
                 do i = 1, n - 1
                    t = ab( kd, i+1 )
                    abst = abs( t )
                    ab( kd, i+1 ) = abst
                    e( i ) = abst
                    if( abst/=zero ) then
                       t = t / abst
                    else
                       t = cone
                    end if
                    if( i<n-1 )ab( kd, i+2 ) = ab( kd, i+2 )*t
                    if( wantq ) then
                       call stdlib_cscal( n, conjg( t ), q( 1, i+1 ), 1 )
                    end if
                 end do
              else
                 ! set e to zero if original matrix was diagonal
                 do i = 1, n - 1
                    e( i ) = zero
                 end do
              end if
              ! copy diagonal elements to d
              do i = 1, n
                 d( i ) = real( ab( kd1, i ),KIND=sp)
              end do
           else
              if( kd>1 ) then
                 ! reduce to complex hermitian tridiagonal form, working with
                 ! the lower triangle
                 nr = 0
                 j1 = kdn + 2
                 j2 = 1
                 ab( 1, 1 ) = real( ab( 1, 1 ),KIND=sp)
                 loop_210: do i = 1, n - 2
                    ! reduce i-th column of matrix to tridiagonal form
                    loop_200: do k = kdn + 1, 2, -1
                       j1 = j1 + kdn
                       j2 = j2 + kdn
                       if( nr>0 ) then
                          ! generate plane rotations to annihilate nonzero
                          ! elements which have been created outside the band
                          call stdlib_clargv( nr, ab( kd1, j1-kd1 ), inca,work( j1 ), kd1, d( j1 )&
                                    , kd1 )
                          ! apply plane rotations from one side
                          ! dependent on the the number of diagonals either
                          ! stdlib_clartv or stdlib_crot is used
                          if( nr>2*kd-1 ) then
                             do l = 1, kd - 1
                                call stdlib_clartv( nr, ab( kd1-l, j1-kd1+l ), inca,ab( kd1-l+1, &
                                          j1-kd1+l ), inca,d( j1 ), work( j1 ), kd1 )
                             end do
                          else
                             jend = j1 + kd1*( nr-1 )
                             do jinc = j1, jend, kd1
                                call stdlib_crot( kdm1, ab( kd, jinc-kd ), incx,ab( kd1, jinc-kd )&
                                          , incx,d( jinc ), work( jinc ) )
                             end do
                          end if
                       end if
                       if( k>2 ) then
                          if( k<=n-i+1 ) then
                             ! generate plane rotation to annihilate a(i+k-1,i)
                             ! within the band
                             call stdlib_clartg( ab( k-1, i ), ab( k, i ),d( i+k-1 ), work( i+k-1 &
                                       ), temp )
                             ab( k-1, i ) = temp
                             ! apply rotation from the left
                             call stdlib_crot( k-3, ab( k-2, i+1 ), ldab-1,ab( k-1, i+1 ), ldab-1,&
                                        d( i+k-1 ),work( i+k-1 ) )
                          end if
                          nr = nr + 1
                          j1 = j1 - kdn - 1
                       end if
                       ! apply plane rotations from both sides to diagonal
                       ! blocks
                       if( nr>0 )call stdlib_clar2v( nr, ab( 1, j1-1 ), ab( 1, j1 ),ab( 2, j1-1 ),&
                                  inca, d( j1 ),work( j1 ), kd1 )
                       ! apply plane rotations from the right
                          ! dependent on the the number of diagonals either
                          ! stdlib_clartv or stdlib_crot is used
                       if( nr>0 ) then
                          call stdlib_clacgv( nr, work( j1 ), kd1 )
                          if( nr>2*kd-1 ) then
                             do l = 1, kd - 1
                                if( j2+l>n ) then
                                   nrt = nr - 1
                                else
                                   nrt = nr
                                end if
                                if( nrt>0 )call stdlib_clartv( nrt, ab( l+2, j1-1 ), inca,ab( l+1,&
                                           j1 ), inca, d( j1 ),work( j1 ), kd1 )
                             end do
                          else
                             j1end = j1 + kd1*( nr-2 )
                             if( j1end>=j1 ) then
                                do j1inc = j1, j1end, kd1
                                   call stdlib_crot( kdm1, ab( 3, j1inc-1 ), 1,ab( 2, j1inc ), 1, &
                                             d( j1inc ),work( j1inc ) )
                                end do
                             end if
                             lend = min( kdm1, n-j2 )
                             last = j1end + kd1
                             if( lend>0 )call stdlib_crot( lend, ab( 3, last-1 ), 1,ab( 2, last ),&
                                        1, d( last ),work( last ) )
                          end if
                       end if
                       if( wantq ) then
                          ! accumulate product of plane rotations in q
                          if( initq ) then
                       ! take advantage of the fact that q was
                       ! initially the identity matrix
                             iqend = max( iqend, j2 )
                             i2 = max( 0, k-3 )
                             iqaend = 1 + i*kd
                             if( k==2 )iqaend = iqaend + kd
                             iqaend = min( iqaend, iqend )
                             do j = j1, j2, kd1
                                ibl = i - i2 / kdm1
                                i2 = i2 + 1
                                iqb = max( 1, j-ibl )
                                nq = 1 + iqaend - iqb
                                iqaend = min( iqaend+kd, iqend )
                                call stdlib_crot( nq, q( iqb, j-1 ), 1, q( iqb, j ),1, d( j ), &
                                          work( j ) )
                             end do
                          else
                             do j = j1, j2, kd1
                                call stdlib_crot( n, q( 1, j-1 ), 1, q( 1, j ), 1,d( j ), work( j &
                                          ) )
                             end do
                          end if
                       end if
                       if( j2+kdn>n ) then
                          ! adjust j2 to keep within the bounds of the matrix
                          nr = nr - 1
                          j2 = j2 - kdn - 1
                       end if
                       do j = j1, j2, kd1
                          ! create nonzero element a(j+kd,j-1) outside the
                          ! band and store it in work
                          work( j+kd ) = work( j )*ab( kd1, j )
                          ab( kd1, j ) = d( j )*ab( kd1, j )
                       end do
                    end do loop_200
                 end do loop_210
              end if
              if( kd>0 ) then
                 ! make off-diagonal elements real and copy them to e
                 do i = 1, n - 1
                    t = ab( 2, i )
                    abst = abs( t )
                    ab( 2, i ) = abst
                    e( i ) = abst
                    if( abst/=zero ) then
                       t = t / abst
                    else
                       t = cone
                    end if
                    if( i<n-1 )ab( 2, i+1 ) = ab( 2, i+1 )*t
                    if( wantq ) then
                       call stdlib_cscal( n, t, q( 1, i+1 ), 1 )
                    end if
                 end do
              else
                 ! set e to zero if original matrix was diagonal
                 do i = 1, n - 1
                    e( i ) = zero
                 end do
              end if
              ! copy diagonal elements to d
              do i = 1, n
                 d( i ) = real( ab( 1, i ),KIND=sp)
              end do
           end if
           return
     end subroutine stdlib_chbtrd

     pure subroutine stdlib_zhbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )
     !! ZHBTRD reduces a complex Hermitian band matrix A to real symmetric
     !! tridiagonal form T by a unitary similarity transformation:
     !! Q**H * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, vect
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldq, n
           ! Array Arguments 
           real(dp), intent(out) :: d(*), e(*)
           complex(dp), intent(inout) :: ab(ldab,*), q(ldq,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: initq, upper, wantq
           integer(ilp) :: i, i2, ibl, inca, incx, iqaend, iqb, iqend, j, j1, j1end, j1inc, j2, &
                     jend, jin, jinc, k, kd1, kdm1, kdn, l, last, lend, nq, nr, nrt
           real(dp) :: abst
           complex(dp) :: t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           initq = stdlib_lsame( vect, 'V' )
           wantq = initq .or. stdlib_lsame( vect, 'U' )
           upper = stdlib_lsame( uplo, 'U' )
           kd1 = kd + 1
           kdm1 = kd - 1
           incx = ldab - 1
           iqend = 1
           info = 0
           if( .not.wantq .and. .not.stdlib_lsame( vect, 'N' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( kd<0 ) then
              info = -4
           else if( ldab<kd1 ) then
              info = -6
           else if( ldq<max( 1, n ) .and. wantq ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHBTRD', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! initialize q to the unit matrix, if needed
           if( initq )call stdlib_zlaset( 'FULL', n, n, czero, cone, q, ldq )
           ! wherever possible, plane rotations are generated and applied in
           ! vector operations of length nr over the index set j1:j2:kd1.
           ! the real cosines and complex sines of the plane rotations are
           ! stored in the arrays d and work.
           inca = kd1*ldab
           kdn = min( n-1, kd )
           if( upper ) then
              if( kd>1 ) then
                 ! reduce to complex hermitian tridiagonal form, working with
                 ! the upper triangle
                 nr = 0
                 j1 = kdn + 2
                 j2 = 1
                 ab( kd1, 1 ) = real( ab( kd1, 1 ),KIND=dp)
                 loop_90: do i = 1, n - 2
                    ! reduce i-th row of matrix to tridiagonal form
                    loop_80: do k = kdn + 1, 2, -1
                       j1 = j1 + kdn
                       j2 = j2 + kdn
                       if( nr>0 ) then
                          ! generate plane rotations to annihilate nonzero
                          ! elements which have been created outside the band
                          call stdlib_zlargv( nr, ab( 1, j1-1 ), inca, work( j1 ),kd1, d( j1 ), &
                                    kd1 )
                          ! apply rotations from the right
                          ! dependent on the the number of diagonals either
                          ! stdlib_zlartv or stdlib_zrot is used
                          if( nr>=2*kd-1 ) then
                             do l = 1, kd - 1
                                call stdlib_zlartv( nr, ab( l+1, j1-1 ), inca,ab( l, j1 ), inca, &
                                          d( j1 ),work( j1 ), kd1 )
                             end do
                          else
                             jend = j1 + ( nr-1 )*kd1
                             do jinc = j1, jend, kd1
                                call stdlib_zrot( kdm1, ab( 2, jinc-1 ), 1,ab( 1, jinc ), 1, d( &
                                          jinc ),work( jinc ) )
                             end do
                          end if
                       end if
                       if( k>2 ) then
                          if( k<=n-i+1 ) then
                             ! generate plane rotation to annihilate a(i,i+k-1)
                             ! within the band
                             call stdlib_zlartg( ab( kd-k+3, i+k-2 ),ab( kd-k+2, i+k-1 ), d( i+k-&
                                       1 ),work( i+k-1 ), temp )
                             ab( kd-k+3, i+k-2 ) = temp
                             ! apply rotation from the right
                             call stdlib_zrot( k-3, ab( kd-k+4, i+k-2 ), 1,ab( kd-k+3, i+k-1 ), 1,&
                                        d( i+k-1 ),work( i+k-1 ) )
                          end if
                          nr = nr + 1
                          j1 = j1 - kdn - 1
                       end if
                       ! apply plane rotations from both sides to diagonal
                       ! blocks
                       if( nr>0 )call stdlib_zlar2v( nr, ab( kd1, j1-1 ), ab( kd1, j1 ),ab( kd, &
                                 j1 ), inca, d( j1 ),work( j1 ), kd1 )
                       ! apply plane rotations from the left
                       if( nr>0 ) then
                          call stdlib_zlacgv( nr, work( j1 ), kd1 )
                          if( 2*kd-1<nr ) then
                          ! dependent on the the number of diagonals either
                          ! stdlib_zlartv or stdlib_zrot is used
                             do l = 1, kd - 1
                                if( j2+l>n ) then
                                   nrt = nr - 1
                                else
                                   nrt = nr
                                end if
                                if( nrt>0 )call stdlib_zlartv( nrt, ab( kd-l, j1+l ), inca,ab( kd-&
                                          l+1, j1+l ), inca,d( j1 ), work( j1 ), kd1 )
                             end do
                          else
                             j1end = j1 + kd1*( nr-2 )
                             if( j1end>=j1 ) then
                                do jin = j1, j1end, kd1
                                   call stdlib_zrot( kd-1, ab( kd-1, jin+1 ), incx,ab( kd, jin+1 )&
                                             , incx,d( jin ), work( jin ) )
                                end do
                             end if
                             lend = min( kdm1, n-j2 )
                             last = j1end + kd1
                             if( lend>0 )call stdlib_zrot( lend, ab( kd-1, last+1 ), incx,ab( kd, &
                                       last+1 ), incx, d( last ),work( last ) )
                          end if
                       end if
                       if( wantq ) then
                          ! accumulate product of plane rotations in q
                          if( initq ) then
                       ! take advantage of the fact that q was
                       ! initially the identity matrix
                             iqend = max( iqend, j2 )
                             i2 = max( 0, k-3 )
                             iqaend = 1 + i*kd
                             if( k==2 )iqaend = iqaend + kd
                             iqaend = min( iqaend, iqend )
                             do j = j1, j2, kd1
                                ibl = i - i2 / kdm1
                                i2 = i2 + 1
                                iqb = max( 1, j-ibl )
                                nq = 1 + iqaend - iqb
                                iqaend = min( iqaend+kd, iqend )
                                call stdlib_zrot( nq, q( iqb, j-1 ), 1, q( iqb, j ),1, d( j ), &
                                          conjg( work( j ) ) )
                             end do
                          else
                             do j = j1, j2, kd1
                                call stdlib_zrot( n, q( 1, j-1 ), 1, q( 1, j ), 1,d( j ), conjg( &
                                          work( j ) ) )
                             end do
                          end if
                       end if
                       if( j2+kdn>n ) then
                          ! adjust j2 to keep within the bounds of the matrix
                          nr = nr - 1
                          j2 = j2 - kdn - 1
                       end if
                       do j = j1, j2, kd1
                          ! create nonzero element a(j-1,j+kd) outside the band
                          ! and store it in work
                          work( j+kd ) = work( j )*ab( 1, j+kd )
                          ab( 1, j+kd ) = d( j )*ab( 1, j+kd )
                       end do
                    end do loop_80
                 end do loop_90
              end if
              if( kd>0 ) then
                 ! make off-diagonal elements real and copy them to e
                 do i = 1, n - 1
                    t = ab( kd, i+1 )
                    abst = abs( t )
                    ab( kd, i+1 ) = abst
                    e( i ) = abst
                    if( abst/=zero ) then
                       t = t / abst
                    else
                       t = cone
                    end if
                    if( i<n-1 )ab( kd, i+2 ) = ab( kd, i+2 )*t
                    if( wantq ) then
                       call stdlib_zscal( n, conjg( t ), q( 1, i+1 ), 1 )
                    end if
                 end do
              else
                 ! set e to zero if original matrix was diagonal
                 do i = 1, n - 1
                    e( i ) = zero
                 end do
              end if
              ! copy diagonal elements to d
              do i = 1, n
                 d( i ) = real( ab( kd1, i ),KIND=dp)
              end do
           else
              if( kd>1 ) then
                 ! reduce to complex hermitian tridiagonal form, working with
                 ! the lower triangle
                 nr = 0
                 j1 = kdn + 2
                 j2 = 1
                 ab( 1, 1 ) = real( ab( 1, 1 ),KIND=dp)
                 loop_210: do i = 1, n - 2
                    ! reduce i-th column of matrix to tridiagonal form
                    loop_200: do k = kdn + 1, 2, -1
                       j1 = j1 + kdn
                       j2 = j2 + kdn
                       if( nr>0 ) then
                          ! generate plane rotations to annihilate nonzero
                          ! elements which have been created outside the band
                          call stdlib_zlargv( nr, ab( kd1, j1-kd1 ), inca,work( j1 ), kd1, d( j1 )&
                                    , kd1 )
                          ! apply plane rotations from one side
                          ! dependent on the the number of diagonals either
                          ! stdlib_zlartv or stdlib_zrot is used
                          if( nr>2*kd-1 ) then
                             do l = 1, kd - 1
                                call stdlib_zlartv( nr, ab( kd1-l, j1-kd1+l ), inca,ab( kd1-l+1, &
                                          j1-kd1+l ), inca,d( j1 ), work( j1 ), kd1 )
                             end do
                          else
                             jend = j1 + kd1*( nr-1 )
                             do jinc = j1, jend, kd1
                                call stdlib_zrot( kdm1, ab( kd, jinc-kd ), incx,ab( kd1, jinc-kd )&
                                          , incx,d( jinc ), work( jinc ) )
                             end do
                          end if
                       end if
                       if( k>2 ) then
                          if( k<=n-i+1 ) then
                             ! generate plane rotation to annihilate a(i+k-1,i)
                             ! within the band
                             call stdlib_zlartg( ab( k-1, i ), ab( k, i ),d( i+k-1 ), work( i+k-1 &
                                       ), temp )
                             ab( k-1, i ) = temp
                             ! apply rotation from the left
                             call stdlib_zrot( k-3, ab( k-2, i+1 ), ldab-1,ab( k-1, i+1 ), ldab-1,&
                                        d( i+k-1 ),work( i+k-1 ) )
                          end if
                          nr = nr + 1
                          j1 = j1 - kdn - 1
                       end if
                       ! apply plane rotations from both sides to diagonal
                       ! blocks
                       if( nr>0 )call stdlib_zlar2v( nr, ab( 1, j1-1 ), ab( 1, j1 ),ab( 2, j1-1 ),&
                                  inca, d( j1 ),work( j1 ), kd1 )
                       ! apply plane rotations from the right
                          ! dependent on the the number of diagonals either
                          ! stdlib_zlartv or stdlib_zrot is used
                       if( nr>0 ) then
                          call stdlib_zlacgv( nr, work( j1 ), kd1 )
                          if( nr>2*kd-1 ) then
                             do l = 1, kd - 1
                                if( j2+l>n ) then
                                   nrt = nr - 1
                                else
                                   nrt = nr
                                end if
                                if( nrt>0 )call stdlib_zlartv( nrt, ab( l+2, j1-1 ), inca,ab( l+1,&
                                           j1 ), inca, d( j1 ),work( j1 ), kd1 )
                             end do
                          else
                             j1end = j1 + kd1*( nr-2 )
                             if( j1end>=j1 ) then
                                do j1inc = j1, j1end, kd1
                                   call stdlib_zrot( kdm1, ab( 3, j1inc-1 ), 1,ab( 2, j1inc ), 1, &
                                             d( j1inc ),work( j1inc ) )
                                end do
                             end if
                             lend = min( kdm1, n-j2 )
                             last = j1end + kd1
                             if( lend>0 )call stdlib_zrot( lend, ab( 3, last-1 ), 1,ab( 2, last ),&
                                        1, d( last ),work( last ) )
                          end if
                       end if
                       if( wantq ) then
                          ! accumulate product of plane rotations in q
                          if( initq ) then
                       ! take advantage of the fact that q was
                       ! initially the identity matrix
                             iqend = max( iqend, j2 )
                             i2 = max( 0, k-3 )
                             iqaend = 1 + i*kd
                             if( k==2 )iqaend = iqaend + kd
                             iqaend = min( iqaend, iqend )
                             do j = j1, j2, kd1
                                ibl = i - i2 / kdm1
                                i2 = i2 + 1
                                iqb = max( 1, j-ibl )
                                nq = 1 + iqaend - iqb
                                iqaend = min( iqaend+kd, iqend )
                                call stdlib_zrot( nq, q( iqb, j-1 ), 1, q( iqb, j ),1, d( j ), &
                                          work( j ) )
                             end do
                          else
                             do j = j1, j2, kd1
                                call stdlib_zrot( n, q( 1, j-1 ), 1, q( 1, j ), 1,d( j ), work( j &
                                          ) )
                             end do
                          end if
                       end if
                       if( j2+kdn>n ) then
                          ! adjust j2 to keep within the bounds of the matrix
                          nr = nr - 1
                          j2 = j2 - kdn - 1
                       end if
                       do j = j1, j2, kd1
                          ! create nonzero element a(j+kd,j-1) outside the
                          ! band and store it in work
                          work( j+kd ) = work( j )*ab( kd1, j )
                          ab( kd1, j ) = d( j )*ab( kd1, j )
                       end do
                    end do loop_200
                 end do loop_210
              end if
              if( kd>0 ) then
                 ! make off-diagonal elements real and copy them to e
                 do i = 1, n - 1
                    t = ab( 2, i )
                    abst = abs( t )
                    ab( 2, i ) = abst
                    e( i ) = abst
                    if( abst/=zero ) then
                       t = t / abst
                    else
                       t = cone
                    end if
                    if( i<n-1 )ab( 2, i+1 ) = ab( 2, i+1 )*t
                    if( wantq ) then
                       call stdlib_zscal( n, t, q( 1, i+1 ), 1 )
                    end if
                 end do
              else
                 ! set e to zero if original matrix was diagonal
                 do i = 1, n - 1
                    e( i ) = zero
                 end do
              end if
              ! copy diagonal elements to d
              do i = 1, n
                 d( i ) = real( ab( 1, i ),KIND=dp)
              end do
           end if
           return
     end subroutine stdlib_zhbtrd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$hbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )
     !! ZHBTRD: reduces a complex Hermitian band matrix A to real symmetric
     !! tridiagonal form T by a unitary similarity transformation:
     !! Q**H * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, vect
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldq, n
           ! Array Arguments 
           real(${ck}$), intent(out) :: d(*), e(*)
           complex(${ck}$), intent(inout) :: ab(ldab,*), q(ldq,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: initq, upper, wantq
           integer(ilp) :: i, i2, ibl, inca, incx, iqaend, iqb, iqend, j, j1, j1end, j1inc, j2, &
                     jend, jin, jinc, k, kd1, kdm1, kdn, l, last, lend, nq, nr, nrt
           real(${ck}$) :: abst
           complex(${ck}$) :: t, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           initq = stdlib_lsame( vect, 'V' )
           wantq = initq .or. stdlib_lsame( vect, 'U' )
           upper = stdlib_lsame( uplo, 'U' )
           kd1 = kd + 1
           kdm1 = kd - 1
           incx = ldab - 1
           iqend = 1
           info = 0
           if( .not.wantq .and. .not.stdlib_lsame( vect, 'N' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( kd<0 ) then
              info = -4
           else if( ldab<kd1 ) then
              info = -6
           else if( ldq<max( 1, n ) .and. wantq ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHBTRD', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! initialize q to the unit matrix, if needed
           if( initq )call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, q, ldq )
           ! wherever possible, plane rotations are generated and applied in
           ! vector operations of length nr over the index set j1:j2:kd1.
           ! the real cosines and complex sines of the plane rotations are
           ! stored in the arrays d and work.
           inca = kd1*ldab
           kdn = min( n-1, kd )
           if( upper ) then
              if( kd>1 ) then
                 ! reduce to complex hermitian tridiagonal form, working with
                 ! the upper triangle
                 nr = 0
                 j1 = kdn + 2
                 j2 = 1
                 ab( kd1, 1 ) = real( ab( kd1, 1 ),KIND=${ck}$)
                 loop_90: do i = 1, n - 2
                    ! reduce i-th row of matrix to tridiagonal form
                    loop_80: do k = kdn + 1, 2, -1
                       j1 = j1 + kdn
                       j2 = j2 + kdn
                       if( nr>0 ) then
                          ! generate plane rotations to annihilate nonzero
                          ! elements which have been created outside the band
                          call stdlib_${ci}$largv( nr, ab( 1, j1-1 ), inca, work( j1 ),kd1, d( j1 ), &
                                    kd1 )
                          ! apply rotations from the right
                          ! dependent on the the number of diagonals either
                          ! stdlib_${ci}$lartv or stdlib_${ci}$rot is used
                          if( nr>=2*kd-1 ) then
                             do l = 1, kd - 1
                                call stdlib_${ci}$lartv( nr, ab( l+1, j1-1 ), inca,ab( l, j1 ), inca, &
                                          d( j1 ),work( j1 ), kd1 )
                             end do
                          else
                             jend = j1 + ( nr-1 )*kd1
                             do jinc = j1, jend, kd1
                                call stdlib_${ci}$rot( kdm1, ab( 2, jinc-1 ), 1,ab( 1, jinc ), 1, d( &
                                          jinc ),work( jinc ) )
                             end do
                          end if
                       end if
                       if( k>2 ) then
                          if( k<=n-i+1 ) then
                             ! generate plane rotation to annihilate a(i,i+k-1)
                             ! within the band
                             call stdlib_${ci}$lartg( ab( kd-k+3, i+k-2 ),ab( kd-k+2, i+k-1 ), d( i+k-&
                                       1 ),work( i+k-1 ), temp )
                             ab( kd-k+3, i+k-2 ) = temp
                             ! apply rotation from the right
                             call stdlib_${ci}$rot( k-3, ab( kd-k+4, i+k-2 ), 1,ab( kd-k+3, i+k-1 ), 1,&
                                        d( i+k-1 ),work( i+k-1 ) )
                          end if
                          nr = nr + 1
                          j1 = j1 - kdn - 1
                       end if
                       ! apply plane rotations from both sides to diagonal
                       ! blocks
                       if( nr>0 )call stdlib_${ci}$lar2v( nr, ab( kd1, j1-1 ), ab( kd1, j1 ),ab( kd, &
                                 j1 ), inca, d( j1 ),work( j1 ), kd1 )
                       ! apply plane rotations from the left
                       if( nr>0 ) then
                          call stdlib_${ci}$lacgv( nr, work( j1 ), kd1 )
                          if( 2*kd-1<nr ) then
                          ! dependent on the the number of diagonals either
                          ! stdlib_${ci}$lartv or stdlib_${ci}$rot is used
                             do l = 1, kd - 1
                                if( j2+l>n ) then
                                   nrt = nr - 1
                                else
                                   nrt = nr
                                end if
                                if( nrt>0 )call stdlib_${ci}$lartv( nrt, ab( kd-l, j1+l ), inca,ab( kd-&
                                          l+1, j1+l ), inca,d( j1 ), work( j1 ), kd1 )
                             end do
                          else
                             j1end = j1 + kd1*( nr-2 )
                             if( j1end>=j1 ) then
                                do jin = j1, j1end, kd1
                                   call stdlib_${ci}$rot( kd-1, ab( kd-1, jin+1 ), incx,ab( kd, jin+1 )&
                                             , incx,d( jin ), work( jin ) )
                                end do
                             end if
                             lend = min( kdm1, n-j2 )
                             last = j1end + kd1
                             if( lend>0 )call stdlib_${ci}$rot( lend, ab( kd-1, last+1 ), incx,ab( kd, &
                                       last+1 ), incx, d( last ),work( last ) )
                          end if
                       end if
                       if( wantq ) then
                          ! accumulate product of plane rotations in q
                          if( initq ) then
                       ! take advantage of the fact that q was
                       ! initially the identity matrix
                             iqend = max( iqend, j2 )
                             i2 = max( 0, k-3 )
                             iqaend = 1 + i*kd
                             if( k==2 )iqaend = iqaend + kd
                             iqaend = min( iqaend, iqend )
                             do j = j1, j2, kd1
                                ibl = i - i2 / kdm1
                                i2 = i2 + 1
                                iqb = max( 1, j-ibl )
                                nq = 1 + iqaend - iqb
                                iqaend = min( iqaend+kd, iqend )
                                call stdlib_${ci}$rot( nq, q( iqb, j-1 ), 1, q( iqb, j ),1, d( j ), &
                                          conjg( work( j ) ) )
                             end do
                          else
                             do j = j1, j2, kd1
                                call stdlib_${ci}$rot( n, q( 1, j-1 ), 1, q( 1, j ), 1,d( j ), conjg( &
                                          work( j ) ) )
                             end do
                          end if
                       end if
                       if( j2+kdn>n ) then
                          ! adjust j2 to keep within the bounds of the matrix
                          nr = nr - 1
                          j2 = j2 - kdn - 1
                       end if
                       do j = j1, j2, kd1
                          ! create nonzero element a(j-1,j+kd) outside the band
                          ! and store it in work
                          work( j+kd ) = work( j )*ab( 1, j+kd )
                          ab( 1, j+kd ) = d( j )*ab( 1, j+kd )
                       end do
                    end do loop_80
                 end do loop_90
              end if
              if( kd>0 ) then
                 ! make off-diagonal elements real and copy them to e
                 do i = 1, n - 1
                    t = ab( kd, i+1 )
                    abst = abs( t )
                    ab( kd, i+1 ) = abst
                    e( i ) = abst
                    if( abst/=zero ) then
                       t = t / abst
                    else
                       t = cone
                    end if
                    if( i<n-1 )ab( kd, i+2 ) = ab( kd, i+2 )*t
                    if( wantq ) then
                       call stdlib_${ci}$scal( n, conjg( t ), q( 1, i+1 ), 1 )
                    end if
                 end do
              else
                 ! set e to zero if original matrix was diagonal
                 do i = 1, n - 1
                    e( i ) = zero
                 end do
              end if
              ! copy diagonal elements to d
              do i = 1, n
                 d( i ) = real( ab( kd1, i ),KIND=${ck}$)
              end do
           else
              if( kd>1 ) then
                 ! reduce to complex hermitian tridiagonal form, working with
                 ! the lower triangle
                 nr = 0
                 j1 = kdn + 2
                 j2 = 1
                 ab( 1, 1 ) = real( ab( 1, 1 ),KIND=${ck}$)
                 loop_210: do i = 1, n - 2
                    ! reduce i-th column of matrix to tridiagonal form
                    loop_200: do k = kdn + 1, 2, -1
                       j1 = j1 + kdn
                       j2 = j2 + kdn
                       if( nr>0 ) then
                          ! generate plane rotations to annihilate nonzero
                          ! elements which have been created outside the band
                          call stdlib_${ci}$largv( nr, ab( kd1, j1-kd1 ), inca,work( j1 ), kd1, d( j1 )&
                                    , kd1 )
                          ! apply plane rotations from one side
                          ! dependent on the the number of diagonals either
                          ! stdlib_${ci}$lartv or stdlib_${ci}$rot is used
                          if( nr>2*kd-1 ) then
                             do l = 1, kd - 1
                                call stdlib_${ci}$lartv( nr, ab( kd1-l, j1-kd1+l ), inca,ab( kd1-l+1, &
                                          j1-kd1+l ), inca,d( j1 ), work( j1 ), kd1 )
                             end do
                          else
                             jend = j1 + kd1*( nr-1 )
                             do jinc = j1, jend, kd1
                                call stdlib_${ci}$rot( kdm1, ab( kd, jinc-kd ), incx,ab( kd1, jinc-kd )&
                                          , incx,d( jinc ), work( jinc ) )
                             end do
                          end if
                       end if
                       if( k>2 ) then
                          if( k<=n-i+1 ) then
                             ! generate plane rotation to annihilate a(i+k-1,i)
                             ! within the band
                             call stdlib_${ci}$lartg( ab( k-1, i ), ab( k, i ),d( i+k-1 ), work( i+k-1 &
                                       ), temp )
                             ab( k-1, i ) = temp
                             ! apply rotation from the left
                             call stdlib_${ci}$rot( k-3, ab( k-2, i+1 ), ldab-1,ab( k-1, i+1 ), ldab-1,&
                                        d( i+k-1 ),work( i+k-1 ) )
                          end if
                          nr = nr + 1
                          j1 = j1 - kdn - 1
                       end if
                       ! apply plane rotations from both sides to diagonal
                       ! blocks
                       if( nr>0 )call stdlib_${ci}$lar2v( nr, ab( 1, j1-1 ), ab( 1, j1 ),ab( 2, j1-1 ),&
                                  inca, d( j1 ),work( j1 ), kd1 )
                       ! apply plane rotations from the right
                          ! dependent on the the number of diagonals either
                          ! stdlib_${ci}$lartv or stdlib_${ci}$rot is used
                       if( nr>0 ) then
                          call stdlib_${ci}$lacgv( nr, work( j1 ), kd1 )
                          if( nr>2*kd-1 ) then
                             do l = 1, kd - 1
                                if( j2+l>n ) then
                                   nrt = nr - 1
                                else
                                   nrt = nr
                                end if
                                if( nrt>0 )call stdlib_${ci}$lartv( nrt, ab( l+2, j1-1 ), inca,ab( l+1,&
                                           j1 ), inca, d( j1 ),work( j1 ), kd1 )
                             end do
                          else
                             j1end = j1 + kd1*( nr-2 )
                             if( j1end>=j1 ) then
                                do j1inc = j1, j1end, kd1
                                   call stdlib_${ci}$rot( kdm1, ab( 3, j1inc-1 ), 1,ab( 2, j1inc ), 1, &
                                             d( j1inc ),work( j1inc ) )
                                end do
                             end if
                             lend = min( kdm1, n-j2 )
                             last = j1end + kd1
                             if( lend>0 )call stdlib_${ci}$rot( lend, ab( 3, last-1 ), 1,ab( 2, last ),&
                                        1, d( last ),work( last ) )
                          end if
                       end if
                       if( wantq ) then
                          ! accumulate product of plane rotations in q
                          if( initq ) then
                       ! take advantage of the fact that q was
                       ! initially the identity matrix
                             iqend = max( iqend, j2 )
                             i2 = max( 0, k-3 )
                             iqaend = 1 + i*kd
                             if( k==2 )iqaend = iqaend + kd
                             iqaend = min( iqaend, iqend )
                             do j = j1, j2, kd1
                                ibl = i - i2 / kdm1
                                i2 = i2 + 1
                                iqb = max( 1, j-ibl )
                                nq = 1 + iqaend - iqb
                                iqaend = min( iqaend+kd, iqend )
                                call stdlib_${ci}$rot( nq, q( iqb, j-1 ), 1, q( iqb, j ),1, d( j ), &
                                          work( j ) )
                             end do
                          else
                             do j = j1, j2, kd1
                                call stdlib_${ci}$rot( n, q( 1, j-1 ), 1, q( 1, j ), 1,d( j ), work( j &
                                          ) )
                             end do
                          end if
                       end if
                       if( j2+kdn>n ) then
                          ! adjust j2 to keep within the bounds of the matrix
                          nr = nr - 1
                          j2 = j2 - kdn - 1
                       end if
                       do j = j1, j2, kd1
                          ! create nonzero element a(j+kd,j-1) outside the
                          ! band and store it in work
                          work( j+kd ) = work( j )*ab( kd1, j )
                          ab( kd1, j ) = d( j )*ab( kd1, j )
                       end do
                    end do loop_200
                 end do loop_210
              end if
              if( kd>0 ) then
                 ! make off-diagonal elements real and copy them to e
                 do i = 1, n - 1
                    t = ab( 2, i )
                    abst = abs( t )
                    ab( 2, i ) = abst
                    e( i ) = abst
                    if( abst/=zero ) then
                       t = t / abst
                    else
                       t = cone
                    end if
                    if( i<n-1 )ab( 2, i+1 ) = ab( 2, i+1 )*t
                    if( wantq ) then
                       call stdlib_${ci}$scal( n, t, q( 1, i+1 ), 1 )
                    end if
                 end do
              else
                 ! set e to zero if original matrix was diagonal
                 do i = 1, n - 1
                    e( i ) = zero
                 end do
              end if
              ! copy diagonal elements to d
              do i = 1, n
                 d( i ) = real( ab( 1, i ),KIND=${ck}$)
              end do
           end if
           return
     end subroutine stdlib_${ci}$hbtrd

#:endif
#:endfor



     pure subroutine stdlib_slarrk( n, iw, gl, gu,d, e2, pivmin, reltol, w, werr, info)
     !! SLARRK computes one eigenvalue of a symmetric tridiagonal
     !! matrix T to suitable accuracy. This is an auxiliary code to be
     !! called from SSTEMR.
     !! To avoid overflow, the matrix must be scaled so that its
     !! largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
     !! accuracy, it should not be much smaller than that.
     !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
     !! Matrix", Report CS41, Computer Science Dept., Stanford
     !! University, July 21, 1966.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: iw, n
           real(sp), intent(in) :: pivmin, reltol, gl, gu
           real(sp), intent(out) :: w, werr
           ! Array Arguments 
           real(sp), intent(in) :: d(*), e2(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: fudge = two
           
           ! Local Scalars 
           integer(ilp) :: i, it, itmax, negcnt
           real(sp) :: atoli, eps, left, mid, right, rtoli, tmp1, tmp2, tnorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              info = 0
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           tnorm = max( abs( gl ), abs( gu ) )
           rtoli = reltol
           atoli = fudge*two*pivmin
           itmax = int( ( log( tnorm+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
           info = -1
           left = gl - fudge*tnorm*eps*n - fudge*two*pivmin
           right = gu + fudge*tnorm*eps*n + fudge*two*pivmin
           it = 0
           10 continue
           ! check if interval converged or maximum number of iterations reached
           tmp1 = abs( right - left )
           tmp2 = max( abs(right), abs(left) )
           if( tmp1<max( atoli, pivmin, rtoli*tmp2 ) ) then
              info = 0
              goto 30
           endif
           if(it>itmax)goto 30
           ! count number of negative pivots for mid-point
           it = it + 1
           mid = half * (left + right)
           negcnt = 0
           tmp1 = d( 1 ) - mid
           if( abs( tmp1 )<pivmin )tmp1 = -pivmin
           if( tmp1<=zero )negcnt = negcnt + 1
           do i = 2, n
              tmp1 = d( i ) - e2( i-1 ) / tmp1 - mid
              if( abs( tmp1 )<pivmin )tmp1 = -pivmin
              if( tmp1<=zero )negcnt = negcnt + 1
           end do
           if(negcnt>=iw) then
              right = mid
           else
              left = mid
           endif
           goto 10
           30 continue
           ! converged or maximum number of iterations reached
           w = half * (left + right)
           werr = half * abs( right - left )
           return
     end subroutine stdlib_slarrk

     pure subroutine stdlib_dlarrk( n, iw, gl, gu,d, e2, pivmin, reltol, w, werr, info)
     !! DLARRK computes one eigenvalue of a symmetric tridiagonal
     !! matrix T to suitable accuracy. This is an auxiliary code to be
     !! called from DSTEMR.
     !! To avoid overflow, the matrix must be scaled so that its
     !! largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
     !! accuracy, it should not be much smaller than that.
     !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
     !! Matrix", Report CS41, Computer Science Dept., Stanford
     !! University, July 21, 1966.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: iw, n
           real(dp), intent(in) :: pivmin, reltol, gl, gu
           real(dp), intent(out) :: w, werr
           ! Array Arguments 
           real(dp), intent(in) :: d(*), e2(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: fudge = two
           
           ! Local Scalars 
           integer(ilp) :: i, it, itmax, negcnt
           real(dp) :: atoli, eps, left, mid, right, rtoli, tmp1, tmp2, tnorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              info = 0
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           tnorm = max( abs( gl ), abs( gu ) )
           rtoli = reltol
           atoli = fudge*two*pivmin
           itmax = int( ( log( tnorm+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
           info = -1
           left = gl - fudge*tnorm*eps*n - fudge*two*pivmin
           right = gu + fudge*tnorm*eps*n + fudge*two*pivmin
           it = 0
           10 continue
           ! check if interval converged or maximum number of iterations reached
           tmp1 = abs( right - left )
           tmp2 = max( abs(right), abs(left) )
           if( tmp1<max( atoli, pivmin, rtoli*tmp2 ) ) then
              info = 0
              goto 30
           endif
           if(it>itmax)goto 30
           ! count number of negative pivots for mid-point
           it = it + 1
           mid = half * (left + right)
           negcnt = 0
           tmp1 = d( 1 ) - mid
           if( abs( tmp1 )<pivmin )tmp1 = -pivmin
           if( tmp1<=zero )negcnt = negcnt + 1
           do i = 2, n
              tmp1 = d( i ) - e2( i-1 ) / tmp1 - mid
              if( abs( tmp1 )<pivmin )tmp1 = -pivmin
              if( tmp1<=zero )negcnt = negcnt + 1
           end do
           if(negcnt>=iw) then
              right = mid
           else
              left = mid
           endif
           goto 10
           30 continue
           ! converged or maximum number of iterations reached
           w = half * (left + right)
           werr = half * abs( right - left )
           return
     end subroutine stdlib_dlarrk

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$larrk( n, iw, gl, gu,d, e2, pivmin, reltol, w, werr, info)
     !! DLARRK: computes one eigenvalue of a symmetric tridiagonal
     !! matrix T to suitable accuracy. This is an auxiliary code to be
     !! called from DSTEMR.
     !! To avoid overflow, the matrix must be scaled so that its
     !! largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
     !! accuracy, it should not be much smaller than that.
     !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
     !! Matrix", Report CS41, Computer Science Dept., Stanford
     !! University, July 21, 1966.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: iw, n
           real(${rk}$), intent(in) :: pivmin, reltol, gl, gu
           real(${rk}$), intent(out) :: w, werr
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(*), e2(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: fudge = two
           
           ! Local Scalars 
           integer(ilp) :: i, it, itmax, negcnt
           real(${rk}$) :: atoli, eps, left, mid, right, rtoli, tmp1, tmp2, tnorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! quick return if possible
           if( n<=0 ) then
              info = 0
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           tnorm = max( abs( gl ), abs( gu ) )
           rtoli = reltol
           atoli = fudge*two*pivmin
           itmax = int( ( log( tnorm+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
           info = -1
           left = gl - fudge*tnorm*eps*n - fudge*two*pivmin
           right = gu + fudge*tnorm*eps*n + fudge*two*pivmin
           it = 0
           10 continue
           ! check if interval converged or maximum number of iterations reached
           tmp1 = abs( right - left )
           tmp2 = max( abs(right), abs(left) )
           if( tmp1<max( atoli, pivmin, rtoli*tmp2 ) ) then
              info = 0
              goto 30
           endif
           if(it>itmax)goto 30
           ! count number of negative pivots for mid-point
           it = it + 1
           mid = half * (left + right)
           negcnt = 0
           tmp1 = d( 1 ) - mid
           if( abs( tmp1 )<pivmin )tmp1 = -pivmin
           if( tmp1<=zero )negcnt = negcnt + 1
           do i = 2, n
              tmp1 = d( i ) - e2( i-1 ) / tmp1 - mid
              if( abs( tmp1 )<pivmin )tmp1 = -pivmin
              if( tmp1<=zero )negcnt = negcnt + 1
           end do
           if(negcnt>=iw) then
              right = mid
           else
              left = mid
           endif
           goto 10
           30 continue
           ! converged or maximum number of iterations reached
           w = half * (left + right)
           werr = half * abs( right - left )
           return
     end subroutine stdlib_${ri}$larrk

#:endif
#:endfor



     pure subroutine stdlib_slarrd( range, order, n, vl, vu, il, iu, gers,reltol, d, e, e2, &
     pivmin, nsplit, isplit,m, w, werr, wl, wu, iblock, indexw,work, iwork, info )
     !! SLARRD computes the eigenvalues of a symmetric tridiagonal
     !! matrix T to suitable accuracy. This is an auxiliary code to be
     !! called from SSTEMR.
     !! The user may ask for all eigenvalues, all eigenvalues
     !! in the half-open interval (VL, VU], or the IL-th through IU-th
     !! eigenvalues.
     !! To avoid overflow, the matrix must be scaled so that its
     !! largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
     !! accuracy, it should not be much smaller than that.
     !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
     !! Matrix", Report CS41, Computer Science Dept., Stanford
     !! University, July 21, 1966.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: order, range
           integer(ilp), intent(in) :: il, iu, n, nsplit
           integer(ilp), intent(out) :: info, m
           real(sp), intent(in) :: pivmin, reltol, vl, vu
           real(sp), intent(out) :: wl, wu
           ! Array Arguments 
           integer(ilp), intent(out) :: iblock(*), indexw(*), iwork(*)
           integer(ilp), intent(in) :: isplit(*)
           real(sp), intent(in) :: d(*), e(*), e2(*), gers(*)
           real(sp), intent(out) :: w(*), werr(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: fudge = two
           integer(ilp), parameter :: allrng = 1
           integer(ilp), parameter :: valrng = 2
           integer(ilp), parameter :: indrng = 3
           
           
           ! Local Scalars 
           logical(lk) :: ncnvrg, toofew
           integer(ilp) :: i, ib, ibegin, idiscl, idiscu, ie, iend, iinfo, im, in, ioff, iout, &
                     irange, itmax, itmp1, itmp2, iw, iwoff, j, jblk, jdisc, je, jee, nb, nwl, nwu
           real(sp) :: atoli, eps, gl, gu, rtoli, tmp1, tmp2, tnorm, uflow, wkill, wlu, &
                     wul
           ! Local Arrays 
           integer(ilp) :: idumma(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           ! decode range
           if( stdlib_lsame( range, 'A' ) ) then
              irange = allrng
           else if( stdlib_lsame( range, 'V' ) ) then
              irange = valrng
           else if( stdlib_lsame( range, 'I' ) ) then
              irange = indrng
           else
              irange = 0
           end if
           ! check for errors
           if( irange<=0 ) then
              info = -1
           else if( .not.(stdlib_lsame(order,'B').or.stdlib_lsame(order,'E')) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( irange==valrng ) then
              if( vl>=vu )info = -5
           else if( irange==indrng .and.( il<1 .or. il>max( 1, n ) ) ) then
              info = -6
           else if( irange==indrng .and.( iu<min( n, il ) .or. iu>n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              return
           end if
           ! initialize error flags
           info = 0
           ncnvrg = .false.
           toofew = .false.
           ! quick return if possible
           m = 0
           if( n==0 ) return
           ! simplification:
           if( irange==indrng .and. il==1 .and. iu==n ) irange = 1
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           uflow = stdlib_slamch( 'U' )
           ! special case when n=1
           ! treat case of 1x1 matrix for quick return
           if( n==1 ) then
              if( (irange==allrng).or.((irange==valrng).and.(d(1)>vl).and.(d(1)<=vu)).or.((&
                        irange==indrng).and.(il==1).and.(iu==1)) ) then
                 m = 1
                 w(1) = d(1)
                 ! the computation error of the eigenvalue is zero
                 werr(1) = zero
                 iblock( 1 ) = 1
                 indexw( 1 ) = 1
              endif
              return
           end if
           ! nb is the minimum vector length for vector bisection, or 0
           ! if only scalar is to be done.
           nb = stdlib_ilaenv( 1, 'SSTEBZ', ' ', n, -1, -1, -1 )
           if( nb<=1 ) nb = 0
           ! find global spectral radius
           gl = d(1)
           gu = d(1)
           do i = 1,n
              gl =  min( gl, gers( 2*i - 1))
              gu = max( gu, gers(2*i) )
           end do
           ! compute global gerschgorin bounds and spectral diameter
           tnorm = max( abs( gl ), abs( gu ) )
           gl = gl - fudge*tnorm*eps*n - fudge*two*pivmin
           gu = gu + fudge*tnorm*eps*n + fudge*two*pivmin
           ! [jan/28/2009] remove the line below since spdiam variable not use
           ! spdiam = gu - gl
           ! input arguments for stdlib_slaebz:
           ! the relative tolerance.  an interval (a,b] lies within
           ! "relative tolerance" if  b-a < reltol*max(|a|,|b|),
           rtoli = reltol
           ! set the absolute tolerance for interval convergence to zero to force
           ! interval convergence based on relative size of the interval.
           ! this is dangerous because intervals might not converge when reltol is
           ! small. but at least a very small number should be selected so that for
           ! strongly graded matrices, the code can get relatively accurate
           ! eigenvalues.
           atoli = fudge*two*uflow + fudge*two*pivmin
           if( irange==indrng ) then
              ! range='i': compute an interval containing eigenvalues
              ! il through iu. the initial interval [gl,gu] from the global
              ! gerschgorin bounds gl and gu is refined by stdlib_slaebz.
              itmax = int( ( log( tnorm+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
              work( n+1 ) = gl
              work( n+2 ) = gl
              work( n+3 ) = gu
              work( n+4 ) = gu
              work( n+5 ) = gl
              work( n+6 ) = gu
              iwork( 1 ) = -1
              iwork( 2 ) = -1
              iwork( 3 ) = n + 1
              iwork( 4 ) = n + 1
              iwork( 5 ) = il - 1
              iwork( 6 ) = iu
              call stdlib_slaebz( 3, itmax, n, 2, 2, nb, atoli, rtoli, pivmin,d, e, e2, iwork( 5 )&
                        , work( n+1 ), work( n+5 ), iout,iwork, w, iblock, iinfo )
              if( iinfo /= 0 ) then
                 info = iinfo
                 return
              end if
              ! on exit, output intervals may not be ordered by ascending negcount
              if( iwork( 6 )==iu ) then
                 wl = work( n+1 )
                 wlu = work( n+3 )
                 nwl = iwork( 1 )
                 wu = work( n+4 )
                 wul = work( n+2 )
                 nwu = iwork( 4 )
              else
                 wl = work( n+2 )
                 wlu = work( n+4 )
                 nwl = iwork( 2 )
                 wu = work( n+3 )
                 wul = work( n+1 )
                 nwu = iwork( 3 )
              end if
              ! on exit, the interval [wl, wlu] contains a value with negcount nwl,
              ! and [wul, wu] contains a value with negcount nwu.
              if( nwl<0 .or. nwl>=n .or. nwu<1 .or. nwu>n ) then
                 info = 4
                 return
              end if
           elseif( irange==valrng ) then
              wl = vl
              wu = vu
           elseif( irange==allrng ) then
              wl = gl
              wu = gu
           endif
           ! find eigenvalues -- loop over blocks and recompute nwl and nwu.
           ! nwl accumulates the number of eigenvalues .le. wl,
           ! nwu accumulates the number of eigenvalues .le. wu
           m = 0
           iend = 0
           info = 0
           nwl = 0
           nwu = 0
           loop_70: do jblk = 1, nsplit
              ioff = iend
              ibegin = ioff + 1
              iend = isplit( jblk )
              in = iend - ioff
              if( in==1 ) then
                 ! 1x1 block
                 if( wl>=d( ibegin )-pivmin )nwl = nwl + 1
                 if( wu>=d( ibegin )-pivmin )nwu = nwu + 1
                 if( irange==allrng .or.( wl<d( ibegin )-pivmin.and. wu>= d( ibegin )-pivmin ) ) &
                           then
                    m = m + 1
                    w( m ) = d( ibegin )
                    werr(m) = zero
                    ! the gap for a single block doesn't matter for the later
                    ! algorithm and is assigned an arbitrary large value
                    iblock( m ) = jblk
                    indexw( m ) = 1
                 end if
              ! disabled 2x2 case because of a failure on the following matrix
              ! range = 'i', il = iu = 4
                ! original tridiagonal, d = [
                 ! -0.150102010615740e+00_sp
                 ! -0.849897989384260e+00_sp
                 ! -0.128208148052635e-15_sp
                  ! 0.128257718286320e-15_sp
                ! ];
                ! e = [
                 ! -0.357171383266986e+00_sp
                 ! -0.180411241501588e-15_sp
                 ! -0.175152352710251e-15_sp
                ! ];
               ! else if( in==2 ) then
      ! *           2x2 block
                  ! disc = sqrt( (half*(d(ibegin)-d(iend)))**2 + e(ibegin)**2 )
                  ! tmp1 = half*(d(ibegin)+d(iend))
                  ! l1 = tmp1 - disc
                  ! if( wl>= l1-pivmin )
           ! $         nwl = nwl + 1
                  ! if( wu>= l1-pivmin )
           ! $         nwu = nwu + 1
                  ! if( irange==allrng .or. ( wl<l1-pivmin .and. wu>=
           ! $          l1-pivmin ) ) then
                     ! m = m + 1
                     ! w( m ) = l1
      ! *              the uncertainty of eigenvalues of a 2x2 matrix is very small
                     ! werr( m ) = eps * abs( w( m ) ) * two
                     ! iblock( m ) = jblk
                     ! indexw( m ) = 1
                  ! endif
                  ! l2 = tmp1 + disc
                  ! if( wl>= l2-pivmin )
           ! $         nwl = nwl + 1
                  ! if( wu>= l2-pivmin )
           ! $         nwu = nwu + 1
                  ! if( irange==allrng .or. ( wl<l2-pivmin .and. wu>=
           ! $          l2-pivmin ) ) then
                     ! m = m + 1
                     ! w( m ) = l2
      ! *              the uncertainty of eigenvalues of a 2x2 matrix is very small
                     ! werr( m ) = eps * abs( w( m ) ) * two
                     ! iblock( m ) = jblk
                     ! indexw( m ) = 2
                  ! endif
              else
                 ! general case - block of size in >= 2
                 ! compute local gerschgorin interval and use it as the initial
                 ! interval for stdlib_slaebz
                 gu = d( ibegin )
                 gl = d( ibegin )
                 tmp1 = zero
                 do j = ibegin, iend
                    gl =  min( gl, gers( 2*j - 1))
                    gu = max( gu, gers(2*j) )
                 end do
                 ! [jan/28/2009]
                 ! change spdiam by tnorm in lines 2 and 3 thereafter
                 ! line 1: remove computation of spdiam (not useful anymore)
                 ! spdiam = gu - gl
                 ! gl = gl - fudge*spdiam*eps*in - fudge*pivmin
                 ! gu = gu + fudge*spdiam*eps*in + fudge*pivmin
                 gl = gl - fudge*tnorm*eps*in - fudge*pivmin
                 gu = gu + fudge*tnorm*eps*in + fudge*pivmin
                 if( irange>1 ) then
                    if( gu<wl ) then
                       ! the local block contains none of the wanted eigenvalues
                       nwl = nwl + in
                       nwu = nwu + in
                       cycle loop_70
                    end if
                    ! refine search interval if possible, only range (wl,wu] matters
                    gl = max( gl, wl )
                    gu = min( gu, wu )
                    if( gl>=gu )cycle loop_70
                 end if
                 ! find negcount of initial interval boundaries gl and gu
                 work( n+1 ) = gl
                 work( n+in+1 ) = gu
                 call stdlib_slaebz( 1, 0, in, in, 1, nb, atoli, rtoli, pivmin,d( ibegin ), e( &
                 ibegin ), e2( ibegin ),idumma, work( n+1 ), work( n+2*in+1 ), im,iwork, w( m+1 ),&
                            iblock( m+1 ), iinfo )
                 if( iinfo /= 0 ) then
                    info = iinfo
                    return
                 end if
                 nwl = nwl + iwork( 1 )
                 nwu = nwu + iwork( in+1 )
                 iwoff = m - iwork( 1 )
                 ! compute eigenvalues
                 itmax = int( ( log( gu-gl+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + &
                           2
                 call stdlib_slaebz( 2, itmax, in, in, 1, nb, atoli, rtoli, pivmin,d( ibegin ), e(&
                  ibegin ), e2( ibegin ),idumma, work( n+1 ), work( n+2*in+1 ), iout,iwork, w( m+&
                            1 ), iblock( m+1 ), iinfo )
                 if( iinfo /= 0 ) then
                    info = iinfo
                    return
                 end if
                 ! copy eigenvalues into w and iblock
                 ! use -jblk for block number for unconverged eigenvalues.
                 ! loop over the number of output intervals from stdlib_slaebz
                 do j = 1, iout
                    ! eigenvalue approximation is middle point of interval
                    tmp1 = half*( work( j+n )+work( j+in+n ) )
                    ! semi length of error interval
                    tmp2 = half*abs( work( j+n )-work( j+in+n ) )
                    if( j>iout-iinfo ) then
                       ! flag non-convergence.
                       ncnvrg = .true.
                       ib = -jblk
                    else
                       ib = jblk
                    end if
                    do je = iwork( j ) + 1 + iwoff,iwork( j+in ) + iwoff
                       w( je ) = tmp1
                       werr( je ) = tmp2
                       indexw( je ) = je - iwoff
                       iblock( je ) = ib
                    end do
                 end do
                 m = m + im
              end if
           end do loop_70
           ! if range='i', then (wl,wu) contains eigenvalues nwl+1,...,nwu
           ! if nwl+1 < il or nwu > iu, discard extra eigenvalues.
           if( irange==indrng ) then
              idiscl = il - 1 - nwl
              idiscu = nwu - iu
              if( idiscl>0 ) then
                 im = 0
                 do je = 1, m
                    ! remove some of the smallest eigenvalues from the left so that
                    ! at the end idiscl =0. move all eigenvalues up to the left.
                    if( w( je )<=wlu .and. idiscl>0 ) then
                       idiscl = idiscl - 1
                    else
                       im = im + 1
                       w( im ) = w( je )
                       werr( im ) = werr( je )
                       indexw( im ) = indexw( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 m = im
              end if
              if( idiscu>0 ) then
                 ! remove some of the largest eigenvalues from the right so that
                 ! at the end idiscu =0. move all eigenvalues up to the left.
                 im=m+1
                 do je = m, 1, -1
                    if( w( je )>=wul .and. idiscu>0 ) then
                       idiscu = idiscu - 1
                    else
                       im = im - 1
                       w( im ) = w( je )
                       werr( im ) = werr( je )
                       indexw( im ) = indexw( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 jee = 0
                 do je = im, m
                    jee = jee + 1
                    w( jee ) = w( je )
                    werr( jee ) = werr( je )
                    indexw( jee ) = indexw( je )
                    iblock( jee ) = iblock( je )
                 end do
                 m = m-im+1
              end if
              if( idiscl>0 .or. idiscu>0 ) then
                 ! code to deal with effects of bad arithmetic. (if n(w) is
                 ! monotone non-decreasing, this should never happen.)
                 ! some low eigenvalues to be discarded are not in (wl,wlu],
                 ! or high eigenvalues to be discarded are not in (wul,wu]
                 ! so just kill off the smallest idiscl/largest idiscu
                 ! eigenvalues, by marking the corresponding iblock = 0
                 if( idiscl>0 ) then
                    wkill = wu
                    do jdisc = 1, idiscl
                       iw = 0
                       do je = 1, m
                          if( iblock( je )/=0 .and.( w( je )<wkill .or. iw==0 ) ) then
                             iw = je
                             wkill = w( je )
                          end if
                       end do
                       iblock( iw ) = 0
                    end do
                 end if
                 if( idiscu>0 ) then
                    wkill = wl
                    do jdisc = 1, idiscu
                       iw = 0
                       do je = 1, m
                          if( iblock( je )/=0 .and.( w( je )>=wkill .or. iw==0 ) ) then
                             iw = je
                             wkill = w( je )
                          end if
                       end do
                       iblock( iw ) = 0
                    end do
                 end if
                 ! now erase all eigenvalues with iblock set to zero
                 im = 0
                 do je = 1, m
                    if( iblock( je )/=0 ) then
                       im = im + 1
                       w( im ) = w( je )
                       werr( im ) = werr( je )
                       indexw( im ) = indexw( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 m = im
              end if
              if( idiscl<0 .or. idiscu<0 ) then
                 toofew = .true.
              end if
           end if
           if(( irange==allrng .and. m/=n ).or.( irange==indrng .and. m/=iu-il+1 ) ) then
              toofew = .true.
           end if
           ! if order='b', do nothing the eigenvalues are already sorted by
              ! block.
           ! if order='e', sort the eigenvalues from smallest to largest
           if( stdlib_lsame(order,'E') .and. nsplit>1 ) then
              do je = 1, m - 1
                 ie = 0
                 tmp1 = w( je )
                 do j = je + 1, m
                    if( w( j )<tmp1 ) then
                       ie = j
                       tmp1 = w( j )
                    end if
                 end do
                 if( ie/=0 ) then
                    tmp2 = werr( ie )
                    itmp1 = iblock( ie )
                    itmp2 = indexw( ie )
                    w( ie ) = w( je )
                    werr( ie ) = werr( je )
                    iblock( ie ) = iblock( je )
                    indexw( ie ) = indexw( je )
                    w( je ) = tmp1
                    werr( je ) = tmp2
                    iblock( je ) = itmp1
                    indexw( je ) = itmp2
                 end if
              end do
           end if
           info = 0
           if( ncnvrg )info = info + 1
           if( toofew )info = info + 2
           return
     end subroutine stdlib_slarrd

     pure subroutine stdlib_dlarrd( range, order, n, vl, vu, il, iu, gers,reltol, d, e, e2, &
     pivmin, nsplit, isplit,m, w, werr, wl, wu, iblock, indexw,work, iwork, info )
     !! DLARRD computes the eigenvalues of a symmetric tridiagonal
     !! matrix T to suitable accuracy. This is an auxiliary code to be
     !! called from DSTEMR.
     !! The user may ask for all eigenvalues, all eigenvalues
     !! in the half-open interval (VL, VU], or the IL-th through IU-th
     !! eigenvalues.
     !! To avoid overflow, the matrix must be scaled so that its
     !! largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
     !! accuracy, it should not be much smaller than that.
     !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
     !! Matrix", Report CS41, Computer Science Dept., Stanford
     !! University, July 21, 1966.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: order, range
           integer(ilp), intent(in) :: il, iu, n, nsplit
           integer(ilp), intent(out) :: info, m
           real(dp), intent(in) :: pivmin, reltol, vl, vu
           real(dp), intent(out) :: wl, wu
           ! Array Arguments 
           integer(ilp), intent(out) :: iblock(*), indexw(*), iwork(*)
           integer(ilp), intent(in) :: isplit(*)
           real(dp), intent(in) :: d(*), e(*), e2(*), gers(*)
           real(dp), intent(out) :: w(*), werr(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: fudge = two
           integer(ilp), parameter :: allrng = 1
           integer(ilp), parameter :: valrng = 2
           integer(ilp), parameter :: indrng = 3
           
           
           ! Local Scalars 
           logical(lk) :: ncnvrg, toofew
           integer(ilp) :: i, ib, ibegin, idiscl, idiscu, ie, iend, iinfo, im, in, ioff, iout, &
                     irange, itmax, itmp1, itmp2, iw, iwoff, j, jblk, jdisc, je, jee, nb, nwl, nwu
           real(dp) :: atoli, eps, gl, gu, rtoli, tmp1, tmp2, tnorm, uflow, wkill, wlu, &
                     wul
           ! Local Arrays 
           integer(ilp) :: idumma(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           ! decode range
           if( stdlib_lsame( range, 'A' ) ) then
              irange = allrng
           else if( stdlib_lsame( range, 'V' ) ) then
              irange = valrng
           else if( stdlib_lsame( range, 'I' ) ) then
              irange = indrng
           else
              irange = 0
           end if
           ! check for errors
           if( irange<=0 ) then
              info = -1
           else if( .not.(stdlib_lsame(order,'B').or.stdlib_lsame(order,'E')) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( irange==valrng ) then
              if( vl>=vu )info = -5
           else if( irange==indrng .and.( il<1 .or. il>max( 1, n ) ) ) then
              info = -6
           else if( irange==indrng .and.( iu<min( n, il ) .or. iu>n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              return
           end if
           ! initialize error flags
           info = 0
           ncnvrg = .false.
           toofew = .false.
           ! quick return if possible
           m = 0
           if( n==0 ) return
           ! simplification:
           if( irange==indrng .and. il==1 .and. iu==n ) irange = 1
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           uflow = stdlib_dlamch( 'U' )
           ! special case when n=1
           ! treat case of 1x1 matrix for quick return
           if( n==1 ) then
              if( (irange==allrng).or.((irange==valrng).and.(d(1)>vl).and.(d(1)<=vu)).or.((&
                        irange==indrng).and.(il==1).and.(iu==1)) ) then
                 m = 1
                 w(1) = d(1)
                 ! the computation error of the eigenvalue is zero
                 werr(1) = zero
                 iblock( 1 ) = 1
                 indexw( 1 ) = 1
              endif
              return
           end if
           ! nb is the minimum vector length for vector bisection, or 0
           ! if only scalar is to be done.
           nb = stdlib_ilaenv( 1, 'DSTEBZ', ' ', n, -1, -1, -1 )
           if( nb<=1 ) nb = 0
           ! find global spectral radius
           gl = d(1)
           gu = d(1)
           do i = 1,n
              gl =  min( gl, gers( 2*i - 1))
              gu = max( gu, gers(2*i) )
           end do
           ! compute global gerschgorin bounds and spectral diameter
           tnorm = max( abs( gl ), abs( gu ) )
           gl = gl - fudge*tnorm*eps*n - fudge*two*pivmin
           gu = gu + fudge*tnorm*eps*n + fudge*two*pivmin
           ! [jan/28/2009] remove the line below since spdiam variable not use
           ! spdiam = gu - gl
           ! input arguments for stdlib_dlaebz:
           ! the relative tolerance.  an interval (a,b] lies within
           ! "relative tolerance" if  b-a < reltol*max(|a|,|b|),
           rtoli = reltol
           ! set the absolute tolerance for interval convergence to zero to force
           ! interval convergence based on relative size of the interval.
           ! this is dangerous because intervals might not converge when reltol is
           ! small. but at least a very small number should be selected so that for
           ! strongly graded matrices, the code can get relatively accurate
           ! eigenvalues.
           atoli = fudge*two*uflow + fudge*two*pivmin
           if( irange==indrng ) then
              ! range='i': compute an interval containing eigenvalues
              ! il through iu. the initial interval [gl,gu] from the global
              ! gerschgorin bounds gl and gu is refined by stdlib_dlaebz.
              itmax = int( ( log( tnorm+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
              work( n+1 ) = gl
              work( n+2 ) = gl
              work( n+3 ) = gu
              work( n+4 ) = gu
              work( n+5 ) = gl
              work( n+6 ) = gu
              iwork( 1 ) = -1
              iwork( 2 ) = -1
              iwork( 3 ) = n + 1
              iwork( 4 ) = n + 1
              iwork( 5 ) = il - 1
              iwork( 6 ) = iu
              call stdlib_dlaebz( 3, itmax, n, 2, 2, nb, atoli, rtoli, pivmin,d, e, e2, iwork( 5 )&
                        , work( n+1 ), work( n+5 ), iout,iwork, w, iblock, iinfo )
              if( iinfo /= 0 ) then
                 info = iinfo
                 return
              end if
              ! on exit, output intervals may not be ordered by ascending negcount
              if( iwork( 6 )==iu ) then
                 wl = work( n+1 )
                 wlu = work( n+3 )
                 nwl = iwork( 1 )
                 wu = work( n+4 )
                 wul = work( n+2 )
                 nwu = iwork( 4 )
              else
                 wl = work( n+2 )
                 wlu = work( n+4 )
                 nwl = iwork( 2 )
                 wu = work( n+3 )
                 wul = work( n+1 )
                 nwu = iwork( 3 )
              end if
              ! on exit, the interval [wl, wlu] contains a value with negcount nwl,
              ! and [wul, wu] contains a value with negcount nwu.
              if( nwl<0 .or. nwl>=n .or. nwu<1 .or. nwu>n ) then
                 info = 4
                 return
              end if
           elseif( irange==valrng ) then
              wl = vl
              wu = vu
           elseif( irange==allrng ) then
              wl = gl
              wu = gu
           endif
           ! find eigenvalues -- loop over blocks and recompute nwl and nwu.
           ! nwl accumulates the number of eigenvalues .le. wl,
           ! nwu accumulates the number of eigenvalues .le. wu
           m = 0
           iend = 0
           info = 0
           nwl = 0
           nwu = 0
           loop_70: do jblk = 1, nsplit
              ioff = iend
              ibegin = ioff + 1
              iend = isplit( jblk )
              in = iend - ioff
              if( in==1 ) then
                 ! 1x1 block
                 if( wl>=d( ibegin )-pivmin )nwl = nwl + 1
                 if( wu>=d( ibegin )-pivmin )nwu = nwu + 1
                 if( irange==allrng .or.( wl<d( ibegin )-pivmin.and. wu>= d( ibegin )-pivmin ) ) &
                           then
                    m = m + 1
                    w( m ) = d( ibegin )
                    werr(m) = zero
                    ! the gap for a single block doesn't matter for the later
                    ! algorithm and is assigned an arbitrary large value
                    iblock( m ) = jblk
                    indexw( m ) = 1
                 end if
              ! disabled 2x2 case because of a failure on the following matrix
              ! range = 'i', il = iu = 4
                ! original tridiagonal, d = [
                 ! -0.150102010615740e+00_dp
                 ! -0.849897989384260e+00_dp
                 ! -0.128208148052635e-15_dp
                  ! 0.128257718286320e-15_dp
                ! ];
                ! e = [
                 ! -0.357171383266986e+00_dp
                 ! -0.180411241501588e-15_dp
                 ! -0.175152352710251e-15_dp
                ! ];
               ! else if( in==2 ) then
      ! *           2x2 block
                  ! disc = sqrt( (half*(d(ibegin)-d(iend)))**2 + e(ibegin)**2 )
                  ! tmp1 = half*(d(ibegin)+d(iend))
                  ! l1 = tmp1 - disc
                  ! if( wl>= l1-pivmin )
           ! $         nwl = nwl + 1
                  ! if( wu>= l1-pivmin )
           ! $         nwu = nwu + 1
                  ! if( irange==allrng .or. ( wl<l1-pivmin .and. wu>=
           ! $          l1-pivmin ) ) then
                     ! m = m + 1
                     ! w( m ) = l1
      ! *              the uncertainty of eigenvalues of a 2x2 matrix is very small
                     ! werr( m ) = eps * abs( w( m ) ) * two
                     ! iblock( m ) = jblk
                     ! indexw( m ) = 1
                  ! endif
                  ! l2 = tmp1 + disc
                  ! if( wl>= l2-pivmin )
           ! $         nwl = nwl + 1
                  ! if( wu>= l2-pivmin )
           ! $         nwu = nwu + 1
                  ! if( irange==allrng .or. ( wl<l2-pivmin .and. wu>=
           ! $          l2-pivmin ) ) then
                     ! m = m + 1
                     ! w( m ) = l2
      ! *              the uncertainty of eigenvalues of a 2x2 matrix is very small
                     ! werr( m ) = eps * abs( w( m ) ) * two
                     ! iblock( m ) = jblk
                     ! indexw( m ) = 2
                  ! endif
              else
                 ! general case - block of size in >= 2
                 ! compute local gerschgorin interval and use it as the initial
                 ! interval for stdlib_dlaebz
                 gu = d( ibegin )
                 gl = d( ibegin )
                 tmp1 = zero
                 do j = ibegin, iend
                    gl =  min( gl, gers( 2*j - 1))
                    gu = max( gu, gers(2*j) )
                 end do
                 ! [jan/28/2009]
                 ! change spdiam by tnorm in lines 2 and 3 thereafter
                 ! line 1: remove computation of spdiam (not useful anymore)
                 ! spdiam = gu - gl
                 ! gl = gl - fudge*spdiam*eps*in - fudge*pivmin
                 ! gu = gu + fudge*spdiam*eps*in + fudge*pivmin
                 gl = gl - fudge*tnorm*eps*in - fudge*pivmin
                 gu = gu + fudge*tnorm*eps*in + fudge*pivmin
                 if( irange>1 ) then
                    if( gu<wl ) then
                       ! the local block contains none of the wanted eigenvalues
                       nwl = nwl + in
                       nwu = nwu + in
                       cycle loop_70
                    end if
                    ! refine search interval if possible, only range (wl,wu] matters
                    gl = max( gl, wl )
                    gu = min( gu, wu )
                    if( gl>=gu )cycle loop_70
                 end if
                 ! find negcount of initial interval boundaries gl and gu
                 work( n+1 ) = gl
                 work( n+in+1 ) = gu
                 call stdlib_dlaebz( 1, 0, in, in, 1, nb, atoli, rtoli, pivmin,d( ibegin ), e( &
                 ibegin ), e2( ibegin ),idumma, work( n+1 ), work( n+2*in+1 ), im,iwork, w( m+1 ),&
                            iblock( m+1 ), iinfo )
                 if( iinfo /= 0 ) then
                    info = iinfo
                    return
                 end if
                 nwl = nwl + iwork( 1 )
                 nwu = nwu + iwork( in+1 )
                 iwoff = m - iwork( 1 )
                 ! compute eigenvalues
                 itmax = int( ( log( gu-gl+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + &
                           2
                 call stdlib_dlaebz( 2, itmax, in, in, 1, nb, atoli, rtoli, pivmin,d( ibegin ), e(&
                  ibegin ), e2( ibegin ),idumma, work( n+1 ), work( n+2*in+1 ), iout,iwork, w( m+&
                            1 ), iblock( m+1 ), iinfo )
                 if( iinfo /= 0 ) then
                    info = iinfo
                    return
                 end if
                 ! copy eigenvalues into w and iblock
                 ! use -jblk for block number for unconverged eigenvalues.
                 ! loop over the number of output intervals from stdlib_dlaebz
                 do j = 1, iout
                    ! eigenvalue approximation is middle point of interval
                    tmp1 = half*( work( j+n )+work( j+in+n ) )
                    ! semi length of error interval
                    tmp2 = half*abs( work( j+n )-work( j+in+n ) )
                    if( j>iout-iinfo ) then
                       ! flag non-convergence.
                       ncnvrg = .true.
                       ib = -jblk
                    else
                       ib = jblk
                    end if
                    do je = iwork( j ) + 1 + iwoff,iwork( j+in ) + iwoff
                       w( je ) = tmp1
                       werr( je ) = tmp2
                       indexw( je ) = je - iwoff
                       iblock( je ) = ib
                    end do
                 end do
                 m = m + im
              end if
           end do loop_70
           ! if range='i', then (wl,wu) contains eigenvalues nwl+1,...,nwu
           ! if nwl+1 < il or nwu > iu, discard extra eigenvalues.
           if( irange==indrng ) then
              idiscl = il - 1 - nwl
              idiscu = nwu - iu
              if( idiscl>0 ) then
                 im = 0
                 do je = 1, m
                    ! remove some of the smallest eigenvalues from the left so that
                    ! at the end idiscl =0. move all eigenvalues up to the left.
                    if( w( je )<=wlu .and. idiscl>0 ) then
                       idiscl = idiscl - 1
                    else
                       im = im + 1
                       w( im ) = w( je )
                       werr( im ) = werr( je )
                       indexw( im ) = indexw( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 m = im
              end if
              if( idiscu>0 ) then
                 ! remove some of the largest eigenvalues from the right so that
                 ! at the end idiscu =0. move all eigenvalues up to the left.
                 im=m+1
                 do je = m, 1, -1
                    if( w( je )>=wul .and. idiscu>0 ) then
                       idiscu = idiscu - 1
                    else
                       im = im - 1
                       w( im ) = w( je )
                       werr( im ) = werr( je )
                       indexw( im ) = indexw( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 jee = 0
                 do je = im, m
                    jee = jee + 1
                    w( jee ) = w( je )
                    werr( jee ) = werr( je )
                    indexw( jee ) = indexw( je )
                    iblock( jee ) = iblock( je )
                 end do
                 m = m-im+1
              end if
              if( idiscl>0 .or. idiscu>0 ) then
                 ! code to deal with effects of bad arithmetic. (if n(w) is
                 ! monotone non-decreasing, this should never happen.)
                 ! some low eigenvalues to be discarded are not in (wl,wlu],
                 ! or high eigenvalues to be discarded are not in (wul,wu]
                 ! so just kill off the smallest idiscl/largest idiscu
                 ! eigenvalues, by marking the corresponding iblock = 0
                 if( idiscl>0 ) then
                    wkill = wu
                    do jdisc = 1, idiscl
                       iw = 0
                       do je = 1, m
                          if( iblock( je )/=0 .and.( w( je )<wkill .or. iw==0 ) ) then
                             iw = je
                             wkill = w( je )
                          end if
                       end do
                       iblock( iw ) = 0
                    end do
                 end if
                 if( idiscu>0 ) then
                    wkill = wl
                    do jdisc = 1, idiscu
                       iw = 0
                       do je = 1, m
                          if( iblock( je )/=0 .and.( w( je )>=wkill .or. iw==0 ) ) then
                             iw = je
                             wkill = w( je )
                          end if
                       end do
                       iblock( iw ) = 0
                    end do
                 end if
                 ! now erase all eigenvalues with iblock set to zero
                 im = 0
                 do je = 1, m
                    if( iblock( je )/=0 ) then
                       im = im + 1
                       w( im ) = w( je )
                       werr( im ) = werr( je )
                       indexw( im ) = indexw( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 m = im
              end if
              if( idiscl<0 .or. idiscu<0 ) then
                 toofew = .true.
              end if
           end if
           if(( irange==allrng .and. m/=n ).or.( irange==indrng .and. m/=iu-il+1 ) ) then
              toofew = .true.
           end if
           ! if order='b', do nothing the eigenvalues are already sorted by
              ! block.
           ! if order='e', sort the eigenvalues from smallest to largest
           if( stdlib_lsame(order,'E') .and. nsplit>1 ) then
              do je = 1, m - 1
                 ie = 0
                 tmp1 = w( je )
                 do j = je + 1, m
                    if( w( j )<tmp1 ) then
                       ie = j
                       tmp1 = w( j )
                    end if
                 end do
                 if( ie/=0 ) then
                    tmp2 = werr( ie )
                    itmp1 = iblock( ie )
                    itmp2 = indexw( ie )
                    w( ie ) = w( je )
                    werr( ie ) = werr( je )
                    iblock( ie ) = iblock( je )
                    indexw( ie ) = indexw( je )
                    w( je ) = tmp1
                    werr( je ) = tmp2
                    iblock( je ) = itmp1
                    indexw( je ) = itmp2
                 end if
              end do
           end if
           info = 0
           if( ncnvrg )info = info + 1
           if( toofew )info = info + 2
           return
     end subroutine stdlib_dlarrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$larrd( range, order, n, vl, vu, il, iu, gers,reltol, d, e, e2, &
     pivmin, nsplit, isplit,m, w, werr, wl, wu, iblock, indexw,work, iwork, info )
     !! DLARRD: computes the eigenvalues of a symmetric tridiagonal
     !! matrix T to suitable accuracy. This is an auxiliary code to be
     !! called from DSTEMR.
     !! The user may ask for all eigenvalues, all eigenvalues
     !! in the half-open interval (VL, VU], or the IL-th through IU-th
     !! eigenvalues.
     !! To avoid overflow, the matrix must be scaled so that its
     !! largest element is no greater than overflow**(1/2) * underflow**(1/4) in absolute value, and for greatest
     !! accuracy, it should not be much smaller than that.
     !! See W. Kahan "Accurate Eigenvalues of a Symmetric Tridiagonal
     !! Matrix", Report CS41, Computer Science Dept., Stanford
     !! University, July 21, 1966.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: order, range
           integer(ilp), intent(in) :: il, iu, n, nsplit
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(in) :: pivmin, reltol, vl, vu
           real(${rk}$), intent(out) :: wl, wu
           ! Array Arguments 
           integer(ilp), intent(out) :: iblock(*), indexw(*), iwork(*)
           integer(ilp), intent(in) :: isplit(*)
           real(${rk}$), intent(in) :: d(*), e(*), e2(*), gers(*)
           real(${rk}$), intent(out) :: w(*), werr(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: fudge = two
           integer(ilp), parameter :: allrng = 1
           integer(ilp), parameter :: valrng = 2
           integer(ilp), parameter :: indrng = 3
           
           
           ! Local Scalars 
           logical(lk) :: ncnvrg, toofew
           integer(ilp) :: i, ib, ibegin, idiscl, idiscu, ie, iend, iinfo, im, in, ioff, iout, &
                     irange, itmax, itmp1, itmp2, iw, iwoff, j, jblk, jdisc, je, jee, nb, nwl, nwu
           real(${rk}$) :: atoli, eps, gl, gu, rtoli, tmp1, tmp2, tnorm, uflow, wkill, wlu, &
                     wul
           ! Local Arrays 
           integer(ilp) :: idumma(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=0 ) then
              return
           end if
           ! decode range
           if( stdlib_lsame( range, 'A' ) ) then
              irange = allrng
           else if( stdlib_lsame( range, 'V' ) ) then
              irange = valrng
           else if( stdlib_lsame( range, 'I' ) ) then
              irange = indrng
           else
              irange = 0
           end if
           ! check for errors
           if( irange<=0 ) then
              info = -1
           else if( .not.(stdlib_lsame(order,'B').or.stdlib_lsame(order,'E')) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( irange==valrng ) then
              if( vl>=vu )info = -5
           else if( irange==indrng .and.( il<1 .or. il>max( 1, n ) ) ) then
              info = -6
           else if( irange==indrng .and.( iu<min( n, il ) .or. iu>n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              return
           end if
           ! initialize error flags
           info = 0
           ncnvrg = .false.
           toofew = .false.
           ! quick return if possible
           m = 0
           if( n==0 ) return
           ! simplification:
           if( irange==indrng .and. il==1 .and. iu==n ) irange = 1
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           uflow = stdlib_${ri}$lamch( 'U' )
           ! special case when n=1
           ! treat case of 1x1 matrix for quick return
           if( n==1 ) then
              if( (irange==allrng).or.((irange==valrng).and.(d(1)>vl).and.(d(1)<=vu)).or.((&
                        irange==indrng).and.(il==1).and.(iu==1)) ) then
                 m = 1
                 w(1) = d(1)
                 ! the computation error of the eigenvalue is zero
                 werr(1) = zero
                 iblock( 1 ) = 1
                 indexw( 1 ) = 1
              endif
              return
           end if
           ! nb is the minimum vector length for vector bisection, or 0
           ! if only scalar is to be done.
           nb = stdlib_ilaenv( 1, 'DSTEBZ', ' ', n, -1, -1, -1 )
           if( nb<=1 ) nb = 0
           ! find global spectral radius
           gl = d(1)
           gu = d(1)
           do i = 1,n
              gl =  min( gl, gers( 2*i - 1))
              gu = max( gu, gers(2*i) )
           end do
           ! compute global gerschgorin bounds and spectral diameter
           tnorm = max( abs( gl ), abs( gu ) )
           gl = gl - fudge*tnorm*eps*n - fudge*two*pivmin
           gu = gu + fudge*tnorm*eps*n + fudge*two*pivmin
           ! [jan/28/2009] remove the line below since spdiam variable not use
           ! spdiam = gu - gl
           ! input arguments for stdlib_${ri}$laebz:
           ! the relative tolerance.  an interval (a,b] lies within
           ! "relative tolerance" if  b-a < reltol*max(|a|,|b|),
           rtoli = reltol
           ! set the absolute tolerance for interval convergence to zero to force
           ! interval convergence based on relative size of the interval.
           ! this is dangerous because intervals might not converge when reltol is
           ! small. but at least a very small number should be selected so that for
           ! strongly graded matrices, the code can get relatively accurate
           ! eigenvalues.
           atoli = fudge*two*uflow + fudge*two*pivmin
           if( irange==indrng ) then
              ! range='i': compute an interval containing eigenvalues
              ! il through iu. the initial interval [gl,gu] from the global
              ! gerschgorin bounds gl and gu is refined by stdlib_${ri}$laebz.
              itmax = int( ( log( tnorm+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + 2
              work( n+1 ) = gl
              work( n+2 ) = gl
              work( n+3 ) = gu
              work( n+4 ) = gu
              work( n+5 ) = gl
              work( n+6 ) = gu
              iwork( 1 ) = -1
              iwork( 2 ) = -1
              iwork( 3 ) = n + 1
              iwork( 4 ) = n + 1
              iwork( 5 ) = il - 1
              iwork( 6 ) = iu
              call stdlib_${ri}$laebz( 3, itmax, n, 2, 2, nb, atoli, rtoli, pivmin,d, e, e2, iwork( 5 )&
                        , work( n+1 ), work( n+5 ), iout,iwork, w, iblock, iinfo )
              if( iinfo /= 0 ) then
                 info = iinfo
                 return
              end if
              ! on exit, output intervals may not be ordered by ascending negcount
              if( iwork( 6 )==iu ) then
                 wl = work( n+1 )
                 wlu = work( n+3 )
                 nwl = iwork( 1 )
                 wu = work( n+4 )
                 wul = work( n+2 )
                 nwu = iwork( 4 )
              else
                 wl = work( n+2 )
                 wlu = work( n+4 )
                 nwl = iwork( 2 )
                 wu = work( n+3 )
                 wul = work( n+1 )
                 nwu = iwork( 3 )
              end if
              ! on exit, the interval [wl, wlu] contains a value with negcount nwl,
              ! and [wul, wu] contains a value with negcount nwu.
              if( nwl<0 .or. nwl>=n .or. nwu<1 .or. nwu>n ) then
                 info = 4
                 return
              end if
           elseif( irange==valrng ) then
              wl = vl
              wu = vu
           elseif( irange==allrng ) then
              wl = gl
              wu = gu
           endif
           ! find eigenvalues -- loop over blocks and recompute nwl and nwu.
           ! nwl accumulates the number of eigenvalues .le. wl,
           ! nwu accumulates the number of eigenvalues .le. wu
           m = 0
           iend = 0
           info = 0
           nwl = 0
           nwu = 0
           loop_70: do jblk = 1, nsplit
              ioff = iend
              ibegin = ioff + 1
              iend = isplit( jblk )
              in = iend - ioff
              if( in==1 ) then
                 ! 1x1 block
                 if( wl>=d( ibegin )-pivmin )nwl = nwl + 1
                 if( wu>=d( ibegin )-pivmin )nwu = nwu + 1
                 if( irange==allrng .or.( wl<d( ibegin )-pivmin.and. wu>= d( ibegin )-pivmin ) ) &
                           then
                    m = m + 1
                    w( m ) = d( ibegin )
                    werr(m) = zero
                    ! the gap for a single block doesn't matter for the later
                    ! algorithm and is assigned an arbitrary large value
                    iblock( m ) = jblk
                    indexw( m ) = 1
                 end if
              ! disabled 2x2 case because of a failure on the following matrix
              ! range = 'i', il = iu = 4
                ! original tridiagonal, d = [
                 ! -0.150102010615740e+00_${rk}$
                 ! -0.849897989384260e+00_${rk}$
                 ! -0.128208148052635e-15_${rk}$
                  ! 0.128257718286320e-15_${rk}$
                ! ];
                ! e = [
                 ! -0.357171383266986e+00_${rk}$
                 ! -0.180411241501588e-15_${rk}$
                 ! -0.175152352710251e-15_${rk}$
                ! ];
               ! else if( in==2 ) then
      ! *           2x2 block
                  ! disc = sqrt( (half*(d(ibegin)-d(iend)))**2 + e(ibegin)**2 )
                  ! tmp1 = half*(d(ibegin)+d(iend))
                  ! l1 = tmp1 - disc
                  ! if( wl>= l1-pivmin )
           ! $         nwl = nwl + 1
                  ! if( wu>= l1-pivmin )
           ! $         nwu = nwu + 1
                  ! if( irange==allrng .or. ( wl<l1-pivmin .and. wu>=
           ! $          l1-pivmin ) ) then
                     ! m = m + 1
                     ! w( m ) = l1
      ! *              the uncertainty of eigenvalues of a 2x2 matrix is very small
                     ! werr( m ) = eps * abs( w( m ) ) * two
                     ! iblock( m ) = jblk
                     ! indexw( m ) = 1
                  ! endif
                  ! l2 = tmp1 + disc
                  ! if( wl>= l2-pivmin )
           ! $         nwl = nwl + 1
                  ! if( wu>= l2-pivmin )
           ! $         nwu = nwu + 1
                  ! if( irange==allrng .or. ( wl<l2-pivmin .and. wu>=
           ! $          l2-pivmin ) ) then
                     ! m = m + 1
                     ! w( m ) = l2
      ! *              the uncertainty of eigenvalues of a 2x2 matrix is very small
                     ! werr( m ) = eps * abs( w( m ) ) * two
                     ! iblock( m ) = jblk
                     ! indexw( m ) = 2
                  ! endif
              else
                 ! general case - block of size in >= 2
                 ! compute local gerschgorin interval and use it as the initial
                 ! interval for stdlib_${ri}$laebz
                 gu = d( ibegin )
                 gl = d( ibegin )
                 tmp1 = zero
                 do j = ibegin, iend
                    gl =  min( gl, gers( 2*j - 1))
                    gu = max( gu, gers(2*j) )
                 end do
                 ! [jan/28/2009]
                 ! change spdiam by tnorm in lines 2 and 3 thereafter
                 ! line 1: remove computation of spdiam (not useful anymore)
                 ! spdiam = gu - gl
                 ! gl = gl - fudge*spdiam*eps*in - fudge*pivmin
                 ! gu = gu + fudge*spdiam*eps*in + fudge*pivmin
                 gl = gl - fudge*tnorm*eps*in - fudge*pivmin
                 gu = gu + fudge*tnorm*eps*in + fudge*pivmin
                 if( irange>1 ) then
                    if( gu<wl ) then
                       ! the local block contains none of the wanted eigenvalues
                       nwl = nwl + in
                       nwu = nwu + in
                       cycle loop_70
                    end if
                    ! refine search interval if possible, only range (wl,wu] matters
                    gl = max( gl, wl )
                    gu = min( gu, wu )
                    if( gl>=gu )cycle loop_70
                 end if
                 ! find negcount of initial interval boundaries gl and gu
                 work( n+1 ) = gl
                 work( n+in+1 ) = gu
                 call stdlib_${ri}$laebz( 1, 0, in, in, 1, nb, atoli, rtoli, pivmin,d( ibegin ), e( &
                 ibegin ), e2( ibegin ),idumma, work( n+1 ), work( n+2*in+1 ), im,iwork, w( m+1 ),&
                            iblock( m+1 ), iinfo )
                 if( iinfo /= 0 ) then
                    info = iinfo
                    return
                 end if
                 nwl = nwl + iwork( 1 )
                 nwu = nwu + iwork( in+1 )
                 iwoff = m - iwork( 1 )
                 ! compute eigenvalues
                 itmax = int( ( log( gu-gl+pivmin )-log( pivmin ) ) /log( two ),KIND=ilp) + &
                           2
                 call stdlib_${ri}$laebz( 2, itmax, in, in, 1, nb, atoli, rtoli, pivmin,d( ibegin ), e(&
                  ibegin ), e2( ibegin ),idumma, work( n+1 ), work( n+2*in+1 ), iout,iwork, w( m+&
                            1 ), iblock( m+1 ), iinfo )
                 if( iinfo /= 0 ) then
                    info = iinfo
                    return
                 end if
                 ! copy eigenvalues into w and iblock
                 ! use -jblk for block number for unconverged eigenvalues.
                 ! loop over the number of output intervals from stdlib_${ri}$laebz
                 do j = 1, iout
                    ! eigenvalue approximation is middle point of interval
                    tmp1 = half*( work( j+n )+work( j+in+n ) )
                    ! semi length of error interval
                    tmp2 = half*abs( work( j+n )-work( j+in+n ) )
                    if( j>iout-iinfo ) then
                       ! flag non-convergence.
                       ncnvrg = .true.
                       ib = -jblk
                    else
                       ib = jblk
                    end if
                    do je = iwork( j ) + 1 + iwoff,iwork( j+in ) + iwoff
                       w( je ) = tmp1
                       werr( je ) = tmp2
                       indexw( je ) = je - iwoff
                       iblock( je ) = ib
                    end do
                 end do
                 m = m + im
              end if
           end do loop_70
           ! if range='i', then (wl,wu) contains eigenvalues nwl+1,...,nwu
           ! if nwl+1 < il or nwu > iu, discard extra eigenvalues.
           if( irange==indrng ) then
              idiscl = il - 1 - nwl
              idiscu = nwu - iu
              if( idiscl>0 ) then
                 im = 0
                 do je = 1, m
                    ! remove some of the smallest eigenvalues from the left so that
                    ! at the end idiscl =0. move all eigenvalues up to the left.
                    if( w( je )<=wlu .and. idiscl>0 ) then
                       idiscl = idiscl - 1
                    else
                       im = im + 1
                       w( im ) = w( je )
                       werr( im ) = werr( je )
                       indexw( im ) = indexw( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 m = im
              end if
              if( idiscu>0 ) then
                 ! remove some of the largest eigenvalues from the right so that
                 ! at the end idiscu =0. move all eigenvalues up to the left.
                 im=m+1
                 do je = m, 1, -1
                    if( w( je )>=wul .and. idiscu>0 ) then
                       idiscu = idiscu - 1
                    else
                       im = im - 1
                       w( im ) = w( je )
                       werr( im ) = werr( je )
                       indexw( im ) = indexw( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 jee = 0
                 do je = im, m
                    jee = jee + 1
                    w( jee ) = w( je )
                    werr( jee ) = werr( je )
                    indexw( jee ) = indexw( je )
                    iblock( jee ) = iblock( je )
                 end do
                 m = m-im+1
              end if
              if( idiscl>0 .or. idiscu>0 ) then
                 ! code to deal with effects of bad arithmetic. (if n(w) is
                 ! monotone non-decreasing, this should never happen.)
                 ! some low eigenvalues to be discarded are not in (wl,wlu],
                 ! or high eigenvalues to be discarded are not in (wul,wu]
                 ! so just kill off the smallest idiscl/largest idiscu
                 ! eigenvalues, by marking the corresponding iblock = 0
                 if( idiscl>0 ) then
                    wkill = wu
                    do jdisc = 1, idiscl
                       iw = 0
                       do je = 1, m
                          if( iblock( je )/=0 .and.( w( je )<wkill .or. iw==0 ) ) then
                             iw = je
                             wkill = w( je )
                          end if
                       end do
                       iblock( iw ) = 0
                    end do
                 end if
                 if( idiscu>0 ) then
                    wkill = wl
                    do jdisc = 1, idiscu
                       iw = 0
                       do je = 1, m
                          if( iblock( je )/=0 .and.( w( je )>=wkill .or. iw==0 ) ) then
                             iw = je
                             wkill = w( je )
                          end if
                       end do
                       iblock( iw ) = 0
                    end do
                 end if
                 ! now erase all eigenvalues with iblock set to zero
                 im = 0
                 do je = 1, m
                    if( iblock( je )/=0 ) then
                       im = im + 1
                       w( im ) = w( je )
                       werr( im ) = werr( je )
                       indexw( im ) = indexw( je )
                       iblock( im ) = iblock( je )
                    end if
                 end do
                 m = im
              end if
              if( idiscl<0 .or. idiscu<0 ) then
                 toofew = .true.
              end if
           end if
           if(( irange==allrng .and. m/=n ).or.( irange==indrng .and. m/=iu-il+1 ) ) then
              toofew = .true.
           end if
           ! if order='b', do nothing the eigenvalues are already sorted by
              ! block.
           ! if order='e', sort the eigenvalues from smallest to largest
           if( stdlib_lsame(order,'E') .and. nsplit>1 ) then
              do je = 1, m - 1
                 ie = 0
                 tmp1 = w( je )
                 do j = je + 1, m
                    if( w( j )<tmp1 ) then
                       ie = j
                       tmp1 = w( j )
                    end if
                 end do
                 if( ie/=0 ) then
                    tmp2 = werr( ie )
                    itmp1 = iblock( ie )
                    itmp2 = indexw( ie )
                    w( ie ) = w( je )
                    werr( ie ) = werr( je )
                    iblock( ie ) = iblock( je )
                    indexw( ie ) = indexw( je )
                    w( je ) = tmp1
                    werr( je ) = tmp2
                    iblock( je ) = itmp1
                    indexw( je ) = itmp2
                 end if
              end do
           end if
           info = 0
           if( ncnvrg )info = info + 1
           if( toofew )info = info + 2
           return
     end subroutine stdlib_${ri}$larrd

#:endif
#:endfor



     pure subroutine stdlib_cupmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )
     !! CUPMTR overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! nq-1 elementary reflectors, as returned by CHPTRD using packed
     !! storage:
     !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, m, n
           ! Array Arguments 
           complex(sp), intent(inout) :: ap(*), c(ldc,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: forwrd, left, notran, upper
           integer(ilp) :: i, i1, i2, i3, ic, ii, jc, mi, ni, nq
           complex(sp) :: aii, taui
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           upper = stdlib_lsame( uplo, 'U' )
           ! nq is the order of q
           if( left ) then
              nq = m
           else
              nq = n
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( ldc<max( 1, m ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUPMTR', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           if( upper ) then
              ! q was determined by a call to stdlib_chptrd with uplo = 'u'
              forwrd = ( left .and. notran ) .or.( .not.left .and. .not.notran )
              if( forwrd ) then
                 i1 = 1
                 i2 = nq - 1
                 i3 = 1
                 ii = 2
              else
                 i1 = nq - 1
                 i2 = 1
                 i3 = -1
                 ii = nq*( nq+1 ) / 2 - 1
              end if
              if( left ) then
                 ni = n
              else
                 mi = m
              end if
              do i = i1, i2, i3
                 if( left ) then
                    ! h(i) or h(i)**h is applied to c(1:i,1:n)
                    mi = i
                 else
                    ! h(i) or h(i)**h is applied to c(1:m,1:i)
                    ni = i
                 end if
                 ! apply h(i) or h(i)**h
                 if( notran ) then
                    taui = tau( i )
                 else
                    taui = conjg( tau( i ) )
                 end if
                 aii = ap( ii )
                 ap( ii ) = cone
                 call stdlib_clarf( side, mi, ni, ap( ii-i+1 ), 1, taui, c, ldc,work )
                 ap( ii ) = aii
                 if( forwrd ) then
                    ii = ii + i + 2
                 else
                    ii = ii - i - 1
                 end if
              end do
           else
              ! q was determined by a call to stdlib_chptrd with uplo = 'l'.
              forwrd = ( left .and. .not.notran ) .or.( .not.left .and. notran )
              if( forwrd ) then
                 i1 = 1
                 i2 = nq - 1
                 i3 = 1
                 ii = 2
              else
                 i1 = nq - 1
                 i2 = 1
                 i3 = -1
                 ii = nq*( nq+1 ) / 2 - 1
              end if
              if( left ) then
                 ni = n
                 jc = 1
              else
                 mi = m
                 ic = 1
              end if
              loop_20: do i = i1, i2, i3
                 aii = ap( ii )
                 ap( ii ) = cone
                 if( left ) then
                    ! h(i) or h(i)**h is applied to c(i+1:m,1:n)
                    mi = m - i
                    ic = i + 1
                 else
                    ! h(i) or h(i)**h is applied to c(1:m,i+1:n)
                    ni = n - i
                    jc = i + 1
                 end if
                 ! apply h(i) or h(i)**h
                 if( notran ) then
                    taui = tau( i )
                 else
                    taui = conjg( tau( i ) )
                 end if
                 call stdlib_clarf( side, mi, ni, ap( ii ), 1, taui, c( ic, jc ),ldc, work )
                           
                 ap( ii ) = aii
                 if( forwrd ) then
                    ii = ii + nq - i + 1
                 else
                    ii = ii - nq + i - 2
                 end if
              end do loop_20
           end if
           return
     end subroutine stdlib_cupmtr

     pure subroutine stdlib_zupmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )
     !! ZUPMTR overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! nq-1 elementary reflectors, as returned by ZHPTRD using packed
     !! storage:
     !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, m, n
           ! Array Arguments 
           complex(dp), intent(inout) :: ap(*), c(ldc,*)
           complex(dp), intent(in) :: tau(*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: forwrd, left, notran, upper
           integer(ilp) :: i, i1, i2, i3, ic, ii, jc, mi, ni, nq
           complex(dp) :: aii, taui
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           upper = stdlib_lsame( uplo, 'U' )
           ! nq is the order of q
           if( left ) then
              nq = m
           else
              nq = n
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( ldc<max( 1, m ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZUPMTR', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           if( upper ) then
              ! q was determined by a call to stdlib_zhptrd with uplo = 'u'
              forwrd = ( left .and. notran ) .or.( .not.left .and. .not.notran )
              if( forwrd ) then
                 i1 = 1
                 i2 = nq - 1
                 i3 = 1
                 ii = 2
              else
                 i1 = nq - 1
                 i2 = 1
                 i3 = -1
                 ii = nq*( nq+1 ) / 2 - 1
              end if
              if( left ) then
                 ni = n
              else
                 mi = m
              end if
              do i = i1, i2, i3
                 if( left ) then
                    ! h(i) or h(i)**h is applied to c(1:i,1:n)
                    mi = i
                 else
                    ! h(i) or h(i)**h is applied to c(1:m,1:i)
                    ni = i
                 end if
                 ! apply h(i) or h(i)**h
                 if( notran ) then
                    taui = tau( i )
                 else
                    taui = conjg( tau( i ) )
                 end if
                 aii = ap( ii )
                 ap( ii ) = cone
                 call stdlib_zlarf( side, mi, ni, ap( ii-i+1 ), 1, taui, c, ldc,work )
                 ap( ii ) = aii
                 if( forwrd ) then
                    ii = ii + i + 2
                 else
                    ii = ii - i - 1
                 end if
              end do
           else
              ! q was determined by a call to stdlib_zhptrd with uplo = 'l'.
              forwrd = ( left .and. .not.notran ) .or.( .not.left .and. notran )
              if( forwrd ) then
                 i1 = 1
                 i2 = nq - 1
                 i3 = 1
                 ii = 2
              else
                 i1 = nq - 1
                 i2 = 1
                 i3 = -1
                 ii = nq*( nq+1 ) / 2 - 1
              end if
              if( left ) then
                 ni = n
                 jc = 1
              else
                 mi = m
                 ic = 1
              end if
              loop_20: do i = i1, i2, i3
                 aii = ap( ii )
                 ap( ii ) = cone
                 if( left ) then
                    ! h(i) or h(i)**h is applied to c(i+1:m,1:n)
                    mi = m - i
                    ic = i + 1
                 else
                    ! h(i) or h(i)**h is applied to c(1:m,i+1:n)
                    ni = n - i
                    jc = i + 1
                 end if
                 ! apply h(i) or h(i)**h
                 if( notran ) then
                    taui = tau( i )
                 else
                    taui = conjg( tau( i ) )
                 end if
                 call stdlib_zlarf( side, mi, ni, ap( ii ), 1, taui, c( ic, jc ),ldc, work )
                           
                 ap( ii ) = aii
                 if( forwrd ) then
                    ii = ii + nq - i + 1
                 else
                    ii = ii - nq + i - 2
                 end if
              end do loop_20
           end if
           return
     end subroutine stdlib_zupmtr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$upmtr( side, uplo, trans, m, n, ap, tau, c, ldc, work,info )
     !! ZUPMTR: overwrites the general complex M-by-N matrix C with
     !! SIDE = 'L'     SIDE = 'R'
     !! TRANS = 'N':      Q * C          C * Q
     !! TRANS = 'C':      Q**H * C       C * Q**H
     !! where Q is a complex unitary matrix of order nq, with nq = m if
     !! SIDE = 'L' and nq = n if SIDE = 'R'. Q is defined as the product of
     !! nq-1 elementary reflectors, as returned by ZHPTRD using packed
     !! storage:
     !! if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: side, trans, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, m, n
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: ap(*), c(ldc,*)
           complex(${ck}$), intent(in) :: tau(*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: forwrd, left, notran, upper
           integer(ilp) :: i, i1, i2, i3, ic, ii, jc, mi, ni, nq
           complex(${ck}$) :: aii, taui
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           left = stdlib_lsame( side, 'L' )
           notran = stdlib_lsame( trans, 'N' )
           upper = stdlib_lsame( uplo, 'U' )
           ! nq is the order of q
           if( left ) then
              nq = m
           else
              nq = n
           end if
           if( .not.left .and. .not.stdlib_lsame( side, 'R' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( n<0 ) then
              info = -5
           else if( ldc<max( 1, m ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZUPMTR', -info )
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 )return
           if( upper ) then
              ! q was determined by a call to stdlib_${ci}$hptrd with uplo = 'u'
              forwrd = ( left .and. notran ) .or.( .not.left .and. .not.notran )
              if( forwrd ) then
                 i1 = 1
                 i2 = nq - 1
                 i3 = 1
                 ii = 2
              else
                 i1 = nq - 1
                 i2 = 1
                 i3 = -1
                 ii = nq*( nq+1 ) / 2 - 1
              end if
              if( left ) then
                 ni = n
              else
                 mi = m
              end if
              do i = i1, i2, i3
                 if( left ) then
                    ! h(i) or h(i)**h is applied to c(1:i,1:n)
                    mi = i
                 else
                    ! h(i) or h(i)**h is applied to c(1:m,1:i)
                    ni = i
                 end if
                 ! apply h(i) or h(i)**h
                 if( notran ) then
                    taui = tau( i )
                 else
                    taui = conjg( tau( i ) )
                 end if
                 aii = ap( ii )
                 ap( ii ) = cone
                 call stdlib_${ci}$larf( side, mi, ni, ap( ii-i+1 ), 1, taui, c, ldc,work )
                 ap( ii ) = aii
                 if( forwrd ) then
                    ii = ii + i + 2
                 else
                    ii = ii - i - 1
                 end if
              end do
           else
              ! q was determined by a call to stdlib_${ci}$hptrd with uplo = 'l'.
              forwrd = ( left .and. .not.notran ) .or.( .not.left .and. notran )
              if( forwrd ) then
                 i1 = 1
                 i2 = nq - 1
                 i3 = 1
                 ii = 2
              else
                 i1 = nq - 1
                 i2 = 1
                 i3 = -1
                 ii = nq*( nq+1 ) / 2 - 1
              end if
              if( left ) then
                 ni = n
                 jc = 1
              else
                 mi = m
                 ic = 1
              end if
              loop_20: do i = i1, i2, i3
                 aii = ap( ii )
                 ap( ii ) = cone
                 if( left ) then
                    ! h(i) or h(i)**h is applied to c(i+1:m,1:n)
                    mi = m - i
                    ic = i + 1
                 else
                    ! h(i) or h(i)**h is applied to c(1:m,i+1:n)
                    ni = n - i
                    jc = i + 1
                 end if
                 ! apply h(i) or h(i)**h
                 if( notran ) then
                    taui = tau( i )
                 else
                    taui = conjg( tau( i ) )
                 end if
                 call stdlib_${ci}$larf( side, mi, ni, ap( ii ), 1, taui, c( ic, jc ),ldc, work )
                           
                 ap( ii ) = aii
                 if( forwrd ) then
                    ii = ii + nq - i + 1
                 else
                    ii = ii - nq + i - 2
                 end if
              end do loop_20
           end if
           return
     end subroutine stdlib_${ci}$upmtr

#:endif
#:endfor







     pure subroutine stdlib_slarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
     !! SLARRV computes the eigenvectors of the tridiagonal matrix
     !! T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.
     !! The input eigenvalues should have been computed by SLARRE.
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: dol, dou, ldz, m, n
           integer(ilp), intent(out) :: info
           real(sp), intent(in) :: minrgp, pivmin, vl, vu
           real(sp), intent(inout) :: rtol1, rtol2
           ! Array Arguments 
           integer(ilp), intent(in) :: iblock(*), indexw(*), isplit(*)
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(inout) :: d(*), l(*), w(*), werr(*), wgap(*)
           real(sp), intent(in) :: gers(*)
           real(sp), intent(out) :: work(*)
           real(sp), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxitr = 10
           
           
           ! Local Scalars 
           logical(lk) :: eskip, needbs, stp2ii, tryrqc, usedbs, usedrq
           integer(ilp) :: done, i, ibegin, idone, iend, ii, iindc1, iindc2, iindr, iindwk, iinfo,&
            im, in, indeig, indld, indlld, indwrk, isupmn, isupmx, iter, itmp1, j, jblk, k, &
            miniwsize, minwsize, nclus, ndepth, negcnt, newcls, newfst, newftt, newlst, newsiz, &
            offset, oldcls, oldfst, oldien, oldlst, oldncl, p, parity, q, wbegin, wend, windex, &
                      windmn, windpl, zfrom, zto, zusedl, zusedu, zusedw
           real(sp) :: bstres, bstw, eps, fudge, gap, gaptol, gl, gu, lambda, left, lgap, mingma, &
           nrminv, resid, rgap, right, rqcorr, rqtol, savgap, sgndef, sigma, spdiam, ssigma, tau, &
                     tmp, tol, ztz
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( (n<=0).or.(m<=0) ) then
              return
           end if
           ! the first n entries of work are reserved for the eigenvalues
           indld = n+1
           indlld= 2*n+1
           indwrk= 3*n+1
           minwsize = 12 * n
           do i= 1,minwsize
              work( i ) = zero
           end do
           ! iwork(iindr+1:iindr+n) hold the twist indices r for the
           ! factorization used to compute the fp vector
           iindr = 0
           ! iwork(iindc1+1:iinc2+n) are used to store the clusters of the current
           ! layer and the one above.
           iindc1 = n
           iindc2 = 2*n
           iindwk = 3*n + 1
           miniwsize = 7 * n
           do i= 1,miniwsize
              iwork( i ) = 0
           end do
           zusedl = 1
           if(dol>1) then
              ! set lower bound for use of z
              zusedl = dol-1
           endif
           zusedu = m
           if(dou<m) then
              ! set lower bound for use of z
              zusedu = dou+1
           endif
           ! the width of the part of z that is used
           zusedw = zusedu - zusedl + 1
           call stdlib_slaset( 'FULL', n, zusedw, zero, zero,z(1,zusedl), ldz )
           eps = stdlib_slamch( 'PRECISION' )
           rqtol = two * eps
           ! set expert flags for standard code.
           tryrqc = .true.
           if((dol==1).and.(dou==m)) then
           else
              ! only selected eigenpairs are computed. since the other evalues
              ! are not refined by rq iteration, bisection has to compute to full
              ! accuracy.
              rtol1 = four * eps
              rtol2 = four * eps
           endif
           ! the entries wbegin:wend in w, werr, wgap correspond to the
           ! desired eigenvalues. the support of the nonzero eigenvector
           ! entries is contained in the interval ibegin:iend.
           ! remark that if k eigenpairs are desired, then the eigenvectors
           ! are stored in k contiguous columns of z.
           ! done is the number of eigenvectors already computed
           done = 0
           ibegin = 1
           wbegin = 1
           loop_170: do jblk = 1, iblock( m )
              iend = isplit( jblk )
              sigma = l( iend )
              ! find the eigenvectors of the submatrix indexed ibegin
              ! through iend.
              wend = wbegin - 1
              15 continue
              if( wend<m ) then
                 if( iblock( wend+1 )==jblk ) then
                    wend = wend + 1
                    go to 15
                 end if
              end if
              if( wend<wbegin ) then
                 ibegin = iend + 1
                 cycle loop_170
              elseif( (wend<dol).or.(wbegin>dou) ) then
                 ibegin = iend + 1
                 wbegin = wend + 1
                 cycle loop_170
              end if
              ! find local spectral diameter of the block
              gl = gers( 2*ibegin-1 )
              gu = gers( 2*ibegin )
              do i = ibegin+1 , iend
                 gl = min( gers( 2*i-1 ), gl )
                 gu = max( gers( 2*i ), gu )
              end do
              spdiam = gu - gl
              ! oldien is the last index of the previous block
              oldien = ibegin - 1
              ! calculate the size of the current block
              in = iend - ibegin + 1
              ! the number of eigenvalues in the current block
              im = wend - wbegin + 1
              ! this is for a 1x1 block
              if( ibegin==iend ) then
                 done = done+1
                 z( ibegin, wbegin ) = one
                 isuppz( 2*wbegin-1 ) = ibegin
                 isuppz( 2*wbegin ) = ibegin
                 w( wbegin ) = w( wbegin ) + sigma
                 work( wbegin ) = w( wbegin )
                 ibegin = iend + 1
                 wbegin = wbegin + 1
                 cycle loop_170
              end if
              ! the desired (shifted) eigenvalues are stored in w(wbegin:wend)
              ! note that these can be approximations, in this case, the corresp.
              ! entries of werr give the size of the uncertainty interval.
              ! the eigenvalue approximations will be refined when necessary as
              ! high relative accuracy is required for the computation of the
              ! corresponding eigenvectors.
              call stdlib_scopy( im, w( wbegin ), 1,work( wbegin ), 1 )
              ! we store in w the eigenvalue approximations w.r.t. the original
              ! matrix t.
              do i=1,im
                 w(wbegin+i-1) = w(wbegin+i-1)+sigma
              end do
              ! ndepth is the current depth of the representation tree
              ndepth = 0
              ! parity is either 1 or 0
              parity = 1
              ! nclus is the number of clusters for the next level of the
              ! representation tree, we start with nclus = 1 for the root
              nclus = 1
              iwork( iindc1+1 ) = 1
              iwork( iindc1+2 ) = im
              ! idone is the number of eigenvectors already computed in the current
              ! block
              idone = 0
              ! loop while( idone<im )
              ! generate the representation tree for the current block and
              ! compute the eigenvectors
              40 continue
              if( idone<im ) then
                 ! this is a crude protection against infinitely deep trees
                 if( ndepth>m ) then
                    info = -2
                    return
                 endif
                 ! breadth first processing of the current level of the representation
                 ! tree: oldncl = number of clusters on current level
                 oldncl = nclus
                 ! reset nclus to count the number of child clusters
                 nclus = 0
                 parity = 1 - parity
                 if( parity==0 ) then
                    oldcls = iindc1
                    newcls = iindc2
                 else
                    oldcls = iindc2
                    newcls = iindc1
                 end if
                 ! process the clusters on the current level
                 loop_150: do i = 1, oldncl
                    j = oldcls + 2*i
                    ! oldfst, oldlst = first, last index of current cluster.
                                     ! cluster indices start with 1 and are relative
                                     ! to wbegin when accessing w, wgap, werr, z
                    oldfst = iwork( j-1 )
                    oldlst = iwork( j )
                    if( ndepth>0 ) then
                       ! retrieve relatively robust representation (rrr) of cluster
                       ! that has been computed at the previous level
                       ! the rrr is stored in z and overwritten once the eigenvectors
                       ! have been computed or when the cluster is refined
                       if((dol==1).and.(dou==m)) then
                          ! get representation from location of the leftmost evalue
                          ! of the cluster
                          j = wbegin + oldfst - 1
                       else
                          if(wbegin+oldfst-1<dol) then
                             ! get representation from the left end of z array
                             j = dol - 1
                          elseif(wbegin+oldfst-1>dou) then
                             ! get representation from the right end of z array
                             j = dou
                          else
                             j = wbegin + oldfst - 1
                          endif
                       endif
                       call stdlib_scopy( in, z( ibegin, j ), 1, d( ibegin ), 1 )
                       call stdlib_scopy( in-1, z( ibegin, j+1 ), 1, l( ibegin ),1 )
                       sigma = z( iend, j+1 )
                       ! set the corresponding entries in z to zero
                       call stdlib_slaset( 'FULL', in, 2, zero, zero,z( ibegin, j), ldz )
                    end if
                    ! compute dl and dll of current rrr
                    do j = ibegin, iend-1
                       tmp = d( j )*l( j )
                       work( indld-1+j ) = tmp
                       work( indlld-1+j ) = tmp*l( j )
                    end do
                    if( ndepth>0 ) then
                       ! p and q are index of the first and last eigenvalue to compute
                       ! within the current block
                       p = indexw( wbegin-1+oldfst )
                       q = indexw( wbegin-1+oldlst )
                       ! offset for the arrays work, wgap and werr, i.e., the p-offset
                       ! through the q-offset elements of these arrays are to be used.
                        ! offset = p-oldfst
                       offset = indexw( wbegin ) - 1
                       ! perform limited bisection (if necessary) to get approximate
                       ! eigenvalues to the precision needed.
                       call stdlib_slarrb( in, d( ibegin ),work(indlld+ibegin-1),p, q, rtol1, &
                       rtol2, offset,work(wbegin),wgap(wbegin),werr(wbegin),work( indwrk ), iwork(&
                                  iindwk ),pivmin, spdiam, in, iinfo )
                       if( iinfo/=0 ) then
                          info = -1
                          return
                       endif
                       ! we also recompute the extremal gaps. w holds all eigenvalues
                       ! of the unshifted matrix and must be used for computation
                       ! of wgap, the entries of work might stem from rrrs with
                       ! different shifts. the gaps from wbegin-1+oldfst to
                       ! wbegin-1+oldlst are correctly computed in stdlib_slarrb.
                       ! however, we only allow the gaps to become greater since
                       ! this is what should happen when we decrease werr
                       if( oldfst>1) then
                          wgap( wbegin+oldfst-2 ) =max(wgap(wbegin+oldfst-2),w(wbegin+oldfst-1)-&
                          werr(wbegin+oldfst-1)- w(wbegin+oldfst-2)-werr(wbegin+oldfst-2) )
                                    
                       endif
                       if( wbegin + oldlst -1 < wend ) then
                          wgap( wbegin+oldlst-1 ) =max(wgap(wbegin+oldlst-1),w(wbegin+oldlst)-&
                                    werr(wbegin+oldlst)- w(wbegin+oldlst-1)-werr(wbegin+oldlst-1) )
                       endif
                       ! each time the eigenvalues in work get refined, we store
                       ! the newly found approximation with all shifts applied in w
                       do j=oldfst,oldlst
                          w(wbegin+j-1) = work(wbegin+j-1)+sigma
                       end do
                    end if
                    ! process the current node.
                    newfst = oldfst
                    loop_140: do j = oldfst, oldlst
                       if( j==oldlst ) then
                          ! we are at the right end of the cluster, this is also the
                          ! boundary of the child cluster
                          newlst = j
                       else if ( wgap( wbegin + j -1)>=minrgp* abs( work(wbegin + j -1) ) ) &
                                 then
                          ! the right relative gap is big enough, the child cluster
                          ! (newfst,..,newlst) is well separated from the following
                          newlst = j
                        else
                          ! inside a child cluster, the relative gap is not
                          ! big enough.
                          cycle loop_140
                       end if
                       ! compute size of child cluster found
                       newsiz = newlst - newfst + 1
                       ! newftt is the place in z where the new rrr or the computed
                       ! eigenvector is to be stored
                       if((dol==1).and.(dou==m)) then
                          ! store representation at location of the leftmost evalue
                          ! of the cluster
                          newftt = wbegin + newfst - 1
                       else
                          if(wbegin+newfst-1<dol) then
                             ! store representation at the left end of z array
                             newftt = dol - 1
                          elseif(wbegin+newfst-1>dou) then
                             ! store representation at the right end of z array
                             newftt = dou
                          else
                             newftt = wbegin + newfst - 1
                          endif
                       endif
                       if( newsiz>1) then
                          ! current child is not a singleton but a cluster.
                          ! compute and store new representation of child.
                          ! compute left and right cluster gap.
                          ! lgap and rgap are not computed from work because
                          ! the eigenvalue approximations may stem from rrrs
                          ! different shifts. however, w hold all eigenvalues
                          ! of the unshifted matrix. still, the entries in wgap
                          ! have to be computed from work since the entries
                          ! in w might be of the same order so that gaps are not
                          ! exhibited correctly for very close eigenvalues.
                          if( newfst==1 ) then
                             lgap = max( zero,w(wbegin)-werr(wbegin) - vl )
                         else
                             lgap = wgap( wbegin+newfst-2 )
                          endif
                          rgap = wgap( wbegin+newlst-1 )
                          ! compute left- and rightmost eigenvalue of child
                          ! to high precision in order to shift as close
                          ! as possible and obtain as large relative gaps
                          ! as possible
                          do k =1,2
                             if(k==1) then
                                p = indexw( wbegin-1+newfst )
                             else
                                p = indexw( wbegin-1+newlst )
                             endif
                             offset = indexw( wbegin ) - 1
                             call stdlib_slarrb( in, d(ibegin),work( indlld+ibegin-1 ),p,p,rqtol, &
                             rqtol, offset,work(wbegin),wgap(wbegin),werr(wbegin),work( indwrk ),&
                                       iwork( iindwk ), pivmin, spdiam,in, iinfo )
                          end do
                          if((wbegin+newlst-1<dol).or.(wbegin+newfst-1>dou)) then
                             ! if the cluster contains no desired eigenvalues
                             ! skip the computation of that branch of the rep. tree
                             ! we could skip before the refinement of the extremal
                             ! eigenvalues of the child, but then the representation
                             ! tree could be different from the one when nothing is
                             ! skipped. for this reason we skip at this place.
                             idone = idone + newlst - newfst + 1
                             goto 139
                          endif
                          ! compute rrr of child cluster.
                          ! note that the new rrr is stored in z
                          ! stdlib_slarrf needs lwork = 2*n
                          call stdlib_slarrf( in, d( ibegin ), l( ibegin ),work(indld+ibegin-1),&
                          newfst, newlst, work(wbegin),wgap(wbegin), werr(wbegin),spdiam, lgap, &
                          rgap, pivmin, tau,z(ibegin, newftt),z(ibegin, newftt+1),work( indwrk ), &
                                    iinfo )
                          if( iinfo==0 ) then
                             ! a new rrr for the cluster was found by stdlib_slarrf
                             ! update shift and store it
                             ssigma = sigma + tau
                             z( iend, newftt+1 ) = ssigma
                             ! work() are the midpoints and werr() the semi-width
                             ! note that the entries in w are unchanged.
                             do k = newfst, newlst
                                fudge =three*eps*abs(work(wbegin+k-1))
                                work( wbegin + k - 1 ) =work( wbegin + k - 1) - tau
                                fudge = fudge +four*eps*abs(work(wbegin+k-1))
                                ! fudge errors
                                werr( wbegin + k - 1 ) =werr( wbegin + k - 1 ) + fudge
                                ! gaps are not fudged. provided that werr is small
                                ! when eigenvalues are close, a zero gap indicates
                                ! that a new representation is needed for resolving
                                ! the cluster. a fudge could lead to a wrong decision
                                ! of judging eigenvalues 'separated' which in
                                ! reality are not. this could have a negative impact
                                ! on the orthogonality of the computed eigenvectors.
                             end do
                             nclus = nclus + 1
                             k = newcls + 2*nclus
                             iwork( k-1 ) = newfst
                             iwork( k ) = newlst
                          else
                             info = -2
                             return
                          endif
                       else
                          ! compute eigenvector of singleton
                          iter = 0
                          tol = four * log(real(in,KIND=sp)) * eps
                          k = newfst
                          windex = wbegin + k - 1
                          windmn = max(windex - 1,1)
                          windpl = min(windex + 1,m)
                          lambda = work( windex )
                          done = done + 1
                          ! check if eigenvector computation is to be skipped
                          if((windex<dol).or.(windex>dou)) then
                             eskip = .true.
                             goto 125
                          else
                             eskip = .false.
                          endif
                          left = work( windex ) - werr( windex )
                          right = work( windex ) + werr( windex )
                          indeig = indexw( windex )
                          ! note that since we compute the eigenpairs for a child,
                          ! all eigenvalue approximations are w.r.t the same shift.
                          ! in this case, the entries in work should be used for
                          ! computing the gaps since they exhibit even very small
                          ! differences in the eigenvalues, as opposed to the
                          ! entries in w which might "look" the same.
                          if( k == 1) then
                             ! in the case range='i' and with not much initial
                             ! accuracy in lambda and vl, the formula
                             ! lgap = max( zero, (sigma - vl) + lambda )
                             ! can lead to an overestimation of the left gap and
                             ! thus to inadequately early rqi 'convergence'.
                             ! prevent this by forcing a small left gap.
                             lgap = eps*max(abs(left),abs(right))
                          else
                             lgap = wgap(windmn)
                          endif
                          if( k == im) then
                             ! in the case range='i' and with not much initial
                             ! accuracy in lambda and vu, the formula
                             ! can lead to an overestimation of the right gap and
                             ! thus to inadequately early rqi 'convergence'.
                             ! prevent this by forcing a small right gap.
                             rgap = eps*max(abs(left),abs(right))
                          else
                             rgap = wgap(windex)
                          endif
                          gap = min( lgap, rgap )
                          if(( k == 1).or.(k == im)) then
                             ! the eigenvector support can become wrong
                             ! because significant entries could be cut off due to a
                             ! large gaptol parameter in lar1v. prevent this.
                             gaptol = zero
                          else
                             gaptol = gap * eps
                          endif
                          isupmn = in
                          isupmx = 1
                          ! update wgap so that it holds the minimum gap
                          ! to the left or the right. this is crucial in the
                          ! case where bisection is used to ensure that the
                          ! eigenvalue is refined up to the required precision.
                          ! the correct value is restored afterwards.
                          savgap = wgap(windex)
                          wgap(windex) = gap
                          ! we want to use the rayleigh quotient correction
                          ! as often as possible since it converges quadratically
                          ! when we are close enough to the desired eigenvalue.
                          ! however, the rayleigh quotient can have the wrong sign
                          ! and lead us away from the desired eigenvalue. in this
                          ! case, the best we can do is to use bisection.
                          usedbs = .false.
                          usedrq = .false.
                          ! bisection is initially turned off unless it is forced
                          needbs =  .not.tryrqc
                          120 continue
                          ! check if bisection should be used to refine eigenvalue
                          if(needbs) then
                             ! take the bisection as new iterate
                             usedbs = .true.
                             itmp1 = iwork( iindr+windex )
                             offset = indexw( wbegin ) - 1
                             call stdlib_slarrb( in, d(ibegin),work(indlld+ibegin-1),indeig,&
                             indeig,zero, two*eps, offset,work(wbegin),wgap(wbegin),werr(wbegin),&
                                       work( indwrk ),iwork( iindwk ), pivmin, spdiam,itmp1, iinfo )
                             if( iinfo/=0 ) then
                                info = -3
                                return
                             endif
                             lambda = work( windex )
                             ! reset twist index from inaccurate lambda to
                             ! force computation of true mingma
                             iwork( iindr+windex ) = 0
                          endif
                          ! given lambda, compute the eigenvector.
                          call stdlib_slar1v( in, 1, in, lambda, d( ibegin ),l( ibegin ), work(&
                          indld+ibegin-1),work(indlld+ibegin-1),pivmin, gaptol, z( ibegin, windex &
                          ),.not.usedbs, negcnt, ztz, mingma,iwork( iindr+windex ), isuppz( &
                                    2*windex-1 ),nrminv, resid, rqcorr, work( indwrk ) )
                          if(iter == 0) then
                             bstres = resid
                             bstw = lambda
                          elseif(resid<bstres) then
                             bstres = resid
                             bstw = lambda
                          endif
                          isupmn = min(isupmn,isuppz( 2*windex-1 ))
                          isupmx = max(isupmx,isuppz( 2*windex ))
                          iter = iter + 1
                          ! sin alpha <= |resid|/gap
                          ! note that both the residual and the gap are
                          ! proportional to the matrix, so ||t|| doesn't play
                          ! a role in the quotient
                          ! convergence test for rayleigh-quotient iteration
                          ! (omitted when bisection has been used)
                          if( resid>tol*gap .and. abs( rqcorr )>rqtol*abs( lambda ) .and. .not. &
                                    usedbs)then
                             ! we need to check that the rqcorr update doesn't
                             ! move the eigenvalue away from the desired one and
                             ! towards a neighbor. -> protection with bisection
                             if(indeig<=negcnt) then
                                ! the wanted eigenvalue lies to the left
                                sgndef = -one
                             else
                                ! the wanted eigenvalue lies to the right
                                sgndef = one
                             endif
                             ! we only use the rqcorr if it improves the
                             ! the iterate reasonably.
                             if( ( rqcorr*sgndef>=zero ).and.( lambda + rqcorr<= right).and.( &
                                       lambda + rqcorr>= left)) then
                                usedrq = .true.
                                ! store new midpoint of bisection interval in work
                                if(sgndef==one) then
                                   ! the current lambda is on the left of the true
                                   ! eigenvalue
                                   left = lambda
                                   ! we prefer to assume that the error estimate
                                   ! is correct. we could make the interval not
                                   ! as a bracket but to be modified if the rqcorr
                                   ! chooses to. in this case, the right side should
                                   ! be modified as follows:
                                    ! right = max(right, lambda + rqcorr)
                                else
                                   ! the current lambda is on the right of the true
                                   ! eigenvalue
                                   right = lambda
                                   ! see comment about assuming the error estimate is
                                   ! correct above.
                                    ! left = min(left, lambda + rqcorr)
                                endif
                                work( windex ) =half * (right + left)
                                ! take rqcorr since it has the correct sign and
                                ! improves the iterate reasonably
                                lambda = lambda + rqcorr
                                ! update width of error interval
                                werr( windex ) =half * (right-left)
                             else
                                needbs = .true.
                             endif
                             if(right-left<rqtol*abs(lambda)) then
                                   ! the eigenvalue is computed to bisection accuracy
                                   ! compute eigenvector and stop
                                usedbs = .true.
                                goto 120
                             elseif( iter<maxitr ) then
                                goto 120
                             elseif( iter==maxitr ) then
                                needbs = .true.
                                goto 120
                             else
                                info = 5
                                return
                             end if
                          else
                             stp2ii = .false.
             if(usedrq .and. usedbs .and.bstres<=resid) then
                                lambda = bstw
                                stp2ii = .true.
                             endif
                             if (stp2ii) then
                                ! improve error angle by second step
                                call stdlib_slar1v( in, 1, in, lambda,d( ibegin ), l( ibegin ),&
                                work(indld+ibegin-1),work(indlld+ibegin-1),pivmin, gaptol, z( &
                                ibegin, windex ),.not.usedbs, negcnt, ztz, mingma,iwork( iindr+&
                                windex ),isuppz( 2*windex-1 ),nrminv, resid, rqcorr, work( indwrk &
                                          ) )
                             endif
                             work( windex ) = lambda
                          end if
                          ! compute fp-vector support w.r.t. whole matrix
                          isuppz( 2*windex-1 ) = isuppz( 2*windex-1 )+oldien
                          isuppz( 2*windex ) = isuppz( 2*windex )+oldien
                          zfrom = isuppz( 2*windex-1 )
                          zto = isuppz( 2*windex )
                          isupmn = isupmn + oldien
                          isupmx = isupmx + oldien
                          ! ensure vector is ok if support in the rqi has changed
                          if(isupmn<zfrom) then
                             do ii = isupmn,zfrom-1
                                z( ii, windex ) = zero
                             end do
                          endif
                          if(isupmx>zto) then
                             do ii = zto+1,isupmx
                                z( ii, windex ) = zero
                             end do
                          endif
                          call stdlib_sscal( zto-zfrom+1, nrminv,z( zfrom, windex ), 1 )
                          125 continue
                          ! update w
                          w( windex ) = lambda+sigma
                          ! recompute the gaps on the left and right
                          ! but only allow them to become larger and not
                          ! smaller (which can only happen through "bad"
                          ! cancellation and doesn't reflect the theory
                          ! where the initial gaps are underestimated due
                          ! to werr being too crude.)
                          if(.not.eskip) then
                             if( k>1) then
                                wgap( windmn ) = max( wgap(windmn),w(windex)-werr(windex)- w(&
                                          windmn)-werr(windmn) )
                             endif
                             if( windex<wend ) then
                                wgap( windex ) = max( savgap,w( windpl )-werr( windpl )- w( &
                                          windex )-werr( windex) )
                             endif
                          endif
                          idone = idone + 1
                       endif
                       ! here ends the code for the current child
                       139 continue
                       ! proceed to any remaining child nodes
                       newfst = j + 1
                    end do loop_140
                 end do loop_150
                 ndepth = ndepth + 1
                 go to 40
              end if
              ibegin = iend + 1
              wbegin = wend + 1
           end do loop_170
           return
     end subroutine stdlib_slarrv

     pure subroutine stdlib_dlarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
     !! DLARRV computes the eigenvectors of the tridiagonal matrix
     !! T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.
     !! The input eigenvalues should have been computed by DLARRE.
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: dol, dou, ldz, m, n
           integer(ilp), intent(out) :: info
           real(dp), intent(in) :: minrgp, pivmin, vl, vu
           real(dp), intent(inout) :: rtol1, rtol2
           ! Array Arguments 
           integer(ilp), intent(in) :: iblock(*), indexw(*), isplit(*)
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(dp), intent(inout) :: d(*), l(*), w(*), werr(*), wgap(*)
           real(dp), intent(in) :: gers(*)
           real(dp), intent(out) :: work(*)
           real(dp), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxitr = 10
           
           
           ! Local Scalars 
           logical(lk) :: eskip, needbs, stp2ii, tryrqc, usedbs, usedrq
           integer(ilp) :: done, i, ibegin, idone, iend, ii, iindc1, iindc2, iindr, iindwk, iinfo,&
            im, in, indeig, indld, indlld, indwrk, isupmn, isupmx, iter, itmp1, j, jblk, k, &
            miniwsize, minwsize, nclus, ndepth, negcnt, newcls, newfst, newftt, newlst, newsiz, &
            offset, oldcls, oldfst, oldien, oldlst, oldncl, p, parity, q, wbegin, wend, windex, &
                      windmn, windpl, zfrom, zto, zusedl, zusedu, zusedw
           real(dp) :: bstres, bstw, eps, fudge, gap, gaptol, gl, gu, lambda, left, lgap, mingma, &
           nrminv, resid, rgap, right, rqcorr, rqtol, savgap, sgndef, sigma, spdiam, ssigma, tau, &
                     tmp, tol, ztz
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( (n<=0).or.(m<=0) ) then
              return
           end if
           ! the first n entries of work are reserved for the eigenvalues
           indld = n+1
           indlld= 2*n+1
           indwrk= 3*n+1
           minwsize = 12 * n
           do i= 1,minwsize
              work( i ) = zero
           end do
           ! iwork(iindr+1:iindr+n) hold the twist indices r for the
           ! factorization used to compute the fp vector
           iindr = 0
           ! iwork(iindc1+1:iinc2+n) are used to store the clusters of the current
           ! layer and the one above.
           iindc1 = n
           iindc2 = 2*n
           iindwk = 3*n + 1
           miniwsize = 7 * n
           do i= 1,miniwsize
              iwork( i ) = 0
           end do
           zusedl = 1
           if(dol>1) then
              ! set lower bound for use of z
              zusedl = dol-1
           endif
           zusedu = m
           if(dou<m) then
              ! set lower bound for use of z
              zusedu = dou+1
           endif
           ! the width of the part of z that is used
           zusedw = zusedu - zusedl + 1
           call stdlib_dlaset( 'FULL', n, zusedw, zero, zero,z(1,zusedl), ldz )
           eps = stdlib_dlamch( 'PRECISION' )
           rqtol = two * eps
           ! set expert flags for standard code.
           tryrqc = .true.
           if((dol==1).and.(dou==m)) then
           else
              ! only selected eigenpairs are computed. since the other evalues
              ! are not refined by rq iteration, bisection has to compute to full
              ! accuracy.
              rtol1 = four * eps
              rtol2 = four * eps
           endif
           ! the entries wbegin:wend in w, werr, wgap correspond to the
           ! desired eigenvalues. the support of the nonzero eigenvector
           ! entries is contained in the interval ibegin:iend.
           ! remark that if k eigenpairs are desired, then the eigenvectors
           ! are stored in k contiguous columns of z.
           ! done is the number of eigenvectors already computed
           done = 0
           ibegin = 1
           wbegin = 1
           loop_170: do jblk = 1, iblock( m )
              iend = isplit( jblk )
              sigma = l( iend )
              ! find the eigenvectors of the submatrix indexed ibegin
              ! through iend.
              wend = wbegin - 1
              15 continue
              if( wend<m ) then
                 if( iblock( wend+1 )==jblk ) then
                    wend = wend + 1
                    go to 15
                 end if
              end if
              if( wend<wbegin ) then
                 ibegin = iend + 1
                 cycle loop_170
              elseif( (wend<dol).or.(wbegin>dou) ) then
                 ibegin = iend + 1
                 wbegin = wend + 1
                 cycle loop_170
              end if
              ! find local spectral diameter of the block
              gl = gers( 2*ibegin-1 )
              gu = gers( 2*ibegin )
              do i = ibegin+1 , iend
                 gl = min( gers( 2*i-1 ), gl )
                 gu = max( gers( 2*i ), gu )
              end do
              spdiam = gu - gl
              ! oldien is the last index of the previous block
              oldien = ibegin - 1
              ! calculate the size of the current block
              in = iend - ibegin + 1
              ! the number of eigenvalues in the current block
              im = wend - wbegin + 1
              ! this is for a 1x1 block
              if( ibegin==iend ) then
                 done = done+1
                 z( ibegin, wbegin ) = one
                 isuppz( 2*wbegin-1 ) = ibegin
                 isuppz( 2*wbegin ) = ibegin
                 w( wbegin ) = w( wbegin ) + sigma
                 work( wbegin ) = w( wbegin )
                 ibegin = iend + 1
                 wbegin = wbegin + 1
                 cycle loop_170
              end if
              ! the desired (shifted) eigenvalues are stored in w(wbegin:wend)
              ! note that these can be approximations, in this case, the corresp.
              ! entries of werr give the size of the uncertainty interval.
              ! the eigenvalue approximations will be refined when necessary as
              ! high relative accuracy is required for the computation of the
              ! corresponding eigenvectors.
              call stdlib_dcopy( im, w( wbegin ), 1,work( wbegin ), 1 )
              ! we store in w the eigenvalue approximations w.r.t. the original
              ! matrix t.
              do i=1,im
                 w(wbegin+i-1) = w(wbegin+i-1)+sigma
              end do
              ! ndepth is the current depth of the representation tree
              ndepth = 0
              ! parity is either 1 or 0
              parity = 1
              ! nclus is the number of clusters for the next level of the
              ! representation tree, we start with nclus = 1 for the root
              nclus = 1
              iwork( iindc1+1 ) = 1
              iwork( iindc1+2 ) = im
              ! idone is the number of eigenvectors already computed in the current
              ! block
              idone = 0
              ! loop while( idone<im )
              ! generate the representation tree for the current block and
              ! compute the eigenvectors
              40 continue
              if( idone<im ) then
                 ! this is a crude protection against infinitely deep trees
                 if( ndepth>m ) then
                    info = -2
                    return
                 endif
                 ! breadth first processing of the current level of the representation
                 ! tree: oldncl = number of clusters on current level
                 oldncl = nclus
                 ! reset nclus to count the number of child clusters
                 nclus = 0
                 parity = 1 - parity
                 if( parity==0 ) then
                    oldcls = iindc1
                    newcls = iindc2
                 else
                    oldcls = iindc2
                    newcls = iindc1
                 end if
                 ! process the clusters on the current level
                 loop_150: do i = 1, oldncl
                    j = oldcls + 2*i
                    ! oldfst, oldlst = first, last index of current cluster.
                                     ! cluster indices start with 1 and are relative
                                     ! to wbegin when accessing w, wgap, werr, z
                    oldfst = iwork( j-1 )
                    oldlst = iwork( j )
                    if( ndepth>0 ) then
                       ! retrieve relatively robust representation (rrr) of cluster
                       ! that has been computed at the previous level
                       ! the rrr is stored in z and overwritten once the eigenvectors
                       ! have been computed or when the cluster is refined
                       if((dol==1).and.(dou==m)) then
                          ! get representation from location of the leftmost evalue
                          ! of the cluster
                          j = wbegin + oldfst - 1
                       else
                          if(wbegin+oldfst-1<dol) then
                             ! get representation from the left end of z array
                             j = dol - 1
                          elseif(wbegin+oldfst-1>dou) then
                             ! get representation from the right end of z array
                             j = dou
                          else
                             j = wbegin + oldfst - 1
                          endif
                       endif
                       call stdlib_dcopy( in, z( ibegin, j ), 1, d( ibegin ), 1 )
                       call stdlib_dcopy( in-1, z( ibegin, j+1 ), 1, l( ibegin ),1 )
                       sigma = z( iend, j+1 )
                       ! set the corresponding entries in z to zero
                       call stdlib_dlaset( 'FULL', in, 2, zero, zero,z( ibegin, j), ldz )
                    end if
                    ! compute dl and dll of current rrr
                    do j = ibegin, iend-1
                       tmp = d( j )*l( j )
                       work( indld-1+j ) = tmp
                       work( indlld-1+j ) = tmp*l( j )
                    end do
                    if( ndepth>0 ) then
                       ! p and q are index of the first and last eigenvalue to compute
                       ! within the current block
                       p = indexw( wbegin-1+oldfst )
                       q = indexw( wbegin-1+oldlst )
                       ! offset for the arrays work, wgap and werr, i.e., the p-offset
                       ! through the q-offset elements of these arrays are to be used.
                        ! offset = p-oldfst
                       offset = indexw( wbegin ) - 1
                       ! perform limited bisection (if necessary) to get approximate
                       ! eigenvalues to the precision needed.
                       call stdlib_dlarrb( in, d( ibegin ),work(indlld+ibegin-1),p, q, rtol1, &
                       rtol2, offset,work(wbegin),wgap(wbegin),werr(wbegin),work( indwrk ), iwork(&
                                  iindwk ),pivmin, spdiam, in, iinfo )
                       if( iinfo/=0 ) then
                          info = -1
                          return
                       endif
                       ! we also recompute the extremal gaps. w holds all eigenvalues
                       ! of the unshifted matrix and must be used for computation
                       ! of wgap, the entries of work might stem from rrrs with
                       ! different shifts. the gaps from wbegin-1+oldfst to
                       ! wbegin-1+oldlst are correctly computed in stdlib_dlarrb.
                       ! however, we only allow the gaps to become greater since
                       ! this is what should happen when we decrease werr
                       if( oldfst>1) then
                          wgap( wbegin+oldfst-2 ) =max(wgap(wbegin+oldfst-2),w(wbegin+oldfst-1)-&
                          werr(wbegin+oldfst-1)- w(wbegin+oldfst-2)-werr(wbegin+oldfst-2) )
                                    
                       endif
                       if( wbegin + oldlst -1 < wend ) then
                          wgap( wbegin+oldlst-1 ) =max(wgap(wbegin+oldlst-1),w(wbegin+oldlst)-&
                                    werr(wbegin+oldlst)- w(wbegin+oldlst-1)-werr(wbegin+oldlst-1) )
                       endif
                       ! each time the eigenvalues in work get refined, we store
                       ! the newly found approximation with all shifts applied in w
                       do j=oldfst,oldlst
                          w(wbegin+j-1) = work(wbegin+j-1)+sigma
                       end do
                    end if
                    ! process the current node.
                    newfst = oldfst
                    loop_140: do j = oldfst, oldlst
                       if( j==oldlst ) then
                          ! we are at the right end of the cluster, this is also the
                          ! boundary of the child cluster
                          newlst = j
                       else if ( wgap( wbegin + j -1)>=minrgp* abs( work(wbegin + j -1) ) ) &
                                 then
                          ! the right relative gap is big enough, the child cluster
                          ! (newfst,..,newlst) is well separated from the following
                          newlst = j
                        else
                          ! inside a child cluster, the relative gap is not
                          ! big enough.
                          cycle loop_140
                       end if
                       ! compute size of child cluster found
                       newsiz = newlst - newfst + 1
                       ! newftt is the place in z where the new rrr or the computed
                       ! eigenvector is to be stored
                       if((dol==1).and.(dou==m)) then
                          ! store representation at location of the leftmost evalue
                          ! of the cluster
                          newftt = wbegin + newfst - 1
                       else
                          if(wbegin+newfst-1<dol) then
                             ! store representation at the left end of z array
                             newftt = dol - 1
                          elseif(wbegin+newfst-1>dou) then
                             ! store representation at the right end of z array
                             newftt = dou
                          else
                             newftt = wbegin + newfst - 1
                          endif
                       endif
                       if( newsiz>1) then
                          ! current child is not a singleton but a cluster.
                          ! compute and store new representation of child.
                          ! compute left and right cluster gap.
                          ! lgap and rgap are not computed from work because
                          ! the eigenvalue approximations may stem from rrrs
                          ! different shifts. however, w hold all eigenvalues
                          ! of the unshifted matrix. still, the entries in wgap
                          ! have to be computed from work since the entries
                          ! in w might be of the same order so that gaps are not
                          ! exhibited correctly for very close eigenvalues.
                          if( newfst==1 ) then
                             lgap = max( zero,w(wbegin)-werr(wbegin) - vl )
                         else
                             lgap = wgap( wbegin+newfst-2 )
                          endif
                          rgap = wgap( wbegin+newlst-1 )
                          ! compute left- and rightmost eigenvalue of child
                          ! to high precision in order to shift as close
                          ! as possible and obtain as large relative gaps
                          ! as possible
                          do k =1,2
                             if(k==1) then
                                p = indexw( wbegin-1+newfst )
                             else
                                p = indexw( wbegin-1+newlst )
                             endif
                             offset = indexw( wbegin ) - 1
                             call stdlib_dlarrb( in, d(ibegin),work( indlld+ibegin-1 ),p,p,rqtol, &
                             rqtol, offset,work(wbegin),wgap(wbegin),werr(wbegin),work( indwrk ),&
                                       iwork( iindwk ), pivmin, spdiam,in, iinfo )
                          end do
                          if((wbegin+newlst-1<dol).or.(wbegin+newfst-1>dou)) then
                             ! if the cluster contains no desired eigenvalues
                             ! skip the computation of that branch of the rep. tree
                             ! we could skip before the refinement of the extremal
                             ! eigenvalues of the child, but then the representation
                             ! tree could be different from the one when nothing is
                             ! skipped. for this reason we skip at this place.
                             idone = idone + newlst - newfst + 1
                             goto 139
                          endif
                          ! compute rrr of child cluster.
                          ! note that the new rrr is stored in z
                          ! stdlib_dlarrf needs lwork = 2*n
                          call stdlib_dlarrf( in, d( ibegin ), l( ibegin ),work(indld+ibegin-1),&
                          newfst, newlst, work(wbegin),wgap(wbegin), werr(wbegin),spdiam, lgap, &
                          rgap, pivmin, tau,z(ibegin, newftt),z(ibegin, newftt+1),work( indwrk ), &
                                    iinfo )
                          if( iinfo==0 ) then
                             ! a new rrr for the cluster was found by stdlib_dlarrf
                             ! update shift and store it
                             ssigma = sigma + tau
                             z( iend, newftt+1 ) = ssigma
                             ! work() are the midpoints and werr() the semi-width
                             ! note that the entries in w are unchanged.
                             do k = newfst, newlst
                                fudge =three*eps*abs(work(wbegin+k-1))
                                work( wbegin + k - 1 ) =work( wbegin + k - 1) - tau
                                fudge = fudge +four*eps*abs(work(wbegin+k-1))
                                ! fudge errors
                                werr( wbegin + k - 1 ) =werr( wbegin + k - 1 ) + fudge
                                ! gaps are not fudged. provided that werr is small
                                ! when eigenvalues are close, a zero gap indicates
                                ! that a new representation is needed for resolving
                                ! the cluster. a fudge could lead to a wrong decision
                                ! of judging eigenvalues 'separated' which in
                                ! reality are not. this could have a negative impact
                                ! on the orthogonality of the computed eigenvectors.
                             end do
                             nclus = nclus + 1
                             k = newcls + 2*nclus
                             iwork( k-1 ) = newfst
                             iwork( k ) = newlst
                          else
                             info = -2
                             return
                          endif
                       else
                          ! compute eigenvector of singleton
                          iter = 0
                          tol = four * log(real(in,KIND=dp)) * eps
                          k = newfst
                          windex = wbegin + k - 1
                          windmn = max(windex - 1,1)
                          windpl = min(windex + 1,m)
                          lambda = work( windex )
                          done = done + 1
                          ! check if eigenvector computation is to be skipped
                          if((windex<dol).or.(windex>dou)) then
                             eskip = .true.
                             goto 125
                          else
                             eskip = .false.
                          endif
                          left = work( windex ) - werr( windex )
                          right = work( windex ) + werr( windex )
                          indeig = indexw( windex )
                          ! note that since we compute the eigenpairs for a child,
                          ! all eigenvalue approximations are w.r.t the same shift.
                          ! in this case, the entries in work should be used for
                          ! computing the gaps since they exhibit even very small
                          ! differences in the eigenvalues, as opposed to the
                          ! entries in w which might "look" the same.
                          if( k == 1) then
                             ! in the case range='i' and with not much initial
                             ! accuracy in lambda and vl, the formula
                             ! lgap = max( zero, (sigma - vl) + lambda )
                             ! can lead to an overestimation of the left gap and
                             ! thus to inadequately early rqi 'convergence'.
                             ! prevent this by forcing a small left gap.
                             lgap = eps*max(abs(left),abs(right))
                          else
                             lgap = wgap(windmn)
                          endif
                          if( k == im) then
                             ! in the case range='i' and with not much initial
                             ! accuracy in lambda and vu, the formula
                             ! can lead to an overestimation of the right gap and
                             ! thus to inadequately early rqi 'convergence'.
                             ! prevent this by forcing a small right gap.
                             rgap = eps*max(abs(left),abs(right))
                          else
                             rgap = wgap(windex)
                          endif
                          gap = min( lgap, rgap )
                          if(( k == 1).or.(k == im)) then
                             ! the eigenvector support can become wrong
                             ! because significant entries could be cut off due to a
                             ! large gaptol parameter in lar1v. prevent this.
                             gaptol = zero
                          else
                             gaptol = gap * eps
                          endif
                          isupmn = in
                          isupmx = 1
                          ! update wgap so that it holds the minimum gap
                          ! to the left or the right. this is crucial in the
                          ! case where bisection is used to ensure that the
                          ! eigenvalue is refined up to the required precision.
                          ! the correct value is restored afterwards.
                          savgap = wgap(windex)
                          wgap(windex) = gap
                          ! we want to use the rayleigh quotient correction
                          ! as often as possible since it converges quadratically
                          ! when we are close enough to the desired eigenvalue.
                          ! however, the rayleigh quotient can have the wrong sign
                          ! and lead us away from the desired eigenvalue. in this
                          ! case, the best we can do is to use bisection.
                          usedbs = .false.
                          usedrq = .false.
                          ! bisection is initially turned off unless it is forced
                          needbs =  .not.tryrqc
                          120 continue
                          ! check if bisection should be used to refine eigenvalue
                          if(needbs) then
                             ! take the bisection as new iterate
                             usedbs = .true.
                             itmp1 = iwork( iindr+windex )
                             offset = indexw( wbegin ) - 1
                             call stdlib_dlarrb( in, d(ibegin),work(indlld+ibegin-1),indeig,&
                             indeig,zero, two*eps, offset,work(wbegin),wgap(wbegin),werr(wbegin),&
                                       work( indwrk ),iwork( iindwk ), pivmin, spdiam,itmp1, iinfo )
                             if( iinfo/=0 ) then
                                info = -3
                                return
                             endif
                             lambda = work( windex )
                             ! reset twist index from inaccurate lambda to
                             ! force computation of true mingma
                             iwork( iindr+windex ) = 0
                          endif
                          ! given lambda, compute the eigenvector.
                          call stdlib_dlar1v( in, 1, in, lambda, d( ibegin ),l( ibegin ), work(&
                          indld+ibegin-1),work(indlld+ibegin-1),pivmin, gaptol, z( ibegin, windex &
                          ),.not.usedbs, negcnt, ztz, mingma,iwork( iindr+windex ), isuppz( &
                                    2*windex-1 ),nrminv, resid, rqcorr, work( indwrk ) )
                          if(iter == 0) then
                             bstres = resid
                             bstw = lambda
                          elseif(resid<bstres) then
                             bstres = resid
                             bstw = lambda
                          endif
                          isupmn = min(isupmn,isuppz( 2*windex-1 ))
                          isupmx = max(isupmx,isuppz( 2*windex ))
                          iter = iter + 1
                          ! sin alpha <= |resid|/gap
                          ! note that both the residual and the gap are
                          ! proportional to the matrix, so ||t|| doesn't play
                          ! a role in the quotient
                          ! convergence test for rayleigh-quotient iteration
                          ! (omitted when bisection has been used)
                          if( resid>tol*gap .and. abs( rqcorr )>rqtol*abs( lambda ) .and. .not. &
                                    usedbs)then
                             ! we need to check that the rqcorr update doesn't
                             ! move the eigenvalue away from the desired one and
                             ! towards a neighbor. -> protection with bisection
                             if(indeig<=negcnt) then
                                ! the wanted eigenvalue lies to the left
                                sgndef = -one
                             else
                                ! the wanted eigenvalue lies to the right
                                sgndef = one
                             endif
                             ! we only use the rqcorr if it improves the
                             ! the iterate reasonably.
                             if( ( rqcorr*sgndef>=zero ).and.( lambda + rqcorr<= right).and.( &
                                       lambda + rqcorr>= left)) then
                                usedrq = .true.
                                ! store new midpoint of bisection interval in work
                                if(sgndef==one) then
                                   ! the current lambda is on the left of the true
                                   ! eigenvalue
                                   left = lambda
                                   ! we prefer to assume that the error estimate
                                   ! is correct. we could make the interval not
                                   ! as a bracket but to be modified if the rqcorr
                                   ! chooses to. in this case, the right side should
                                   ! be modified as follows:
                                    ! right = max(right, lambda + rqcorr)
                                else
                                   ! the current lambda is on the right of the true
                                   ! eigenvalue
                                   right = lambda
                                   ! see comment about assuming the error estimate is
                                   ! correct above.
                                    ! left = min(left, lambda + rqcorr)
                                endif
                                work( windex ) =half * (right + left)
                                ! take rqcorr since it has the correct sign and
                                ! improves the iterate reasonably
                                lambda = lambda + rqcorr
                                ! update width of error interval
                                werr( windex ) =half * (right-left)
                             else
                                needbs = .true.
                             endif
                             if(right-left<rqtol*abs(lambda)) then
                                   ! the eigenvalue is computed to bisection accuracy
                                   ! compute eigenvector and stop
                                usedbs = .true.
                                goto 120
                             elseif( iter<maxitr ) then
                                goto 120
                             elseif( iter==maxitr ) then
                                needbs = .true.
                                goto 120
                             else
                                info = 5
                                return
                             end if
                          else
                             stp2ii = .false.
             if(usedrq .and. usedbs .and.bstres<=resid) then
                                lambda = bstw
                                stp2ii = .true.
                             endif
                             if (stp2ii) then
                                ! improve error angle by second step
                                call stdlib_dlar1v( in, 1, in, lambda,d( ibegin ), l( ibegin ),&
                                work(indld+ibegin-1),work(indlld+ibegin-1),pivmin, gaptol, z( &
                                ibegin, windex ),.not.usedbs, negcnt, ztz, mingma,iwork( iindr+&
                                windex ),isuppz( 2*windex-1 ),nrminv, resid, rqcorr, work( indwrk &
                                          ) )
                             endif
                             work( windex ) = lambda
                          end if
                          ! compute fp-vector support w.r.t. whole matrix
                          isuppz( 2*windex-1 ) = isuppz( 2*windex-1 )+oldien
                          isuppz( 2*windex ) = isuppz( 2*windex )+oldien
                          zfrom = isuppz( 2*windex-1 )
                          zto = isuppz( 2*windex )
                          isupmn = isupmn + oldien
                          isupmx = isupmx + oldien
                          ! ensure vector is ok if support in the rqi has changed
                          if(isupmn<zfrom) then
                             do ii = isupmn,zfrom-1
                                z( ii, windex ) = zero
                             end do
                          endif
                          if(isupmx>zto) then
                             do ii = zto+1,isupmx
                                z( ii, windex ) = zero
                             end do
                          endif
                          call stdlib_dscal( zto-zfrom+1, nrminv,z( zfrom, windex ), 1 )
                          125 continue
                          ! update w
                          w( windex ) = lambda+sigma
                          ! recompute the gaps on the left and right
                          ! but only allow them to become larger and not
                          ! smaller (which can only happen through "bad"
                          ! cancellation and doesn't reflect the theory
                          ! where the initial gaps are underestimated due
                          ! to werr being too crude.)
                          if(.not.eskip) then
                             if( k>1) then
                                wgap( windmn ) = max( wgap(windmn),w(windex)-werr(windex)- w(&
                                          windmn)-werr(windmn) )
                             endif
                             if( windex<wend ) then
                                wgap( windex ) = max( savgap,w( windpl )-werr( windpl )- w( &
                                          windex )-werr( windex) )
                             endif
                          endif
                          idone = idone + 1
                       endif
                       ! here ends the code for the current child
                       139 continue
                       ! proceed to any remaining child nodes
                       newfst = j + 1
                    end do loop_140
                 end do loop_150
                 ndepth = ndepth + 1
                 go to 40
              end if
              ibegin = iend + 1
              wbegin = wend + 1
           end do loop_170
           return
     end subroutine stdlib_dlarrv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$larrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
     !! DLARRV: computes the eigenvectors of the tridiagonal matrix
     !! T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.
     !! The input eigenvalues should have been computed by DLARRE.
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: dol, dou, ldz, m, n
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(in) :: minrgp, pivmin, vl, vu
           real(${rk}$), intent(inout) :: rtol1, rtol2
           ! Array Arguments 
           integer(ilp), intent(in) :: iblock(*), indexw(*), isplit(*)
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), l(*), w(*), werr(*), wgap(*)
           real(${rk}$), intent(in) :: gers(*)
           real(${rk}$), intent(out) :: work(*)
           real(${rk}$), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxitr = 10
           
           
           ! Local Scalars 
           logical(lk) :: eskip, needbs, stp2ii, tryrqc, usedbs, usedrq
           integer(ilp) :: done, i, ibegin, idone, iend, ii, iindc1, iindc2, iindr, iindwk, iinfo,&
            im, in, indeig, indld, indlld, indwrk, isupmn, isupmx, iter, itmp1, j, jblk, k, &
            miniwsize, minwsize, nclus, ndepth, negcnt, newcls, newfst, newftt, newlst, newsiz, &
            offset, oldcls, oldfst, oldien, oldlst, oldncl, p, parity, q, wbegin, wend, windex, &
                      windmn, windpl, zfrom, zto, zusedl, zusedu, zusedw
           real(${rk}$) :: bstres, bstw, eps, fudge, gap, gaptol, gl, gu, lambda, left, lgap, mingma, &
           nrminv, resid, rgap, right, rqcorr, rqtol, savgap, sgndef, sigma, spdiam, ssigma, tau, &
                     tmp, tol, ztz
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( (n<=0).or.(m<=0) ) then
              return
           end if
           ! the first n entries of work are reserved for the eigenvalues
           indld = n+1
           indlld= 2*n+1
           indwrk= 3*n+1
           minwsize = 12 * n
           do i= 1,minwsize
              work( i ) = zero
           end do
           ! iwork(iindr+1:iindr+n) hold the twist indices r for the
           ! factorization used to compute the fp vector
           iindr = 0
           ! iwork(iindc1+1:iinc2+n) are used to store the clusters of the current
           ! layer and the one above.
           iindc1 = n
           iindc2 = 2*n
           iindwk = 3*n + 1
           miniwsize = 7 * n
           do i= 1,miniwsize
              iwork( i ) = 0
           end do
           zusedl = 1
           if(dol>1) then
              ! set lower bound for use of z
              zusedl = dol-1
           endif
           zusedu = m
           if(dou<m) then
              ! set lower bound for use of z
              zusedu = dou+1
           endif
           ! the width of the part of z that is used
           zusedw = zusedu - zusedl + 1
           call stdlib_${ri}$laset( 'FULL', n, zusedw, zero, zero,z(1,zusedl), ldz )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           rqtol = two * eps
           ! set expert flags for standard code.
           tryrqc = .true.
           if((dol==1).and.(dou==m)) then
           else
              ! only selected eigenpairs are computed. since the other evalues
              ! are not refined by rq iteration, bisection has to compute to full
              ! accuracy.
              rtol1 = four * eps
              rtol2 = four * eps
           endif
           ! the entries wbegin:wend in w, werr, wgap correspond to the
           ! desired eigenvalues. the support of the nonzero eigenvector
           ! entries is contained in the interval ibegin:iend.
           ! remark that if k eigenpairs are desired, then the eigenvectors
           ! are stored in k contiguous columns of z.
           ! done is the number of eigenvectors already computed
           done = 0
           ibegin = 1
           wbegin = 1
           loop_170: do jblk = 1, iblock( m )
              iend = isplit( jblk )
              sigma = l( iend )
              ! find the eigenvectors of the submatrix indexed ibegin
              ! through iend.
              wend = wbegin - 1
              15 continue
              if( wend<m ) then
                 if( iblock( wend+1 )==jblk ) then
                    wend = wend + 1
                    go to 15
                 end if
              end if
              if( wend<wbegin ) then
                 ibegin = iend + 1
                 cycle loop_170
              elseif( (wend<dol).or.(wbegin>dou) ) then
                 ibegin = iend + 1
                 wbegin = wend + 1
                 cycle loop_170
              end if
              ! find local spectral diameter of the block
              gl = gers( 2*ibegin-1 )
              gu = gers( 2*ibegin )
              do i = ibegin+1 , iend
                 gl = min( gers( 2*i-1 ), gl )
                 gu = max( gers( 2*i ), gu )
              end do
              spdiam = gu - gl
              ! oldien is the last index of the previous block
              oldien = ibegin - 1
              ! calculate the size of the current block
              in = iend - ibegin + 1
              ! the number of eigenvalues in the current block
              im = wend - wbegin + 1
              ! this is for a 1x1 block
              if( ibegin==iend ) then
                 done = done+1
                 z( ibegin, wbegin ) = one
                 isuppz( 2*wbegin-1 ) = ibegin
                 isuppz( 2*wbegin ) = ibegin
                 w( wbegin ) = w( wbegin ) + sigma
                 work( wbegin ) = w( wbegin )
                 ibegin = iend + 1
                 wbegin = wbegin + 1
                 cycle loop_170
              end if
              ! the desired (shifted) eigenvalues are stored in w(wbegin:wend)
              ! note that these can be approximations, in this case, the corresp.
              ! entries of werr give the size of the uncertainty interval.
              ! the eigenvalue approximations will be refined when necessary as
              ! high relative accuracy is required for the computation of the
              ! corresponding eigenvectors.
              call stdlib_${ri}$copy( im, w( wbegin ), 1,work( wbegin ), 1 )
              ! we store in w the eigenvalue approximations w.r.t. the original
              ! matrix t.
              do i=1,im
                 w(wbegin+i-1) = w(wbegin+i-1)+sigma
              end do
              ! ndepth is the current depth of the representation tree
              ndepth = 0
              ! parity is either 1 or 0
              parity = 1
              ! nclus is the number of clusters for the next level of the
              ! representation tree, we start with nclus = 1 for the root
              nclus = 1
              iwork( iindc1+1 ) = 1
              iwork( iindc1+2 ) = im
              ! idone is the number of eigenvectors already computed in the current
              ! block
              idone = 0
              ! loop while( idone<im )
              ! generate the representation tree for the current block and
              ! compute the eigenvectors
              40 continue
              if( idone<im ) then
                 ! this is a crude protection against infinitely deep trees
                 if( ndepth>m ) then
                    info = -2
                    return
                 endif
                 ! breadth first processing of the current level of the representation
                 ! tree: oldncl = number of clusters on current level
                 oldncl = nclus
                 ! reset nclus to count the number of child clusters
                 nclus = 0
                 parity = 1 - parity
                 if( parity==0 ) then
                    oldcls = iindc1
                    newcls = iindc2
                 else
                    oldcls = iindc2
                    newcls = iindc1
                 end if
                 ! process the clusters on the current level
                 loop_150: do i = 1, oldncl
                    j = oldcls + 2*i
                    ! oldfst, oldlst = first, last index of current cluster.
                                     ! cluster indices start with 1 and are relative
                                     ! to wbegin when accessing w, wgap, werr, z
                    oldfst = iwork( j-1 )
                    oldlst = iwork( j )
                    if( ndepth>0 ) then
                       ! retrieve relatively robust representation (rrr) of cluster
                       ! that has been computed at the previous level
                       ! the rrr is stored in z and overwritten once the eigenvectors
                       ! have been computed or when the cluster is refined
                       if((dol==1).and.(dou==m)) then
                          ! get representation from location of the leftmost evalue
                          ! of the cluster
                          j = wbegin + oldfst - 1
                       else
                          if(wbegin+oldfst-1<dol) then
                             ! get representation from the left end of z array
                             j = dol - 1
                          elseif(wbegin+oldfst-1>dou) then
                             ! get representation from the right end of z array
                             j = dou
                          else
                             j = wbegin + oldfst - 1
                          endif
                       endif
                       call stdlib_${ri}$copy( in, z( ibegin, j ), 1, d( ibegin ), 1 )
                       call stdlib_${ri}$copy( in-1, z( ibegin, j+1 ), 1, l( ibegin ),1 )
                       sigma = z( iend, j+1 )
                       ! set the corresponding entries in z to zero
                       call stdlib_${ri}$laset( 'FULL', in, 2, zero, zero,z( ibegin, j), ldz )
                    end if
                    ! compute dl and dll of current rrr
                    do j = ibegin, iend-1
                       tmp = d( j )*l( j )
                       work( indld-1+j ) = tmp
                       work( indlld-1+j ) = tmp*l( j )
                    end do
                    if( ndepth>0 ) then
                       ! p and q are index of the first and last eigenvalue to compute
                       ! within the current block
                       p = indexw( wbegin-1+oldfst )
                       q = indexw( wbegin-1+oldlst )
                       ! offset for the arrays work, wgap and werr, i.e., the p-offset
                       ! through the q-offset elements of these arrays are to be used.
                        ! offset = p-oldfst
                       offset = indexw( wbegin ) - 1
                       ! perform limited bisection (if necessary) to get approximate
                       ! eigenvalues to the precision needed.
                       call stdlib_${ri}$larrb( in, d( ibegin ),work(indlld+ibegin-1),p, q, rtol1, &
                       rtol2, offset,work(wbegin),wgap(wbegin),werr(wbegin),work( indwrk ), iwork(&
                                  iindwk ),pivmin, spdiam, in, iinfo )
                       if( iinfo/=0 ) then
                          info = -1
                          return
                       endif
                       ! we also recompute the extremal gaps. w holds all eigenvalues
                       ! of the unshifted matrix and must be used for computation
                       ! of wgap, the entries of work might stem from rrrs with
                       ! different shifts. the gaps from wbegin-1+oldfst to
                       ! wbegin-1+oldlst are correctly computed in stdlib_${ri}$larrb.
                       ! however, we only allow the gaps to become greater since
                       ! this is what should happen when we decrease werr
                       if( oldfst>1) then
                          wgap( wbegin+oldfst-2 ) =max(wgap(wbegin+oldfst-2),w(wbegin+oldfst-1)-&
                          werr(wbegin+oldfst-1)- w(wbegin+oldfst-2)-werr(wbegin+oldfst-2) )
                                    
                       endif
                       if( wbegin + oldlst -1 < wend ) then
                          wgap( wbegin+oldlst-1 ) =max(wgap(wbegin+oldlst-1),w(wbegin+oldlst)-&
                                    werr(wbegin+oldlst)- w(wbegin+oldlst-1)-werr(wbegin+oldlst-1) )
                       endif
                       ! each time the eigenvalues in work get refined, we store
                       ! the newly found approximation with all shifts applied in w
                       do j=oldfst,oldlst
                          w(wbegin+j-1) = work(wbegin+j-1)+sigma
                       end do
                    end if
                    ! process the current node.
                    newfst = oldfst
                    loop_140: do j = oldfst, oldlst
                       if( j==oldlst ) then
                          ! we are at the right end of the cluster, this is also the
                          ! boundary of the child cluster
                          newlst = j
                       else if ( wgap( wbegin + j -1)>=minrgp* abs( work(wbegin + j -1) ) ) &
                                 then
                          ! the right relative gap is big enough, the child cluster
                          ! (newfst,..,newlst) is well separated from the following
                          newlst = j
                        else
                          ! inside a child cluster, the relative gap is not
                          ! big enough.
                          cycle loop_140
                       end if
                       ! compute size of child cluster found
                       newsiz = newlst - newfst + 1
                       ! newftt is the place in z where the new rrr or the computed
                       ! eigenvector is to be stored
                       if((dol==1).and.(dou==m)) then
                          ! store representation at location of the leftmost evalue
                          ! of the cluster
                          newftt = wbegin + newfst - 1
                       else
                          if(wbegin+newfst-1<dol) then
                             ! store representation at the left end of z array
                             newftt = dol - 1
                          elseif(wbegin+newfst-1>dou) then
                             ! store representation at the right end of z array
                             newftt = dou
                          else
                             newftt = wbegin + newfst - 1
                          endif
                       endif
                       if( newsiz>1) then
                          ! current child is not a singleton but a cluster.
                          ! compute and store new representation of child.
                          ! compute left and right cluster gap.
                          ! lgap and rgap are not computed from work because
                          ! the eigenvalue approximations may stem from rrrs
                          ! different shifts. however, w hold all eigenvalues
                          ! of the unshifted matrix. still, the entries in wgap
                          ! have to be computed from work since the entries
                          ! in w might be of the same order so that gaps are not
                          ! exhibited correctly for very close eigenvalues.
                          if( newfst==1 ) then
                             lgap = max( zero,w(wbegin)-werr(wbegin) - vl )
                         else
                             lgap = wgap( wbegin+newfst-2 )
                          endif
                          rgap = wgap( wbegin+newlst-1 )
                          ! compute left- and rightmost eigenvalue of child
                          ! to high precision in order to shift as close
                          ! as possible and obtain as large relative gaps
                          ! as possible
                          do k =1,2
                             if(k==1) then
                                p = indexw( wbegin-1+newfst )
                             else
                                p = indexw( wbegin-1+newlst )
                             endif
                             offset = indexw( wbegin ) - 1
                             call stdlib_${ri}$larrb( in, d(ibegin),work( indlld+ibegin-1 ),p,p,rqtol, &
                             rqtol, offset,work(wbegin),wgap(wbegin),werr(wbegin),work( indwrk ),&
                                       iwork( iindwk ), pivmin, spdiam,in, iinfo )
                          end do
                          if((wbegin+newlst-1<dol).or.(wbegin+newfst-1>dou)) then
                             ! if the cluster contains no desired eigenvalues
                             ! skip the computation of that branch of the rep. tree
                             ! we could skip before the refinement of the extremal
                             ! eigenvalues of the child, but then the representation
                             ! tree could be different from the one when nothing is
                             ! skipped. for this reason we skip at this place.
                             idone = idone + newlst - newfst + 1
                             goto 139
                          endif
                          ! compute rrr of child cluster.
                          ! note that the new rrr is stored in z
                          ! stdlib_${ri}$larrf needs lwork = 2*n
                          call stdlib_${ri}$larrf( in, d( ibegin ), l( ibegin ),work(indld+ibegin-1),&
                          newfst, newlst, work(wbegin),wgap(wbegin), werr(wbegin),spdiam, lgap, &
                          rgap, pivmin, tau,z(ibegin, newftt),z(ibegin, newftt+1),work( indwrk ), &
                                    iinfo )
                          if( iinfo==0 ) then
                             ! a new rrr for the cluster was found by stdlib_${ri}$larrf
                             ! update shift and store it
                             ssigma = sigma + tau
                             z( iend, newftt+1 ) = ssigma
                             ! work() are the midpoints and werr() the semi-width
                             ! note that the entries in w are unchanged.
                             do k = newfst, newlst
                                fudge =three*eps*abs(work(wbegin+k-1))
                                work( wbegin + k - 1 ) =work( wbegin + k - 1) - tau
                                fudge = fudge +four*eps*abs(work(wbegin+k-1))
                                ! fudge errors
                                werr( wbegin + k - 1 ) =werr( wbegin + k - 1 ) + fudge
                                ! gaps are not fudged. provided that werr is small
                                ! when eigenvalues are close, a zero gap indicates
                                ! that a new representation is needed for resolving
                                ! the cluster. a fudge could lead to a wrong decision
                                ! of judging eigenvalues 'separated' which in
                                ! reality are not. this could have a negative impact
                                ! on the orthogonality of the computed eigenvectors.
                             end do
                             nclus = nclus + 1
                             k = newcls + 2*nclus
                             iwork( k-1 ) = newfst
                             iwork( k ) = newlst
                          else
                             info = -2
                             return
                          endif
                       else
                          ! compute eigenvector of singleton
                          iter = 0
                          tol = four * log(real(in,KIND=${rk}$)) * eps
                          k = newfst
                          windex = wbegin + k - 1
                          windmn = max(windex - 1,1)
                          windpl = min(windex + 1,m)
                          lambda = work( windex )
                          done = done + 1
                          ! check if eigenvector computation is to be skipped
                          if((windex<dol).or.(windex>dou)) then
                             eskip = .true.
                             goto 125
                          else
                             eskip = .false.
                          endif
                          left = work( windex ) - werr( windex )
                          right = work( windex ) + werr( windex )
                          indeig = indexw( windex )
                          ! note that since we compute the eigenpairs for a child,
                          ! all eigenvalue approximations are w.r.t the same shift.
                          ! in this case, the entries in work should be used for
                          ! computing the gaps since they exhibit even very small
                          ! differences in the eigenvalues, as opposed to the
                          ! entries in w which might "look" the same.
                          if( k == 1) then
                             ! in the case range='i' and with not much initial
                             ! accuracy in lambda and vl, the formula
                             ! lgap = max( zero, (sigma - vl) + lambda )
                             ! can lead to an overestimation of the left gap and
                             ! thus to inadequately early rqi 'convergence'.
                             ! prevent this by forcing a small left gap.
                             lgap = eps*max(abs(left),abs(right))
                          else
                             lgap = wgap(windmn)
                          endif
                          if( k == im) then
                             ! in the case range='i' and with not much initial
                             ! accuracy in lambda and vu, the formula
                             ! can lead to an overestimation of the right gap and
                             ! thus to inadequately early rqi 'convergence'.
                             ! prevent this by forcing a small right gap.
                             rgap = eps*max(abs(left),abs(right))
                          else
                             rgap = wgap(windex)
                          endif
                          gap = min( lgap, rgap )
                          if(( k == 1).or.(k == im)) then
                             ! the eigenvector support can become wrong
                             ! because significant entries could be cut off due to a
                             ! large gaptol parameter in lar1v. prevent this.
                             gaptol = zero
                          else
                             gaptol = gap * eps
                          endif
                          isupmn = in
                          isupmx = 1
                          ! update wgap so that it holds the minimum gap
                          ! to the left or the right. this is crucial in the
                          ! case where bisection is used to ensure that the
                          ! eigenvalue is refined up to the required precision.
                          ! the correct value is restored afterwards.
                          savgap = wgap(windex)
                          wgap(windex) = gap
                          ! we want to use the rayleigh quotient correction
                          ! as often as possible since it converges quadratically
                          ! when we are close enough to the desired eigenvalue.
                          ! however, the rayleigh quotient can have the wrong sign
                          ! and lead us away from the desired eigenvalue. in this
                          ! case, the best we can do is to use bisection.
                          usedbs = .false.
                          usedrq = .false.
                          ! bisection is initially turned off unless it is forced
                          needbs =  .not.tryrqc
                          120 continue
                          ! check if bisection should be used to refine eigenvalue
                          if(needbs) then
                             ! take the bisection as new iterate
                             usedbs = .true.
                             itmp1 = iwork( iindr+windex )
                             offset = indexw( wbegin ) - 1
                             call stdlib_${ri}$larrb( in, d(ibegin),work(indlld+ibegin-1),indeig,&
                             indeig,zero, two*eps, offset,work(wbegin),wgap(wbegin),werr(wbegin),&
                                       work( indwrk ),iwork( iindwk ), pivmin, spdiam,itmp1, iinfo )
                             if( iinfo/=0 ) then
                                info = -3
                                return
                             endif
                             lambda = work( windex )
                             ! reset twist index from inaccurate lambda to
                             ! force computation of true mingma
                             iwork( iindr+windex ) = 0
                          endif
                          ! given lambda, compute the eigenvector.
                          call stdlib_${ri}$lar1v( in, 1, in, lambda, d( ibegin ),l( ibegin ), work(&
                          indld+ibegin-1),work(indlld+ibegin-1),pivmin, gaptol, z( ibegin, windex &
                          ),.not.usedbs, negcnt, ztz, mingma,iwork( iindr+windex ), isuppz( &
                                    2*windex-1 ),nrminv, resid, rqcorr, work( indwrk ) )
                          if(iter == 0) then
                             bstres = resid
                             bstw = lambda
                          elseif(resid<bstres) then
                             bstres = resid
                             bstw = lambda
                          endif
                          isupmn = min(isupmn,isuppz( 2*windex-1 ))
                          isupmx = max(isupmx,isuppz( 2*windex ))
                          iter = iter + 1
                          ! sin alpha <= |resid|/gap
                          ! note that both the residual and the gap are
                          ! proportional to the matrix, so ||t|| doesn't play
                          ! a role in the quotient
                          ! convergence test for rayleigh-quotient iteration
                          ! (omitted when bisection has been used)
                          if( resid>tol*gap .and. abs( rqcorr )>rqtol*abs( lambda ) .and. .not. &
                                    usedbs)then
                             ! we need to check that the rqcorr update doesn't
                             ! move the eigenvalue away from the desired one and
                             ! towards a neighbor. -> protection with bisection
                             if(indeig<=negcnt) then
                                ! the wanted eigenvalue lies to the left
                                sgndef = -one
                             else
                                ! the wanted eigenvalue lies to the right
                                sgndef = one
                             endif
                             ! we only use the rqcorr if it improves the
                             ! the iterate reasonably.
                             if( ( rqcorr*sgndef>=zero ).and.( lambda + rqcorr<= right).and.( &
                                       lambda + rqcorr>= left)) then
                                usedrq = .true.
                                ! store new midpoint of bisection interval in work
                                if(sgndef==one) then
                                   ! the current lambda is on the left of the true
                                   ! eigenvalue
                                   left = lambda
                                   ! we prefer to assume that the error estimate
                                   ! is correct. we could make the interval not
                                   ! as a bracket but to be modified if the rqcorr
                                   ! chooses to. in this case, the right side should
                                   ! be modified as follows:
                                    ! right = max(right, lambda + rqcorr)
                                else
                                   ! the current lambda is on the right of the true
                                   ! eigenvalue
                                   right = lambda
                                   ! see comment about assuming the error estimate is
                                   ! correct above.
                                    ! left = min(left, lambda + rqcorr)
                                endif
                                work( windex ) =half * (right + left)
                                ! take rqcorr since it has the correct sign and
                                ! improves the iterate reasonably
                                lambda = lambda + rqcorr
                                ! update width of error interval
                                werr( windex ) =half * (right-left)
                             else
                                needbs = .true.
                             endif
                             if(right-left<rqtol*abs(lambda)) then
                                   ! the eigenvalue is computed to bisection accuracy
                                   ! compute eigenvector and stop
                                usedbs = .true.
                                goto 120
                             elseif( iter<maxitr ) then
                                goto 120
                             elseif( iter==maxitr ) then
                                needbs = .true.
                                goto 120
                             else
                                info = 5
                                return
                             end if
                          else
                             stp2ii = .false.
             if(usedrq .and. usedbs .and.bstres<=resid) then
                                lambda = bstw
                                stp2ii = .true.
                             endif
                             if (stp2ii) then
                                ! improve error angle by second step
                                call stdlib_${ri}$lar1v( in, 1, in, lambda,d( ibegin ), l( ibegin ),&
                                work(indld+ibegin-1),work(indlld+ibegin-1),pivmin, gaptol, z( &
                                ibegin, windex ),.not.usedbs, negcnt, ztz, mingma,iwork( iindr+&
                                windex ),isuppz( 2*windex-1 ),nrminv, resid, rqcorr, work( indwrk &
                                          ) )
                             endif
                             work( windex ) = lambda
                          end if
                          ! compute fp-vector support w.r.t. whole matrix
                          isuppz( 2*windex-1 ) = isuppz( 2*windex-1 )+oldien
                          isuppz( 2*windex ) = isuppz( 2*windex )+oldien
                          zfrom = isuppz( 2*windex-1 )
                          zto = isuppz( 2*windex )
                          isupmn = isupmn + oldien
                          isupmx = isupmx + oldien
                          ! ensure vector is ok if support in the rqi has changed
                          if(isupmn<zfrom) then
                             do ii = isupmn,zfrom-1
                                z( ii, windex ) = zero
                             end do
                          endif
                          if(isupmx>zto) then
                             do ii = zto+1,isupmx
                                z( ii, windex ) = zero
                             end do
                          endif
                          call stdlib_${ri}$scal( zto-zfrom+1, nrminv,z( zfrom, windex ), 1 )
                          125 continue
                          ! update w
                          w( windex ) = lambda+sigma
                          ! recompute the gaps on the left and right
                          ! but only allow them to become larger and not
                          ! smaller (which can only happen through "bad"
                          ! cancellation and doesn't reflect the theory
                          ! where the initial gaps are underestimated due
                          ! to werr being too crude.)
                          if(.not.eskip) then
                             if( k>1) then
                                wgap( windmn ) = max( wgap(windmn),w(windex)-werr(windex)- w(&
                                          windmn)-werr(windmn) )
                             endif
                             if( windex<wend ) then
                                wgap( windex ) = max( savgap,w( windpl )-werr( windpl )- w( &
                                          windex )-werr( windex) )
                             endif
                          endif
                          idone = idone + 1
                       endif
                       ! here ends the code for the current child
                       139 continue
                       ! proceed to any remaining child nodes
                       newfst = j + 1
                    end do loop_140
                 end do loop_150
                 ndepth = ndepth + 1
                 go to 40
              end if
              ibegin = iend + 1
              wbegin = wend + 1
           end do loop_170
           return
     end subroutine stdlib_${ri}$larrv

#:endif
#:endfor

     pure subroutine stdlib_clarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
     !! CLARRV computes the eigenvectors of the tridiagonal matrix
     !! T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.
     !! The input eigenvalues should have been computed by SLARRE.
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: dol, dou, ldz, m, n
           integer(ilp), intent(out) :: info
           real(sp), intent(in) :: minrgp, pivmin, vl, vu
           real(sp), intent(inout) :: rtol1, rtol2
           ! Array Arguments 
           integer(ilp), intent(in) :: iblock(*), indexw(*), isplit(*)
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(sp), intent(inout) :: d(*), l(*), w(*), werr(*), wgap(*)
           real(sp), intent(in) :: gers(*)
           real(sp), intent(out) :: work(*)
           complex(sp), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxitr = 10
           
           
           
           ! Local Scalars 
           logical(lk) :: eskip, needbs, stp2ii, tryrqc, usedbs, usedrq
           integer(ilp) :: done, i, ibegin, idone, iend, ii, iindc1, iindc2, iindr, iindwk, iinfo,&
            im, in, indeig, indld, indlld, indwrk, isupmn, isupmx, iter, itmp1, j, jblk, k, &
            miniwsize, minwsize, nclus, ndepth, negcnt, newcls, newfst, newftt, newlst, newsiz, &
            offset, oldcls, oldfst, oldien, oldlst, oldncl, p, parity, q, wbegin, wend, windex, &
                      windmn, windpl, zfrom, zto, zusedl, zusedu, zusedw
           integer(ilp) :: indin1, indin2
           real(sp) :: bstres, bstw, eps, fudge, gap, gaptol, gl, gu, lambda, left, lgap, mingma, &
           nrminv, resid, rgap, right, rqcorr, rqtol, savgap, sgndef, sigma, spdiam, ssigma, tau, &
                     tmp, tol, ztz
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( (n<=0).or.(m<=0) ) then
              return
           end if
           ! the first n entries of work are reserved for the eigenvalues
           indld = n+1
           indlld= 2*n+1
           indin1 = 3*n + 1
           indin2 = 4*n + 1
           indwrk = 5*n + 1
           minwsize = 12 * n
           do i= 1,minwsize
              work( i ) = zero
           end do
           ! iwork(iindr+1:iindr+n) hold the twist indices r for the
           ! factorization used to compute the fp vector
           iindr = 0
           ! iwork(iindc1+1:iinc2+n) are used to store the clusters of the current
           ! layer and the one above.
           iindc1 = n
           iindc2 = 2*n
           iindwk = 3*n + 1
           miniwsize = 7 * n
           do i= 1,miniwsize
              iwork( i ) = 0
           end do
           zusedl = 1
           if(dol>1) then
              ! set lower bound for use of z
              zusedl = dol-1
           endif
           zusedu = m
           if(dou<m) then
              ! set lower bound for use of z
              zusedu = dou+1
           endif
           ! the width of the part of z that is used
           zusedw = zusedu - zusedl + 1
           call stdlib_claset( 'FULL', n, zusedw, czero, czero,z(1,zusedl), ldz )
           eps = stdlib_slamch( 'PRECISION' )
           rqtol = two * eps
           ! set expert flags for standard code.
           tryrqc = .true.
           if((dol==1).and.(dou==m)) then
           else
              ! only selected eigenpairs are computed. since the other evalues
              ! are not refined by rq iteration, bisection has to compute to full
              ! accuracy.
              rtol1 = four * eps
              rtol2 = four * eps
           endif
           ! the entries wbegin:wend in w, werr, wgap correspond to the
           ! desired eigenvalues. the support of the nonzero eigenvector
           ! entries is contained in the interval ibegin:iend.
           ! remark that if k eigenpairs are desired, then the eigenvectors
           ! are stored in k contiguous columns of z.
           ! done is the number of eigenvectors already computed
           done = 0
           ibegin = 1
           wbegin = 1
           loop_170: do jblk = 1, iblock( m )
              iend = isplit( jblk )
              sigma = l( iend )
              ! find the eigenvectors of the submatrix indexed ibegin
              ! through iend.
              wend = wbegin - 1
              15 continue
              if( wend<m ) then
                 if( iblock( wend+1 )==jblk ) then
                    wend = wend + 1
                    go to 15
                 end if
              end if
              if( wend<wbegin ) then
                 ibegin = iend + 1
                 cycle loop_170
              elseif( (wend<dol).or.(wbegin>dou) ) then
                 ibegin = iend + 1
                 wbegin = wend + 1
                 cycle loop_170
              end if
              ! find local spectral diameter of the block
              gl = gers( 2*ibegin-1 )
              gu = gers( 2*ibegin )
              do i = ibegin+1 , iend
                 gl = min( gers( 2*i-1 ), gl )
                 gu = max( gers( 2*i ), gu )
              end do
              spdiam = gu - gl
              ! oldien is the last index of the previous block
              oldien = ibegin - 1
              ! calculate the size of the current block
              in = iend - ibegin + 1
              ! the number of eigenvalues in the current block
              im = wend - wbegin + 1
              ! this is for a 1x1 block
              if( ibegin==iend ) then
                 done = done+1
                 z( ibegin, wbegin ) = cmplx( one, zero,KIND=sp)
                 isuppz( 2*wbegin-1 ) = ibegin
                 isuppz( 2*wbegin ) = ibegin
                 w( wbegin ) = w( wbegin ) + sigma
                 work( wbegin ) = w( wbegin )
                 ibegin = iend + 1
                 wbegin = wbegin + 1
                 cycle loop_170
              end if
              ! the desired (shifted) eigenvalues are stored in w(wbegin:wend)
              ! note that these can be approximations, in this case, the corresp.
              ! entries of werr give the size of the uncertainty interval.
              ! the eigenvalue approximations will be refined when necessary as
              ! high relative accuracy is required for the computation of the
              ! corresponding eigenvectors.
              call stdlib_scopy( im, w( wbegin ), 1,work( wbegin ), 1 )
              ! we store in w the eigenvalue approximations w.r.t. the original
              ! matrix t.
              do i=1,im
                 w(wbegin+i-1) = w(wbegin+i-1)+sigma
              end do
              ! ndepth is the current depth of the representation tree
              ndepth = 0
              ! parity is either 1 or 0
              parity = 1
              ! nclus is the number of clusters for the next level of the
              ! representation tree, we start with nclus = 1 for the root
              nclus = 1
              iwork( iindc1+1 ) = 1
              iwork( iindc1+2 ) = im
              ! idone is the number of eigenvectors already computed in the current
              ! block
              idone = 0
              ! loop while( idone<im )
              ! generate the representation tree for the current block and
              ! compute the eigenvectors
              40 continue
              if( idone<im ) then
                 ! this is a crude protection against infinitely deep trees
                 if( ndepth>m ) then
                    info = -2
                    return
                 endif
                 ! breadth first processing of the current level of the representation
                 ! tree: oldncl = number of clusters on current level
                 oldncl = nclus
                 ! reset nclus to count the number of child clusters
                 nclus = 0
                 parity = 1 - parity
                 if( parity==0 ) then
                    oldcls = iindc1
                    newcls = iindc2
                 else
                    oldcls = iindc2
                    newcls = iindc1
                 end if
                 ! process the clusters on the current level
                 loop_150: do i = 1, oldncl
                    j = oldcls + 2*i
                    ! oldfst, oldlst = first, last index of current cluster.
                                     ! cluster indices start with 1 and are relative
                                     ! to wbegin when accessing w, wgap, werr, z
                    oldfst = iwork( j-1 )
                    oldlst = iwork( j )
                    if( ndepth>0 ) then
                       ! retrieve relatively robust representation (rrr) of cluster
                       ! that has been computed at the previous level
                       ! the rrr is stored in z and overwritten once the eigenvectors
                       ! have been computed or when the cluster is refined
                       if((dol==1).and.(dou==m)) then
                          ! get representation from location of the leftmost evalue
                          ! of the cluster
                          j = wbegin + oldfst - 1
                       else
                          if(wbegin+oldfst-1<dol) then
                             ! get representation from the left end of z array
                             j = dol - 1
                          elseif(wbegin+oldfst-1>dou) then
                             ! get representation from the right end of z array
                             j = dou
                          else
                             j = wbegin + oldfst - 1
                          endif
                       endif
                       do k = 1, in - 1
                          d( ibegin+k-1 ) = real( z( ibegin+k-1,j ),KIND=sp)
                          l( ibegin+k-1 ) = real( z( ibegin+k-1,j+1 ),KIND=sp)
                       end do
                       d( iend ) = real( z( iend, j ),KIND=sp)
                       sigma = real( z( iend, j+1 ),KIND=sp)
                       ! set the corresponding entries in z to zero
                       call stdlib_claset( 'FULL', in, 2, czero, czero,z( ibegin, j), ldz )
                                 
                    end if
                    ! compute dl and dll of current rrr
                    do j = ibegin, iend-1
                       tmp = d( j )*l( j )
                       work( indld-1+j ) = tmp
                       work( indlld-1+j ) = tmp*l( j )
                    end do
                    if( ndepth>0 ) then
                       ! p and q are index of the first and last eigenvalue to compute
                       ! within the current block
                       p = indexw( wbegin-1+oldfst )
                       q = indexw( wbegin-1+oldlst )
                       ! offset for the arrays work, wgap and werr, i.e., the p-offset
                       ! through the q-offset elements of these arrays are to be used.
                        ! offset = p-oldfst
                       offset = indexw( wbegin ) - 1
                       ! perform limited bisection (if necessary) to get approximate
                       ! eigenvalues to the precision needed.
                       call stdlib_slarrb( in, d( ibegin ),work(indlld+ibegin-1),p, q, rtol1, &
                       rtol2, offset,work(wbegin),wgap(wbegin),werr(wbegin),work( indwrk ), iwork(&
                                  iindwk ),pivmin, spdiam, in, iinfo )
                       if( iinfo/=0 ) then
                          info = -1
                          return
                       endif
                       ! we also recompute the extremal gaps. w holds all eigenvalues
                       ! of the unshifted matrix and must be used for computation
                       ! of wgap, the entries of work might stem from rrrs with
                       ! different shifts. the gaps from wbegin-1+oldfst to
                       ! wbegin-1+oldlst are correctly computed in stdlib_slarrb.
                       ! however, we only allow the gaps to become greater since
                       ! this is what should happen when we decrease werr
                       if( oldfst>1) then
                          wgap( wbegin+oldfst-2 ) =max(wgap(wbegin+oldfst-2),w(wbegin+oldfst-1)-&
                          werr(wbegin+oldfst-1)- w(wbegin+oldfst-2)-werr(wbegin+oldfst-2) )
                                    
                       endif
                       if( wbegin + oldlst -1 < wend ) then
                          wgap( wbegin+oldlst-1 ) =max(wgap(wbegin+oldlst-1),w(wbegin+oldlst)-&
                                    werr(wbegin+oldlst)- w(wbegin+oldlst-1)-werr(wbegin+oldlst-1) )
                       endif
                       ! each time the eigenvalues in work get refined, we store
                       ! the newly found approximation with all shifts applied in w
                       do j=oldfst,oldlst
                          w(wbegin+j-1) = work(wbegin+j-1)+sigma
                       end do
                    end if
                    ! process the current node.
                    newfst = oldfst
                    loop_140: do j = oldfst, oldlst
                       if( j==oldlst ) then
                          ! we are at the right end of the cluster, this is also the
                          ! boundary of the child cluster
                          newlst = j
                       else if ( wgap( wbegin + j -1)>=minrgp* abs( work(wbegin + j -1) ) ) &
                                 then
                          ! the right relative gap is big enough, the child cluster
                          ! (newfst,..,newlst) is well separated from the following
                          newlst = j
                        else
                          ! inside a child cluster, the relative gap is not
                          ! big enough.
                          cycle loop_140
                       end if
                       ! compute size of child cluster found
                       newsiz = newlst - newfst + 1
                       ! newftt is the place in z where the new rrr or the computed
                       ! eigenvector is to be stored
                       if((dol==1).and.(dou==m)) then
                          ! store representation at location of the leftmost evalue
                          ! of the cluster
                          newftt = wbegin + newfst - 1
                       else
                          if(wbegin+newfst-1<dol) then
                             ! store representation at the left end of z array
                             newftt = dol - 1
                          elseif(wbegin+newfst-1>dou) then
                             ! store representation at the right end of z array
                             newftt = dou
                          else
                             newftt = wbegin + newfst - 1
                          endif
                       endif
                       if( newsiz>1) then
                          ! current child is not a singleton but a cluster.
                          ! compute and store new representation of child.
                          ! compute left and right cluster gap.
                          ! lgap and rgap are not computed from work because
                          ! the eigenvalue approximations may stem from rrrs
                          ! different shifts. however, w hold all eigenvalues
                          ! of the unshifted matrix. still, the entries in wgap
                          ! have to be computed from work since the entries
                          ! in w might be of the same order so that gaps are not
                          ! exhibited correctly for very close eigenvalues.
                          if( newfst==1 ) then
                             lgap = max( zero,w(wbegin)-werr(wbegin) - vl )
                         else
                             lgap = wgap( wbegin+newfst-2 )
                          endif
                          rgap = wgap( wbegin+newlst-1 )
                          ! compute left- and rightmost eigenvalue of child
                          ! to high precision in order to shift as close
                          ! as possible and obtain as large relative gaps
                          ! as possible
                          do k =1,2
                             if(k==1) then
                                p = indexw( wbegin-1+newfst )
                             else
                                p = indexw( wbegin-1+newlst )
                             endif
                             offset = indexw( wbegin ) - 1
                             call stdlib_slarrb( in, d(ibegin),work( indlld+ibegin-1 ),p,p,rqtol, &
                             rqtol, offset,work(wbegin),wgap(wbegin),werr(wbegin),work( indwrk ),&
                                       iwork( iindwk ), pivmin, spdiam,in, iinfo )
                          end do
                          if((wbegin+newlst-1<dol).or.(wbegin+newfst-1>dou)) then
                             ! if the cluster contains no desired eigenvalues
                             ! skip the computation of that branch of the rep. tree
                             ! we could skip before the refinement of the extremal
                             ! eigenvalues of the child, but then the representation
                             ! tree could be different from the one when nothing is
                             ! skipped. for this reason we skip at this place.
                             idone = idone + newlst - newfst + 1
                             goto 139
                          endif
                          ! compute rrr of child cluster.
                          ! note that the new rrr is stored in z
                          ! stdlib_slarrf needs lwork = 2*n
                          call stdlib_slarrf( in, d( ibegin ), l( ibegin ),work(indld+ibegin-1),&
                          newfst, newlst, work(wbegin),wgap(wbegin), werr(wbegin),spdiam, lgap, &
                          rgap, pivmin, tau,work( indin1 ), work( indin2 ),work( indwrk ), iinfo )
                                    
                          ! in the complex case, stdlib_slarrf cannot write
                          ! the new rrr directly into z and needs an intermediate
                          ! workspace
                          do k = 1, in-1
                             z( ibegin+k-1, newftt ) =cmplx( work( indin1+k-1 ), zero,KIND=sp)
                                       
                             z( ibegin+k-1, newftt+1 ) =cmplx( work( indin2+k-1 ), zero,KIND=sp)
                                       
                          end do
                          z( iend, newftt ) =cmplx( work( indin1+in-1 ), zero,KIND=sp)
                          if( iinfo==0 ) then
                             ! a new rrr for the cluster was found by stdlib_slarrf
                             ! update shift and store it
                             ssigma = sigma + tau
                             z( iend, newftt+1 ) = cmplx( ssigma, zero,KIND=sp)
                             ! work() are the midpoints and werr() the semi-width
                             ! note that the entries in w are unchanged.
                             do k = newfst, newlst
                                fudge =three*eps*abs(work(wbegin+k-1))
                                work( wbegin + k - 1 ) =work( wbegin + k - 1) - tau
                                fudge = fudge +four*eps*abs(work(wbegin+k-1))
                                ! fudge errors
                                werr( wbegin + k - 1 ) =werr( wbegin + k - 1 ) + fudge
                                ! gaps are not fudged. provided that werr is small
                                ! when eigenvalues are close, a zero gap indicates
                                ! that a new representation is needed for resolving
                                ! the cluster. a fudge could lead to a wrong decision
                                ! of judging eigenvalues 'separated' which in
                                ! reality are not. this could have a negative impact
                                ! on the orthogonality of the computed eigenvectors.
                             end do
                             nclus = nclus + 1
                             k = newcls + 2*nclus
                             iwork( k-1 ) = newfst
                             iwork( k ) = newlst
                          else
                             info = -2
                             return
                          endif
                       else
                          ! compute eigenvector of singleton
                          iter = 0
                          tol = four * log(real(in,KIND=sp)) * eps
                          k = newfst
                          windex = wbegin + k - 1
                          windmn = max(windex - 1,1)
                          windpl = min(windex + 1,m)
                          lambda = work( windex )
                          done = done + 1
                          ! check if eigenvector computation is to be skipped
                          if((windex<dol).or.(windex>dou)) then
                             eskip = .true.
                             goto 125
                          else
                             eskip = .false.
                          endif
                          left = work( windex ) - werr( windex )
                          right = work( windex ) + werr( windex )
                          indeig = indexw( windex )
                          ! note that since we compute the eigenpairs for a child,
                          ! all eigenvalue approximations are w.r.t the same shift.
                          ! in this case, the entries in work should be used for
                          ! computing the gaps since they exhibit even very small
                          ! differences in the eigenvalues, as opposed to the
                          ! entries in w which might "look" the same.
                          if( k == 1) then
                             ! in the case range='i' and with not much initial
                             ! accuracy in lambda and vl, the formula
                             ! lgap = max( zero, (sigma - vl) + lambda )
                             ! can lead to an overestimation of the left gap and
                             ! thus to inadequately early rqi 'convergence'.
                             ! prevent this by forcing a small left gap.
                             lgap = eps*max(abs(left),abs(right))
                          else
                             lgap = wgap(windmn)
                          endif
                          if( k == im) then
                             ! in the case range='i' and with not much initial
                             ! accuracy in lambda and vu, the formula
                             ! can lead to an overestimation of the right gap and
                             ! thus to inadequately early rqi 'convergence'.
                             ! prevent this by forcing a small right gap.
                             rgap = eps*max(abs(left),abs(right))
                          else
                             rgap = wgap(windex)
                          endif
                          gap = min( lgap, rgap )
                          if(( k == 1).or.(k == im)) then
                             ! the eigenvector support can become wrong
                             ! because significant entries could be cut off due to a
                             ! large gaptol parameter in lar1v. prevent this.
                             gaptol = zero
                          else
                             gaptol = gap * eps
                          endif
                          isupmn = in
                          isupmx = 1
                          ! update wgap so that it holds the minimum gap
                          ! to the left or the right. this is crucial in the
                          ! case where bisection is used to ensure that the
                          ! eigenvalue is refined up to the required precision.
                          ! the correct value is restored afterwards.
                          savgap = wgap(windex)
                          wgap(windex) = gap
                          ! we want to use the rayleigh quotient correction
                          ! as often as possible since it converges quadratically
                          ! when we are close enough to the desired eigenvalue.
                          ! however, the rayleigh quotient can have the wrong sign
                          ! and lead us away from the desired eigenvalue. in this
                          ! case, the best we can do is to use bisection.
                          usedbs = .false.
                          usedrq = .false.
                          ! bisection is initially turned off unless it is forced
                          needbs =  .not.tryrqc
                          120 continue
                          ! check if bisection should be used to refine eigenvalue
                          if(needbs) then
                             ! take the bisection as new iterate
                             usedbs = .true.
                             itmp1 = iwork( iindr+windex )
                             offset = indexw( wbegin ) - 1
                             call stdlib_slarrb( in, d(ibegin),work(indlld+ibegin-1),indeig,&
                             indeig,zero, two*eps, offset,work(wbegin),wgap(wbegin),werr(wbegin),&
                                       work( indwrk ),iwork( iindwk ), pivmin, spdiam,itmp1, iinfo )
                             if( iinfo/=0 ) then
                                info = -3
                                return
                             endif
                             lambda = work( windex )
                             ! reset twist index from inaccurate lambda to
                             ! force computation of true mingma
                             iwork( iindr+windex ) = 0
                          endif
                          ! given lambda, compute the eigenvector.
                          call stdlib_clar1v( in, 1, in, lambda, d( ibegin ),l( ibegin ), work(&
                          indld+ibegin-1),work(indlld+ibegin-1),pivmin, gaptol, z( ibegin, windex &
                          ),.not.usedbs, negcnt, ztz, mingma,iwork( iindr+windex ), isuppz( &
                                    2*windex-1 ),nrminv, resid, rqcorr, work( indwrk ) )
                          if(iter == 0) then
                             bstres = resid
                             bstw = lambda
                          elseif(resid<bstres) then
                             bstres = resid
                             bstw = lambda
                          endif
                          isupmn = min(isupmn,isuppz( 2*windex-1 ))
                          isupmx = max(isupmx,isuppz( 2*windex ))
                          iter = iter + 1
                          ! sin alpha <= |resid|/gap
                          ! note that both the residual and the gap are
                          ! proportional to the matrix, so ||t|| doesn't play
                          ! a role in the quotient
                          ! convergence test for rayleigh-quotient iteration
                          ! (omitted when bisection has been used)
                          if( resid>tol*gap .and. abs( rqcorr )>rqtol*abs( lambda ) .and. .not. &
                                    usedbs)then
                             ! we need to check that the rqcorr update doesn't
                             ! move the eigenvalue away from the desired one and
                             ! towards a neighbor. -> protection with bisection
                             if(indeig<=negcnt) then
                                ! the wanted eigenvalue lies to the left
                                sgndef = -one
                             else
                                ! the wanted eigenvalue lies to the right
                                sgndef = one
                             endif
                             ! we only use the rqcorr if it improves the
                             ! the iterate reasonably.
                             if( ( rqcorr*sgndef>=zero ).and.( lambda + rqcorr<= right).and.( &
                                       lambda + rqcorr>= left)) then
                                usedrq = .true.
                                ! store new midpoint of bisection interval in work
                                if(sgndef==one) then
                                   ! the current lambda is on the left of the true
                                   ! eigenvalue
                                   left = lambda
                                   ! we prefer to assume that the error estimate
                                   ! is correct. we could make the interval not
                                   ! as a bracket but to be modified if the rqcorr
                                   ! chooses to. in this case, the right side should
                                   ! be modified as follows:
                                    ! right = max(right, lambda + rqcorr)
                                else
                                   ! the current lambda is on the right of the true
                                   ! eigenvalue
                                   right = lambda
                                   ! see comment about assuming the error estimate is
                                   ! correct above.
                                    ! left = min(left, lambda + rqcorr)
                                endif
                                work( windex ) =half * (right + left)
                                ! take rqcorr since it has the correct sign and
                                ! improves the iterate reasonably
                                lambda = lambda + rqcorr
                                ! update width of error interval
                                werr( windex ) =half * (right-left)
                             else
                                needbs = .true.
                             endif
                             if(right-left<rqtol*abs(lambda)) then
                                   ! the eigenvalue is computed to bisection accuracy
                                   ! compute eigenvector and stop
                                usedbs = .true.
                                goto 120
                             elseif( iter<maxitr ) then
                                goto 120
                             elseif( iter==maxitr ) then
                                needbs = .true.
                                goto 120
                             else
                                info = 5
                                return
                             end if
                          else
                             stp2ii = .false.
             if(usedrq .and. usedbs .and.bstres<=resid) then
                                lambda = bstw
                                stp2ii = .true.
                             endif
                             if (stp2ii) then
                                ! improve error angle by second step
                                call stdlib_clar1v( in, 1, in, lambda,d( ibegin ), l( ibegin ),&
                                work(indld+ibegin-1),work(indlld+ibegin-1),pivmin, gaptol, z( &
                                ibegin, windex ),.not.usedbs, negcnt, ztz, mingma,iwork( iindr+&
                                windex ),isuppz( 2*windex-1 ),nrminv, resid, rqcorr, work( indwrk &
                                          ) )
                             endif
                             work( windex ) = lambda
                          end if
                          ! compute fp-vector support w.r.t. whole matrix
                          isuppz( 2*windex-1 ) = isuppz( 2*windex-1 )+oldien
                          isuppz( 2*windex ) = isuppz( 2*windex )+oldien
                          zfrom = isuppz( 2*windex-1 )
                          zto = isuppz( 2*windex )
                          isupmn = isupmn + oldien
                          isupmx = isupmx + oldien
                          ! ensure vector is ok if support in the rqi has changed
                          if(isupmn<zfrom) then
                             do ii = isupmn,zfrom-1
                                z( ii, windex ) = zero
                             end do
                          endif
                          if(isupmx>zto) then
                             do ii = zto+1,isupmx
                                z( ii, windex ) = zero
                             end do
                          endif
                          call stdlib_csscal( zto-zfrom+1, nrminv,z( zfrom, windex ), 1 )
                          125 continue
                          ! update w
                          w( windex ) = lambda+sigma
                          ! recompute the gaps on the left and right
                          ! but only allow them to become larger and not
                          ! smaller (which can only happen through "bad"
                          ! cancellation and doesn't reflect the theory
                          ! where the initial gaps are underestimated due
                          ! to werr being too crude.)
                          if(.not.eskip) then
                             if( k>1) then
                                wgap( windmn ) = max( wgap(windmn),w(windex)-werr(windex)- w(&
                                          windmn)-werr(windmn) )
                             endif
                             if( windex<wend ) then
                                wgap( windex ) = max( savgap,w( windpl )-werr( windpl )- w( &
                                          windex )-werr( windex) )
                             endif
                          endif
                          idone = idone + 1
                       endif
                       ! here ends the code for the current child
                       139 continue
                       ! proceed to any remaining child nodes
                       newfst = j + 1
                    end do loop_140
                 end do loop_150
                 ndepth = ndepth + 1
                 go to 40
              end if
              ibegin = iend + 1
              wbegin = wend + 1
           end do loop_170
           return
     end subroutine stdlib_clarrv

     pure subroutine stdlib_zlarrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
     !! ZLARRV computes the eigenvectors of the tridiagonal matrix
     !! T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.
     !! The input eigenvalues should have been computed by DLARRE.
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: dol, dou, ldz, m, n
           integer(ilp), intent(out) :: info
           real(dp), intent(in) :: minrgp, pivmin, vl, vu
           real(dp), intent(inout) :: rtol1, rtol2
           ! Array Arguments 
           integer(ilp), intent(in) :: iblock(*), indexw(*), isplit(*)
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(dp), intent(inout) :: d(*), l(*), w(*), werr(*), wgap(*)
           real(dp), intent(in) :: gers(*)
           real(dp), intent(out) :: work(*)
           complex(dp), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxitr = 10
           
           
           
           ! Local Scalars 
           logical(lk) :: eskip, needbs, stp2ii, tryrqc, usedbs, usedrq
           integer(ilp) :: done, i, ibegin, idone, iend, ii, iindc1, iindc2, iindr, iindwk, iinfo,&
            im, in, indeig, indld, indlld, indwrk, isupmn, isupmx, iter, itmp1, j, jblk, k, &
            miniwsize, minwsize, nclus, ndepth, negcnt, newcls, newfst, newftt, newlst, newsiz, &
            offset, oldcls, oldfst, oldien, oldlst, oldncl, p, parity, q, wbegin, wend, windex, &
                      windmn, windpl, zfrom, zto, zusedl, zusedu, zusedw
           integer(ilp) :: indin1, indin2
           real(dp) :: bstres, bstw, eps, fudge, gap, gaptol, gl, gu, lambda, left, lgap, mingma, &
           nrminv, resid, rgap, right, rqcorr, rqtol, savgap, sgndef, sigma, spdiam, ssigma, tau, &
                     tmp, tol, ztz
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( (n<=0).or.(m<=0) ) then
              return
           end if
           ! the first n entries of work are reserved for the eigenvalues
           indld = n+1
           indlld= 2*n+1
           indin1 = 3*n + 1
           indin2 = 4*n + 1
           indwrk = 5*n + 1
           minwsize = 12 * n
           do i= 1,minwsize
              work( i ) = zero
           end do
           ! iwork(iindr+1:iindr+n) hold the twist indices r for the
           ! factorization used to compute the fp vector
           iindr = 0
           ! iwork(iindc1+1:iinc2+n) are used to store the clusters of the current
           ! layer and the one above.
           iindc1 = n
           iindc2 = 2*n
           iindwk = 3*n + 1
           miniwsize = 7 * n
           do i= 1,miniwsize
              iwork( i ) = 0
           end do
           zusedl = 1
           if(dol>1) then
              ! set lower bound for use of z
              zusedl = dol-1
           endif
           zusedu = m
           if(dou<m) then
              ! set lower bound for use of z
              zusedu = dou+1
           endif
           ! the width of the part of z that is used
           zusedw = zusedu - zusedl + 1
           call stdlib_zlaset( 'FULL', n, zusedw, czero, czero,z(1,zusedl), ldz )
           eps = stdlib_dlamch( 'PRECISION' )
           rqtol = two * eps
           ! set expert flags for standard code.
           tryrqc = .true.
           if((dol==1).and.(dou==m)) then
           else
              ! only selected eigenpairs are computed. since the other evalues
              ! are not refined by rq iteration, bisection has to compute to full
              ! accuracy.
              rtol1 = four * eps
              rtol2 = four * eps
           endif
           ! the entries wbegin:wend in w, werr, wgap correspond to the
           ! desired eigenvalues. the support of the nonzero eigenvector
           ! entries is contained in the interval ibegin:iend.
           ! remark that if k eigenpairs are desired, then the eigenvectors
           ! are stored in k contiguous columns of z.
           ! done is the number of eigenvectors already computed
           done = 0
           ibegin = 1
           wbegin = 1
           loop_170: do jblk = 1, iblock( m )
              iend = isplit( jblk )
              sigma = l( iend )
              ! find the eigenvectors of the submatrix indexed ibegin
              ! through iend.
              wend = wbegin - 1
              15 continue
              if( wend<m ) then
                 if( iblock( wend+1 )==jblk ) then
                    wend = wend + 1
                    go to 15
                 end if
              end if
              if( wend<wbegin ) then
                 ibegin = iend + 1
                 cycle loop_170
              elseif( (wend<dol).or.(wbegin>dou) ) then
                 ibegin = iend + 1
                 wbegin = wend + 1
                 cycle loop_170
              end if
              ! find local spectral diameter of the block
              gl = gers( 2*ibegin-1 )
              gu = gers( 2*ibegin )
              do i = ibegin+1 , iend
                 gl = min( gers( 2*i-1 ), gl )
                 gu = max( gers( 2*i ), gu )
              end do
              spdiam = gu - gl
              ! oldien is the last index of the previous block
              oldien = ibegin - 1
              ! calculate the size of the current block
              in = iend - ibegin + 1
              ! the number of eigenvalues in the current block
              im = wend - wbegin + 1
              ! this is for a 1x1 block
              if( ibegin==iend ) then
                 done = done+1
                 z( ibegin, wbegin ) = cmplx( one, zero,KIND=dp)
                 isuppz( 2*wbegin-1 ) = ibegin
                 isuppz( 2*wbegin ) = ibegin
                 w( wbegin ) = w( wbegin ) + sigma
                 work( wbegin ) = w( wbegin )
                 ibegin = iend + 1
                 wbegin = wbegin + 1
                 cycle loop_170
              end if
              ! the desired (shifted) eigenvalues are stored in w(wbegin:wend)
              ! note that these can be approximations, in this case, the corresp.
              ! entries of werr give the size of the uncertainty interval.
              ! the eigenvalue approximations will be refined when necessary as
              ! high relative accuracy is required for the computation of the
              ! corresponding eigenvectors.
              call stdlib_dcopy( im, w( wbegin ), 1,work( wbegin ), 1 )
              ! we store in w the eigenvalue approximations w.r.t. the original
              ! matrix t.
              do i=1,im
                 w(wbegin+i-1) = w(wbegin+i-1)+sigma
              end do
              ! ndepth is the current depth of the representation tree
              ndepth = 0
              ! parity is either 1 or 0
              parity = 1
              ! nclus is the number of clusters for the next level of the
              ! representation tree, we start with nclus = 1 for the root
              nclus = 1
              iwork( iindc1+1 ) = 1
              iwork( iindc1+2 ) = im
              ! idone is the number of eigenvectors already computed in the current
              ! block
              idone = 0
              ! loop while( idone<im )
              ! generate the representation tree for the current block and
              ! compute the eigenvectors
              40 continue
              if( idone<im ) then
                 ! this is a crude protection against infinitely deep trees
                 if( ndepth>m ) then
                    info = -2
                    return
                 endif
                 ! breadth first processing of the current level of the representation
                 ! tree: oldncl = number of clusters on current level
                 oldncl = nclus
                 ! reset nclus to count the number of child clusters
                 nclus = 0
                 parity = 1 - parity
                 if( parity==0 ) then
                    oldcls = iindc1
                    newcls = iindc2
                 else
                    oldcls = iindc2
                    newcls = iindc1
                 end if
                 ! process the clusters on the current level
                 loop_150: do i = 1, oldncl
                    j = oldcls + 2*i
                    ! oldfst, oldlst = first, last index of current cluster.
                                     ! cluster indices start with 1 and are relative
                                     ! to wbegin when accessing w, wgap, werr, z
                    oldfst = iwork( j-1 )
                    oldlst = iwork( j )
                    if( ndepth>0 ) then
                       ! retrieve relatively robust representation (rrr) of cluster
                       ! that has been computed at the previous level
                       ! the rrr is stored in z and overwritten once the eigenvectors
                       ! have been computed or when the cluster is refined
                       if((dol==1).and.(dou==m)) then
                          ! get representation from location of the leftmost evalue
                          ! of the cluster
                          j = wbegin + oldfst - 1
                       else
                          if(wbegin+oldfst-1<dol) then
                             ! get representation from the left end of z array
                             j = dol - 1
                          elseif(wbegin+oldfst-1>dou) then
                             ! get representation from the right end of z array
                             j = dou
                          else
                             j = wbegin + oldfst - 1
                          endif
                       endif
                       do k = 1, in - 1
                          d( ibegin+k-1 ) = real( z( ibegin+k-1,j ),KIND=dp)
                          l( ibegin+k-1 ) = real( z( ibegin+k-1,j+1 ),KIND=dp)
                       end do
                       d( iend ) = real( z( iend, j ),KIND=dp)
                       sigma = real( z( iend, j+1 ),KIND=dp)
                       ! set the corresponding entries in z to zero
                       call stdlib_zlaset( 'FULL', in, 2, czero, czero,z( ibegin, j), ldz )
                                 
                    end if
                    ! compute dl and dll of current rrr
                    do j = ibegin, iend-1
                       tmp = d( j )*l( j )
                       work( indld-1+j ) = tmp
                       work( indlld-1+j ) = tmp*l( j )
                    end do
                    if( ndepth>0 ) then
                       ! p and q are index of the first and last eigenvalue to compute
                       ! within the current block
                       p = indexw( wbegin-1+oldfst )
                       q = indexw( wbegin-1+oldlst )
                       ! offset for the arrays work, wgap and werr, i.e., the p-offset
                       ! through the q-offset elements of these arrays are to be used.
                        ! offset = p-oldfst
                       offset = indexw( wbegin ) - 1
                       ! perform limited bisection (if necessary) to get approximate
                       ! eigenvalues to the precision needed.
                       call stdlib_dlarrb( in, d( ibegin ),work(indlld+ibegin-1),p, q, rtol1, &
                       rtol2, offset,work(wbegin),wgap(wbegin),werr(wbegin),work( indwrk ), iwork(&
                                  iindwk ),pivmin, spdiam, in, iinfo )
                       if( iinfo/=0 ) then
                          info = -1
                          return
                       endif
                       ! we also recompute the extremal gaps. w holds all eigenvalues
                       ! of the unshifted matrix and must be used for computation
                       ! of wgap, the entries of work might stem from rrrs with
                       ! different shifts. the gaps from wbegin-1+oldfst to
                       ! wbegin-1+oldlst are correctly computed in stdlib_dlarrb.
                       ! however, we only allow the gaps to become greater since
                       ! this is what should happen when we decrease werr
                       if( oldfst>1) then
                          wgap( wbegin+oldfst-2 ) =max(wgap(wbegin+oldfst-2),w(wbegin+oldfst-1)-&
                          werr(wbegin+oldfst-1)- w(wbegin+oldfst-2)-werr(wbegin+oldfst-2) )
                                    
                       endif
                       if( wbegin + oldlst -1 < wend ) then
                          wgap( wbegin+oldlst-1 ) =max(wgap(wbegin+oldlst-1),w(wbegin+oldlst)-&
                                    werr(wbegin+oldlst)- w(wbegin+oldlst-1)-werr(wbegin+oldlst-1) )
                       endif
                       ! each time the eigenvalues in work get refined, we store
                       ! the newly found approximation with all shifts applied in w
                       do j=oldfst,oldlst
                          w(wbegin+j-1) = work(wbegin+j-1)+sigma
                       end do
                    end if
                    ! process the current node.
                    newfst = oldfst
                    loop_140: do j = oldfst, oldlst
                       if( j==oldlst ) then
                          ! we are at the right end of the cluster, this is also the
                          ! boundary of the child cluster
                          newlst = j
                       else if ( wgap( wbegin + j -1)>=minrgp* abs( work(wbegin + j -1) ) ) &
                                 then
                          ! the right relative gap is big enough, the child cluster
                          ! (newfst,..,newlst) is well separated from the following
                          newlst = j
                        else
                          ! inside a child cluster, the relative gap is not
                          ! big enough.
                          cycle loop_140
                       end if
                       ! compute size of child cluster found
                       newsiz = newlst - newfst + 1
                       ! newftt is the place in z where the new rrr or the computed
                       ! eigenvector is to be stored
                       if((dol==1).and.(dou==m)) then
                          ! store representation at location of the leftmost evalue
                          ! of the cluster
                          newftt = wbegin + newfst - 1
                       else
                          if(wbegin+newfst-1<dol) then
                             ! store representation at the left end of z array
                             newftt = dol - 1
                          elseif(wbegin+newfst-1>dou) then
                             ! store representation at the right end of z array
                             newftt = dou
                          else
                             newftt = wbegin + newfst - 1
                          endif
                       endif
                       if( newsiz>1) then
                          ! current child is not a singleton but a cluster.
                          ! compute and store new representation of child.
                          ! compute left and right cluster gap.
                          ! lgap and rgap are not computed from work because
                          ! the eigenvalue approximations may stem from rrrs
                          ! different shifts. however, w hold all eigenvalues
                          ! of the unshifted matrix. still, the entries in wgap
                          ! have to be computed from work since the entries
                          ! in w might be of the same order so that gaps are not
                          ! exhibited correctly for very close eigenvalues.
                          if( newfst==1 ) then
                             lgap = max( zero,w(wbegin)-werr(wbegin) - vl )
                         else
                             lgap = wgap( wbegin+newfst-2 )
                          endif
                          rgap = wgap( wbegin+newlst-1 )
                          ! compute left- and rightmost eigenvalue of child
                          ! to high precision in order to shift as close
                          ! as possible and obtain as large relative gaps
                          ! as possible
                          do k =1,2
                             if(k==1) then
                                p = indexw( wbegin-1+newfst )
                             else
                                p = indexw( wbegin-1+newlst )
                             endif
                             offset = indexw( wbegin ) - 1
                             call stdlib_dlarrb( in, d(ibegin),work( indlld+ibegin-1 ),p,p,rqtol, &
                             rqtol, offset,work(wbegin),wgap(wbegin),werr(wbegin),work( indwrk ),&
                                       iwork( iindwk ), pivmin, spdiam,in, iinfo )
                          end do
                          if((wbegin+newlst-1<dol).or.(wbegin+newfst-1>dou)) then
                             ! if the cluster contains no desired eigenvalues
                             ! skip the computation of that branch of the rep. tree
                             ! we could skip before the refinement of the extremal
                             ! eigenvalues of the child, but then the representation
                             ! tree could be different from the one when nothing is
                             ! skipped. for this reason we skip at this place.
                             idone = idone + newlst - newfst + 1
                             goto 139
                          endif
                          ! compute rrr of child cluster.
                          ! note that the new rrr is stored in z
                          ! stdlib_dlarrf needs lwork = 2*n
                          call stdlib_dlarrf( in, d( ibegin ), l( ibegin ),work(indld+ibegin-1),&
                          newfst, newlst, work(wbegin),wgap(wbegin), werr(wbegin),spdiam, lgap, &
                          rgap, pivmin, tau,work( indin1 ), work( indin2 ),work( indwrk ), iinfo )
                                    
                          ! in the complex case, stdlib_dlarrf cannot write
                          ! the new rrr directly into z and needs an intermediate
                          ! workspace
                          do k = 1, in-1
                             z( ibegin+k-1, newftt ) =cmplx( work( indin1+k-1 ), zero,KIND=dp)
                                       
                             z( ibegin+k-1, newftt+1 ) =cmplx( work( indin2+k-1 ), zero,KIND=dp)
                                       
                          end do
                          z( iend, newftt ) =cmplx( work( indin1+in-1 ), zero,KIND=dp)
                          if( iinfo==0 ) then
                             ! a new rrr for the cluster was found by stdlib_dlarrf
                             ! update shift and store it
                             ssigma = sigma + tau
                             z( iend, newftt+1 ) = cmplx( ssigma, zero,KIND=dp)
                             ! work() are the midpoints and werr() the semi-width
                             ! note that the entries in w are unchanged.
                             do k = newfst, newlst
                                fudge =three*eps*abs(work(wbegin+k-1))
                                work( wbegin + k - 1 ) =work( wbegin + k - 1) - tau
                                fudge = fudge +four*eps*abs(work(wbegin+k-1))
                                ! fudge errors
                                werr( wbegin + k - 1 ) =werr( wbegin + k - 1 ) + fudge
                                ! gaps are not fudged. provided that werr is small
                                ! when eigenvalues are close, a zero gap indicates
                                ! that a new representation is needed for resolving
                                ! the cluster. a fudge could lead to a wrong decision
                                ! of judging eigenvalues 'separated' which in
                                ! reality are not. this could have a negative impact
                                ! on the orthogonality of the computed eigenvectors.
                             end do
                             nclus = nclus + 1
                             k = newcls + 2*nclus
                             iwork( k-1 ) = newfst
                             iwork( k ) = newlst
                          else
                             info = -2
                             return
                          endif
                       else
                          ! compute eigenvector of singleton
                          iter = 0
                          tol = four * log(real(in,KIND=dp)) * eps
                          k = newfst
                          windex = wbegin + k - 1
                          windmn = max(windex - 1,1)
                          windpl = min(windex + 1,m)
                          lambda = work( windex )
                          done = done + 1
                          ! check if eigenvector computation is to be skipped
                          if((windex<dol).or.(windex>dou)) then
                             eskip = .true.
                             goto 125
                          else
                             eskip = .false.
                          endif
                          left = work( windex ) - werr( windex )
                          right = work( windex ) + werr( windex )
                          indeig = indexw( windex )
                          ! note that since we compute the eigenpairs for a child,
                          ! all eigenvalue approximations are w.r.t the same shift.
                          ! in this case, the entries in work should be used for
                          ! computing the gaps since they exhibit even very small
                          ! differences in the eigenvalues, as opposed to the
                          ! entries in w which might "look" the same.
                          if( k == 1) then
                             ! in the case range='i' and with not much initial
                             ! accuracy in lambda and vl, the formula
                             ! lgap = max( zero, (sigma - vl) + lambda )
                             ! can lead to an overestimation of the left gap and
                             ! thus to inadequately early rqi 'convergence'.
                             ! prevent this by forcing a small left gap.
                             lgap = eps*max(abs(left),abs(right))
                          else
                             lgap = wgap(windmn)
                          endif
                          if( k == im) then
                             ! in the case range='i' and with not much initial
                             ! accuracy in lambda and vu, the formula
                             ! can lead to an overestimation of the right gap and
                             ! thus to inadequately early rqi 'convergence'.
                             ! prevent this by forcing a small right gap.
                             rgap = eps*max(abs(left),abs(right))
                          else
                             rgap = wgap(windex)
                          endif
                          gap = min( lgap, rgap )
                          if(( k == 1).or.(k == im)) then
                             ! the eigenvector support can become wrong
                             ! because significant entries could be cut off due to a
                             ! large gaptol parameter in lar1v. prevent this.
                             gaptol = zero
                          else
                             gaptol = gap * eps
                          endif
                          isupmn = in
                          isupmx = 1
                          ! update wgap so that it holds the minimum gap
                          ! to the left or the right. this is crucial in the
                          ! case where bisection is used to ensure that the
                          ! eigenvalue is refined up to the required precision.
                          ! the correct value is restored afterwards.
                          savgap = wgap(windex)
                          wgap(windex) = gap
                          ! we want to use the rayleigh quotient correction
                          ! as often as possible since it converges quadratically
                          ! when we are close enough to the desired eigenvalue.
                          ! however, the rayleigh quotient can have the wrong sign
                          ! and lead us away from the desired eigenvalue. in this
                          ! case, the best we can do is to use bisection.
                          usedbs = .false.
                          usedrq = .false.
                          ! bisection is initially turned off unless it is forced
                          needbs =  .not.tryrqc
                          120 continue
                          ! check if bisection should be used to refine eigenvalue
                          if(needbs) then
                             ! take the bisection as new iterate
                             usedbs = .true.
                             itmp1 = iwork( iindr+windex )
                             offset = indexw( wbegin ) - 1
                             call stdlib_dlarrb( in, d(ibegin),work(indlld+ibegin-1),indeig,&
                             indeig,zero, two*eps, offset,work(wbegin),wgap(wbegin),werr(wbegin),&
                                       work( indwrk ),iwork( iindwk ), pivmin, spdiam,itmp1, iinfo )
                             if( iinfo/=0 ) then
                                info = -3
                                return
                             endif
                             lambda = work( windex )
                             ! reset twist index from inaccurate lambda to
                             ! force computation of true mingma
                             iwork( iindr+windex ) = 0
                          endif
                          ! given lambda, compute the eigenvector.
                          call stdlib_zlar1v( in, 1, in, lambda, d( ibegin ),l( ibegin ), work(&
                          indld+ibegin-1),work(indlld+ibegin-1),pivmin, gaptol, z( ibegin, windex &
                          ),.not.usedbs, negcnt, ztz, mingma,iwork( iindr+windex ), isuppz( &
                                    2*windex-1 ),nrminv, resid, rqcorr, work( indwrk ) )
                          if(iter == 0) then
                             bstres = resid
                             bstw = lambda
                          elseif(resid<bstres) then
                             bstres = resid
                             bstw = lambda
                          endif
                          isupmn = min(isupmn,isuppz( 2*windex-1 ))
                          isupmx = max(isupmx,isuppz( 2*windex ))
                          iter = iter + 1
                          ! sin alpha <= |resid|/gap
                          ! note that both the residual and the gap are
                          ! proportional to the matrix, so ||t|| doesn't play
                          ! a role in the quotient
                          ! convergence test for rayleigh-quotient iteration
                          ! (omitted when bisection has been used)
                          if( resid>tol*gap .and. abs( rqcorr )>rqtol*abs( lambda ) .and. .not. &
                                    usedbs)then
                             ! we need to check that the rqcorr update doesn't
                             ! move the eigenvalue away from the desired one and
                             ! towards a neighbor. -> protection with bisection
                             if(indeig<=negcnt) then
                                ! the wanted eigenvalue lies to the left
                                sgndef = -one
                             else
                                ! the wanted eigenvalue lies to the right
                                sgndef = one
                             endif
                             ! we only use the rqcorr if it improves the
                             ! the iterate reasonably.
                             if( ( rqcorr*sgndef>=zero ).and.( lambda + rqcorr<= right).and.( &
                                       lambda + rqcorr>= left)) then
                                usedrq = .true.
                                ! store new midpoint of bisection interval in work
                                if(sgndef==one) then
                                   ! the current lambda is on the left of the true
                                   ! eigenvalue
                                   left = lambda
                                   ! we prefer to assume that the error estimate
                                   ! is correct. we could make the interval not
                                   ! as a bracket but to be modified if the rqcorr
                                   ! chooses to. in this case, the right side should
                                   ! be modified as follows:
                                    ! right = max(right, lambda + rqcorr)
                                else
                                   ! the current lambda is on the right of the true
                                   ! eigenvalue
                                   right = lambda
                                   ! see comment about assuming the error estimate is
                                   ! correct above.
                                    ! left = min(left, lambda + rqcorr)
                                endif
                                work( windex ) =half * (right + left)
                                ! take rqcorr since it has the correct sign and
                                ! improves the iterate reasonably
                                lambda = lambda + rqcorr
                                ! update width of error interval
                                werr( windex ) =half * (right-left)
                             else
                                needbs = .true.
                             endif
                             if(right-left<rqtol*abs(lambda)) then
                                   ! the eigenvalue is computed to bisection accuracy
                                   ! compute eigenvector and stop
                                usedbs = .true.
                                goto 120
                             elseif( iter<maxitr ) then
                                goto 120
                             elseif( iter==maxitr ) then
                                needbs = .true.
                                goto 120
                             else
                                info = 5
                                return
                             end if
                          else
                             stp2ii = .false.
             if(usedrq .and. usedbs .and.bstres<=resid) then
                                lambda = bstw
                                stp2ii = .true.
                             endif
                             if (stp2ii) then
                                ! improve error angle by second step
                                call stdlib_zlar1v( in, 1, in, lambda,d( ibegin ), l( ibegin ),&
                                work(indld+ibegin-1),work(indlld+ibegin-1),pivmin, gaptol, z( &
                                ibegin, windex ),.not.usedbs, negcnt, ztz, mingma,iwork( iindr+&
                                windex ),isuppz( 2*windex-1 ),nrminv, resid, rqcorr, work( indwrk &
                                          ) )
                             endif
                             work( windex ) = lambda
                          end if
                          ! compute fp-vector support w.r.t. whole matrix
                          isuppz( 2*windex-1 ) = isuppz( 2*windex-1 )+oldien
                          isuppz( 2*windex ) = isuppz( 2*windex )+oldien
                          zfrom = isuppz( 2*windex-1 )
                          zto = isuppz( 2*windex )
                          isupmn = isupmn + oldien
                          isupmx = isupmx + oldien
                          ! ensure vector is ok if support in the rqi has changed
                          if(isupmn<zfrom) then
                             do ii = isupmn,zfrom-1
                                z( ii, windex ) = zero
                             end do
                          endif
                          if(isupmx>zto) then
                             do ii = zto+1,isupmx
                                z( ii, windex ) = zero
                             end do
                          endif
                          call stdlib_zdscal( zto-zfrom+1, nrminv,z( zfrom, windex ), 1 )
                          125 continue
                          ! update w
                          w( windex ) = lambda+sigma
                          ! recompute the gaps on the left and right
                          ! but only allow them to become larger and not
                          ! smaller (which can only happen through "bad"
                          ! cancellation and doesn't reflect the theory
                          ! where the initial gaps are underestimated due
                          ! to werr being too crude.)
                          if(.not.eskip) then
                             if( k>1) then
                                wgap( windmn ) = max( wgap(windmn),w(windex)-werr(windex)- w(&
                                          windmn)-werr(windmn) )
                             endif
                             if( windex<wend ) then
                                wgap( windex ) = max( savgap,w( windpl )-werr( windpl )- w( &
                                          windex )-werr( windex) )
                             endif
                          endif
                          idone = idone + 1
                       endif
                       ! here ends the code for the current child
                       139 continue
                       ! proceed to any remaining child nodes
                       newfst = j + 1
                    end do loop_140
                 end do loop_150
                 ndepth = ndepth + 1
                 go to 40
              end if
              ibegin = iend + 1
              wbegin = wend + 1
           end do loop_170
           return
     end subroutine stdlib_zlarrv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$larrv( n, vl, vu, d, l, pivmin,isplit, m, dol, dou, minrgp,rtol1, &
     !! ZLARRV: computes the eigenvectors of the tridiagonal matrix
     !! T = L D L**T given L, D and APPROXIMATIONS to the eigenvalues of L D L**T.
     !! The input eigenvalues should have been computed by DLARRE.
               rtol2, w, werr, wgap,iblock, indexw, gers, z, ldz, isuppz,work, iwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: dol, dou, ldz, m, n
           integer(ilp), intent(out) :: info
           real(${ck}$), intent(in) :: minrgp, pivmin, vl, vu
           real(${ck}$), intent(inout) :: rtol1, rtol2
           ! Array Arguments 
           integer(ilp), intent(in) :: iblock(*), indexw(*), isplit(*)
           integer(ilp), intent(out) :: isuppz(*), iwork(*)
           real(${ck}$), intent(inout) :: d(*), l(*), w(*), werr(*), wgap(*)
           real(${ck}$), intent(in) :: gers(*)
           real(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(out) :: z(ldz,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxitr = 10
           
           
           
           ! Local Scalars 
           logical(lk) :: eskip, needbs, stp2ii, tryrqc, usedbs, usedrq
           integer(ilp) :: done, i, ibegin, idone, iend, ii, iindc1, iindc2, iindr, iindwk, iinfo,&
            im, in, indeig, indld, indlld, indwrk, isupmn, isupmx, iter, itmp1, j, jblk, k, &
            miniwsize, minwsize, nclus, ndepth, negcnt, newcls, newfst, newftt, newlst, newsiz, &
            offset, oldcls, oldfst, oldien, oldlst, oldncl, p, parity, q, wbegin, wend, windex, &
                      windmn, windpl, zfrom, zto, zusedl, zusedu, zusedw
           integer(ilp) :: indin1, indin2
           real(${ck}$) :: bstres, bstw, eps, fudge, gap, gaptol, gl, gu, lambda, left, lgap, mingma, &
           nrminv, resid, rgap, right, rqcorr, rqtol, savgap, sgndef, sigma, spdiam, ssigma, tau, &
                     tmp, tol, ztz
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( (n<=0).or.(m<=0) ) then
              return
           end if
           ! the first n entries of work are reserved for the eigenvalues
           indld = n+1
           indlld= 2*n+1
           indin1 = 3*n + 1
           indin2 = 4*n + 1
           indwrk = 5*n + 1
           minwsize = 12 * n
           do i= 1,minwsize
              work( i ) = zero
           end do
           ! iwork(iindr+1:iindr+n) hold the twist indices r for the
           ! factorization used to compute the fp vector
           iindr = 0
           ! iwork(iindc1+1:iinc2+n) are used to store the clusters of the current
           ! layer and the one above.
           iindc1 = n
           iindc2 = 2*n
           iindwk = 3*n + 1
           miniwsize = 7 * n
           do i= 1,miniwsize
              iwork( i ) = 0
           end do
           zusedl = 1
           if(dol>1) then
              ! set lower bound for use of z
              zusedl = dol-1
           endif
           zusedu = m
           if(dou<m) then
              ! set lower bound for use of z
              zusedu = dou+1
           endif
           ! the width of the part of z that is used
           zusedw = zusedu - zusedl + 1
           call stdlib_${ci}$laset( 'FULL', n, zusedw, czero, czero,z(1,zusedl), ldz )
           eps = stdlib_${c2ri(ci)}$lamch( 'PRECISION' )
           rqtol = two * eps
           ! set expert flags for standard code.
           tryrqc = .true.
           if((dol==1).and.(dou==m)) then
           else
              ! only selected eigenpairs are computed. since the other evalues
              ! are not refined by rq iteration, bisection has to compute to full
              ! accuracy.
              rtol1 = four * eps
              rtol2 = four * eps
           endif
           ! the entries wbegin:wend in w, werr, wgap correspond to the
           ! desired eigenvalues. the support of the nonzero eigenvector
           ! entries is contained in the interval ibegin:iend.
           ! remark that if k eigenpairs are desired, then the eigenvectors
           ! are stored in k contiguous columns of z.
           ! done is the number of eigenvectors already computed
           done = 0
           ibegin = 1
           wbegin = 1
           loop_170: do jblk = 1, iblock( m )
              iend = isplit( jblk )
              sigma = l( iend )
              ! find the eigenvectors of the submatrix indexed ibegin
              ! through iend.
              wend = wbegin - 1
              15 continue
              if( wend<m ) then
                 if( iblock( wend+1 )==jblk ) then
                    wend = wend + 1
                    go to 15
                 end if
              end if
              if( wend<wbegin ) then
                 ibegin = iend + 1
                 cycle loop_170
              elseif( (wend<dol).or.(wbegin>dou) ) then
                 ibegin = iend + 1
                 wbegin = wend + 1
                 cycle loop_170
              end if
              ! find local spectral diameter of the block
              gl = gers( 2*ibegin-1 )
              gu = gers( 2*ibegin )
              do i = ibegin+1 , iend
                 gl = min( gers( 2*i-1 ), gl )
                 gu = max( gers( 2*i ), gu )
              end do
              spdiam = gu - gl
              ! oldien is the last index of the previous block
              oldien = ibegin - 1
              ! calculate the size of the current block
              in = iend - ibegin + 1
              ! the number of eigenvalues in the current block
              im = wend - wbegin + 1
              ! this is for a 1x1 block
              if( ibegin==iend ) then
                 done = done+1
                 z( ibegin, wbegin ) = cmplx( one, zero,KIND=${ck}$)
                 isuppz( 2*wbegin-1 ) = ibegin
                 isuppz( 2*wbegin ) = ibegin
                 w( wbegin ) = w( wbegin ) + sigma
                 work( wbegin ) = w( wbegin )
                 ibegin = iend + 1
                 wbegin = wbegin + 1
                 cycle loop_170
              end if
              ! the desired (shifted) eigenvalues are stored in w(wbegin:wend)
              ! note that these can be approximations, in this case, the corresp.
              ! entries of werr give the size of the uncertainty interval.
              ! the eigenvalue approximations will be refined when necessary as
              ! high relative accuracy is required for the computation of the
              ! corresponding eigenvectors.
              call stdlib_${c2ri(ci)}$copy( im, w( wbegin ), 1,work( wbegin ), 1 )
              ! we store in w the eigenvalue approximations w.r.t. the original
              ! matrix t.
              do i=1,im
                 w(wbegin+i-1) = w(wbegin+i-1)+sigma
              end do
              ! ndepth is the current depth of the representation tree
              ndepth = 0
              ! parity is either 1 or 0
              parity = 1
              ! nclus is the number of clusters for the next level of the
              ! representation tree, we start with nclus = 1 for the root
              nclus = 1
              iwork( iindc1+1 ) = 1
              iwork( iindc1+2 ) = im
              ! idone is the number of eigenvectors already computed in the current
              ! block
              idone = 0
              ! loop while( idone<im )
              ! generate the representation tree for the current block and
              ! compute the eigenvectors
              40 continue
              if( idone<im ) then
                 ! this is a crude protection against infinitely deep trees
                 if( ndepth>m ) then
                    info = -2
                    return
                 endif
                 ! breadth first processing of the current level of the representation
                 ! tree: oldncl = number of clusters on current level
                 oldncl = nclus
                 ! reset nclus to count the number of child clusters
                 nclus = 0
                 parity = 1 - parity
                 if( parity==0 ) then
                    oldcls = iindc1
                    newcls = iindc2
                 else
                    oldcls = iindc2
                    newcls = iindc1
                 end if
                 ! process the clusters on the current level
                 loop_150: do i = 1, oldncl
                    j = oldcls + 2*i
                    ! oldfst, oldlst = first, last index of current cluster.
                                     ! cluster indices start with 1 and are relative
                                     ! to wbegin when accessing w, wgap, werr, z
                    oldfst = iwork( j-1 )
                    oldlst = iwork( j )
                    if( ndepth>0 ) then
                       ! retrieve relatively robust representation (rrr) of cluster
                       ! that has been computed at the previous level
                       ! the rrr is stored in z and overwritten once the eigenvectors
                       ! have been computed or when the cluster is refined
                       if((dol==1).and.(dou==m)) then
                          ! get representation from location of the leftmost evalue
                          ! of the cluster
                          j = wbegin + oldfst - 1
                       else
                          if(wbegin+oldfst-1<dol) then
                             ! get representation from the left end of z array
                             j = dol - 1
                          elseif(wbegin+oldfst-1>dou) then
                             ! get representation from the right end of z array
                             j = dou
                          else
                             j = wbegin + oldfst - 1
                          endif
                       endif
                       do k = 1, in - 1
                          d( ibegin+k-1 ) = real( z( ibegin+k-1,j ),KIND=${ck}$)
                          l( ibegin+k-1 ) = real( z( ibegin+k-1,j+1 ),KIND=${ck}$)
                       end do
                       d( iend ) = real( z( iend, j ),KIND=${ck}$)
                       sigma = real( z( iend, j+1 ),KIND=${ck}$)
                       ! set the corresponding entries in z to zero
                       call stdlib_${ci}$laset( 'FULL', in, 2, czero, czero,z( ibegin, j), ldz )
                                 
                    end if
                    ! compute dl and dll of current rrr
                    do j = ibegin, iend-1
                       tmp = d( j )*l( j )
                       work( indld-1+j ) = tmp
                       work( indlld-1+j ) = tmp*l( j )
                    end do
                    if( ndepth>0 ) then
                       ! p and q are index of the first and last eigenvalue to compute
                       ! within the current block
                       p = indexw( wbegin-1+oldfst )
                       q = indexw( wbegin-1+oldlst )
                       ! offset for the arrays work, wgap and werr, i.e., the p-offset
                       ! through the q-offset elements of these arrays are to be used.
                        ! offset = p-oldfst
                       offset = indexw( wbegin ) - 1
                       ! perform limited bisection (if necessary) to get approximate
                       ! eigenvalues to the precision needed.
                       call stdlib_${c2ri(ci)}$larrb( in, d( ibegin ),work(indlld+ibegin-1),p, q, rtol1, &
                       rtol2, offset,work(wbegin),wgap(wbegin),werr(wbegin),work( indwrk ), iwork(&
                                  iindwk ),pivmin, spdiam, in, iinfo )
                       if( iinfo/=0 ) then
                          info = -1
                          return
                       endif
                       ! we also recompute the extremal gaps. w holds all eigenvalues
                       ! of the unshifted matrix and must be used for computation
                       ! of wgap, the entries of work might stem from rrrs with
                       ! different shifts. the gaps from wbegin-1+oldfst to
                       ! wbegin-1+oldlst are correctly computed in stdlib_${c2ri(ci)}$larrb.
                       ! however, we only allow the gaps to become greater since
                       ! this is what should happen when we decrease werr
                       if( oldfst>1) then
                          wgap( wbegin+oldfst-2 ) =max(wgap(wbegin+oldfst-2),w(wbegin+oldfst-1)-&
                          werr(wbegin+oldfst-1)- w(wbegin+oldfst-2)-werr(wbegin+oldfst-2) )
                                    
                       endif
                       if( wbegin + oldlst -1 < wend ) then
                          wgap( wbegin+oldlst-1 ) =max(wgap(wbegin+oldlst-1),w(wbegin+oldlst)-&
                                    werr(wbegin+oldlst)- w(wbegin+oldlst-1)-werr(wbegin+oldlst-1) )
                       endif
                       ! each time the eigenvalues in work get refined, we store
                       ! the newly found approximation with all shifts applied in w
                       do j=oldfst,oldlst
                          w(wbegin+j-1) = work(wbegin+j-1)+sigma
                       end do
                    end if
                    ! process the current node.
                    newfst = oldfst
                    loop_140: do j = oldfst, oldlst
                       if( j==oldlst ) then
                          ! we are at the right end of the cluster, this is also the
                          ! boundary of the child cluster
                          newlst = j
                       else if ( wgap( wbegin + j -1)>=minrgp* abs( work(wbegin + j -1) ) ) &
                                 then
                          ! the right relative gap is big enough, the child cluster
                          ! (newfst,..,newlst) is well separated from the following
                          newlst = j
                        else
                          ! inside a child cluster, the relative gap is not
                          ! big enough.
                          cycle loop_140
                       end if
                       ! compute size of child cluster found
                       newsiz = newlst - newfst + 1
                       ! newftt is the place in z where the new rrr or the computed
                       ! eigenvector is to be stored
                       if((dol==1).and.(dou==m)) then
                          ! store representation at location of the leftmost evalue
                          ! of the cluster
                          newftt = wbegin + newfst - 1
                       else
                          if(wbegin+newfst-1<dol) then
                             ! store representation at the left end of z array
                             newftt = dol - 1
                          elseif(wbegin+newfst-1>dou) then
                             ! store representation at the right end of z array
                             newftt = dou
                          else
                             newftt = wbegin + newfst - 1
                          endif
                       endif
                       if( newsiz>1) then
                          ! current child is not a singleton but a cluster.
                          ! compute and store new representation of child.
                          ! compute left and right cluster gap.
                          ! lgap and rgap are not computed from work because
                          ! the eigenvalue approximations may stem from rrrs
                          ! different shifts. however, w hold all eigenvalues
                          ! of the unshifted matrix. still, the entries in wgap
                          ! have to be computed from work since the entries
                          ! in w might be of the same order so that gaps are not
                          ! exhibited correctly for very close eigenvalues.
                          if( newfst==1 ) then
                             lgap = max( zero,w(wbegin)-werr(wbegin) - vl )
                         else
                             lgap = wgap( wbegin+newfst-2 )
                          endif
                          rgap = wgap( wbegin+newlst-1 )
                          ! compute left- and rightmost eigenvalue of child
                          ! to high precision in order to shift as close
                          ! as possible and obtain as large relative gaps
                          ! as possible
                          do k =1,2
                             if(k==1) then
                                p = indexw( wbegin-1+newfst )
                             else
                                p = indexw( wbegin-1+newlst )
                             endif
                             offset = indexw( wbegin ) - 1
                             call stdlib_${c2ri(ci)}$larrb( in, d(ibegin),work( indlld+ibegin-1 ),p,p,rqtol, &
                             rqtol, offset,work(wbegin),wgap(wbegin),werr(wbegin),work( indwrk ),&
                                       iwork( iindwk ), pivmin, spdiam,in, iinfo )
                          end do
                          if((wbegin+newlst-1<dol).or.(wbegin+newfst-1>dou)) then
                             ! if the cluster contains no desired eigenvalues
                             ! skip the computation of that branch of the rep. tree
                             ! we could skip before the refinement of the extremal
                             ! eigenvalues of the child, but then the representation
                             ! tree could be different from the one when nothing is
                             ! skipped. for this reason we skip at this place.
                             idone = idone + newlst - newfst + 1
                             goto 139
                          endif
                          ! compute rrr of child cluster.
                          ! note that the new rrr is stored in z
                          ! stdlib_${c2ri(ci)}$larrf needs lwork = 2*n
                          call stdlib_${c2ri(ci)}$larrf( in, d( ibegin ), l( ibegin ),work(indld+ibegin-1),&
                          newfst, newlst, work(wbegin),wgap(wbegin), werr(wbegin),spdiam, lgap, &
                          rgap, pivmin, tau,work( indin1 ), work( indin2 ),work( indwrk ), iinfo )
                                    
                          ! in the complex case, stdlib_${c2ri(ci)}$larrf cannot write
                          ! the new rrr directly into z and needs an intermediate
                          ! workspace
                          do k = 1, in-1
                             z( ibegin+k-1, newftt ) =cmplx( work( indin1+k-1 ), zero,KIND=${ck}$)
                                       
                             z( ibegin+k-1, newftt+1 ) =cmplx( work( indin2+k-1 ), zero,KIND=${ck}$)
                                       
                          end do
                          z( iend, newftt ) =cmplx( work( indin1+in-1 ), zero,KIND=${ck}$)
                          if( iinfo==0 ) then
                             ! a new rrr for the cluster was found by stdlib_${c2ri(ci)}$larrf
                             ! update shift and store it
                             ssigma = sigma + tau
                             z( iend, newftt+1 ) = cmplx( ssigma, zero,KIND=${ck}$)
                             ! work() are the midpoints and werr() the semi-width
                             ! note that the entries in w are unchanged.
                             do k = newfst, newlst
                                fudge =three*eps*abs(work(wbegin+k-1))
                                work( wbegin + k - 1 ) =work( wbegin + k - 1) - tau
                                fudge = fudge +four*eps*abs(work(wbegin+k-1))
                                ! fudge errors
                                werr( wbegin + k - 1 ) =werr( wbegin + k - 1 ) + fudge
                                ! gaps are not fudged. provided that werr is small
                                ! when eigenvalues are close, a zero gap indicates
                                ! that a new representation is needed for resolving
                                ! the cluster. a fudge could lead to a wrong decision
                                ! of judging eigenvalues 'separated' which in
                                ! reality are not. this could have a negative impact
                                ! on the orthogonality of the computed eigenvectors.
                             end do
                             nclus = nclus + 1
                             k = newcls + 2*nclus
                             iwork( k-1 ) = newfst
                             iwork( k ) = newlst
                          else
                             info = -2
                             return
                          endif
                       else
                          ! compute eigenvector of singleton
                          iter = 0
                          tol = four * log(real(in,KIND=${ck}$)) * eps
                          k = newfst
                          windex = wbegin + k - 1
                          windmn = max(windex - 1,1)
                          windpl = min(windex + 1,m)
                          lambda = work( windex )
                          done = done + 1
                          ! check if eigenvector computation is to be skipped
                          if((windex<dol).or.(windex>dou)) then
                             eskip = .true.
                             goto 125
                          else
                             eskip = .false.
                          endif
                          left = work( windex ) - werr( windex )
                          right = work( windex ) + werr( windex )
                          indeig = indexw( windex )
                          ! note that since we compute the eigenpairs for a child,
                          ! all eigenvalue approximations are w.r.t the same shift.
                          ! in this case, the entries in work should be used for
                          ! computing the gaps since they exhibit even very small
                          ! differences in the eigenvalues, as opposed to the
                          ! entries in w which might "look" the same.
                          if( k == 1) then
                             ! in the case range='i' and with not much initial
                             ! accuracy in lambda and vl, the formula
                             ! lgap = max( zero, (sigma - vl) + lambda )
                             ! can lead to an overestimation of the left gap and
                             ! thus to inadequately early rqi 'convergence'.
                             ! prevent this by forcing a small left gap.
                             lgap = eps*max(abs(left),abs(right))
                          else
                             lgap = wgap(windmn)
                          endif
                          if( k == im) then
                             ! in the case range='i' and with not much initial
                             ! accuracy in lambda and vu, the formula
                             ! can lead to an overestimation of the right gap and
                             ! thus to inadequately early rqi 'convergence'.
                             ! prevent this by forcing a small right gap.
                             rgap = eps*max(abs(left),abs(right))
                          else
                             rgap = wgap(windex)
                          endif
                          gap = min( lgap, rgap )
                          if(( k == 1).or.(k == im)) then
                             ! the eigenvector support can become wrong
                             ! because significant entries could be cut off due to a
                             ! large gaptol parameter in lar1v. prevent this.
                             gaptol = zero
                          else
                             gaptol = gap * eps
                          endif
                          isupmn = in
                          isupmx = 1
                          ! update wgap so that it holds the minimum gap
                          ! to the left or the right. this is crucial in the
                          ! case where bisection is used to ensure that the
                          ! eigenvalue is refined up to the required precision.
                          ! the correct value is restored afterwards.
                          savgap = wgap(windex)
                          wgap(windex) = gap
                          ! we want to use the rayleigh quotient correction
                          ! as often as possible since it converges quadratically
                          ! when we are close enough to the desired eigenvalue.
                          ! however, the rayleigh quotient can have the wrong sign
                          ! and lead us away from the desired eigenvalue. in this
                          ! case, the best we can do is to use bisection.
                          usedbs = .false.
                          usedrq = .false.
                          ! bisection is initially turned off unless it is forced
                          needbs =  .not.tryrqc
                          120 continue
                          ! check if bisection should be used to refine eigenvalue
                          if(needbs) then
                             ! take the bisection as new iterate
                             usedbs = .true.
                             itmp1 = iwork( iindr+windex )
                             offset = indexw( wbegin ) - 1
                             call stdlib_${c2ri(ci)}$larrb( in, d(ibegin),work(indlld+ibegin-1),indeig,&
                             indeig,zero, two*eps, offset,work(wbegin),wgap(wbegin),werr(wbegin),&
                                       work( indwrk ),iwork( iindwk ), pivmin, spdiam,itmp1, iinfo )
                             if( iinfo/=0 ) then
                                info = -3
                                return
                             endif
                             lambda = work( windex )
                             ! reset twist index from inaccurate lambda to
                             ! force computation of true mingma
                             iwork( iindr+windex ) = 0
                          endif
                          ! given lambda, compute the eigenvector.
                          call stdlib_${ci}$lar1v( in, 1, in, lambda, d( ibegin ),l( ibegin ), work(&
                          indld+ibegin-1),work(indlld+ibegin-1),pivmin, gaptol, z( ibegin, windex &
                          ),.not.usedbs, negcnt, ztz, mingma,iwork( iindr+windex ), isuppz( &
                                    2*windex-1 ),nrminv, resid, rqcorr, work( indwrk ) )
                          if(iter == 0) then
                             bstres = resid
                             bstw = lambda
                          elseif(resid<bstres) then
                             bstres = resid
                             bstw = lambda
                          endif
                          isupmn = min(isupmn,isuppz( 2*windex-1 ))
                          isupmx = max(isupmx,isuppz( 2*windex ))
                          iter = iter + 1
                          ! sin alpha <= |resid|/gap
                          ! note that both the residual and the gap are
                          ! proportional to the matrix, so ||t|| doesn't play
                          ! a role in the quotient
                          ! convergence test for rayleigh-quotient iteration
                          ! (omitted when bisection has been used)
                          if( resid>tol*gap .and. abs( rqcorr )>rqtol*abs( lambda ) .and. .not. &
                                    usedbs)then
                             ! we need to check that the rqcorr update doesn't
                             ! move the eigenvalue away from the desired one and
                             ! towards a neighbor. -> protection with bisection
                             if(indeig<=negcnt) then
                                ! the wanted eigenvalue lies to the left
                                sgndef = -one
                             else
                                ! the wanted eigenvalue lies to the right
                                sgndef = one
                             endif
                             ! we only use the rqcorr if it improves the
                             ! the iterate reasonably.
                             if( ( rqcorr*sgndef>=zero ).and.( lambda + rqcorr<= right).and.( &
                                       lambda + rqcorr>= left)) then
                                usedrq = .true.
                                ! store new midpoint of bisection interval in work
                                if(sgndef==one) then
                                   ! the current lambda is on the left of the true
                                   ! eigenvalue
                                   left = lambda
                                   ! we prefer to assume that the error estimate
                                   ! is correct. we could make the interval not
                                   ! as a bracket but to be modified if the rqcorr
                                   ! chooses to. in this case, the right side should
                                   ! be modified as follows:
                                    ! right = max(right, lambda + rqcorr)
                                else
                                   ! the current lambda is on the right of the true
                                   ! eigenvalue
                                   right = lambda
                                   ! see comment about assuming the error estimate is
                                   ! correct above.
                                    ! left = min(left, lambda + rqcorr)
                                endif
                                work( windex ) =half * (right + left)
                                ! take rqcorr since it has the correct sign and
                                ! improves the iterate reasonably
                                lambda = lambda + rqcorr
                                ! update width of error interval
                                werr( windex ) =half * (right-left)
                             else
                                needbs = .true.
                             endif
                             if(right-left<rqtol*abs(lambda)) then
                                   ! the eigenvalue is computed to bisection accuracy
                                   ! compute eigenvector and stop
                                usedbs = .true.
                                goto 120
                             elseif( iter<maxitr ) then
                                goto 120
                             elseif( iter==maxitr ) then
                                needbs = .true.
                                goto 120
                             else
                                info = 5
                                return
                             end if
                          else
                             stp2ii = .false.
             if(usedrq .and. usedbs .and.bstres<=resid) then
                                lambda = bstw
                                stp2ii = .true.
                             endif
                             if (stp2ii) then
                                ! improve error angle by second step
                                call stdlib_${ci}$lar1v( in, 1, in, lambda,d( ibegin ), l( ibegin ),&
                                work(indld+ibegin-1),work(indlld+ibegin-1),pivmin, gaptol, z( &
                                ibegin, windex ),.not.usedbs, negcnt, ztz, mingma,iwork( iindr+&
                                windex ),isuppz( 2*windex-1 ),nrminv, resid, rqcorr, work( indwrk &
                                          ) )
                             endif
                             work( windex ) = lambda
                          end if
                          ! compute fp-vector support w.r.t. whole matrix
                          isuppz( 2*windex-1 ) = isuppz( 2*windex-1 )+oldien
                          isuppz( 2*windex ) = isuppz( 2*windex )+oldien
                          zfrom = isuppz( 2*windex-1 )
                          zto = isuppz( 2*windex )
                          isupmn = isupmn + oldien
                          isupmx = isupmx + oldien
                          ! ensure vector is ok if support in the rqi has changed
                          if(isupmn<zfrom) then
                             do ii = isupmn,zfrom-1
                                z( ii, windex ) = zero
                             end do
                          endif
                          if(isupmx>zto) then
                             do ii = zto+1,isupmx
                                z( ii, windex ) = zero
                             end do
                          endif
                          call stdlib_${ci}$dscal( zto-zfrom+1, nrminv,z( zfrom, windex ), 1 )
                          125 continue
                          ! update w
                          w( windex ) = lambda+sigma
                          ! recompute the gaps on the left and right
                          ! but only allow them to become larger and not
                          ! smaller (which can only happen through "bad"
                          ! cancellation and doesn't reflect the theory
                          ! where the initial gaps are underestimated due
                          ! to werr being too crude.)
                          if(.not.eskip) then
                             if( k>1) then
                                wgap( windmn ) = max( wgap(windmn),w(windex)-werr(windex)- w(&
                                          windmn)-werr(windmn) )
                             endif
                             if( windex<wend ) then
                                wgap( windex ) = max( savgap,w( windpl )-werr( windpl )- w( &
                                          windex )-werr( windex) )
                             endif
                          endif
                          idone = idone + 1
                       endif
                       ! here ends the code for the current child
                       139 continue
                       ! proceed to any remaining child nodes
                       newfst = j + 1
                    end do loop_140
                 end do loop_150
                 ndepth = ndepth + 1
                 go to 40
              end if
              ibegin = iend + 1
              wbegin = wend + 1
           end do loop_170
           return
     end subroutine stdlib_${ci}$larrv

#:endif
#:endfor





     pure subroutine stdlib_ssytrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
     !! SSYTRD reduces a real symmetric matrix A to real symmetric
     !! tridiagonal form T by an orthogonal similarity transformation:
     !! Q**T * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: d(*), e(*), tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, iws, j, kk, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -9
           end if
           if( info==0 ) then
              ! determine the block size.
              nb = stdlib_ilaenv( 1, 'SSYTRD', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYTRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           nx = n
           iws = 1
           if( nb>1 .and. nb<n ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code).
              nx = max( nb, stdlib_ilaenv( 3, 'SSYTRD', uplo, n, -1, -1, -1 ) )
              if( nx<n ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = n
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code by setting nx = n.
                    nb = max( lwork / ldwork, 1 )
                    nbmin = stdlib_ilaenv( 2, 'SSYTRD', uplo, n, -1, -1, -1 )
                    if( nb<nbmin )nx = n
                 end if
              else
                 nx = n
              end if
           else
              nb = 1
           end if
           if( upper ) then
              ! reduce the upper triangle of a.
              ! columns 1:kk are handled by the unblocked method.
              kk = n - ( ( n-nx+nb-1 ) / nb )*nb
              do i = n - nb + 1, kk + 1, -nb
                 ! reduce columns i:i+nb-1 to tridiagonal form and form the
                 ! matrix w which is needed to update the unreduced part of
                 ! the matrix
                 call stdlib_slatrd( uplo, i+nb-1, nb, a, lda, e, tau, work,ldwork )
                 ! update the unreduced submatrix a(1:i-1,1:i-1), using an
                 ! update of the form:  a := a - v*w**t - w*v**t
                 call stdlib_ssyr2k( uplo, 'NO TRANSPOSE', i-1, nb, -one, a( 1, i ),lda, work, &
                           ldwork, one, a, lda )
                 ! copy superdiagonal elements back into a, and diagonal
                 ! elements into d
                 do j = i, i + nb - 1
                    a( j-1, j ) = e( j-1 )
                    d( j ) = a( j, j )
                 end do
              end do
              ! use unblocked code to reduce the last or only block
              call stdlib_ssytd2( uplo, kk, a, lda, d, e, tau, iinfo )
           else
              ! reduce the lower triangle of a
              do i = 1, n - nx, nb
                 ! reduce columns i:i+nb-1 to tridiagonal form and form the
                 ! matrix w which is needed to update the unreduced part of
                 ! the matrix
                 call stdlib_slatrd( uplo, n-i+1, nb, a( i, i ), lda, e( i ),tau( i ), work, &
                           ldwork )
                 ! update the unreduced submatrix a(i+ib:n,i+ib:n), using
                 ! an update of the form:  a := a - v*w**t - w*v**t
                 call stdlib_ssyr2k( uplo, 'NO TRANSPOSE', n-i-nb+1, nb, -one,a( i+nb, i ), lda, &
                           work( nb+1 ), ldwork, one,a( i+nb, i+nb ), lda )
                 ! copy subdiagonal elements back into a, and diagonal
                 ! elements into d
                 do j = i, i + nb - 1
                    a( j+1, j ) = e( j )
                    d( j ) = a( j, j )
                 end do
              end do
              ! use unblocked code to reduce the last or only block
              call stdlib_ssytd2( uplo, n-i+1, a( i, i ), lda, d( i ), e( i ),tau( i ), iinfo )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_ssytrd

     pure subroutine stdlib_dsytrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
     !! DSYTRD reduces a real symmetric matrix A to real symmetric
     !! tridiagonal form T by an orthogonal similarity transformation:
     !! Q**T * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: d(*), e(*), tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, iws, j, kk, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -9
           end if
           if( info==0 ) then
              ! determine the block size.
              nb = stdlib_ilaenv( 1, 'DSYTRD', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           nx = n
           iws = 1
           if( nb>1 .and. nb<n ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code).
              nx = max( nb, stdlib_ilaenv( 3, 'DSYTRD', uplo, n, -1, -1, -1 ) )
              if( nx<n ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = n
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code by setting nx = n.
                    nb = max( lwork / ldwork, 1 )
                    nbmin = stdlib_ilaenv( 2, 'DSYTRD', uplo, n, -1, -1, -1 )
                    if( nb<nbmin )nx = n
                 end if
              else
                 nx = n
              end if
           else
              nb = 1
           end if
           if( upper ) then
              ! reduce the upper triangle of a.
              ! columns 1:kk are handled by the unblocked method.
              kk = n - ( ( n-nx+nb-1 ) / nb )*nb
              do i = n - nb + 1, kk + 1, -nb
                 ! reduce columns i:i+nb-1 to tridiagonal form and form the
                 ! matrix w which is needed to update the unreduced part of
                 ! the matrix
                 call stdlib_dlatrd( uplo, i+nb-1, nb, a, lda, e, tau, work,ldwork )
                 ! update the unreduced submatrix a(1:i-1,1:i-1), using an
                 ! update of the form:  a := a - v*w**t - w*v**t
                 call stdlib_dsyr2k( uplo, 'NO TRANSPOSE', i-1, nb, -one, a( 1, i ),lda, work, &
                           ldwork, one, a, lda )
                 ! copy superdiagonal elements back into a, and diagonal
                 ! elements into d
                 do j = i, i + nb - 1
                    a( j-1, j ) = e( j-1 )
                    d( j ) = a( j, j )
                 end do
              end do
              ! use unblocked code to reduce the last or only block
              call stdlib_dsytd2( uplo, kk, a, lda, d, e, tau, iinfo )
           else
              ! reduce the lower triangle of a
              do i = 1, n - nx, nb
                 ! reduce columns i:i+nb-1 to tridiagonal form and form the
                 ! matrix w which is needed to update the unreduced part of
                 ! the matrix
                 call stdlib_dlatrd( uplo, n-i+1, nb, a( i, i ), lda, e( i ),tau( i ), work, &
                           ldwork )
                 ! update the unreduced submatrix a(i+ib:n,i+ib:n), using
                 ! an update of the form:  a := a - v*w**t - w*v**t
                 call stdlib_dsyr2k( uplo, 'NO TRANSPOSE', n-i-nb+1, nb, -one,a( i+nb, i ), lda, &
                           work( nb+1 ), ldwork, one,a( i+nb, i+nb ), lda )
                 ! copy subdiagonal elements back into a, and diagonal
                 ! elements into d
                 do j = i, i + nb - 1
                    a( j+1, j ) = e( j )
                    d( j ) = a( j, j )
                 end do
              end do
              ! use unblocked code to reduce the last or only block
              call stdlib_dsytd2( uplo, n-i+1, a( i, i ), lda, d( i ), e( i ),tau( i ), iinfo )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dsytrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$sytrd( uplo, n, a, lda, d, e, tau, work, lwork, info )
     !! DSYTRD: reduces a real symmetric matrix A to real symmetric
     !! tridiagonal form T by an orthogonal similarity transformation:
     !! Q**T * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: d(*), e(*), tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, iws, j, kk, ldwork, lwkopt, nb, nbmin, nx
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<1 .and. .not.lquery ) then
              info = -9
           end if
           if( info==0 ) then
              ! determine the block size.
              nb = stdlib_ilaenv( 1, 'DSYTRD', uplo, n, -1, -1, -1 )
              lwkopt = n*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYTRD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           nx = n
           iws = 1
           if( nb>1 .and. nb<n ) then
              ! determine when to cross over from blocked to unblocked code
              ! (last block is always handled by unblocked code).
              nx = max( nb, stdlib_ilaenv( 3, 'DSYTRD', uplo, n, -1, -1, -1 ) )
              if( nx<n ) then
                 ! determine if workspace is large enough for blocked code.
                 ldwork = n
                 iws = ldwork*nb
                 if( lwork<iws ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code by setting nx = n.
                    nb = max( lwork / ldwork, 1 )
                    nbmin = stdlib_ilaenv( 2, 'DSYTRD', uplo, n, -1, -1, -1 )
                    if( nb<nbmin )nx = n
                 end if
              else
                 nx = n
              end if
           else
              nb = 1
           end if
           if( upper ) then
              ! reduce the upper triangle of a.
              ! columns 1:kk are handled by the unblocked method.
              kk = n - ( ( n-nx+nb-1 ) / nb )*nb
              do i = n - nb + 1, kk + 1, -nb
                 ! reduce columns i:i+nb-1 to tridiagonal form and form the
                 ! matrix w which is needed to update the unreduced part of
                 ! the matrix
                 call stdlib_${ri}$latrd( uplo, i+nb-1, nb, a, lda, e, tau, work,ldwork )
                 ! update the unreduced submatrix a(1:i-1,1:i-1), using an
                 ! update of the form:  a := a - v*w**t - w*v**t
                 call stdlib_${ri}$syr2k( uplo, 'NO TRANSPOSE', i-1, nb, -one, a( 1, i ),lda, work, &
                           ldwork, one, a, lda )
                 ! copy superdiagonal elements back into a, and diagonal
                 ! elements into d
                 do j = i, i + nb - 1
                    a( j-1, j ) = e( j-1 )
                    d( j ) = a( j, j )
                 end do
              end do
              ! use unblocked code to reduce the last or only block
              call stdlib_${ri}$sytd2( uplo, kk, a, lda, d, e, tau, iinfo )
           else
              ! reduce the lower triangle of a
              do i = 1, n - nx, nb
                 ! reduce columns i:i+nb-1 to tridiagonal form and form the
                 ! matrix w which is needed to update the unreduced part of
                 ! the matrix
                 call stdlib_${ri}$latrd( uplo, n-i+1, nb, a( i, i ), lda, e( i ),tau( i ), work, &
                           ldwork )
                 ! update the unreduced submatrix a(i+ib:n,i+ib:n), using
                 ! an update of the form:  a := a - v*w**t - w*v**t
                 call stdlib_${ri}$syr2k( uplo, 'NO TRANSPOSE', n-i-nb+1, nb, -one,a( i+nb, i ), lda, &
                           work( nb+1 ), ldwork, one,a( i+nb, i+nb ), lda )
                 ! copy subdiagonal elements back into a, and diagonal
                 ! elements into d
                 do j = i, i + nb - 1
                    a( j+1, j ) = e( j )
                    d( j ) = a( j, j )
                 end do
              end do
              ! use unblocked code to reduce the last or only block
              call stdlib_${ri}$sytd2( uplo, n-i+1, a( i, i ), lda, d( i ), e( i ),tau( i ), iinfo )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sytrd

#:endif
#:endfor





     pure subroutine stdlib_slaed4( n, i, d, z, delta, rho, dlam, info )
     !! This subroutine computes the I-th updated eigenvalue of a symmetric
     !! rank-one modification to a diagonal matrix whose elements are
     !! given in the array d, and that
     !! D(i) < D(j)  for  i < j
     !! and that RHO > 0.  This is arranged by the calling routine, and is
     !! no loss in generality.  The rank-one modified system is thus
     !! diag( D )  +  RHO * Z * Z_transpose.
     !! where we assume the Euclidean norm of Z is 1.
     !! The method consists of approximating the rational functions in the
     !! secular equation by simpler interpolating rational functions.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: i, n
           integer(ilp), intent(out) :: info
           real(sp), intent(out) :: dlam
           real(sp), intent(in) :: rho
           ! Array Arguments 
           real(sp), intent(in) :: d(*), z(*)
           real(sp), intent(out) :: delta(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 30
           
           
           ! Local Scalars 
           logical(lk) :: orgati, swtch, swtch3
           integer(ilp) :: ii, iim1, iip1, ip1, iter, j, niter
           real(sp) :: a, b, c, del, dltlb, dltub, dphi, dpsi, dw, eps, erretm, eta, midpt, phi, &
                     prew, psi, rhoinv, tau, temp, temp1, w
           ! Local Arrays 
           real(sp) :: zz(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! since this routine is called in an inner loop, we do no argument
           ! checking.
           ! quick return for n=1 and 2.
           info = 0
           if( n==1 ) then
               ! presumably, i=1 upon entry
              dlam = d( 1 ) + rho*z( 1 )*z( 1 )
              delta( 1 ) = one
              return
           end if
           if( n==2 ) then
              call stdlib_slaed5( i, d, z, delta, rho, dlam )
              return
           end if
           ! compute machine epsilon
           eps = stdlib_slamch( 'EPSILON' )
           rhoinv = one / rho
           ! the case i = n
           if( i==n ) then
              ! initialize some basic variables
              ii = n - 1
              niter = 1
              ! calculate initial guess
              midpt = rho / two
              ! if ||z||_2 is not one, then temp should be set to
              ! rho * ||z||_2^2 / two
              do j = 1, n
                 delta( j ) = ( d( j )-d( i ) ) - midpt
              end do
              psi = zero
              do j = 1, n - 2
                 psi = psi + z( j )*z( j ) / delta( j )
              end do
              c = rhoinv + psi
              w = c + z( ii )*z( ii ) / delta( ii ) +z( n )*z( n ) / delta( n )
              if( w<=zero ) then
                 temp = z( n-1 )*z( n-1 ) / ( d( n )-d( n-1 )+rho ) +z( n )*z( n ) / rho
                 if( c<=temp ) then
                    tau = rho
                 else
                    del = d( n ) - d( n-1 )
                    a = -c*del + z( n-1 )*z( n-1 ) + z( n )*z( n )
                    b = z( n )*z( n )*del
                    if( a<zero ) then
                       tau = two*b / ( sqrt( a*a+four*b*c )-a )
                    else
                       tau = ( a+sqrt( a*a+four*b*c ) ) / ( two*c )
                    end if
                 end if
                 ! it can be proved that
                     ! d(n)+rho/2 <= lambda(n) < d(n)+tau <= d(n)+rho
                 dltlb = midpt
                 dltub = rho
              else
                 del = d( n ) - d( n-1 )
                 a = -c*del + z( n-1 )*z( n-1 ) + z( n )*z( n )
                 b = z( n )*z( n )*del
                 if( a<zero ) then
                    tau = two*b / ( sqrt( a*a+four*b*c )-a )
                 else
                    tau = ( a+sqrt( a*a+four*b*c ) ) / ( two*c )
                 end if
                 ! it can be proved that
                     ! d(n) < d(n)+tau < lambda(n) < d(n)+rho/2
                 dltlb = zero
                 dltub = midpt
              end if
              do j = 1, n
                 delta( j ) = ( d( j )-d( i ) ) - tau
              end do
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, ii
                 temp = z( j ) / delta( j )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              temp = z( n ) / delta( n )
              phi = z( n )*temp
              dphi = temp*temp
              erretm = eight*( -phi-psi ) + erretm - phi + rhoinv +abs( tau )*( dpsi+dphi )
                        
              w = rhoinv + phi + psi
              ! test for convergence
              if( abs( w )<=eps*erretm ) then
                 dlam = d( i ) + tau
                 go to 250
              end if
              if( w<=zero ) then
                 dltlb = max( dltlb, tau )
              else
                 dltub = min( dltub, tau )
              end if
              ! calculate the new step
              niter = niter + 1
              c = w - delta( n-1 )*dpsi - delta( n )*dphi
              a = ( delta( n-1 )+delta( n ) )*w -delta( n-1 )*delta( n )*( dpsi+dphi )
              b = delta( n-1 )*delta( n )*w
              if( c<zero )c = abs( c )
              if( c==zero ) then
                ! eta = b/a
                 ! eta = rho - tau
                 eta = dltub - tau
              else if( a>=zero ) then
                 eta = ( a+sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
              else
                 eta = two*b / ( a-sqrt( abs( a*a-four*b*c ) ) )
              end if
              ! note, eta should be positive if w is negative, and
              ! eta should be negative otherwise. however,
              ! if for some reason caused by roundoff, eta*w > 0,
              ! we simply use one newton step instead. this way
              ! will guarantee eta*w < 0.
              if( w*eta>zero )eta = -w / ( dpsi+dphi )
              temp = tau + eta
              if( temp>dltub .or. temp<dltlb ) then
                 if( w<zero ) then
                    eta = ( dltub-tau ) / two
                 else
                    eta = ( dltlb-tau ) / two
                 end if
              end if
              do j = 1, n
                 delta( j ) = delta( j ) - eta
              end do
              tau = tau + eta
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, ii
                 temp = z( j ) / delta( j )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              temp = z( n ) / delta( n )
              phi = z( n )*temp
              dphi = temp*temp
              erretm = eight*( -phi-psi ) + erretm - phi + rhoinv +abs( tau )*( dpsi+dphi )
                        
              w = rhoinv + phi + psi
              ! main loop to update the values of the array   delta
              iter = niter + 1
              loop_90: do niter = iter, maxit
                 ! test for convergence
                 if( abs( w )<=eps*erretm ) then
                    dlam = d( i ) + tau
                    go to 250
                 end if
                 if( w<=zero ) then
                    dltlb = max( dltlb, tau )
                 else
                    dltub = min( dltub, tau )
                 end if
                 ! calculate the new step
                 c = w - delta( n-1 )*dpsi - delta( n )*dphi
                 a = ( delta( n-1 )+delta( n ) )*w -delta( n-1 )*delta( n )*( dpsi+dphi )
                 b = delta( n-1 )*delta( n )*w
                 if( a>=zero ) then
                    eta = ( a+sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                 else
                    eta = two*b / ( a-sqrt( abs( a*a-four*b*c ) ) )
                 end if
                 ! note, eta should be positive if w is negative, and
                 ! eta should be negative otherwise. however,
                 ! if for some reason caused by roundoff, eta*w > 0,
                 ! we simply use one newton step instead. this way
                 ! will guarantee eta*w < 0.
                 if( w*eta>zero )eta = -w / ( dpsi+dphi )
                 temp = tau + eta
                 if( temp>dltub .or. temp<dltlb ) then
                    if( w<zero ) then
                       eta = ( dltub-tau ) / two
                    else
                       eta = ( dltlb-tau ) / two
                    end if
                 end if
                 do j = 1, n
                    delta( j ) = delta( j ) - eta
                 end do
                 tau = tau + eta
                 ! evaluate psi and the derivative dpsi
                 dpsi = zero
                 psi = zero
                 erretm = zero
                 do j = 1, ii
                    temp = z( j ) / delta( j )
                    psi = psi + z( j )*temp
                    dpsi = dpsi + temp*temp
                    erretm = erretm + psi
                 end do
                 erretm = abs( erretm )
                 ! evaluate phi and the derivative dphi
                 temp = z( n ) / delta( n )
                 phi = z( n )*temp
                 dphi = temp*temp
                 erretm = eight*( -phi-psi ) + erretm - phi + rhoinv +abs( tau )*( dpsi+dphi )
                           
                 w = rhoinv + phi + psi
              end do loop_90
              ! return with info = 1, niter = maxit and not converged
              info = 1
              dlam = d( i ) + tau
              go to 250
              ! end for the case i = n
           else
              ! the case for i < n
              niter = 1
              ip1 = i + 1
              ! calculate initial guess
              del = d( ip1 ) - d( i )
              midpt = del / two
              do j = 1, n
                 delta( j ) = ( d( j )-d( i ) ) - midpt
              end do
              psi = zero
              do j = 1, i - 1
                 psi = psi + z( j )*z( j ) / delta( j )
              end do
              phi = zero
              do j = n, i + 2, -1
                 phi = phi + z( j )*z( j ) / delta( j )
              end do
              c = rhoinv + psi + phi
              w = c + z( i )*z( i ) / delta( i ) +z( ip1 )*z( ip1 ) / delta( ip1 )
              if( w>zero ) then
                 ! d(i)< the ith eigenvalue < (d(i)+d(i+1))/2
                 ! we choose d(i) as origin.
                 orgati = .true.
                 a = c*del + z( i )*z( i ) + z( ip1 )*z( ip1 )
                 b = z( i )*z( i )*del
                 if( a>zero ) then
                    tau = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
                 else
                    tau = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                 end if
                 dltlb = zero
                 dltub = midpt
              else
                 ! (d(i)+d(i+1))/2 <= the ith eigenvalue < d(i+1)
                 ! we choose d(i+1) as origin.
                 orgati = .false.
                 a = c*del - z( i )*z( i ) - z( ip1 )*z( ip1 )
                 b = z( ip1 )*z( ip1 )*del
                 if( a<zero ) then
                    tau = two*b / ( a-sqrt( abs( a*a+four*b*c ) ) )
                 else
                    tau = -( a+sqrt( abs( a*a+four*b*c ) ) ) / ( two*c )
                 end if
                 dltlb = -midpt
                 dltub = zero
              end if
              if( orgati ) then
                 do j = 1, n
                    delta( j ) = ( d( j )-d( i ) ) - tau
                 end do
              else
                 do j = 1, n
                    delta( j ) = ( d( j )-d( ip1 ) ) - tau
                 end do
              end if
              if( orgati ) then
                 ii = i
              else
                 ii = i + 1
              end if
              iim1 = ii - 1
              iip1 = ii + 1
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, iim1
                 temp = z( j ) / delta( j )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              dphi = zero
              phi = zero
              do j = n, iip1, -1
                 temp = z( j ) / delta( j )
                 phi = phi + z( j )*temp
                 dphi = dphi + temp*temp
                 erretm = erretm + phi
              end do
              w = rhoinv + phi + psi
              ! w is the value of the secular function with
              ! its ii-th element removed.
              swtch3 = .false.
              if( orgati ) then
                 if( w<zero )swtch3 = .true.
              else
                 if( w>zero )swtch3 = .true.
              end if
              if( ii==1 .or. ii==n )swtch3 = .false.
              temp = z( ii ) / delta( ii )
              dw = dpsi + dphi + temp*temp
              temp = z( ii )*temp
              w = w + temp
              erretm = eight*( phi-psi ) + erretm + two*rhoinv +three*abs( temp ) + abs( tau )&
                        *dw
              ! test for convergence
              if( abs( w )<=eps*erretm ) then
                 if( orgati ) then
                    dlam = d( i ) + tau
                 else
                    dlam = d( ip1 ) + tau
                 end if
                 go to 250
              end if
              if( w<=zero ) then
                 dltlb = max( dltlb, tau )
              else
                 dltub = min( dltub, tau )
              end if
              ! calculate the new step
              niter = niter + 1
              if( .not.swtch3 ) then
                 if( orgati ) then
                    c = w - delta( ip1 )*dw - ( d( i )-d( ip1 ) )*( z( i ) / delta( i ) )&
                              **2
                 else
                    c = w - delta( i )*dw - ( d( ip1 )-d( i ) )*( z( ip1 ) / delta( ip1 ) )&
                              **2
                 end if
                 a = ( delta( i )+delta( ip1 ) )*w -delta( i )*delta( ip1 )*dw
                 b = delta( i )*delta( ip1 )*w
                 if( c==zero ) then
                    if( a==zero ) then
                       if( orgati ) then
                          a = z( i )*z( i ) + delta( ip1 )*delta( ip1 )*( dpsi+dphi )
                       else
                          a = z( ip1 )*z( ip1 ) + delta( i )*delta( i )*( dpsi+dphi )
                       end if
                    end if
                    eta = b / a
                 else if( a<=zero ) then
                    eta = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                 else
                    eta = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
                 end if
              else
                 ! interpolation using three most relevant poles
                 temp = rhoinv + psi + phi
                 if( orgati ) then
                    temp1 = z( iim1 ) / delta( iim1 )
                    temp1 = temp1*temp1
                    c = temp - delta( iip1 )*( dpsi+dphi ) -( d( iim1 )-d( iip1 ) )*temp1
                    zz( 1 ) = z( iim1 )*z( iim1 )
                    zz( 3 ) = delta( iip1 )*delta( iip1 )*( ( dpsi-temp1 )+dphi )
                 else
                    temp1 = z( iip1 ) / delta( iip1 )
                    temp1 = temp1*temp1
                    c = temp - delta( iim1 )*( dpsi+dphi ) -( d( iip1 )-d( iim1 ) )*temp1
                    zz( 1 ) = delta( iim1 )*delta( iim1 )*( dpsi+( dphi-temp1 ) )
                    zz( 3 ) = z( iip1 )*z( iip1 )
                 end if
                 zz( 2 ) = z( ii )*z( ii )
                 call stdlib_slaed6( niter, orgati, c, delta( iim1 ), zz, w, eta,info )
                 if( info/=0 )go to 250
              end if
              ! note, eta should be positive if w is negative, and
              ! eta should be negative otherwise. however,
              ! if for some reason caused by roundoff, eta*w > 0,
              ! we simply use one newton step instead. this way
              ! will guarantee eta*w < 0.
              if( w*eta>=zero )eta = -w / dw
              temp = tau + eta
              if( temp>dltub .or. temp<dltlb ) then
                 if( w<zero ) then
                    eta = ( dltub-tau ) / two
                 else
                    eta = ( dltlb-tau ) / two
                 end if
              end if
              prew = w
              do j = 1, n
                 delta( j ) = delta( j ) - eta
              end do
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, iim1
                 temp = z( j ) / delta( j )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              dphi = zero
              phi = zero
              do j = n, iip1, -1
                 temp = z( j ) / delta( j )
                 phi = phi + z( j )*temp
                 dphi = dphi + temp*temp
                 erretm = erretm + phi
              end do
              temp = z( ii ) / delta( ii )
              dw = dpsi + dphi + temp*temp
              temp = z( ii )*temp
              w = rhoinv + phi + psi + temp
              erretm = eight*( phi-psi ) + erretm + two*rhoinv +three*abs( temp ) + abs( tau+eta )&
                        *dw
              swtch = .false.
              if( orgati ) then
                 if( -w>abs( prew ) / ten )swtch = .true.
              else
                 if( w>abs( prew ) / ten )swtch = .true.
              end if
              tau = tau + eta
              ! main loop to update the values of the array   delta
              iter = niter + 1
              loop_240: do niter = iter, maxit
                 ! test for convergence
                 if( abs( w )<=eps*erretm ) then
                    if( orgati ) then
                       dlam = d( i ) + tau
                    else
                       dlam = d( ip1 ) + tau
                    end if
                    go to 250
                 end if
                 if( w<=zero ) then
                    dltlb = max( dltlb, tau )
                 else
                    dltub = min( dltub, tau )
                 end if
                 ! calculate the new step
                 if( .not.swtch3 ) then
                    if( .not.swtch ) then
                       if( orgati ) then
                          c = w - delta( ip1 )*dw -( d( i )-d( ip1 ) )*( z( i ) / delta( i ) )&
                                    **2
                       else
                          c = w - delta( i )*dw - ( d( ip1 )-d( i ) )*( z( ip1 ) / delta( ip1 ) )&
                                    **2
                       end if
                    else
                       temp = z( ii ) / delta( ii )
                       if( orgati ) then
                          dpsi = dpsi + temp*temp
                       else
                          dphi = dphi + temp*temp
                       end if
                       c = w - delta( i )*dpsi - delta( ip1 )*dphi
                    end if
                    a = ( delta( i )+delta( ip1 ) )*w -delta( i )*delta( ip1 )*dw
                    b = delta( i )*delta( ip1 )*w
                    if( c==zero ) then
                       if( a==zero ) then
                          if( .not.swtch ) then
                             if( orgati ) then
                                a = z( i )*z( i ) + delta( ip1 )*delta( ip1 )*( dpsi+dphi )
                                          
                             else
                                a = z( ip1 )*z( ip1 ) +delta( i )*delta( i )*( dpsi+dphi )
                             end if
                          else
                             a = delta( i )*delta( i )*dpsi +delta( ip1 )*delta( ip1 )&
                                       *dphi
                          end if
                       end if
                       eta = b / a
                    else if( a<=zero ) then
                       eta = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                    else
                       eta = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
                    end if
                 else
                    ! interpolation using three most relevant poles
                    temp = rhoinv + psi + phi
                    if( swtch ) then
                       c = temp - delta( iim1 )*dpsi - delta( iip1 )*dphi
                       zz( 1 ) = delta( iim1 )*delta( iim1 )*dpsi
                       zz( 3 ) = delta( iip1 )*delta( iip1 )*dphi
                    else
                       if( orgati ) then
                          temp1 = z( iim1 ) / delta( iim1 )
                          temp1 = temp1*temp1
                          c = temp - delta( iip1 )*( dpsi+dphi ) -( d( iim1 )-d( iip1 ) )&
                                    *temp1
                          zz( 1 ) = z( iim1 )*z( iim1 )
                          zz( 3 ) = delta( iip1 )*delta( iip1 )*( ( dpsi-temp1 )+dphi )
                       else
                          temp1 = z( iip1 ) / delta( iip1 )
                          temp1 = temp1*temp1
                          c = temp - delta( iim1 )*( dpsi+dphi ) -( d( iip1 )-d( iim1 ) )&
                                    *temp1
                          zz( 1 ) = delta( iim1 )*delta( iim1 )*( dpsi+( dphi-temp1 ) )
                          zz( 3 ) = z( iip1 )*z( iip1 )
                       end if
                    end if
                    call stdlib_slaed6( niter, orgati, c, delta( iim1 ), zz, w, eta,info )
                    if( info/=0 )go to 250
                 end if
                 ! note, eta should be positive if w is negative, and
                 ! eta should be negative otherwise. however,
                 ! if for some reason caused by roundoff, eta*w > 0,
                 ! we simply use one newton step instead. this way
                 ! will guarantee eta*w < 0.
                 if( w*eta>=zero )eta = -w / dw
                 temp = tau + eta
                 if( temp>dltub .or. temp<dltlb ) then
                    if( w<zero ) then
                       eta = ( dltub-tau ) / two
                    else
                       eta = ( dltlb-tau ) / two
                    end if
                 end if
                 do j = 1, n
                    delta( j ) = delta( j ) - eta
                 end do
                 tau = tau + eta
                 prew = w
                 ! evaluate psi and the derivative dpsi
                 dpsi = zero
                 psi = zero
                 erretm = zero
                 do j = 1, iim1
                    temp = z( j ) / delta( j )
                    psi = psi + z( j )*temp
                    dpsi = dpsi + temp*temp
                    erretm = erretm + psi
                 end do
                 erretm = abs( erretm )
                 ! evaluate phi and the derivative dphi
                 dphi = zero
                 phi = zero
                 do j = n, iip1, -1
                    temp = z( j ) / delta( j )
                    phi = phi + z( j )*temp
                    dphi = dphi + temp*temp
                    erretm = erretm + phi
                 end do
                 temp = z( ii ) / delta( ii )
                 dw = dpsi + dphi + temp*temp
                 temp = z( ii )*temp
                 w = rhoinv + phi + psi + temp
                 erretm = eight*( phi-psi ) + erretm + two*rhoinv +three*abs( temp ) + abs( tau )&
                           *dw
                 if( w*prew>zero .and. abs( w )>abs( prew ) / ten )swtch = .not.swtch
              end do loop_240
              ! return with info = 1, niter = maxit and not converged
              info = 1
              if( orgati ) then
                 dlam = d( i ) + tau
              else
                 dlam = d( ip1 ) + tau
              end if
           end if
           250 continue
           return
     end subroutine stdlib_slaed4

     pure subroutine stdlib_dlaed4( n, i, d, z, delta, rho, dlam, info )
     !! This subroutine computes the I-th updated eigenvalue of a symmetric
     !! rank-one modification to a diagonal matrix whose elements are
     !! given in the array d, and that
     !! D(i) < D(j)  for  i < j
     !! and that RHO > 0.  This is arranged by the calling routine, and is
     !! no loss in generality.  The rank-one modified system is thus
     !! diag( D )  +  RHO * Z * Z_transpose.
     !! where we assume the Euclidean norm of Z is 1.
     !! The method consists of approximating the rational functions in the
     !! secular equation by simpler interpolating rational functions.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: i, n
           integer(ilp), intent(out) :: info
           real(dp), intent(out) :: dlam
           real(dp), intent(in) :: rho
           ! Array Arguments 
           real(dp), intent(in) :: d(*), z(*)
           real(dp), intent(out) :: delta(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 30
           
           
           ! Local Scalars 
           logical(lk) :: orgati, swtch, swtch3
           integer(ilp) :: ii, iim1, iip1, ip1, iter, j, niter
           real(dp) :: a, b, c, del, dltlb, dltub, dphi, dpsi, dw, eps, erretm, eta, midpt, phi, &
                     prew, psi, rhoinv, tau, temp, temp1, w
           ! Local Arrays 
           real(dp) :: zz(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! since this routine is called in an inner loop, we do no argument
           ! checking.
           ! quick return for n=1 and 2.
           info = 0
           if( n==1 ) then
               ! presumably, i=1 upon entry
              dlam = d( 1 ) + rho*z( 1 )*z( 1 )
              delta( 1 ) = one
              return
           end if
           if( n==2 ) then
              call stdlib_dlaed5( i, d, z, delta, rho, dlam )
              return
           end if
           ! compute machine epsilon
           eps = stdlib_dlamch( 'EPSILON' )
           rhoinv = one / rho
           ! the case i = n
           if( i==n ) then
              ! initialize some basic variables
              ii = n - 1
              niter = 1
              ! calculate initial guess
              midpt = rho / two
              ! if ||z||_2 is not one, then temp should be set to
              ! rho * ||z||_2^2 / two
              do j = 1, n
                 delta( j ) = ( d( j )-d( i ) ) - midpt
              end do
              psi = zero
              do j = 1, n - 2
                 psi = psi + z( j )*z( j ) / delta( j )
              end do
              c = rhoinv + psi
              w = c + z( ii )*z( ii ) / delta( ii ) +z( n )*z( n ) / delta( n )
              if( w<=zero ) then
                 temp = z( n-1 )*z( n-1 ) / ( d( n )-d( n-1 )+rho ) +z( n )*z( n ) / rho
                 if( c<=temp ) then
                    tau = rho
                 else
                    del = d( n ) - d( n-1 )
                    a = -c*del + z( n-1 )*z( n-1 ) + z( n )*z( n )
                    b = z( n )*z( n )*del
                    if( a<zero ) then
                       tau = two*b / ( sqrt( a*a+four*b*c )-a )
                    else
                       tau = ( a+sqrt( a*a+four*b*c ) ) / ( two*c )
                    end if
                 end if
                 ! it can be proved that
                     ! d(n)+rho/2 <= lambda(n) < d(n)+tau <= d(n)+rho
                 dltlb = midpt
                 dltub = rho
              else
                 del = d( n ) - d( n-1 )
                 a = -c*del + z( n-1 )*z( n-1 ) + z( n )*z( n )
                 b = z( n )*z( n )*del
                 if( a<zero ) then
                    tau = two*b / ( sqrt( a*a+four*b*c )-a )
                 else
                    tau = ( a+sqrt( a*a+four*b*c ) ) / ( two*c )
                 end if
                 ! it can be proved that
                     ! d(n) < d(n)+tau < lambda(n) < d(n)+rho/2
                 dltlb = zero
                 dltub = midpt
              end if
              do j = 1, n
                 delta( j ) = ( d( j )-d( i ) ) - tau
              end do
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, ii
                 temp = z( j ) / delta( j )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              temp = z( n ) / delta( n )
              phi = z( n )*temp
              dphi = temp*temp
              erretm = eight*( -phi-psi ) + erretm - phi + rhoinv +abs( tau )*( dpsi+dphi )
                        
              w = rhoinv + phi + psi
              ! test for convergence
              if( abs( w )<=eps*erretm ) then
                 dlam = d( i ) + tau
                 go to 250
              end if
              if( w<=zero ) then
                 dltlb = max( dltlb, tau )
              else
                 dltub = min( dltub, tau )
              end if
              ! calculate the new step
              niter = niter + 1
              c = w - delta( n-1 )*dpsi - delta( n )*dphi
              a = ( delta( n-1 )+delta( n ) )*w -delta( n-1 )*delta( n )*( dpsi+dphi )
              b = delta( n-1 )*delta( n )*w
              if( c<zero )c = abs( c )
              if( c==zero ) then
                ! eta = b/a
                 ! eta = rho - tau
                 eta = dltub - tau
              else if( a>=zero ) then
                 eta = ( a+sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
              else
                 eta = two*b / ( a-sqrt( abs( a*a-four*b*c ) ) )
              end if
              ! note, eta should be positive if w is negative, and
              ! eta should be negative otherwise. however,
              ! if for some reason caused by roundoff, eta*w > 0,
              ! we simply use one newton step instead. this way
              ! will guarantee eta*w < 0.
              if( w*eta>zero )eta = -w / ( dpsi+dphi )
              temp = tau + eta
              if( temp>dltub .or. temp<dltlb ) then
                 if( w<zero ) then
                    eta = ( dltub-tau ) / two
                 else
                    eta = ( dltlb-tau ) / two
                 end if
              end if
              do j = 1, n
                 delta( j ) = delta( j ) - eta
              end do
              tau = tau + eta
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, ii
                 temp = z( j ) / delta( j )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              temp = z( n ) / delta( n )
              phi = z( n )*temp
              dphi = temp*temp
              erretm = eight*( -phi-psi ) + erretm - phi + rhoinv +abs( tau )*( dpsi+dphi )
                        
              w = rhoinv + phi + psi
              ! main loop to update the values of the array   delta
              iter = niter + 1
              loop_90: do niter = iter, maxit
                 ! test for convergence
                 if( abs( w )<=eps*erretm ) then
                    dlam = d( i ) + tau
                    go to 250
                 end if
                 if( w<=zero ) then
                    dltlb = max( dltlb, tau )
                 else
                    dltub = min( dltub, tau )
                 end if
                 ! calculate the new step
                 c = w - delta( n-1 )*dpsi - delta( n )*dphi
                 a = ( delta( n-1 )+delta( n ) )*w -delta( n-1 )*delta( n )*( dpsi+dphi )
                 b = delta( n-1 )*delta( n )*w
                 if( a>=zero ) then
                    eta = ( a+sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                 else
                    eta = two*b / ( a-sqrt( abs( a*a-four*b*c ) ) )
                 end if
                 ! note, eta should be positive if w is negative, and
                 ! eta should be negative otherwise. however,
                 ! if for some reason caused by roundoff, eta*w > 0,
                 ! we simply use one newton step instead. this way
                 ! will guarantee eta*w < 0.
                 if( w*eta>zero )eta = -w / ( dpsi+dphi )
                 temp = tau + eta
                 if( temp>dltub .or. temp<dltlb ) then
                    if( w<zero ) then
                       eta = ( dltub-tau ) / two
                    else
                       eta = ( dltlb-tau ) / two
                    end if
                 end if
                 do j = 1, n
                    delta( j ) = delta( j ) - eta
                 end do
                 tau = tau + eta
                 ! evaluate psi and the derivative dpsi
                 dpsi = zero
                 psi = zero
                 erretm = zero
                 do j = 1, ii
                    temp = z( j ) / delta( j )
                    psi = psi + z( j )*temp
                    dpsi = dpsi + temp*temp
                    erretm = erretm + psi
                 end do
                 erretm = abs( erretm )
                 ! evaluate phi and the derivative dphi
                 temp = z( n ) / delta( n )
                 phi = z( n )*temp
                 dphi = temp*temp
                 erretm = eight*( -phi-psi ) + erretm - phi + rhoinv +abs( tau )*( dpsi+dphi )
                           
                 w = rhoinv + phi + psi
              end do loop_90
              ! return with info = 1, niter = maxit and not converged
              info = 1
              dlam = d( i ) + tau
              go to 250
              ! end for the case i = n
           else
              ! the case for i < n
              niter = 1
              ip1 = i + 1
              ! calculate initial guess
              del = d( ip1 ) - d( i )
              midpt = del / two
              do j = 1, n
                 delta( j ) = ( d( j )-d( i ) ) - midpt
              end do
              psi = zero
              do j = 1, i - 1
                 psi = psi + z( j )*z( j ) / delta( j )
              end do
              phi = zero
              do j = n, i + 2, -1
                 phi = phi + z( j )*z( j ) / delta( j )
              end do
              c = rhoinv + psi + phi
              w = c + z( i )*z( i ) / delta( i ) +z( ip1 )*z( ip1 ) / delta( ip1 )
              if( w>zero ) then
                 ! d(i)< the ith eigenvalue < (d(i)+d(i+1))/2
                 ! we choose d(i) as origin.
                 orgati = .true.
                 a = c*del + z( i )*z( i ) + z( ip1 )*z( ip1 )
                 b = z( i )*z( i )*del
                 if( a>zero ) then
                    tau = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
                 else
                    tau = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                 end if
                 dltlb = zero
                 dltub = midpt
              else
                 ! (d(i)+d(i+1))/2 <= the ith eigenvalue < d(i+1)
                 ! we choose d(i+1) as origin.
                 orgati = .false.
                 a = c*del - z( i )*z( i ) - z( ip1 )*z( ip1 )
                 b = z( ip1 )*z( ip1 )*del
                 if( a<zero ) then
                    tau = two*b / ( a-sqrt( abs( a*a+four*b*c ) ) )
                 else
                    tau = -( a+sqrt( abs( a*a+four*b*c ) ) ) / ( two*c )
                 end if
                 dltlb = -midpt
                 dltub = zero
              end if
              if( orgati ) then
                 do j = 1, n
                    delta( j ) = ( d( j )-d( i ) ) - tau
                 end do
              else
                 do j = 1, n
                    delta( j ) = ( d( j )-d( ip1 ) ) - tau
                 end do
              end if
              if( orgati ) then
                 ii = i
              else
                 ii = i + 1
              end if
              iim1 = ii - 1
              iip1 = ii + 1
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, iim1
                 temp = z( j ) / delta( j )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              dphi = zero
              phi = zero
              do j = n, iip1, -1
                 temp = z( j ) / delta( j )
                 phi = phi + z( j )*temp
                 dphi = dphi + temp*temp
                 erretm = erretm + phi
              end do
              w = rhoinv + phi + psi
              ! w is the value of the secular function with
              ! its ii-th element removed.
              swtch3 = .false.
              if( orgati ) then
                 if( w<zero )swtch3 = .true.
              else
                 if( w>zero )swtch3 = .true.
              end if
              if( ii==1 .or. ii==n )swtch3 = .false.
              temp = z( ii ) / delta( ii )
              dw = dpsi + dphi + temp*temp
              temp = z( ii )*temp
              w = w + temp
              erretm = eight*( phi-psi ) + erretm + two*rhoinv +three*abs( temp ) + abs( tau )&
                        *dw
              ! test for convergence
              if( abs( w )<=eps*erretm ) then
                 if( orgati ) then
                    dlam = d( i ) + tau
                 else
                    dlam = d( ip1 ) + tau
                 end if
                 go to 250
              end if
              if( w<=zero ) then
                 dltlb = max( dltlb, tau )
              else
                 dltub = min( dltub, tau )
              end if
              ! calculate the new step
              niter = niter + 1
              if( .not.swtch3 ) then
                 if( orgati ) then
                    c = w - delta( ip1 )*dw - ( d( i )-d( ip1 ) )*( z( i ) / delta( i ) )&
                              **2
                 else
                    c = w - delta( i )*dw - ( d( ip1 )-d( i ) )*( z( ip1 ) / delta( ip1 ) )&
                              **2
                 end if
                 a = ( delta( i )+delta( ip1 ) )*w -delta( i )*delta( ip1 )*dw
                 b = delta( i )*delta( ip1 )*w
                 if( c==zero ) then
                    if( a==zero ) then
                       if( orgati ) then
                          a = z( i )*z( i ) + delta( ip1 )*delta( ip1 )*( dpsi+dphi )
                       else
                          a = z( ip1 )*z( ip1 ) + delta( i )*delta( i )*( dpsi+dphi )
                       end if
                    end if
                    eta = b / a
                 else if( a<=zero ) then
                    eta = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                 else
                    eta = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
                 end if
              else
                 ! interpolation using three most relevant poles
                 temp = rhoinv + psi + phi
                 if( orgati ) then
                    temp1 = z( iim1 ) / delta( iim1 )
                    temp1 = temp1*temp1
                    c = temp - delta( iip1 )*( dpsi+dphi ) -( d( iim1 )-d( iip1 ) )*temp1
                    zz( 1 ) = z( iim1 )*z( iim1 )
                    zz( 3 ) = delta( iip1 )*delta( iip1 )*( ( dpsi-temp1 )+dphi )
                 else
                    temp1 = z( iip1 ) / delta( iip1 )
                    temp1 = temp1*temp1
                    c = temp - delta( iim1 )*( dpsi+dphi ) -( d( iip1 )-d( iim1 ) )*temp1
                    zz( 1 ) = delta( iim1 )*delta( iim1 )*( dpsi+( dphi-temp1 ) )
                    zz( 3 ) = z( iip1 )*z( iip1 )
                 end if
                 zz( 2 ) = z( ii )*z( ii )
                 call stdlib_dlaed6( niter, orgati, c, delta( iim1 ), zz, w, eta,info )
                 if( info/=0 )go to 250
              end if
              ! note, eta should be positive if w is negative, and
              ! eta should be negative otherwise. however,
              ! if for some reason caused by roundoff, eta*w > 0,
              ! we simply use one newton step instead. this way
              ! will guarantee eta*w < 0.
              if( w*eta>=zero )eta = -w / dw
              temp = tau + eta
              if( temp>dltub .or. temp<dltlb ) then
                 if( w<zero ) then
                    eta = ( dltub-tau ) / two
                 else
                    eta = ( dltlb-tau ) / two
                 end if
              end if
              prew = w
              do j = 1, n
                 delta( j ) = delta( j ) - eta
              end do
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, iim1
                 temp = z( j ) / delta( j )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              dphi = zero
              phi = zero
              do j = n, iip1, -1
                 temp = z( j ) / delta( j )
                 phi = phi + z( j )*temp
                 dphi = dphi + temp*temp
                 erretm = erretm + phi
              end do
              temp = z( ii ) / delta( ii )
              dw = dpsi + dphi + temp*temp
              temp = z( ii )*temp
              w = rhoinv + phi + psi + temp
              erretm = eight*( phi-psi ) + erretm + two*rhoinv +three*abs( temp ) + abs( tau+eta )&
                        *dw
              swtch = .false.
              if( orgati ) then
                 if( -w>abs( prew ) / ten )swtch = .true.
              else
                 if( w>abs( prew ) / ten )swtch = .true.
              end if
              tau = tau + eta
              ! main loop to update the values of the array   delta
              iter = niter + 1
              loop_240: do niter = iter, maxit
                 ! test for convergence
                 if( abs( w )<=eps*erretm ) then
                    if( orgati ) then
                       dlam = d( i ) + tau
                    else
                       dlam = d( ip1 ) + tau
                    end if
                    go to 250
                 end if
                 if( w<=zero ) then
                    dltlb = max( dltlb, tau )
                 else
                    dltub = min( dltub, tau )
                 end if
                 ! calculate the new step
                 if( .not.swtch3 ) then
                    if( .not.swtch ) then
                       if( orgati ) then
                          c = w - delta( ip1 )*dw -( d( i )-d( ip1 ) )*( z( i ) / delta( i ) )&
                                    **2
                       else
                          c = w - delta( i )*dw - ( d( ip1 )-d( i ) )*( z( ip1 ) / delta( ip1 ) )&
                                    **2
                       end if
                    else
                       temp = z( ii ) / delta( ii )
                       if( orgati ) then
                          dpsi = dpsi + temp*temp
                       else
                          dphi = dphi + temp*temp
                       end if
                       c = w - delta( i )*dpsi - delta( ip1 )*dphi
                    end if
                    a = ( delta( i )+delta( ip1 ) )*w -delta( i )*delta( ip1 )*dw
                    b = delta( i )*delta( ip1 )*w
                    if( c==zero ) then
                       if( a==zero ) then
                          if( .not.swtch ) then
                             if( orgati ) then
                                a = z( i )*z( i ) + delta( ip1 )*delta( ip1 )*( dpsi+dphi )
                                          
                             else
                                a = z( ip1 )*z( ip1 ) +delta( i )*delta( i )*( dpsi+dphi )
                             end if
                          else
                             a = delta( i )*delta( i )*dpsi +delta( ip1 )*delta( ip1 )&
                                       *dphi
                          end if
                       end if
                       eta = b / a
                    else if( a<=zero ) then
                       eta = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                    else
                       eta = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
                    end if
                 else
                    ! interpolation using three most relevant poles
                    temp = rhoinv + psi + phi
                    if( swtch ) then
                       c = temp - delta( iim1 )*dpsi - delta( iip1 )*dphi
                       zz( 1 ) = delta( iim1 )*delta( iim1 )*dpsi
                       zz( 3 ) = delta( iip1 )*delta( iip1 )*dphi
                    else
                       if( orgati ) then
                          temp1 = z( iim1 ) / delta( iim1 )
                          temp1 = temp1*temp1
                          c = temp - delta( iip1 )*( dpsi+dphi ) -( d( iim1 )-d( iip1 ) )&
                                    *temp1
                          zz( 1 ) = z( iim1 )*z( iim1 )
                          zz( 3 ) = delta( iip1 )*delta( iip1 )*( ( dpsi-temp1 )+dphi )
                       else
                          temp1 = z( iip1 ) / delta( iip1 )
                          temp1 = temp1*temp1
                          c = temp - delta( iim1 )*( dpsi+dphi ) -( d( iip1 )-d( iim1 ) )&
                                    *temp1
                          zz( 1 ) = delta( iim1 )*delta( iim1 )*( dpsi+( dphi-temp1 ) )
                          zz( 3 ) = z( iip1 )*z( iip1 )
                       end if
                    end if
                    call stdlib_dlaed6( niter, orgati, c, delta( iim1 ), zz, w, eta,info )
                    if( info/=0 )go to 250
                 end if
                 ! note, eta should be positive if w is negative, and
                 ! eta should be negative otherwise. however,
                 ! if for some reason caused by roundoff, eta*w > 0,
                 ! we simply use one newton step instead. this way
                 ! will guarantee eta*w < 0.
                 if( w*eta>=zero )eta = -w / dw
                 temp = tau + eta
                 if( temp>dltub .or. temp<dltlb ) then
                    if( w<zero ) then
                       eta = ( dltub-tau ) / two
                    else
                       eta = ( dltlb-tau ) / two
                    end if
                 end if
                 do j = 1, n
                    delta( j ) = delta( j ) - eta
                 end do
                 tau = tau + eta
                 prew = w
                 ! evaluate psi and the derivative dpsi
                 dpsi = zero
                 psi = zero
                 erretm = zero
                 do j = 1, iim1
                    temp = z( j ) / delta( j )
                    psi = psi + z( j )*temp
                    dpsi = dpsi + temp*temp
                    erretm = erretm + psi
                 end do
                 erretm = abs( erretm )
                 ! evaluate phi and the derivative dphi
                 dphi = zero
                 phi = zero
                 do j = n, iip1, -1
                    temp = z( j ) / delta( j )
                    phi = phi + z( j )*temp
                    dphi = dphi + temp*temp
                    erretm = erretm + phi
                 end do
                 temp = z( ii ) / delta( ii )
                 dw = dpsi + dphi + temp*temp
                 temp = z( ii )*temp
                 w = rhoinv + phi + psi + temp
                 erretm = eight*( phi-psi ) + erretm + two*rhoinv +three*abs( temp ) + abs( tau )&
                           *dw
                 if( w*prew>zero .and. abs( w )>abs( prew ) / ten )swtch = .not.swtch
              end do loop_240
              ! return with info = 1, niter = maxit and not converged
              info = 1
              if( orgati ) then
                 dlam = d( i ) + tau
              else
                 dlam = d( ip1 ) + tau
              end if
           end if
           250 continue
           return
     end subroutine stdlib_dlaed4

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laed4( n, i, d, z, delta, rho, dlam, info )
     !! This subroutine computes the I-th updated eigenvalue of a symmetric
     !! rank-one modification to a diagonal matrix whose elements are
     !! given in the array d, and that
     !! D(i) < D(j)  for  i < j
     !! and that RHO > 0.  This is arranged by the calling routine, and is
     !! no loss in generality.  The rank-one modified system is thus
     !! diag( D )  +  RHO * Z * Z_transpose.
     !! where we assume the Euclidean norm of Z is 1.
     !! The method consists of approximating the rational functions in the
     !! secular equation by simpler interpolating rational functions.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: i, n
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(out) :: dlam
           real(${rk}$), intent(in) :: rho
           ! Array Arguments 
           real(${rk}$), intent(in) :: d(*), z(*)
           real(${rk}$), intent(out) :: delta(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: maxit = 30
           
           
           ! Local Scalars 
           logical(lk) :: orgati, swtch, swtch3
           integer(ilp) :: ii, iim1, iip1, ip1, iter, j, niter
           real(${rk}$) :: a, b, c, del, dltlb, dltub, dphi, dpsi, dw, eps, erretm, eta, midpt, phi, &
                     prew, psi, rhoinv, tau, temp, temp1, w
           ! Local Arrays 
           real(${rk}$) :: zz(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! since this routine is called in an inner loop, we do no argument
           ! checking.
           ! quick return for n=1 and 2.
           info = 0
           if( n==1 ) then
               ! presumably, i=1 upon entry
              dlam = d( 1 ) + rho*z( 1 )*z( 1 )
              delta( 1 ) = one
              return
           end if
           if( n==2 ) then
              call stdlib_${ri}$laed5( i, d, z, delta, rho, dlam )
              return
           end if
           ! compute machine epsilon
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           rhoinv = one / rho
           ! the case i = n
           if( i==n ) then
              ! initialize some basic variables
              ii = n - 1
              niter = 1
              ! calculate initial guess
              midpt = rho / two
              ! if ||z||_2 is not one, then temp should be set to
              ! rho * ||z||_2^2 / two
              do j = 1, n
                 delta( j ) = ( d( j )-d( i ) ) - midpt
              end do
              psi = zero
              do j = 1, n - 2
                 psi = psi + z( j )*z( j ) / delta( j )
              end do
              c = rhoinv + psi
              w = c + z( ii )*z( ii ) / delta( ii ) +z( n )*z( n ) / delta( n )
              if( w<=zero ) then
                 temp = z( n-1 )*z( n-1 ) / ( d( n )-d( n-1 )+rho ) +z( n )*z( n ) / rho
                 if( c<=temp ) then
                    tau = rho
                 else
                    del = d( n ) - d( n-1 )
                    a = -c*del + z( n-1 )*z( n-1 ) + z( n )*z( n )
                    b = z( n )*z( n )*del
                    if( a<zero ) then
                       tau = two*b / ( sqrt( a*a+four*b*c )-a )
                    else
                       tau = ( a+sqrt( a*a+four*b*c ) ) / ( two*c )
                    end if
                 end if
                 ! it can be proved that
                     ! d(n)+rho/2 <= lambda(n) < d(n)+tau <= d(n)+rho
                 dltlb = midpt
                 dltub = rho
              else
                 del = d( n ) - d( n-1 )
                 a = -c*del + z( n-1 )*z( n-1 ) + z( n )*z( n )
                 b = z( n )*z( n )*del
                 if( a<zero ) then
                    tau = two*b / ( sqrt( a*a+four*b*c )-a )
                 else
                    tau = ( a+sqrt( a*a+four*b*c ) ) / ( two*c )
                 end if
                 ! it can be proved that
                     ! d(n) < d(n)+tau < lambda(n) < d(n)+rho/2
                 dltlb = zero
                 dltub = midpt
              end if
              do j = 1, n
                 delta( j ) = ( d( j )-d( i ) ) - tau
              end do
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, ii
                 temp = z( j ) / delta( j )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              temp = z( n ) / delta( n )
              phi = z( n )*temp
              dphi = temp*temp
              erretm = eight*( -phi-psi ) + erretm - phi + rhoinv +abs( tau )*( dpsi+dphi )
                        
              w = rhoinv + phi + psi
              ! test for convergence
              if( abs( w )<=eps*erretm ) then
                 dlam = d( i ) + tau
                 go to 250
              end if
              if( w<=zero ) then
                 dltlb = max( dltlb, tau )
              else
                 dltub = min( dltub, tau )
              end if
              ! calculate the new step
              niter = niter + 1
              c = w - delta( n-1 )*dpsi - delta( n )*dphi
              a = ( delta( n-1 )+delta( n ) )*w -delta( n-1 )*delta( n )*( dpsi+dphi )
              b = delta( n-1 )*delta( n )*w
              if( c<zero )c = abs( c )
              if( c==zero ) then
                ! eta = b/a
                 ! eta = rho - tau
                 eta = dltub - tau
              else if( a>=zero ) then
                 eta = ( a+sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
              else
                 eta = two*b / ( a-sqrt( abs( a*a-four*b*c ) ) )
              end if
              ! note, eta should be positive if w is negative, and
              ! eta should be negative otherwise. however,
              ! if for some reason caused by roundoff, eta*w > 0,
              ! we simply use one newton step instead. this way
              ! will guarantee eta*w < 0.
              if( w*eta>zero )eta = -w / ( dpsi+dphi )
              temp = tau + eta
              if( temp>dltub .or. temp<dltlb ) then
                 if( w<zero ) then
                    eta = ( dltub-tau ) / two
                 else
                    eta = ( dltlb-tau ) / two
                 end if
              end if
              do j = 1, n
                 delta( j ) = delta( j ) - eta
              end do
              tau = tau + eta
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, ii
                 temp = z( j ) / delta( j )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              temp = z( n ) / delta( n )
              phi = z( n )*temp
              dphi = temp*temp
              erretm = eight*( -phi-psi ) + erretm - phi + rhoinv +abs( tau )*( dpsi+dphi )
                        
              w = rhoinv + phi + psi
              ! main loop to update the values of the array   delta
              iter = niter + 1
              loop_90: do niter = iter, maxit
                 ! test for convergence
                 if( abs( w )<=eps*erretm ) then
                    dlam = d( i ) + tau
                    go to 250
                 end if
                 if( w<=zero ) then
                    dltlb = max( dltlb, tau )
                 else
                    dltub = min( dltub, tau )
                 end if
                 ! calculate the new step
                 c = w - delta( n-1 )*dpsi - delta( n )*dphi
                 a = ( delta( n-1 )+delta( n ) )*w -delta( n-1 )*delta( n )*( dpsi+dphi )
                 b = delta( n-1 )*delta( n )*w
                 if( a>=zero ) then
                    eta = ( a+sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                 else
                    eta = two*b / ( a-sqrt( abs( a*a-four*b*c ) ) )
                 end if
                 ! note, eta should be positive if w is negative, and
                 ! eta should be negative otherwise. however,
                 ! if for some reason caused by roundoff, eta*w > 0,
                 ! we simply use one newton step instead. this way
                 ! will guarantee eta*w < 0.
                 if( w*eta>zero )eta = -w / ( dpsi+dphi )
                 temp = tau + eta
                 if( temp>dltub .or. temp<dltlb ) then
                    if( w<zero ) then
                       eta = ( dltub-tau ) / two
                    else
                       eta = ( dltlb-tau ) / two
                    end if
                 end if
                 do j = 1, n
                    delta( j ) = delta( j ) - eta
                 end do
                 tau = tau + eta
                 ! evaluate psi and the derivative dpsi
                 dpsi = zero
                 psi = zero
                 erretm = zero
                 do j = 1, ii
                    temp = z( j ) / delta( j )
                    psi = psi + z( j )*temp
                    dpsi = dpsi + temp*temp
                    erretm = erretm + psi
                 end do
                 erretm = abs( erretm )
                 ! evaluate phi and the derivative dphi
                 temp = z( n ) / delta( n )
                 phi = z( n )*temp
                 dphi = temp*temp
                 erretm = eight*( -phi-psi ) + erretm - phi + rhoinv +abs( tau )*( dpsi+dphi )
                           
                 w = rhoinv + phi + psi
              end do loop_90
              ! return with info = 1, niter = maxit and not converged
              info = 1
              dlam = d( i ) + tau
              go to 250
              ! end for the case i = n
           else
              ! the case for i < n
              niter = 1
              ip1 = i + 1
              ! calculate initial guess
              del = d( ip1 ) - d( i )
              midpt = del / two
              do j = 1, n
                 delta( j ) = ( d( j )-d( i ) ) - midpt
              end do
              psi = zero
              do j = 1, i - 1
                 psi = psi + z( j )*z( j ) / delta( j )
              end do
              phi = zero
              do j = n, i + 2, -1
                 phi = phi + z( j )*z( j ) / delta( j )
              end do
              c = rhoinv + psi + phi
              w = c + z( i )*z( i ) / delta( i ) +z( ip1 )*z( ip1 ) / delta( ip1 )
              if( w>zero ) then
                 ! d(i)< the ith eigenvalue < (d(i)+d(i+1))/2
                 ! we choose d(i) as origin.
                 orgati = .true.
                 a = c*del + z( i )*z( i ) + z( ip1 )*z( ip1 )
                 b = z( i )*z( i )*del
                 if( a>zero ) then
                    tau = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
                 else
                    tau = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                 end if
                 dltlb = zero
                 dltub = midpt
              else
                 ! (d(i)+d(i+1))/2 <= the ith eigenvalue < d(i+1)
                 ! we choose d(i+1) as origin.
                 orgati = .false.
                 a = c*del - z( i )*z( i ) - z( ip1 )*z( ip1 )
                 b = z( ip1 )*z( ip1 )*del
                 if( a<zero ) then
                    tau = two*b / ( a-sqrt( abs( a*a+four*b*c ) ) )
                 else
                    tau = -( a+sqrt( abs( a*a+four*b*c ) ) ) / ( two*c )
                 end if
                 dltlb = -midpt
                 dltub = zero
              end if
              if( orgati ) then
                 do j = 1, n
                    delta( j ) = ( d( j )-d( i ) ) - tau
                 end do
              else
                 do j = 1, n
                    delta( j ) = ( d( j )-d( ip1 ) ) - tau
                 end do
              end if
              if( orgati ) then
                 ii = i
              else
                 ii = i + 1
              end if
              iim1 = ii - 1
              iip1 = ii + 1
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, iim1
                 temp = z( j ) / delta( j )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              dphi = zero
              phi = zero
              do j = n, iip1, -1
                 temp = z( j ) / delta( j )
                 phi = phi + z( j )*temp
                 dphi = dphi + temp*temp
                 erretm = erretm + phi
              end do
              w = rhoinv + phi + psi
              ! w is the value of the secular function with
              ! its ii-th element removed.
              swtch3 = .false.
              if( orgati ) then
                 if( w<zero )swtch3 = .true.
              else
                 if( w>zero )swtch3 = .true.
              end if
              if( ii==1 .or. ii==n )swtch3 = .false.
              temp = z( ii ) / delta( ii )
              dw = dpsi + dphi + temp*temp
              temp = z( ii )*temp
              w = w + temp
              erretm = eight*( phi-psi ) + erretm + two*rhoinv +three*abs( temp ) + abs( tau )&
                        *dw
              ! test for convergence
              if( abs( w )<=eps*erretm ) then
                 if( orgati ) then
                    dlam = d( i ) + tau
                 else
                    dlam = d( ip1 ) + tau
                 end if
                 go to 250
              end if
              if( w<=zero ) then
                 dltlb = max( dltlb, tau )
              else
                 dltub = min( dltub, tau )
              end if
              ! calculate the new step
              niter = niter + 1
              if( .not.swtch3 ) then
                 if( orgati ) then
                    c = w - delta( ip1 )*dw - ( d( i )-d( ip1 ) )*( z( i ) / delta( i ) )&
                              **2
                 else
                    c = w - delta( i )*dw - ( d( ip1 )-d( i ) )*( z( ip1 ) / delta( ip1 ) )&
                              **2
                 end if
                 a = ( delta( i )+delta( ip1 ) )*w -delta( i )*delta( ip1 )*dw
                 b = delta( i )*delta( ip1 )*w
                 if( c==zero ) then
                    if( a==zero ) then
                       if( orgati ) then
                          a = z( i )*z( i ) + delta( ip1 )*delta( ip1 )*( dpsi+dphi )
                       else
                          a = z( ip1 )*z( ip1 ) + delta( i )*delta( i )*( dpsi+dphi )
                       end if
                    end if
                    eta = b / a
                 else if( a<=zero ) then
                    eta = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                 else
                    eta = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
                 end if
              else
                 ! interpolation using three most relevant poles
                 temp = rhoinv + psi + phi
                 if( orgati ) then
                    temp1 = z( iim1 ) / delta( iim1 )
                    temp1 = temp1*temp1
                    c = temp - delta( iip1 )*( dpsi+dphi ) -( d( iim1 )-d( iip1 ) )*temp1
                    zz( 1 ) = z( iim1 )*z( iim1 )
                    zz( 3 ) = delta( iip1 )*delta( iip1 )*( ( dpsi-temp1 )+dphi )
                 else
                    temp1 = z( iip1 ) / delta( iip1 )
                    temp1 = temp1*temp1
                    c = temp - delta( iim1 )*( dpsi+dphi ) -( d( iip1 )-d( iim1 ) )*temp1
                    zz( 1 ) = delta( iim1 )*delta( iim1 )*( dpsi+( dphi-temp1 ) )
                    zz( 3 ) = z( iip1 )*z( iip1 )
                 end if
                 zz( 2 ) = z( ii )*z( ii )
                 call stdlib_${ri}$laed6( niter, orgati, c, delta( iim1 ), zz, w, eta,info )
                 if( info/=0 )go to 250
              end if
              ! note, eta should be positive if w is negative, and
              ! eta should be negative otherwise. however,
              ! if for some reason caused by roundoff, eta*w > 0,
              ! we simply use one newton step instead. this way
              ! will guarantee eta*w < 0.
              if( w*eta>=zero )eta = -w / dw
              temp = tau + eta
              if( temp>dltub .or. temp<dltlb ) then
                 if( w<zero ) then
                    eta = ( dltub-tau ) / two
                 else
                    eta = ( dltlb-tau ) / two
                 end if
              end if
              prew = w
              do j = 1, n
                 delta( j ) = delta( j ) - eta
              end do
              ! evaluate psi and the derivative dpsi
              dpsi = zero
              psi = zero
              erretm = zero
              do j = 1, iim1
                 temp = z( j ) / delta( j )
                 psi = psi + z( j )*temp
                 dpsi = dpsi + temp*temp
                 erretm = erretm + psi
              end do
              erretm = abs( erretm )
              ! evaluate phi and the derivative dphi
              dphi = zero
              phi = zero
              do j = n, iip1, -1
                 temp = z( j ) / delta( j )
                 phi = phi + z( j )*temp
                 dphi = dphi + temp*temp
                 erretm = erretm + phi
              end do
              temp = z( ii ) / delta( ii )
              dw = dpsi + dphi + temp*temp
              temp = z( ii )*temp
              w = rhoinv + phi + psi + temp
              erretm = eight*( phi-psi ) + erretm + two*rhoinv +three*abs( temp ) + abs( tau+eta )&
                        *dw
              swtch = .false.
              if( orgati ) then
                 if( -w>abs( prew ) / ten )swtch = .true.
              else
                 if( w>abs( prew ) / ten )swtch = .true.
              end if
              tau = tau + eta
              ! main loop to update the values of the array   delta
              iter = niter + 1
              loop_240: do niter = iter, maxit
                 ! test for convergence
                 if( abs( w )<=eps*erretm ) then
                    if( orgati ) then
                       dlam = d( i ) + tau
                    else
                       dlam = d( ip1 ) + tau
                    end if
                    go to 250
                 end if
                 if( w<=zero ) then
                    dltlb = max( dltlb, tau )
                 else
                    dltub = min( dltub, tau )
                 end if
                 ! calculate the new step
                 if( .not.swtch3 ) then
                    if( .not.swtch ) then
                       if( orgati ) then
                          c = w - delta( ip1 )*dw -( d( i )-d( ip1 ) )*( z( i ) / delta( i ) )&
                                    **2
                       else
                          c = w - delta( i )*dw - ( d( ip1 )-d( i ) )*( z( ip1 ) / delta( ip1 ) )&
                                    **2
                       end if
                    else
                       temp = z( ii ) / delta( ii )
                       if( orgati ) then
                          dpsi = dpsi + temp*temp
                       else
                          dphi = dphi + temp*temp
                       end if
                       c = w - delta( i )*dpsi - delta( ip1 )*dphi
                    end if
                    a = ( delta( i )+delta( ip1 ) )*w -delta( i )*delta( ip1 )*dw
                    b = delta( i )*delta( ip1 )*w
                    if( c==zero ) then
                       if( a==zero ) then
                          if( .not.swtch ) then
                             if( orgati ) then
                                a = z( i )*z( i ) + delta( ip1 )*delta( ip1 )*( dpsi+dphi )
                                          
                             else
                                a = z( ip1 )*z( ip1 ) +delta( i )*delta( i )*( dpsi+dphi )
                             end if
                          else
                             a = delta( i )*delta( i )*dpsi +delta( ip1 )*delta( ip1 )&
                                       *dphi
                          end if
                       end if
                       eta = b / a
                    else if( a<=zero ) then
                       eta = ( a-sqrt( abs( a*a-four*b*c ) ) ) / ( two*c )
                    else
                       eta = two*b / ( a+sqrt( abs( a*a-four*b*c ) ) )
                    end if
                 else
                    ! interpolation using three most relevant poles
                    temp = rhoinv + psi + phi
                    if( swtch ) then
                       c = temp - delta( iim1 )*dpsi - delta( iip1 )*dphi
                       zz( 1 ) = delta( iim1 )*delta( iim1 )*dpsi
                       zz( 3 ) = delta( iip1 )*delta( iip1 )*dphi
                    else
                       if( orgati ) then
                          temp1 = z( iim1 ) / delta( iim1 )
                          temp1 = temp1*temp1
                          c = temp - delta( iip1 )*( dpsi+dphi ) -( d( iim1 )-d( iip1 ) )&
                                    *temp1
                          zz( 1 ) = z( iim1 )*z( iim1 )
                          zz( 3 ) = delta( iip1 )*delta( iip1 )*( ( dpsi-temp1 )+dphi )
                       else
                          temp1 = z( iip1 ) / delta( iip1 )
                          temp1 = temp1*temp1
                          c = temp - delta( iim1 )*( dpsi+dphi ) -( d( iip1 )-d( iim1 ) )&
                                    *temp1
                          zz( 1 ) = delta( iim1 )*delta( iim1 )*( dpsi+( dphi-temp1 ) )
                          zz( 3 ) = z( iip1 )*z( iip1 )
                       end if
                    end if
                    call stdlib_${ri}$laed6( niter, orgati, c, delta( iim1 ), zz, w, eta,info )
                    if( info/=0 )go to 250
                 end if
                 ! note, eta should be positive if w is negative, and
                 ! eta should be negative otherwise. however,
                 ! if for some reason caused by roundoff, eta*w > 0,
                 ! we simply use one newton step instead. this way
                 ! will guarantee eta*w < 0.
                 if( w*eta>=zero )eta = -w / dw
                 temp = tau + eta
                 if( temp>dltub .or. temp<dltlb ) then
                    if( w<zero ) then
                       eta = ( dltub-tau ) / two
                    else
                       eta = ( dltlb-tau ) / two
                    end if
                 end if
                 do j = 1, n
                    delta( j ) = delta( j ) - eta
                 end do
                 tau = tau + eta
                 prew = w
                 ! evaluate psi and the derivative dpsi
                 dpsi = zero
                 psi = zero
                 erretm = zero
                 do j = 1, iim1
                    temp = z( j ) / delta( j )
                    psi = psi + z( j )*temp
                    dpsi = dpsi + temp*temp
                    erretm = erretm + psi
                 end do
                 erretm = abs( erretm )
                 ! evaluate phi and the derivative dphi
                 dphi = zero
                 phi = zero
                 do j = n, iip1, -1
                    temp = z( j ) / delta( j )
                    phi = phi + z( j )*temp
                    dphi = dphi + temp*temp
                    erretm = erretm + phi
                 end do
                 temp = z( ii ) / delta( ii )
                 dw = dpsi + dphi + temp*temp
                 temp = z( ii )*temp
                 w = rhoinv + phi + psi + temp
                 erretm = eight*( phi-psi ) + erretm + two*rhoinv +three*abs( temp ) + abs( tau )&
                           *dw
                 if( w*prew>zero .and. abs( w )>abs( prew ) / ten )swtch = .not.swtch
              end do loop_240
              ! return with info = 1, niter = maxit and not converged
              info = 1
              if( orgati ) then
                 dlam = d( i ) + tau
              else
                 dlam = d( ip1 ) + tau
              end if
           end if
           250 continue
           return
     end subroutine stdlib_${ri}$laed4

#:endif
#:endfor







     pure subroutine stdlib_ssbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
     !! SSBGV computes all the eigenvalues, and optionally, the eigenvectors
     !! of a real generalized symmetric-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
     !! and banded, and B is also positive definite.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ka, kb, ldab, ldbb, ldz, n
           ! Array Arguments 
           real(sp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper, wantz
           character :: vect
           integer(ilp) :: iinfo, inde, indwrk
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ka<0 ) then
              info = -4
           else if( kb<0 .or. kb>ka ) then
              info = -5
           else if( ldab<ka+1 ) then
              info = -7
           else if( ldbb<kb+1 ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSBGV ', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_spbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           inde = 1
           indwrk = inde + n
           call stdlib_ssbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, z, ldz,work( indwrk ), &
                     iinfo )
           ! reduce to tridiagonal form.
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_ssbtrd( vect, uplo, n, ka, ab, ldab, w, work( inde ), z, ldz,work( indwrk )&
                     , iinfo )
           ! for eigenvalues only, call stdlib_ssterf.  for eigenvectors, call stdlib_ssteqr.
           if( .not.wantz ) then
              call stdlib_ssterf( n, w, work( inde ), info )
           else
              call stdlib_ssteqr( jobz, n, w, work( inde ), z, ldz, work( indwrk ),info )
           end if
           return
     end subroutine stdlib_ssbgv

     pure subroutine stdlib_dsbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
     !! DSBGV computes all the eigenvalues, and optionally, the eigenvectors
     !! of a real generalized symmetric-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
     !! and banded, and B is also positive definite.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ka, kb, ldab, ldbb, ldz, n
           ! Array Arguments 
           real(dp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper, wantz
           character :: vect
           integer(ilp) :: iinfo, inde, indwrk
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ka<0 ) then
              info = -4
           else if( kb<0 .or. kb>ka ) then
              info = -5
           else if( ldab<ka+1 ) then
              info = -7
           else if( ldbb<kb+1 ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSBGV ', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_dpbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           inde = 1
           indwrk = inde + n
           call stdlib_dsbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, z, ldz,work( indwrk ), &
                     iinfo )
           ! reduce to tridiagonal form.
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_dsbtrd( vect, uplo, n, ka, ab, ldab, w, work( inde ), z, ldz,work( indwrk )&
                     , iinfo )
           ! for eigenvalues only, call stdlib_dsterf.  for eigenvectors, call stdlib_ssteqr.
           if( .not.wantz ) then
              call stdlib_dsterf( n, w, work( inde ), info )
           else
              call stdlib_dsteqr( jobz, n, w, work( inde ), z, ldz, work( indwrk ),info )
           end if
           return
     end subroutine stdlib_dsbgv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$sbgv( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w, z,ldz, work, &
     !! DSBGV: computes all the eigenvalues, and optionally, the eigenvectors
     !! of a real generalized symmetric-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x. Here A and B are assumed to be symmetric
     !! and banded, and B is also positive definite.
               info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ka, kb, ldab, ldbb, ldz, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: upper, wantz
           character :: vect
           integer(ilp) :: iinfo, inde, indwrk
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ka<0 ) then
              info = -4
           else if( kb<0 .or. kb>ka ) then
              info = -5
           else if( ldab<ka+1 ) then
              info = -7
           else if( ldbb<kb+1 ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSBGV ', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_${ri}$pbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           inde = 1
           indwrk = inde + n
           call stdlib_${ri}$sbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, z, ldz,work( indwrk ), &
                     iinfo )
           ! reduce to tridiagonal form.
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_${ri}$sbtrd( vect, uplo, n, ka, ab, ldab, w, work( inde ), z, ldz,work( indwrk )&
                     , iinfo )
           ! for eigenvalues only, call stdlib_${ri}$sterf.  for eigenvectors, call stdlib_dsteqr.
           if( .not.wantz ) then
              call stdlib_${ri}$sterf( n, w, work( inde ), info )
           else
              call stdlib_${ri}$steqr( jobz, n, w, work( inde ), z, ldz, work( indwrk ),info )
           end if
           return
     end subroutine stdlib_${ri}$sbgv

#:endif
#:endfor



     pure subroutine stdlib_slaed3( k, n, n1, d, q, ldq, rho, dlamda, q2, indx,ctot, w, s, info )
     !! SLAED3 finds the roots of the secular equation, as defined by the
     !! values in D, W, and RHO, between 1 and K.  It makes the
     !! appropriate calls to SLAED4 and then updates the eigenvectors by
     !! multiplying the matrix of eigenvectors of the pair of eigensystems
     !! being combined by the matrix of eigenvectors of the K-by-K system
     !! which is solved here.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, ldq, n, n1
           real(sp), intent(in) :: rho
           ! Array Arguments 
           integer(ilp), intent(in) :: ctot(*), indx(*)
           real(sp), intent(out) :: d(*), q(ldq,*), s(*)
           real(sp), intent(inout) :: dlamda(*), w(*)
           real(sp), intent(in) :: q2(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, ii, iq2, j, n12, n2, n23
           real(sp) :: temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( k<0 ) then
              info = -1
           else if( n<k ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SLAED3', -info )
              return
           end if
           ! quick return if possible
           if( k==0 )return
           ! modify values dlamda(i) to make sure all dlamda(i)-dlamda(j) can
           ! be computed with high relative accuracy (barring over/underflow).
           ! this is a problem on machines without a guard digit in
           ! add/subtract (cray xmp, cray ymp, cray c 90 and cray 2).
           ! the following code replaces dlamda(i) by 2*dlamda(i)-dlamda(i),
           ! which on any of these machines zeros out the bottommost
           ! bit of dlamda(i) if it is 1; this makes the subsequent
           ! subtractions dlamda(i)-dlamda(j) unproblematic when cancellation
           ! occurs. on binary machines with a guard digit (almost all
           ! machines) it does not change dlamda(i) at all. on hexadecimal
           ! and decimal machines with a guard digit, it slightly
           ! changes the bottommost bits of dlamda(i). it does not account
           ! for hexadecimal or decimal machines without guard digits
           ! (we know of none). we use a subroutine call to compute
           ! 2*dlambda(i) to prevent optimizing compilers from eliminating
           ! this code.
           do i = 1, k
              dlamda( i ) = stdlib_slamc3( dlamda( i ), dlamda( i ) ) - dlamda( i )
           end do
           do j = 1, k
              call stdlib_slaed4( k, j, dlamda, w, q( 1, j ), rho, d( j ), info )
              ! if the zero finder fails, the computation is terminated.
              if( info/=0 )go to 120
           end do
           if( k==1 )go to 110
           if( k==2 ) then
              do j = 1, k
                 w( 1 ) = q( 1, j )
                 w( 2 ) = q( 2, j )
                 ii = indx( 1 )
                 q( 1, j ) = w( ii )
                 ii = indx( 2 )
                 q( 2, j ) = w( ii )
              end do
              go to 110
           end if
           ! compute updated w.
           call stdlib_scopy( k, w, 1, s, 1 )
           ! initialize w(i) = q(i,i)
           call stdlib_scopy( k, q, ldq+1, w, 1 )
           do j = 1, k
              do i = 1, j - 1
                 w( i ) = w( i )*( q( i, j ) / ( dlamda( i )-dlamda( j ) ) )
              end do
              do i = j + 1, k
                 w( i ) = w( i )*( q( i, j ) / ( dlamda( i )-dlamda( j ) ) )
              end do
           end do
           do i = 1, k
              w( i ) = sign( sqrt( -w( i ) ), s( i ) )
           end do
           ! compute eigenvectors of the modified rank-1 modification.
           do j = 1, k
              do i = 1, k
                 s( i ) = w( i ) / q( i, j )
              end do
              temp = stdlib_snrm2( k, s, 1 )
              do i = 1, k
                 ii = indx( i )
                 q( i, j ) = s( ii ) / temp
              end do
           end do
           ! compute the updated eigenvectors.
           110 continue
           n2 = n - n1
           n12 = ctot( 1 ) + ctot( 2 )
           n23 = ctot( 2 ) + ctot( 3 )
           call stdlib_slacpy( 'A', n23, k, q( ctot( 1 )+1, 1 ), ldq, s, n23 )
           iq2 = n1*n12 + 1
           if( n23/=0 ) then
              call stdlib_sgemm( 'N', 'N', n2, k, n23, one, q2( iq2 ), n2, s, n23,zero, q( n1+1, &
                        1 ), ldq )
           else
              call stdlib_slaset( 'A', n2, k, zero, zero, q( n1+1, 1 ), ldq )
           end if
           call stdlib_slacpy( 'A', n12, k, q, ldq, s, n12 )
           if( n12/=0 ) then
              call stdlib_sgemm( 'N', 'N', n1, k, n12, one, q2, n1, s, n12, zero, q,ldq )
           else
              call stdlib_slaset( 'A', n1, k, zero, zero, q( 1, 1 ), ldq )
           end if
           120 continue
           return
     end subroutine stdlib_slaed3

     pure subroutine stdlib_dlaed3( k, n, n1, d, q, ldq, rho, dlamda, q2, indx,ctot, w, s, info )
     !! DLAED3 finds the roots of the secular equation, as defined by the
     !! values in D, W, and RHO, between 1 and K.  It makes the
     !! appropriate calls to DLAED4 and then updates the eigenvectors by
     !! multiplying the matrix of eigenvectors of the pair of eigensystems
     !! being combined by the matrix of eigenvectors of the K-by-K system
     !! which is solved here.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, ldq, n, n1
           real(dp), intent(in) :: rho
           ! Array Arguments 
           integer(ilp), intent(in) :: ctot(*), indx(*)
           real(dp), intent(out) :: d(*), q(ldq,*), s(*)
           real(dp), intent(inout) :: dlamda(*), w(*)
           real(dp), intent(in) :: q2(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, ii, iq2, j, n12, n2, n23
           real(dp) :: temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( k<0 ) then
              info = -1
           else if( n<k ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED3', -info )
              return
           end if
           ! quick return if possible
           if( k==0 )return
           ! modify values dlamda(i) to make sure all dlamda(i)-dlamda(j) can
           ! be computed with high relative accuracy (barring over/underflow).
           ! this is a problem on machines without a guard digit in
           ! add/subtract (cray xmp, cray ymp, cray c 90 and cray 2).
           ! the following code replaces dlamda(i) by 2*dlamda(i)-dlamda(i),
           ! which on any of these machines zeros out the bottommost
           ! bit of dlamda(i) if it is 1; this makes the subsequent
           ! subtractions dlamda(i)-dlamda(j) unproblematic when cancellation
           ! occurs. on binary machines with a guard digit (almost all
           ! machines) it does not change dlamda(i) at all. on hexadecimal
           ! and decimal machines with a guard digit, it slightly
           ! changes the bottommost bits of dlamda(i). it does not account
           ! for hexadecimal or decimal machines without guard digits
           ! (we know of none). we use a subroutine call to compute
           ! 2*dlambda(i) to prevent optimizing compilers from eliminating
           ! this code.
           do i = 1, k
              dlamda( i ) = stdlib_dlamc3( dlamda( i ), dlamda( i ) ) - dlamda( i )
           end do
           do j = 1, k
              call stdlib_dlaed4( k, j, dlamda, w, q( 1, j ), rho, d( j ), info )
              ! if the zero finder fails, the computation is terminated.
              if( info/=0 )go to 120
           end do
           if( k==1 )go to 110
           if( k==2 ) then
              do j = 1, k
                 w( 1 ) = q( 1, j )
                 w( 2 ) = q( 2, j )
                 ii = indx( 1 )
                 q( 1, j ) = w( ii )
                 ii = indx( 2 )
                 q( 2, j ) = w( ii )
              end do
              go to 110
           end if
           ! compute updated w.
           call stdlib_dcopy( k, w, 1, s, 1 )
           ! initialize w(i) = q(i,i)
           call stdlib_dcopy( k, q, ldq+1, w, 1 )
           do j = 1, k
              do i = 1, j - 1
                 w( i ) = w( i )*( q( i, j ) / ( dlamda( i )-dlamda( j ) ) )
              end do
              do i = j + 1, k
                 w( i ) = w( i )*( q( i, j ) / ( dlamda( i )-dlamda( j ) ) )
              end do
           end do
           do i = 1, k
              w( i ) = sign( sqrt( -w( i ) ), s( i ) )
           end do
           ! compute eigenvectors of the modified rank-1 modification.
           do j = 1, k
              do i = 1, k
                 s( i ) = w( i ) / q( i, j )
              end do
              temp = stdlib_dnrm2( k, s, 1 )
              do i = 1, k
                 ii = indx( i )
                 q( i, j ) = s( ii ) / temp
              end do
           end do
           ! compute the updated eigenvectors.
           110 continue
           n2 = n - n1
           n12 = ctot( 1 ) + ctot( 2 )
           n23 = ctot( 2 ) + ctot( 3 )
           call stdlib_dlacpy( 'A', n23, k, q( ctot( 1 )+1, 1 ), ldq, s, n23 )
           iq2 = n1*n12 + 1
           if( n23/=0 ) then
              call stdlib_dgemm( 'N', 'N', n2, k, n23, one, q2( iq2 ), n2, s, n23,zero, q( n1+1, &
                        1 ), ldq )
           else
              call stdlib_dlaset( 'A', n2, k, zero, zero, q( n1+1, 1 ), ldq )
           end if
           call stdlib_dlacpy( 'A', n12, k, q, ldq, s, n12 )
           if( n12/=0 ) then
              call stdlib_dgemm( 'N', 'N', n1, k, n12, one, q2, n1, s, n12, zero, q,ldq )
           else
              call stdlib_dlaset( 'A', n1, k, zero, zero, q( 1, 1 ), ldq )
           end if
           120 continue
           return
     end subroutine stdlib_dlaed3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laed3( k, n, n1, d, q, ldq, rho, dlamda, q2, indx,ctot, w, s, info )
     !! DLAED3: finds the roots of the secular equation, as defined by the
     !! values in D, W, and RHO, between 1 and K.  It makes the
     !! appropriate calls to DLAED4 and then updates the eigenvectors by
     !! multiplying the matrix of eigenvectors of the pair of eigensystems
     !! being combined by the matrix of eigenvectors of the K-by-K system
     !! which is solved here.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: k, ldq, n, n1
           real(${rk}$), intent(in) :: rho
           ! Array Arguments 
           integer(ilp), intent(in) :: ctot(*), indx(*)
           real(${rk}$), intent(out) :: d(*), q(ldq,*), s(*)
           real(${rk}$), intent(inout) :: dlamda(*), w(*)
           real(${rk}$), intent(in) :: q2(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: i, ii, iq2, j, n12, n2, n23
           real(${rk}$) :: temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( k<0 ) then
              info = -1
           else if( n<k ) then
              info = -2
           else if( ldq<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED3', -info )
              return
           end if
           ! quick return if possible
           if( k==0 )return
           ! modify values dlamda(i) to make sure all dlamda(i)-dlamda(j) can
           ! be computed with high relative accuracy (barring over/underflow).
           ! this is a problem on machines without a guard digit in
           ! add/subtract (cray xmp, cray ymp, cray c 90 and cray 2).
           ! the following code replaces dlamda(i) by 2*dlamda(i)-dlamda(i),
           ! which on any of these machines zeros out the bottommost
           ! bit of dlamda(i) if it is 1; this makes the subsequent
           ! subtractions dlamda(i)-dlamda(j) unproblematic when cancellation
           ! occurs. on binary machines with a guard digit (almost all
           ! machines) it does not change dlamda(i) at all. on hexadecimal
           ! and decimal machines with a guard digit, it slightly
           ! changes the bottommost bits of dlamda(i). it does not account
           ! for hexadecimal or decimal machines without guard digits
           ! (we know of none). we use a subroutine call to compute
           ! 2*dlambda(i) to prevent optimizing compilers from eliminating
           ! this code.
           do i = 1, k
              dlamda( i ) = stdlib_${ri}$lamc3( dlamda( i ), dlamda( i ) ) - dlamda( i )
           end do
           do j = 1, k
              call stdlib_${ri}$laed4( k, j, dlamda, w, q( 1, j ), rho, d( j ), info )
              ! if the zero finder fails, the computation is terminated.
              if( info/=0 )go to 120
           end do
           if( k==1 )go to 110
           if( k==2 ) then
              do j = 1, k
                 w( 1 ) = q( 1, j )
                 w( 2 ) = q( 2, j )
                 ii = indx( 1 )
                 q( 1, j ) = w( ii )
                 ii = indx( 2 )
                 q( 2, j ) = w( ii )
              end do
              go to 110
           end if
           ! compute updated w.
           call stdlib_${ri}$copy( k, w, 1, s, 1 )
           ! initialize w(i) = q(i,i)
           call stdlib_${ri}$copy( k, q, ldq+1, w, 1 )
           do j = 1, k
              do i = 1, j - 1
                 w( i ) = w( i )*( q( i, j ) / ( dlamda( i )-dlamda( j ) ) )
              end do
              do i = j + 1, k
                 w( i ) = w( i )*( q( i, j ) / ( dlamda( i )-dlamda( j ) ) )
              end do
           end do
           do i = 1, k
              w( i ) = sign( sqrt( -w( i ) ), s( i ) )
           end do
           ! compute eigenvectors of the modified rank-1 modification.
           do j = 1, k
              do i = 1, k
                 s( i ) = w( i ) / q( i, j )
              end do
              temp = stdlib_${ri}$nrm2( k, s, 1 )
              do i = 1, k
                 ii = indx( i )
                 q( i, j ) = s( ii ) / temp
              end do
           end do
           ! compute the updated eigenvectors.
           110 continue
           n2 = n - n1
           n12 = ctot( 1 ) + ctot( 2 )
           n23 = ctot( 2 ) + ctot( 3 )
           call stdlib_${ri}$lacpy( 'A', n23, k, q( ctot( 1 )+1, 1 ), ldq, s, n23 )
           iq2 = n1*n12 + 1
           if( n23/=0 ) then
              call stdlib_${ri}$gemm( 'N', 'N', n2, k, n23, one, q2( iq2 ), n2, s, n23,zero, q( n1+1, &
                        1 ), ldq )
           else
              call stdlib_${ri}$laset( 'A', n2, k, zero, zero, q( n1+1, 1 ), ldq )
           end if
           call stdlib_${ri}$lacpy( 'A', n12, k, q, ldq, s, n12 )
           if( n12/=0 ) then
              call stdlib_${ri}$gemm( 'N', 'N', n1, k, n12, one, q2, n1, s, n12, zero, q,ldq )
           else
              call stdlib_${ri}$laset( 'A', n1, k, zero, zero, q( 1, 1 ), ldq )
           end if
           120 continue
           return
     end subroutine stdlib_${ri}$laed3

#:endif
#:endfor





     pure subroutine stdlib_ssptrd( uplo, n, ap, d, e, tau, info )
     !! SSPTRD reduces a real symmetric matrix A stored in packed form to
     !! symmetric tridiagonal form T by an orthogonal similarity
     !! transformation: Q**T * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(sp), intent(inout) :: ap(*)
           real(sp), intent(out) :: d(*), e(*), tau(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, i1, i1i1, ii
           real(sp) :: alpha, taui
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSPTRD', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           if( upper ) then
              ! reduce the upper triangle of a.
              ! i1 is the index in ap of a(1,i+1).
              i1 = n*( n-1 ) / 2 + 1
              do i = n - 1, 1, -1
                 ! generate elementary reflector h(i) = i - tau * v * v**t
                 ! to annihilate a(1:i-1,i+1)
                 call stdlib_slarfg( i, ap( i1+i-1 ), ap( i1 ), 1, taui )
                 e( i ) = ap( i1+i-1 )
                 if( taui/=zero ) then
                    ! apply h(i) from both sides to a(1:i,1:i)
                    ap( i1+i-1 ) = one
                    ! compute  y := tau * a * v  storing y in tau(1:i)
                    call stdlib_sspmv( uplo, i, taui, ap, ap( i1 ), 1, zero, tau,1 )
                    ! compute  w := y - 1/2 * tau * (y**t *v) * v
                    alpha = -half*taui*stdlib_sdot( i, tau, 1, ap( i1 ), 1 )
                    call stdlib_saxpy( i, alpha, ap( i1 ), 1, tau, 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**t - w * v**t
                    call stdlib_sspr2( uplo, i, -one, ap( i1 ), 1, tau, 1, ap )
                    ap( i1+i-1 ) = e( i )
                 end if
                 d( i+1 ) = ap( i1+i )
                 tau( i ) = taui
                 i1 = i1 - i
              end do
              d( 1 ) = ap( 1 )
           else
              ! reduce the lower triangle of a. ii is the index in ap of
              ! a(i,i) and i1i1 is the index of a(i+1,i+1).
              ii = 1
              do i = 1, n - 1
                 i1i1 = ii + n - i + 1
                 ! generate elementary reflector h(i) = i - tau * v * v**t
                 ! to annihilate a(i+2:n,i)
                 call stdlib_slarfg( n-i, ap( ii+1 ), ap( ii+2 ), 1, taui )
                 e( i ) = ap( ii+1 )
                 if( taui/=zero ) then
                    ! apply h(i) from both sides to a(i+1:n,i+1:n)
                    ap( ii+1 ) = one
                    ! compute  y := tau * a * v  storing y in tau(i:n-1)
                    call stdlib_sspmv( uplo, n-i, taui, ap( i1i1 ), ap( ii+1 ), 1,zero, tau( i ), &
                              1 )
                    ! compute  w := y - 1/2 * tau * (y**t *v) * v
                    alpha = -half*taui*stdlib_sdot( n-i, tau( i ), 1, ap( ii+1 ),1 )
                    call stdlib_saxpy( n-i, alpha, ap( ii+1 ), 1, tau( i ), 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**t - w * v**t
                    call stdlib_sspr2( uplo, n-i, -one, ap( ii+1 ), 1, tau( i ), 1,ap( i1i1 ) )
                              
                    ap( ii+1 ) = e( i )
                 end if
                 d( i ) = ap( ii )
                 tau( i ) = taui
                 ii = i1i1
              end do
              d( n ) = ap( ii )
           end if
           return
     end subroutine stdlib_ssptrd

     pure subroutine stdlib_dsptrd( uplo, n, ap, d, e, tau, info )
     !! DSPTRD reduces a real symmetric matrix A stored in packed form to
     !! symmetric tridiagonal form T by an orthogonal similarity
     !! transformation: Q**T * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(dp), intent(inout) :: ap(*)
           real(dp), intent(out) :: d(*), e(*), tau(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, i1, i1i1, ii
           real(dp) :: alpha, taui
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPTRD', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           if( upper ) then
              ! reduce the upper triangle of a.
              ! i1 is the index in ap of a(1,i+1).
              i1 = n*( n-1 ) / 2 + 1
              do i = n - 1, 1, -1
                 ! generate elementary reflector h(i) = i - tau * v * v**t
                 ! to annihilate a(1:i-1,i+1)
                 call stdlib_dlarfg( i, ap( i1+i-1 ), ap( i1 ), 1, taui )
                 e( i ) = ap( i1+i-1 )
                 if( taui/=zero ) then
                    ! apply h(i) from both sides to a(1:i,1:i)
                    ap( i1+i-1 ) = one
                    ! compute  y := tau * a * v  storing y in tau(1:i)
                    call stdlib_dspmv( uplo, i, taui, ap, ap( i1 ), 1, zero, tau,1 )
                    ! compute  w := y - 1/2 * tau * (y**t *v) * v
                    alpha = -half*taui*stdlib_ddot( i, tau, 1, ap( i1 ), 1 )
                    call stdlib_daxpy( i, alpha, ap( i1 ), 1, tau, 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**t - w * v**t
                    call stdlib_dspr2( uplo, i, -one, ap( i1 ), 1, tau, 1, ap )
                    ap( i1+i-1 ) = e( i )
                 end if
                 d( i+1 ) = ap( i1+i )
                 tau( i ) = taui
                 i1 = i1 - i
              end do
              d( 1 ) = ap( 1 )
           else
              ! reduce the lower triangle of a. ii is the index in ap of
              ! a(i,i) and i1i1 is the index of a(i+1,i+1).
              ii = 1
              do i = 1, n - 1
                 i1i1 = ii + n - i + 1
                 ! generate elementary reflector h(i) = i - tau * v * v**t
                 ! to annihilate a(i+2:n,i)
                 call stdlib_dlarfg( n-i, ap( ii+1 ), ap( ii+2 ), 1, taui )
                 e( i ) = ap( ii+1 )
                 if( taui/=zero ) then
                    ! apply h(i) from both sides to a(i+1:n,i+1:n)
                    ap( ii+1 ) = one
                    ! compute  y := tau * a * v  storing y in tau(i:n-1)
                    call stdlib_dspmv( uplo, n-i, taui, ap( i1i1 ), ap( ii+1 ), 1,zero, tau( i ), &
                              1 )
                    ! compute  w := y - 1/2 * tau * (y**t *v) * v
                    alpha = -half*taui*stdlib_ddot( n-i, tau( i ), 1, ap( ii+1 ),1 )
                    call stdlib_daxpy( n-i, alpha, ap( ii+1 ), 1, tau( i ), 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**t - w * v**t
                    call stdlib_dspr2( uplo, n-i, -one, ap( ii+1 ), 1, tau( i ), 1,ap( i1i1 ) )
                              
                    ap( ii+1 ) = e( i )
                 end if
                 d( i ) = ap( ii )
                 tau( i ) = taui
                 ii = i1i1
              end do
              d( n ) = ap( ii )
           end if
           return
     end subroutine stdlib_dsptrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$sptrd( uplo, n, ap, d, e, tau, info )
     !! DSPTRD: reduces a real symmetric matrix A stored in packed form to
     !! symmetric tridiagonal form T by an orthogonal similarity
     !! transformation: Q**T * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ap(*)
           real(${rk}$), intent(out) :: d(*), e(*), tau(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, i1, i1i1, ii
           real(${rk}$) :: alpha, taui
           ! Executable Statements 
           ! test the input parameters
           info = 0
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPTRD', -info )
              return
           end if
           ! quick return if possible
           if( n<=0 )return
           if( upper ) then
              ! reduce the upper triangle of a.
              ! i1 is the index in ap of a(1,i+1).
              i1 = n*( n-1 ) / 2 + 1
              do i = n - 1, 1, -1
                 ! generate elementary reflector h(i) = i - tau * v * v**t
                 ! to annihilate a(1:i-1,i+1)
                 call stdlib_${ri}$larfg( i, ap( i1+i-1 ), ap( i1 ), 1, taui )
                 e( i ) = ap( i1+i-1 )
                 if( taui/=zero ) then
                    ! apply h(i) from both sides to a(1:i,1:i)
                    ap( i1+i-1 ) = one
                    ! compute  y := tau * a * v  storing y in tau(1:i)
                    call stdlib_${ri}$spmv( uplo, i, taui, ap, ap( i1 ), 1, zero, tau,1 )
                    ! compute  w := y - 1/2 * tau * (y**t *v) * v
                    alpha = -half*taui*stdlib_${ri}$dot( i, tau, 1, ap( i1 ), 1 )
                    call stdlib_${ri}$axpy( i, alpha, ap( i1 ), 1, tau, 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**t - w * v**t
                    call stdlib_${ri}$spr2( uplo, i, -one, ap( i1 ), 1, tau, 1, ap )
                    ap( i1+i-1 ) = e( i )
                 end if
                 d( i+1 ) = ap( i1+i )
                 tau( i ) = taui
                 i1 = i1 - i
              end do
              d( 1 ) = ap( 1 )
           else
              ! reduce the lower triangle of a. ii is the index in ap of
              ! a(i,i) and i1i1 is the index of a(i+1,i+1).
              ii = 1
              do i = 1, n - 1
                 i1i1 = ii + n - i + 1
                 ! generate elementary reflector h(i) = i - tau * v * v**t
                 ! to annihilate a(i+2:n,i)
                 call stdlib_${ri}$larfg( n-i, ap( ii+1 ), ap( ii+2 ), 1, taui )
                 e( i ) = ap( ii+1 )
                 if( taui/=zero ) then
                    ! apply h(i) from both sides to a(i+1:n,i+1:n)
                    ap( ii+1 ) = one
                    ! compute  y := tau * a * v  storing y in tau(i:n-1)
                    call stdlib_${ri}$spmv( uplo, n-i, taui, ap( i1i1 ), ap( ii+1 ), 1,zero, tau( i ), &
                              1 )
                    ! compute  w := y - 1/2 * tau * (y**t *v) * v
                    alpha = -half*taui*stdlib_${ri}$dot( n-i, tau( i ), 1, ap( ii+1 ),1 )
                    call stdlib_${ri}$axpy( n-i, alpha, ap( ii+1 ), 1, tau( i ), 1 )
                    ! apply the transformation as a rank-2 update:
                       ! a := a - v * w**t - w * v**t
                    call stdlib_${ri}$spr2( uplo, n-i, -one, ap( ii+1 ), 1, tau( i ), 1,ap( i1i1 ) )
                              
                    ap( ii+1 ) = e( i )
                 end if
                 d( i ) = ap( ii )
                 tau( i ) = taui
                 ii = i1i1
              end do
              d( n ) = ap( ii )
           end if
           return
     end subroutine stdlib_${ri}$sptrd

#:endif
#:endfor



     pure subroutine  stdlib_ssb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, lda, &
     !! SSB2ST_KERNELS is an internal routine used by the SSYTRD_SB2ST
     !! subroutine.
               v, tau, ldvt, work)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           logical(lk), intent(in) :: wantz
           integer(ilp), intent(in) :: ttype, st, ed, sweep, n, nb, ib, lda, ldvt
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*)
           real(sp), intent(out) :: v(*), tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j1, j2, lm, ln, vpos, taupos, dpos, ofdpos, ajeter
           real(sp) :: ctmp
           ! Intrinsic Functions 
           ! Executable Statements 
           ajeter = ib + ldvt
           upper = stdlib_lsame( uplo, 'U' )
           if( upper ) then
               dpos    = 2 * nb + 1
               ofdpos  = 2 * nb
           else
               dpos    = 1
               ofdpos  = 2
           endif
           ! upper case
           if( upper ) then
               if( wantz ) then
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               else
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               endif
               if( ttype==1 ) then
                   lm = ed - st + 1
                   v( vpos ) = one
                   do i = 1, lm-1
                       v( vpos+i )         = ( a( ofdpos-i, st+i ) )
                       a( ofdpos-i, st+i ) = zero
                   end do
                   ctmp = ( a( ofdpos, st ) )
                   call stdlib_slarfg( lm, ctmp, v( vpos+1 ), 1,tau( taupos ) )
                   a( ofdpos, st ) = ctmp
                   lm = ed - st + 1
                   call stdlib_slarfy( uplo, lm, v( vpos ), 1,( tau( taupos ) ),a( dpos, st ), &
                             lda-1, work)
               endif
               if( ttype==3 ) then
                   lm = ed - st + 1
                   call stdlib_slarfy( uplo, lm, v( vpos ), 1,( tau( taupos ) ),a( dpos, st ), &
                             lda-1, work)
               endif
               if( ttype==2 ) then
                   j1 = ed+1
                   j2 = min( ed+nb, n )
                   ln = ed-st+1
                   lm = j2-j1+1
                   if( lm>0) then
                       call stdlib_slarfx( 'LEFT', ln, lm, v( vpos ),( tau( taupos ) ),a( dpos-nb,&
                                  j1 ), lda-1, work)
                       if( wantz ) then
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       else
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       endif
                       v( vpos ) = one
                       do i = 1, lm-1
                           v( vpos+i )          =( a( dpos-nb-i, j1+i ) )
                           a( dpos-nb-i, j1+i ) = zero
                       end do
                       ctmp = ( a( dpos-nb, j1 ) )
                       call stdlib_slarfg( lm, ctmp, v( vpos+1 ), 1, tau( taupos ) )
                       a( dpos-nb, j1 ) = ctmp
                       call stdlib_slarfx( 'RIGHT', ln-1, lm, v( vpos ),tau( taupos ),a( dpos-nb+&
                                 1, j1 ), lda-1, work)
                   endif
               endif
           ! lower case
           else
               if( wantz ) then
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               else
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               endif
               if( ttype==1 ) then
                   lm = ed - st + 1
                   v( vpos ) = one
                   do i = 1, lm-1
                       v( vpos+i )         = a( ofdpos+i, st-1 )
                       a( ofdpos+i, st-1 ) = zero
                   end do
                   call stdlib_slarfg( lm, a( ofdpos, st-1 ), v( vpos+1 ), 1,tau( taupos ) )
                             
                   lm = ed - st + 1
                   call stdlib_slarfy( uplo, lm, v( vpos ), 1,( tau( taupos ) ),a( dpos, st ), &
                             lda-1, work)
               endif
               if( ttype==3 ) then
                   lm = ed - st + 1
                   call stdlib_slarfy( uplo, lm, v( vpos ), 1,( tau( taupos ) ),a( dpos, st ), &
                             lda-1, work)
               endif
               if( ttype==2 ) then
                   j1 = ed+1
                   j2 = min( ed+nb, n )
                   ln = ed-st+1
                   lm = j2-j1+1
                   if( lm>0) then
                       call stdlib_slarfx( 'RIGHT', lm, ln, v( vpos ),tau( taupos ), a( dpos+nb, &
                                 st ),lda-1, work)
                       if( wantz ) then
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       else
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       endif
                       v( vpos ) = one
                       do i = 1, lm-1
                           v( vpos+i )        = a( dpos+nb+i, st )
                           a( dpos+nb+i, st ) = zero
                       end do
                       call stdlib_slarfg( lm, a( dpos+nb, st ), v( vpos+1 ), 1,tau( taupos ) )
                                 
                       call stdlib_slarfx( 'LEFT', lm, ln-1, v( vpos ),( tau( taupos ) ),a( dpos+&
                                 nb-1, st+1 ), lda-1, work)
                   endif
               endif
           endif
           return
     end subroutine stdlib_ssb2st_kernels

     pure subroutine  stdlib_dsb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, lda, &
     !! DSB2ST_KERNELS is an internal routine used by the DSYTRD_SB2ST
     !! subroutine.
               v, tau, ldvt, work)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           logical(lk), intent(in) :: wantz
           integer(ilp), intent(in) :: ttype, st, ed, sweep, n, nb, ib, lda, ldvt
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*)
           real(dp), intent(out) :: v(*), tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j1, j2, lm, ln, vpos, taupos, dpos, ofdpos, ajeter
           real(dp) :: ctmp
           ! Intrinsic Functions 
           ! Executable Statements 
           ajeter = ib + ldvt
           upper = stdlib_lsame( uplo, 'U' )
           if( upper ) then
               dpos    = 2 * nb + 1
               ofdpos  = 2 * nb
           else
               dpos    = 1
               ofdpos  = 2
           endif
           ! upper case
           if( upper ) then
               if( wantz ) then
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               else
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               endif
               if( ttype==1 ) then
                   lm = ed - st + 1
                   v( vpos ) = one
                   do i = 1, lm-1
                       v( vpos+i )         = ( a( ofdpos-i, st+i ) )
                       a( ofdpos-i, st+i ) = zero
                   end do
                   ctmp = ( a( ofdpos, st ) )
                   call stdlib_dlarfg( lm, ctmp, v( vpos+1 ), 1,tau( taupos ) )
                   a( ofdpos, st ) = ctmp
                   lm = ed - st + 1
                   call stdlib_dlarfy( uplo, lm, v( vpos ), 1,( tau( taupos ) ),a( dpos, st ), &
                             lda-1, work)
               endif
               if( ttype==3 ) then
                   lm = ed - st + 1
                   call stdlib_dlarfy( uplo, lm, v( vpos ), 1,( tau( taupos ) ),a( dpos, st ), &
                             lda-1, work)
               endif
               if( ttype==2 ) then
                   j1 = ed+1
                   j2 = min( ed+nb, n )
                   ln = ed-st+1
                   lm = j2-j1+1
                   if( lm>0) then
                       call stdlib_dlarfx( 'LEFT', ln, lm, v( vpos ),( tau( taupos ) ),a( dpos-nb,&
                                  j1 ), lda-1, work)
                       if( wantz ) then
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       else
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       endif
                       v( vpos ) = one
                       do i = 1, lm-1
                           v( vpos+i )          =( a( dpos-nb-i, j1+i ) )
                           a( dpos-nb-i, j1+i ) = zero
                       end do
                       ctmp = ( a( dpos-nb, j1 ) )
                       call stdlib_dlarfg( lm, ctmp, v( vpos+1 ), 1, tau( taupos ) )
                       a( dpos-nb, j1 ) = ctmp
                       call stdlib_dlarfx( 'RIGHT', ln-1, lm, v( vpos ),tau( taupos ),a( dpos-nb+&
                                 1, j1 ), lda-1, work)
                   endif
               endif
           ! lower case
           else
               if( wantz ) then
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               else
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               endif
               if( ttype==1 ) then
                   lm = ed - st + 1
                   v( vpos ) = one
                   do i = 1, lm-1
                       v( vpos+i )         = a( ofdpos+i, st-1 )
                       a( ofdpos+i, st-1 ) = zero
                   end do
                   call stdlib_dlarfg( lm, a( ofdpos, st-1 ), v( vpos+1 ), 1,tau( taupos ) )
                             
                   lm = ed - st + 1
                   call stdlib_dlarfy( uplo, lm, v( vpos ), 1,( tau( taupos ) ),a( dpos, st ), &
                             lda-1, work)
               endif
               if( ttype==3 ) then
                   lm = ed - st + 1
                   call stdlib_dlarfy( uplo, lm, v( vpos ), 1,( tau( taupos ) ),a( dpos, st ), &
                             lda-1, work)
               endif
               if( ttype==2 ) then
                   j1 = ed+1
                   j2 = min( ed+nb, n )
                   ln = ed-st+1
                   lm = j2-j1+1
                   if( lm>0) then
                       call stdlib_dlarfx( 'RIGHT', lm, ln, v( vpos ),tau( taupos ), a( dpos+nb, &
                                 st ),lda-1, work)
                       if( wantz ) then
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       else
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       endif
                       v( vpos ) = one
                       do i = 1, lm-1
                           v( vpos+i )        = a( dpos+nb+i, st )
                           a( dpos+nb+i, st ) = zero
                       end do
                       call stdlib_dlarfg( lm, a( dpos+nb, st ), v( vpos+1 ), 1,tau( taupos ) )
                                 
                       call stdlib_dlarfx( 'LEFT', lm, ln-1, v( vpos ),( tau( taupos ) ),a( dpos+&
                                 nb-1, st+1 ), lda-1, work)
                   endif
               endif
           endif
           return
     end subroutine stdlib_dsb2st_kernels

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine  stdlib_${ri}$sb2st_kernels( uplo, wantz, ttype,st, ed, sweep, n, nb, ib,a, lda, &
     !! DSB2ST_KERNELS: is an internal routine used by the DSYTRD_SB2ST
     !! subroutine.
               v, tau, ldvt, work)
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           logical(lk), intent(in) :: wantz
           integer(ilp), intent(in) :: ttype, st, ed, sweep, n, nb, ib, lda, ldvt
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*)
           real(${rk}$), intent(out) :: v(*), tau(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: upper
           integer(ilp) :: i, j1, j2, lm, ln, vpos, taupos, dpos, ofdpos, ajeter
           real(${rk}$) :: ctmp
           ! Intrinsic Functions 
           ! Executable Statements 
           ajeter = ib + ldvt
           upper = stdlib_lsame( uplo, 'U' )
           if( upper ) then
               dpos    = 2 * nb + 1
               ofdpos  = 2 * nb
           else
               dpos    = 1
               ofdpos  = 2
           endif
           ! upper case
           if( upper ) then
               if( wantz ) then
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               else
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               endif
               if( ttype==1 ) then
                   lm = ed - st + 1
                   v( vpos ) = one
                   do i = 1, lm-1
                       v( vpos+i )         = ( a( ofdpos-i, st+i ) )
                       a( ofdpos-i, st+i ) = zero
                   end do
                   ctmp = ( a( ofdpos, st ) )
                   call stdlib_${ri}$larfg( lm, ctmp, v( vpos+1 ), 1,tau( taupos ) )
                   a( ofdpos, st ) = ctmp
                   lm = ed - st + 1
                   call stdlib_${ri}$larfy( uplo, lm, v( vpos ), 1,( tau( taupos ) ),a( dpos, st ), &
                             lda-1, work)
               endif
               if( ttype==3 ) then
                   lm = ed - st + 1
                   call stdlib_${ri}$larfy( uplo, lm, v( vpos ), 1,( tau( taupos ) ),a( dpos, st ), &
                             lda-1, work)
               endif
               if( ttype==2 ) then
                   j1 = ed+1
                   j2 = min( ed+nb, n )
                   ln = ed-st+1
                   lm = j2-j1+1
                   if( lm>0) then
                       call stdlib_${ri}$larfx( 'LEFT', ln, lm, v( vpos ),( tau( taupos ) ),a( dpos-nb,&
                                  j1 ), lda-1, work)
                       if( wantz ) then
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       else
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       endif
                       v( vpos ) = one
                       do i = 1, lm-1
                           v( vpos+i )          =( a( dpos-nb-i, j1+i ) )
                           a( dpos-nb-i, j1+i ) = zero
                       end do
                       ctmp = ( a( dpos-nb, j1 ) )
                       call stdlib_${ri}$larfg( lm, ctmp, v( vpos+1 ), 1, tau( taupos ) )
                       a( dpos-nb, j1 ) = ctmp
                       call stdlib_${ri}$larfx( 'RIGHT', ln-1, lm, v( vpos ),tau( taupos ),a( dpos-nb+&
                                 1, j1 ), lda-1, work)
                   endif
               endif
           ! lower case
           else
               if( wantz ) then
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               else
                   vpos   = mod( sweep-1, 2 ) * n + st
                   taupos = mod( sweep-1, 2 ) * n + st
               endif
               if( ttype==1 ) then
                   lm = ed - st + 1
                   v( vpos ) = one
                   do i = 1, lm-1
                       v( vpos+i )         = a( ofdpos+i, st-1 )
                       a( ofdpos+i, st-1 ) = zero
                   end do
                   call stdlib_${ri}$larfg( lm, a( ofdpos, st-1 ), v( vpos+1 ), 1,tau( taupos ) )
                             
                   lm = ed - st + 1
                   call stdlib_${ri}$larfy( uplo, lm, v( vpos ), 1,( tau( taupos ) ),a( dpos, st ), &
                             lda-1, work)
               endif
               if( ttype==3 ) then
                   lm = ed - st + 1
                   call stdlib_${ri}$larfy( uplo, lm, v( vpos ), 1,( tau( taupos ) ),a( dpos, st ), &
                             lda-1, work)
               endif
               if( ttype==2 ) then
                   j1 = ed+1
                   j2 = min( ed+nb, n )
                   ln = ed-st+1
                   lm = j2-j1+1
                   if( lm>0) then
                       call stdlib_${ri}$larfx( 'RIGHT', lm, ln, v( vpos ),tau( taupos ), a( dpos+nb, &
                                 st ),lda-1, work)
                       if( wantz ) then
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       else
                           vpos   = mod( sweep-1, 2 ) * n + j1
                           taupos = mod( sweep-1, 2 ) * n + j1
                       endif
                       v( vpos ) = one
                       do i = 1, lm-1
                           v( vpos+i )        = a( dpos+nb+i, st )
                           a( dpos+nb+i, st ) = zero
                       end do
                       call stdlib_${ri}$larfg( lm, a( dpos+nb, st ), v( vpos+1 ), 1,tau( taupos ) )
                                 
                       call stdlib_${ri}$larfx( 'LEFT', lm, ln-1, v( vpos ),( tau( taupos ) ),a( dpos+&
                                 nb-1, st+1 ), lda-1, work)
                   endif
               endif
           endif
           return
     end subroutine stdlib_${ri}$sb2st_kernels

#:endif
#:endfor









     pure subroutine stdlib_chbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
     !! CHBGVD computes all the eigenvalues, and optionally, the eigenvectors
     !! of a complex generalized Hermitian-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
     !! and banded, and B is also positive definite.  If eigenvectors are
     !! desired, it uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               lwork, rwork, lrwork, iwork,liwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ka, kb, ldab, ldbb, ldz, liwork, lrwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(sp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper, wantz
           character :: vect
           integer(ilp) :: iinfo, inde, indwk2, indwrk, liwmin, llrwk, llwk2, lrwmin, &
                     lwmin
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 .or. lrwork==-1 .or. liwork==-1 )
           info = 0
           if( n<=1 ) then
              lwmin = 1+n
              lrwmin = 1+n
              liwmin = 1
           else if( wantz ) then
              lwmin = 2*n**2
              lrwmin = 1 + 5*n + 2*n**2
              liwmin = 3 + 5*n
           else
              lwmin = n
              lrwmin = n
              liwmin = 1
           end if
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ka<0 ) then
              info = -4
           else if( kb<0 .or. kb>ka ) then
              info = -5
           else if( ldab<ka+1 ) then
              info = -7
           else if( ldbb<kb+1 ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -12
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              rwork( 1 ) = lrwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -14
              else if( lrwork<lrwmin .and. .not.lquery ) then
                 info = -16
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHBGVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_cpbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           inde = 1
           indwrk = inde + n
           indwk2 = 1 + n*n
           llwk2 = lwork - indwk2 + 2
           llrwk = lrwork - indwrk + 2
           call stdlib_chbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, z, ldz,work, rwork, &
                     iinfo )
           ! reduce hermitian band matrix to tridiagonal form.
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_chbtrd( vect, uplo, n, ka, ab, ldab, w, rwork( inde ), z,ldz, work, iinfo )
                     
           ! for eigenvalues only, call stdlib_ssterf.  for eigenvectors, call stdlib_cstedc.
           if( .not.wantz ) then
              call stdlib_ssterf( n, w, rwork( inde ), info )
           else
              call stdlib_cstedc( 'I', n, w, rwork( inde ), work, n, work( indwk2 ),llwk2, rwork( &
                        indwrk ), llrwk, iwork, liwork,info )
              call stdlib_cgemm( 'N', 'N', n, n, n, cone, z, ldz, work, n, czero,work( indwk2 ), &
                        n )
              call stdlib_clacpy( 'A', n, n, work( indwk2 ), n, z, ldz )
           end if
           work( 1 ) = lwmin
           rwork( 1 ) = lrwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_chbgvd

     pure subroutine stdlib_zhbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
     !! ZHBGVD computes all the eigenvalues, and optionally, the eigenvectors
     !! of a complex generalized Hermitian-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
     !! and banded, and B is also positive definite.  If eigenvectors are
     !! desired, it uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               lwork, rwork, lrwork, iwork,liwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ka, kb, ldab, ldbb, ldz, liwork, lrwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(dp), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper, wantz
           character :: vect
           integer(ilp) :: iinfo, inde, indwk2, indwrk, liwmin, llrwk, llwk2, lrwmin, &
                     lwmin
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 .or. lrwork==-1 .or. liwork==-1 )
           info = 0
           if( n<=1 ) then
              lwmin = 1+n
              lrwmin = 1+n
              liwmin = 1
           else if( wantz ) then
              lwmin = 2*n**2
              lrwmin = 1 + 5*n + 2*n**2
              liwmin = 3 + 5*n
           else
              lwmin = n
              lrwmin = n
              liwmin = 1
           end if
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ka<0 ) then
              info = -4
           else if( kb<0 .or. kb>ka ) then
              info = -5
           else if( ldab<ka+1 ) then
              info = -7
           else if( ldbb<kb+1 ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -12
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              rwork( 1 ) = lrwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -14
              else if( lrwork<lrwmin .and. .not.lquery ) then
                 info = -16
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHBGVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_zpbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           inde = 1
           indwrk = inde + n
           indwk2 = 1 + n*n
           llwk2 = lwork - indwk2 + 2
           llrwk = lrwork - indwrk + 2
           call stdlib_zhbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, z, ldz,work, rwork, &
                     iinfo )
           ! reduce hermitian band matrix to tridiagonal form.
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_zhbtrd( vect, uplo, n, ka, ab, ldab, w, rwork( inde ), z,ldz, work, iinfo )
                     
           ! for eigenvalues only, call stdlib_dsterf.  for eigenvectors, call stdlib_zstedc.
           if( .not.wantz ) then
              call stdlib_dsterf( n, w, rwork( inde ), info )
           else
              call stdlib_zstedc( 'I', n, w, rwork( inde ), work, n, work( indwk2 ),llwk2, rwork( &
                        indwrk ), llrwk, iwork, liwork,info )
              call stdlib_zgemm( 'N', 'N', n, n, n, cone, z, ldz, work, n, czero,work( indwk2 ), &
                        n )
              call stdlib_zlacpy( 'A', n, n, work( indwk2 ), n, z, ldz )
           end if
           work( 1 ) = lwmin
           rwork( 1 ) = lrwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_zhbgvd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$hbgvd( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, w,z, ldz, work, &
     !! ZHBGVD: computes all the eigenvalues, and optionally, the eigenvectors
     !! of a complex generalized Hermitian-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
     !! and banded, and B is also positive definite.  If eigenvectors are
     !! desired, it uses a divide and conquer algorithm.
     !! The divide and conquer algorithm makes very mild assumptions about
     !! floating point arithmetic. It will work on machines with a guard
     !! digit in add/subtract, or on those binary machines without guard
     !! digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
     !! Cray-2. It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.
               lwork, rwork, lrwork, iwork,liwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ka, kb, ldab, ldbb, ldz, liwork, lrwork, lwork, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(${ck}$), intent(out) :: work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper, wantz
           character :: vect
           integer(ilp) :: iinfo, inde, indwk2, indwrk, liwmin, llrwk, llwk2, lrwmin, &
                     lwmin
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           lquery = ( lwork==-1 .or. lrwork==-1 .or. liwork==-1 )
           info = 0
           if( n<=1 ) then
              lwmin = 1+n
              lrwmin = 1+n
              liwmin = 1
           else if( wantz ) then
              lwmin = 2*n**2
              lrwmin = 1 + 5*n + 2*n**2
              liwmin = 3 + 5*n
           else
              lwmin = n
              lrwmin = n
              liwmin = 1
           end if
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ka<0 ) then
              info = -4
           else if( kb<0 .or. kb>ka ) then
              info = -5
           else if( ldab<ka+1 ) then
              info = -7
           else if( ldbb<kb+1 ) then
              info = -9
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -12
           end if
           if( info==0 ) then
              work( 1 ) = lwmin
              rwork( 1 ) = lrwmin
              iwork( 1 ) = liwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -14
              else if( lrwork<lrwmin .and. .not.lquery ) then
                 info = -16
              else if( liwork<liwmin .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHBGVD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_${ci}$pbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           inde = 1
           indwrk = inde + n
           indwk2 = 1 + n*n
           llwk2 = lwork - indwk2 + 2
           llrwk = lrwork - indwrk + 2
           call stdlib_${ci}$hbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, z, ldz,work, rwork, &
                     iinfo )
           ! reduce hermitian band matrix to tridiagonal form.
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_${ci}$hbtrd( vect, uplo, n, ka, ab, ldab, w, rwork( inde ), z,ldz, work, iinfo )
                     
           ! for eigenvalues only, call stdlib_${c2ri(ci)}$sterf.  for eigenvectors, call stdlib_${ci}$stedc.
           if( .not.wantz ) then
              call stdlib_${c2ri(ci)}$sterf( n, w, rwork( inde ), info )
           else
              call stdlib_${ci}$stedc( 'I', n, w, rwork( inde ), work, n, work( indwk2 ),llwk2, rwork( &
                        indwrk ), llrwk, iwork, liwork,info )
              call stdlib_${ci}$gemm( 'N', 'N', n, n, n, cone, z, ldz, work, n, czero,work( indwk2 ), &
                        n )
              call stdlib_${ci}$lacpy( 'A', n, n, work( indwk2 ), n, z, ldz )
           end if
           work( 1 ) = lwmin
           rwork( 1 ) = lrwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ci}$hbgvd

#:endif
#:endfor





     pure subroutine stdlib_slamrg( n1, n2, a, strd1, strd2, index )
     !! SLAMRG will create a permutation list which will merge the elements
     !! of A (which is composed of two independently sorted sets) into a
     !! single set which is sorted in ascending order.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: n1, n2, strd1, strd2
           ! Array Arguments 
           integer(ilp), intent(out) :: index(*)
           real(sp), intent(in) :: a(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ind1, ind2, n1sv, n2sv
           ! Executable Statements 
           n1sv = n1
           n2sv = n2
           if( strd1>0 ) then
              ind1 = 1
           else
              ind1 = n1
           end if
           if( strd2>0 ) then
              ind2 = 1 + n1
           else
              ind2 = n1 + n2
           end if
           i = 1
           ! while ( (n1sv > 0)
           10 continue
           if( n1sv>0 .and. n2sv>0 ) then
              if( a( ind1 )<=a( ind2 ) ) then
                 index( i ) = ind1
                 i = i + 1
                 ind1 = ind1 + strd1
                 n1sv = n1sv - 1
              else
                 index( i ) = ind2
                 i = i + 1
                 ind2 = ind2 + strd2
                 n2sv = n2sv - 1
              end if
              go to 10
           end if
           ! end while
           if( n1sv==0 ) then
              do n1sv = 1, n2sv
                 index( i ) = ind2
                 i = i + 1
                 ind2 = ind2 + strd2
              end do
           else
           ! n2sv == 0
              do n2sv = 1, n1sv
                 index( i ) = ind1
                 i = i + 1
                 ind1 = ind1 + strd1
              end do
           end if
           return
     end subroutine stdlib_slamrg

     pure subroutine stdlib_dlamrg( n1, n2, a, dtrd1, dtrd2, index )
     !! DLAMRG will create a permutation list which will merge the elements
     !! of A (which is composed of two independently sorted sets) into a
     !! single set which is sorted in ascending order.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: dtrd1, dtrd2, n1, n2
           ! Array Arguments 
           integer(ilp), intent(out) :: index(*)
           real(dp), intent(in) :: a(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ind1, ind2, n1sv, n2sv
           ! Executable Statements 
           n1sv = n1
           n2sv = n2
           if( dtrd1>0 ) then
              ind1 = 1
           else
              ind1 = n1
           end if
           if( dtrd2>0 ) then
              ind2 = 1 + n1
           else
              ind2 = n1 + n2
           end if
           i = 1
           ! while ( (n1sv > 0)
           10 continue
           if( n1sv>0 .and. n2sv>0 ) then
              if( a( ind1 )<=a( ind2 ) ) then
                 index( i ) = ind1
                 i = i + 1
                 ind1 = ind1 + dtrd1
                 n1sv = n1sv - 1
              else
                 index( i ) = ind2
                 i = i + 1
                 ind2 = ind2 + dtrd2
                 n2sv = n2sv - 1
              end if
              go to 10
           end if
           ! end while
           if( n1sv==0 ) then
              do n1sv = 1, n2sv
                 index( i ) = ind2
                 i = i + 1
                 ind2 = ind2 + dtrd2
              end do
           else
           ! n2sv == 0
              do n2sv = 1, n1sv
                 index( i ) = ind1
                 i = i + 1
                 ind1 = ind1 + dtrd1
              end do
           end if
           return
     end subroutine stdlib_dlamrg

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$lamrg( n1, n2, a, dtrd1, dtrd2, index )
     !! DLAMRG: will create a permutation list which will merge the elements
     !! of A (which is composed of two independently sorted sets) into a
     !! single set which is sorted in ascending order.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: dtrd1, dtrd2, n1, n2
           ! Array Arguments 
           integer(ilp), intent(out) :: index(*)
           real(${rk}$), intent(in) :: a(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ind1, ind2, n1sv, n2sv
           ! Executable Statements 
           n1sv = n1
           n2sv = n2
           if( dtrd1>0 ) then
              ind1 = 1
           else
              ind1 = n1
           end if
           if( dtrd2>0 ) then
              ind2 = 1 + n1
           else
              ind2 = n1 + n2
           end if
           i = 1
           ! while ( (n1sv > 0)
           10 continue
           if( n1sv>0 .and. n2sv>0 ) then
              if( a( ind1 )<=a( ind2 ) ) then
                 index( i ) = ind1
                 i = i + 1
                 ind1 = ind1 + dtrd1
                 n1sv = n1sv - 1
              else
                 index( i ) = ind2
                 i = i + 1
                 ind2 = ind2 + dtrd2
                 n2sv = n2sv - 1
              end if
              go to 10
           end if
           ! end while
           if( n1sv==0 ) then
              do n1sv = 1, n2sv
                 index( i ) = ind2
                 i = i + 1
                 ind2 = ind2 + dtrd2
              end do
           else
           ! n2sv == 0
              do n2sv = 1, n1sv
                 index( i ) = ind1
                 i = i + 1
                 ind1 = ind1 + dtrd1
              end do
           end if
           return
     end subroutine stdlib_${ri}$lamrg

#:endif
#:endfor



     pure subroutine stdlib_cungtr( uplo, n, a, lda, tau, work, lwork, info )
     !! CUNGTR generates a complex unitary matrix Q which is defined as the
     !! product of n-1 elementary reflectors of order N, as returned by
     !! CHETRD:
     !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*)
           complex(sp), intent(in) :: tau(*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, j, lwkopt, nb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<max( 1, n-1 ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              if ( upper ) then
                nb = stdlib_ilaenv( 1, 'CUNGQL', ' ', n-1, n-1, n-1, -1 )
              else
                nb = stdlib_ilaenv( 1, 'CUNGQR', ' ', n-1, n-1, n-1, -1 )
              end if
              lwkopt = max( 1, n-1 )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CUNGTR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           if( upper ) then
              ! q was determined by a call to stdlib_chetrd with uplo = 'u'
              ! shift the vectors which define the elementary reflectors cone
              ! column to the left, and set the last row and column of q to
              ! those of the unit matrix
              do j = 1, n - 1
                 do i = 1, j - 1
                    a( i, j ) = a( i, j+1 )
                 end do
                 a( n, j ) = czero
              end do
              do i = 1, n - 1
                 a( i, n ) = czero
              end do
              a( n, n ) = cone
              ! generate q(1:n-1,1:n-1)
              call stdlib_cungql( n-1, n-1, n-1, a, lda, tau, work, lwork, iinfo )
           else
              ! q was determined by a call to stdlib_chetrd with uplo = 'l'.
              ! shift the vectors which define the elementary reflectors cone
              ! column to the right, and set the first row and column of q to
              ! those of the unit matrix
              do j = n, 2, -1
                 a( 1, j ) = czero
                 do i = j + 1, n
                    a( i, j ) = a( i, j-1 )
                 end do
              end do
              a( 1, 1 ) = cone
              do i = 2, n
                 a( i, 1 ) = czero
              end do
              if( n>1 ) then
                 ! generate q(2:n,2:n)
                 call stdlib_cungqr( n-1, n-1, n-1, a( 2, 2 ), lda, tau, work,lwork, iinfo )
                           
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_cungtr

     pure subroutine stdlib_zungtr( uplo, n, a, lda, tau, work, lwork, info )
     !! ZUNGTR generates a complex unitary matrix Q which is defined as the
     !! product of n-1 elementary reflectors of order N, as returned by
     !! ZHETRD:
     !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*)
           complex(dp), intent(in) :: tau(*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, j, lwkopt, nb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<max( 1, n-1 ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              if( upper ) then
                 nb = stdlib_ilaenv( 1, 'ZUNGQL', ' ', n-1, n-1, n-1, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'ZUNGQR', ' ', n-1, n-1, n-1, -1 )
              end if
              lwkopt = max( 1, n-1 )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZUNGTR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           if( upper ) then
              ! q was determined by a call to stdlib_zhetrd with uplo = 'u'
              ! shift the vectors which define the elementary reflectors cone
              ! column to the left, and set the last row and column of q to
              ! those of the unit matrix
              do j = 1, n - 1
                 do i = 1, j - 1
                    a( i, j ) = a( i, j+1 )
                 end do
                 a( n, j ) = czero
              end do
              do i = 1, n - 1
                 a( i, n ) = czero
              end do
              a( n, n ) = cone
              ! generate q(1:n-1,1:n-1)
              call stdlib_zungql( n-1, n-1, n-1, a, lda, tau, work, lwork, iinfo )
           else
              ! q was determined by a call to stdlib_zhetrd with uplo = 'l'.
              ! shift the vectors which define the elementary reflectors cone
              ! column to the right, and set the first row and column of q to
              ! those of the unit matrix
              do j = n, 2, -1
                 a( 1, j ) = czero
                 do i = j + 1, n
                    a( i, j ) = a( i, j-1 )
                 end do
              end do
              a( 1, 1 ) = cone
              do i = 2, n
                 a( i, 1 ) = czero
              end do
              if( n>1 ) then
                 ! generate q(2:n,2:n)
                 call stdlib_zungqr( n-1, n-1, n-1, a( 2, 2 ), lda, tau, work,lwork, iinfo )
                           
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zungtr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$ungtr( uplo, n, a, lda, tau, work, lwork, info )
     !! ZUNGTR: generates a complex unitary matrix Q which is defined as the
     !! product of n-1 elementary reflectors of order N, as returned by
     !! ZHETRD:
     !! if UPLO = 'U', Q = H(n-1) . . . H(2) H(1),
     !! if UPLO = 'L', Q = H(1) H(2) . . . H(n-1).
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, lwork, n
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*)
           complex(${ck}$), intent(in) :: tau(*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, upper
           integer(ilp) :: i, iinfo, j, lwkopt, nb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input arguments
           info = 0
           lquery = ( lwork==-1 )
           upper = stdlib_lsame( uplo, 'U' )
           if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( lwork<max( 1, n-1 ) .and. .not.lquery ) then
              info = -7
           end if
           if( info==0 ) then
              if( upper ) then
                 nb = stdlib_ilaenv( 1, 'ZUNGQL', ' ', n-1, n-1, n-1, -1 )
              else
                 nb = stdlib_ilaenv( 1, 'ZUNGQR', ' ', n-1, n-1, n-1, -1 )
              end if
              lwkopt = max( 1, n-1 )*nb
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZUNGTR', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              work( 1 ) = 1
              return
           end if
           if( upper ) then
              ! q was determined by a call to stdlib_${ci}$hetrd with uplo = 'u'
              ! shift the vectors which define the elementary reflectors cone
              ! column to the left, and set the last row and column of q to
              ! those of the unit matrix
              do j = 1, n - 1
                 do i = 1, j - 1
                    a( i, j ) = a( i, j+1 )
                 end do
                 a( n, j ) = czero
              end do
              do i = 1, n - 1
                 a( i, n ) = czero
              end do
              a( n, n ) = cone
              ! generate q(1:n-1,1:n-1)
              call stdlib_${ci}$ungql( n-1, n-1, n-1, a, lda, tau, work, lwork, iinfo )
           else
              ! q was determined by a call to stdlib_${ci}$hetrd with uplo = 'l'.
              ! shift the vectors which define the elementary reflectors cone
              ! column to the right, and set the first row and column of q to
              ! those of the unit matrix
              do j = n, 2, -1
                 a( 1, j ) = czero
                 do i = j + 1, n
                    a( i, j ) = a( i, j-1 )
                 end do
              end do
              a( 1, 1 ) = cone
              do i = 2, n
                 a( i, 1 ) = czero
              end do
              if( n>1 ) then
                 ! generate q(2:n,2:n)
                 call stdlib_${ci}$ungqr( n-1, n-1, n-1, a( 2, 2 ), lda, tau, work,lwork, iinfo )
                           
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$ungtr

#:endif
#:endfor



     pure subroutine stdlib_slaed7( icompq, n, qsiz, tlvls, curlvl, curpbm, d, q,ldq, indxq, rho, &
     !! SLAED7 computes the updated eigensystem of a diagonal
     !! matrix after modification by a rank-one symmetric matrix. This
     !! routine is used only for the eigenproblem which requires all
     !! eigenvalues and optionally eigenvectors of a dense symmetric matrix
     !! that has been reduced to tridiagonal form.  SLAED1 handles
     !! the case in which all eigenvalues and eigenvectors of a symmetric
     !! tridiagonal matrix are desired.
     !! T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)
     !! where Z = Q**Tu, u is a vector of length N with ones in the
     !! CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
     !! The eigenvectors of the original matrix are stored in Q, and the
     !! eigenvalues are in D.  The algorithm consists of three stages:
     !! The first stage consists of deflating the size of the problem
     !! when there are multiple eigenvalues or if there is a zero in
     !! the Z vector.  For each such occurrence the dimension of the
     !! secular equation problem is reduced by one.  This stage is
     !! performed by the routine SLAED8.
     !! The second stage consists of calculating the updated
     !! eigenvalues. This is done by finding the roots of the secular
     !! equation via the routine SLAED4 (as called by SLAED9).
     !! This routine also calculates the eigenvectors of the current
     !! problem.
     !! The final stage consists of computing the updated eigenvectors
     !! directly using the updated eigenvalues.  The eigenvectors for
     !! the current problem are multiplied with the eigenvectors from
     !! the overall problem.
               cutpnt, qstore, qptr, prmptr,perm, givptr, givcol, givnum, work, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: curlvl, curpbm, cutpnt, icompq, ldq, n, qsiz, tlvls
           integer(ilp), intent(out) :: info
           real(sp), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(inout) :: givcol(2,*), givptr(*), perm(*), prmptr(*), qptr(*)
                     
           integer(ilp), intent(out) :: indxq(*), iwork(*)
           real(sp), intent(inout) :: d(*), givnum(2,*), q(ldq,*), qstore(*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: coltyp, curr, i, idlmda, indx, indxc, indxp, iq2, is, iw, iz, k, ldq2, &
                     n1, n2, ptr
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( icompq<0 .or. icompq>1 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( icompq==1 .and. qsiz<n ) then
              info = -3
           else if( ldq<max( 1, n ) ) then
              info = -9
           else if( min( 1, n )>cutpnt .or. n<cutpnt ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SLAED7', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! the following values are for bookkeeping purposes only.  they are
           ! integer pointers which indicate the portion of the workspace
           ! used by a particular array in stdlib_slaed8 and stdlib_slaed9.
           if( icompq==1 ) then
              ldq2 = qsiz
           else
              ldq2 = n
           end if
           iz = 1
           idlmda = iz + n
           iw = idlmda + n
           iq2 = iw + n
           is = iq2 + n*ldq2
           indx = 1
           indxc = indx + n
           coltyp = indxc + n
           indxp = coltyp + n
           ! form the z-vector which consists of the last row of q_1 and the
           ! first row of q_2.
           ptr = 1 + 2**tlvls
           do i = 1, curlvl - 1
              ptr = ptr + 2**( tlvls-i )
           end do
           curr = ptr + curpbm
           call stdlib_slaeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, givnum, &
                     qstore, qptr, work( iz ),work( iz+n ), info )
           ! when solving the final problem, we no longer need the stored data,
           ! so we will overwrite the data from this level onto the previously
           ! used storage space.
           if( curlvl==tlvls ) then
              qptr( curr ) = 1
              prmptr( curr ) = 1
              givptr( curr ) = 1
           end if
           ! sort and deflate eigenvalues.
           call stdlib_slaed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho, cutpnt,work( iz ), work(&
            idlmda ), work( iq2 ), ldq2,work( iw ), perm( prmptr( curr ) ), givptr( curr+1 ),&
            givcol( 1, givptr( curr ) ),givnum( 1, givptr( curr ) ), iwork( indxp ),iwork( indx ),&
                       info )
           prmptr( curr+1 ) = prmptr( curr ) + n
           givptr( curr+1 ) = givptr( curr+1 ) + givptr( curr )
           ! solve secular equation.
           if( k/=0 ) then
              call stdlib_slaed9( k, 1, k, n, d, work( is ), k, rho, work( idlmda ),work( iw ), &
                        qstore( qptr( curr ) ), k, info )
              if( info/=0 )go to 30
              if( icompq==1 ) then
                 call stdlib_sgemm( 'N', 'N', qsiz, k, k, one, work( iq2 ), ldq2,qstore( qptr( &
                           curr ) ), k, zero, q, ldq )
              end if
              qptr( curr+1 ) = qptr( curr ) + k**2
           ! prepare the indxq sorting permutation.
              n1 = k
              n2 = n - k
              call stdlib_slamrg( n1, n2, d, 1, -1, indxq )
           else
              qptr( curr+1 ) = qptr( curr )
              do i = 1, n
                 indxq( i ) = i
              end do
           end if
           30 continue
           return
     end subroutine stdlib_slaed7

     pure subroutine stdlib_dlaed7( icompq, n, qsiz, tlvls, curlvl, curpbm, d, q,ldq, indxq, rho, &
     !! DLAED7 computes the updated eigensystem of a diagonal
     !! matrix after modification by a rank-one symmetric matrix. This
     !! routine is used only for the eigenproblem which requires all
     !! eigenvalues and optionally eigenvectors of a dense symmetric matrix
     !! that has been reduced to tridiagonal form.  DLAED1 handles
     !! the case in which all eigenvalues and eigenvectors of a symmetric
     !! tridiagonal matrix are desired.
     !! T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)
     !! where Z = Q**Tu, u is a vector of length N with ones in the
     !! CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
     !! The eigenvectors of the original matrix are stored in Q, and the
     !! eigenvalues are in D.  The algorithm consists of three stages:
     !! The first stage consists of deflating the size of the problem
     !! when there are multiple eigenvalues or if there is a zero in
     !! the Z vector.  For each such occurrence the dimension of the
     !! secular equation problem is reduced by one.  This stage is
     !! performed by the routine DLAED8.
     !! The second stage consists of calculating the updated
     !! eigenvalues. This is done by finding the roots of the secular
     !! equation via the routine DLAED4 (as called by DLAED9).
     !! This routine also calculates the eigenvectors of the current
     !! problem.
     !! The final stage consists of computing the updated eigenvectors
     !! directly using the updated eigenvalues.  The eigenvectors for
     !! the current problem are multiplied with the eigenvectors from
     !! the overall problem.
               cutpnt, qstore, qptr, prmptr,perm, givptr, givcol, givnum, work, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: curlvl, curpbm, cutpnt, icompq, ldq, n, qsiz, tlvls
           integer(ilp), intent(out) :: info
           real(dp), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(inout) :: givcol(2,*), givptr(*), perm(*), prmptr(*), qptr(*)
                     
           integer(ilp), intent(out) :: indxq(*), iwork(*)
           real(dp), intent(inout) :: d(*), givnum(2,*), q(ldq,*), qstore(*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: coltyp, curr, i, idlmda, indx, indxc, indxp, iq2, is, iw, iz, k, ldq2, &
                     n1, n2, ptr
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( icompq<0 .or. icompq>1 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( icompq==1 .and. qsiz<n ) then
              info = -3
           else if( ldq<max( 1, n ) ) then
              info = -9
           else if( min( 1, n )>cutpnt .or. n<cutpnt ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED7', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! the following values are for bookkeeping purposes only.  they are
           ! integer pointers which indicate the portion of the workspace
           ! used by a particular array in stdlib_dlaed8 and stdlib_dlaed9.
           if( icompq==1 ) then
              ldq2 = qsiz
           else
              ldq2 = n
           end if
           iz = 1
           idlmda = iz + n
           iw = idlmda + n
           iq2 = iw + n
           is = iq2 + n*ldq2
           indx = 1
           indxc = indx + n
           coltyp = indxc + n
           indxp = coltyp + n
           ! form the z-vector which consists of the last row of q_1 and the
           ! first row of q_2.
           ptr = 1 + 2**tlvls
           do i = 1, curlvl - 1
              ptr = ptr + 2**( tlvls-i )
           end do
           curr = ptr + curpbm
           call stdlib_dlaeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, givnum, &
                     qstore, qptr, work( iz ),work( iz+n ), info )
           ! when solving the final problem, we no longer need the stored data,
           ! so we will overwrite the data from this level onto the previously
           ! used storage space.
           if( curlvl==tlvls ) then
              qptr( curr ) = 1
              prmptr( curr ) = 1
              givptr( curr ) = 1
           end if
           ! sort and deflate eigenvalues.
           call stdlib_dlaed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho, cutpnt,work( iz ), work(&
            idlmda ), work( iq2 ), ldq2,work( iw ), perm( prmptr( curr ) ), givptr( curr+1 ),&
            givcol( 1, givptr( curr ) ),givnum( 1, givptr( curr ) ), iwork( indxp ),iwork( indx ),&
                       info )
           prmptr( curr+1 ) = prmptr( curr ) + n
           givptr( curr+1 ) = givptr( curr+1 ) + givptr( curr )
           ! solve secular equation.
           if( k/=0 ) then
              call stdlib_dlaed9( k, 1, k, n, d, work( is ), k, rho, work( idlmda ),work( iw ), &
                        qstore( qptr( curr ) ), k, info )
              if( info/=0 )go to 30
              if( icompq==1 ) then
                 call stdlib_dgemm( 'N', 'N', qsiz, k, k, one, work( iq2 ), ldq2,qstore( qptr( &
                           curr ) ), k, zero, q, ldq )
              end if
              qptr( curr+1 ) = qptr( curr ) + k**2
           ! prepare the indxq sorting permutation.
              n1 = k
              n2 = n - k
              call stdlib_dlamrg( n1, n2, d, 1, -1, indxq )
           else
              qptr( curr+1 ) = qptr( curr )
              do i = 1, n
                 indxq( i ) = i
              end do
           end if
           30 continue
           return
     end subroutine stdlib_dlaed7

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$laed7( icompq, n, qsiz, tlvls, curlvl, curpbm, d, q,ldq, indxq, rho, &
     !! DLAED7: computes the updated eigensystem of a diagonal
     !! matrix after modification by a rank-one symmetric matrix. This
     !! routine is used only for the eigenproblem which requires all
     !! eigenvalues and optionally eigenvectors of a dense symmetric matrix
     !! that has been reduced to tridiagonal form.  DLAED1 handles
     !! the case in which all eigenvalues and eigenvectors of a symmetric
     !! tridiagonal matrix are desired.
     !! T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)
     !! where Z = Q**Tu, u is a vector of length N with ones in the
     !! CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
     !! The eigenvectors of the original matrix are stored in Q, and the
     !! eigenvalues are in D.  The algorithm consists of three stages:
     !! The first stage consists of deflating the size of the problem
     !! when there are multiple eigenvalues or if there is a zero in
     !! the Z vector.  For each such occurrence the dimension of the
     !! secular equation problem is reduced by one.  This stage is
     !! performed by the routine DLAED8.
     !! The second stage consists of calculating the updated
     !! eigenvalues. This is done by finding the roots of the secular
     !! equation via the routine DLAED4 (as called by DLAED9).
     !! This routine also calculates the eigenvectors of the current
     !! problem.
     !! The final stage consists of computing the updated eigenvectors
     !! directly using the updated eigenvalues.  The eigenvectors for
     !! the current problem are multiplied with the eigenvectors from
     !! the overall problem.
               cutpnt, qstore, qptr, prmptr,perm, givptr, givcol, givnum, work, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: curlvl, curpbm, cutpnt, icompq, ldq, n, qsiz, tlvls
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(inout) :: givcol(2,*), givptr(*), perm(*), prmptr(*), qptr(*)
                     
           integer(ilp), intent(out) :: indxq(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), givnum(2,*), q(ldq,*), qstore(*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: coltyp, curr, i, idlmda, indx, indxc, indxp, iq2, is, iw, iz, k, ldq2, &
                     n1, n2, ptr
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( icompq<0 .or. icompq>1 ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( icompq==1 .and. qsiz<n ) then
              info = -3
           else if( ldq<max( 1, n ) ) then
              info = -9
           else if( min( 1, n )>cutpnt .or. n<cutpnt ) then
              info = -12
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DLAED7', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! the following values are for bookkeeping purposes only.  they are
           ! integer pointers which indicate the portion of the workspace
           ! used by a particular array in stdlib_${ri}$laed8 and stdlib_${ri}$laed9.
           if( icompq==1 ) then
              ldq2 = qsiz
           else
              ldq2 = n
           end if
           iz = 1
           idlmda = iz + n
           iw = idlmda + n
           iq2 = iw + n
           is = iq2 + n*ldq2
           indx = 1
           indxc = indx + n
           coltyp = indxc + n
           indxp = coltyp + n
           ! form the z-vector which consists of the last row of q_1 and the
           ! first row of q_2.
           ptr = 1 + 2**tlvls
           do i = 1, curlvl - 1
              ptr = ptr + 2**( tlvls-i )
           end do
           curr = ptr + curpbm
           call stdlib_${ri}$laeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, givnum, &
                     qstore, qptr, work( iz ),work( iz+n ), info )
           ! when solving the final problem, we no longer need the stored data,
           ! so we will overwrite the data from this level onto the previously
           ! used storage space.
           if( curlvl==tlvls ) then
              qptr( curr ) = 1
              prmptr( curr ) = 1
              givptr( curr ) = 1
           end if
           ! sort and deflate eigenvalues.
           call stdlib_${ri}$laed8( icompq, k, n, qsiz, d, q, ldq, indxq, rho, cutpnt,work( iz ), work(&
            idlmda ), work( iq2 ), ldq2,work( iw ), perm( prmptr( curr ) ), givptr( curr+1 ),&
            givcol( 1, givptr( curr ) ),givnum( 1, givptr( curr ) ), iwork( indxp ),iwork( indx ),&
                       info )
           prmptr( curr+1 ) = prmptr( curr ) + n
           givptr( curr+1 ) = givptr( curr+1 ) + givptr( curr )
           ! solve secular equation.
           if( k/=0 ) then
              call stdlib_${ri}$laed9( k, 1, k, n, d, work( is ), k, rho, work( idlmda ),work( iw ), &
                        qstore( qptr( curr ) ), k, info )
              if( info/=0 )go to 30
              if( icompq==1 ) then
                 call stdlib_${ri}$gemm( 'N', 'N', qsiz, k, k, one, work( iq2 ), ldq2,qstore( qptr( &
                           curr ) ), k, zero, q, ldq )
              end if
              qptr( curr+1 ) = qptr( curr ) + k**2
           ! prepare the indxq sorting permutation.
              n1 = k
              n2 = n - k
              call stdlib_${ri}$lamrg( n1, n2, d, 1, -1, indxq )
           else
              qptr( curr+1 ) = qptr( curr )
              do i = 1, n
                 indxq( i ) = i
              end do
           end if
           30 continue
           return
     end subroutine stdlib_${ri}$laed7

#:endif
#:endfor

     pure subroutine stdlib_claed7( n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q,ldq, rho, indxq, &
     !! CLAED7 computes the updated eigensystem of a diagonal
     !! matrix after modification by a rank-one symmetric matrix. This
     !! routine is used only for the eigenproblem which requires all
     !! eigenvalues and optionally eigenvectors of a dense or banded
     !! Hermitian matrix that has been reduced to tridiagonal form.
     !! T = Q(in) ( D(in) + RHO * Z*Z**H ) Q**H(in) = Q(out) * D(out) * Q**H(out)
     !! where Z = Q**Hu, u is a vector of length N with ones in the
     !! CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
     !! The eigenvectors of the original matrix are stored in Q, and the
     !! eigenvalues are in D.  The algorithm consists of three stages:
     !! The first stage consists of deflating the size of the problem
     !! when there are multiple eigenvalues or if there is a zero in
     !! the Z vector.  For each such occurrence the dimension of the
     !! secular equation problem is reduced by one.  This stage is
     !! performed by the routine SLAED2.
     !! The second stage consists of calculating the updated
     !! eigenvalues. This is done by finding the roots of the secular
     !! equation via the routine SLAED4 (as called by SLAED3).
     !! This routine also calculates the eigenvectors of the current
     !! problem.
     !! The final stage consists of computing the updated eigenvectors
     !! directly using the updated eigenvalues.  The eigenvectors for
     !! the current problem are multiplied with the eigenvectors from
     !! the overall problem.
               qstore, qptr, prmptr, perm,givptr, givcol, givnum, work, rwork, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: curlvl, curpbm, cutpnt, ldq, n, qsiz, tlvls
           integer(ilp), intent(out) :: info
           real(sp), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(inout) :: givcol(2,*), givptr(*), perm(*), prmptr(*), qptr(*)
                     
           integer(ilp), intent(out) :: indxq(*), iwork(*)
           real(sp), intent(inout) :: d(*), givnum(2,*), qstore(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: q(ldq,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: coltyp, curr, i, idlmda, indx, indxc, indxp, iq, iw, iz, k, n1, n2, &
                     ptr
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           ! if( icompq<0 .or. icompq>1 ) then
              ! info = -1
           ! else if( n<0 ) then
           if( n<0 ) then
              info = -1
           else if( min( 1, n )>cutpnt .or. n<cutpnt ) then
              info = -2
           else if( qsiz<n ) then
              info = -3
           else if( ldq<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CLAED7', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! the following values are for bookkeeping purposes only.  they are
           ! integer pointers which indicate the portion of the workspace
           ! used by a particular array in stdlib_slaed2 and stdlib_slaed3.
           iz = 1
           idlmda = iz + n
           iw = idlmda + n
           iq = iw + n
           indx = 1
           indxc = indx + n
           coltyp = indxc + n
           indxp = coltyp + n
           ! form the z-vector which consists of the last row of q_1 and the
           ! first row of q_2.
           ptr = 1 + 2**tlvls
           do i = 1, curlvl - 1
              ptr = ptr + 2**( tlvls-i )
           end do
           curr = ptr + curpbm
           call stdlib_slaeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, givnum, &
                     qstore, qptr, rwork( iz ),rwork( iz+n ), info )
           ! when solving the final problem, we no longer need the stored data,
           ! so we will overwrite the data from this level onto the previously
           ! used storage space.
           if( curlvl==tlvls ) then
              qptr( curr ) = 1
              prmptr( curr ) = 1
              givptr( curr ) = 1
           end if
           ! sort and deflate eigenvalues.
           call stdlib_claed8( k, n, qsiz, q, ldq, d, rho, cutpnt, rwork( iz ),rwork( idlmda ), &
           work, qsiz, rwork( iw ),iwork( indxp ), iwork( indx ), indxq,perm( prmptr( curr ) ), &
           givptr( curr+1 ),givcol( 1, givptr( curr ) ),givnum( 1, givptr( curr ) ), info )
                     
           prmptr( curr+1 ) = prmptr( curr ) + n
           givptr( curr+1 ) = givptr( curr+1 ) + givptr( curr )
           ! solve secular equation.
           if( k/=0 ) then
              call stdlib_slaed9( k, 1, k, n, d, rwork( iq ), k, rho,rwork( idlmda ), rwork( iw ),&
                        qstore( qptr( curr ) ), k, info )
              call stdlib_clacrm( qsiz, k, work, qsiz, qstore( qptr( curr ) ), k, q,ldq, rwork( &
                        iq ) )
              qptr( curr+1 ) = qptr( curr ) + k**2
              if( info/=0 ) then
                 return
              end if
           ! prepare the indxq sorting premutation.
              n1 = k
              n2 = n - k
              call stdlib_slamrg( n1, n2, d, 1, -1, indxq )
           else
              qptr( curr+1 ) = qptr( curr )
              do i = 1, n
                 indxq( i ) = i
              end do
           end if
           return
     end subroutine stdlib_claed7

     pure subroutine stdlib_zlaed7( n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q,ldq, rho, indxq, &
     !! ZLAED7 computes the updated eigensystem of a diagonal
     !! matrix after modification by a rank-one symmetric matrix. This
     !! routine is used only for the eigenproblem which requires all
     !! eigenvalues and optionally eigenvectors of a dense or banded
     !! Hermitian matrix that has been reduced to tridiagonal form.
     !! T = Q(in) ( D(in) + RHO * Z*Z**H ) Q**H(in) = Q(out) * D(out) * Q**H(out)
     !! where Z = Q**Hu, u is a vector of length N with ones in the
     !! CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
     !! The eigenvectors of the original matrix are stored in Q, and the
     !! eigenvalues are in D.  The algorithm consists of three stages:
     !! The first stage consists of deflating the size of the problem
     !! when there are multiple eigenvalues or if there is a zero in
     !! the Z vector.  For each such occurrence the dimension of the
     !! secular equation problem is reduced by one.  This stage is
     !! performed by the routine DLAED2.
     !! The second stage consists of calculating the updated
     !! eigenvalues. This is done by finding the roots of the secular
     !! equation via the routine DLAED4 (as called by SLAED3).
     !! This routine also calculates the eigenvectors of the current
     !! problem.
     !! The final stage consists of computing the updated eigenvectors
     !! directly using the updated eigenvalues.  The eigenvectors for
     !! the current problem are multiplied with the eigenvectors from
     !! the overall problem.
               qstore, qptr, prmptr, perm,givptr, givcol, givnum, work, rwork, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: curlvl, curpbm, cutpnt, ldq, n, qsiz, tlvls
           integer(ilp), intent(out) :: info
           real(dp), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(inout) :: givcol(2,*), givptr(*), perm(*), prmptr(*), qptr(*)
                     
           integer(ilp), intent(out) :: indxq(*), iwork(*)
           real(dp), intent(inout) :: d(*), givnum(2,*), qstore(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: q(ldq,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: coltyp, curr, i, idlmda, indx, indxc, indxp, iq, iw, iz, k, n1, n2, &
                     ptr
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           ! if( icompq<0 .or. icompq>1 ) then
              ! info = -1
           ! else if( n<0 ) then
           if( n<0 ) then
              info = -1
           else if( min( 1, n )>cutpnt .or. n<cutpnt ) then
              info = -2
           else if( qsiz<n ) then
              info = -3
           else if( ldq<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZLAED7', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! the following values are for bookkeeping purposes only.  they are
           ! integer pointers which indicate the portion of the workspace
           ! used by a particular array in stdlib_dlaed2 and stdlib_slaed3.
           iz = 1
           idlmda = iz + n
           iw = idlmda + n
           iq = iw + n
           indx = 1
           indxc = indx + n
           coltyp = indxc + n
           indxp = coltyp + n
           ! form the z-vector which consists of the last row of q_1 and the
           ! first row of q_2.
           ptr = 1 + 2**tlvls
           do i = 1, curlvl - 1
              ptr = ptr + 2**( tlvls-i )
           end do
           curr = ptr + curpbm
           call stdlib_dlaeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, givnum, &
                     qstore, qptr, rwork( iz ),rwork( iz+n ), info )
           ! when solving the final problem, we no longer need the stored data,
           ! so we will overwrite the data from this level onto the previously
           ! used storage space.
           if( curlvl==tlvls ) then
              qptr( curr ) = 1
              prmptr( curr ) = 1
              givptr( curr ) = 1
           end if
           ! sort and deflate eigenvalues.
           call stdlib_zlaed8( k, n, qsiz, q, ldq, d, rho, cutpnt, rwork( iz ),rwork( idlmda ), &
           work, qsiz, rwork( iw ),iwork( indxp ), iwork( indx ), indxq,perm( prmptr( curr ) ), &
           givptr( curr+1 ),givcol( 1, givptr( curr ) ),givnum( 1, givptr( curr ) ), info )
                     
           prmptr( curr+1 ) = prmptr( curr ) + n
           givptr( curr+1 ) = givptr( curr+1 ) + givptr( curr )
           ! solve secular equation.
           if( k/=0 ) then
              call stdlib_dlaed9( k, 1, k, n, d, rwork( iq ), k, rho,rwork( idlmda ), rwork( iw ),&
                        qstore( qptr( curr ) ), k, info )
              call stdlib_zlacrm( qsiz, k, work, qsiz, qstore( qptr( curr ) ), k, q,ldq, rwork( &
                        iq ) )
              qptr( curr+1 ) = qptr( curr ) + k**2
              if( info/=0 ) then
                 return
              end if
           ! prepare the indxq sorting premutation.
              n1 = k
              n2 = n - k
              call stdlib_dlamrg( n1, n2, d, 1, -1, indxq )
           else
              qptr( curr+1 ) = qptr( curr )
              do i = 1, n
                 indxq( i ) = i
              end do
           end if
           return
     end subroutine stdlib_zlaed7

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$laed7( n, cutpnt, qsiz, tlvls, curlvl, curpbm, d, q,ldq, rho, indxq, &
     !! ZLAED7: computes the updated eigensystem of a diagonal
     !! matrix after modification by a rank-one symmetric matrix. This
     !! routine is used only for the eigenproblem which requires all
     !! eigenvalues and optionally eigenvectors of a dense or banded
     !! Hermitian matrix that has been reduced to tridiagonal form.
     !! T = Q(in) ( D(in) + RHO * Z*Z**H ) Q**H(in) = Q(out) * D(out) * Q**H(out)
     !! where Z = Q**Hu, u is a vector of length N with ones in the
     !! CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
     !! The eigenvectors of the original matrix are stored in Q, and the
     !! eigenvalues are in D.  The algorithm consists of three stages:
     !! The first stage consists of deflating the size of the problem
     !! when there are multiple eigenvalues or if there is a zero in
     !! the Z vector.  For each such occurrence the dimension of the
     !! secular equation problem is reduced by one.  This stage is
     !! performed by the routine DLAED2.
     !! The second stage consists of calculating the updated
     !! eigenvalues. This is done by finding the roots of the secular
     !! equation via the routine DLAED4 (as called by SLAED3).
     !! This routine also calculates the eigenvectors of the current
     !! problem.
     !! The final stage consists of computing the updated eigenvectors
     !! directly using the updated eigenvalues.  The eigenvectors for
     !! the current problem are multiplied with the eigenvectors from
     !! the overall problem.
               qstore, qptr, prmptr, perm,givptr, givcol, givnum, work, rwork, iwork,info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: curlvl, curpbm, cutpnt, ldq, n, qsiz, tlvls
           integer(ilp), intent(out) :: info
           real(${ck}$), intent(inout) :: rho
           ! Array Arguments 
           integer(ilp), intent(inout) :: givcol(2,*), givptr(*), perm(*), prmptr(*), qptr(*)
                     
           integer(ilp), intent(out) :: indxq(*), iwork(*)
           real(${ck}$), intent(inout) :: d(*), givnum(2,*), qstore(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: q(ldq,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: coltyp, curr, i, idlmda, indx, indxc, indxp, iq, iw, iz, k, n1, n2, &
                     ptr
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           ! if( icompq<0 .or. icompq>1 ) then
              ! info = -1
           ! else if( n<0 ) then
           if( n<0 ) then
              info = -1
           else if( min( 1, n )>cutpnt .or. n<cutpnt ) then
              info = -2
           else if( qsiz<n ) then
              info = -3
           else if( ldq<max( 1, n ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZLAED7', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! the following values are for bookkeeping purposes only.  they are
           ! integer pointers which indicate the portion of the workspace
           ! used by a particular array in stdlib_${c2ri(ci)}$laed2 and stdlib_dlaed3.
           iz = 1
           idlmda = iz + n
           iw = idlmda + n
           iq = iw + n
           indx = 1
           indxc = indx + n
           coltyp = indxc + n
           indxp = coltyp + n
           ! form the z-vector which consists of the last row of q_1 and the
           ! first row of q_2.
           ptr = 1 + 2**tlvls
           do i = 1, curlvl - 1
              ptr = ptr + 2**( tlvls-i )
           end do
           curr = ptr + curpbm
           call stdlib_${c2ri(ci)}$laeda( n, tlvls, curlvl, curpbm, prmptr, perm, givptr,givcol, givnum, &
                     qstore, qptr, rwork( iz ),rwork( iz+n ), info )
           ! when solving the final problem, we no longer need the stored data,
           ! so we will overwrite the data from this level onto the previously
           ! used storage space.
           if( curlvl==tlvls ) then
              qptr( curr ) = 1
              prmptr( curr ) = 1
              givptr( curr ) = 1
           end if
           ! sort and deflate eigenvalues.
           call stdlib_${ci}$laed8( k, n, qsiz, q, ldq, d, rho, cutpnt, rwork( iz ),rwork( idlmda ), &
           work, qsiz, rwork( iw ),iwork( indxp ), iwork( indx ), indxq,perm( prmptr( curr ) ), &
           givptr( curr+1 ),givcol( 1, givptr( curr ) ),givnum( 1, givptr( curr ) ), info )
                     
           prmptr( curr+1 ) = prmptr( curr ) + n
           givptr( curr+1 ) = givptr( curr+1 ) + givptr( curr )
           ! solve secular equation.
           if( k/=0 ) then
              call stdlib_${c2ri(ci)}$laed9( k, 1, k, n, d, rwork( iq ), k, rho,rwork( idlmda ), rwork( iw ),&
                        qstore( qptr( curr ) ), k, info )
              call stdlib_${ci}$lacrm( qsiz, k, work, qsiz, qstore( qptr( curr ) ), k, q,ldq, rwork( &
                        iq ) )
              qptr( curr+1 ) = qptr( curr ) + k**2
              if( info/=0 ) then
                 return
              end if
           ! prepare the indxq sorting premutation.
              n1 = k
              n2 = n - k
              call stdlib_${c2ri(ci)}$lamrg( n1, n2, d, 1, -1, indxq )
           else
              qptr( curr+1 ) = qptr( curr )
              do i = 1, n
                 indxq( i ) = i
              end do
           end if
           return
     end subroutine stdlib_${ci}$laed7

#:endif
#:endfor



     pure subroutine stdlib_chbgvx( jobz, range, uplo, n, ka, kb, ab, ldab, bb,ldbb, q, ldq, vl, &
     !! CHBGVX computes all the eigenvalues, and optionally, the eigenvectors
     !! of a complex generalized Hermitian-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
     !! and banded, and B is also positive definite.  Eigenvalues and
     !! eigenvectors can be selected by specifying either all eigenvalues,
     !! a range of values or a range of indices for the desired eigenvalues.
               vu, il, iu, abstol, m, w, z,ldz, work, rwork, iwork, ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, iu, ka, kb, ldab, ldbb, ldq, ldz, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(out) :: rwork(*), w(*)
           complex(sp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(sp), intent(out) :: q(ldq,*), work(*), z(ldz,*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, test, upper, valeig, wantz
           character :: order, vect
           integer(ilp) :: i, iinfo, indd, inde, indee, indibl, indisp, indiwk, indrwk, indwrk, &
                     itmp1, j, jj, nsplit
           real(sp) :: tmp1
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ka<0 ) then
              info = -5
           else if( kb<0 .or. kb>ka ) then
              info = -6
           else if( ldab<ka+1 ) then
              info = -8
           else if( ldbb<kb+1 ) then
              info = -10
           else if( ldq<1 .or. ( wantz .and. ldq<n ) ) then
              info = -12
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -14
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -15
                 else if ( iu<min( n, il ) .or. iu>n ) then
                    info = -16
                 end if
              end if
           end if
           if( info==0) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
                 info = -21
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHBGVX', -info )
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_cpbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           call stdlib_chbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq,work, rwork, &
                     iinfo )
           ! solve the standard eigenvalue problem.
           ! reduce hermitian band matrix to tridiagonal form.
           indd = 1
           inde = indd + n
           indrwk = inde + n
           indwrk = 1
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_chbtrd( vect, uplo, n, ka, ab, ldab, rwork( indd ),rwork( inde ), q, ldq, &
                     work( indwrk ), iinfo )
           ! if all eigenvalues are desired and abstol is less than or equal
           ! to zero, then call stdlib_ssterf or stdlib_csteqr.  if this fails for some
           ! eigenvalue, then try stdlib_sstebz.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig .or. test ) .and. ( abstol<=zero ) ) then
              call stdlib_scopy( n, rwork( indd ), 1, w, 1 )
              indee = indrwk + 2*n
              call stdlib_scopy( n-1, rwork( inde ), 1, rwork( indee ), 1 )
              if( .not.wantz ) then
                 call stdlib_ssterf( n, w, rwork( indee ), info )
              else
                 call stdlib_clacpy( 'A', n, n, q, ldq, z, ldz )
                 call stdlib_csteqr( jobz, n, w, rwork( indee ), z, ldz,rwork( indrwk ), info )
                           
                 if( info==0 ) then
                    do i = 1, n
                       ifail( i ) = 0
                    end do
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 30
              end if
              info = 0
           end if
           ! otherwise, call stdlib_sstebz and, if eigenvectors are desired,
           ! call stdlib_cstein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           indibl = 1
           indisp = indibl + n
           indiwk = indisp + n
           call stdlib_sstebz( range, order, n, vl, vu, il, iu, abstol,rwork( indd ), rwork( inde &
           ), m, nsplit, w,iwork( indibl ), iwork( indisp ), rwork( indrwk ),iwork( indiwk ), &
                     info )
           if( wantz ) then
              call stdlib_cstein( n, rwork( indd ), rwork( inde ), m, w,iwork( indibl ), iwork( &
                        indisp ), z, ldz,rwork( indrwk ), iwork( indiwk ), ifail, info )
              ! apply unitary matrix used in reduction to tridiagonal
              ! form to eigenvectors returned by stdlib_cstein.
              do j = 1, m
                 call stdlib_ccopy( n, z( 1, j ), 1, work( 1 ), 1 )
                 call stdlib_cgemv( 'N', n, n, cone, q, ldq, work, 1, czero,z( 1, j ), 1 )
              end do
           end if
           30 continue
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_cswap( n, z( 1, i ), 1, z( 1, j ), 1 )
                    if( info/=0 ) then
                       itmp1 = ifail( i )
                       ifail( i ) = ifail( j )
                       ifail( j ) = itmp1
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_chbgvx

     pure subroutine stdlib_zhbgvx( jobz, range, uplo, n, ka, kb, ab, ldab, bb,ldbb, q, ldq, vl, &
     !! ZHBGVX computes all the eigenvalues, and optionally, the eigenvectors
     !! of a complex generalized Hermitian-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
     !! and banded, and B is also positive definite.  Eigenvalues and
     !! eigenvectors can be selected by specifying either all eigenvalues,
     !! a range of values or a range of indices for the desired eigenvalues.
               vu, il, iu, abstol, m, w, z,ldz, work, rwork, iwork, ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, iu, ka, kb, ldab, ldbb, ldq, ldz, n
           integer(ilp), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(out) :: rwork(*), w(*)
           complex(dp), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(dp), intent(out) :: q(ldq,*), work(*), z(ldz,*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, test, upper, valeig, wantz
           character :: order, vect
           integer(ilp) :: i, iinfo, indd, inde, indee, indibl, indisp, indiwk, indrwk, indwrk, &
                     itmp1, j, jj, nsplit
           real(dp) :: tmp1
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ka<0 ) then
              info = -5
           else if( kb<0 .or. kb>ka ) then
              info = -6
           else if( ldab<ka+1 ) then
              info = -8
           else if( ldbb<kb+1 ) then
              info = -10
           else if( ldq<1 .or. ( wantz .and. ldq<n ) ) then
              info = -12
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -14
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -15
                 else if ( iu<min( n, il ) .or. iu>n ) then
                    info = -16
                 end if
              end if
           end if
           if( info==0) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
                 info = -21
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHBGVX', -info )
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_zpbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           call stdlib_zhbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq,work, rwork, &
                     iinfo )
           ! solve the standard eigenvalue problem.
           ! reduce hermitian band matrix to tridiagonal form.
           indd = 1
           inde = indd + n
           indrwk = inde + n
           indwrk = 1
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_zhbtrd( vect, uplo, n, ka, ab, ldab, rwork( indd ),rwork( inde ), q, ldq, &
                     work( indwrk ), iinfo )
           ! if all eigenvalues are desired and abstol is less than or equal
           ! to zero, then call stdlib_dsterf or stdlib_zsteqr.  if this fails for some
           ! eigenvalue, then try stdlib_dstebz.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig .or. test ) .and. ( abstol<=zero ) ) then
              call stdlib_dcopy( n, rwork( indd ), 1, w, 1 )
              indee = indrwk + 2*n
              call stdlib_dcopy( n-1, rwork( inde ), 1, rwork( indee ), 1 )
              if( .not.wantz ) then
                 call stdlib_dsterf( n, w, rwork( indee ), info )
              else
                 call stdlib_zlacpy( 'A', n, n, q, ldq, z, ldz )
                 call stdlib_zsteqr( jobz, n, w, rwork( indee ), z, ldz,rwork( indrwk ), info )
                           
                 if( info==0 ) then
                    do i = 1, n
                       ifail( i ) = 0
                    end do
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 30
              end if
              info = 0
           end if
           ! otherwise, call stdlib_dstebz and, if eigenvectors are desired,
           ! call stdlib_zstein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           indibl = 1
           indisp = indibl + n
           indiwk = indisp + n
           call stdlib_dstebz( range, order, n, vl, vu, il, iu, abstol,rwork( indd ), rwork( inde &
           ), m, nsplit, w,iwork( indibl ), iwork( indisp ), rwork( indrwk ),iwork( indiwk ), &
                     info )
           if( wantz ) then
              call stdlib_zstein( n, rwork( indd ), rwork( inde ), m, w,iwork( indibl ), iwork( &
                        indisp ), z, ldz,rwork( indrwk ), iwork( indiwk ), ifail, info )
              ! apply unitary matrix used in reduction to tridiagonal
              ! form to eigenvectors returned by stdlib_zstein.
              do j = 1, m
                 call stdlib_zcopy( n, z( 1, j ), 1, work( 1 ), 1 )
                 call stdlib_zgemv( 'N', n, n, cone, q, ldq, work, 1, czero,z( 1, j ), 1 )
              end do
           end if
           30 continue
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_zswap( n, z( 1, i ), 1, z( 1, j ), 1 )
                    if( info/=0 ) then
                       itmp1 = ifail( i )
                       ifail( i ) = ifail( j )
                       ifail( j ) = itmp1
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_zhbgvx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$hbgvx( jobz, range, uplo, n, ka, kb, ab, ldab, bb,ldbb, q, ldq, vl, &
     !! ZHBGVX: computes all the eigenvalues, and optionally, the eigenvectors
     !! of a complex generalized Hermitian-definite banded eigenproblem, of
     !! the form A*x=(lambda)*B*x. Here A and B are assumed to be Hermitian
     !! and banded, and B is also positive definite.  Eigenvalues and
     !! eigenvectors can be selected by specifying either all eigenvalues,
     !! a range of values or a range of indices for the desired eigenvalues.
               vu, il, iu, abstol, m, w, z,ldz, work, rwork, iwork, ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range, uplo
           integer(ilp), intent(in) :: il, iu, ka, kb, ldab, ldbb, ldq, ldz, n
           integer(ilp), intent(out) :: info, m
           real(${ck}$), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(${ck}$), intent(out) :: rwork(*), w(*)
           complex(${ck}$), intent(inout) :: ab(ldab,*), bb(ldbb,*)
           complex(${ck}$), intent(out) :: q(ldq,*), work(*), z(ldz,*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, test, upper, valeig, wantz
           character :: order, vect
           integer(ilp) :: i, iinfo, indd, inde, indee, indibl, indisp, indiwk, indrwk, indwrk, &
                     itmp1, j, jj, nsplit
           real(${ck}$) :: tmp1
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           upper = stdlib_lsame( uplo, 'U' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( .not.( upper .or. stdlib_lsame( uplo, 'L' ) ) ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ka<0 ) then
              info = -5
           else if( kb<0 .or. kb>ka ) then
              info = -6
           else if( ldab<ka+1 ) then
              info = -8
           else if( ldbb<kb+1 ) then
              info = -10
           else if( ldq<1 .or. ( wantz .and. ldq<n ) ) then
              info = -12
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -14
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -15
                 else if ( iu<min( n, il ) .or. iu>n ) then
                    info = -16
                 end if
              end if
           end if
           if( info==0) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
                 info = -21
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHBGVX', -info )
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           ! form a split cholesky factorization of b.
           call stdlib_${ci}$pbstf( uplo, n, kb, bb, ldbb, info )
           if( info/=0 ) then
              info = n + info
              return
           end if
           ! transform problem to standard eigenvalue problem.
           call stdlib_${ci}$hbgst( jobz, uplo, n, ka, kb, ab, ldab, bb, ldbb, q, ldq,work, rwork, &
                     iinfo )
           ! solve the standard eigenvalue problem.
           ! reduce hermitian band matrix to tridiagonal form.
           indd = 1
           inde = indd + n
           indrwk = inde + n
           indwrk = 1
           if( wantz ) then
              vect = 'U'
           else
              vect = 'N'
           end if
           call stdlib_${ci}$hbtrd( vect, uplo, n, ka, ab, ldab, rwork( indd ),rwork( inde ), q, ldq, &
                     work( indwrk ), iinfo )
           ! if all eigenvalues are desired and abstol is less than or equal
           ! to zero, then call stdlib_${c2ri(ci)}$sterf or stdlib_${ci}$steqr.  if this fails for some
           ! eigenvalue, then try stdlib_${c2ri(ci)}$stebz.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig .or. test ) .and. ( abstol<=zero ) ) then
              call stdlib_${c2ri(ci)}$copy( n, rwork( indd ), 1, w, 1 )
              indee = indrwk + 2*n
              call stdlib_${c2ri(ci)}$copy( n-1, rwork( inde ), 1, rwork( indee ), 1 )
              if( .not.wantz ) then
                 call stdlib_${c2ri(ci)}$sterf( n, w, rwork( indee ), info )
              else
                 call stdlib_${ci}$lacpy( 'A', n, n, q, ldq, z, ldz )
                 call stdlib_${ci}$steqr( jobz, n, w, rwork( indee ), z, ldz,rwork( indrwk ), info )
                           
                 if( info==0 ) then
                    do i = 1, n
                       ifail( i ) = 0
                    end do
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 30
              end if
              info = 0
           end if
           ! otherwise, call stdlib_${c2ri(ci)}$stebz and, if eigenvectors are desired,
           ! call stdlib_${ci}$stein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           indibl = 1
           indisp = indibl + n
           indiwk = indisp + n
           call stdlib_${c2ri(ci)}$stebz( range, order, n, vl, vu, il, iu, abstol,rwork( indd ), rwork( inde &
           ), m, nsplit, w,iwork( indibl ), iwork( indisp ), rwork( indrwk ),iwork( indiwk ), &
                     info )
           if( wantz ) then
              call stdlib_${ci}$stein( n, rwork( indd ), rwork( inde ), m, w,iwork( indibl ), iwork( &
                        indisp ), z, ldz,rwork( indrwk ), iwork( indiwk ), ifail, info )
              ! apply unitary matrix used in reduction to tridiagonal
              ! form to eigenvectors returned by stdlib_${ci}$stein.
              do j = 1, m
                 call stdlib_${ci}$copy( n, z( 1, j ), 1, work( 1 ), 1 )
                 call stdlib_${ci}$gemv( 'N', n, n, cone, q, ldq, work, 1, czero,z( 1, j ), 1 )
              end do
           end if
           30 continue
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_${ci}$swap( n, z( 1, i ), 1, z( 1, j ), 1 )
                    if( info/=0 ) then
                       itmp1 = ifail( i )
                       ifail( i ) = ifail( j )
                       ifail( j ) = itmp1
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_${ci}$hbgvx

#:endif
#:endfor



     pure subroutine stdlib_ssbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )
     !! SSBTRD reduces a real symmetric band matrix A to symmetric
     !! tridiagonal form T by an orthogonal similarity transformation:
     !! Q**T * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, vect
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldq, n
           ! Array Arguments 
           real(sp), intent(inout) :: ab(ldab,*), q(ldq,*)
           real(sp), intent(out) :: d(*), e(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: initq, upper, wantq
           integer(ilp) :: i, i2, ibl, inca, incx, iqaend, iqb, iqend, j, j1, j1end, j1inc, j2, &
                     jend, jin, jinc, k, kd1, kdm1, kdn, l, last, lend, nq, nr, nrt
           real(sp) :: temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           initq = stdlib_lsame( vect, 'V' )
           wantq = initq .or. stdlib_lsame( vect, 'U' )
           upper = stdlib_lsame( uplo, 'U' )
           kd1 = kd + 1
           kdm1 = kd - 1
           incx = ldab - 1
           iqend = 1
           info = 0
           if( .not.wantq .and. .not.stdlib_lsame( vect, 'N' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( kd<0 ) then
              info = -4
           else if( ldab<kd1 ) then
              info = -6
           else if( ldq<max( 1, n ) .and. wantq ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSBTRD', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! initialize q to the unit matrix, if needed
           if( initq )call stdlib_slaset( 'FULL', n, n, zero, one, q, ldq )
           ! wherever possible, plane rotations are generated and applied in
           ! vector operations of length nr over the index set j1:j2:kd1.
           ! the cosines and sines of the plane rotations are stored in the
           ! arrays d and work.
           inca = kd1*ldab
           kdn = min( n-1, kd )
           if( upper ) then
              if( kd>1 ) then
                 ! reduce to tridiagonal form, working with upper triangle
                 nr = 0
                 j1 = kdn + 2
                 j2 = 1
                 loop_90: do i = 1, n - 2
                    ! reduce i-th row of matrix to tridiagonal form
                    loop_80: do k = kdn + 1, 2, -1
                       j1 = j1 + kdn
                       j2 = j2 + kdn
                       if( nr>0 ) then
                          ! generate plane rotations to annihilate nonzero
                          ! elements which have been created outside the band
                          call stdlib_slargv( nr, ab( 1, j1-1 ), inca, work( j1 ),kd1, d( j1 ), &
                                    kd1 )
                          ! apply rotations from the right
                          ! dependent on the the number of diagonals either
                          ! stdlib_slartv or stdlib_srot is used
                          if( nr>=2*kd-1 ) then
                             do l = 1, kd - 1
                                call stdlib_slartv( nr, ab( l+1, j1-1 ), inca,ab( l, j1 ), inca, &
                                          d( j1 ),work( j1 ), kd1 )
                             end do
                          else
                             jend = j1 + ( nr-1 )*kd1
                             do jinc = j1, jend, kd1
                                call stdlib_srot( kdm1, ab( 2, jinc-1 ), 1,ab( 1, jinc ), 1, d( &
                                          jinc ),work( jinc ) )
                             end do
                          end if
                       end if
                       if( k>2 ) then
                          if( k<=n-i+1 ) then
                             ! generate plane rotation to annihilate a(i,i+k-1)
                             ! within the band
                             call stdlib_slartg( ab( kd-k+3, i+k-2 ),ab( kd-k+2, i+k-1 ), d( i+k-&
                                       1 ),work( i+k-1 ), temp )
                             ab( kd-k+3, i+k-2 ) = temp
                             ! apply rotation from the right
                             call stdlib_srot( k-3, ab( kd-k+4, i+k-2 ), 1,ab( kd-k+3, i+k-1 ), 1,&
                                        d( i+k-1 ),work( i+k-1 ) )
                          end if
                          nr = nr + 1
                          j1 = j1 - kdn - 1
                       end if
                       ! apply plane rotations from both sides to diagonal
                       ! blocks
                       if( nr>0 )call stdlib_slar2v( nr, ab( kd1, j1-1 ), ab( kd1, j1 ),ab( kd, &
                                 j1 ), inca, d( j1 ),work( j1 ), kd1 )
                       ! apply plane rotations from the left
                       if( nr>0 ) then
                          if( 2*kd-1<nr ) then
                          ! dependent on the the number of diagonals either
                          ! stdlib_slartv or stdlib_srot is used
                             do l = 1, kd - 1
                                if( j2+l>n ) then
                                   nrt = nr - 1
                                else
                                   nrt = nr
                                end if
                                if( nrt>0 )call stdlib_slartv( nrt, ab( kd-l, j1+l ), inca,ab( kd-&
                                          l+1, j1+l ), inca,d( j1 ), work( j1 ), kd1 )
                             end do
                          else
                             j1end = j1 + kd1*( nr-2 )
                             if( j1end>=j1 ) then
                                do jin = j1, j1end, kd1
                                   call stdlib_srot( kd-1, ab( kd-1, jin+1 ), incx,ab( kd, jin+1 )&
                                             , incx,d( jin ), work( jin ) )
                                end do
                             end if
                             lend = min( kdm1, n-j2 )
                             last = j1end + kd1
                             if( lend>0 )call stdlib_srot( lend, ab( kd-1, last+1 ), incx,ab( kd, &
                                       last+1 ), incx, d( last ),work( last ) )
                          end if
                       end if
                       if( wantq ) then
                          ! accumulate product of plane rotations in q
                          if( initq ) then
                       ! take advantage of the fact that q was
                       ! initially the identity matrix
                             iqend = max( iqend, j2 )
                             i2 = max( 0, k-3 )
                             iqaend = 1 + i*kd
                             if( k==2 )iqaend = iqaend + kd
                             iqaend = min( iqaend, iqend )
                             do j = j1, j2, kd1
                                ibl = i - i2 / kdm1
                                i2 = i2 + 1
                                iqb = max( 1, j-ibl )
                                nq = 1 + iqaend - iqb
                                iqaend = min( iqaend+kd, iqend )
                                call stdlib_srot( nq, q( iqb, j-1 ), 1, q( iqb, j ),1, d( j ), &
                                          work( j ) )
                             end do
                          else
                             do j = j1, j2, kd1
                                call stdlib_srot( n, q( 1, j-1 ), 1, q( 1, j ), 1,d( j ), work( j &
                                          ) )
                             end do
                          end if
                       end if
                       if( j2+kdn>n ) then
                          ! adjust j2 to keep within the bounds of the matrix
                          nr = nr - 1
                          j2 = j2 - kdn - 1
                       end if
                       do j = j1, j2, kd1
                          ! create nonzero element a(j-1,j+kd) outside the band
                          ! and store it in work
                          work( j+kd ) = work( j )*ab( 1, j+kd )
                          ab( 1, j+kd ) = d( j )*ab( 1, j+kd )
                       end do
                    end do loop_80
                 end do loop_90
              end if
              if( kd>0 ) then
                 ! copy off-diagonal elements to e
                 do i = 1, n - 1
                    e( i ) = ab( kd, i+1 )
                 end do
              else
                 ! set e to zero if original matrix was diagonal
                 do i = 1, n - 1
                    e( i ) = zero
                 end do
              end if
              ! copy diagonal elements to d
              do i = 1, n
                 d( i ) = ab( kd1, i )
              end do
           else
              if( kd>1 ) then
                 ! reduce to tridiagonal form, working with lower triangle
                 nr = 0
                 j1 = kdn + 2
                 j2 = 1
                 loop_210: do i = 1, n - 2
                    ! reduce i-th column of matrix to tridiagonal form
                    loop_200: do k = kdn + 1, 2, -1
                       j1 = j1 + kdn
                       j2 = j2 + kdn
                       if( nr>0 ) then
                          ! generate plane rotations to annihilate nonzero
                          ! elements which have been created outside the band
                          call stdlib_slargv( nr, ab( kd1, j1-kd1 ), inca,work( j1 ), kd1, d( j1 )&
                                    , kd1 )
                          ! apply plane rotations from one side
                          ! dependent on the the number of diagonals either
                          ! stdlib_slartv or stdlib_srot is used
                          if( nr>2*kd-1 ) then
                             do l = 1, kd - 1
                                call stdlib_slartv( nr, ab( kd1-l, j1-kd1+l ), inca,ab( kd1-l+1, &
                                          j1-kd1+l ), inca,d( j1 ), work( j1 ), kd1 )
                             end do
                          else
                             jend = j1 + kd1*( nr-1 )
                             do jinc = j1, jend, kd1
                                call stdlib_srot( kdm1, ab( kd, jinc-kd ), incx,ab( kd1, jinc-kd )&
                                          , incx,d( jinc ), work( jinc ) )
                             end do
                          end if
                       end if
                       if( k>2 ) then
                          if( k<=n-i+1 ) then
                             ! generate plane rotation to annihilate a(i+k-1,i)
                             ! within the band
                             call stdlib_slartg( ab( k-1, i ), ab( k, i ),d( i+k-1 ), work( i+k-1 &
                                       ), temp )
                             ab( k-1, i ) = temp
                             ! apply rotation from the left
                             call stdlib_srot( k-3, ab( k-2, i+1 ), ldab-1,ab( k-1, i+1 ), ldab-1,&
                                        d( i+k-1 ),work( i+k-1 ) )
                          end if
                          nr = nr + 1
                          j1 = j1 - kdn - 1
                       end if
                       ! apply plane rotations from both sides to diagonal
                       ! blocks
                       if( nr>0 )call stdlib_slar2v( nr, ab( 1, j1-1 ), ab( 1, j1 ),ab( 2, j1-1 ),&
                                  inca, d( j1 ),work( j1 ), kd1 )
                       ! apply plane rotations from the right
                          ! dependent on the the number of diagonals either
                          ! stdlib_slartv or stdlib_srot is used
                       if( nr>0 ) then
                          if( nr>2*kd-1 ) then
                             do l = 1, kd - 1
                                if( j2+l>n ) then
                                   nrt = nr - 1
                                else
                                   nrt = nr
                                end if
                                if( nrt>0 )call stdlib_slartv( nrt, ab( l+2, j1-1 ), inca,ab( l+1,&
                                           j1 ), inca, d( j1 ),work( j1 ), kd1 )
                             end do
                          else
                             j1end = j1 + kd1*( nr-2 )
                             if( j1end>=j1 ) then
                                do j1inc = j1, j1end, kd1
                                   call stdlib_srot( kdm1, ab( 3, j1inc-1 ), 1,ab( 2, j1inc ), 1, &
                                             d( j1inc ),work( j1inc ) )
                                end do
                             end if
                             lend = min( kdm1, n-j2 )
                             last = j1end + kd1
                             if( lend>0 )call stdlib_srot( lend, ab( 3, last-1 ), 1,ab( 2, last ),&
                                        1, d( last ),work( last ) )
                          end if
                       end if
                       if( wantq ) then
                          ! accumulate product of plane rotations in q
                          if( initq ) then
                       ! take advantage of the fact that q was
                       ! initially the identity matrix
                             iqend = max( iqend, j2 )
                             i2 = max( 0, k-3 )
                             iqaend = 1 + i*kd
                             if( k==2 )iqaend = iqaend + kd
                             iqaend = min( iqaend, iqend )
                             do j = j1, j2, kd1
                                ibl = i - i2 / kdm1
                                i2 = i2 + 1
                                iqb = max( 1, j-ibl )
                                nq = 1 + iqaend - iqb
                                iqaend = min( iqaend+kd, iqend )
                                call stdlib_srot( nq, q( iqb, j-1 ), 1, q( iqb, j ),1, d( j ), &
                                          work( j ) )
                             end do
                          else
                             do j = j1, j2, kd1
                                call stdlib_srot( n, q( 1, j-1 ), 1, q( 1, j ), 1,d( j ), work( j &
                                          ) )
                             end do
                          end if
                       end if
                       if( j2+kdn>n ) then
                          ! adjust j2 to keep within the bounds of the matrix
                          nr = nr - 1
                          j2 = j2 - kdn - 1
                       end if
                       do j = j1, j2, kd1
                          ! create nonzero element a(j+kd,j-1) outside the
                          ! band and store it in work
                          work( j+kd ) = work( j )*ab( kd1, j )
                          ab( kd1, j ) = d( j )*ab( kd1, j )
                       end do
                    end do loop_200
                 end do loop_210
              end if
              if( kd>0 ) then
                 ! copy off-diagonal elements to e
                 do i = 1, n - 1
                    e( i ) = ab( 2, i )
                 end do
              else
                 ! set e to zero if original matrix was diagonal
                 do i = 1, n - 1
                    e( i ) = zero
                 end do
              end if
              ! copy diagonal elements to d
              do i = 1, n
                 d( i ) = ab( 1, i )
              end do
           end if
           return
     end subroutine stdlib_ssbtrd

     pure subroutine stdlib_dsbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )
     !! DSBTRD reduces a real symmetric band matrix A to symmetric
     !! tridiagonal form T by an orthogonal similarity transformation:
     !! Q**T * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, vect
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldq, n
           ! Array Arguments 
           real(dp), intent(inout) :: ab(ldab,*), q(ldq,*)
           real(dp), intent(out) :: d(*), e(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: initq, upper, wantq
           integer(ilp) :: i, i2, ibl, inca, incx, iqaend, iqb, iqend, j, j1, j1end, j1inc, j2, &
                     jend, jin, jinc, k, kd1, kdm1, kdn, l, last, lend, nq, nr, nrt
           real(dp) :: temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           initq = stdlib_lsame( vect, 'V' )
           wantq = initq .or. stdlib_lsame( vect, 'U' )
           upper = stdlib_lsame( uplo, 'U' )
           kd1 = kd + 1
           kdm1 = kd - 1
           incx = ldab - 1
           iqend = 1
           info = 0
           if( .not.wantq .and. .not.stdlib_lsame( vect, 'N' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( kd<0 ) then
              info = -4
           else if( ldab<kd1 ) then
              info = -6
           else if( ldq<max( 1, n ) .and. wantq ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSBTRD', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! initialize q to the unit matrix, if needed
           if( initq )call stdlib_dlaset( 'FULL', n, n, zero, one, q, ldq )
           ! wherever possible, plane rotations are generated and applied in
           ! vector operations of length nr over the index set j1:j2:kd1.
           ! the cosines and sines of the plane rotations are stored in the
           ! arrays d and work.
           inca = kd1*ldab
           kdn = min( n-1, kd )
           if( upper ) then
              if( kd>1 ) then
                 ! reduce to tridiagonal form, working with upper triangle
                 nr = 0
                 j1 = kdn + 2
                 j2 = 1
                 loop_90: do i = 1, n - 2
                    ! reduce i-th row of matrix to tridiagonal form
                    loop_80: do k = kdn + 1, 2, -1
                       j1 = j1 + kdn
                       j2 = j2 + kdn
                       if( nr>0 ) then
                          ! generate plane rotations to annihilate nonzero
                          ! elements which have been created outside the band
                          call stdlib_dlargv( nr, ab( 1, j1-1 ), inca, work( j1 ),kd1, d( j1 ), &
                                    kd1 )
                          ! apply rotations from the right
                          ! dependent on the the number of diagonals either
                          ! stdlib_dlartv or stdlib_drot is used
                          if( nr>=2*kd-1 ) then
                             do l = 1, kd - 1
                                call stdlib_dlartv( nr, ab( l+1, j1-1 ), inca,ab( l, j1 ), inca, &
                                          d( j1 ),work( j1 ), kd1 )
                             end do
                          else
                             jend = j1 + ( nr-1 )*kd1
                             do jinc = j1, jend, kd1
                                call stdlib_drot( kdm1, ab( 2, jinc-1 ), 1,ab( 1, jinc ), 1, d( &
                                          jinc ),work( jinc ) )
                             end do
                          end if
                       end if
                       if( k>2 ) then
                          if( k<=n-i+1 ) then
                             ! generate plane rotation to annihilate a(i,i+k-1)
                             ! within the band
                             call stdlib_dlartg( ab( kd-k+3, i+k-2 ),ab( kd-k+2, i+k-1 ), d( i+k-&
                                       1 ),work( i+k-1 ), temp )
                             ab( kd-k+3, i+k-2 ) = temp
                             ! apply rotation from the right
                             call stdlib_drot( k-3, ab( kd-k+4, i+k-2 ), 1,ab( kd-k+3, i+k-1 ), 1,&
                                        d( i+k-1 ),work( i+k-1 ) )
                          end if
                          nr = nr + 1
                          j1 = j1 - kdn - 1
                       end if
                       ! apply plane rotations from both sides to diagonal
                       ! blocks
                       if( nr>0 )call stdlib_dlar2v( nr, ab( kd1, j1-1 ), ab( kd1, j1 ),ab( kd, &
                                 j1 ), inca, d( j1 ),work( j1 ), kd1 )
                       ! apply plane rotations from the left
                       if( nr>0 ) then
                          if( 2*kd-1<nr ) then
                          ! dependent on the the number of diagonals either
                          ! stdlib_dlartv or stdlib_drot is used
                             do l = 1, kd - 1
                                if( j2+l>n ) then
                                   nrt = nr - 1
                                else
                                   nrt = nr
                                end if
                                if( nrt>0 )call stdlib_dlartv( nrt, ab( kd-l, j1+l ), inca,ab( kd-&
                                          l+1, j1+l ), inca,d( j1 ), work( j1 ), kd1 )
                             end do
                          else
                             j1end = j1 + kd1*( nr-2 )
                             if( j1end>=j1 ) then
                                do jin = j1, j1end, kd1
                                   call stdlib_drot( kd-1, ab( kd-1, jin+1 ), incx,ab( kd, jin+1 )&
                                             , incx,d( jin ), work( jin ) )
                                end do
                             end if
                             lend = min( kdm1, n-j2 )
                             last = j1end + kd1
                             if( lend>0 )call stdlib_drot( lend, ab( kd-1, last+1 ), incx,ab( kd, &
                                       last+1 ), incx, d( last ),work( last ) )
                          end if
                       end if
                       if( wantq ) then
                          ! accumulate product of plane rotations in q
                          if( initq ) then
                       ! take advantage of the fact that q was
                       ! initially the identity matrix
                             iqend = max( iqend, j2 )
                             i2 = max( 0, k-3 )
                             iqaend = 1 + i*kd
                             if( k==2 )iqaend = iqaend + kd
                             iqaend = min( iqaend, iqend )
                             do j = j1, j2, kd1
                                ibl = i - i2 / kdm1
                                i2 = i2 + 1
                                iqb = max( 1, j-ibl )
                                nq = 1 + iqaend - iqb
                                iqaend = min( iqaend+kd, iqend )
                                call stdlib_drot( nq, q( iqb, j-1 ), 1, q( iqb, j ),1, d( j ), &
                                          work( j ) )
                             end do
                          else
                             do j = j1, j2, kd1
                                call stdlib_drot( n, q( 1, j-1 ), 1, q( 1, j ), 1,d( j ), work( j &
                                          ) )
                             end do
                          end if
                       end if
                       if( j2+kdn>n ) then
                          ! adjust j2 to keep within the bounds of the matrix
                          nr = nr - 1
                          j2 = j2 - kdn - 1
                       end if
                       do j = j1, j2, kd1
                          ! create nonzero element a(j-1,j+kd) outside the band
                          ! and store it in work
                          work( j+kd ) = work( j )*ab( 1, j+kd )
                          ab( 1, j+kd ) = d( j )*ab( 1, j+kd )
                       end do
                    end do loop_80
                 end do loop_90
              end if
              if( kd>0 ) then
                 ! copy off-diagonal elements to e
                 do i = 1, n - 1
                    e( i ) = ab( kd, i+1 )
                 end do
              else
                 ! set e to zero if original matrix was diagonal
                 do i = 1, n - 1
                    e( i ) = zero
                 end do
              end if
              ! copy diagonal elements to d
              do i = 1, n
                 d( i ) = ab( kd1, i )
              end do
           else
              if( kd>1 ) then
                 ! reduce to tridiagonal form, working with lower triangle
                 nr = 0
                 j1 = kdn + 2
                 j2 = 1
                 loop_210: do i = 1, n - 2
                    ! reduce i-th column of matrix to tridiagonal form
                    loop_200: do k = kdn + 1, 2, -1
                       j1 = j1 + kdn
                       j2 = j2 + kdn
                       if( nr>0 ) then
                          ! generate plane rotations to annihilate nonzero
                          ! elements which have been created outside the band
                          call stdlib_dlargv( nr, ab( kd1, j1-kd1 ), inca,work( j1 ), kd1, d( j1 )&
                                    , kd1 )
                          ! apply plane rotations from one side
                          ! dependent on the the number of diagonals either
                          ! stdlib_dlartv or stdlib_drot is used
                          if( nr>2*kd-1 ) then
                             do l = 1, kd - 1
                                call stdlib_dlartv( nr, ab( kd1-l, j1-kd1+l ), inca,ab( kd1-l+1, &
                                          j1-kd1+l ), inca,d( j1 ), work( j1 ), kd1 )
                             end do
                          else
                             jend = j1 + kd1*( nr-1 )
                             do jinc = j1, jend, kd1
                                call stdlib_drot( kdm1, ab( kd, jinc-kd ), incx,ab( kd1, jinc-kd )&
                                          , incx,d( jinc ), work( jinc ) )
                             end do
                          end if
                       end if
                       if( k>2 ) then
                          if( k<=n-i+1 ) then
                             ! generate plane rotation to annihilate a(i+k-1,i)
                             ! within the band
                             call stdlib_dlartg( ab( k-1, i ), ab( k, i ),d( i+k-1 ), work( i+k-1 &
                                       ), temp )
                             ab( k-1, i ) = temp
                             ! apply rotation from the left
                             call stdlib_drot( k-3, ab( k-2, i+1 ), ldab-1,ab( k-1, i+1 ), ldab-1,&
                                        d( i+k-1 ),work( i+k-1 ) )
                          end if
                          nr = nr + 1
                          j1 = j1 - kdn - 1
                       end if
                       ! apply plane rotations from both sides to diagonal
                       ! blocks
                       if( nr>0 )call stdlib_dlar2v( nr, ab( 1, j1-1 ), ab( 1, j1 ),ab( 2, j1-1 ),&
                                  inca, d( j1 ),work( j1 ), kd1 )
                       ! apply plane rotations from the right
                          ! dependent on the the number of diagonals either
                          ! stdlib_dlartv or stdlib_drot is used
                       if( nr>0 ) then
                          if( nr>2*kd-1 ) then
                             do l = 1, kd - 1
                                if( j2+l>n ) then
                                   nrt = nr - 1
                                else
                                   nrt = nr
                                end if
                                if( nrt>0 )call stdlib_dlartv( nrt, ab( l+2, j1-1 ), inca,ab( l+1,&
                                           j1 ), inca, d( j1 ),work( j1 ), kd1 )
                             end do
                          else
                             j1end = j1 + kd1*( nr-2 )
                             if( j1end>=j1 ) then
                                do j1inc = j1, j1end, kd1
                                   call stdlib_drot( kdm1, ab( 3, j1inc-1 ), 1,ab( 2, j1inc ), 1, &
                                             d( j1inc ),work( j1inc ) )
                                end do
                             end if
                             lend = min( kdm1, n-j2 )
                             last = j1end + kd1
                             if( lend>0 )call stdlib_drot( lend, ab( 3, last-1 ), 1,ab( 2, last ),&
                                        1, d( last ),work( last ) )
                          end if
                       end if
                       if( wantq ) then
                          ! accumulate product of plane rotations in q
                          if( initq ) then
                       ! take advantage of the fact that q was
                       ! initially the identity matrix
                             iqend = max( iqend, j2 )
                             i2 = max( 0, k-3 )
                             iqaend = 1 + i*kd
                             if( k==2 )iqaend = iqaend + kd
                             iqaend = min( iqaend, iqend )
                             do j = j1, j2, kd1
                                ibl = i - i2 / kdm1
                                i2 = i2 + 1
                                iqb = max( 1, j-ibl )
                                nq = 1 + iqaend - iqb
                                iqaend = min( iqaend+kd, iqend )
                                call stdlib_drot( nq, q( iqb, j-1 ), 1, q( iqb, j ),1, d( j ), &
                                          work( j ) )
                             end do
                          else
                             do j = j1, j2, kd1
                                call stdlib_drot( n, q( 1, j-1 ), 1, q( 1, j ), 1,d( j ), work( j &
                                          ) )
                             end do
                          end if
                       end if
                       if( j2+kdn>n ) then
                          ! adjust j2 to keep within the bounds of the matrix
                          nr = nr - 1
                          j2 = j2 - kdn - 1
                       end if
                       do j = j1, j2, kd1
                          ! create nonzero element a(j+kd,j-1) outside the
                          ! band and store it in work
                          work( j+kd ) = work( j )*ab( kd1, j )
                          ab( kd1, j ) = d( j )*ab( kd1, j )
                       end do
                    end do loop_200
                 end do loop_210
              end if
              if( kd>0 ) then
                 ! copy off-diagonal elements to e
                 do i = 1, n - 1
                    e( i ) = ab( 2, i )
                 end do
              else
                 ! set e to zero if original matrix was diagonal
                 do i = 1, n - 1
                    e( i ) = zero
                 end do
              end if
              ! copy diagonal elements to d
              do i = 1, n
                 d( i ) = ab( 1, i )
              end do
           end if
           return
     end subroutine stdlib_dsbtrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$sbtrd( vect, uplo, n, kd, ab, ldab, d, e, q, ldq,work, info )
     !! DSBTRD: reduces a real symmetric band matrix A to symmetric
     !! tridiagonal form T by an orthogonal similarity transformation:
     !! Q**T * A * Q = T.
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo, vect
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldq, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ab(ldab,*), q(ldq,*)
           real(${rk}$), intent(out) :: d(*), e(*), work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: initq, upper, wantq
           integer(ilp) :: i, i2, ibl, inca, incx, iqaend, iqb, iqend, j, j1, j1end, j1inc, j2, &
                     jend, jin, jinc, k, kd1, kdm1, kdn, l, last, lend, nq, nr, nrt
           real(${rk}$) :: temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           initq = stdlib_lsame( vect, 'V' )
           wantq = initq .or. stdlib_lsame( vect, 'U' )
           upper = stdlib_lsame( uplo, 'U' )
           kd1 = kd + 1
           kdm1 = kd - 1
           incx = ldab - 1
           iqend = 1
           info = 0
           if( .not.wantq .and. .not.stdlib_lsame( vect, 'N' ) ) then
              info = -1
           else if( .not.upper .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( kd<0 ) then
              info = -4
           else if( ldab<kd1 ) then
              info = -6
           else if( ldq<max( 1, n ) .and. wantq ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSBTRD', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! initialize q to the unit matrix, if needed
           if( initq )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, q, ldq )
           ! wherever possible, plane rotations are generated and applied in
           ! vector operations of length nr over the index set j1:j2:kd1.
           ! the cosines and sines of the plane rotations are stored in the
           ! arrays d and work.
           inca = kd1*ldab
           kdn = min( n-1, kd )
           if( upper ) then
              if( kd>1 ) then
                 ! reduce to tridiagonal form, working with upper triangle
                 nr = 0
                 j1 = kdn + 2
                 j2 = 1
                 loop_90: do i = 1, n - 2
                    ! reduce i-th row of matrix to tridiagonal form
                    loop_80: do k = kdn + 1, 2, -1
                       j1 = j1 + kdn
                       j2 = j2 + kdn
                       if( nr>0 ) then
                          ! generate plane rotations to annihilate nonzero
                          ! elements which have been created outside the band
                          call stdlib_${ri}$largv( nr, ab( 1, j1-1 ), inca, work( j1 ),kd1, d( j1 ), &
                                    kd1 )
                          ! apply rotations from the right
                          ! dependent on the the number of diagonals either
                          ! stdlib_${ri}$lartv or stdlib_${ri}$rot is used
                          if( nr>=2*kd-1 ) then
                             do l = 1, kd - 1
                                call stdlib_${ri}$lartv( nr, ab( l+1, j1-1 ), inca,ab( l, j1 ), inca, &
                                          d( j1 ),work( j1 ), kd1 )
                             end do
                          else
                             jend = j1 + ( nr-1 )*kd1
                             do jinc = j1, jend, kd1
                                call stdlib_${ri}$rot( kdm1, ab( 2, jinc-1 ), 1,ab( 1, jinc ), 1, d( &
                                          jinc ),work( jinc ) )
                             end do
                          end if
                       end if
                       if( k>2 ) then
                          if( k<=n-i+1 ) then
                             ! generate plane rotation to annihilate a(i,i+k-1)
                             ! within the band
                             call stdlib_${ri}$lartg( ab( kd-k+3, i+k-2 ),ab( kd-k+2, i+k-1 ), d( i+k-&
                                       1 ),work( i+k-1 ), temp )
                             ab( kd-k+3, i+k-2 ) = temp
                             ! apply rotation from the right
                             call stdlib_${ri}$rot( k-3, ab( kd-k+4, i+k-2 ), 1,ab( kd-k+3, i+k-1 ), 1,&
                                        d( i+k-1 ),work( i+k-1 ) )
                          end if
                          nr = nr + 1
                          j1 = j1 - kdn - 1
                       end if
                       ! apply plane rotations from both sides to diagonal
                       ! blocks
                       if( nr>0 )call stdlib_${ri}$lar2v( nr, ab( kd1, j1-1 ), ab( kd1, j1 ),ab( kd, &
                                 j1 ), inca, d( j1 ),work( j1 ), kd1 )
                       ! apply plane rotations from the left
                       if( nr>0 ) then
                          if( 2*kd-1<nr ) then
                          ! dependent on the the number of diagonals either
                          ! stdlib_${ri}$lartv or stdlib_${ri}$rot is used
                             do l = 1, kd - 1
                                if( j2+l>n ) then
                                   nrt = nr - 1
                                else
                                   nrt = nr
                                end if
                                if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( kd-l, j1+l ), inca,ab( kd-&
                                          l+1, j1+l ), inca,d( j1 ), work( j1 ), kd1 )
                             end do
                          else
                             j1end = j1 + kd1*( nr-2 )
                             if( j1end>=j1 ) then
                                do jin = j1, j1end, kd1
                                   call stdlib_${ri}$rot( kd-1, ab( kd-1, jin+1 ), incx,ab( kd, jin+1 )&
                                             , incx,d( jin ), work( jin ) )
                                end do
                             end if
                             lend = min( kdm1, n-j2 )
                             last = j1end + kd1
                             if( lend>0 )call stdlib_${ri}$rot( lend, ab( kd-1, last+1 ), incx,ab( kd, &
                                       last+1 ), incx, d( last ),work( last ) )
                          end if
                       end if
                       if( wantq ) then
                          ! accumulate product of plane rotations in q
                          if( initq ) then
                       ! take advantage of the fact that q was
                       ! initially the identity matrix
                             iqend = max( iqend, j2 )
                             i2 = max( 0, k-3 )
                             iqaend = 1 + i*kd
                             if( k==2 )iqaend = iqaend + kd
                             iqaend = min( iqaend, iqend )
                             do j = j1, j2, kd1
                                ibl = i - i2 / kdm1
                                i2 = i2 + 1
                                iqb = max( 1, j-ibl )
                                nq = 1 + iqaend - iqb
                                iqaend = min( iqaend+kd, iqend )
                                call stdlib_${ri}$rot( nq, q( iqb, j-1 ), 1, q( iqb, j ),1, d( j ), &
                                          work( j ) )
                             end do
                          else
                             do j = j1, j2, kd1
                                call stdlib_${ri}$rot( n, q( 1, j-1 ), 1, q( 1, j ), 1,d( j ), work( j &
                                          ) )
                             end do
                          end if
                       end if
                       if( j2+kdn>n ) then
                          ! adjust j2 to keep within the bounds of the matrix
                          nr = nr - 1
                          j2 = j2 - kdn - 1
                       end if
                       do j = j1, j2, kd1
                          ! create nonzero element a(j-1,j+kd) outside the band
                          ! and store it in work
                          work( j+kd ) = work( j )*ab( 1, j+kd )
                          ab( 1, j+kd ) = d( j )*ab( 1, j+kd )
                       end do
                    end do loop_80
                 end do loop_90
              end if
              if( kd>0 ) then
                 ! copy off-diagonal elements to e
                 do i = 1, n - 1
                    e( i ) = ab( kd, i+1 )
                 end do
              else
                 ! set e to zero if original matrix was diagonal
                 do i = 1, n - 1
                    e( i ) = zero
                 end do
              end if
              ! copy diagonal elements to d
              do i = 1, n
                 d( i ) = ab( kd1, i )
              end do
           else
              if( kd>1 ) then
                 ! reduce to tridiagonal form, working with lower triangle
                 nr = 0
                 j1 = kdn + 2
                 j2 = 1
                 loop_210: do i = 1, n - 2
                    ! reduce i-th column of matrix to tridiagonal form
                    loop_200: do k = kdn + 1, 2, -1
                       j1 = j1 + kdn
                       j2 = j2 + kdn
                       if( nr>0 ) then
                          ! generate plane rotations to annihilate nonzero
                          ! elements which have been created outside the band
                          call stdlib_${ri}$largv( nr, ab( kd1, j1-kd1 ), inca,work( j1 ), kd1, d( j1 )&
                                    , kd1 )
                          ! apply plane rotations from one side
                          ! dependent on the the number of diagonals either
                          ! stdlib_${ri}$lartv or stdlib_${ri}$rot is used
                          if( nr>2*kd-1 ) then
                             do l = 1, kd - 1
                                call stdlib_${ri}$lartv( nr, ab( kd1-l, j1-kd1+l ), inca,ab( kd1-l+1, &
                                          j1-kd1+l ), inca,d( j1 ), work( j1 ), kd1 )
                             end do
                          else
                             jend = j1 + kd1*( nr-1 )
                             do jinc = j1, jend, kd1
                                call stdlib_${ri}$rot( kdm1, ab( kd, jinc-kd ), incx,ab( kd1, jinc-kd )&
                                          , incx,d( jinc ), work( jinc ) )
                             end do
                          end if
                       end if
                       if( k>2 ) then
                          if( k<=n-i+1 ) then
                             ! generate plane rotation to annihilate a(i+k-1,i)
                             ! within the band
                             call stdlib_${ri}$lartg( ab( k-1, i ), ab( k, i ),d( i+k-1 ), work( i+k-1 &
                                       ), temp )
                             ab( k-1, i ) = temp
                             ! apply rotation from the left
                             call stdlib_${ri}$rot( k-3, ab( k-2, i+1 ), ldab-1,ab( k-1, i+1 ), ldab-1,&
                                        d( i+k-1 ),work( i+k-1 ) )
                          end if
                          nr = nr + 1
                          j1 = j1 - kdn - 1
                       end if
                       ! apply plane rotations from both sides to diagonal
                       ! blocks
                       if( nr>0 )call stdlib_${ri}$lar2v( nr, ab( 1, j1-1 ), ab( 1, j1 ),ab( 2, j1-1 ),&
                                  inca, d( j1 ),work( j1 ), kd1 )
                       ! apply plane rotations from the right
                          ! dependent on the the number of diagonals either
                          ! stdlib_${ri}$lartv or stdlib_${ri}$rot is used
                       if( nr>0 ) then
                          if( nr>2*kd-1 ) then
                             do l = 1, kd - 1
                                if( j2+l>n ) then
                                   nrt = nr - 1
                                else
                                   nrt = nr
                                end if
                                if( nrt>0 )call stdlib_${ri}$lartv( nrt, ab( l+2, j1-1 ), inca,ab( l+1,&
                                           j1 ), inca, d( j1 ),work( j1 ), kd1 )
                             end do
                          else
                             j1end = j1 + kd1*( nr-2 )
                             if( j1end>=j1 ) then
                                do j1inc = j1, j1end, kd1
                                   call stdlib_${ri}$rot( kdm1, ab( 3, j1inc-1 ), 1,ab( 2, j1inc ), 1, &
                                             d( j1inc ),work( j1inc ) )
                                end do
                             end if
                             lend = min( kdm1, n-j2 )
                             last = j1end + kd1
                             if( lend>0 )call stdlib_${ri}$rot( lend, ab( 3, last-1 ), 1,ab( 2, last ),&
                                        1, d( last ),work( last ) )
                          end if
                       end if
                       if( wantq ) then
                          ! accumulate product of plane rotations in q
                          if( initq ) then
                       ! take advantage of the fact that q was
                       ! initially the identity matrix
                             iqend = max( iqend, j2 )
                             i2 = max( 0, k-3 )
                             iqaend = 1 + i*kd
                             if( k==2 )iqaend = iqaend + kd
                             iqaend = min( iqaend, iqend )
                             do j = j1, j2, kd1
                                ibl = i - i2 / kdm1
                                i2 = i2 + 1
                                iqb = max( 1, j-ibl )
                                nq = 1 + iqaend - iqb
                                iqaend = min( iqaend+kd, iqend )
                                call stdlib_${ri}$rot( nq, q( iqb, j-1 ), 1, q( iqb, j ),1, d( j ), &
                                          work( j ) )
                             end do
                          else
                             do j = j1, j2, kd1
                                call stdlib_${ri}$rot( n, q( 1, j-1 ), 1, q( 1, j ), 1,d( j ), work( j &
                                          ) )
                             end do
                          end if
                       end if
                       if( j2+kdn>n ) then
                          ! adjust j2 to keep within the bounds of the matrix
                          nr = nr - 1
                          j2 = j2 - kdn - 1
                       end if
                       do j = j1, j2, kd1
                          ! create nonzero element a(j+kd,j-1) outside the
                          ! band and store it in work
                          work( j+kd ) = work( j )*ab( kd1, j )
                          ab( kd1, j ) = d( j )*ab( kd1, j )
                       end do
                    end do loop_200
                 end do loop_210
              end if
              if( kd>0 ) then
                 ! copy off-diagonal elements to e
                 do i = 1, n - 1
                    e( i ) = ab( 2, i )
                 end do
              else
                 ! set e to zero if original matrix was diagonal
                 do i = 1, n - 1
                    e( i ) = zero
                 end do
              end if
              ! copy diagonal elements to d
              do i = 1, n
                 d( i ) = ab( 1, i )
              end do
           end if
           return
     end subroutine stdlib_${ri}$sbtrd

#:endif
#:endfor





     pure subroutine stdlib_sstevx( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
     !! SSTEVX computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix A.  Eigenvalues and
     !! eigenvectors can be selected by specifying either a range of values
     !! or a range of indices for the desired eigenvalues.
               work, iwork, ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           integer(ilp), intent(in) :: il, iu, ldz, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, test, valeig, wantz
           character :: order
           integer(ilp) :: i, imax, indibl, indisp, indiwo, indwrk, iscale, itmp1, j, jj, &
                     nsplit
           real(sp) :: bignum, eps, rmax, rmin, safmin, sigma, smlnum, tmp1, tnrm, vll, &
                     vuu
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -7
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -8
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -9
                 end if
              end if
           end if
           if( info==0 ) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) )info = -14
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSTEVX', -info )
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = d( 1 )
              else
                 if( vl<d( 1 ) .and. vu>=d( 1 ) ) then
                    m = 1
                    w( 1 ) = d( 1 )
                 end if
              end if
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           eps = stdlib_slamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           if ( valeig ) then
              vll = vl
              vuu = vu
           else
              vll = zero
              vuu = zero
           endif
           tnrm = stdlib_slanst( 'M', n, d, e )
           if( tnrm>zero .and. tnrm<rmin ) then
              iscale = 1
              sigma = rmin / tnrm
           else if( tnrm>rmax ) then
              iscale = 1
              sigma = rmax / tnrm
           end if
           if( iscale==1 ) then
              call stdlib_sscal( n, sigma, d, 1 )
              call stdlib_sscal( n-1, sigma, e( 1 ), 1 )
              if( valeig ) then
                 vll = vl*sigma
                 vuu = vu*sigma
              end if
           end if
           ! if all eigenvalues are desired and abstol is less than zero, then
           ! call stdlib_ssterf or stdlib_ssteqr.  if this fails for some eigenvalue, then
           ! try stdlib_sstebz.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig .or. test ) .and. ( abstol<=zero ) ) then
              call stdlib_scopy( n, d, 1, w, 1 )
              call stdlib_scopy( n-1, e( 1 ), 1, work( 1 ), 1 )
              indwrk = n + 1
              if( .not.wantz ) then
                 call stdlib_ssterf( n, w, work, info )
              else
                 call stdlib_ssteqr( 'I', n, w, work, z, ldz, work( indwrk ), info )
                 if( info==0 ) then
                    do i = 1, n
                       ifail( i ) = 0
                    end do
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 20
              end if
              info = 0
           end if
           ! otherwise, call stdlib_sstebz and, if eigenvectors are desired, stdlib_sstein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           indwrk = 1
           indibl = 1
           indisp = indibl + n
           indiwo = indisp + n
           call stdlib_sstebz( range, order, n, vll, vuu, il, iu, abstol, d, e, m,nsplit, w, &
                     iwork( indibl ), iwork( indisp ),work( indwrk ), iwork( indiwo ), info )
           if( wantz ) then
              call stdlib_sstein( n, d, e, m, w, iwork( indibl ), iwork( indisp ),z, ldz, work( &
                        indwrk ), iwork( indiwo ), ifail,info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           20 continue
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = m
              else
                 imax = info - 1
              end if
              call stdlib_sscal( imax, one / sigma, w, 1 )
           end if
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_sswap( n, z( 1, i ), 1, z( 1, j ), 1 )
                    if( info/=0 ) then
                       itmp1 = ifail( i )
                       ifail( i ) = ifail( j )
                       ifail( j ) = itmp1
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_sstevx

     pure subroutine stdlib_dstevx( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
     !! DSTEVX computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix A.  Eigenvalues and
     !! eigenvectors can be selected by specifying either a range of values
     !! or a range of indices for the desired eigenvalues.
               work, iwork, ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           integer(ilp), intent(in) :: il, iu, ldz, n
           integer(ilp), intent(out) :: info, m
           real(dp), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, test, valeig, wantz
           character :: order
           integer(ilp) :: i, imax, indibl, indisp, indiwo, indwrk, iscale, itmp1, j, jj, &
                     nsplit
           real(dp) :: bignum, eps, rmax, rmin, safmin, sigma, smlnum, tmp1, tnrm, vll, &
                     vuu
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -7
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -8
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -9
                 end if
              end if
           end if
           if( info==0 ) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) )info = -14
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEVX', -info )
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = d( 1 )
              else
                 if( vl<d( 1 ) .and. vu>=d( 1 ) ) then
                    m = 1
                    w( 1 ) = d( 1 )
                 end if
              end if
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           eps = stdlib_dlamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           if( valeig ) then
              vll = vl
              vuu = vu
           else
              vll = zero
              vuu = zero
           end if
           tnrm = stdlib_dlanst( 'M', n, d, e )
           if( tnrm>zero .and. tnrm<rmin ) then
              iscale = 1
              sigma = rmin / tnrm
           else if( tnrm>rmax ) then
              iscale = 1
              sigma = rmax / tnrm
           end if
           if( iscale==1 ) then
              call stdlib_dscal( n, sigma, d, 1 )
              call stdlib_dscal( n-1, sigma, e( 1 ), 1 )
              if( valeig ) then
                 vll = vl*sigma
                 vuu = vu*sigma
              end if
           end if
           ! if all eigenvalues are desired and abstol is less than zero, then
           ! call stdlib_dsterf or stdlib_ssteqr.  if this fails for some eigenvalue, then
           ! try stdlib_dstebz.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig .or. test ) .and. ( abstol<=zero ) ) then
              call stdlib_dcopy( n, d, 1, w, 1 )
              call stdlib_dcopy( n-1, e( 1 ), 1, work( 1 ), 1 )
              indwrk = n + 1
              if( .not.wantz ) then
                 call stdlib_dsterf( n, w, work, info )
              else
                 call stdlib_dsteqr( 'I', n, w, work, z, ldz, work( indwrk ), info )
                 if( info==0 ) then
                    do i = 1, n
                       ifail( i ) = 0
                    end do
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 20
              end if
              info = 0
           end if
           ! otherwise, call stdlib_dstebz and, if eigenvectors are desired, stdlib_sstein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           indwrk = 1
           indibl = 1
           indisp = indibl + n
           indiwo = indisp + n
           call stdlib_dstebz( range, order, n, vll, vuu, il, iu, abstol, d, e, m,nsplit, w, &
                     iwork( indibl ), iwork( indisp ),work( indwrk ), iwork( indiwo ), info )
           if( wantz ) then
              call stdlib_dstein( n, d, e, m, w, iwork( indibl ), iwork( indisp ),z, ldz, work( &
                        indwrk ), iwork( indiwo ), ifail,info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           20 continue
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = m
              else
                 imax = info - 1
              end if
              call stdlib_dscal( imax, one / sigma, w, 1 )
           end if
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_dswap( n, z( 1, i ), 1, z( 1, j ), 1 )
                    if( info/=0 ) then
                       itmp1 = ifail( i )
                       ifail( i ) = ifail( j )
                       ifail( j ) = itmp1
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_dstevx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$stevx( jobz, range, n, d, e, vl, vu, il, iu, abstol,m, w, z, ldz, &
     !! DSTEVX: computes selected eigenvalues and, optionally, eigenvectors
     !! of a real symmetric tridiagonal matrix A.  Eigenvalues and
     !! eigenvectors can be selected by specifying either a range of values
     !! or a range of indices for the desired eigenvalues.
               work, iwork, ifail, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: jobz, range
           integer(ilp), intent(in) :: il, iu, ldz, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(in) :: abstol, vl, vu
           ! Array Arguments 
           integer(ilp), intent(out) :: ifail(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: w(*), work(*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: alleig, indeig, test, valeig, wantz
           character :: order
           integer(ilp) :: i, imax, indibl, indisp, indiwo, indwrk, iscale, itmp1, j, jj, &
                     nsplit
           real(${rk}$) :: bignum, eps, rmax, rmin, safmin, sigma, smlnum, tmp1, tnrm, vll, &
                     vuu
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           wantz = stdlib_lsame( jobz, 'V' )
           alleig = stdlib_lsame( range, 'A' )
           valeig = stdlib_lsame( range, 'V' )
           indeig = stdlib_lsame( range, 'I' )
           info = 0
           if( .not.( wantz .or. stdlib_lsame( jobz, 'N' ) ) ) then
              info = -1
           else if( .not.( alleig .or. valeig .or. indeig ) ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else
              if( valeig ) then
                 if( n>0 .and. vu<=vl )info = -7
              else if( indeig ) then
                 if( il<1 .or. il>max( 1, n ) ) then
                    info = -8
                 else if( iu<min( n, il ) .or. iu>n ) then
                    info = -9
                 end if
              end if
           end if
           if( info==0 ) then
              if( ldz<1 .or. ( wantz .and. ldz<n ) )info = -14
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSTEVX', -info )
              return
           end if
           ! quick return if possible
           m = 0
           if( n==0 )return
           if( n==1 ) then
              if( alleig .or. indeig ) then
                 m = 1
                 w( 1 ) = d( 1 )
              else
                 if( vl<d( 1 ) .and. vu>=d( 1 ) ) then
                    m = 1
                    w( 1 ) = d( 1 )
                 end if
              end if
              if( wantz )z( 1, 1 ) = one
              return
           end if
           ! get machine constants.
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           eps = stdlib_${ri}$lamch( 'PRECISION' )
           smlnum = safmin / eps
           bignum = one / smlnum
           rmin = sqrt( smlnum )
           rmax = min( sqrt( bignum ), one / sqrt( sqrt( safmin ) ) )
           ! scale matrix to allowable range, if necessary.
           iscale = 0
           if( valeig ) then
              vll = vl
              vuu = vu
           else
              vll = zero
              vuu = zero
           end if
           tnrm = stdlib_${ri}$lanst( 'M', n, d, e )
           if( tnrm>zero .and. tnrm<rmin ) then
              iscale = 1
              sigma = rmin / tnrm
           else if( tnrm>rmax ) then
              iscale = 1
              sigma = rmax / tnrm
           end if
           if( iscale==1 ) then
              call stdlib_${ri}$scal( n, sigma, d, 1 )
              call stdlib_${ri}$scal( n-1, sigma, e( 1 ), 1 )
              if( valeig ) then
                 vll = vl*sigma
                 vuu = vu*sigma
              end if
           end if
           ! if all eigenvalues are desired and abstol is less than zero, then
           ! call stdlib_${ri}$sterf or stdlib_dsteqr.  if this fails for some eigenvalue, then
           ! try stdlib_${ri}$stebz.
           test = .false.
           if( indeig ) then
              if( il==1 .and. iu==n ) then
                 test = .true.
              end if
           end if
           if( ( alleig .or. test ) .and. ( abstol<=zero ) ) then
              call stdlib_${ri}$copy( n, d, 1, w, 1 )
              call stdlib_${ri}$copy( n-1, e( 1 ), 1, work( 1 ), 1 )
              indwrk = n + 1
              if( .not.wantz ) then
                 call stdlib_${ri}$sterf( n, w, work, info )
              else
                 call stdlib_${ri}$steqr( 'I', n, w, work, z, ldz, work( indwrk ), info )
                 if( info==0 ) then
                    do i = 1, n
                       ifail( i ) = 0
                    end do
                 end if
              end if
              if( info==0 ) then
                 m = n
                 go to 20
              end if
              info = 0
           end if
           ! otherwise, call stdlib_${ri}$stebz and, if eigenvectors are desired, stdlib_dstein.
           if( wantz ) then
              order = 'B'
           else
              order = 'E'
           end if
           indwrk = 1
           indibl = 1
           indisp = indibl + n
           indiwo = indisp + n
           call stdlib_${ri}$stebz( range, order, n, vll, vuu, il, iu, abstol, d, e, m,nsplit, w, &
                     iwork( indibl ), iwork( indisp ),work( indwrk ), iwork( indiwo ), info )
           if( wantz ) then
              call stdlib_${ri}$stein( n, d, e, m, w, iwork( indibl ), iwork( indisp ),z, ldz, work( &
                        indwrk ), iwork( indiwo ), ifail,info )
           end if
           ! if matrix was scaled, then rescale eigenvalues appropriately.
           20 continue
           if( iscale==1 ) then
              if( info==0 ) then
                 imax = m
              else
                 imax = info - 1
              end if
              call stdlib_${ri}$scal( imax, one / sigma, w, 1 )
           end if
           ! if eigenvalues are not in order, then sort them, along with
           ! eigenvectors.
           if( wantz ) then
              do j = 1, m - 1
                 i = 0
                 tmp1 = w( j )
                 do jj = j + 1, m
                    if( w( jj )<tmp1 ) then
                       i = jj
                       tmp1 = w( jj )
                    end if
                 end do
                 if( i/=0 ) then
                    itmp1 = iwork( indibl+i-1 )
                    w( i ) = w( j )
                    iwork( indibl+i-1 ) = iwork( indibl+j-1 )
                    w( j ) = tmp1
                    iwork( indibl+j-1 ) = itmp1
                    call stdlib_${ri}$swap( n, z( 1, i ), 1, z( 1, j ), 1 )
                    if( info/=0 ) then
                       itmp1 = ifail( i )
                       ifail( i ) = ifail( j )
                       ifail( j ) = itmp1
                    end if
                 end if
              end do
           end if
           return
     end subroutine stdlib_${ri}$stevx

#:endif
#:endfor


end module stdlib_lapack_eigv_sym
