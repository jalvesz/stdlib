#:include "common.fypp" 
submodule(stdlib_lapack) stdlib_lapack_eigv_svd_drivers2
  implicit none(type,external)


  contains



     module pure subroutine stdlib_sbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, work, &
     !! SBDSQR computes the singular values and, optionally, the right and/or
     !! left singular vectors from the singular value decomposition (SVD) of
     !! a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
     !! zero-shift QR algorithm.  The SVD of B has the form
     !! B = Q * S * P**T
     !! where S is the diagonal matrix of singular values, Q is an orthogonal
     !! matrix of left singular vectors, and P is an orthogonal matrix of
     !! right singular vectors.  If left singular vectors are requested, this
     !! subroutine actually returns U*Q instead of Q, and, if right singular
     !! vectors are requested, this subroutine returns P**T*VT instead of
     !! P**T, for given real input matrices U and VT.  When U and VT are the
     !! orthogonal matrices that reduce a general matrix A to bidiagonal
     !! form:  A = U*B*VT, as computed by SGEBRD, then
     !! A = (U*Q) * S * (P**T*VT)
     !! is the SVD of A.  Optionally, the subroutine may also compute Q**T*C
     !! for a given real input matrix C.
     !! See "Computing  Small Singular Values of Bidiagonal Matrices With
     !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
     !! LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
     !! no. 5, pp. 873-912, Sept 1990) and
     !! "Accurate singular values and differential qd algorithms," by
     !! B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
     !! Department, University of California at Berkeley, July 1992
     !! for a detailed description of the algorithm.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           ! Array Arguments 
           real(sp), intent(inout) :: c(ldc,*), d(*), e(*), u(ldu,*), vt(ldvt,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: hndrth = 0.01_sp
           real(sp), parameter :: hndrd = 100.0_sp
           real(sp), parameter :: meigth = -0.125_sp
           integer(ilp), parameter :: maxitr = 6
           
           
           
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: lower, rotate
           integer(ilp) :: i, idir, isub, iter, iterdivn, j, ll, lll, m, maxitdivn, nm1, nm12, &
                     nm13, oldll, oldm
           real(sp) :: abse, abss, cosl, cosr, cs, eps, f, g, h, mu, oldcs, oldsn, r, shift, &
           sigmn, sigmx, sinl, sinr, sll, smax, smin, sminl, sminoa, sn, thresh, tol, tolmul, &
                     unfl
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.lower ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ncvt<0 ) then
              info = -3
           else if( nru<0 ) then
              info = -4
           else if( ncc<0 ) then
              info = -5
           else if( ( ncvt==0 .and. ldvt<1 ) .or.( ncvt>0 .and. ldvt<max( 1, n ) ) ) then
              info = -9
           else if( ldu<max( 1, nru ) ) then
              info = -11
           else if( ( ncc==0 .and. ldc<1 ) .or.( ncc>0 .and. ldc<max( 1, n ) ) ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SBDSQR', -info )
              return
           end if
           if( n==0 )return
           if( n==1 )go to 160
           ! rotate is true if any singular vectors desired, false otherwise
           rotate = ( ncvt>0 ) .or. ( nru>0 ) .or. ( ncc>0 )
           ! if no singular vectors desired, use qd algorithm
           if( .not.rotate ) then
              call stdlib_slasq1( n, d, e, work, info )
           ! if info equals 2, dqds didn't finish, try to finish
              if( info /= 2 ) return
              info = 0
           end if
           nm1 = n - 1
           nm12 = nm1 + nm1
           nm13 = nm12 + nm1
           idir = 0
           ! get machine constants
           eps = stdlib_slamch( 'EPSILON' )
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           if( lower ) then
              do i = 1, n - 1
                 call stdlib_slartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 work( i ) = cs
                 work( nm1+i ) = sn
              end do
              ! update singular vectors if desired
              if( nru>0 )call stdlib_slasr( 'R', 'V', 'F', nru, n, work( 1 ), work( n ), u,ldu )
                        
              if( ncc>0 )call stdlib_slasr( 'L', 'V', 'F', n, ncc, work( 1 ), work( n ), c,ldc )
                        
           end if
           ! compute singular values to relative accuracy tol
           ! (by setting tol to be negative, algorithm will compute
           ! singular values to absolute accuracy abs(tol)*norm(input matrix))
           tolmul = max( ten, min( hndrd, eps**meigth ) )
           tol = tolmul*eps
           ! compute approximate maximum, minimum singular values
           smax = zero
           do i = 1, n
              smax = max( smax, abs( d( i ) ) )
           end do
           do i = 1, n - 1
              smax = max( smax, abs( e( i ) ) )
           end do
           sminl = zero
           if( tol>=zero ) then
              ! relative accuracy desired
              sminoa = abs( d( 1 ) )
              if( sminoa==zero )go to 50
              mu = sminoa
              do i = 2, n
                 mu = abs( d( i ) )*( mu / ( mu+abs( e( i-1 ) ) ) )
                 sminoa = min( sminoa, mu )
                 if( sminoa==zero )go to 50
              end do
              50 continue
              sminoa = sminoa / sqrt( real( n,KIND=sp) )
              thresh = max( tol*sminoa, maxitr*(n*(n*unfl)) )
           else
              ! absolute accuracy desired
              thresh = max( abs( tol )*smax, maxitr*(n*(n*unfl)) )
           end if
           ! prepare for main iteration loop for the singular values
           ! (maxit is the maximum number of passes through the inner
           ! loop permitted before nonconvergence signalled.)
           maxitdivn = maxitr*n
           iterdivn = 0
           iter = -1
           oldll = -1
           oldm = -1
           ! m points to last element of unconverged part of matrix
           m = n
           ! begin main iteration loop
           60 continue
           ! check for convergence or exceeding iteration count
           if( m<=1 )go to 160
           if( iter>=n ) then
              iter = iter - n
              iterdivn = iterdivn + 1
              if( iterdivn>=maxitdivn )go to 200
           end if
           ! find diagonal block of matrix to work on
           if( tol<zero .and. abs( d( m ) )<=thresh )d( m ) = zero
           smax = abs( d( m ) )
           smin = smax
           do lll = 1, m - 1
              ll = m - lll
              abss = abs( d( ll ) )
              abse = abs( e( ll ) )
              if( tol<zero .and. abss<=thresh )d( ll ) = zero
              if( abse<=thresh )go to 80
              smin = min( smin, abss )
              smax = max( smax, abss, abse )
           end do
           ll = 0
           go to 90
           80 continue
           e( ll ) = zero
           ! matrix splits since e(ll) = 0
           if( ll==m-1 ) then
              ! convergence of bottom singular value, return to top of loop
              m = m - 1
              go to 60
           end if
           90 continue
           ll = ll + 1
           ! e(ll) through e(m-1) are nonzero, e(ll-1) is zero
           if( ll==m-1 ) then
              ! 2 by 2 block, handle separately
              call stdlib_slasv2( d( m-1 ), e( m-1 ), d( m ), sigmn, sigmx, sinr,cosr, sinl, cosl &
                        )
              d( m-1 ) = sigmx
              e( m-1 ) = zero
              d( m ) = sigmn
              ! compute singular vectors, if desired
              if( ncvt>0 )call stdlib_srot( ncvt, vt( m-1, 1 ), ldvt, vt( m, 1 ), ldvt, cosr,sinr &
                        )
              if( nru>0 )call stdlib_srot( nru, u( 1, m-1 ), 1, u( 1, m ), 1, cosl, sinl )
              if( ncc>0 )call stdlib_srot( ncc, c( m-1, 1 ), ldc, c( m, 1 ), ldc, cosl,sinl )
                        
              m = m - 2
              go to 60
           end if
           ! if working on new submatrix, choose shift direction
           ! (from larger end diagonal element towards smaller)
           if( ll>oldm .or. m<oldll ) then
              if( abs( d( ll ) )>=abs( d( m ) ) ) then
                 ! chase bulge from top (big end) to bottom (small end)
                 idir = 1
              else
                 ! chase bulge from bottom (big end) to top (small end)
                 idir = 2
              end if
           end if
           ! apply convergence tests
           if( idir==1 ) then
              ! run convergence test in forward direction
              ! first apply standard test to bottom of matrix
              if( abs( e( m-1 ) )<=abs( tol )*abs( d( m ) ) .or.( tol<zero .and. abs( e( m-1 ) )&
                        <=thresh ) ) then
                 e( m-1 ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion forward
                 mu = abs( d( ll ) )
                 sminl = mu
                 do lll = ll, m - 1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll+1 ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           else
              ! run convergence test in backward direction
              ! first apply standard test to top of matrix
              if( abs( e( ll ) )<=abs( tol )*abs( d( ll ) ) .or.( tol<zero .and. abs( e( ll ) )&
                        <=thresh ) ) then
                 e( ll ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion backward
                 mu = abs( d( m ) )
                 sminl = mu
                 do lll = m - 1, ll, -1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           end if
           oldll = ll
           oldm = m
           ! compute shift.  first, test if shifting would ruin relative
           ! accuracy, and if so set the shift to zero.
           if( tol>=zero .and. n*tol*( sminl / smax )<=max( eps, hndrth*tol ) ) then
              ! use a zero shift to avoid loss of relative accuracy
              shift = zero
           else
              ! compute the shift from 2-by-2 block at end of matrix
              if( idir==1 ) then
                 sll = abs( d( ll ) )
                 call stdlib_slas2( d( m-1 ), e( m-1 ), d( m ), shift, r )
              else
                 sll = abs( d( m ) )
                 call stdlib_slas2( d( ll ), e( ll ), d( ll+1 ), shift, r )
              end if
              ! test if shift negligible, and if so set to zero
              if( sll>zero ) then
                 if( ( shift / sll )**2<eps )shift = zero
              end if
           end if
           ! increment iteration count
           iter = iter + m - ll
           ! if shift = 0, do simplified qr iteration
           if( shift==zero ) then
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = ll, m - 1
                    call stdlib_slartg( d( i )*cs, e( i ), cs, sn, r )
                    if( i>ll )e( i-1 ) = oldsn*r
                    call stdlib_slartg( oldcs*r, d( i+1 )*sn, oldcs, oldsn, d( i ) )
                    work( i-ll+1 ) = cs
                    work( i-ll+1+nm1 ) = sn
                    work( i-ll+1+nm12 ) = oldcs
                    work( i-ll+1+nm13 ) = oldsn
                 end do
                 h = d( m )*cs
                 d( m ) = h*oldcs
                 e( m-1 ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_slasr( 'L', 'V', 'F', m-ll+1, ncvt, work( 1 ),work( n ), &
                           vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_slasr( 'R', 'V', 'F', nru, m-ll+1, work( nm12+1 ),work( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_slasr( 'L', 'V', 'F', m-ll+1, ncc, work( nm12+1 ),work( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = m, ll + 1, -1
                    call stdlib_slartg( d( i )*cs, e( i-1 ), cs, sn, r )
                    if( i<m )e( i ) = oldsn*r
                    call stdlib_slartg( oldcs*r, d( i-1 )*sn, oldcs, oldsn, d( i ) )
                    work( i-ll ) = cs
                    work( i-ll+nm1 ) = -sn
                    work( i-ll+nm12 ) = oldcs
                    work( i-ll+nm13 ) = -oldsn
                 end do
                 h = d( ll )*cs
                 d( ll ) = h*oldcs
                 e( ll ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_slasr( 'L', 'V', 'B', m-ll+1, ncvt, work( nm12+1 ),work( &
                           nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_slasr( 'R', 'V', 'B', nru, m-ll+1, work( 1 ),work( n ), u(&
                            1, ll ), ldu )
                 if( ncc>0 )call stdlib_slasr( 'L', 'V', 'B', m-ll+1, ncc, work( 1 ),work( n ), c(&
                            ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
              end if
           else
              ! use nonzero shift
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( ll ) )-shift )*( sign( one, d( ll ) )+shift / d( ll ) )
                 g = e( ll )
                 do i = ll, m - 1
                    call stdlib_slartg( f, g, cosr, sinr, r )
                    if( i>ll )e( i-1 ) = r
                    f = cosr*d( i ) + sinr*e( i )
                    e( i ) = cosr*e( i ) - sinr*d( i )
                    g = sinr*d( i+1 )
                    d( i+1 ) = cosr*d( i+1 )
                    call stdlib_slartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i ) + sinl*d( i+1 )
                    d( i+1 ) = cosl*d( i+1 ) - sinl*e( i )
                    if( i<m-1 ) then
                       g = sinl*e( i+1 )
                       e( i+1 ) = cosl*e( i+1 )
                    end if
                    work( i-ll+1 ) = cosr
                    work( i-ll+1+nm1 ) = sinr
                    work( i-ll+1+nm12 ) = cosl
                    work( i-ll+1+nm13 ) = sinl
                 end do
                 e( m-1 ) = f
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_slasr( 'L', 'V', 'F', m-ll+1, ncvt, work( 1 ),work( n ), &
                           vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_slasr( 'R', 'V', 'F', nru, m-ll+1, work( nm12+1 ),work( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_slasr( 'L', 'V', 'F', m-ll+1, ncc, work( nm12+1 ),work( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( m ) )-shift )*( sign( one, d( m ) )+shift /d( m ) )
                 g = e( m-1 )
                 do i = m, ll + 1, -1
                    call stdlib_slartg( f, g, cosr, sinr, r )
                    if( i<m )e( i ) = r
                    f = cosr*d( i ) + sinr*e( i-1 )
                    e( i-1 ) = cosr*e( i-1 ) - sinr*d( i )
                    g = sinr*d( i-1 )
                    d( i-1 ) = cosr*d( i-1 )
                    call stdlib_slartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i-1 ) + sinl*d( i-1 )
                    d( i-1 ) = cosl*d( i-1 ) - sinl*e( i-1 )
                    if( i>ll+1 ) then
                       g = sinl*e( i-2 )
                       e( i-2 ) = cosl*e( i-2 )
                    end if
                    work( i-ll ) = cosr
                    work( i-ll+nm1 ) = -sinr
                    work( i-ll+nm12 ) = cosl
                    work( i-ll+nm13 ) = -sinl
                 end do
                 e( ll ) = f
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
                 ! update singular vectors if desired
                 if( ncvt>0 )call stdlib_slasr( 'L', 'V', 'B', m-ll+1, ncvt, work( nm12+1 ),work( &
                           nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_slasr( 'R', 'V', 'B', nru, m-ll+1, work( 1 ),work( n ), u(&
                            1, ll ), ldu )
                 if( ncc>0 )call stdlib_slasr( 'L', 'V', 'B', m-ll+1, ncc, work( 1 ),work( n ), c(&
                            ll, 1 ), ldc )
              end if
           end if
           ! qr iteration finished, go back and check convergence
           go to 60
           ! all singular values converged, so make them positive
           160 continue
           do i = 1, n
              if( d( i )<zero ) then
                 d( i ) = -d( i )
                 ! change sign of singular vectors, if desired
                 if( ncvt>0 )call stdlib_sscal( ncvt, negone, vt( i, 1 ), ldvt )
              end if
           end do
           ! sort the singular values into decreasing order (insertion sort on
           ! singular values, but only one transposition per singular vector)
           do i = 1, n - 1
              ! scan for smallest d(i)
              isub = 1
              smin = d( 1 )
              do j = 2, n + 1 - i
                 if( d( j )<=smin ) then
                    isub = j
                    smin = d( j )
                 end if
              end do
              if( isub/=n+1-i ) then
                 ! swap singular values and vectors
                 d( isub ) = d( n+1-i )
                 d( n+1-i ) = smin
                 if( ncvt>0 )call stdlib_sswap( ncvt, vt( isub, 1 ), ldvt, vt( n+1-i, 1 ),ldvt )
                           
                 if( nru>0 )call stdlib_sswap( nru, u( 1, isub ), 1, u( 1, n+1-i ), 1 )
                 if( ncc>0 )call stdlib_sswap( ncc, c( isub, 1 ), ldc, c( n+1-i, 1 ), ldc )
                           
              end if
           end do
           go to 220
           ! maximum number of iterations exceeded, failure to converge
           200 continue
           info = 0
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           220 continue
           return
     end subroutine stdlib_sbdsqr

     module pure subroutine stdlib_dbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, work, &
     !! DBDSQR computes the singular values and, optionally, the right and/or
     !! left singular vectors from the singular value decomposition (SVD) of
     !! a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
     !! zero-shift QR algorithm.  The SVD of B has the form
     !! B = Q * S * P**T
     !! where S is the diagonal matrix of singular values, Q is an orthogonal
     !! matrix of left singular vectors, and P is an orthogonal matrix of
     !! right singular vectors.  If left singular vectors are requested, this
     !! subroutine actually returns U*Q instead of Q, and, if right singular
     !! vectors are requested, this subroutine returns P**T*VT instead of
     !! P**T, for given real input matrices U and VT.  When U and VT are the
     !! orthogonal matrices that reduce a general matrix A to bidiagonal
     !! form:  A = U*B*VT, as computed by DGEBRD, then
     !! A = (U*Q) * S * (P**T*VT)
     !! is the SVD of A.  Optionally, the subroutine may also compute Q**T*C
     !! for a given real input matrix C.
     !! See "Computing  Small Singular Values of Bidiagonal Matrices With
     !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
     !! LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
     !! no. 5, pp. 873-912, Sept 1990) and
     !! "Accurate singular values and differential qd algorithms," by
     !! B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
     !! Department, University of California at Berkeley, July 1992
     !! for a detailed description of the algorithm.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           ! Array Arguments 
           real(dp), intent(inout) :: c(ldc,*), d(*), e(*), u(ldu,*), vt(ldvt,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: hndrth = 0.01_dp
           real(dp), parameter :: hndrd = 100.0_dp
           real(dp), parameter :: meigth = -0.125_dp
           integer(ilp), parameter :: maxitr = 6
           
           
           
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: lower, rotate
           integer(ilp) :: i, idir, isub, iter, iterdivn, j, ll, lll, m, maxitdivn, nm1, nm12, &
                     nm13, oldll, oldm
           real(dp) :: abse, abss, cosl, cosr, cs, eps, f, g, h, mu, oldcs, oldsn, r, shift, &
           sigmn, sigmx, sinl, sinr, sll, smax, smin, sminl, sminoa, sn, thresh, tol, tolmul, &
                     unfl
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.lower ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ncvt<0 ) then
              info = -3
           else if( nru<0 ) then
              info = -4
           else if( ncc<0 ) then
              info = -5
           else if( ( ncvt==0 .and. ldvt<1 ) .or.( ncvt>0 .and. ldvt<max( 1, n ) ) ) then
              info = -9
           else if( ldu<max( 1, nru ) ) then
              info = -11
           else if( ( ncc==0 .and. ldc<1 ) .or.( ncc>0 .and. ldc<max( 1, n ) ) ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DBDSQR', -info )
              return
           end if
           if( n==0 )return
           if( n==1 )go to 160
           ! rotate is true if any singular vectors desired, false otherwise
           rotate = ( ncvt>0 ) .or. ( nru>0 ) .or. ( ncc>0 )
           ! if no singular vectors desired, use qd algorithm
           if( .not.rotate ) then
              call stdlib_dlasq1( n, d, e, work, info )
           ! if info equals 2, dqds didn't finish, try to finish
              if( info /= 2 ) return
              info = 0
           end if
           nm1 = n - 1
           nm12 = nm1 + nm1
           nm13 = nm12 + nm1
           idir = 0
           ! get machine constants
           eps = stdlib_dlamch( 'EPSILON' )
           unfl = stdlib_dlamch( 'SAFE MINIMUM' )
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           if( lower ) then
              do i = 1, n - 1
                 call stdlib_dlartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 work( i ) = cs
                 work( nm1+i ) = sn
              end do
              ! update singular vectors if desired
              if( nru>0 )call stdlib_dlasr( 'R', 'V', 'F', nru, n, work( 1 ), work( n ), u,ldu )
                        
              if( ncc>0 )call stdlib_dlasr( 'L', 'V', 'F', n, ncc, work( 1 ), work( n ), c,ldc )
                        
           end if
           ! compute singular values to relative accuracy tol
           ! (by setting tol to be negative, algorithm will compute
           ! singular values to absolute accuracy abs(tol)*norm(input matrix))
           tolmul = max( ten, min( hndrd, eps**meigth ) )
           tol = tolmul*eps
           ! compute approximate maximum, minimum singular values
           smax = zero
           do i = 1, n
              smax = max( smax, abs( d( i ) ) )
           end do
           do i = 1, n - 1
              smax = max( smax, abs( e( i ) ) )
           end do
           sminl = zero
           if( tol>=zero ) then
              ! relative accuracy desired
              sminoa = abs( d( 1 ) )
              if( sminoa==zero )go to 50
              mu = sminoa
              do i = 2, n
                 mu = abs( d( i ) )*( mu / ( mu+abs( e( i-1 ) ) ) )
                 sminoa = min( sminoa, mu )
                 if( sminoa==zero )go to 50
              end do
              50 continue
              sminoa = sminoa / sqrt( real( n,KIND=dp) )
              thresh = max( tol*sminoa, maxitr*(n*(n*unfl)) )
           else
              ! absolute accuracy desired
              thresh = max( abs( tol )*smax, maxitr*(n*(n*unfl)) )
           end if
           ! prepare for main iteration loop for the singular values
           ! (maxit is the maximum number of passes through the inner
           ! loop permitted before nonconvergence signalled.)
           maxitdivn = maxitr*n
           iterdivn = 0
           iter = -1
           oldll = -1
           oldm = -1
           ! m points to last element of unconverged part of matrix
           m = n
           ! begin main iteration loop
           60 continue
           ! check for convergence or exceeding iteration count
           if( m<=1 )go to 160
           if( iter>=n ) then
              iter = iter - n
              iterdivn = iterdivn + 1
              if( iterdivn>=maxitdivn )go to 200
           end if
           ! find diagonal block of matrix to work on
           if( tol<zero .and. abs( d( m ) )<=thresh )d( m ) = zero
           smax = abs( d( m ) )
           smin = smax
           do lll = 1, m - 1
              ll = m - lll
              abss = abs( d( ll ) )
              abse = abs( e( ll ) )
              if( tol<zero .and. abss<=thresh )d( ll ) = zero
              if( abse<=thresh )go to 80
              smin = min( smin, abss )
              smax = max( smax, abss, abse )
           end do
           ll = 0
           go to 90
           80 continue
           e( ll ) = zero
           ! matrix splits since e(ll) = 0
           if( ll==m-1 ) then
              ! convergence of bottom singular value, return to top of loop
              m = m - 1
              go to 60
           end if
           90 continue
           ll = ll + 1
           ! e(ll) through e(m-1) are nonzero, e(ll-1) is zero
           if( ll==m-1 ) then
              ! 2 by 2 block, handle separately
              call stdlib_dlasv2( d( m-1 ), e( m-1 ), d( m ), sigmn, sigmx, sinr,cosr, sinl, cosl &
                        )
              d( m-1 ) = sigmx
              e( m-1 ) = zero
              d( m ) = sigmn
              ! compute singular vectors, if desired
              if( ncvt>0 )call stdlib_drot( ncvt, vt( m-1, 1 ), ldvt, vt( m, 1 ), ldvt, cosr,sinr &
                        )
              if( nru>0 )call stdlib_drot( nru, u( 1, m-1 ), 1, u( 1, m ), 1, cosl, sinl )
              if( ncc>0 )call stdlib_drot( ncc, c( m-1, 1 ), ldc, c( m, 1 ), ldc, cosl,sinl )
                        
              m = m - 2
              go to 60
           end if
           ! if working on new submatrix, choose shift direction
           ! (from larger end diagonal element towards smaller)
           if( ll>oldm .or. m<oldll ) then
              if( abs( d( ll ) )>=abs( d( m ) ) ) then
                 ! chase bulge from top (big end) to bottom (small end)
                 idir = 1
              else
                 ! chase bulge from bottom (big end) to top (small end)
                 idir = 2
              end if
           end if
           ! apply convergence tests
           if( idir==1 ) then
              ! run convergence test in forward direction
              ! first apply standard test to bottom of matrix
              if( abs( e( m-1 ) )<=abs( tol )*abs( d( m ) ) .or.( tol<zero .and. abs( e( m-1 ) )&
                        <=thresh ) ) then
                 e( m-1 ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion forward
                 mu = abs( d( ll ) )
                 sminl = mu
                 do lll = ll, m - 1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll+1 ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           else
              ! run convergence test in backward direction
              ! first apply standard test to top of matrix
              if( abs( e( ll ) )<=abs( tol )*abs( d( ll ) ) .or.( tol<zero .and. abs( e( ll ) )&
                        <=thresh ) ) then
                 e( ll ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion backward
                 mu = abs( d( m ) )
                 sminl = mu
                 do lll = m - 1, ll, -1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           end if
           oldll = ll
           oldm = m
           ! compute shift.  first, test if shifting would ruin relative
           ! accuracy, and if so set the shift to zero.
           if( tol>=zero .and. n*tol*( sminl / smax )<=max( eps, hndrth*tol ) ) then
              ! use a zero shift to avoid loss of relative accuracy
              shift = zero
           else
              ! compute the shift from 2-by-2 block at end of matrix
              if( idir==1 ) then
                 sll = abs( d( ll ) )
                 call stdlib_dlas2( d( m-1 ), e( m-1 ), d( m ), shift, r )
              else
                 sll = abs( d( m ) )
                 call stdlib_dlas2( d( ll ), e( ll ), d( ll+1 ), shift, r )
              end if
              ! test if shift negligible, and if so set to zero
              if( sll>zero ) then
                 if( ( shift / sll )**2<eps )shift = zero
              end if
           end if
           ! increment iteration count
           iter = iter + m - ll
           ! if shift = 0, do simplified qr iteration
           if( shift==zero ) then
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = ll, m - 1
                    call stdlib_dlartg( d( i )*cs, e( i ), cs, sn, r )
                    if( i>ll )e( i-1 ) = oldsn*r
                    call stdlib_dlartg( oldcs*r, d( i+1 )*sn, oldcs, oldsn, d( i ) )
                    work( i-ll+1 ) = cs
                    work( i-ll+1+nm1 ) = sn
                    work( i-ll+1+nm12 ) = oldcs
                    work( i-ll+1+nm13 ) = oldsn
                 end do
                 h = d( m )*cs
                 d( m ) = h*oldcs
                 e( m-1 ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_dlasr( 'L', 'V', 'F', m-ll+1, ncvt, work( 1 ),work( n ), &
                           vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_dlasr( 'R', 'V', 'F', nru, m-ll+1, work( nm12+1 ),work( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_dlasr( 'L', 'V', 'F', m-ll+1, ncc, work( nm12+1 ),work( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = m, ll + 1, -1
                    call stdlib_dlartg( d( i )*cs, e( i-1 ), cs, sn, r )
                    if( i<m )e( i ) = oldsn*r
                    call stdlib_dlartg( oldcs*r, d( i-1 )*sn, oldcs, oldsn, d( i ) )
                    work( i-ll ) = cs
                    work( i-ll+nm1 ) = -sn
                    work( i-ll+nm12 ) = oldcs
                    work( i-ll+nm13 ) = -oldsn
                 end do
                 h = d( ll )*cs
                 d( ll ) = h*oldcs
                 e( ll ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_dlasr( 'L', 'V', 'B', m-ll+1, ncvt, work( nm12+1 ),work( &
                           nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_dlasr( 'R', 'V', 'B', nru, m-ll+1, work( 1 ),work( n ), u(&
                            1, ll ), ldu )
                 if( ncc>0 )call stdlib_dlasr( 'L', 'V', 'B', m-ll+1, ncc, work( 1 ),work( n ), c(&
                            ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
              end if
           else
              ! use nonzero shift
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( ll ) )-shift )*( sign( one, d( ll ) )+shift / d( ll ) )
                 g = e( ll )
                 do i = ll, m - 1
                    call stdlib_dlartg( f, g, cosr, sinr, r )
                    if( i>ll )e( i-1 ) = r
                    f = cosr*d( i ) + sinr*e( i )
                    e( i ) = cosr*e( i ) - sinr*d( i )
                    g = sinr*d( i+1 )
                    d( i+1 ) = cosr*d( i+1 )
                    call stdlib_dlartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i ) + sinl*d( i+1 )
                    d( i+1 ) = cosl*d( i+1 ) - sinl*e( i )
                    if( i<m-1 ) then
                       g = sinl*e( i+1 )
                       e( i+1 ) = cosl*e( i+1 )
                    end if
                    work( i-ll+1 ) = cosr
                    work( i-ll+1+nm1 ) = sinr
                    work( i-ll+1+nm12 ) = cosl
                    work( i-ll+1+nm13 ) = sinl
                 end do
                 e( m-1 ) = f
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_dlasr( 'L', 'V', 'F', m-ll+1, ncvt, work( 1 ),work( n ), &
                           vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_dlasr( 'R', 'V', 'F', nru, m-ll+1, work( nm12+1 ),work( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_dlasr( 'L', 'V', 'F', m-ll+1, ncc, work( nm12+1 ),work( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( m ) )-shift )*( sign( one, d( m ) )+shift /d( m ) )
                 g = e( m-1 )
                 do i = m, ll + 1, -1
                    call stdlib_dlartg( f, g, cosr, sinr, r )
                    if( i<m )e( i ) = r
                    f = cosr*d( i ) + sinr*e( i-1 )
                    e( i-1 ) = cosr*e( i-1 ) - sinr*d( i )
                    g = sinr*d( i-1 )
                    d( i-1 ) = cosr*d( i-1 )
                    call stdlib_dlartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i-1 ) + sinl*d( i-1 )
                    d( i-1 ) = cosl*d( i-1 ) - sinl*e( i-1 )
                    if( i>ll+1 ) then
                       g = sinl*e( i-2 )
                       e( i-2 ) = cosl*e( i-2 )
                    end if
                    work( i-ll ) = cosr
                    work( i-ll+nm1 ) = -sinr
                    work( i-ll+nm12 ) = cosl
                    work( i-ll+nm13 ) = -sinl
                 end do
                 e( ll ) = f
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
                 ! update singular vectors if desired
                 if( ncvt>0 )call stdlib_dlasr( 'L', 'V', 'B', m-ll+1, ncvt, work( nm12+1 ),work( &
                           nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_dlasr( 'R', 'V', 'B', nru, m-ll+1, work( 1 ),work( n ), u(&
                            1, ll ), ldu )
                 if( ncc>0 )call stdlib_dlasr( 'L', 'V', 'B', m-ll+1, ncc, work( 1 ),work( n ), c(&
                            ll, 1 ), ldc )
              end if
           end if
           ! qr iteration finished, go back and check convergence
           go to 60
           ! all singular values converged, so make them positive
           160 continue
           do i = 1, n
              if( d( i )<zero ) then
                 d( i ) = -d( i )
                 ! change sign of singular vectors, if desired
                 if( ncvt>0 )call stdlib_dscal( ncvt, negone, vt( i, 1 ), ldvt )
              end if
           end do
           ! sort the singular values into decreasing order (insertion sort on
           ! singular values, but only one transposition per singular vector)
           do i = 1, n - 1
              ! scan for smallest d(i)
              isub = 1
              smin = d( 1 )
              do j = 2, n + 1 - i
                 if( d( j )<=smin ) then
                    isub = j
                    smin = d( j )
                 end if
              end do
              if( isub/=n+1-i ) then
                 ! swap singular values and vectors
                 d( isub ) = d( n+1-i )
                 d( n+1-i ) = smin
                 if( ncvt>0 )call stdlib_dswap( ncvt, vt( isub, 1 ), ldvt, vt( n+1-i, 1 ),ldvt )
                           
                 if( nru>0 )call stdlib_dswap( nru, u( 1, isub ), 1, u( 1, n+1-i ), 1 )
                 if( ncc>0 )call stdlib_dswap( ncc, c( isub, 1 ), ldc, c( n+1-i, 1 ), ldc )
                           
              end if
           end do
           go to 220
           ! maximum number of iterations exceeded, failure to converge
           200 continue
           info = 0
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           220 continue
           return
     end subroutine stdlib_dbdsqr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$bdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, work, &
     !! DBDSQR: computes the singular values and, optionally, the right and/or
     !! left singular vectors from the singular value decomposition (SVD) of
     !! a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
     !! zero-shift QR algorithm.  The SVD of B has the form
     !! B = Q * S * P**T
     !! where S is the diagonal matrix of singular values, Q is an orthogonal
     !! matrix of left singular vectors, and P is an orthogonal matrix of
     !! right singular vectors.  If left singular vectors are requested, this
     !! subroutine actually returns U*Q instead of Q, and, if right singular
     !! vectors are requested, this subroutine returns P**T*VT instead of
     !! P**T, for given real input matrices U and VT.  When U and VT are the
     !! orthogonal matrices that reduce a general matrix A to bidiagonal
     !! form:  A = U*B*VT, as computed by DGEBRD, then
     !! A = (U*Q) * S * (P**T*VT)
     !! is the SVD of A.  Optionally, the subroutine may also compute Q**T*C
     !! for a given real input matrix C.
     !! See "Computing  Small Singular Values of Bidiagonal Matrices With
     !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
     !! LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
     !! no. 5, pp. 873-912, Sept 1990) and
     !! "Accurate singular values and differential qd algorithms," by
     !! B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
     !! Department, University of California at Berkeley, July 1992
     !! for a detailed description of the algorithm.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           ! Array Arguments 
           real(${rk}$), intent(inout) :: c(ldc,*), d(*), e(*), u(ldu,*), vt(ldvt,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: hndrth = 0.01_${rk}$
           real(${rk}$), parameter :: hndrd = 100.0_${rk}$
           real(${rk}$), parameter :: meigth = -0.125_${rk}$
           integer(ilp), parameter :: maxitr = 6
           
           
           
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: lower, rotate
           integer(ilp) :: i, idir, isub, iter, iterdivn, j, ll, lll, m, maxitdivn, nm1, nm12, &
                     nm13, oldll, oldm
           real(${rk}$) :: abse, abss, cosl, cosr, cs, eps, f, g, h, mu, oldcs, oldsn, r, shift, &
           sigmn, sigmx, sinl, sinr, sll, smax, smin, sminl, sminoa, sn, thresh, tol, tolmul, &
                     unfl
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.lower ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ncvt<0 ) then
              info = -3
           else if( nru<0 ) then
              info = -4
           else if( ncc<0 ) then
              info = -5
           else if( ( ncvt==0 .and. ldvt<1 ) .or.( ncvt>0 .and. ldvt<max( 1, n ) ) ) then
              info = -9
           else if( ldu<max( 1, nru ) ) then
              info = -11
           else if( ( ncc==0 .and. ldc<1 ) .or.( ncc>0 .and. ldc<max( 1, n ) ) ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DBDSQR', -info )
              return
           end if
           if( n==0 )return
           if( n==1 )go to 160
           ! rotate is true if any singular vectors desired, false otherwise
           rotate = ( ncvt>0 ) .or. ( nru>0 ) .or. ( ncc>0 )
           ! if no singular vectors desired, use qd algorithm
           if( .not.rotate ) then
              call stdlib_${ri}$lasq1( n, d, e, work, info )
           ! if info equals 2, dqds didn't finish, try to finish
              if( info /= 2 ) return
              info = 0
           end if
           nm1 = n - 1
           nm12 = nm1 + nm1
           nm13 = nm12 + nm1
           idir = 0
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           unfl = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           if( lower ) then
              do i = 1, n - 1
                 call stdlib_${ri}$lartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 work( i ) = cs
                 work( nm1+i ) = sn
              end do
              ! update singular vectors if desired
              if( nru>0 )call stdlib_${ri}$lasr( 'R', 'V', 'F', nru, n, work( 1 ), work( n ), u,ldu )
                        
              if( ncc>0 )call stdlib_${ri}$lasr( 'L', 'V', 'F', n, ncc, work( 1 ), work( n ), c,ldc )
                        
           end if
           ! compute singular values to relative accuracy tol
           ! (by setting tol to be negative, algorithm will compute
           ! singular values to absolute accuracy abs(tol)*norm(input matrix))
           tolmul = max( ten, min( hndrd, eps**meigth ) )
           tol = tolmul*eps
           ! compute approximate maximum, minimum singular values
           smax = zero
           do i = 1, n
              smax = max( smax, abs( d( i ) ) )
           end do
           do i = 1, n - 1
              smax = max( smax, abs( e( i ) ) )
           end do
           sminl = zero
           if( tol>=zero ) then
              ! relative accuracy desired
              sminoa = abs( d( 1 ) )
              if( sminoa==zero )go to 50
              mu = sminoa
              do i = 2, n
                 mu = abs( d( i ) )*( mu / ( mu+abs( e( i-1 ) ) ) )
                 sminoa = min( sminoa, mu )
                 if( sminoa==zero )go to 50
              end do
              50 continue
              sminoa = sminoa / sqrt( real( n,KIND=${rk}$) )
              thresh = max( tol*sminoa, maxitr*(n*(n*unfl)) )
           else
              ! absolute accuracy desired
              thresh = max( abs( tol )*smax, maxitr*(n*(n*unfl)) )
           end if
           ! prepare for main iteration loop for the singular values
           ! (maxit is the maximum number of passes through the inner
           ! loop permitted before nonconvergence signalled.)
           maxitdivn = maxitr*n
           iterdivn = 0
           iter = -1
           oldll = -1
           oldm = -1
           ! m points to last element of unconverged part of matrix
           m = n
           ! begin main iteration loop
           60 continue
           ! check for convergence or exceeding iteration count
           if( m<=1 )go to 160
           if( iter>=n ) then
              iter = iter - n
              iterdivn = iterdivn + 1
              if( iterdivn>=maxitdivn )go to 200
           end if
           ! find diagonal block of matrix to work on
           if( tol<zero .and. abs( d( m ) )<=thresh )d( m ) = zero
           smax = abs( d( m ) )
           smin = smax
           do lll = 1, m - 1
              ll = m - lll
              abss = abs( d( ll ) )
              abse = abs( e( ll ) )
              if( tol<zero .and. abss<=thresh )d( ll ) = zero
              if( abse<=thresh )go to 80
              smin = min( smin, abss )
              smax = max( smax, abss, abse )
           end do
           ll = 0
           go to 90
           80 continue
           e( ll ) = zero
           ! matrix splits since e(ll) = 0
           if( ll==m-1 ) then
              ! convergence of bottom singular value, return to top of loop
              m = m - 1
              go to 60
           end if
           90 continue
           ll = ll + 1
           ! e(ll) through e(m-1) are nonzero, e(ll-1) is zero
           if( ll==m-1 ) then
              ! 2 by 2 block, handle separately
              call stdlib_${ri}$lasv2( d( m-1 ), e( m-1 ), d( m ), sigmn, sigmx, sinr,cosr, sinl, cosl &
                        )
              d( m-1 ) = sigmx
              e( m-1 ) = zero
              d( m ) = sigmn
              ! compute singular vectors, if desired
              if( ncvt>0 )call stdlib_${ri}$rot( ncvt, vt( m-1, 1 ), ldvt, vt( m, 1 ), ldvt, cosr,sinr &
                        )
              if( nru>0 )call stdlib_${ri}$rot( nru, u( 1, m-1 ), 1, u( 1, m ), 1, cosl, sinl )
              if( ncc>0 )call stdlib_${ri}$rot( ncc, c( m-1, 1 ), ldc, c( m, 1 ), ldc, cosl,sinl )
                        
              m = m - 2
              go to 60
           end if
           ! if working on new submatrix, choose shift direction
           ! (from larger end diagonal element towards smaller)
           if( ll>oldm .or. m<oldll ) then
              if( abs( d( ll ) )>=abs( d( m ) ) ) then
                 ! chase bulge from top (big end) to bottom (small end)
                 idir = 1
              else
                 ! chase bulge from bottom (big end) to top (small end)
                 idir = 2
              end if
           end if
           ! apply convergence tests
           if( idir==1 ) then
              ! run convergence test in forward direction
              ! first apply standard test to bottom of matrix
              if( abs( e( m-1 ) )<=abs( tol )*abs( d( m ) ) .or.( tol<zero .and. abs( e( m-1 ) )&
                        <=thresh ) ) then
                 e( m-1 ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion forward
                 mu = abs( d( ll ) )
                 sminl = mu
                 do lll = ll, m - 1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll+1 ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           else
              ! run convergence test in backward direction
              ! first apply standard test to top of matrix
              if( abs( e( ll ) )<=abs( tol )*abs( d( ll ) ) .or.( tol<zero .and. abs( e( ll ) )&
                        <=thresh ) ) then
                 e( ll ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion backward
                 mu = abs( d( m ) )
                 sminl = mu
                 do lll = m - 1, ll, -1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           end if
           oldll = ll
           oldm = m
           ! compute shift.  first, test if shifting would ruin relative
           ! accuracy, and if so set the shift to zero.
           if( tol>=zero .and. n*tol*( sminl / smax )<=max( eps, hndrth*tol ) ) then
              ! use a zero shift to avoid loss of relative accuracy
              shift = zero
           else
              ! compute the shift from 2-by-2 block at end of matrix
              if( idir==1 ) then
                 sll = abs( d( ll ) )
                 call stdlib_${ri}$las2( d( m-1 ), e( m-1 ), d( m ), shift, r )
              else
                 sll = abs( d( m ) )
                 call stdlib_${ri}$las2( d( ll ), e( ll ), d( ll+1 ), shift, r )
              end if
              ! test if shift negligible, and if so set to zero
              if( sll>zero ) then
                 if( ( shift / sll )**2<eps )shift = zero
              end if
           end if
           ! increment iteration count
           iter = iter + m - ll
           ! if shift = 0, do simplified qr iteration
           if( shift==zero ) then
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = ll, m - 1
                    call stdlib_${ri}$lartg( d( i )*cs, e( i ), cs, sn, r )
                    if( i>ll )e( i-1 ) = oldsn*r
                    call stdlib_${ri}$lartg( oldcs*r, d( i+1 )*sn, oldcs, oldsn, d( i ) )
                    work( i-ll+1 ) = cs
                    work( i-ll+1+nm1 ) = sn
                    work( i-ll+1+nm12 ) = oldcs
                    work( i-ll+1+nm13 ) = oldsn
                 end do
                 h = d( m )*cs
                 d( m ) = h*oldcs
                 e( m-1 ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_${ri}$lasr( 'L', 'V', 'F', m-ll+1, ncvt, work( 1 ),work( n ), &
                           vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ri}$lasr( 'R', 'V', 'F', nru, m-ll+1, work( nm12+1 ),work( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ri}$lasr( 'L', 'V', 'F', m-ll+1, ncc, work( nm12+1 ),work( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = m, ll + 1, -1
                    call stdlib_${ri}$lartg( d( i )*cs, e( i-1 ), cs, sn, r )
                    if( i<m )e( i ) = oldsn*r
                    call stdlib_${ri}$lartg( oldcs*r, d( i-1 )*sn, oldcs, oldsn, d( i ) )
                    work( i-ll ) = cs
                    work( i-ll+nm1 ) = -sn
                    work( i-ll+nm12 ) = oldcs
                    work( i-ll+nm13 ) = -oldsn
                 end do
                 h = d( ll )*cs
                 d( ll ) = h*oldcs
                 e( ll ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_${ri}$lasr( 'L', 'V', 'B', m-ll+1, ncvt, work( nm12+1 ),work( &
                           nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ri}$lasr( 'R', 'V', 'B', nru, m-ll+1, work( 1 ),work( n ), u(&
                            1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ri}$lasr( 'L', 'V', 'B', m-ll+1, ncc, work( 1 ),work( n ), c(&
                            ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
              end if
           else
              ! use nonzero shift
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( ll ) )-shift )*( sign( one, d( ll ) )+shift / d( ll ) )
                 g = e( ll )
                 do i = ll, m - 1
                    call stdlib_${ri}$lartg( f, g, cosr, sinr, r )
                    if( i>ll )e( i-1 ) = r
                    f = cosr*d( i ) + sinr*e( i )
                    e( i ) = cosr*e( i ) - sinr*d( i )
                    g = sinr*d( i+1 )
                    d( i+1 ) = cosr*d( i+1 )
                    call stdlib_${ri}$lartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i ) + sinl*d( i+1 )
                    d( i+1 ) = cosl*d( i+1 ) - sinl*e( i )
                    if( i<m-1 ) then
                       g = sinl*e( i+1 )
                       e( i+1 ) = cosl*e( i+1 )
                    end if
                    work( i-ll+1 ) = cosr
                    work( i-ll+1+nm1 ) = sinr
                    work( i-ll+1+nm12 ) = cosl
                    work( i-ll+1+nm13 ) = sinl
                 end do
                 e( m-1 ) = f
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_${ri}$lasr( 'L', 'V', 'F', m-ll+1, ncvt, work( 1 ),work( n ), &
                           vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ri}$lasr( 'R', 'V', 'F', nru, m-ll+1, work( nm12+1 ),work( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ri}$lasr( 'L', 'V', 'F', m-ll+1, ncc, work( nm12+1 ),work( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( m ) )-shift )*( sign( one, d( m ) )+shift /d( m ) )
                 g = e( m-1 )
                 do i = m, ll + 1, -1
                    call stdlib_${ri}$lartg( f, g, cosr, sinr, r )
                    if( i<m )e( i ) = r
                    f = cosr*d( i ) + sinr*e( i-1 )
                    e( i-1 ) = cosr*e( i-1 ) - sinr*d( i )
                    g = sinr*d( i-1 )
                    d( i-1 ) = cosr*d( i-1 )
                    call stdlib_${ri}$lartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i-1 ) + sinl*d( i-1 )
                    d( i-1 ) = cosl*d( i-1 ) - sinl*e( i-1 )
                    if( i>ll+1 ) then
                       g = sinl*e( i-2 )
                       e( i-2 ) = cosl*e( i-2 )
                    end if
                    work( i-ll ) = cosr
                    work( i-ll+nm1 ) = -sinr
                    work( i-ll+nm12 ) = cosl
                    work( i-ll+nm13 ) = -sinl
                 end do
                 e( ll ) = f
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
                 ! update singular vectors if desired
                 if( ncvt>0 )call stdlib_${ri}$lasr( 'L', 'V', 'B', m-ll+1, ncvt, work( nm12+1 ),work( &
                           nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ri}$lasr( 'R', 'V', 'B', nru, m-ll+1, work( 1 ),work( n ), u(&
                            1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ri}$lasr( 'L', 'V', 'B', m-ll+1, ncc, work( 1 ),work( n ), c(&
                            ll, 1 ), ldc )
              end if
           end if
           ! qr iteration finished, go back and check convergence
           go to 60
           ! all singular values converged, so make them positive
           160 continue
           do i = 1, n
              if( d( i )<zero ) then
                 d( i ) = -d( i )
                 ! change sign of singular vectors, if desired
                 if( ncvt>0 )call stdlib_${ri}$scal( ncvt, negone, vt( i, 1 ), ldvt )
              end if
           end do
           ! sort the singular values into decreasing order (insertion sort on
           ! singular values, but only one transposition per singular vector)
           do i = 1, n - 1
              ! scan for smallest d(i)
              isub = 1
              smin = d( 1 )
              do j = 2, n + 1 - i
                 if( d( j )<=smin ) then
                    isub = j
                    smin = d( j )
                 end if
              end do
              if( isub/=n+1-i ) then
                 ! swap singular values and vectors
                 d( isub ) = d( n+1-i )
                 d( n+1-i ) = smin
                 if( ncvt>0 )call stdlib_${ri}$swap( ncvt, vt( isub, 1 ), ldvt, vt( n+1-i, 1 ),ldvt )
                           
                 if( nru>0 )call stdlib_${ri}$swap( nru, u( 1, isub ), 1, u( 1, n+1-i ), 1 )
                 if( ncc>0 )call stdlib_${ri}$swap( ncc, c( isub, 1 ), ldc, c( n+1-i, 1 ), ldc )
                           
              end if
           end do
           go to 220
           ! maximum number of iterations exceeded, failure to converge
           200 continue
           info = 0
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           220 continue
           return
     end subroutine stdlib_${ri}$bdsqr

#:endif
#:endfor

     module pure subroutine stdlib_cbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, rwork,&
     !! CBDSQR computes the singular values and, optionally, the right and/or
     !! left singular vectors from the singular value decomposition (SVD) of
     !! a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
     !! zero-shift QR algorithm.  The SVD of B has the form
     !! B = Q * S * P**H
     !! where S is the diagonal matrix of singular values, Q is an orthogonal
     !! matrix of left singular vectors, and P is an orthogonal matrix of
     !! right singular vectors.  If left singular vectors are requested, this
     !! subroutine actually returns U*Q instead of Q, and, if right singular
     !! vectors are requested, this subroutine returns P**H*VT instead of
     !! P**H, for given complex input matrices U and VT.  When U and VT are
     !! the unitary matrices that reduce a general matrix A to bidiagonal
     !! form: A = U*B*VT, as computed by CGEBRD, then
     !! A = (U*Q) * S * (P**H*VT)
     !! is the SVD of A.  Optionally, the subroutine may also compute Q**H*C
     !! for a given complex input matrix C.
     !! See "Computing  Small Singular Values of Bidiagonal Matrices With
     !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
     !! LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
     !! no. 5, pp. 873-912, Sept 1990) and
     !! "Accurate singular values and differential qd algorithms," by
     !! B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
     !! Department, University of California at Berkeley, July 1992
     !! for a detailed description of the algorithm.
                info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           ! Array Arguments 
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(inout) :: c(ldc,*), u(ldu,*), vt(ldvt,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: hndrth = 0.01_sp
           real(sp), parameter :: hndrd = 100.0_sp
           real(sp), parameter :: meigth = -0.125_sp
           integer(ilp), parameter :: maxitr = 6
           
           
           
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: lower, rotate
           integer(ilp) :: i, idir, isub, iter, j, ll, lll, m, maxit, nm1, nm12, nm13, oldll, &
                     oldm
           real(sp) :: abse, abss, cosl, cosr, cs, eps, f, g, h, mu, oldcs, oldsn, r, shift, &
           sigmn, sigmx, sinl, sinr, sll, smax, smin, sminl, sminoa, sn, thresh, tol, tolmul, &
                     unfl
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.lower ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ncvt<0 ) then
              info = -3
           else if( nru<0 ) then
              info = -4
           else if( ncc<0 ) then
              info = -5
           else if( ( ncvt==0 .and. ldvt<1 ) .or.( ncvt>0 .and. ldvt<max( 1, n ) ) ) then
              info = -9
           else if( ldu<max( 1, nru ) ) then
              info = -11
           else if( ( ncc==0 .and. ldc<1 ) .or.( ncc>0 .and. ldc<max( 1, n ) ) ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CBDSQR', -info )
              return
           end if
           if( n==0 )return
           if( n==1 )go to 160
           ! rotate is true if any singular vectors desired, false otherwise
           rotate = ( ncvt>0 ) .or. ( nru>0 ) .or. ( ncc>0 )
           ! if no singular vectors desired, use qd algorithm
           if( .not.rotate ) then
              call stdlib_slasq1( n, d, e, rwork, info )
           ! if info equals 2, dqds didn't finish, try to finish
              if( info /= 2 ) return
              info = 0
           end if
           nm1 = n - 1
           nm12 = nm1 + nm1
           nm13 = nm12 + nm1
           idir = 0
           ! get machine constants
           eps = stdlib_slamch( 'EPSILON' )
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           if( lower ) then
              do i = 1, n - 1
                 call stdlib_slartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 rwork( i ) = cs
                 rwork( nm1+i ) = sn
              end do
              ! update singular vectors if desired
              if( nru>0 )call stdlib_clasr( 'R', 'V', 'F', nru, n, rwork( 1 ), rwork( n ),u, ldu )
                        
              if( ncc>0 )call stdlib_clasr( 'L', 'V', 'F', n, ncc, rwork( 1 ), rwork( n ),c, ldc )
                        
           end if
           ! compute singular values to relative accuracy tol
           ! (by setting tol to be negative, algorithm will compute
           ! singular values to absolute accuracy abs(tol)*norm(input matrix))
           tolmul = max( ten, min( hndrd, eps**meigth ) )
           tol = tolmul*eps
           ! compute approximate maximum, minimum singular values
           smax = zero
           do i = 1, n
              smax = max( smax, abs( d( i ) ) )
           end do
           do i = 1, n - 1
              smax = max( smax, abs( e( i ) ) )
           end do
           sminl = zero
           if( tol>=zero ) then
              ! relative accuracy desired
              sminoa = abs( d( 1 ) )
              if( sminoa==zero )go to 50
              mu = sminoa
              do i = 2, n
                 mu = abs( d( i ) )*( mu / ( mu+abs( e( i-1 ) ) ) )
                 sminoa = min( sminoa, mu )
                 if( sminoa==zero )go to 50
              end do
              50 continue
              sminoa = sminoa / sqrt( real( n,KIND=sp) )
              thresh = max( tol*sminoa, maxitr*n*n*unfl )
           else
              ! absolute accuracy desired
              thresh = max( abs( tol )*smax, maxitr*n*n*unfl )
           end if
           ! prepare for main iteration loop for the singular values
           ! (maxit is the maximum number of passes through the inner
           ! loop permitted before nonconvergence signalled.)
           maxit = maxitr*n*n
           iter = 0
           oldll = -1
           oldm = -1
           ! m points to last element of unconverged part of matrix
           m = n
           ! begin main iteration loop
           60 continue
           ! check for convergence or exceeding iteration count
           if( m<=1 )go to 160
           if( iter>maxit )go to 200
           ! find diagonal block of matrix to work on
           if( tol<zero .and. abs( d( m ) )<=thresh )d( m ) = zero
           smax = abs( d( m ) )
           smin = smax
           do lll = 1, m - 1
              ll = m - lll
              abss = abs( d( ll ) )
              abse = abs( e( ll ) )
              if( tol<zero .and. abss<=thresh )d( ll ) = zero
              if( abse<=thresh )go to 80
              smin = min( smin, abss )
              smax = max( smax, abss, abse )
           end do
           ll = 0
           go to 90
           80 continue
           e( ll ) = zero
           ! matrix splits since e(ll) = 0
           if( ll==m-1 ) then
              ! convergence of bottom singular value, return to top of loop
              m = m - 1
              go to 60
           end if
           90 continue
           ll = ll + 1
           ! e(ll) through e(m-1) are nonzero, e(ll-1) is zero
           if( ll==m-1 ) then
              ! 2 by 2 block, handle separately
              call stdlib_slasv2( d( m-1 ), e( m-1 ), d( m ), sigmn, sigmx, sinr,cosr, sinl, cosl &
                        )
              d( m-1 ) = sigmx
              e( m-1 ) = zero
              d( m ) = sigmn
              ! compute singular vectors, if desired
              if( ncvt>0 )call stdlib_csrot( ncvt, vt( m-1, 1 ), ldvt, vt( m, 1 ), ldvt,cosr, &
                        sinr )
              if( nru>0 )call stdlib_csrot( nru, u( 1, m-1 ), 1, u( 1, m ), 1, cosl, sinl )
                        
              if( ncc>0 )call stdlib_csrot( ncc, c( m-1, 1 ), ldc, c( m, 1 ), ldc, cosl,sinl )
                        
              m = m - 2
              go to 60
           end if
           ! if working on new submatrix, choose shift direction
           ! (from larger end diagonal element towards smaller)
           if( ll>oldm .or. m<oldll ) then
              if( abs( d( ll ) )>=abs( d( m ) ) ) then
                 ! chase bulge from top (big end) to bottom (small end)
                 idir = 1
              else
                 ! chase bulge from bottom (big end) to top (small end)
                 idir = 2
              end if
           end if
           ! apply convergence tests
           if( idir==1 ) then
              ! run convergence test in forward direction
              ! first apply standard test to bottom of matrix
              if( abs( e( m-1 ) )<=abs( tol )*abs( d( m ) ) .or.( tol<zero .and. abs( e( m-1 ) )&
                        <=thresh ) ) then
                 e( m-1 ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion forward
                 mu = abs( d( ll ) )
                 sminl = mu
                 do lll = ll, m - 1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll+1 ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           else
              ! run convergence test in backward direction
              ! first apply standard test to top of matrix
              if( abs( e( ll ) )<=abs( tol )*abs( d( ll ) ) .or.( tol<zero .and. abs( e( ll ) )&
                        <=thresh ) ) then
                 e( ll ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion backward
                 mu = abs( d( m ) )
                 sminl = mu
                 do lll = m - 1, ll, -1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           end if
           oldll = ll
           oldm = m
           ! compute shift.  first, test if shifting would ruin relative
           ! accuracy, and if so set the shift to zero.
           if( tol>=zero .and. n*tol*( sminl / smax )<=max( eps, hndrth*tol ) ) then
              ! use a zero shift to avoid loss of relative accuracy
              shift = zero
           else
              ! compute the shift from 2-by-2 block at end of matrix
              if( idir==1 ) then
                 sll = abs( d( ll ) )
                 call stdlib_slas2( d( m-1 ), e( m-1 ), d( m ), shift, r )
              else
                 sll = abs( d( m ) )
                 call stdlib_slas2( d( ll ), e( ll ), d( ll+1 ), shift, r )
              end if
              ! test if shift negligible, and if so set to zero
              if( sll>zero ) then
                 if( ( shift / sll )**2<eps )shift = zero
              end if
           end if
           ! increment iteration count
           iter = iter + m - ll
           ! if shift = 0, do simplified qr iteration
           if( shift==zero ) then
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = ll, m - 1
                    call stdlib_slartg( d( i )*cs, e( i ), cs, sn, r )
                    if( i>ll )e( i-1 ) = oldsn*r
                    call stdlib_slartg( oldcs*r, d( i+1 )*sn, oldcs, oldsn, d( i ) )
                    rwork( i-ll+1 ) = cs
                    rwork( i-ll+1+nm1 ) = sn
                    rwork( i-ll+1+nm12 ) = oldcs
                    rwork( i-ll+1+nm13 ) = oldsn
                 end do
                 h = d( m )*cs
                 d( m ) = h*oldcs
                 e( m-1 ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_clasr( 'L', 'V', 'F', m-ll+1, ncvt, rwork( 1 ),rwork( n )&
                           , vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_clasr( 'R', 'V', 'F', nru, m-ll+1, rwork( nm12+1 ),rwork( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_clasr( 'L', 'V', 'F', m-ll+1, ncc, rwork( nm12+1 ),rwork( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = m, ll + 1, -1
                    call stdlib_slartg( d( i )*cs, e( i-1 ), cs, sn, r )
                    if( i<m )e( i ) = oldsn*r
                    call stdlib_slartg( oldcs*r, d( i-1 )*sn, oldcs, oldsn, d( i ) )
                    rwork( i-ll ) = cs
                    rwork( i-ll+nm1 ) = -sn
                    rwork( i-ll+nm12 ) = oldcs
                    rwork( i-ll+nm13 ) = -oldsn
                 end do
                 h = d( ll )*cs
                 d( ll ) = h*oldcs
                 e( ll ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_clasr( 'L', 'V', 'B', m-ll+1, ncvt, rwork( nm12+1 ),&
                           rwork( nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_clasr( 'R', 'V', 'B', nru, m-ll+1, rwork( 1 ),rwork( n ), &
                           u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_clasr( 'L', 'V', 'B', m-ll+1, ncc, rwork( 1 ),rwork( n ), &
                           c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
              end if
           else
              ! use nonzero shift
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( ll ) )-shift )*( sign( one, d( ll ) )+shift / d( ll ) )
                 g = e( ll )
                 do i = ll, m - 1
                    call stdlib_slartg( f, g, cosr, sinr, r )
                    if( i>ll )e( i-1 ) = r
                    f = cosr*d( i ) + sinr*e( i )
                    e( i ) = cosr*e( i ) - sinr*d( i )
                    g = sinr*d( i+1 )
                    d( i+1 ) = cosr*d( i+1 )
                    call stdlib_slartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i ) + sinl*d( i+1 )
                    d( i+1 ) = cosl*d( i+1 ) - sinl*e( i )
                    if( i<m-1 ) then
                       g = sinl*e( i+1 )
                       e( i+1 ) = cosl*e( i+1 )
                    end if
                    rwork( i-ll+1 ) = cosr
                    rwork( i-ll+1+nm1 ) = sinr
                    rwork( i-ll+1+nm12 ) = cosl
                    rwork( i-ll+1+nm13 ) = sinl
                 end do
                 e( m-1 ) = f
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_clasr( 'L', 'V', 'F', m-ll+1, ncvt, rwork( 1 ),rwork( n )&
                           , vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_clasr( 'R', 'V', 'F', nru, m-ll+1, rwork( nm12+1 ),rwork( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_clasr( 'L', 'V', 'F', m-ll+1, ncc, rwork( nm12+1 ),rwork( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( m ) )-shift )*( sign( one, d( m ) )+shift /d( m ) )
                 g = e( m-1 )
                 do i = m, ll + 1, -1
                    call stdlib_slartg( f, g, cosr, sinr, r )
                    if( i<m )e( i ) = r
                    f = cosr*d( i ) + sinr*e( i-1 )
                    e( i-1 ) = cosr*e( i-1 ) - sinr*d( i )
                    g = sinr*d( i-1 )
                    d( i-1 ) = cosr*d( i-1 )
                    call stdlib_slartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i-1 ) + sinl*d( i-1 )
                    d( i-1 ) = cosl*d( i-1 ) - sinl*e( i-1 )
                    if( i>ll+1 ) then
                       g = sinl*e( i-2 )
                       e( i-2 ) = cosl*e( i-2 )
                    end if
                    rwork( i-ll ) = cosr
                    rwork( i-ll+nm1 ) = -sinr
                    rwork( i-ll+nm12 ) = cosl
                    rwork( i-ll+nm13 ) = -sinl
                 end do
                 e( ll ) = f
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
                 ! update singular vectors if desired
                 if( ncvt>0 )call stdlib_clasr( 'L', 'V', 'B', m-ll+1, ncvt, rwork( nm12+1 ),&
                           rwork( nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_clasr( 'R', 'V', 'B', nru, m-ll+1, rwork( 1 ),rwork( n ), &
                           u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_clasr( 'L', 'V', 'B', m-ll+1, ncc, rwork( 1 ),rwork( n ), &
                           c( ll, 1 ), ldc )
              end if
           end if
           ! qr iteration finished, go back and check convergence
           go to 60
           ! all singular values converged, so make them positive
           160 continue
           do i = 1, n
              if( d( i )<zero ) then
                 d( i ) = -d( i )
                 ! change sign of singular vectors, if desired
                 if( ncvt>0 )call stdlib_csscal( ncvt, negone, vt( i, 1 ), ldvt )
              end if
           end do
           ! sort the singular values into decreasing order (insertion sort on
           ! singular values, but only one transposition per singular vector)
           do i = 1, n - 1
              ! scan for smallest d(i)
              isub = 1
              smin = d( 1 )
              do j = 2, n + 1 - i
                 if( d( j )<=smin ) then
                    isub = j
                    smin = d( j )
                 end if
              end do
              if( isub/=n+1-i ) then
                 ! swap singular values and vectors
                 d( isub ) = d( n+1-i )
                 d( n+1-i ) = smin
                 if( ncvt>0 )call stdlib_cswap( ncvt, vt( isub, 1 ), ldvt, vt( n+1-i, 1 ),ldvt )
                           
                 if( nru>0 )call stdlib_cswap( nru, u( 1, isub ), 1, u( 1, n+1-i ), 1 )
                 if( ncc>0 )call stdlib_cswap( ncc, c( isub, 1 ), ldc, c( n+1-i, 1 ), ldc )
                           
              end if
           end do
           go to 220
           ! maximum number of iterations exceeded, failure to converge
           200 continue
           info = 0
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           220 continue
           return
     end subroutine stdlib_cbdsqr

     module pure subroutine stdlib_zbdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, rwork,&
     !! ZBDSQR computes the singular values and, optionally, the right and/or
     !! left singular vectors from the singular value decomposition (SVD) of
     !! a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
     !! zero-shift QR algorithm.  The SVD of B has the form
     !! B = Q * S * P**H
     !! where S is the diagonal matrix of singular values, Q is an orthogonal
     !! matrix of left singular vectors, and P is an orthogonal matrix of
     !! right singular vectors.  If left singular vectors are requested, this
     !! subroutine actually returns U*Q instead of Q, and, if right singular
     !! vectors are requested, this subroutine returns P**H*VT instead of
     !! P**H, for given complex input matrices U and VT.  When U and VT are
     !! the unitary matrices that reduce a general matrix A to bidiagonal
     !! form: A = U*B*VT, as computed by ZGEBRD, then
     !! A = (U*Q) * S * (P**H*VT)
     !! is the SVD of A.  Optionally, the subroutine may also compute Q**H*C
     !! for a given complex input matrix C.
     !! See "Computing  Small Singular Values of Bidiagonal Matrices With
     !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
     !! LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
     !! no. 5, pp. 873-912, Sept 1990) and
     !! "Accurate singular values and differential qd algorithms," by
     !! B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
     !! Department, University of California at Berkeley, July 1992
     !! for a detailed description of the algorithm.
                info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           ! Array Arguments 
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(inout) :: c(ldc,*), u(ldu,*), vt(ldvt,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: hndrth = 0.01_dp
           real(dp), parameter :: hndrd = 100.0_dp
           real(dp), parameter :: meigth = -0.125_dp
           integer(ilp), parameter :: maxitr = 6
           
           
           
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: lower, rotate
           integer(ilp) :: i, idir, isub, iter, j, ll, lll, m, maxit, nm1, nm12, nm13, oldll, &
                     oldm
           real(dp) :: abse, abss, cosl, cosr, cs, eps, f, g, h, mu, oldcs, oldsn, r, shift, &
           sigmn, sigmx, sinl, sinr, sll, smax, smin, sminl, sminoa, sn, thresh, tol, tolmul, &
                     unfl
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.lower ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ncvt<0 ) then
              info = -3
           else if( nru<0 ) then
              info = -4
           else if( ncc<0 ) then
              info = -5
           else if( ( ncvt==0 .and. ldvt<1 ) .or.( ncvt>0 .and. ldvt<max( 1, n ) ) ) then
              info = -9
           else if( ldu<max( 1, nru ) ) then
              info = -11
           else if( ( ncc==0 .and. ldc<1 ) .or.( ncc>0 .and. ldc<max( 1, n ) ) ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZBDSQR', -info )
              return
           end if
           if( n==0 )return
           if( n==1 )go to 160
           ! rotate is true if any singular vectors desired, false otherwise
           rotate = ( ncvt>0 ) .or. ( nru>0 ) .or. ( ncc>0 )
           ! if no singular vectors desired, use qd algorithm
           if( .not.rotate ) then
              call stdlib_dlasq1( n, d, e, rwork, info )
           ! if info equals 2, dqds didn't finish, try to finish
              if( info /= 2 ) return
              info = 0
           end if
           nm1 = n - 1
           nm12 = nm1 + nm1
           nm13 = nm12 + nm1
           idir = 0
           ! get machine constants
           eps = stdlib_dlamch( 'EPSILON' )
           unfl = stdlib_dlamch( 'SAFE MINIMUM' )
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           if( lower ) then
              do i = 1, n - 1
                 call stdlib_dlartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 rwork( i ) = cs
                 rwork( nm1+i ) = sn
              end do
              ! update singular vectors if desired
              if( nru>0 )call stdlib_zlasr( 'R', 'V', 'F', nru, n, rwork( 1 ), rwork( n ),u, ldu )
                        
              if( ncc>0 )call stdlib_zlasr( 'L', 'V', 'F', n, ncc, rwork( 1 ), rwork( n ),c, ldc )
                        
           end if
           ! compute singular values to relative accuracy tol
           ! (by setting tol to be negative, algorithm will compute
           ! singular values to absolute accuracy abs(tol)*norm(input matrix))
           tolmul = max( ten, min( hndrd, eps**meigth ) )
           tol = tolmul*eps
           ! compute approximate maximum, minimum singular values
           smax = zero
           do i = 1, n
              smax = max( smax, abs( d( i ) ) )
           end do
           do i = 1, n - 1
              smax = max( smax, abs( e( i ) ) )
           end do
           sminl = zero
           if( tol>=zero ) then
              ! relative accuracy desired
              sminoa = abs( d( 1 ) )
              if( sminoa==zero )go to 50
              mu = sminoa
              do i = 2, n
                 mu = abs( d( i ) )*( mu / ( mu+abs( e( i-1 ) ) ) )
                 sminoa = min( sminoa, mu )
                 if( sminoa==zero )go to 50
              end do
              50 continue
              sminoa = sminoa / sqrt( real( n,KIND=dp) )
              thresh = max( tol*sminoa, maxitr*n*n*unfl )
           else
              ! absolute accuracy desired
              thresh = max( abs( tol )*smax, maxitr*n*n*unfl )
           end if
           ! prepare for main iteration loop for the singular values
           ! (maxit is the maximum number of passes through the inner
           ! loop permitted before nonconvergence signalled.)
           maxit = maxitr*n*n
           iter = 0
           oldll = -1
           oldm = -1
           ! m points to last element of unconverged part of matrix
           m = n
           ! begin main iteration loop
           60 continue
           ! check for convergence or exceeding iteration count
           if( m<=1 )go to 160
           if( iter>maxit )go to 200
           ! find diagonal block of matrix to work on
           if( tol<zero .and. abs( d( m ) )<=thresh )d( m ) = zero
           smax = abs( d( m ) )
           smin = smax
           do lll = 1, m - 1
              ll = m - lll
              abss = abs( d( ll ) )
              abse = abs( e( ll ) )
              if( tol<zero .and. abss<=thresh )d( ll ) = zero
              if( abse<=thresh )go to 80
              smin = min( smin, abss )
              smax = max( smax, abss, abse )
           end do
           ll = 0
           go to 90
           80 continue
           e( ll ) = zero
           ! matrix splits since e(ll) = 0
           if( ll==m-1 ) then
              ! convergence of bottom singular value, return to top of loop
              m = m - 1
              go to 60
           end if
           90 continue
           ll = ll + 1
           ! e(ll) through e(m-1) are nonzero, e(ll-1) is zero
           if( ll==m-1 ) then
              ! 2 by 2 block, handle separately
              call stdlib_dlasv2( d( m-1 ), e( m-1 ), d( m ), sigmn, sigmx, sinr,cosr, sinl, cosl &
                        )
              d( m-1 ) = sigmx
              e( m-1 ) = zero
              d( m ) = sigmn
              ! compute singular vectors, if desired
              if( ncvt>0 )call stdlib_zdrot( ncvt, vt( m-1, 1 ), ldvt, vt( m, 1 ), ldvt,cosr, &
                        sinr )
              if( nru>0 )call stdlib_zdrot( nru, u( 1, m-1 ), 1, u( 1, m ), 1, cosl, sinl )
                        
              if( ncc>0 )call stdlib_zdrot( ncc, c( m-1, 1 ), ldc, c( m, 1 ), ldc, cosl,sinl )
                        
              m = m - 2
              go to 60
           end if
           ! if working on new submatrix, choose shift direction
           ! (from larger end diagonal element towards smaller)
           if( ll>oldm .or. m<oldll ) then
              if( abs( d( ll ) )>=abs( d( m ) ) ) then
                 ! chase bulge from top (big end) to bottom (small end)
                 idir = 1
              else
                 ! chase bulge from bottom (big end) to top (small end)
                 idir = 2
              end if
           end if
           ! apply convergence tests
           if( idir==1 ) then
              ! run convergence test in forward direction
              ! first apply standard test to bottom of matrix
              if( abs( e( m-1 ) )<=abs( tol )*abs( d( m ) ) .or.( tol<zero .and. abs( e( m-1 ) )&
                        <=thresh ) ) then
                 e( m-1 ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion forward
                 mu = abs( d( ll ) )
                 sminl = mu
                 do lll = ll, m - 1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll+1 ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           else
              ! run convergence test in backward direction
              ! first apply standard test to top of matrix
              if( abs( e( ll ) )<=abs( tol )*abs( d( ll ) ) .or.( tol<zero .and. abs( e( ll ) )&
                        <=thresh ) ) then
                 e( ll ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion backward
                 mu = abs( d( m ) )
                 sminl = mu
                 do lll = m - 1, ll, -1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           end if
           oldll = ll
           oldm = m
           ! compute shift.  first, test if shifting would ruin relative
           ! accuracy, and if so set the shift to zero.
           if( tol>=zero .and. n*tol*( sminl / smax )<=max( eps, hndrth*tol ) ) then
              ! use a zero shift to avoid loss of relative accuracy
              shift = zero
           else
              ! compute the shift from 2-by-2 block at end of matrix
              if( idir==1 ) then
                 sll = abs( d( ll ) )
                 call stdlib_dlas2( d( m-1 ), e( m-1 ), d( m ), shift, r )
              else
                 sll = abs( d( m ) )
                 call stdlib_dlas2( d( ll ), e( ll ), d( ll+1 ), shift, r )
              end if
              ! test if shift negligible, and if so set to zero
              if( sll>zero ) then
                 if( ( shift / sll )**2<eps )shift = zero
              end if
           end if
           ! increment iteration count
           iter = iter + m - ll
           ! if shift = 0, do simplified qr iteration
           if( shift==zero ) then
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = ll, m - 1
                    call stdlib_dlartg( d( i )*cs, e( i ), cs, sn, r )
                    if( i>ll )e( i-1 ) = oldsn*r
                    call stdlib_dlartg( oldcs*r, d( i+1 )*sn, oldcs, oldsn, d( i ) )
                    rwork( i-ll+1 ) = cs
                    rwork( i-ll+1+nm1 ) = sn
                    rwork( i-ll+1+nm12 ) = oldcs
                    rwork( i-ll+1+nm13 ) = oldsn
                 end do
                 h = d( m )*cs
                 d( m ) = h*oldcs
                 e( m-1 ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_zlasr( 'L', 'V', 'F', m-ll+1, ncvt, rwork( 1 ),rwork( n )&
                           , vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_zlasr( 'R', 'V', 'F', nru, m-ll+1, rwork( nm12+1 ),rwork( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_zlasr( 'L', 'V', 'F', m-ll+1, ncc, rwork( nm12+1 ),rwork( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = m, ll + 1, -1
                    call stdlib_dlartg( d( i )*cs, e( i-1 ), cs, sn, r )
                    if( i<m )e( i ) = oldsn*r
                    call stdlib_dlartg( oldcs*r, d( i-1 )*sn, oldcs, oldsn, d( i ) )
                    rwork( i-ll ) = cs
                    rwork( i-ll+nm1 ) = -sn
                    rwork( i-ll+nm12 ) = oldcs
                    rwork( i-ll+nm13 ) = -oldsn
                 end do
                 h = d( ll )*cs
                 d( ll ) = h*oldcs
                 e( ll ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_zlasr( 'L', 'V', 'B', m-ll+1, ncvt, rwork( nm12+1 ),&
                           rwork( nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_zlasr( 'R', 'V', 'B', nru, m-ll+1, rwork( 1 ),rwork( n ), &
                           u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_zlasr( 'L', 'V', 'B', m-ll+1, ncc, rwork( 1 ),rwork( n ), &
                           c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
              end if
           else
              ! use nonzero shift
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( ll ) )-shift )*( sign( one, d( ll ) )+shift / d( ll ) )
                 g = e( ll )
                 do i = ll, m - 1
                    call stdlib_dlartg( f, g, cosr, sinr, r )
                    if( i>ll )e( i-1 ) = r
                    f = cosr*d( i ) + sinr*e( i )
                    e( i ) = cosr*e( i ) - sinr*d( i )
                    g = sinr*d( i+1 )
                    d( i+1 ) = cosr*d( i+1 )
                    call stdlib_dlartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i ) + sinl*d( i+1 )
                    d( i+1 ) = cosl*d( i+1 ) - sinl*e( i )
                    if( i<m-1 ) then
                       g = sinl*e( i+1 )
                       e( i+1 ) = cosl*e( i+1 )
                    end if
                    rwork( i-ll+1 ) = cosr
                    rwork( i-ll+1+nm1 ) = sinr
                    rwork( i-ll+1+nm12 ) = cosl
                    rwork( i-ll+1+nm13 ) = sinl
                 end do
                 e( m-1 ) = f
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_zlasr( 'L', 'V', 'F', m-ll+1, ncvt, rwork( 1 ),rwork( n )&
                           , vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_zlasr( 'R', 'V', 'F', nru, m-ll+1, rwork( nm12+1 ),rwork( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_zlasr( 'L', 'V', 'F', m-ll+1, ncc, rwork( nm12+1 ),rwork( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( m ) )-shift )*( sign( one, d( m ) )+shift /d( m ) )
                 g = e( m-1 )
                 do i = m, ll + 1, -1
                    call stdlib_dlartg( f, g, cosr, sinr, r )
                    if( i<m )e( i ) = r
                    f = cosr*d( i ) + sinr*e( i-1 )
                    e( i-1 ) = cosr*e( i-1 ) - sinr*d( i )
                    g = sinr*d( i-1 )
                    d( i-1 ) = cosr*d( i-1 )
                    call stdlib_dlartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i-1 ) + sinl*d( i-1 )
                    d( i-1 ) = cosl*d( i-1 ) - sinl*e( i-1 )
                    if( i>ll+1 ) then
                       g = sinl*e( i-2 )
                       e( i-2 ) = cosl*e( i-2 )
                    end if
                    rwork( i-ll ) = cosr
                    rwork( i-ll+nm1 ) = -sinr
                    rwork( i-ll+nm12 ) = cosl
                    rwork( i-ll+nm13 ) = -sinl
                 end do
                 e( ll ) = f
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
                 ! update singular vectors if desired
                 if( ncvt>0 )call stdlib_zlasr( 'L', 'V', 'B', m-ll+1, ncvt, rwork( nm12+1 ),&
                           rwork( nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_zlasr( 'R', 'V', 'B', nru, m-ll+1, rwork( 1 ),rwork( n ), &
                           u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_zlasr( 'L', 'V', 'B', m-ll+1, ncc, rwork( 1 ),rwork( n ), &
                           c( ll, 1 ), ldc )
              end if
           end if
           ! qr iteration finished, go back and check convergence
           go to 60
           ! all singular values converged, so make them positive
           160 continue
           do i = 1, n
              if( d( i )<zero ) then
                 d( i ) = -d( i )
                 ! change sign of singular vectors, if desired
                 if( ncvt>0 )call stdlib_zdscal( ncvt, negone, vt( i, 1 ), ldvt )
              end if
           end do
           ! sort the singular values into decreasing order (insertion sort on
           ! singular values, but only one transposition per singular vector)
           do i = 1, n - 1
              ! scan for smallest d(i)
              isub = 1
              smin = d( 1 )
              do j = 2, n + 1 - i
                 if( d( j )<=smin ) then
                    isub = j
                    smin = d( j )
                 end if
              end do
              if( isub/=n+1-i ) then
                 ! swap singular values and vectors
                 d( isub ) = d( n+1-i )
                 d( n+1-i ) = smin
                 if( ncvt>0 )call stdlib_zswap( ncvt, vt( isub, 1 ), ldvt, vt( n+1-i, 1 ),ldvt )
                           
                 if( nru>0 )call stdlib_zswap( nru, u( 1, isub ), 1, u( 1, n+1-i ), 1 )
                 if( ncc>0 )call stdlib_zswap( ncc, c( isub, 1 ), ldc, c( n+1-i, 1 ), ldc )
                           
              end if
           end do
           go to 220
           ! maximum number of iterations exceeded, failure to converge
           200 continue
           info = 0
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           220 continue
           return
     end subroutine stdlib_zbdsqr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$bdsqr( uplo, n, ncvt, nru, ncc, d, e, vt, ldvt, u,ldu, c, ldc, rwork,&
     !! ZBDSQR: computes the singular values and, optionally, the right and/or
     !! left singular vectors from the singular value decomposition (SVD) of
     !! a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
     !! zero-shift QR algorithm.  The SVD of B has the form
     !! B = Q * S * P**H
     !! where S is the diagonal matrix of singular values, Q is an orthogonal
     !! matrix of left singular vectors, and P is an orthogonal matrix of
     !! right singular vectors.  If left singular vectors are requested, this
     !! subroutine actually returns U*Q instead of Q, and, if right singular
     !! vectors are requested, this subroutine returns P**H*VT instead of
     !! P**H, for given complex input matrices U and VT.  When U and VT are
     !! the unitary matrices that reduce a general matrix A to bidiagonal
     !! form: A = U*B*VT, as computed by ZGEBRD, then
     !! A = (U*Q) * S * (P**H*VT)
     !! is the SVD of A.  Optionally, the subroutine may also compute Q**H*C
     !! for a given complex input matrix C.
     !! See "Computing  Small Singular Values of Bidiagonal Matrices With
     !! Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
     !! LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
     !! no. 5, pp. 873-912, Sept 1990) and
     !! "Accurate singular values and differential qd algorithms," by
     !! B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
     !! Department, University of California at Berkeley, July 1992
     !! for a detailed description of the algorithm.
                info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldc, ldu, ldvt, n, ncc, ncvt, nru
           ! Array Arguments 
           real(${ck}$), intent(inout) :: d(*), e(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(inout) :: c(ldc,*), u(ldu,*), vt(ldvt,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: hndrth = 0.01_${ck}$
           real(${ck}$), parameter :: hndrd = 100.0_${ck}$
           real(${ck}$), parameter :: meigth = -0.125_${ck}$
           integer(ilp), parameter :: maxitr = 6
           
           
           
           
           
           
           
           
           ! Local Scalars 
           logical(lk) :: lower, rotate
           integer(ilp) :: i, idir, isub, iter, j, ll, lll, m, maxit, nm1, nm12, nm13, oldll, &
                     oldm
           real(${ck}$) :: abse, abss, cosl, cosr, cs, eps, f, g, h, mu, oldcs, oldsn, r, shift, &
           sigmn, sigmx, sinl, sinr, sll, smax, smin, sminl, sminoa, sn, thresh, tol, tolmul, &
                     unfl
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lower = stdlib_lsame( uplo, 'L' )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.lower ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( ncvt<0 ) then
              info = -3
           else if( nru<0 ) then
              info = -4
           else if( ncc<0 ) then
              info = -5
           else if( ( ncvt==0 .and. ldvt<1 ) .or.( ncvt>0 .and. ldvt<max( 1, n ) ) ) then
              info = -9
           else if( ldu<max( 1, nru ) ) then
              info = -11
           else if( ( ncc==0 .and. ldc<1 ) .or.( ncc>0 .and. ldc<max( 1, n ) ) ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZBDSQR', -info )
              return
           end if
           if( n==0 )return
           if( n==1 )go to 160
           ! rotate is true if any singular vectors desired, false otherwise
           rotate = ( ncvt>0 ) .or. ( nru>0 ) .or. ( ncc>0 )
           ! if no singular vectors desired, use qd algorithm
           if( .not.rotate ) then
              call stdlib_${c2ri(ci)}$lasq1( n, d, e, rwork, info )
           ! if info equals 2, dqds didn't finish, try to finish
              if( info /= 2 ) return
              info = 0
           end if
           nm1 = n - 1
           nm12 = nm1 + nm1
           nm13 = nm12 + nm1
           idir = 0
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'EPSILON' )
           unfl = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           if( lower ) then
              do i = 1, n - 1
                 call stdlib_${c2ri(ci)}$lartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 rwork( i ) = cs
                 rwork( nm1+i ) = sn
              end do
              ! update singular vectors if desired
              if( nru>0 )call stdlib_${ci}$lasr( 'R', 'V', 'F', nru, n, rwork( 1 ), rwork( n ),u, ldu )
                        
              if( ncc>0 )call stdlib_${ci}$lasr( 'L', 'V', 'F', n, ncc, rwork( 1 ), rwork( n ),c, ldc )
                        
           end if
           ! compute singular values to relative accuracy tol
           ! (by setting tol to be negative, algorithm will compute
           ! singular values to absolute accuracy abs(tol)*norm(input matrix))
           tolmul = max( ten, min( hndrd, eps**meigth ) )
           tol = tolmul*eps
           ! compute approximate maximum, minimum singular values
           smax = zero
           do i = 1, n
              smax = max( smax, abs( d( i ) ) )
           end do
           do i = 1, n - 1
              smax = max( smax, abs( e( i ) ) )
           end do
           sminl = zero
           if( tol>=zero ) then
              ! relative accuracy desired
              sminoa = abs( d( 1 ) )
              if( sminoa==zero )go to 50
              mu = sminoa
              do i = 2, n
                 mu = abs( d( i ) )*( mu / ( mu+abs( e( i-1 ) ) ) )
                 sminoa = min( sminoa, mu )
                 if( sminoa==zero )go to 50
              end do
              50 continue
              sminoa = sminoa / sqrt( real( n,KIND=${ck}$) )
              thresh = max( tol*sminoa, maxitr*n*n*unfl )
           else
              ! absolute accuracy desired
              thresh = max( abs( tol )*smax, maxitr*n*n*unfl )
           end if
           ! prepare for main iteration loop for the singular values
           ! (maxit is the maximum number of passes through the inner
           ! loop permitted before nonconvergence signalled.)
           maxit = maxitr*n*n
           iter = 0
           oldll = -1
           oldm = -1
           ! m points to last element of unconverged part of matrix
           m = n
           ! begin main iteration loop
           60 continue
           ! check for convergence or exceeding iteration count
           if( m<=1 )go to 160
           if( iter>maxit )go to 200
           ! find diagonal block of matrix to work on
           if( tol<zero .and. abs( d( m ) )<=thresh )d( m ) = zero
           smax = abs( d( m ) )
           smin = smax
           do lll = 1, m - 1
              ll = m - lll
              abss = abs( d( ll ) )
              abse = abs( e( ll ) )
              if( tol<zero .and. abss<=thresh )d( ll ) = zero
              if( abse<=thresh )go to 80
              smin = min( smin, abss )
              smax = max( smax, abss, abse )
           end do
           ll = 0
           go to 90
           80 continue
           e( ll ) = zero
           ! matrix splits since e(ll) = 0
           if( ll==m-1 ) then
              ! convergence of bottom singular value, return to top of loop
              m = m - 1
              go to 60
           end if
           90 continue
           ll = ll + 1
           ! e(ll) through e(m-1) are nonzero, e(ll-1) is zero
           if( ll==m-1 ) then
              ! 2 by 2 block, handle separately
              call stdlib_${c2ri(ci)}$lasv2( d( m-1 ), e( m-1 ), d( m ), sigmn, sigmx, sinr,cosr, sinl, cosl &
                        )
              d( m-1 ) = sigmx
              e( m-1 ) = zero
              d( m ) = sigmn
              ! compute singular vectors, if desired
              if( ncvt>0 )call stdlib_${ci}$drot( ncvt, vt( m-1, 1 ), ldvt, vt( m, 1 ), ldvt,cosr, &
                        sinr )
              if( nru>0 )call stdlib_${ci}$drot( nru, u( 1, m-1 ), 1, u( 1, m ), 1, cosl, sinl )
                        
              if( ncc>0 )call stdlib_${ci}$drot( ncc, c( m-1, 1 ), ldc, c( m, 1 ), ldc, cosl,sinl )
                        
              m = m - 2
              go to 60
           end if
           ! if working on new submatrix, choose shift direction
           ! (from larger end diagonal element towards smaller)
           if( ll>oldm .or. m<oldll ) then
              if( abs( d( ll ) )>=abs( d( m ) ) ) then
                 ! chase bulge from top (big end) to bottom (small end)
                 idir = 1
              else
                 ! chase bulge from bottom (big end) to top (small end)
                 idir = 2
              end if
           end if
           ! apply convergence tests
           if( idir==1 ) then
              ! run convergence test in forward direction
              ! first apply standard test to bottom of matrix
              if( abs( e( m-1 ) )<=abs( tol )*abs( d( m ) ) .or.( tol<zero .and. abs( e( m-1 ) )&
                        <=thresh ) ) then
                 e( m-1 ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion forward
                 mu = abs( d( ll ) )
                 sminl = mu
                 do lll = ll, m - 1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll+1 ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           else
              ! run convergence test in backward direction
              ! first apply standard test to top of matrix
              if( abs( e( ll ) )<=abs( tol )*abs( d( ll ) ) .or.( tol<zero .and. abs( e( ll ) )&
                        <=thresh ) ) then
                 e( ll ) = zero
                 go to 60
              end if
              if( tol>=zero ) then
                 ! if relative accuracy desired,
                 ! apply convergence criterion backward
                 mu = abs( d( m ) )
                 sminl = mu
                 do lll = m - 1, ll, -1
                    if( abs( e( lll ) )<=tol*mu ) then
                       e( lll ) = zero
                       go to 60
                    end if
                    mu = abs( d( lll ) )*( mu / ( mu+abs( e( lll ) ) ) )
                    sminl = min( sminl, mu )
                 end do
              end if
           end if
           oldll = ll
           oldm = m
           ! compute shift.  first, test if shifting would ruin relative
           ! accuracy, and if so set the shift to zero.
           if( tol>=zero .and. n*tol*( sminl / smax )<=max( eps, hndrth*tol ) ) then
              ! use a zero shift to avoid loss of relative accuracy
              shift = zero
           else
              ! compute the shift from 2-by-2 block at end of matrix
              if( idir==1 ) then
                 sll = abs( d( ll ) )
                 call stdlib_${c2ri(ci)}$las2( d( m-1 ), e( m-1 ), d( m ), shift, r )
              else
                 sll = abs( d( m ) )
                 call stdlib_${c2ri(ci)}$las2( d( ll ), e( ll ), d( ll+1 ), shift, r )
              end if
              ! test if shift negligible, and if so set to zero
              if( sll>zero ) then
                 if( ( shift / sll )**2<eps )shift = zero
              end if
           end if
           ! increment iteration count
           iter = iter + m - ll
           ! if shift = 0, do simplified qr iteration
           if( shift==zero ) then
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = ll, m - 1
                    call stdlib_${c2ri(ci)}$lartg( d( i )*cs, e( i ), cs, sn, r )
                    if( i>ll )e( i-1 ) = oldsn*r
                    call stdlib_${c2ri(ci)}$lartg( oldcs*r, d( i+1 )*sn, oldcs, oldsn, d( i ) )
                    rwork( i-ll+1 ) = cs
                    rwork( i-ll+1+nm1 ) = sn
                    rwork( i-ll+1+nm12 ) = oldcs
                    rwork( i-ll+1+nm13 ) = oldsn
                 end do
                 h = d( m )*cs
                 d( m ) = h*oldcs
                 e( m-1 ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_${ci}$lasr( 'L', 'V', 'F', m-ll+1, ncvt, rwork( 1 ),rwork( n )&
                           , vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ci}$lasr( 'R', 'V', 'F', nru, m-ll+1, rwork( nm12+1 ),rwork( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ci}$lasr( 'L', 'V', 'F', m-ll+1, ncc, rwork( nm12+1 ),rwork( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 cs = one
                 oldcs = one
                 do i = m, ll + 1, -1
                    call stdlib_${c2ri(ci)}$lartg( d( i )*cs, e( i-1 ), cs, sn, r )
                    if( i<m )e( i ) = oldsn*r
                    call stdlib_${c2ri(ci)}$lartg( oldcs*r, d( i-1 )*sn, oldcs, oldsn, d( i ) )
                    rwork( i-ll ) = cs
                    rwork( i-ll+nm1 ) = -sn
                    rwork( i-ll+nm12 ) = oldcs
                    rwork( i-ll+nm13 ) = -oldsn
                 end do
                 h = d( ll )*cs
                 d( ll ) = h*oldcs
                 e( ll ) = h*oldsn
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_${ci}$lasr( 'L', 'V', 'B', m-ll+1, ncvt, rwork( nm12+1 ),&
                           rwork( nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ci}$lasr( 'R', 'V', 'B', nru, m-ll+1, rwork( 1 ),rwork( n ), &
                           u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ci}$lasr( 'L', 'V', 'B', m-ll+1, ncc, rwork( 1 ),rwork( n ), &
                           c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
              end if
           else
              ! use nonzero shift
              if( idir==1 ) then
                 ! chase bulge from top to bottom
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( ll ) )-shift )*( sign( one, d( ll ) )+shift / d( ll ) )
                 g = e( ll )
                 do i = ll, m - 1
                    call stdlib_${c2ri(ci)}$lartg( f, g, cosr, sinr, r )
                    if( i>ll )e( i-1 ) = r
                    f = cosr*d( i ) + sinr*e( i )
                    e( i ) = cosr*e( i ) - sinr*d( i )
                    g = sinr*d( i+1 )
                    d( i+1 ) = cosr*d( i+1 )
                    call stdlib_${c2ri(ci)}$lartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i ) + sinl*d( i+1 )
                    d( i+1 ) = cosl*d( i+1 ) - sinl*e( i )
                    if( i<m-1 ) then
                       g = sinl*e( i+1 )
                       e( i+1 ) = cosl*e( i+1 )
                    end if
                    rwork( i-ll+1 ) = cosr
                    rwork( i-ll+1+nm1 ) = sinr
                    rwork( i-ll+1+nm12 ) = cosl
                    rwork( i-ll+1+nm13 ) = sinl
                 end do
                 e( m-1 ) = f
                 ! update singular vectors
                 if( ncvt>0 )call stdlib_${ci}$lasr( 'L', 'V', 'F', m-ll+1, ncvt, rwork( 1 ),rwork( n )&
                           , vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ci}$lasr( 'R', 'V', 'F', nru, m-ll+1, rwork( nm12+1 ),rwork( &
                           nm13+1 ), u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ci}$lasr( 'L', 'V', 'F', m-ll+1, ncc, rwork( nm12+1 ),rwork( &
                           nm13+1 ), c( ll, 1 ), ldc )
                 ! test convergence
                 if( abs( e( m-1 ) )<=thresh )e( m-1 ) = zero
              else
                 ! chase bulge from bottom to top
                 ! save cosines and sines for later singular vector updates
                 f = ( abs( d( m ) )-shift )*( sign( one, d( m ) )+shift /d( m ) )
                 g = e( m-1 )
                 do i = m, ll + 1, -1
                    call stdlib_${c2ri(ci)}$lartg( f, g, cosr, sinr, r )
                    if( i<m )e( i ) = r
                    f = cosr*d( i ) + sinr*e( i-1 )
                    e( i-1 ) = cosr*e( i-1 ) - sinr*d( i )
                    g = sinr*d( i-1 )
                    d( i-1 ) = cosr*d( i-1 )
                    call stdlib_${c2ri(ci)}$lartg( f, g, cosl, sinl, r )
                    d( i ) = r
                    f = cosl*e( i-1 ) + sinl*d( i-1 )
                    d( i-1 ) = cosl*d( i-1 ) - sinl*e( i-1 )
                    if( i>ll+1 ) then
                       g = sinl*e( i-2 )
                       e( i-2 ) = cosl*e( i-2 )
                    end if
                    rwork( i-ll ) = cosr
                    rwork( i-ll+nm1 ) = -sinr
                    rwork( i-ll+nm12 ) = cosl
                    rwork( i-ll+nm13 ) = -sinl
                 end do
                 e( ll ) = f
                 ! test convergence
                 if( abs( e( ll ) )<=thresh )e( ll ) = zero
                 ! update singular vectors if desired
                 if( ncvt>0 )call stdlib_${ci}$lasr( 'L', 'V', 'B', m-ll+1, ncvt, rwork( nm12+1 ),&
                           rwork( nm13+1 ), vt( ll, 1 ), ldvt )
                 if( nru>0 )call stdlib_${ci}$lasr( 'R', 'V', 'B', nru, m-ll+1, rwork( 1 ),rwork( n ), &
                           u( 1, ll ), ldu )
                 if( ncc>0 )call stdlib_${ci}$lasr( 'L', 'V', 'B', m-ll+1, ncc, rwork( 1 ),rwork( n ), &
                           c( ll, 1 ), ldc )
              end if
           end if
           ! qr iteration finished, go back and check convergence
           go to 60
           ! all singular values converged, so make them positive
           160 continue
           do i = 1, n
              if( d( i )<zero ) then
                 d( i ) = -d( i )
                 ! change sign of singular vectors, if desired
                 if( ncvt>0 )call stdlib_${ci}$dscal( ncvt, negone, vt( i, 1 ), ldvt )
              end if
           end do
           ! sort the singular values into decreasing order (insertion sort on
           ! singular values, but only one transposition per singular vector)
           do i = 1, n - 1
              ! scan for smallest d(i)
              isub = 1
              smin = d( 1 )
              do j = 2, n + 1 - i
                 if( d( j )<=smin ) then
                    isub = j
                    smin = d( j )
                 end if
              end do
              if( isub/=n+1-i ) then
                 ! swap singular values and vectors
                 d( isub ) = d( n+1-i )
                 d( n+1-i ) = smin
                 if( ncvt>0 )call stdlib_${ci}$swap( ncvt, vt( isub, 1 ), ldvt, vt( n+1-i, 1 ),ldvt )
                           
                 if( nru>0 )call stdlib_${ci}$swap( nru, u( 1, isub ), 1, u( 1, n+1-i ), 1 )
                 if( ncc>0 )call stdlib_${ci}$swap( ncc, c( isub, 1 ), ldc, c( n+1-i, 1 ), ldc )
                           
              end if
           end do
           go to 220
           ! maximum number of iterations exceeded, failure to converge
           200 continue
           info = 0
           do i = 1, n - 1
              if( e( i )/=zero )info = info + 1
           end do
           220 continue
           return
     end subroutine stdlib_${ci}$bdsqr

#:endif
#:endfor



     module pure subroutine stdlib_sgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, work, lwork, &
     !! SGESVJ computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^t,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N orthogonal matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
     !! SGESVJ can sometimes compute tiny singular values and their singular vectors much
     !! more accurately than other SVD routines, see below under Further Details.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldv, lwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), v(ldv,*), work(lwork)
           real(sp), intent(out) :: sva(n)
        ! =====================================================================
           ! Local Parameters 
           integer(ilp), parameter :: nsweep = 30
           
           
           ! Local Scalars 
           real(sp) :: aapp, aapp0, aapq, aaqq, apoaq, aqoap, big, bigtheta, cs, ctol, epsln, &
           large, mxaapq, mxsinj, rootbig, rooteps, rootsfmin, roottol, skl, sfmin, small, sn, t, &
                     temp1, theta, thsign, tol
           integer(ilp) :: blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1, iswrot, jbc, jgl, kbl, &
                     lkahead, mvl, n2, n34, n4, nbl, notrot, p, pskipped, q, rowskip, swband
           logical(lk) :: applv, goscale, lower, lsvec, noscale, rotok, rsvec, uctol, &
                     upper
           ! Local Arrays 
           real(sp) :: fastr(5)
           ! Intrinsic Functions 
           ! from lapack
           ! from lapack
           ! Executable Statements 
           ! test the input arguments
           lsvec = stdlib_lsame( jobu, 'U' )
           uctol = stdlib_lsame( jobu, 'C' )
           rsvec = stdlib_lsame( jobv, 'V' )
           applv = stdlib_lsame( jobv, 'A' )
           upper = stdlib_lsame( joba, 'U' )
           lower = stdlib_lsame( joba, 'L' )
           if( .not.( upper .or. lower .or. stdlib_lsame( joba, 'G' ) ) ) then
              info = -1
           else if( .not.( lsvec .or. uctol .or. stdlib_lsame( jobu, 'N' ) ) ) then
              info = -2
           else if( .not.( rsvec .or. applv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( ( n<0 ) .or. ( n>m ) ) then
              info = -5
           else if( lda<m ) then
              info = -7
           else if( mv<0 ) then
              info = -9
           else if( ( rsvec .and. ( ldv<n ) ) .or.( applv .and. ( ldv<mv ) ) ) then
              info = -11
           else if( uctol .and. ( work( 1 )<=one ) ) then
              info = -12
           else if( lwork<max( m+n, 6 ) ) then
              info = -13
           else
              info = 0
           end if
           ! #:(
           if( info/=0 ) then
              call stdlib_xerbla( 'SGESVJ', -info )
              return
           end if
       ! #:) quick return for void matrix
           if( ( m==0 ) .or. ( n==0 ) )return
           ! set numerical parameters
           ! the stopping criterion for jacobi rotations is
           ! max_{i<>j}|a(:,i)^t * a(:,j)|/(||a(:,i)||*||a(:,j)||) < ctol*eps
           ! where eps is the round-off and ctol is defined as follows:
           if( uctol ) then
              ! ... user controlled
              ctol = work( 1 )
           else
              ! ... default
              if( lsvec .or. rsvec .or. applv ) then
                 ctol = sqrt( real( m,KIND=sp) )
              else
                 ctol = real( m,KIND=sp)
              end if
           end if
           ! ... and the machine dependent parameters are
      ! [!]  (make sure that stdlib_slamch() works properly on the target machine.)
           epsln = stdlib_slamch( 'EPSILON' )
           rooteps = sqrt( epsln )
           sfmin = stdlib_slamch( 'SAFEMINIMUM' )
           rootsfmin = sqrt( sfmin )
           small = sfmin / epsln
           big = stdlib_slamch( 'OVERFLOW' )
           ! big         = one    / sfmin
           rootbig = one / rootsfmin
           large = big / sqrt( real( m*n,KIND=sp) )
           bigtheta = one / rooteps
           tol = ctol*epsln
           roottol = sqrt( tol )
           if( real( m,KIND=sp)*epsln>=one ) then
              info = -4
              call stdlib_xerbla( 'SGESVJ', -info )
              return
           end if
           ! initialize the right singular vector matrix.
           if( rsvec ) then
              mvl = n
              call stdlib_slaset( 'A', mvl, n, zero, one, v, ldv )
           else if( applv ) then
              mvl = mv
           end if
           rsvec = rsvec .or. applv
           ! initialize sva( 1:n ) = ( ||a e_i||_2, i = 1:n )
      ! (!)  if necessary, scale a to protect the largest singular value
           ! from overflow. it is possible that saving the largest singular
           ! value destroys the information about the small ones.
           ! this initial scaling is almost minimal in the sense that the
           ! goal is to make sure that no column norm overflows, and that
           ! sqrt(n)*max_i sva(i) does not overflow. if infinite entries
           ! in a are detected, the procedure returns with info=-6.
           skl = one / sqrt( real( m,KIND=sp)*real( n,KIND=sp) )
           noscale = .true.
           goscale = .true.
           if( lower ) then
              ! the input matrix is m-by-n lower triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_slassq( m-p+1, a( p, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'SGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else if( upper ) then
              ! the input matrix is m-by-n upper triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_slassq( p, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'SGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else
              ! the input matrix is m-by-n general dense
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_slassq( m, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'SGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           end if
           if( noscale )skl = one
           ! move the smaller part of the spectrum from the underflow threshold
      ! (!)  start by determining the position of the nonzero entries of the
           ! array sva() relative to ( sfmin, big ).
           aapp = zero
           aaqq = big
           do p = 1, n
              if( sva( p )/=zero )aaqq = min( aaqq, sva( p ) )
              aapp = max( aapp, sva( p ) )
           end do
       ! #:) quick return for zero matrix
           if( aapp==zero ) then
              if( lsvec )call stdlib_slaset( 'G', m, n, zero, one, a, lda )
              work( 1 ) = one
              work( 2 ) = zero
              work( 3 ) = zero
              work( 4 ) = zero
              work( 5 ) = zero
              work( 6 ) = zero
              return
           end if
       ! #:) quick return for one-column matrix
           if( n==1 ) then
              if( lsvec )call stdlib_slascl( 'G', 0, 0, sva( 1 ), skl, m, 1,a( 1, 1 ), lda, ierr )
                        
              work( 1 ) = one / skl
              if( sva( 1 )>=sfmin ) then
                 work( 2 ) = one
              else
                 work( 2 ) = zero
              end if
              work( 3 ) = zero
              work( 4 ) = zero
              work( 5 ) = zero
              work( 6 ) = zero
              return
           end if
           ! protect small singular values from underflow, and try to
           ! avoid underflows/overflows in computing jacobi rotations.
           sn = sqrt( sfmin / epsln )
           temp1 = sqrt( big / real( n,KIND=sp) )
           if( ( aapp<=sn ) .or. ( aaqq>=temp1 ) .or.( ( sn<=aaqq ) .and. ( aapp<=temp1 ) ) ) &
                     then
              temp1 = min( big, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp<=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( aapp*sqrt( real( n,KIND=sp) ) ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq>=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = max( sn / aaqq, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( sqrt( real( n,KIND=sp) )*aapp ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else
              temp1 = one
           end if
           ! scale, if necessary
           if( temp1/=one ) then
              call stdlib_slascl( 'G', 0, 0, one, temp1, n, 1, sva, n, ierr )
           end if
           skl = temp1*skl
           if( skl/=one ) then
              call stdlib_slascl( joba, 0, 0, one, skl, m, n, a, lda, ierr )
              skl = one / skl
           end if
           ! row-cyclic jacobi svd algorithm with column pivoting
           emptsw = ( n*( n-1 ) ) / 2
           notrot = 0
           fastr( 1 ) = zero
           ! a is represented in factored form a = a * diag(work), where diag(work)
           ! is initialized to identity. work is updated during fast scaled
           ! rotations.
           do q = 1, n
              work( q ) = one
           end do
           swband = 3
      ! [tp] swband is a tuning parameter [tp]. it is meaningful and effective
           ! if stdlib_sgesvj is used as a computational routine in the preconditioned
           ! jacobi svd algorithm stdlib_sgesvj. for sweeps i=1:swband the procedure
           ! works on pivots inside a band-like region around the diagonal.
           ! the boundaries are determined dynamically, based on the number of
           ! pivots above a threshold.
           kbl = min( 8, n )
      ! [tp] kbl is a tuning parameter that defines the tile size in the
           ! tiling of the p-q loops of pivot pairs. in general, an optimal
           ! value of kbl depends on the matrix dimensions and on the
           ! parameters of the computer's memory.
           nbl = n / kbl
           if( ( nbl*kbl )/=n )nbl = nbl + 1
           blskip = kbl**2
      ! [tp] blkskip is a tuning parameter that depends on swband and kbl.
           rowskip = min( 5, kbl )
      ! [tp] rowskip is a tuning parameter.
           lkahead = 1
      ! [tp] lkahead is a tuning parameter.
           ! quasi block transformations, using the lower (upper) triangular
           ! structure of the input matrix. the quasi-block-cycling usually
           ! invokes cubic convergence. big part of this cycle is done inside
           ! canonical subspaces of dimensions less than m.
           if( ( lower .or. upper ) .and. ( n>max( 64, 4*kbl ) ) ) then
      ! [tp] the number of partition levels and the actual partition are
           ! tuning parameters.
              n4 = n / 4
              n2 = n / 2
              n34 = 3*n4
              if( applv ) then
                 q = 0
              else
                 q = 1
              end if
              if( lower ) then
           ! this works very well on lower triangular matrices, in particular
           ! in the framework of the preconditioned jacobi svd (xgejsv).
           ! the idea is simple:
           ! [+ 0 0 0]   note that jacobi transformations of [0 0]
           ! [+ + 0 0]                                       [0 0]
           ! [+ + x 0]   actually work on [x 0]              [x 0]
           ! [+ + x x]                    [x x].             [x x]
                 call stdlib_sgsvj0( jobv, m-n34, n-n34, a( n34+1, n34+1 ), lda,work( n34+1 ), &
                 sva( n34+1 ), mvl,v( n34*q+1, n34+1 ), ldv, epsln, sfmin, tol,2, work( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_sgsvj0( jobv, m-n2, n34-n2, a( n2+1, n2+1 ), lda,work( n2+1 ), sva( &
                 n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 2,work( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_sgsvj1( jobv, m-n2, n-n2, n4, a( n2+1, n2+1 ), lda,work( n2+1 ), sva(&
                  n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, &
                            ierr )
                 call stdlib_sgsvj0( jobv, m-n4, n2-n4, a( n4+1, n4+1 ), lda,work( n4+1 ), sva( &
                 n4+1 ), mvl,v( n4*q+1, n4+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_sgsvj0( jobv, m, n4, a, lda, work, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 1, work( n+1 ), lwork-n,ierr )
                 call stdlib_sgsvj1( jobv, m, n2, n4, a, lda, work, sva, mvl, v,ldv, epsln, sfmin,&
                            tol, 1, work( n+1 ),lwork-n, ierr )
              else if( upper ) then
                 call stdlib_sgsvj0( jobv, n4, n4, a, lda, work, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 2, work( n+1 ), lwork-n,ierr )
                 call stdlib_sgsvj0( jobv, n2, n4, a( 1, n4+1 ), lda, work( n4+1 ),sva( n4+1 ), &
                 mvl, v( n4*q+1, n4+1 ), ldv,epsln, sfmin, tol, 1, work( n+1 ), lwork-n,ierr )
                           
                 call stdlib_sgsvj1( jobv, n2, n2, n4, a, lda, work, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, work( n+1 ),lwork-n, ierr )
                 call stdlib_sgsvj0( jobv, n2+n4, n4, a( 1, n2+1 ), lda,work( n2+1 ), sva( n2+1 ),&
                  mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, ierr )
                            
              end if
           end if
           ! .. row-cyclic pivot strategy with de rijk's pivoting ..
           loop_1993: do i = 1, nsweep
           ! .. go go go ...
              mxaapq = zero
              mxsinj = zero
              iswrot = 0
              notrot = 0
              pskipped = 0
           ! each sweep is unrolled using kbl-by-kbl tiles over the pivot pairs
           ! 1 <= p < q <= n. this is the first step toward a blocked implementation
           ! of the rotations. new implementation, based on block transformations,
           ! is under development.
              loop_2000: do ibr = 1, nbl
                 igl = ( ibr-1 )*kbl + 1
                 loop_1002: do ir1 = 0, min( lkahead, nbl-ibr )
                    igl = igl + ir1*kbl
                    loop_2001: do p = igl, min( igl+kbl-1, n-1 )
           ! .. de rijk's pivoting
                       q = stdlib_isamax( n-p+1, sva( p ), 1 ) + p - 1
                       if( p/=q ) then
                          call stdlib_sswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                          if( rsvec )call stdlib_sswap( mvl, v( 1, p ), 1,v( 1, q ), 1 )
                          temp1 = sva( p )
                          sva( p ) = sva( q )
                          sva( q ) = temp1
                          temp1 = work( p )
                          work( p ) = work( q )
                          work( q ) = temp1
                       end if
                       if( ir1==0 ) then
              ! column norms are periodically updated by explicit
              ! norm computation.
              ! caveat:
              ! unfortunately, some blas implementations compute stdlib_snrm2(m,a(1,p),1)
              ! as sqrt(stdlib_sdot(m,a(1,p),1,a(1,p),1)), which may cause the result to
              ! overflow for ||a(:,p)||_2 > sqrt(overflow_threshold), and to
              ! underflow for ||a(:,p)||_2 < sqrt(underflow_threshold).
              ! hence, stdlib_snrm2 cannot be trusted, not even in the case when
              ! the true norm is far from the under(over)flow boundaries.
              ! if properly implemented stdlib_snrm2 is available, the if-then-else
              ! below should read "aapp = stdlib_snrm2( m, a(1,p), 1 ) * work(p)".
                          if( ( sva( p )<rootbig ) .and.( sva( p )>rootsfmin ) ) then
                             sva( p ) = stdlib_snrm2( m, a( 1, p ), 1 )*work( p )
                          else
                             temp1 = zero
                             aapp = one
                             call stdlib_slassq( m, a( 1, p ), 1, temp1, aapp )
                             sva( p ) = temp1*sqrt( aapp )*work( p )
                          end if
                          aapp = sva( p )
                       else
                          aapp = sva( p )
                       end if
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2002: do q = p + 1, min( igl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
                                if( aaqq>=one ) then
                                   rotok = ( small*aapp )<=aaqq
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_sdot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_scopy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_slascl( 'G', 0, 0, aapp,work( p ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_sdot( m, work( n+1 ), 1,a( 1, q ), 1 )*work( &
                                                q ) / aaqq
                                   end if
                                else
                                   rotok = aapp<=( aaqq / small )
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_sdot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_scopy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                      call stdlib_slascl( 'G', 0, 0, aaqq,work( q ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_sdot( m, work( n+1 ), 1,a( 1, p ), 1 )*work( &
                                                p ) / aapp
                                   end if
                                end if
                                mxaapq = max( mxaapq, abs( aapq ) )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq )>tol ) then
                 ! Rotate
      ! [rtd]      rotated = rotated + one
                                   if( ir1==0 ) then
                                      notrot = 0
                                      pskipped = 0
                                      iswrot = iswrot + 1
                                   end if
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq ) / aapq
                                      if( abs( theta )>bigtheta ) then
                                         t = half / theta
                                         fastr( 3 ) = t*work( p ) / work( q )
                                         fastr( 4 ) = -t*work( q ) /work( p )
                                         call stdlib_srotm( m, a( 1, p ), 1,a( 1, q ), 1, fastr )
                                                   
                                         if( rsvec )call stdlib_srotm( mvl,v( 1, p ), 1,v( 1, q ),&
                                                    1,fastr )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq )
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         apoaq = work( p ) / work( q )
                                         aqoap = work( q ) / work( p )
                                         if( work( p )>=one ) then
                                            if( work( q )>=one ) then
                                               fastr( 3 ) = t*apoaq
                                               fastr( 4 ) = -t*aqoap
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q )*cs
                                               call stdlib_srotm( m, a( 1, p ), 1,a( 1, q ), 1,&
                                                         fastr )
                                               if( rsvec )call stdlib_srotm( mvl,v( 1, p ), 1, v( &
                                                         1, q ),1, fastr )
                                            else
                                               call stdlib_saxpy( m, -t*aqoap,a( 1, q ), 1,a( 1, &
                                                         p ), 1 )
                                               call stdlib_saxpy( m, cs*sn*apoaq,a( 1, p ), 1,a( &
                                                         1, q ), 1 )
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q ) / cs
                                               if( rsvec ) then
                                                  call stdlib_saxpy( mvl, -t*aqoap,v( 1, q ), 1,v(&
                                                             1, p ), 1 )
                                                  call stdlib_saxpy( mvl,cs*sn*apoaq,v( 1, p ), 1,&
                                                            v( 1, q ), 1 )
                                               end if
                                            end if
                                         else
                                            if( work( q )>=one ) then
                                               call stdlib_saxpy( m, t*apoaq,a( 1, p ), 1,a( 1, q &
                                                         ), 1 )
                                               call stdlib_saxpy( m, -cs*sn*aqoap,a( 1, q ), 1,a( &
                                                         1, p ), 1 )
                                               work( p ) = work( p ) / cs
                                               work( q ) = work( q )*cs
                                               if( rsvec ) then
                                                  call stdlib_saxpy( mvl, t*apoaq,v( 1, p ), 1,v( &
                                                            1, q ), 1 )
                                                  call stdlib_saxpy( mvl,-cs*sn*aqoap,v( 1, q ), &
                                                            1,v( 1, p ), 1 )
                                               end if
                                            else
                                               if( work( p )>=work( q ) )then
                                                  call stdlib_saxpy( m, -t*aqoap,a( 1, q ), 1,a( &
                                                            1, p ), 1 )
                                                  call stdlib_saxpy( m, cs*sn*apoaq,a( 1, p ), 1,&
                                                            a( 1, q ), 1 )
                                                  work( p ) = work( p )*cs
                                                  work( q ) = work( q ) / cs
                                                  if( rsvec ) then
                                                     call stdlib_saxpy( mvl,-t*aqoap,v( 1, q ), 1,&
                                                               v( 1, p ), 1 )
                                                     call stdlib_saxpy( mvl,cs*sn*apoaq,v( 1, p ),&
                                                                1,v( 1, q ), 1 )
                                                  end if
                                               else
                                                  call stdlib_saxpy( m, t*apoaq,a( 1, p ), 1,a( 1,&
                                                             q ), 1 )
                                                  call stdlib_saxpy( m,-cs*sn*aqoap,a( 1, q ), 1,&
                                                            a( 1, p ), 1 )
                                                  work( p ) = work( p ) / cs
                                                  work( q ) = work( q )*cs
                                                  if( rsvec ) then
                                                     call stdlib_saxpy( mvl,t*apoaq, v( 1, p ),1, &
                                                               v( 1, q ), 1 )
                                                     call stdlib_saxpy( mvl,-cs*sn*aqoap,v( 1, q )&
                                                               , 1,v( 1, p ), 1 )
                                                  end if
                                               end if
                                            end if
                                         end if
                                      end if
                                   else
                    ! .. have to use modified gram-schmidt like transformation
                                      call stdlib_scopy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_slascl( 'G', 0, 0, aapp, one, m,1, work( n+1 ), &
                                                lda,ierr )
                                      call stdlib_slascl( 'G', 0, 0, aaqq, one, m,1, a( 1, q ), &
                                                lda, ierr )
                                      temp1 = -aapq*work( p ) / work( q )
                                      call stdlib_saxpy( m, temp1, work( n+1 ), 1,a( 1, q ), 1 )
                                                
                                      call stdlib_slascl( 'G', 0, 0, one, aaqq, m,1, a( 1, q ), &
                                                lda, ierr )
                                      sva( q ) = aaqq*sqrt( max( zero,one-aapq*aapq ) )
                                      mxsinj = max( mxsinj, sfmin )
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! recompute sva(q), sva(p).
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_snrm2( m, a( 1, q ), 1 )*work( q )
                                                   
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_slassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )*work( q )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_snrm2( m, a( 1, p ), 1 )*work( p )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_slassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )*work( p )
                                      end if
                                      sva( p ) = aapp
                                   end if
                                else
              ! a(:,p) and a(:,q) already numerically orthogonal
                                   if( ir1==0 )notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                end if
                             else
              ! a(:,q) is zero column
                                if( ir1==0 )notrot = notrot + 1
                                pskipped = pskipped + 1
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                if( ir1==0 )aapp = -aapp
                                notrot = 0
                                go to 2103
                             end if
                          end do loop_2002
           ! end q-loop
           2103 continue
           ! bailed out of q-loop
                          sva( p ) = aapp
                       else
                          sva( p ) = aapp
                          if( ( ir1==0 ) .and. ( aapp==zero ) )notrot = notrot + min( igl+kbl-1, &
                                    n ) - p
                       end if
                    end do loop_2001
           ! end of the p-loop
           ! end of doing the block ( ibr, ibr )
                 end do loop_1002
           ! end of ir1-loop
       ! ... go to the off diagonal blocks
                 igl = ( ibr-1 )*kbl + 1
                 loop_2010: do jbc = ibr + 1, nbl
                    jgl = ( jbc-1 )*kbl + 1
              ! doing the block at ( ibr, jbc )
                    ijblsk = 0
                    loop_2100: do p = igl, min( igl+kbl-1, n )
                       aapp = sva( p )
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2200: do q = jgl, min( jgl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
           ! M X 2 Jacobi Svd 
              ! safe gram matrix computation
                                if( aaqq>=one ) then
                                   if( aapp>=aaqq ) then
                                      rotok = ( small*aapp )<=aaqq
                                   else
                                      rotok = ( small*aaqq )<=aapp
                                   end if
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_sdot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_scopy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_slascl( 'G', 0, 0, aapp,work( p ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_sdot( m, work( n+1 ), 1,a( 1, q ), 1 )*work( &
                                                q ) / aaqq
                                   end if
                                else
                                   if( aapp>=aaqq ) then
                                      rotok = aapp<=( aaqq / small )
                                   else
                                      rotok = aaqq<=( aapp / small )
                                   end if
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_sdot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_scopy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                      call stdlib_slascl( 'G', 0, 0, aaqq,work( q ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_sdot( m, work( n+1 ), 1,a( 1, p ), 1 )*work( &
                                                p ) / aapp
                                   end if
                                end if
                                mxaapq = max( mxaapq, abs( aapq ) )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq )>tol ) then
                                   notrot = 0
      ! [rtd]      rotated  = rotated + 1
                                   pskipped = 0
                                   iswrot = iswrot + 1
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq ) / aapq
                                      if( aaqq>aapp0 )theta = -theta
                                      if( abs( theta )>bigtheta ) then
                                         t = half / theta
                                         fastr( 3 ) = t*work( p ) / work( q )
                                         fastr( 4 ) = -t*work( q ) /work( p )
                                         call stdlib_srotm( m, a( 1, p ), 1,a( 1, q ), 1, fastr )
                                                   
                                         if( rsvec )call stdlib_srotm( mvl,v( 1, p ), 1,v( 1, q ),&
                                                    1,fastr )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq )
                                         if( aaqq>aapp0 )thsign = -thsign
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         apoaq = work( p ) / work( q )
                                         aqoap = work( q ) / work( p )
                                         if( work( p )>=one ) then
                                            if( work( q )>=one ) then
                                               fastr( 3 ) = t*apoaq
                                               fastr( 4 ) = -t*aqoap
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q )*cs
                                               call stdlib_srotm( m, a( 1, p ), 1,a( 1, q ), 1,&
                                                         fastr )
                                               if( rsvec )call stdlib_srotm( mvl,v( 1, p ), 1, v( &
                                                         1, q ),1, fastr )
                                            else
                                               call stdlib_saxpy( m, -t*aqoap,a( 1, q ), 1,a( 1, &
                                                         p ), 1 )
                                               call stdlib_saxpy( m, cs*sn*apoaq,a( 1, p ), 1,a( &
                                                         1, q ), 1 )
                                               if( rsvec ) then
                                                  call stdlib_saxpy( mvl, -t*aqoap,v( 1, q ), 1,v(&
                                                             1, p ), 1 )
                                                  call stdlib_saxpy( mvl,cs*sn*apoaq,v( 1, p ), 1,&
                                                            v( 1, q ), 1 )
                                               end if
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q ) / cs
                                            end if
                                         else
                                            if( work( q )>=one ) then
                                               call stdlib_saxpy( m, t*apoaq,a( 1, p ), 1,a( 1, q &
                                                         ), 1 )
                                               call stdlib_saxpy( m, -cs*sn*aqoap,a( 1, q ), 1,a( &
                                                         1, p ), 1 )
                                               if( rsvec ) then
                                                  call stdlib_saxpy( mvl, t*apoaq,v( 1, p ), 1,v( &
                                                            1, q ), 1 )
                                                  call stdlib_saxpy( mvl,-cs*sn*aqoap,v( 1, q ), &
                                                            1,v( 1, p ), 1 )
                                               end if
                                               work( p ) = work( p ) / cs
                                               work( q ) = work( q )*cs
                                            else
                                               if( work( p )>=work( q ) )then
                                                  call stdlib_saxpy( m, -t*aqoap,a( 1, q ), 1,a( &
                                                            1, p ), 1 )
                                                  call stdlib_saxpy( m, cs*sn*apoaq,a( 1, p ), 1,&
                                                            a( 1, q ), 1 )
                                                  work( p ) = work( p )*cs
                                                  work( q ) = work( q ) / cs
                                                  if( rsvec ) then
                                                     call stdlib_saxpy( mvl,-t*aqoap,v( 1, q ), 1,&
                                                               v( 1, p ), 1 )
                                                     call stdlib_saxpy( mvl,cs*sn*apoaq,v( 1, p ),&
                                                                1,v( 1, q ), 1 )
                                                  end if
                                               else
                                                  call stdlib_saxpy( m, t*apoaq,a( 1, p ), 1,a( 1,&
                                                             q ), 1 )
                                                  call stdlib_saxpy( m,-cs*sn*aqoap,a( 1, q ), 1,&
                                                            a( 1, p ), 1 )
                                                  work( p ) = work( p ) / cs
                                                  work( q ) = work( q )*cs
                                                  if( rsvec ) then
                                                     call stdlib_saxpy( mvl,t*apoaq, v( 1, p ),1, &
                                                               v( 1, q ), 1 )
                                                     call stdlib_saxpy( mvl,-cs*sn*aqoap,v( 1, q )&
                                                               , 1,v( 1, p ), 1 )
                                                  end if
                                               end if
                                            end if
                                         end if
                                      end if
                                   else
                                      if( aapp>aaqq ) then
                                         call stdlib_scopy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                                   
                                         call stdlib_slascl( 'G', 0, 0, aapp, one,m, 1, work( n+1 &
                                                   ), lda,ierr )
                                         call stdlib_slascl( 'G', 0, 0, aaqq, one,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         temp1 = -aapq*work( p ) / work( q )
                                         call stdlib_saxpy( m, temp1, work( n+1 ),1, a( 1, q ), 1 &
                                                   )
                                         call stdlib_slascl( 'G', 0, 0, one, aaqq,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         sva( q ) = aaqq*sqrt( max( zero,one-aapq*aapq ) )
                                         mxsinj = max( mxsinj, sfmin )
                                      else
                                         call stdlib_scopy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                                   
                                         call stdlib_slascl( 'G', 0, 0, aaqq, one,m, 1, work( n+1 &
                                                   ), lda,ierr )
                                         call stdlib_slascl( 'G', 0, 0, aapp, one,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         temp1 = -aapq*work( q ) / work( p )
                                         call stdlib_saxpy( m, temp1, work( n+1 ),1, a( 1, p ), 1 &
                                                   )
                                         call stdlib_slascl( 'G', 0, 0, one, aapp,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         sva( p ) = aapp*sqrt( max( zero,one-aapq*aapq ) )
                                         mxsinj = max( mxsinj, sfmin )
                                      end if
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q)
                 ! .. recompute sva(q)
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_snrm2( m, a( 1, q ), 1 )*work( q )
                                                   
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_slassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )*work( q )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )**2<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_snrm2( m, a( 1, p ), 1 )*work( p )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_slassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )*work( p )
                                      end if
                                      sva( p ) = aapp
                                   end if
                    ! end of ok rotation
                                else
                                   notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                   ijblsk = ijblsk + 1
                                end if
                             else
                                notrot = notrot + 1
                                pskipped = pskipped + 1
                                ijblsk = ijblsk + 1
                             end if
                             if( ( i<=swband ) .and. ( ijblsk>=blskip ) )then
                                sva( p ) = aapp
                                notrot = 0
                                go to 2011
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                aapp = -aapp
                                notrot = 0
                                go to 2203
                             end if
                          end do loop_2200
              ! end of the q-loop
              2203 continue
                          sva( p ) = aapp
                       else
                          if( aapp==zero )notrot = notrot +min( jgl+kbl-1, n ) - jgl + 1
                          if( aapp<zero )notrot = 0
                       end if
                    end do loop_2100
           ! end of the p-loop
                 end do loop_2010
           ! end of the jbc-loop
           2011 continue
      ! 2011 bailed out of the jbc-loop
                 do p = igl, min( igl+kbl-1, n )
                    sva( p ) = abs( sva( p ) )
                 end do
      ! **
              end do loop_2000
      ! 2000 :: end of the ibr-loop
           ! .. update sva(n)
              if( ( sva( n )<rootbig ) .and. ( sva( n )>rootsfmin ) )then
                 sva( n ) = stdlib_snrm2( m, a( 1, n ), 1 )*work( n )
              else
                 t = zero
                 aapp = one
                 call stdlib_slassq( m, a( 1, n ), 1, t, aapp )
                 sva( n ) = t*sqrt( aapp )*work( n )
              end if
           ! additional steering devices
              if( ( i<swband ) .and. ( ( mxaapq<=roottol ) .or.( iswrot<=n ) ) )swband = i
              if( ( i>swband+1 ) .and. ( mxaapq<sqrt( real( n,KIND=sp) )*tol ) .and. ( real( n,&
                        KIND=sp)*mxaapq*mxsinj<tol ) ) then
                 go to 1994
              end if
              if( notrot>=emptsw )go to 1994
           end do loop_1993
           ! end i=1:nsweep loop
       ! #:( reaching this point means that the procedure has not converged.
           info = nsweep - 1
           go to 1995
           1994 continue
       ! #:) reaching this point means numerical convergence after the i-th
           ! sweep.
           info = 0
       ! #:) info = 0 confirms successful iterations.
       1995 continue
           ! sort the singular values and find how many are above
           ! the underflow threshold.
           n2 = 0
           n4 = 0
           do p = 1, n - 1
              q = stdlib_isamax( n-p+1, sva( p ), 1 ) + p - 1
              if( p/=q ) then
                 temp1 = sva( p )
                 sva( p ) = sva( q )
                 sva( q ) = temp1
                 temp1 = work( p )
                 work( p ) = work( q )
                 work( q ) = temp1
                 call stdlib_sswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                 if( rsvec )call stdlib_sswap( mvl, v( 1, p ), 1, v( 1, q ), 1 )
              end if
              if( sva( p )/=zero ) then
                 n4 = n4 + 1
                 if( sva( p )*skl>sfmin )n2 = n2 + 1
              end if
           end do
           if( sva( n )/=zero ) then
              n4 = n4 + 1
              if( sva( n )*skl>sfmin )n2 = n2 + 1
           end if
           ! normalize the left singular vectors.
           if( lsvec .or. uctol ) then
              do p = 1, n2
                 call stdlib_sscal( m, work( p ) / sva( p ), a( 1, p ), 1 )
              end do
           end if
           ! scale the product of jacobi rotations (assemble the fast rotations).
           if( rsvec ) then
              if( applv ) then
                 do p = 1, n
                    call stdlib_sscal( mvl, work( p ), v( 1, p ), 1 )
                 end do
              else
                 do p = 1, n
                    temp1 = one / stdlib_snrm2( mvl, v( 1, p ), 1 )
                    call stdlib_sscal( mvl, temp1, v( 1, p ), 1 )
                 end do
              end if
           end if
           ! undo scaling, if necessary (and possible).
           if( ( ( skl>one ) .and. ( sva( 1 )<( big / skl ) ) ).or. ( ( skl<one ) .and. ( sva( &
                     max( n2, 1 ) ) >( sfmin / skl ) ) ) ) then
              do p = 1, n
                 sva( p ) = skl*sva( p )
              end do
              skl = one
           end if
           work( 1 ) = skl
           ! the singular values of a are skl*sva(1:n). if skl/=one
           ! then some of the singular values may overflow or underflow and
           ! the spectrum is given in this factored representation.
           work( 2 ) = real( n4,KIND=sp)
           ! n4 is the number of computed nonzero singular values of a.
           work( 3 ) = real( n2,KIND=sp)
           ! n2 is the number of singular values of a greater than sfmin.
           ! if n2<n, sva(n2:n) contains zeros and/or denormalized numbers
           ! that may carry some information.
           work( 4 ) = real( i,KIND=sp)
           ! i is the index of the last sweep before declaring convergence.
           work( 5 ) = mxaapq
           ! mxaapq is the largest absolute value of scaled pivots in the
           ! last sweep
           work( 6 ) = mxsinj
           ! mxsinj is the largest absolute value of the sines of jacobi angles
           ! in the last sweep
           return
     end subroutine stdlib_sgesvj

     module pure subroutine stdlib_dgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, work, lwork, &
     !! DGESVJ computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^t,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N orthogonal matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
     !! DGESVJ can sometimes compute tiny singular values and their singular vectors much
     !! more accurately than other SVD routines, see below under Further Details.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldv, lwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), v(ldv,*), work(lwork)
           real(dp), intent(out) :: sva(n)
        ! =====================================================================
           ! Local Parameters 
           integer(ilp), parameter :: nsweep = 30
           
           
           ! Local Scalars 
           real(dp) :: aapp, aapp0, aapq, aaqq, apoaq, aqoap, big, bigtheta, cs, ctol, epsln, &
           large, mxaapq, mxsinj, rootbig, rooteps, rootsfmin, roottol, skl, sfmin, small, sn, t, &
                     temp1, theta, thsign, tol
           integer(ilp) :: blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1, iswrot, jbc, jgl, kbl, &
                     lkahead, mvl, n2, n34, n4, nbl, notrot, p, pskipped, q, rowskip, swband
           logical(lk) :: applv, goscale, lower, lsvec, noscale, rotok, rsvec, uctol, &
                     upper
           ! Local Arrays 
           real(dp) :: fastr(5)
           ! Intrinsic Functions 
           ! from lapack
           ! from lapack
           ! Executable Statements 
           ! test the input arguments
           lsvec = stdlib_lsame( jobu, 'U' )
           uctol = stdlib_lsame( jobu, 'C' )
           rsvec = stdlib_lsame( jobv, 'V' )
           applv = stdlib_lsame( jobv, 'A' )
           upper = stdlib_lsame( joba, 'U' )
           lower = stdlib_lsame( joba, 'L' )
           if( .not.( upper .or. lower .or. stdlib_lsame( joba, 'G' ) ) ) then
              info = -1
           else if( .not.( lsvec .or. uctol .or. stdlib_lsame( jobu, 'N' ) ) ) then
              info = -2
           else if( .not.( rsvec .or. applv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( ( n<0 ) .or. ( n>m ) ) then
              info = -5
           else if( lda<m ) then
              info = -7
           else if( mv<0 ) then
              info = -9
           else if( ( rsvec .and. ( ldv<n ) ) .or.( applv .and. ( ldv<mv ) ) ) then
              info = -11
           else if( uctol .and. ( work( 1 )<=one ) ) then
              info = -12
           else if( lwork<max( m+n, 6 ) ) then
              info = -13
           else
              info = 0
           end if
           ! #:(
           if( info/=0 ) then
              call stdlib_xerbla( 'DGESVJ', -info )
              return
           end if
       ! #:) quick return for void matrix
           if( ( m==0 ) .or. ( n==0 ) )return
           ! set numerical parameters
           ! the stopping criterion for jacobi rotations is
           ! max_{i<>j}|a(:,i)^t * a(:,j)|/(||a(:,i)||*||a(:,j)||) < ctol*eps
           ! where eps is the round-off and ctol is defined as follows:
           if( uctol ) then
              ! ... user controlled
              ctol = work( 1 )
           else
              ! ... default
              if( lsvec .or. rsvec .or. applv ) then
                 ctol = sqrt( real( m,KIND=dp) )
              else
                 ctol = real( m,KIND=dp)
              end if
           end if
           ! ... and the machine dependent parameters are
      ! [!]  (make sure that stdlib_dlamch() works properly on the target machine.)
           epsln = stdlib_dlamch( 'EPSILON' )
           rooteps = sqrt( epsln )
           sfmin = stdlib_dlamch( 'SAFEMINIMUM' )
           rootsfmin = sqrt( sfmin )
           small = sfmin / epsln
           big = stdlib_dlamch( 'OVERFLOW' )
           ! big         = one    / sfmin
           rootbig = one / rootsfmin
           large = big / sqrt( real( m*n,KIND=dp) )
           bigtheta = one / rooteps
           tol = ctol*epsln
           roottol = sqrt( tol )
           if( real( m,KIND=dp)*epsln>=one ) then
              info = -4
              call stdlib_xerbla( 'DGESVJ', -info )
              return
           end if
           ! initialize the right singular vector matrix.
           if( rsvec ) then
              mvl = n
              call stdlib_dlaset( 'A', mvl, n, zero, one, v, ldv )
           else if( applv ) then
              mvl = mv
           end if
           rsvec = rsvec .or. applv
           ! initialize sva( 1:n ) = ( ||a e_i||_2, i = 1:n )
      ! (!)  if necessary, scale a to protect the largest singular value
           ! from overflow. it is possible that saving the largest singular
           ! value destroys the information about the small ones.
           ! this initial scaling is almost minimal in the sense that the
           ! goal is to make sure that no column norm overflows, and that
           ! sqrt(n)*max_i sva(i) does not overflow. if infinite entries
           ! in a are detected, the procedure returns with info=-6.
           skl= one / sqrt( real( m,KIND=dp)*real( n,KIND=dp) )
           noscale = .true.
           goscale = .true.
           if( lower ) then
              ! the input matrix is m-by-n lower triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_dlassq( m-p+1, a( p, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'DGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl)
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else if( upper ) then
              ! the input matrix is m-by-n upper triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_dlassq( p, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'DGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl)
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else
              ! the input matrix is m-by-n general dense
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_dlassq( m, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'DGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl)
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           end if
           if( noscale )skl= one
           ! move the smaller part of the spectrum from the underflow threshold
      ! (!)  start by determining the position of the nonzero entries of the
           ! array sva() relative to ( sfmin, big ).
           aapp = zero
           aaqq = big
           do p = 1, n
              if( sva( p )/=zero )aaqq = min( aaqq, sva( p ) )
              aapp = max( aapp, sva( p ) )
           end do
       ! #:) quick return for zero matrix
           if( aapp==zero ) then
              if( lsvec )call stdlib_dlaset( 'G', m, n, zero, one, a, lda )
              work( 1 ) = one
              work( 2 ) = zero
              work( 3 ) = zero
              work( 4 ) = zero
              work( 5 ) = zero
              work( 6 ) = zero
              return
           end if
       ! #:) quick return for one-column matrix
           if( n==1 ) then
              if( lsvec )call stdlib_dlascl( 'G', 0, 0, sva( 1 ), skl, m, 1,a( 1, 1 ), lda, ierr )
                        
              work( 1 ) = one / skl
              if( sva( 1 )>=sfmin ) then
                 work( 2 ) = one
              else
                 work( 2 ) = zero
              end if
              work( 3 ) = zero
              work( 4 ) = zero
              work( 5 ) = zero
              work( 6 ) = zero
              return
           end if
           ! protect small singular values from underflow, and try to
           ! avoid underflows/overflows in computing jacobi rotations.
           sn = sqrt( sfmin / epsln )
           temp1 = sqrt( big / real( n,KIND=dp) )
           if( ( aapp<=sn ) .or. ( aaqq>=temp1 ) .or.( ( sn<=aaqq ) .and. ( aapp<=temp1 ) ) ) &
                     then
              temp1 = min( big, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp<=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( aapp*sqrt( real( n,KIND=dp) ) ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq>=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = max( sn / aaqq, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( sqrt( real( n,KIND=dp) )*aapp ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else
              temp1 = one
           end if
           ! scale, if necessary
           if( temp1/=one ) then
              call stdlib_dlascl( 'G', 0, 0, one, temp1, n, 1, sva, n, ierr )
           end if
           skl= temp1*skl
           if( skl/=one ) then
              call stdlib_dlascl( joba, 0, 0, one, skl, m, n, a, lda, ierr )
              skl= one / skl
           end if
           ! row-cyclic jacobi svd algorithm with column pivoting
           emptsw = ( n*( n-1 ) ) / 2
           notrot = 0
           fastr( 1 ) = zero
           ! a is represented in factored form a = a * diag(work), where diag(work)
           ! is initialized to identity. work is updated during fast scaled
           ! rotations.
           do q = 1, n
              work( q ) = one
           end do
           swband = 3
      ! [tp] swband is a tuning parameter [tp]. it is meaningful and effective
           ! if stdlib_dgesvj is used as a computational routine in the preconditioned
           ! jacobi svd algorithm stdlib_dgesvj. for sweeps i=1:swband the procedure
           ! works on pivots inside a band-like region around the diagonal.
           ! the boundaries are determined dynamically, based on the number of
           ! pivots above a threshold.
           kbl = min( 8, n )
      ! [tp] kbl is a tuning parameter that defines the tile size in the
           ! tiling of the p-q loops of pivot pairs. in general, an optimal
           ! value of kbl depends on the matrix dimensions and on the
           ! parameters of the computer's memory.
           nbl = n / kbl
           if( ( nbl*kbl )/=n )nbl = nbl + 1
           blskip = kbl**2
      ! [tp] blkskip is a tuning parameter that depends on swband and kbl.
           rowskip = min( 5, kbl )
      ! [tp] rowskip is a tuning parameter.
           lkahead = 1
      ! [tp] lkahead is a tuning parameter.
           ! quasi block transformations, using the lower (upper) triangular
           ! structure of the input matrix. the quasi-block-cycling usually
           ! invokes cubic convergence. big part of this cycle is done inside
           ! canonical subspaces of dimensions less than m.
           if( ( lower .or. upper ) .and. ( n>max( 64, 4*kbl ) ) ) then
      ! [tp] the number of partition levels and the actual partition are
           ! tuning parameters.
              n4 = n / 4
              n2 = n / 2
              n34 = 3*n4
              if( applv ) then
                 q = 0
              else
                 q = 1
              end if
              if( lower ) then
           ! this works very well on lower triangular matrices, in particular
           ! in the framework of the preconditioned jacobi svd (xgejsv).
           ! the idea is simple:
           ! [+ 0 0 0]   note that jacobi transformations of [0 0]
           ! [+ + 0 0]                                       [0 0]
           ! [+ + x 0]   actually work on [x 0]              [x 0]
           ! [+ + x x]                    [x x].             [x x]
                 call stdlib_dgsvj0( jobv, m-n34, n-n34, a( n34+1, n34+1 ), lda,work( n34+1 ), &
                 sva( n34+1 ), mvl,v( n34*q+1, n34+1 ), ldv, epsln, sfmin, tol,2, work( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_dgsvj0( jobv, m-n2, n34-n2, a( n2+1, n2+1 ), lda,work( n2+1 ), sva( &
                 n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 2,work( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_dgsvj1( jobv, m-n2, n-n2, n4, a( n2+1, n2+1 ), lda,work( n2+1 ), sva(&
                  n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, &
                            ierr )
                 call stdlib_dgsvj0( jobv, m-n4, n2-n4, a( n4+1, n4+1 ), lda,work( n4+1 ), sva( &
                 n4+1 ), mvl,v( n4*q+1, n4+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_dgsvj0( jobv, m, n4, a, lda, work, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 1, work( n+1 ), lwork-n,ierr )
                 call stdlib_dgsvj1( jobv, m, n2, n4, a, lda, work, sva, mvl, v,ldv, epsln, sfmin,&
                            tol, 1, work( n+1 ),lwork-n, ierr )
              else if( upper ) then
                 call stdlib_dgsvj0( jobv, n4, n4, a, lda, work, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 2, work( n+1 ), lwork-n,ierr )
                 call stdlib_dgsvj0( jobv, n2, n4, a( 1, n4+1 ), lda, work( n4+1 ),sva( n4+1 ), &
                 mvl, v( n4*q+1, n4+1 ), ldv,epsln, sfmin, tol, 1, work( n+1 ), lwork-n,ierr )
                           
                 call stdlib_dgsvj1( jobv, n2, n2, n4, a, lda, work, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, work( n+1 ),lwork-n, ierr )
                 call stdlib_dgsvj0( jobv, n2+n4, n4, a( 1, n2+1 ), lda,work( n2+1 ), sva( n2+1 ),&
                  mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, ierr )
                            
              end if
           end if
           ! .. row-cyclic pivot strategy with de rijk's pivoting ..
           loop_1993: do i = 1, nsweep
           ! .. go go go ...
              mxaapq = zero
              mxsinj = zero
              iswrot = 0
              notrot = 0
              pskipped = 0
           ! each sweep is unrolled using kbl-by-kbl tiles over the pivot pairs
           ! 1 <= p < q <= n. this is the first step toward a blocked implementation
           ! of the rotations. new implementation, based on block transformations,
           ! is under development.
              loop_2000: do ibr = 1, nbl
                 igl = ( ibr-1 )*kbl + 1
                 loop_1002: do ir1 = 0, min( lkahead, nbl-ibr )
                    igl = igl + ir1*kbl
                    loop_2001: do p = igl, min( igl+kbl-1, n-1 )
           ! .. de rijk's pivoting
                       q = stdlib_idamax( n-p+1, sva( p ), 1 ) + p - 1
                       if( p/=q ) then
                          call stdlib_dswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                          if( rsvec )call stdlib_dswap( mvl, v( 1, p ), 1,v( 1, q ), 1 )
                          temp1 = sva( p )
                          sva( p ) = sva( q )
                          sva( q ) = temp1
                          temp1 = work( p )
                          work( p ) = work( q )
                          work( q ) = temp1
                       end if
                       if( ir1==0 ) then
              ! column norms are periodically updated by explicit
              ! norm computation.
              ! caveat:
              ! unfortunately, some blas implementations compute stdlib_dnrm2(m,a(1,p),1)
              ! as sqrt(stdlib_ddot(m,a(1,p),1,a(1,p),1)), which may cause the result to
              ! overflow for ||a(:,p)||_2 > sqrt(overflow_threshold), and to
              ! underflow for ||a(:,p)||_2 < sqrt(underflow_threshold).
              ! hence, stdlib_dnrm2 cannot be trusted, not even in the case when
              ! the true norm is far from the under(over)flow boundaries.
              ! if properly implemented stdlib_dnrm2 is available, the if-then-else
              ! below should read "aapp = stdlib_dnrm2( m, a(1,p), 1 ) * work(p)".
                          if( ( sva( p )<rootbig ) .and.( sva( p )>rootsfmin ) ) then
                             sva( p ) = stdlib_dnrm2( m, a( 1, p ), 1 )*work( p )
                          else
                             temp1 = zero
                             aapp = one
                             call stdlib_dlassq( m, a( 1, p ), 1, temp1, aapp )
                             sva( p ) = temp1*sqrt( aapp )*work( p )
                          end if
                          aapp = sva( p )
                       else
                          aapp = sva( p )
                       end if
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2002: do q = p + 1, min( igl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
                                if( aaqq>=one ) then
                                   rotok = ( small*aapp )<=aaqq
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_ddot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_dcopy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_dlascl( 'G', 0, 0, aapp,work( p ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_ddot( m, work( n+1 ), 1,a( 1, q ), 1 )*work( &
                                                q ) / aaqq
                                   end if
                                else
                                   rotok = aapp<=( aaqq / small )
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_ddot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_dcopy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                      call stdlib_dlascl( 'G', 0, 0, aaqq,work( q ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_ddot( m, work( n+1 ), 1,a( 1, p ), 1 )*work( &
                                                p ) / aapp
                                   end if
                                end if
                                mxaapq = max( mxaapq, abs( aapq ) )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq )>tol ) then
                 ! Rotate
      ! [rtd]      rotated = rotated + one
                                   if( ir1==0 ) then
                                      notrot = 0
                                      pskipped = 0
                                      iswrot = iswrot + 1
                                   end if
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs(aqoap-apoaq)/aapq
                                      if( abs( theta )>bigtheta ) then
                                         t = half / theta
                                         fastr( 3 ) = t*work( p ) / work( q )
                                         fastr( 4 ) = -t*work( q ) /work( p )
                                         call stdlib_drotm( m, a( 1, p ), 1,a( 1, q ), 1, fastr )
                                                   
                                         if( rsvec )call stdlib_drotm( mvl,v( 1, p ), 1,v( 1, q ),&
                                                    1,fastr )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq )
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         apoaq = work( p ) / work( q )
                                         aqoap = work( q ) / work( p )
                                         if( work( p )>=one ) then
                                            if( work( q )>=one ) then
                                               fastr( 3 ) = t*apoaq
                                               fastr( 4 ) = -t*aqoap
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q )*cs
                                               call stdlib_drotm( m, a( 1, p ), 1,a( 1, q ), 1,&
                                                         fastr )
                                               if( rsvec )call stdlib_drotm( mvl,v( 1, p ), 1, v( &
                                                         1, q ),1, fastr )
                                            else
                                               call stdlib_daxpy( m, -t*aqoap,a( 1, q ), 1,a( 1, &
                                                         p ), 1 )
                                               call stdlib_daxpy( m, cs*sn*apoaq,a( 1, p ), 1,a( &
                                                         1, q ), 1 )
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q ) / cs
                                               if( rsvec ) then
                                                  call stdlib_daxpy( mvl, -t*aqoap,v( 1, q ), 1,v(&
                                                             1, p ), 1 )
                                                  call stdlib_daxpy( mvl,cs*sn*apoaq,v( 1, p ), 1,&
                                                            v( 1, q ), 1 )
                                               end if
                                            end if
                                         else
                                            if( work( q )>=one ) then
                                               call stdlib_daxpy( m, t*apoaq,a( 1, p ), 1,a( 1, q &
                                                         ), 1 )
                                               call stdlib_daxpy( m, -cs*sn*aqoap,a( 1, q ), 1,a( &
                                                         1, p ), 1 )
                                               work( p ) = work( p ) / cs
                                               work( q ) = work( q )*cs
                                               if( rsvec ) then
                                                  call stdlib_daxpy( mvl, t*apoaq,v( 1, p ), 1,v( &
                                                            1, q ), 1 )
                                                  call stdlib_daxpy( mvl,-cs*sn*aqoap,v( 1, q ), &
                                                            1,v( 1, p ), 1 )
                                               end if
                                            else
                                               if( work( p )>=work( q ) )then
                                                  call stdlib_daxpy( m, -t*aqoap,a( 1, q ), 1,a( &
                                                            1, p ), 1 )
                                                  call stdlib_daxpy( m, cs*sn*apoaq,a( 1, p ), 1,&
                                                            a( 1, q ), 1 )
                                                  work( p ) = work( p )*cs
                                                  work( q ) = work( q ) / cs
                                                  if( rsvec ) then
                                                     call stdlib_daxpy( mvl,-t*aqoap,v( 1, q ), 1,&
                                                               v( 1, p ), 1 )
                                                     call stdlib_daxpy( mvl,cs*sn*apoaq,v( 1, p ),&
                                                                1,v( 1, q ), 1 )
                                                  end if
                                               else
                                                  call stdlib_daxpy( m, t*apoaq,a( 1, p ), 1,a( 1,&
                                                             q ), 1 )
                                                  call stdlib_daxpy( m,-cs*sn*aqoap,a( 1, q ), 1,&
                                                            a( 1, p ), 1 )
                                                  work( p ) = work( p ) / cs
                                                  work( q ) = work( q )*cs
                                                  if( rsvec ) then
                                                     call stdlib_daxpy( mvl,t*apoaq, v( 1, p ),1, &
                                                               v( 1, q ), 1 )
                                                     call stdlib_daxpy( mvl,-cs*sn*aqoap,v( 1, q )&
                                                               , 1,v( 1, p ), 1 )
                                                  end if
                                               end if
                                            end if
                                         end if
                                      end if
                                   else
                    ! .. have to use modified gram-schmidt like transformation
                                      call stdlib_dcopy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_dlascl( 'G', 0, 0, aapp, one, m,1, work( n+1 ), &
                                                lda,ierr )
                                      call stdlib_dlascl( 'G', 0, 0, aaqq, one, m,1, a( 1, q ), &
                                                lda, ierr )
                                      temp1 = -aapq*work( p ) / work( q )
                                      call stdlib_daxpy( m, temp1, work( n+1 ), 1,a( 1, q ), 1 )
                                                
                                      call stdlib_dlascl( 'G', 0, 0, one, aaqq, m,1, a( 1, q ), &
                                                lda, ierr )
                                      sva( q ) = aaqq*sqrt( max( zero,one-aapq*aapq ) )
                                      mxsinj = max( mxsinj, sfmin )
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! recompute sva(q), sva(p).
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_dnrm2( m, a( 1, q ), 1 )*work( q )
                                                   
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_dlassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )*work( q )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_dnrm2( m, a( 1, p ), 1 )*work( p )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_dlassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )*work( p )
                                      end if
                                      sva( p ) = aapp
                                   end if
                                else
              ! a(:,p) and a(:,q) already numerically orthogonal
                                   if( ir1==0 )notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                end if
                             else
              ! a(:,q) is zero column
                                if( ir1==0 )notrot = notrot + 1
                                pskipped = pskipped + 1
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                if( ir1==0 )aapp = -aapp
                                notrot = 0
                                go to 2103
                             end if
                          end do loop_2002
           ! end q-loop
           2103 continue
           ! bailed out of q-loop
                          sva( p ) = aapp
                       else
                          sva( p ) = aapp
                          if( ( ir1==0 ) .and. ( aapp==zero ) )notrot = notrot + min( igl+kbl-1, &
                                    n ) - p
                       end if
                    end do loop_2001
           ! end of the p-loop
           ! end of doing the block ( ibr, ibr )
                 end do loop_1002
           ! end of ir1-loop
       ! ... go to the off diagonal blocks
                 igl = ( ibr-1 )*kbl + 1
                 loop_2010: do jbc = ibr + 1, nbl
                    jgl = ( jbc-1 )*kbl + 1
              ! doing the block at ( ibr, jbc )
                    ijblsk = 0
                    loop_2100: do p = igl, min( igl+kbl-1, n )
                       aapp = sva( p )
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2200: do q = jgl, min( jgl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
           ! M X 2 Jacobi Svd 
              ! safe gram matrix computation
                                if( aaqq>=one ) then
                                   if( aapp>=aaqq ) then
                                      rotok = ( small*aapp )<=aaqq
                                   else
                                      rotok = ( small*aaqq )<=aapp
                                   end if
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_ddot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_dcopy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_dlascl( 'G', 0, 0, aapp,work( p ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_ddot( m, work( n+1 ), 1,a( 1, q ), 1 )*work( &
                                                q ) / aaqq
                                   end if
                                else
                                   if( aapp>=aaqq ) then
                                      rotok = aapp<=( aaqq / small )
                                   else
                                      rotok = aaqq<=( aapp / small )
                                   end if
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_ddot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_dcopy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                      call stdlib_dlascl( 'G', 0, 0, aaqq,work( q ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_ddot( m, work( n+1 ), 1,a( 1, p ), 1 )*work( &
                                                p ) / aapp
                                   end if
                                end if
                                mxaapq = max( mxaapq, abs( aapq ) )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq )>tol ) then
                                   notrot = 0
      ! [rtd]      rotated  = rotated + 1
                                   pskipped = 0
                                   iswrot = iswrot + 1
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs(aqoap-apoaq)/aapq
                                      if( aaqq>aapp0 )theta = -theta
                                      if( abs( theta )>bigtheta ) then
                                         t = half / theta
                                         fastr( 3 ) = t*work( p ) / work( q )
                                         fastr( 4 ) = -t*work( q ) /work( p )
                                         call stdlib_drotm( m, a( 1, p ), 1,a( 1, q ), 1, fastr )
                                                   
                                         if( rsvec )call stdlib_drotm( mvl,v( 1, p ), 1,v( 1, q ),&
                                                    1,fastr )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq )
                                         if( aaqq>aapp0 )thsign = -thsign
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         apoaq = work( p ) / work( q )
                                         aqoap = work( q ) / work( p )
                                         if( work( p )>=one ) then
                                            if( work( q )>=one ) then
                                               fastr( 3 ) = t*apoaq
                                               fastr( 4 ) = -t*aqoap
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q )*cs
                                               call stdlib_drotm( m, a( 1, p ), 1,a( 1, q ), 1,&
                                                         fastr )
                                               if( rsvec )call stdlib_drotm( mvl,v( 1, p ), 1, v( &
                                                         1, q ),1, fastr )
                                            else
                                               call stdlib_daxpy( m, -t*aqoap,a( 1, q ), 1,a( 1, &
                                                         p ), 1 )
                                               call stdlib_daxpy( m, cs*sn*apoaq,a( 1, p ), 1,a( &
                                                         1, q ), 1 )
                                               if( rsvec ) then
                                                  call stdlib_daxpy( mvl, -t*aqoap,v( 1, q ), 1,v(&
                                                             1, p ), 1 )
                                                  call stdlib_daxpy( mvl,cs*sn*apoaq,v( 1, p ), 1,&
                                                            v( 1, q ), 1 )
                                               end if
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q ) / cs
                                            end if
                                         else
                                            if( work( q )>=one ) then
                                               call stdlib_daxpy( m, t*apoaq,a( 1, p ), 1,a( 1, q &
                                                         ), 1 )
                                               call stdlib_daxpy( m, -cs*sn*aqoap,a( 1, q ), 1,a( &
                                                         1, p ), 1 )
                                               if( rsvec ) then
                                                  call stdlib_daxpy( mvl, t*apoaq,v( 1, p ), 1,v( &
                                                            1, q ), 1 )
                                                  call stdlib_daxpy( mvl,-cs*sn*aqoap,v( 1, q ), &
                                                            1,v( 1, p ), 1 )
                                               end if
                                               work( p ) = work( p ) / cs
                                               work( q ) = work( q )*cs
                                            else
                                               if( work( p )>=work( q ) )then
                                                  call stdlib_daxpy( m, -t*aqoap,a( 1, q ), 1,a( &
                                                            1, p ), 1 )
                                                  call stdlib_daxpy( m, cs*sn*apoaq,a( 1, p ), 1,&
                                                            a( 1, q ), 1 )
                                                  work( p ) = work( p )*cs
                                                  work( q ) = work( q ) / cs
                                                  if( rsvec ) then
                                                     call stdlib_daxpy( mvl,-t*aqoap,v( 1, q ), 1,&
                                                               v( 1, p ), 1 )
                                                     call stdlib_daxpy( mvl,cs*sn*apoaq,v( 1, p ),&
                                                                1,v( 1, q ), 1 )
                                                  end if
                                               else
                                                  call stdlib_daxpy( m, t*apoaq,a( 1, p ), 1,a( 1,&
                                                             q ), 1 )
                                                  call stdlib_daxpy( m,-cs*sn*aqoap,a( 1, q ), 1,&
                                                            a( 1, p ), 1 )
                                                  work( p ) = work( p ) / cs
                                                  work( q ) = work( q )*cs
                                                  if( rsvec ) then
                                                     call stdlib_daxpy( mvl,t*apoaq, v( 1, p ),1, &
                                                               v( 1, q ), 1 )
                                                     call stdlib_daxpy( mvl,-cs*sn*aqoap,v( 1, q )&
                                                               , 1,v( 1, p ), 1 )
                                                  end if
                                               end if
                                            end if
                                         end if
                                      end if
                                   else
                                      if( aapp>aaqq ) then
                                         call stdlib_dcopy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                                   
                                         call stdlib_dlascl( 'G', 0, 0, aapp, one,m, 1, work( n+1 &
                                                   ), lda,ierr )
                                         call stdlib_dlascl( 'G', 0, 0, aaqq, one,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         temp1 = -aapq*work( p ) / work( q )
                                         call stdlib_daxpy( m, temp1, work( n+1 ),1, a( 1, q ), 1 &
                                                   )
                                         call stdlib_dlascl( 'G', 0, 0, one, aaqq,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         sva( q ) = aaqq*sqrt( max( zero,one-aapq*aapq ) )
                                         mxsinj = max( mxsinj, sfmin )
                                      else
                                         call stdlib_dcopy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                                   
                                         call stdlib_dlascl( 'G', 0, 0, aaqq, one,m, 1, work( n+1 &
                                                   ), lda,ierr )
                                         call stdlib_dlascl( 'G', 0, 0, aapp, one,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         temp1 = -aapq*work( q ) / work( p )
                                         call stdlib_daxpy( m, temp1, work( n+1 ),1, a( 1, p ), 1 &
                                                   )
                                         call stdlib_dlascl( 'G', 0, 0, one, aapp,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         sva( p ) = aapp*sqrt( max( zero,one-aapq*aapq ) )
                                         mxsinj = max( mxsinj, sfmin )
                                      end if
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q)
                 ! .. recompute sva(q)
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_dnrm2( m, a( 1, q ), 1 )*work( q )
                                                   
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_dlassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )*work( q )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )**2<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_dnrm2( m, a( 1, p ), 1 )*work( p )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_dlassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )*work( p )
                                      end if
                                      sva( p ) = aapp
                                   end if
                    ! end of ok rotation
                                else
                                   notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                   ijblsk = ijblsk + 1
                                end if
                             else
                                notrot = notrot + 1
                                pskipped = pskipped + 1
                                ijblsk = ijblsk + 1
                             end if
                             if( ( i<=swband ) .and. ( ijblsk>=blskip ) )then
                                sva( p ) = aapp
                                notrot = 0
                                go to 2011
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                aapp = -aapp
                                notrot = 0
                                go to 2203
                             end if
                          end do loop_2200
              ! end of the q-loop
              2203 continue
                          sva( p ) = aapp
                       else
                          if( aapp==zero )notrot = notrot +min( jgl+kbl-1, n ) - jgl + 1
                          if( aapp<zero )notrot = 0
                       end if
                    end do loop_2100
           ! end of the p-loop
                 end do loop_2010
           ! end of the jbc-loop
           2011 continue
      ! 2011 bailed out of the jbc-loop
                 do p = igl, min( igl+kbl-1, n )
                    sva( p ) = abs( sva( p ) )
                 end do
      ! **
              end do loop_2000
      ! 2000 :: end of the ibr-loop
           ! .. update sva(n)
              if( ( sva( n )<rootbig ) .and. ( sva( n )>rootsfmin ) )then
                 sva( n ) = stdlib_dnrm2( m, a( 1, n ), 1 )*work( n )
              else
                 t = zero
                 aapp = one
                 call stdlib_dlassq( m, a( 1, n ), 1, t, aapp )
                 sva( n ) = t*sqrt( aapp )*work( n )
              end if
           ! additional steering devices
              if( ( i<swband ) .and. ( ( mxaapq<=roottol ) .or.( iswrot<=n ) ) )swband = i
              if( ( i>swband+1 ) .and. ( mxaapq<sqrt( real( n,KIND=dp) )*tol ) .and. ( real( n,&
                        KIND=dp)*mxaapq*mxsinj<tol ) ) then
                 go to 1994
              end if
              if( notrot>=emptsw )go to 1994
           end do loop_1993
           ! end i=1:nsweep loop
       ! #:( reaching this point means that the procedure has not converged.
           info = nsweep - 1
           go to 1995
           1994 continue
       ! #:) reaching this point means numerical convergence after the i-th
           ! sweep.
           info = 0
       ! #:) info = 0 confirms successful iterations.
       1995 continue
           ! sort the singular values and find how many are above
           ! the underflow threshold.
           n2 = 0
           n4 = 0
           do p = 1, n - 1
              q = stdlib_idamax( n-p+1, sva( p ), 1 ) + p - 1
              if( p/=q ) then
                 temp1 = sva( p )
                 sva( p ) = sva( q )
                 sva( q ) = temp1
                 temp1 = work( p )
                 work( p ) = work( q )
                 work( q ) = temp1
                 call stdlib_dswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                 if( rsvec )call stdlib_dswap( mvl, v( 1, p ), 1, v( 1, q ), 1 )
              end if
              if( sva( p )/=zero ) then
                 n4 = n4 + 1
                 if( sva( p )*skl>sfmin )n2 = n2 + 1
              end if
           end do
           if( sva( n )/=zero ) then
              n4 = n4 + 1
              if( sva( n )*skl>sfmin )n2 = n2 + 1
           end if
           ! normalize the left singular vectors.
           if( lsvec .or. uctol ) then
              do p = 1, n2
                 call stdlib_dscal( m, work( p ) / sva( p ), a( 1, p ), 1 )
              end do
           end if
           ! scale the product of jacobi rotations (assemble the fast rotations).
           if( rsvec ) then
              if( applv ) then
                 do p = 1, n
                    call stdlib_dscal( mvl, work( p ), v( 1, p ), 1 )
                 end do
              else
                 do p = 1, n
                    temp1 = one / stdlib_dnrm2( mvl, v( 1, p ), 1 )
                    call stdlib_dscal( mvl, temp1, v( 1, p ), 1 )
                 end do
              end if
           end if
           ! undo scaling, if necessary (and possible).
           if( ( ( skl>one ) .and. ( sva( 1 )<( big / skl) ) ).or. ( ( skl<one ) .and. ( sva( max(&
                      n2, 1 ) ) >( sfmin / skl) ) ) ) then
              do p = 1, n
                 sva( p ) = skl*sva( p )
              end do
              skl= one
           end if
           work( 1 ) = skl
           ! the singular values of a are skl*sva(1:n). if skl/=one
           ! then some of the singular values may overflow or underflow and
           ! the spectrum is given in this factored representation.
           work( 2 ) = real( n4,KIND=dp)
           ! n4 is the number of computed nonzero singular values of a.
           work( 3 ) = real( n2,KIND=dp)
           ! n2 is the number of singular values of a greater than sfmin.
           ! if n2<n, sva(n2:n) contains zeros and/or denormalized numbers
           ! that may carry some information.
           work( 4 ) = real( i,KIND=dp)
           ! i is the index of the last sweep before declaring convergence.
           work( 5 ) = mxaapq
           ! mxaapq is the largest absolute value of scaled pivots in the
           ! last sweep
           work( 6 ) = mxsinj
           ! mxsinj is the largest absolute value of the sines of jacobi angles
           ! in the last sweep
           return
     end subroutine stdlib_dgesvj

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$gesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, work, lwork, &
     !! DGESVJ: computes the singular value decomposition (SVD) of a real
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^t,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N orthogonal matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
     !! DGESVJ can sometimes compute tiny singular values and their singular vectors much
     !! more accurately than other SVD routines, see below under Further Details.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldv, lwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), v(ldv,*), work(lwork)
           real(${rk}$), intent(out) :: sva(n)
        ! =====================================================================
           ! Local Parameters 
           integer(ilp), parameter :: nsweep = 30
           
           
           ! Local Scalars 
           real(${rk}$) :: aapp, aapp0, aapq, aaqq, apoaq, aqoap, big, bigtheta, cs, ctol, epsln, &
           large, mxaapq, mxsinj, rootbig, rooteps, rootsfmin, roottol, skl, sfmin, small, sn, t, &
                     temp1, theta, thsign, tol
           integer(ilp) :: blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1, iswrot, jbc, jgl, kbl, &
                     lkahead, mvl, n2, n34, n4, nbl, notrot, p, pskipped, q, rowskip, swband
           logical(lk) :: applv, goscale, lower, lsvec, noscale, rotok, rsvec, uctol, &
                     upper
           ! Local Arrays 
           real(${rk}$) :: fastr(5)
           ! Intrinsic Functions 
           ! from lapack
           ! from lapack
           ! Executable Statements 
           ! test the input arguments
           lsvec = stdlib_lsame( jobu, 'U' )
           uctol = stdlib_lsame( jobu, 'C' )
           rsvec = stdlib_lsame( jobv, 'V' )
           applv = stdlib_lsame( jobv, 'A' )
           upper = stdlib_lsame( joba, 'U' )
           lower = stdlib_lsame( joba, 'L' )
           if( .not.( upper .or. lower .or. stdlib_lsame( joba, 'G' ) ) ) then
              info = -1
           else if( .not.( lsvec .or. uctol .or. stdlib_lsame( jobu, 'N' ) ) ) then
              info = -2
           else if( .not.( rsvec .or. applv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( ( n<0 ) .or. ( n>m ) ) then
              info = -5
           else if( lda<m ) then
              info = -7
           else if( mv<0 ) then
              info = -9
           else if( ( rsvec .and. ( ldv<n ) ) .or.( applv .and. ( ldv<mv ) ) ) then
              info = -11
           else if( uctol .and. ( work( 1 )<=one ) ) then
              info = -12
           else if( lwork<max( m+n, 6 ) ) then
              info = -13
           else
              info = 0
           end if
           ! #:(
           if( info/=0 ) then
              call stdlib_xerbla( 'DGESVJ', -info )
              return
           end if
       ! #:) quick return for void matrix
           if( ( m==0 ) .or. ( n==0 ) )return
           ! set numerical parameters
           ! the stopping criterion for jacobi rotations is
           ! max_{i<>j}|a(:,i)^t * a(:,j)|/(||a(:,i)||*||a(:,j)||) < ctol*eps
           ! where eps is the round-off and ctol is defined as follows:
           if( uctol ) then
              ! ... user controlled
              ctol = work( 1 )
           else
              ! ... default
              if( lsvec .or. rsvec .or. applv ) then
                 ctol = sqrt( real( m,KIND=${rk}$) )
              else
                 ctol = real( m,KIND=${rk}$)
              end if
           end if
           ! ... and the machine dependent parameters are
      ! [!]  (make sure that stdlib_${ri}$lamch() works properly on the target machine.)
           epsln = stdlib_${ri}$lamch( 'EPSILON' )
           rooteps = sqrt( epsln )
           sfmin = stdlib_${ri}$lamch( 'SAFEMINIMUM' )
           rootsfmin = sqrt( sfmin )
           small = sfmin / epsln
           big = stdlib_${ri}$lamch( 'OVERFLOW' )
           ! big         = one    / sfmin
           rootbig = one / rootsfmin
           large = big / sqrt( real( m*n,KIND=${rk}$) )
           bigtheta = one / rooteps
           tol = ctol*epsln
           roottol = sqrt( tol )
           if( real( m,KIND=${rk}$)*epsln>=one ) then
              info = -4
              call stdlib_xerbla( 'DGESVJ', -info )
              return
           end if
           ! initialize the right singular vector matrix.
           if( rsvec ) then
              mvl = n
              call stdlib_${ri}$laset( 'A', mvl, n, zero, one, v, ldv )
           else if( applv ) then
              mvl = mv
           end if
           rsvec = rsvec .or. applv
           ! initialize sva( 1:n ) = ( ||a e_i||_2, i = 1:n )
      ! (!)  if necessary, scale a to protect the largest singular value
           ! from overflow. it is possible that saving the largest singular
           ! value destroys the information about the small ones.
           ! this initial scaling is almost minimal in the sense that the
           ! goal is to make sure that no column norm overflows, and that
           ! sqrt(n)*max_i sva(i) does not overflow. if infinite entries
           ! in a are detected, the procedure returns with info=-6.
           skl= one / sqrt( real( m,KIND=${rk}$)*real( n,KIND=${rk}$) )
           noscale = .true.
           goscale = .true.
           if( lower ) then
              ! the input matrix is m-by-n lower triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_${ri}$lassq( m-p+1, a( p, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'DGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl)
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else if( upper ) then
              ! the input matrix is m-by-n upper triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_${ri}$lassq( p, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'DGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl)
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else
              ! the input matrix is m-by-n general dense
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_${ri}$lassq( m, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'DGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl)
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           end if
           if( noscale )skl= one
           ! move the smaller part of the spectrum from the underflow threshold
      ! (!)  start by determining the position of the nonzero entries of the
           ! array sva() relative to ( sfmin, big ).
           aapp = zero
           aaqq = big
           do p = 1, n
              if( sva( p )/=zero )aaqq = min( aaqq, sva( p ) )
              aapp = max( aapp, sva( p ) )
           end do
       ! #:) quick return for zero matrix
           if( aapp==zero ) then
              if( lsvec )call stdlib_${ri}$laset( 'G', m, n, zero, one, a, lda )
              work( 1 ) = one
              work( 2 ) = zero
              work( 3 ) = zero
              work( 4 ) = zero
              work( 5 ) = zero
              work( 6 ) = zero
              return
           end if
       ! #:) quick return for one-column matrix
           if( n==1 ) then
              if( lsvec )call stdlib_${ri}$lascl( 'G', 0, 0, sva( 1 ), skl, m, 1,a( 1, 1 ), lda, ierr )
                        
              work( 1 ) = one / skl
              if( sva( 1 )>=sfmin ) then
                 work( 2 ) = one
              else
                 work( 2 ) = zero
              end if
              work( 3 ) = zero
              work( 4 ) = zero
              work( 5 ) = zero
              work( 6 ) = zero
              return
           end if
           ! protect small singular values from underflow, and try to
           ! avoid underflows/overflows in computing jacobi rotations.
           sn = sqrt( sfmin / epsln )
           temp1 = sqrt( big / real( n,KIND=${rk}$) )
           if( ( aapp<=sn ) .or. ( aaqq>=temp1 ) .or.( ( sn<=aaqq ) .and. ( aapp<=temp1 ) ) ) &
                     then
              temp1 = min( big, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp<=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( aapp*sqrt( real( n,KIND=${rk}$) ) ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq>=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = max( sn / aaqq, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( sqrt( real( n,KIND=${rk}$) )*aapp ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else
              temp1 = one
           end if
           ! scale, if necessary
           if( temp1/=one ) then
              call stdlib_${ri}$lascl( 'G', 0, 0, one, temp1, n, 1, sva, n, ierr )
           end if
           skl= temp1*skl
           if( skl/=one ) then
              call stdlib_${ri}$lascl( joba, 0, 0, one, skl, m, n, a, lda, ierr )
              skl= one / skl
           end if
           ! row-cyclic jacobi svd algorithm with column pivoting
           emptsw = ( n*( n-1 ) ) / 2
           notrot = 0
           fastr( 1 ) = zero
           ! a is represented in factored form a = a * diag(work), where diag(work)
           ! is initialized to identity. work is updated during fast scaled
           ! rotations.
           do q = 1, n
              work( q ) = one
           end do
           swband = 3
      ! [tp] swband is a tuning parameter [tp]. it is meaningful and effective
           ! if stdlib_${ri}$gesvj is used as a computational routine in the preconditioned
           ! jacobi svd algorithm stdlib_${ri}$gesvj. for sweeps i=1:swband the procedure
           ! works on pivots inside a band-like region around the diagonal.
           ! the boundaries are determined dynamically, based on the number of
           ! pivots above a threshold.
           kbl = min( 8, n )
      ! [tp] kbl is a tuning parameter that defines the tile size in the
           ! tiling of the p-q loops of pivot pairs. in general, an optimal
           ! value of kbl depends on the matrix dimensions and on the
           ! parameters of the computer's memory.
           nbl = n / kbl
           if( ( nbl*kbl )/=n )nbl = nbl + 1
           blskip = kbl**2
      ! [tp] blkskip is a tuning parameter that depends on swband and kbl.
           rowskip = min( 5, kbl )
      ! [tp] rowskip is a tuning parameter.
           lkahead = 1
      ! [tp] lkahead is a tuning parameter.
           ! quasi block transformations, using the lower (upper) triangular
           ! structure of the input matrix. the quasi-block-cycling usually
           ! invokes cubic convergence. big part of this cycle is done inside
           ! canonical subspaces of dimensions less than m.
           if( ( lower .or. upper ) .and. ( n>max( 64, 4*kbl ) ) ) then
      ! [tp] the number of partition levels and the actual partition are
           ! tuning parameters.
              n4 = n / 4
              n2 = n / 2
              n34 = 3*n4
              if( applv ) then
                 q = 0
              else
                 q = 1
              end if
              if( lower ) then
           ! this works very well on lower triangular matrices, in particular
           ! in the framework of the preconditioned jacobi svd (xgejsv).
           ! the idea is simple:
           ! [+ 0 0 0]   note that jacobi transformations of [0 0]
           ! [+ + 0 0]                                       [0 0]
           ! [+ + x 0]   actually work on [x 0]              [x 0]
           ! [+ + x x]                    [x x].             [x x]
                 call stdlib_${ri}$gsvj0( jobv, m-n34, n-n34, a( n34+1, n34+1 ), lda,work( n34+1 ), &
                 sva( n34+1 ), mvl,v( n34*q+1, n34+1 ), ldv, epsln, sfmin, tol,2, work( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_${ri}$gsvj0( jobv, m-n2, n34-n2, a( n2+1, n2+1 ), lda,work( n2+1 ), sva( &
                 n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 2,work( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_${ri}$gsvj1( jobv, m-n2, n-n2, n4, a( n2+1, n2+1 ), lda,work( n2+1 ), sva(&
                  n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, &
                            ierr )
                 call stdlib_${ri}$gsvj0( jobv, m-n4, n2-n4, a( n4+1, n4+1 ), lda,work( n4+1 ), sva( &
                 n4+1 ), mvl,v( n4*q+1, n4+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_${ri}$gsvj0( jobv, m, n4, a, lda, work, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 1, work( n+1 ), lwork-n,ierr )
                 call stdlib_${ri}$gsvj1( jobv, m, n2, n4, a, lda, work, sva, mvl, v,ldv, epsln, sfmin,&
                            tol, 1, work( n+1 ),lwork-n, ierr )
              else if( upper ) then
                 call stdlib_${ri}$gsvj0( jobv, n4, n4, a, lda, work, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 2, work( n+1 ), lwork-n,ierr )
                 call stdlib_${ri}$gsvj0( jobv, n2, n4, a( 1, n4+1 ), lda, work( n4+1 ),sva( n4+1 ), &
                 mvl, v( n4*q+1, n4+1 ), ldv,epsln, sfmin, tol, 1, work( n+1 ), lwork-n,ierr )
                           
                 call stdlib_${ri}$gsvj1( jobv, n2, n2, n4, a, lda, work, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, work( n+1 ),lwork-n, ierr )
                 call stdlib_${ri}$gsvj0( jobv, n2+n4, n4, a( 1, n2+1 ), lda,work( n2+1 ), sva( n2+1 ),&
                  mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,work( n+1 ), lwork-n, ierr )
                            
              end if
           end if
           ! .. row-cyclic pivot strategy with de rijk's pivoting ..
           loop_1993: do i = 1, nsweep
           ! .. go go go ...
              mxaapq = zero
              mxsinj = zero
              iswrot = 0
              notrot = 0
              pskipped = 0
           ! each sweep is unrolled using kbl-by-kbl tiles over the pivot pairs
           ! 1 <= p < q <= n. this is the first step toward a blocked implementation
           ! of the rotations. new implementation, based on block transformations,
           ! is under development.
              loop_2000: do ibr = 1, nbl
                 igl = ( ibr-1 )*kbl + 1
                 loop_1002: do ir1 = 0, min( lkahead, nbl-ibr )
                    igl = igl + ir1*kbl
                    loop_2001: do p = igl, min( igl+kbl-1, n-1 )
           ! .. de rijk's pivoting
                       q = stdlib_i${ri}$amax( n-p+1, sva( p ), 1 ) + p - 1
                       if( p/=q ) then
                          call stdlib_${ri}$swap( m, a( 1, p ), 1, a( 1, q ), 1 )
                          if( rsvec )call stdlib_${ri}$swap( mvl, v( 1, p ), 1,v( 1, q ), 1 )
                          temp1 = sva( p )
                          sva( p ) = sva( q )
                          sva( q ) = temp1
                          temp1 = work( p )
                          work( p ) = work( q )
                          work( q ) = temp1
                       end if
                       if( ir1==0 ) then
              ! column norms are periodically updated by explicit
              ! norm computation.
              ! caveat:
              ! unfortunately, some blas implementations compute stdlib_${ri}$nrm2(m,a(1,p),1)
              ! as sqrt(stdlib_${ri}$dot(m,a(1,p),1,a(1,p),1)), which may cause the result to
              ! overflow for ||a(:,p)||_2 > sqrt(overflow_threshold), and to
              ! underflow for ||a(:,p)||_2 < sqrt(underflow_threshold).
              ! hence, stdlib_${ri}$nrm2 cannot be trusted, not even in the case when
              ! the true norm is far from the under(over)flow boundaries.
              ! if properly implemented stdlib_${ri}$nrm2 is available, the if-then-else
              ! below should read "aapp = stdlib_${ri}$nrm2( m, a(1,p), 1 ) * work(p)".
                          if( ( sva( p )<rootbig ) .and.( sva( p )>rootsfmin ) ) then
                             sva( p ) = stdlib_${ri}$nrm2( m, a( 1, p ), 1 )*work( p )
                          else
                             temp1 = zero
                             aapp = one
                             call stdlib_${ri}$lassq( m, a( 1, p ), 1, temp1, aapp )
                             sva( p ) = temp1*sqrt( aapp )*work( p )
                          end if
                          aapp = sva( p )
                       else
                          aapp = sva( p )
                       end if
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2002: do q = p + 1, min( igl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
                                if( aaqq>=one ) then
                                   rotok = ( small*aapp )<=aaqq
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_${ri}$dot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_${ri}$copy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aapp,work( p ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_${ri}$dot( m, work( n+1 ), 1,a( 1, q ), 1 )*work( &
                                                q ) / aaqq
                                   end if
                                else
                                   rotok = aapp<=( aaqq / small )
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_${ri}$dot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_${ri}$copy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aaqq,work( q ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_${ri}$dot( m, work( n+1 ), 1,a( 1, p ), 1 )*work( &
                                                p ) / aapp
                                   end if
                                end if
                                mxaapq = max( mxaapq, abs( aapq ) )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq )>tol ) then
                 ! Rotate
      ! [rtd]      rotated = rotated + one
                                   if( ir1==0 ) then
                                      notrot = 0
                                      pskipped = 0
                                      iswrot = iswrot + 1
                                   end if
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs(aqoap-apoaq)/aapq
                                      if( abs( theta )>bigtheta ) then
                                         t = half / theta
                                         fastr( 3 ) = t*work( p ) / work( q )
                                         fastr( 4 ) = -t*work( q ) /work( p )
                                         call stdlib_${ri}$rotm( m, a( 1, p ), 1,a( 1, q ), 1, fastr )
                                                   
                                         if( rsvec )call stdlib_${ri}$rotm( mvl,v( 1, p ), 1,v( 1, q ),&
                                                    1,fastr )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq )
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         apoaq = work( p ) / work( q )
                                         aqoap = work( q ) / work( p )
                                         if( work( p )>=one ) then
                                            if( work( q )>=one ) then
                                               fastr( 3 ) = t*apoaq
                                               fastr( 4 ) = -t*aqoap
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q )*cs
                                               call stdlib_${ri}$rotm( m, a( 1, p ), 1,a( 1, q ), 1,&
                                                         fastr )
                                               if( rsvec )call stdlib_${ri}$rotm( mvl,v( 1, p ), 1, v( &
                                                         1, q ),1, fastr )
                                            else
                                               call stdlib_${ri}$axpy( m, -t*aqoap,a( 1, q ), 1,a( 1, &
                                                         p ), 1 )
                                               call stdlib_${ri}$axpy( m, cs*sn*apoaq,a( 1, p ), 1,a( &
                                                         1, q ), 1 )
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q ) / cs
                                               if( rsvec ) then
                                                  call stdlib_${ri}$axpy( mvl, -t*aqoap,v( 1, q ), 1,v(&
                                                             1, p ), 1 )
                                                  call stdlib_${ri}$axpy( mvl,cs*sn*apoaq,v( 1, p ), 1,&
                                                            v( 1, q ), 1 )
                                               end if
                                            end if
                                         else
                                            if( work( q )>=one ) then
                                               call stdlib_${ri}$axpy( m, t*apoaq,a( 1, p ), 1,a( 1, q &
                                                         ), 1 )
                                               call stdlib_${ri}$axpy( m, -cs*sn*aqoap,a( 1, q ), 1,a( &
                                                         1, p ), 1 )
                                               work( p ) = work( p ) / cs
                                               work( q ) = work( q )*cs
                                               if( rsvec ) then
                                                  call stdlib_${ri}$axpy( mvl, t*apoaq,v( 1, p ), 1,v( &
                                                            1, q ), 1 )
                                                  call stdlib_${ri}$axpy( mvl,-cs*sn*aqoap,v( 1, q ), &
                                                            1,v( 1, p ), 1 )
                                               end if
                                            else
                                               if( work( p )>=work( q ) )then
                                                  call stdlib_${ri}$axpy( m, -t*aqoap,a( 1, q ), 1,a( &
                                                            1, p ), 1 )
                                                  call stdlib_${ri}$axpy( m, cs*sn*apoaq,a( 1, p ), 1,&
                                                            a( 1, q ), 1 )
                                                  work( p ) = work( p )*cs
                                                  work( q ) = work( q ) / cs
                                                  if( rsvec ) then
                                                     call stdlib_${ri}$axpy( mvl,-t*aqoap,v( 1, q ), 1,&
                                                               v( 1, p ), 1 )
                                                     call stdlib_${ri}$axpy( mvl,cs*sn*apoaq,v( 1, p ),&
                                                                1,v( 1, q ), 1 )
                                                  end if
                                               else
                                                  call stdlib_${ri}$axpy( m, t*apoaq,a( 1, p ), 1,a( 1,&
                                                             q ), 1 )
                                                  call stdlib_${ri}$axpy( m,-cs*sn*aqoap,a( 1, q ), 1,&
                                                            a( 1, p ), 1 )
                                                  work( p ) = work( p ) / cs
                                                  work( q ) = work( q )*cs
                                                  if( rsvec ) then
                                                     call stdlib_${ri}$axpy( mvl,t*apoaq, v( 1, p ),1, &
                                                               v( 1, q ), 1 )
                                                     call stdlib_${ri}$axpy( mvl,-cs*sn*aqoap,v( 1, q )&
                                                               , 1,v( 1, p ), 1 )
                                                  end if
                                               end if
                                            end if
                                         end if
                                      end if
                                   else
                    ! .. have to use modified gram-schmidt like transformation
                                      call stdlib_${ri}$copy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aapp, one, m,1, work( n+1 ), &
                                                lda,ierr )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aaqq, one, m,1, a( 1, q ), &
                                                lda, ierr )
                                      temp1 = -aapq*work( p ) / work( q )
                                      call stdlib_${ri}$axpy( m, temp1, work( n+1 ), 1,a( 1, q ), 1 )
                                                
                                      call stdlib_${ri}$lascl( 'G', 0, 0, one, aaqq, m,1, a( 1, q ), &
                                                lda, ierr )
                                      sva( q ) = aaqq*sqrt( max( zero,one-aapq*aapq ) )
                                      mxsinj = max( mxsinj, sfmin )
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! recompute sva(q), sva(p).
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_${ri}$nrm2( m, a( 1, q ), 1 )*work( q )
                                                   
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_${ri}$lassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )*work( q )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_${ri}$nrm2( m, a( 1, p ), 1 )*work( p )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_${ri}$lassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )*work( p )
                                      end if
                                      sva( p ) = aapp
                                   end if
                                else
              ! a(:,p) and a(:,q) already numerically orthogonal
                                   if( ir1==0 )notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                end if
                             else
              ! a(:,q) is zero column
                                if( ir1==0 )notrot = notrot + 1
                                pskipped = pskipped + 1
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                if( ir1==0 )aapp = -aapp
                                notrot = 0
                                go to 2103
                             end if
                          end do loop_2002
           ! end q-loop
           2103 continue
           ! bailed out of q-loop
                          sva( p ) = aapp
                       else
                          sva( p ) = aapp
                          if( ( ir1==0 ) .and. ( aapp==zero ) )notrot = notrot + min( igl+kbl-1, &
                                    n ) - p
                       end if
                    end do loop_2001
           ! end of the p-loop
           ! end of doing the block ( ibr, ibr )
                 end do loop_1002
           ! end of ir1-loop
       ! ... go to the off diagonal blocks
                 igl = ( ibr-1 )*kbl + 1
                 loop_2010: do jbc = ibr + 1, nbl
                    jgl = ( jbc-1 )*kbl + 1
              ! doing the block at ( ibr, jbc )
                    ijblsk = 0
                    loop_2100: do p = igl, min( igl+kbl-1, n )
                       aapp = sva( p )
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2200: do q = jgl, min( jgl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
           ! M X 2 Jacobi Svd 
              ! safe gram matrix computation
                                if( aaqq>=one ) then
                                   if( aapp>=aaqq ) then
                                      rotok = ( small*aapp )<=aaqq
                                   else
                                      rotok = ( small*aaqq )<=aapp
                                   end if
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_${ri}$dot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_${ri}$copy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aapp,work( p ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_${ri}$dot( m, work( n+1 ), 1,a( 1, q ), 1 )*work( &
                                                q ) / aaqq
                                   end if
                                else
                                   if( aapp>=aaqq ) then
                                      rotok = aapp<=( aaqq / small )
                                   else
                                      rotok = aaqq<=( aapp / small )
                                   end if
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_${ri}$dot( m, a( 1, p ), 1, a( 1,q ), 1 )*work( &
                                                p )*work( q ) /aaqq ) / aapp
                                   else
                                      call stdlib_${ri}$copy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                      call stdlib_${ri}$lascl( 'G', 0, 0, aaqq,work( q ), m, 1,work( n+&
                                                1 ), lda, ierr )
                                      aapq = stdlib_${ri}$dot( m, work( n+1 ), 1,a( 1, p ), 1 )*work( &
                                                p ) / aapp
                                   end if
                                end if
                                mxaapq = max( mxaapq, abs( aapq ) )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq )>tol ) then
                                   notrot = 0
      ! [rtd]      rotated  = rotated + 1
                                   pskipped = 0
                                   iswrot = iswrot + 1
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs(aqoap-apoaq)/aapq
                                      if( aaqq>aapp0 )theta = -theta
                                      if( abs( theta )>bigtheta ) then
                                         t = half / theta
                                         fastr( 3 ) = t*work( p ) / work( q )
                                         fastr( 4 ) = -t*work( q ) /work( p )
                                         call stdlib_${ri}$rotm( m, a( 1, p ), 1,a( 1, q ), 1, fastr )
                                                   
                                         if( rsvec )call stdlib_${ri}$rotm( mvl,v( 1, p ), 1,v( 1, q ),&
                                                    1,fastr )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq )
                                         if( aaqq>aapp0 )thsign = -thsign
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq ) )
                                         apoaq = work( p ) / work( q )
                                         aqoap = work( q ) / work( p )
                                         if( work( p )>=one ) then
                                            if( work( q )>=one ) then
                                               fastr( 3 ) = t*apoaq
                                               fastr( 4 ) = -t*aqoap
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q )*cs
                                               call stdlib_${ri}$rotm( m, a( 1, p ), 1,a( 1, q ), 1,&
                                                         fastr )
                                               if( rsvec )call stdlib_${ri}$rotm( mvl,v( 1, p ), 1, v( &
                                                         1, q ),1, fastr )
                                            else
                                               call stdlib_${ri}$axpy( m, -t*aqoap,a( 1, q ), 1,a( 1, &
                                                         p ), 1 )
                                               call stdlib_${ri}$axpy( m, cs*sn*apoaq,a( 1, p ), 1,a( &
                                                         1, q ), 1 )
                                               if( rsvec ) then
                                                  call stdlib_${ri}$axpy( mvl, -t*aqoap,v( 1, q ), 1,v(&
                                                             1, p ), 1 )
                                                  call stdlib_${ri}$axpy( mvl,cs*sn*apoaq,v( 1, p ), 1,&
                                                            v( 1, q ), 1 )
                                               end if
                                               work( p ) = work( p )*cs
                                               work( q ) = work( q ) / cs
                                            end if
                                         else
                                            if( work( q )>=one ) then
                                               call stdlib_${ri}$axpy( m, t*apoaq,a( 1, p ), 1,a( 1, q &
                                                         ), 1 )
                                               call stdlib_${ri}$axpy( m, -cs*sn*aqoap,a( 1, q ), 1,a( &
                                                         1, p ), 1 )
                                               if( rsvec ) then
                                                  call stdlib_${ri}$axpy( mvl, t*apoaq,v( 1, p ), 1,v( &
                                                            1, q ), 1 )
                                                  call stdlib_${ri}$axpy( mvl,-cs*sn*aqoap,v( 1, q ), &
                                                            1,v( 1, p ), 1 )
                                               end if
                                               work( p ) = work( p ) / cs
                                               work( q ) = work( q )*cs
                                            else
                                               if( work( p )>=work( q ) )then
                                                  call stdlib_${ri}$axpy( m, -t*aqoap,a( 1, q ), 1,a( &
                                                            1, p ), 1 )
                                                  call stdlib_${ri}$axpy( m, cs*sn*apoaq,a( 1, p ), 1,&
                                                            a( 1, q ), 1 )
                                                  work( p ) = work( p )*cs
                                                  work( q ) = work( q ) / cs
                                                  if( rsvec ) then
                                                     call stdlib_${ri}$axpy( mvl,-t*aqoap,v( 1, q ), 1,&
                                                               v( 1, p ), 1 )
                                                     call stdlib_${ri}$axpy( mvl,cs*sn*apoaq,v( 1, p ),&
                                                                1,v( 1, q ), 1 )
                                                  end if
                                               else
                                                  call stdlib_${ri}$axpy( m, t*apoaq,a( 1, p ), 1,a( 1,&
                                                             q ), 1 )
                                                  call stdlib_${ri}$axpy( m,-cs*sn*aqoap,a( 1, q ), 1,&
                                                            a( 1, p ), 1 )
                                                  work( p ) = work( p ) / cs
                                                  work( q ) = work( q )*cs
                                                  if( rsvec ) then
                                                     call stdlib_${ri}$axpy( mvl,t*apoaq, v( 1, p ),1, &
                                                               v( 1, q ), 1 )
                                                     call stdlib_${ri}$axpy( mvl,-cs*sn*aqoap,v( 1, q )&
                                                               , 1,v( 1, p ), 1 )
                                                  end if
                                               end if
                                            end if
                                         end if
                                      end if
                                   else
                                      if( aapp>aaqq ) then
                                         call stdlib_${ri}$copy( m, a( 1, p ), 1,work( n+1 ), 1 )
                                                   
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aapp, one,m, 1, work( n+1 &
                                                   ), lda,ierr )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aaqq, one,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         temp1 = -aapq*work( p ) / work( q )
                                         call stdlib_${ri}$axpy( m, temp1, work( n+1 ),1, a( 1, q ), 1 &
                                                   )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, one, aaqq,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         sva( q ) = aaqq*sqrt( max( zero,one-aapq*aapq ) )
                                         mxsinj = max( mxsinj, sfmin )
                                      else
                                         call stdlib_${ri}$copy( m, a( 1, q ), 1,work( n+1 ), 1 )
                                                   
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aaqq, one,m, 1, work( n+1 &
                                                   ), lda,ierr )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, aapp, one,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         temp1 = -aapq*work( q ) / work( p )
                                         call stdlib_${ri}$axpy( m, temp1, work( n+1 ),1, a( 1, p ), 1 &
                                                   )
                                         call stdlib_${ri}$lascl( 'G', 0, 0, one, aapp,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         sva( p ) = aapp*sqrt( max( zero,one-aapq*aapq ) )
                                         mxsinj = max( mxsinj, sfmin )
                                      end if
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q)
                 ! .. recompute sva(q)
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_${ri}$nrm2( m, a( 1, q ), 1 )*work( q )
                                                   
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_${ri}$lassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )*work( q )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )**2<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_${ri}$nrm2( m, a( 1, p ), 1 )*work( p )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_${ri}$lassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )*work( p )
                                      end if
                                      sva( p ) = aapp
                                   end if
                    ! end of ok rotation
                                else
                                   notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                   ijblsk = ijblsk + 1
                                end if
                             else
                                notrot = notrot + 1
                                pskipped = pskipped + 1
                                ijblsk = ijblsk + 1
                             end if
                             if( ( i<=swband ) .and. ( ijblsk>=blskip ) )then
                                sva( p ) = aapp
                                notrot = 0
                                go to 2011
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                aapp = -aapp
                                notrot = 0
                                go to 2203
                             end if
                          end do loop_2200
              ! end of the q-loop
              2203 continue
                          sva( p ) = aapp
                       else
                          if( aapp==zero )notrot = notrot +min( jgl+kbl-1, n ) - jgl + 1
                          if( aapp<zero )notrot = 0
                       end if
                    end do loop_2100
           ! end of the p-loop
                 end do loop_2010
           ! end of the jbc-loop
           2011 continue
      ! 2011 bailed out of the jbc-loop
                 do p = igl, min( igl+kbl-1, n )
                    sva( p ) = abs( sva( p ) )
                 end do
      ! **
              end do loop_2000
      ! 2000 :: end of the ibr-loop
           ! .. update sva(n)
              if( ( sva( n )<rootbig ) .and. ( sva( n )>rootsfmin ) )then
                 sva( n ) = stdlib_${ri}$nrm2( m, a( 1, n ), 1 )*work( n )
              else
                 t = zero
                 aapp = one
                 call stdlib_${ri}$lassq( m, a( 1, n ), 1, t, aapp )
                 sva( n ) = t*sqrt( aapp )*work( n )
              end if
           ! additional steering devices
              if( ( i<swband ) .and. ( ( mxaapq<=roottol ) .or.( iswrot<=n ) ) )swband = i
              if( ( i>swband+1 ) .and. ( mxaapq<sqrt( real( n,KIND=${rk}$) )*tol ) .and. ( real( n,&
                        KIND=${rk}$)*mxaapq*mxsinj<tol ) ) then
                 go to 1994
              end if
              if( notrot>=emptsw )go to 1994
           end do loop_1993
           ! end i=1:nsweep loop
       ! #:( reaching this point means that the procedure has not converged.
           info = nsweep - 1
           go to 1995
           1994 continue
       ! #:) reaching this point means numerical convergence after the i-th
           ! sweep.
           info = 0
       ! #:) info = 0 confirms successful iterations.
       1995 continue
           ! sort the singular values and find how many are above
           ! the underflow threshold.
           n2 = 0
           n4 = 0
           do p = 1, n - 1
              q = stdlib_i${ri}$amax( n-p+1, sva( p ), 1 ) + p - 1
              if( p/=q ) then
                 temp1 = sva( p )
                 sva( p ) = sva( q )
                 sva( q ) = temp1
                 temp1 = work( p )
                 work( p ) = work( q )
                 work( q ) = temp1
                 call stdlib_${ri}$swap( m, a( 1, p ), 1, a( 1, q ), 1 )
                 if( rsvec )call stdlib_${ri}$swap( mvl, v( 1, p ), 1, v( 1, q ), 1 )
              end if
              if( sva( p )/=zero ) then
                 n4 = n4 + 1
                 if( sva( p )*skl>sfmin )n2 = n2 + 1
              end if
           end do
           if( sva( n )/=zero ) then
              n4 = n4 + 1
              if( sva( n )*skl>sfmin )n2 = n2 + 1
           end if
           ! normalize the left singular vectors.
           if( lsvec .or. uctol ) then
              do p = 1, n2
                 call stdlib_${ri}$scal( m, work( p ) / sva( p ), a( 1, p ), 1 )
              end do
           end if
           ! scale the product of jacobi rotations (assemble the fast rotations).
           if( rsvec ) then
              if( applv ) then
                 do p = 1, n
                    call stdlib_${ri}$scal( mvl, work( p ), v( 1, p ), 1 )
                 end do
              else
                 do p = 1, n
                    temp1 = one / stdlib_${ri}$nrm2( mvl, v( 1, p ), 1 )
                    call stdlib_${ri}$scal( mvl, temp1, v( 1, p ), 1 )
                 end do
              end if
           end if
           ! undo scaling, if necessary (and possible).
           if( ( ( skl>one ) .and. ( sva( 1 )<( big / skl) ) ).or. ( ( skl<one ) .and. ( sva( max(&
                      n2, 1 ) ) >( sfmin / skl) ) ) ) then
              do p = 1, n
                 sva( p ) = skl*sva( p )
              end do
              skl= one
           end if
           work( 1 ) = skl
           ! the singular values of a are skl*sva(1:n). if skl/=one
           ! then some of the singular values may overflow or underflow and
           ! the spectrum is given in this factored representation.
           work( 2 ) = real( n4,KIND=${rk}$)
           ! n4 is the number of computed nonzero singular values of a.
           work( 3 ) = real( n2,KIND=${rk}$)
           ! n2 is the number of singular values of a greater than sfmin.
           ! if n2<n, sva(n2:n) contains zeros and/or denormalized numbers
           ! that may carry some information.
           work( 4 ) = real( i,KIND=${rk}$)
           ! i is the index of the last sweep before declaring convergence.
           work( 5 ) = mxaapq
           ! mxaapq is the largest absolute value of scaled pivots in the
           ! last sweep
           work( 6 ) = mxsinj
           ! mxsinj is the largest absolute value of the sines of jacobi angles
           ! in the last sweep
           return
     end subroutine stdlib_${ri}$gesvj

#:endif
#:endfor

     module pure subroutine stdlib_cgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, cwork, lwork, &
     rwork, lrwork, info )
     !! CGESVJ computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N unitary matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldv, lwork, lrwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), v(ldv,*), cwork(lwork)
           real(sp), intent(inout) :: rwork(lrwork)
           real(sp), intent(out) :: sva(n)
        ! =====================================================================
           ! Local Parameters 
           integer(ilp), parameter :: nsweep = 30
           
           
           
           ! Local Scalars 
           complex(sp) :: aapq, ompq
           real(sp) :: aapp, aapp0, aapq1, aaqq, apoaq, aqoap, big, bigtheta, cs, ctol, epsln, &
           mxaapq, mxsinj, rootbig, rooteps, rootsfmin, roottol, skl, sfmin, small, sn, t, temp1, &
                     theta, thsign, tol
           integer(ilp) :: blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1, iswrot, jbc, jgl, kbl, &
                     lkahead, mvl, n2, n34, n4, nbl, notrot, p, pskipped, q, rowskip, swband
           logical(lk) :: applv, goscale, lower, lquery, lsvec, noscale, rotok, rsvec, uctol, &
                     upper
           ! Intrinsic Functions 
           ! from lapack
           ! from lapack
           ! Executable Statements 
           ! test the input arguments
           lsvec = stdlib_lsame( jobu, 'U' ) .or. stdlib_lsame( jobu, 'F' )
           uctol = stdlib_lsame( jobu, 'C' )
           rsvec = stdlib_lsame( jobv, 'V' ) .or. stdlib_lsame( jobv, 'J' )
           applv = stdlib_lsame( jobv, 'A' )
           upper = stdlib_lsame( joba, 'U' )
           lower = stdlib_lsame( joba, 'L' )
           lquery = ( lwork == -1 ) .or. ( lrwork == -1 )
           if( .not.( upper .or. lower .or. stdlib_lsame( joba, 'G' ) ) ) then
              info = -1
           else if( .not.( lsvec .or. uctol .or. stdlib_lsame( jobu, 'N' ) ) ) then
              info = -2
           else if( .not.( rsvec .or. applv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( ( n<0 ) .or. ( n>m ) ) then
              info = -5
           else if( lda<m ) then
              info = -7
           else if( mv<0 ) then
              info = -9
           else if( ( rsvec .and. ( ldv<n ) ) .or.( applv .and. ( ldv<mv ) ) ) then
              info = -11
           else if( uctol .and. ( rwork( 1 )<=one ) ) then
              info = -12
           else if( lwork<( m+n ) .and. ( .not.lquery ) ) then
              info = -13
           else if( lrwork<max( n, 6 ) .and. ( .not.lquery ) ) then
              info = -15
           else
              info = 0
           end if
           ! #:(
           if( info/=0 ) then
              call stdlib_xerbla( 'CGESVJ', -info )
              return
           else if ( lquery ) then
              cwork(1) = m + n
              rwork(1) = max( n, 6 )
              return
           end if
       ! #:) quick return for void matrix
           if( ( m==0 ) .or. ( n==0 ) )return
           ! set numerical parameters
           ! the stopping criterion for jacobi rotations is
           ! max_{i<>j}|a(:,i)^* * a(:,j)| / (||a(:,i)||*||a(:,j)||) < ctol*eps
           ! where eps is the round-off and ctol is defined as follows:
           if( uctol ) then
              ! ... user controlled
              ctol = rwork( 1 )
           else
              ! ... default
              if( lsvec .or. rsvec .or. applv ) then
                 ctol = sqrt( real( m,KIND=sp) )
              else
                 ctol = real( m,KIND=sp)
              end if
           end if
           ! ... and the machine dependent parameters are
      ! [!]  (make sure that stdlib_slamch() works properly on the target machine.)
           epsln = stdlib_slamch( 'EPSILON' )
           rooteps = sqrt( epsln )
           sfmin = stdlib_slamch( 'SAFEMINIMUM' )
           rootsfmin = sqrt( sfmin )
           small = sfmin / epsln
            ! big = stdlib_slamch( 'overflow' )
           big     = one  / sfmin
           rootbig = one / rootsfmin
           ! large = big / sqrt( real( m*n,KIND=sp) )
           bigtheta = one / rooteps
           tol = ctol*epsln
           roottol = sqrt( tol )
           if( real( m,KIND=sp)*epsln>=one ) then
              info = -4
              call stdlib_xerbla( 'CGESVJ', -info )
              return
           end if
           ! initialize the right singular vector matrix.
           if( rsvec ) then
              mvl = n
              call stdlib_claset( 'A', mvl, n, czero, cone, v, ldv )
           else if( applv ) then
              mvl = mv
           end if
           rsvec = rsvec .or. applv
           ! initialize sva( 1:n ) = ( ||a e_i||_2, i = 1:n )
      ! (!)  if necessary, scale a to protect the largest singular value
           ! from overflow. it is possible that saving the largest singular
           ! value destroys the information about the small ones.
           ! this initial scaling is almost minimal in the sense that the
           ! goal is to make sure that no column norm overflows, and that
           ! sqrt(n)*max_i sva(i) does not overflow. if infinite entries
           ! in a are detected, the procedure returns with info=-6.
           skl = one / sqrt( real( m,KIND=sp)*real( n,KIND=sp) )
           noscale = .true.
           goscale = .true.
           if( lower ) then
              ! the input matrix is m-by-n lower triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_classq( m-p+1, a( p, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'CGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else if( upper ) then
              ! the input matrix is m-by-n upper triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_classq( p, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'CGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else
              ! the input matrix is m-by-n general dense
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_classq( m, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'CGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           end if
           if( noscale )skl = one
           ! move the smaller part of the spectrum from the underflow threshold
      ! (!)  start by determining the position of the nonzero entries of the
           ! array sva() relative to ( sfmin, big ).
           aapp = zero
           aaqq = big
           do p = 1, n
              if( sva( p )/=zero )aaqq = min( aaqq, sva( p ) )
              aapp = max( aapp, sva( p ) )
           end do
       ! #:) quick return for zero matrix
           if( aapp==zero ) then
              if( lsvec )call stdlib_claset( 'G', m, n, czero, cone, a, lda )
              rwork( 1 ) = one
              rwork( 2 ) = zero
              rwork( 3 ) = zero
              rwork( 4 ) = zero
              rwork( 5 ) = zero
              rwork( 6 ) = zero
              return
           end if
       ! #:) quick return for one-column matrix
           if( n==1 ) then
              if( lsvec )call stdlib_clascl( 'G', 0, 0, sva( 1 ), skl, m, 1,a( 1, 1 ), lda, ierr )
                        
              rwork( 1 ) = one / skl
              if( sva( 1 )>=sfmin ) then
                 rwork( 2 ) = one
              else
                 rwork( 2 ) = zero
              end if
              rwork( 3 ) = zero
              rwork( 4 ) = zero
              rwork( 5 ) = zero
              rwork( 6 ) = zero
              return
           end if
           ! protect small singular values from underflow, and try to
           ! avoid underflows/overflows in computing jacobi rotations.
           sn = sqrt( sfmin / epsln )
           temp1 = sqrt( big / real( n,KIND=sp) )
           if( ( aapp<=sn ) .or. ( aaqq>=temp1 ) .or.( ( sn<=aaqq ) .and. ( aapp<=temp1 ) ) ) &
                     then
              temp1 = min( big, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp<=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( aapp*sqrt( real( n,KIND=sp) ) ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq>=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = max( sn / aaqq, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( sqrt( real( n,KIND=sp) )*aapp ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else
              temp1 = one
           end if
           ! scale, if necessary
           if( temp1/=one ) then
              call stdlib_slascl( 'G', 0, 0, one, temp1, n, 1, sva, n, ierr )
           end if
           skl = temp1*skl
           if( skl/=one ) then
              call stdlib_clascl( joba, 0, 0, one, skl, m, n, a, lda, ierr )
              skl = one / skl
           end if
           ! row-cyclic jacobi svd algorithm with column pivoting
           emptsw = ( n*( n-1 ) ) / 2
           notrot = 0
           do q = 1, n
              cwork( q ) = cone
           end do
           swband = 3
      ! [tp] swband is a tuning parameter [tp]. it is meaningful and effective
           ! if stdlib_cgesvj is used as a computational routine in the preconditioned
           ! jacobi svd algorithm stdlib_cgejsv. for sweeps i=1:swband the procedure
           ! works on pivots inside a band-like region around the diagonal.
           ! the boundaries are determined dynamically, based on the number of
           ! pivots above a threshold.
           kbl = min( 8, n )
      ! [tp] kbl is a tuning parameter that defines the tile size in the
           ! tiling of the p-q loops of pivot pairs. in general, an optimal
           ! value of kbl depends on the matrix dimensions and on the
           ! parameters of the computer's memory.
           nbl = n / kbl
           if( ( nbl*kbl )/=n )nbl = nbl + 1
           blskip = kbl**2
      ! [tp] blkskip is a tuning parameter that depends on swband and kbl.
           rowskip = min( 5, kbl )
      ! [tp] rowskip is a tuning parameter.
           lkahead = 1
      ! [tp] lkahead is a tuning parameter.
           ! quasi block transformations, using the lower (upper) triangular
           ! structure of the input matrix. the quasi-block-cycling usually
           ! invokes cubic convergence. big part of this cycle is done inside
           ! canonical subspaces of dimensions less than m.
           if( ( lower .or. upper ) .and. ( n>max( 64, 4*kbl ) ) ) then
      ! [tp] the number of partition levels and the actual partition are
           ! tuning parameters.
              n4 = n / 4
              n2 = n / 2
              n34 = 3*n4
              if( applv ) then
                 q = 0
              else
                 q = 1
              end if
              if( lower ) then
           ! this works very well on lower triangular matrices, in particular
           ! in the framework of the preconditioned jacobi svd (xgejsv).
           ! the idea is simple:
           ! [+ 0 0 0]   note that jacobi transformations of [0 0]
           ! [+ + 0 0]                                       [0 0]
           ! [+ + x 0]   actually work on [x 0]              [x 0]
           ! [+ + x x]                    [x x].             [x x]
                 call stdlib_cgsvj0( jobv, m-n34, n-n34, a( n34+1, n34+1 ), lda,cwork( n34+1 ), &
                 sva( n34+1 ), mvl,v( n34*q+1, n34+1 ), ldv, epsln, sfmin, tol,2, cwork( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_cgsvj0( jobv, m-n2, n34-n2, a( n2+1, n2+1 ), lda,cwork( n2+1 ), sva( &
                 n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 2,cwork( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_cgsvj1( jobv, m-n2, n-n2, n4, a( n2+1, n2+1 ), lda,cwork( n2+1 ), &
                 sva( n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_cgsvj0( jobv, m-n4, n2-n4, a( n4+1, n4+1 ), lda,cwork( n4+1 ), sva( &
                 n4+1 ), mvl,v( n4*q+1, n4+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_cgsvj0( jobv, m, n4, a, lda, cwork, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 1, cwork( n+1 ), lwork-n,ierr )
                 call stdlib_cgsvj1( jobv, m, n2, n4, a, lda, cwork, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, cwork( n+1 ),lwork-n, ierr )
              else if( upper ) then
                 call stdlib_cgsvj0( jobv, n4, n4, a, lda, cwork, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 2, cwork( n+1 ), lwork-n,ierr )
                 call stdlib_cgsvj0( jobv, n2, n4, a( 1, n4+1 ), lda, cwork( n4+1 ),sva( n4+1 ), &
                 mvl, v( n4*q+1, n4+1 ), ldv,epsln, sfmin, tol, 1, cwork( n+1 ), lwork-n,ierr )
                           
                 call stdlib_cgsvj1( jobv, n2, n2, n4, a, lda, cwork, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, cwork( n+1 ),lwork-n, ierr )
                 call stdlib_cgsvj0( jobv, n2+n4, n4, a( 1, n2+1 ), lda,cwork( n2+1 ), sva( n2+1 )&
                 , mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), lwork-n, ierr )
                           
              end if
           end if
           ! .. row-cyclic pivot strategy with de rijk's pivoting ..
           loop_1993: do i = 1, nsweep
           ! .. go go go ...
              mxaapq = zero
              mxsinj = zero
              iswrot = 0
              notrot = 0
              pskipped = 0
           ! each sweep is unrolled using kbl-by-kbl tiles over the pivot pairs
           ! 1 <= p < q <= n. this is the first step toward a blocked implementation
           ! of the rotations. new implementation, based on block transformations,
           ! is under development.
              loop_2000: do ibr = 1, nbl
                 igl = ( ibr-1 )*kbl + 1
                 loop_1002: do ir1 = 0, min( lkahead, nbl-ibr )
                    igl = igl + ir1*kbl
                    loop_2001: do p = igl, min( igl+kbl-1, n-1 )
           ! .. de rijk's pivoting
                       q = stdlib_isamax( n-p+1, sva( p ), 1 ) + p - 1
                       if( p/=q ) then
                          call stdlib_cswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                          if( rsvec )call stdlib_cswap( mvl, v( 1, p ), 1,v( 1, q ), 1 )
                          temp1 = sva( p )
                          sva( p ) = sva( q )
                          sva( q ) = temp1
                          aapq = cwork(p)
                          cwork(p) = cwork(q)
                          cwork(q) = aapq
                       end if
                       if( ir1==0 ) then
              ! column norms are periodically updated by explicit
              ! norm computation.
      ! [!]     caveat:
              ! unfortunately, some blas implementations compute stdlib_scnrm2(m,a(1,p),1)
              ! as sqrt(s=stdlib_cdotc(m,a(1,p),1,a(1,p),1)), which may cause the result to
              ! overflow for ||a(:,p)||_2 > sqrt(overflow_threshold), and to
              ! underflow for ||a(:,p)||_2 < sqrt(underflow_threshold).
              ! hence, stdlib_scnrm2 cannot be trusted, not even in the case when
              ! the true norm is far from the under(over)flow boundaries.
              ! if properly implemented stdlib_scnrm2 is available, the if-then-else-end if
              ! below should be replaced with "aapp = stdlib_scnrm2( m, a(1,p), 1 )".
                          if( ( sva( p )<rootbig ) .and.( sva( p )>rootsfmin ) ) then
                             sva( p ) = stdlib_scnrm2( m, a( 1, p ), 1 )
                          else
                             temp1 = zero
                             aapp = one
                             call stdlib_classq( m, a( 1, p ), 1, temp1, aapp )
                             sva( p ) = temp1*sqrt( aapp )
                          end if
                          aapp = sva( p )
                       else
                          aapp = sva( p )
                       end if
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2002: do q = p + 1, min( igl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
                                if( aaqq>=one ) then
                                   rotok = ( small*aapp )<=aaqq
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_cdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aaqq ) / aapp
                                   else
                                      call stdlib_ccopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_clascl( 'G', 0, 0, aapp, one,m, 1, cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_cdotc( m, cwork(n+1), 1,a( 1, q ), 1 ) / &
                                                aaqq
                                   end if
                                else
                                   rotok = aapp<=( aaqq / small )
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_cdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aapp ) / aaqq
                                   else
                                      call stdlib_ccopy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                      call stdlib_clascl( 'G', 0, 0, aaqq,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_cdotc( m, a(1, p ), 1,cwork(n+1), 1 ) / &
                                                aapp
                                   end if
                                end if
                                 ! aapq = aapq * conjg( cwork(p) ) * cwork(q)
                                aapq1  = -abs(aapq)
                                mxaapq = max( mxaapq, -aapq1 )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq1 )>tol ) then
                                    ompq = aapq / abs(aapq)
                 ! Rotate
      ! [rtd]      rotated = rotated + one
                                   if( ir1==0 ) then
                                      notrot = 0
                                      pskipped = 0
                                      iswrot = iswrot + 1
                                   end if
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/aapq1
                                      if( abs( theta )>bigtheta ) then
                                         t  = half / theta
                                         cs = one
                                         call stdlib_crot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *t )
                                         if ( rsvec ) then
                                             call stdlib_crot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*t )
                                         end if
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq1 )
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         call stdlib_crot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *sn )
                                         if ( rsvec ) then
                                             call stdlib_crot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*sn )
                                         end if
                                      end if
                                      cwork(p) = -cwork(q) * ompq
                                      else
                    ! .. have to use modified gram-schmidt like transformation
                                      call stdlib_ccopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_clascl( 'G', 0, 0, aapp, one, m,1, cwork(n+1), &
                                                lda,ierr )
                                      call stdlib_clascl( 'G', 0, 0, aaqq, one, m,1, a( 1, q ), &
                                                lda, ierr )
                                      call stdlib_caxpy( m, -aapq, cwork(n+1), 1,a( 1, q ), 1 )
                                                
                                      call stdlib_clascl( 'G', 0, 0, one, aaqq, m,1, a( 1, q ), &
                                                lda, ierr )
                                      sva( q ) = aaqq*sqrt( max( zero,one-aapq1*aapq1 ) )
                                      mxsinj = max( mxsinj, sfmin )
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! recompute sva(q), sva(p).
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_scnrm2( m, a( 1, q ), 1 )
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_classq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_scnrm2( m, a( 1, p ), 1 )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_classq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )
                                      end if
                                      sva( p ) = aapp
                                   end if
                                else
                                   ! a(:,p) and a(:,q) already numerically orthogonal
                                   if( ir1==0 )notrot = notrot + 1
      ! [rtd]      skipped  = skipped + 1
                                   pskipped = pskipped + 1
                                end if
                             else
                                ! a(:,q) is zero column
                                if( ir1==0 )notrot = notrot + 1
                                pskipped = pskipped + 1
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                if( ir1==0 )aapp = -aapp
                                notrot = 0
                                go to 2103
                             end if
                          end do loop_2002
           ! end q-loop
           2103 continue
           ! bailed out of q-loop
                          sva( p ) = aapp
                       else
                          sva( p ) = aapp
                          if( ( ir1==0 ) .and. ( aapp==zero ) )notrot = notrot + min( igl+kbl-1, &
                                    n ) - p
                       end if
                    end do loop_2001
           ! end of the p-loop
           ! end of doing the block ( ibr, ibr )
                 end do loop_1002
           ! end of ir1-loop
       ! ... go to the off diagonal blocks
                 igl = ( ibr-1 )*kbl + 1
                 loop_2010: do jbc = ibr + 1, nbl
                    jgl = ( jbc-1 )*kbl + 1
              ! doing the block at ( ibr, jbc )
                    ijblsk = 0
                    loop_2100: do p = igl, min( igl+kbl-1, n )
                       aapp = sva( p )
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2200: do q = jgl, min( jgl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
           ! M X 2 Jacobi Svd 
              ! safe gram matrix computation
                                if( aaqq>=one ) then
                                   if( aapp>=aaqq ) then
                                      rotok = ( small*aapp )<=aaqq
                                   else
                                      rotok = ( small*aaqq )<=aapp
                                   end if
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_cdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aaqq ) / aapp
                                   else
                                      call stdlib_ccopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_clascl( 'G', 0, 0, aapp,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_cdotc( m, cwork(n+1), 1,a( 1, q ), 1 ) / &
                                                aaqq
                                   end if
                                else
                                   if( aapp>=aaqq ) then
                                      rotok = aapp<=( aaqq / small )
                                   else
                                      rotok = aaqq<=( aapp / small )
                                   end if
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_cdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / max(&
                                                aaqq,aapp) )/ min(aaqq,aapp)
                                   else
                                      call stdlib_ccopy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                      call stdlib_clascl( 'G', 0, 0, aaqq,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_cdotc( m, a( 1, p ), 1,cwork(n+1),  1 ) / &
                                                aapp
                                   end if
                                end if
                                 ! aapq = aapq * conjg(cwork(p))*cwork(q)
                                aapq1  = -abs(aapq)
                                mxaapq = max( mxaapq, -aapq1 )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq1 )>tol ) then
                                   ompq = aapq / abs(aapq)
                                   notrot = 0
      ! [rtd]      rotated  = rotated + 1
                                   pskipped = 0
                                   iswrot = iswrot + 1
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/ aapq1
                                      if( aaqq>aapp0 )theta = -theta
                                      if( abs( theta )>bigtheta ) then
                                         t  = half / theta
                                         cs = one
                                         call stdlib_crot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *t )
                                         if( rsvec ) then
                                             call stdlib_crot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*t )
                                         end if
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq1 )
                                         if( aaqq>aapp0 )thsign = -thsign
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         call stdlib_crot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *sn )
                                         if( rsvec ) then
                                             call stdlib_crot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*sn )
                                         end if
                                      end if
                                      cwork(p) = -cwork(q) * ompq
                                   else
                    ! .. have to use modified gram-schmidt like transformation
                                    if( aapp>aaqq ) then
                                         call stdlib_ccopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                                   
                                         call stdlib_clascl( 'G', 0, 0, aapp, one,m, 1, cwork(n+1)&
                                                   ,lda,ierr )
                                         call stdlib_clascl( 'G', 0, 0, aaqq, one,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         call stdlib_caxpy( m, -aapq, cwork(n+1),1, a( 1, q ), 1 )
                                                   
                                         call stdlib_clascl( 'G', 0, 0, one, aaqq,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         sva( q ) = aaqq*sqrt( max( zero,one-aapq1*aapq1 ) )
                                                   
                                         mxsinj = max( mxsinj, sfmin )
                                    else
                                        call stdlib_ccopy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                         call stdlib_clascl( 'G', 0, 0, aaqq, one,m, 1, cwork(n+1)&
                                                   ,lda,ierr )
                                         call stdlib_clascl( 'G', 0, 0, aapp, one,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         call stdlib_caxpy( m, -conjg(aapq),cwork(n+1), 1, a( 1, &
                                                   p ), 1 )
                                         call stdlib_clascl( 'G', 0, 0, one, aapp,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         sva( p ) = aapp*sqrt( max( zero,one-aapq1*aapq1 ) )
                                                   
                                         mxsinj = max( mxsinj, sfmin )
                                    end if
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! .. recompute sva(q), sva(p)
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_scnrm2( m, a( 1, q ), 1)
                                       else
                                         t = zero
                                         aaqq = one
                                         call stdlib_classq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )**2<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_scnrm2( m, a( 1, p ), 1 )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_classq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )
                                      end if
                                      sva( p ) = aapp
                                   end if
                    ! end of ok rotation
                                else
                                   notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                   ijblsk = ijblsk + 1
                                end if
                             else
                                notrot = notrot + 1
                                pskipped = pskipped + 1
                                ijblsk = ijblsk + 1
                             end if
                             if( ( i<=swband ) .and. ( ijblsk>=blskip ) )then
                                sva( p ) = aapp
                                notrot = 0
                                go to 2011
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                aapp = -aapp
                                notrot = 0
                                go to 2203
                             end if
                          end do loop_2200
              ! end of the q-loop
              2203 continue
                          sva( p ) = aapp
                       else
                          if( aapp==zero )notrot = notrot +min( jgl+kbl-1, n ) - jgl + 1
                          if( aapp<zero )notrot = 0
                       end if
                    end do loop_2100
           ! end of the p-loop
                 end do loop_2010
           ! end of the jbc-loop
           2011 continue
      ! 2011 bailed out of the jbc-loop
                 do p = igl, min( igl+kbl-1, n )
                    sva( p ) = abs( sva( p ) )
                 end do
      ! **
              end do loop_2000
      ! 2000 :: end of the ibr-loop
           ! .. update sva(n)
              if( ( sva( n )<rootbig ) .and. ( sva( n )>rootsfmin ) )then
                 sva( n ) = stdlib_scnrm2( m, a( 1, n ), 1 )
              else
                 t = zero
                 aapp = one
                 call stdlib_classq( m, a( 1, n ), 1, t, aapp )
                 sva( n ) = t*sqrt( aapp )
              end if
           ! additional steering devices
              if( ( i<swband ) .and. ( ( mxaapq<=roottol ) .or.( iswrot<=n ) ) )swband = i
              if( ( i>swband+1 ) .and. ( mxaapq<sqrt( real( n,KIND=sp) )*tol ) .and. ( real( n,&
                        KIND=sp)*mxaapq*mxsinj<tol ) ) then
                 go to 1994
              end if
              if( notrot>=emptsw )go to 1994
           end do loop_1993
           ! end i=1:nsweep loop
       ! #:( reaching this point means that the procedure has not converged.
           info = nsweep - 1
           go to 1995
           1994 continue
       ! #:) reaching this point means numerical convergence after the i-th
           ! sweep.
           info = 0
       ! #:) info = 0 confirms successful iterations.
       1995 continue
           ! sort the singular values and find how many are above
           ! the underflow threshold.
           n2 = 0
           n4 = 0
           do p = 1, n - 1
              q = stdlib_isamax( n-p+1, sva( p ), 1 ) + p - 1
              if( p/=q ) then
                 temp1 = sva( p )
                 sva( p ) = sva( q )
                 sva( q ) = temp1
                 call stdlib_cswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                 if( rsvec )call stdlib_cswap( mvl, v( 1, p ), 1, v( 1, q ), 1 )
              end if
              if( sva( p )/=zero ) then
                 n4 = n4 + 1
                 if( sva( p )*skl>sfmin )n2 = n2 + 1
              end if
           end do
           if( sva( n )/=zero ) then
              n4 = n4 + 1
              if( sva( n )*skl>sfmin )n2 = n2 + 1
           end if
           ! normalize the left singular vectors.
           if( lsvec .or. uctol ) then
              do p = 1, n4
                 ! call stdlib_csscal( m, one / sva( p ), a( 1, p ), 1 )
                 call stdlib_clascl( 'G',0,0, sva(p), one, m, 1, a(1,p), m, ierr )
              end do
           end if
           ! scale the product of jacobi rotations.
           if( rsvec ) then
                 do p = 1, n
                    temp1 = one / stdlib_scnrm2( mvl, v( 1, p ), 1 )
                    call stdlib_csscal( mvl, temp1, v( 1, p ), 1 )
                 end do
           end if
           ! undo scaling, if necessary (and possible).
           if( ( ( skl>one ) .and. ( sva( 1 )<( big / skl ) ) ).or. ( ( skl<one ) .and. ( sva( &
                     max( n2, 1 ) ) >( sfmin / skl ) ) ) ) then
              do p = 1, n
                 sva( p ) = skl*sva( p )
              end do
              skl = one
           end if
           rwork( 1 ) = skl
           ! the singular values of a are skl*sva(1:n). if skl/=one
           ! then some of the singular values may overflow or underflow and
           ! the spectrum is given in this factored representation.
           rwork( 2 ) = real( n4,KIND=sp)
           ! n4 is the number of computed nonzero singular values of a.
           rwork( 3 ) = real( n2,KIND=sp)
           ! n2 is the number of singular values of a greater than sfmin.
           ! if n2<n, sva(n2:n) contains zeros and/or denormalized numbers
           ! that may carry some information.
           rwork( 4 ) = real( i,KIND=sp)
           ! i is the index of the last sweep before declaring convergence.
           rwork( 5 ) = mxaapq
           ! mxaapq is the largest absolute value of scaled pivots in the
           ! last sweep
           rwork( 6 ) = mxsinj
           ! mxsinj is the largest absolute value of the sines of jacobi angles
           ! in the last sweep
           return
     end subroutine stdlib_cgesvj

     module pure subroutine stdlib_zgesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, cwork, lwork, rwork, lrwork, info )
     !! ZGESVJ computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N unitary matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldv, lwork, lrwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*), v(ldv,*), cwork(lwork)
           real(dp), intent(inout) :: rwork(lrwork)
           real(dp), intent(out) :: sva(n)
        ! =====================================================================
           ! Local Parameters 
           integer(ilp), parameter :: nsweep = 30
           
           
           
           ! Local Scalars 
           complex(dp) :: aapq, ompq
           real(dp) :: aapp, aapp0, aapq1, aaqq, apoaq, aqoap, big, bigtheta, cs, ctol, epsln, &
           mxaapq, mxsinj, rootbig, rooteps, rootsfmin, roottol, skl, sfmin, small, sn, t, temp1, &
                     theta, thsign, tol
           integer(ilp) :: blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1, iswrot, jbc, jgl, kbl, &
                     lkahead, mvl, n2, n34, n4, nbl, notrot, p, pskipped, q, rowskip, swband
           logical(lk) :: applv, goscale, lower, lquery, lsvec, noscale, rotok, rsvec, uctol, &
                     upper
           ! Intrinsic Functions 
           ! from lapack
           ! from lapack
           ! Executable Statements 
           ! test the input arguments
           lsvec = stdlib_lsame( jobu, 'U' ) .or. stdlib_lsame( jobu, 'F' )
           uctol = stdlib_lsame( jobu, 'C' )
           rsvec = stdlib_lsame( jobv, 'V' ) .or. stdlib_lsame( jobv, 'J' )
           applv = stdlib_lsame( jobv, 'A' )
           upper = stdlib_lsame( joba, 'U' )
           lower = stdlib_lsame( joba, 'L' )
           lquery = ( lwork == -1 ) .or. ( lrwork == -1 )
           if( .not.( upper .or. lower .or. stdlib_lsame( joba, 'G' ) ) ) then
              info = -1
           else if( .not.( lsvec .or. uctol .or. stdlib_lsame( jobu, 'N' ) ) ) then
              info = -2
           else if( .not.( rsvec .or. applv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( ( n<0 ) .or. ( n>m ) ) then
              info = -5
           else if( lda<m ) then
              info = -7
           else if( mv<0 ) then
              info = -9
           else if( ( rsvec .and. ( ldv<n ) ) .or.( applv .and. ( ldv<mv ) ) ) then
              info = -11
           else if( uctol .and. ( rwork( 1 )<=one ) ) then
              info = -12
           else if( ( lwork<( m+n ) ) .and. ( .not.lquery ) ) then
              info = -13
           else if( ( lrwork<max( n, 6 ) ) .and. ( .not.lquery ) ) then
              info = -15
           else
              info = 0
           end if
           ! #:(
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGESVJ', -info )
              return
           else if ( lquery ) then
              cwork(1) = m + n
              rwork(1) = max( n, 6 )
              return
           end if
       ! #:) quick return for void matrix
           if( ( m==0 ) .or. ( n==0 ) )return
           ! set numerical parameters
           ! the stopping criterion for jacobi rotations is
           ! max_{i<>j}|a(:,i)^* * a(:,j)| / (||a(:,i)||*||a(:,j)||) < ctol*eps
           ! where eps is the round-off and ctol is defined as follows:
           if( uctol ) then
              ! ... user controlled
              ctol = rwork( 1 )
           else
              ! ... default
              if( lsvec .or. rsvec .or. applv ) then
                 ctol = sqrt( real( m,KIND=dp) )
              else
                 ctol = real( m,KIND=dp)
              end if
           end if
           ! ... and the machine dependent parameters are
      ! [!]  (make sure that stdlib_slamch() works properly on the target machine.)
           epsln = stdlib_dlamch( 'EPSILON' )
           rooteps = sqrt( epsln )
           sfmin = stdlib_dlamch( 'SAFEMINIMUM' )
           rootsfmin = sqrt( sfmin )
           small = sfmin / epsln
           big = stdlib_dlamch( 'OVERFLOW' )
           ! big         = one    / sfmin
           rootbig = one / rootsfmin
            ! large = big / sqrt( real( m*n,KIND=dp) )
           bigtheta = one / rooteps
           tol = ctol*epsln
           roottol = sqrt( tol )
           if( real( m,KIND=dp)*epsln>=one ) then
              info = -4
              call stdlib_xerbla( 'ZGESVJ', -info )
              return
           end if
           ! initialize the right singular vector matrix.
           if( rsvec ) then
              mvl = n
              call stdlib_zlaset( 'A', mvl, n, czero, cone, v, ldv )
           else if( applv ) then
              mvl = mv
           end if
           rsvec = rsvec .or. applv
           ! initialize sva( 1:n ) = ( ||a e_i||_2, i = 1:n )
      ! (!)  if necessary, scale a to protect the largest singular value
           ! from overflow. it is possible that saving the largest singular
           ! value destroys the information about the small ones.
           ! this initial scaling is almost minimal in the sense that the
           ! goal is to make sure that no column norm overflows, and that
           ! sqrt(n)*max_i sva(i) does not overflow. if infinite entries
           ! in a are detected, the procedure returns with info=-6.
           skl = one / sqrt( real( m,KIND=dp)*real( n,KIND=dp) )
           noscale = .true.
           goscale = .true.
           if( lower ) then
              ! the input matrix is m-by-n lower triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_zlassq( m-p+1, a( p, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'ZGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else if( upper ) then
              ! the input matrix is m-by-n upper triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_zlassq( p, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'ZGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else
              ! the input matrix is m-by-n general dense
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_zlassq( m, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'ZGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           end if
           if( noscale )skl = one
           ! move the smaller part of the spectrum from the underflow threshold
      ! (!)  start by determining the position of the nonzero entries of the
           ! array sva() relative to ( sfmin, big ).
           aapp = zero
           aaqq = big
           do p = 1, n
              if( sva( p )/=zero )aaqq = min( aaqq, sva( p ) )
              aapp = max( aapp, sva( p ) )
           end do
       ! #:) quick return for zero matrix
           if( aapp==zero ) then
              if( lsvec )call stdlib_zlaset( 'G', m, n, czero, cone, a, lda )
              rwork( 1 ) = one
              rwork( 2 ) = zero
              rwork( 3 ) = zero
              rwork( 4 ) = zero
              rwork( 5 ) = zero
              rwork( 6 ) = zero
              return
           end if
       ! #:) quick return for one-column matrix
           if( n==1 ) then
              if( lsvec )call stdlib_zlascl( 'G', 0, 0, sva( 1 ), skl, m, 1,a( 1, 1 ), lda, ierr )
                        
              rwork( 1 ) = one / skl
              if( sva( 1 )>=sfmin ) then
                 rwork( 2 ) = one
              else
                 rwork( 2 ) = zero
              end if
              rwork( 3 ) = zero
              rwork( 4 ) = zero
              rwork( 5 ) = zero
              rwork( 6 ) = zero
              return
           end if
           ! protect small singular values from underflow, and try to
           ! avoid underflows/overflows in computing jacobi rotations.
           sn = sqrt( sfmin / epsln )
           temp1 = sqrt( big / real( n,KIND=dp) )
           if( ( aapp<=sn ) .or. ( aaqq>=temp1 ) .or.( ( sn<=aaqq ) .and. ( aapp<=temp1 ) ) ) &
                     then
              temp1 = min( big, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp<=temp1 ) ) then
              temp1 = min( sn / aaqq, big / (aapp*sqrt( real(n,KIND=dp)) ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq>=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = max( sn / aaqq, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( sqrt( real( n,KIND=dp) )*aapp ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else
              temp1 = one
           end if
           ! scale, if necessary
           if( temp1/=one ) then
              call stdlib_dlascl( 'G', 0, 0, one, temp1, n, 1, sva, n, ierr )
           end if
           skl = temp1*skl
           if( skl/=one ) then
              call stdlib_zlascl( joba, 0, 0, one, skl, m, n, a, lda, ierr )
              skl = one / skl
           end if
           ! row-cyclic jacobi svd algorithm with column pivoting
           emptsw = ( n*( n-1 ) ) / 2
           notrot = 0
           do q = 1, n
              cwork( q ) = cone
           end do
           swband = 3
      ! [tp] swband is a tuning parameter [tp]. it is meaningful and effective
           ! if stdlib_zgesvj is used as a computational routine in the preconditioned
           ! jacobi svd algorithm stdlib_zgejsv. for sweeps i=1:swband the procedure
           ! works on pivots inside a band-like region around the diagonal.
           ! the boundaries are determined dynamically, based on the number of
           ! pivots above a threshold.
           kbl = min( 8, n )
      ! [tp] kbl is a tuning parameter that defines the tile size in the
           ! tiling of the p-q loops of pivot pairs. in general, an optimal
           ! value of kbl depends on the matrix dimensions and on the
           ! parameters of the computer's memory.
           nbl = n / kbl
           if( ( nbl*kbl )/=n )nbl = nbl + 1
           blskip = kbl**2
      ! [tp] blkskip is a tuning parameter that depends on swband and kbl.
           rowskip = min( 5, kbl )
      ! [tp] rowskip is a tuning parameter.
           lkahead = 1
      ! [tp] lkahead is a tuning parameter.
           ! quasi block transformations, using the lower (upper) triangular
           ! structure of the input matrix. the quasi-block-cycling usually
           ! invokes cubic convergence. big part of this cycle is done inside
           ! canonical subspaces of dimensions less than m.
           if( ( lower .or. upper ) .and. ( n>max( 64, 4*kbl ) ) ) then
      ! [tp] the number of partition levels and the actual partition are
           ! tuning parameters.
              n4 = n / 4
              n2 = n / 2
              n34 = 3*n4
              if( applv ) then
                 q = 0
              else
                 q = 1
              end if
              if( lower ) then
           ! this works very well on lower triangular matrices, in particular
           ! in the framework of the preconditioned jacobi svd (xgejsv).
           ! the idea is simple:
           ! [+ 0 0 0]   note that jacobi transformations of [0 0]
           ! [+ + 0 0]                                       [0 0]
           ! [+ + x 0]   actually work on [x 0]              [x 0]
           ! [+ + x x]                    [x x].             [x x]
                 call stdlib_zgsvj0( jobv, m-n34, n-n34, a( n34+1, n34+1 ), lda,cwork( n34+1 ), &
                 sva( n34+1 ), mvl,v( n34*q+1, n34+1 ), ldv, epsln, sfmin, tol,2, cwork( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_zgsvj0( jobv, m-n2, n34-n2, a( n2+1, n2+1 ), lda,cwork( n2+1 ), sva( &
                 n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 2,cwork( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_zgsvj1( jobv, m-n2, n-n2, n4, a( n2+1, n2+1 ), lda,cwork( n2+1 ), &
                 sva( n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_zgsvj0( jobv, m-n4, n2-n4, a( n4+1, n4+1 ), lda,cwork( n4+1 ), sva( &
                 n4+1 ), mvl,v( n4*q+1, n4+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_zgsvj0( jobv, m, n4, a, lda, cwork, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 1, cwork( n+1 ), lwork-n,ierr )
                 call stdlib_zgsvj1( jobv, m, n2, n4, a, lda, cwork, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, cwork( n+1 ),lwork-n, ierr )
              else if( upper ) then
                 call stdlib_zgsvj0( jobv, n4, n4, a, lda, cwork, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 2, cwork( n+1 ), lwork-n,ierr )
                 call stdlib_zgsvj0( jobv, n2, n4, a( 1, n4+1 ), lda, cwork( n4+1 ),sva( n4+1 ), &
                 mvl, v( n4*q+1, n4+1 ), ldv,epsln, sfmin, tol, 1, cwork( n+1 ), lwork-n,ierr )
                           
                 call stdlib_zgsvj1( jobv, n2, n2, n4, a, lda, cwork, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, cwork( n+1 ),lwork-n, ierr )
                 call stdlib_zgsvj0( jobv, n2+n4, n4, a( 1, n2+1 ), lda,cwork( n2+1 ), sva( n2+1 )&
                 , mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), lwork-n, ierr )
                           
              end if
           end if
           ! .. row-cyclic pivot strategy with de rijk's pivoting ..
           loop_1993: do i = 1, nsweep
           ! .. go go go ...
              mxaapq = zero
              mxsinj = zero
              iswrot = 0
              notrot = 0
              pskipped = 0
           ! each sweep is unrolled using kbl-by-kbl tiles over the pivot pairs
           ! 1 <= p < q <= n. this is the first step toward a blocked implementation
           ! of the rotations. new implementation, based on block transformations,
           ! is under development.
              loop_2000: do ibr = 1, nbl
                 igl = ( ibr-1 )*kbl + 1
                 loop_1002: do ir1 = 0, min( lkahead, nbl-ibr )
                    igl = igl + ir1*kbl
                    loop_2001: do p = igl, min( igl+kbl-1, n-1 )
           ! .. de rijk's pivoting
                       q = stdlib_idamax( n-p+1, sva( p ), 1 ) + p - 1
                       if( p/=q ) then
                          call stdlib_zswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                          if( rsvec )call stdlib_zswap( mvl, v( 1, p ), 1,v( 1, q ), 1 )
                          temp1 = sva( p )
                          sva( p ) = sva( q )
                          sva( q ) = temp1
                          aapq = cwork(p)
                          cwork(p) = cwork(q)
                          cwork(q) = aapq
                       end if
                       if( ir1==0 ) then
              ! column norms are periodically updated by explicit
              ! norm computation.
      ! [!]     caveat:
              ! unfortunately, some blas implementations compute stdlib_dznrm2(m,a(1,p),1)
              ! as sqrt(s=stdlib_cdotc(m,a(1,p),1,a(1,p),1)), which may cause the result to
              ! overflow for ||a(:,p)||_2 > sqrt(overflow_threshold), and to
              ! underflow for ||a(:,p)||_2 < sqrt(underflow_threshold).
              ! hence, stdlib_dznrm2 cannot be trusted, not even in the case when
              ! the true norm is far from the under(over)flow boundaries.
              ! if properly implemented stdlib_scnrm2 is available, the if-then-else-end if
              ! below should be replaced with "aapp = stdlib_dznrm2( m, a(1,p), 1 )".
                          if( ( sva( p )<rootbig ) .and.( sva( p )>rootsfmin ) ) then
                             sva( p ) = stdlib_dznrm2( m, a( 1, p ), 1 )
                          else
                             temp1 = zero
                             aapp = one
                             call stdlib_zlassq( m, a( 1, p ), 1, temp1, aapp )
                             sva( p ) = temp1*sqrt( aapp )
                          end if
                          aapp = sva( p )
                       else
                          aapp = sva( p )
                       end if
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2002: do q = p + 1, min( igl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
                                if( aaqq>=one ) then
                                   rotok = ( small*aapp )<=aaqq
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_zdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aaqq ) / aapp
                                   else
                                      call stdlib_zcopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_zlascl( 'G', 0, 0, aapp, one,m, 1, cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_zdotc( m, cwork(n+1), 1,a( 1, q ), 1 ) / &
                                                aaqq
                                   end if
                                else
                                   rotok = aapp<=( aaqq / small )
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_zdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aapp ) / aaqq
                                   else
                                      call stdlib_zcopy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                      call stdlib_zlascl( 'G', 0, 0, aaqq,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_zdotc( m, a(1, p ), 1,cwork(n+1), 1 ) / &
                                                aapp
                                   end if
                                end if
                                 ! aapq = aapq * conjg( cwork(p) ) * cwork(q)
                                aapq1  = -abs(aapq)
                                mxaapq = max( mxaapq, -aapq1 )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq1 )>tol ) then
                                ompq = aapq / abs(aapq)
                 ! Rotate
      ! [rtd]      rotated = rotated + one
                                   if( ir1==0 ) then
                                      notrot = 0
                                      pskipped = 0
                                      iswrot = iswrot + 1
                                   end if
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/aapq1
                                      if( abs( theta )>bigtheta ) then
                                         t  = half / theta
                                         cs = one
                                         call stdlib_zrot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *t )
                                         if ( rsvec ) then
                                             call stdlib_zrot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*t )
                                         end if
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq1 )
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         call stdlib_zrot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *sn )
                                         if ( rsvec ) then
                                             call stdlib_zrot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*sn )
                                         end if
                                      end if
                                      cwork(p) = -cwork(q) * ompq
                                      else
                    ! .. have to use modified gram-schmidt like transformation
                                      call stdlib_zcopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_zlascl( 'G', 0, 0, aapp, one, m,1, cwork(n+1), &
                                                lda,ierr )
                                      call stdlib_zlascl( 'G', 0, 0, aaqq, one, m,1, a( 1, q ), &
                                                lda, ierr )
                                      call stdlib_zaxpy( m, -aapq, cwork(n+1), 1,a( 1, q ), 1 )
                                                
                                      call stdlib_zlascl( 'G', 0, 0, one, aaqq, m,1, a( 1, q ), &
                                                lda, ierr )
                                      sva( q ) = aaqq*sqrt( max( zero,one-aapq1*aapq1 ) )
                                      mxsinj = max( mxsinj, sfmin )
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! recompute sva(q), sva(p).
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_dznrm2( m, a( 1, q ), 1 )
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_zlassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_dznrm2( m, a( 1, p ), 1 )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_zlassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )
                                      end if
                                      sva( p ) = aapp
                                   end if
                                else
                                   ! a(:,p) and a(:,q) already numerically orthogonal
                                   if( ir1==0 )notrot = notrot + 1
      ! [rtd]      skipped  = skipped + 1
                                   pskipped = pskipped + 1
                                end if
                             else
                                ! a(:,q) is zero column
                                if( ir1==0 )notrot = notrot + 1
                                pskipped = pskipped + 1
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                if( ir1==0 )aapp = -aapp
                                notrot = 0
                                go to 2103
                             end if
                          end do loop_2002
           ! end q-loop
           2103 continue
           ! bailed out of q-loop
                          sva( p ) = aapp
                       else
                          sva( p ) = aapp
                          if( ( ir1==0 ) .and. ( aapp==zero ) )notrot = notrot + min( igl+kbl-1, &
                                    n ) - p
                       end if
                    end do loop_2001
           ! end of the p-loop
           ! end of doing the block ( ibr, ibr )
                 end do loop_1002
           ! end of ir1-loop
       ! ... go to the off diagonal blocks
                 igl = ( ibr-1 )*kbl + 1
                 loop_2010: do jbc = ibr + 1, nbl
                    jgl = ( jbc-1 )*kbl + 1
              ! doing the block at ( ibr, jbc )
                    ijblsk = 0
                    loop_2100: do p = igl, min( igl+kbl-1, n )
                       aapp = sva( p )
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2200: do q = jgl, min( jgl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
           ! M X 2 Jacobi Svd 
              ! safe gram matrix computation
                                if( aaqq>=one ) then
                                   if( aapp>=aaqq ) then
                                      rotok = ( small*aapp )<=aaqq
                                   else
                                      rotok = ( small*aaqq )<=aapp
                                   end if
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_zdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aaqq ) / aapp
                                   else
                                      call stdlib_zcopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_zlascl( 'G', 0, 0, aapp,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_zdotc( m, cwork(n+1), 1,a( 1, q ), 1 ) / &
                                                aaqq
                                   end if
                                else
                                   if( aapp>=aaqq ) then
                                      rotok = aapp<=( aaqq / small )
                                   else
                                      rotok = aaqq<=( aapp / small )
                                   end if
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_zdotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / max(&
                                                aaqq,aapp) )/ min(aaqq,aapp)
                                   else
                                      call stdlib_zcopy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                      call stdlib_zlascl( 'G', 0, 0, aaqq,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_zdotc( m, a( 1, p ), 1,cwork(n+1),  1 ) / &
                                                aapp
                                   end if
                                end if
                                 ! aapq = aapq * conjg(cwork(p))*cwork(q)
                                aapq1  = -abs(aapq)
                                mxaapq = max( mxaapq, -aapq1 )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq1 )>tol ) then
                                   ompq = aapq / abs(aapq)
                                   notrot = 0
      ! [rtd]      rotated  = rotated + 1
                                   pskipped = 0
                                   iswrot = iswrot + 1
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/ aapq1
                                      if( aaqq>aapp0 )theta = -theta
                                      if( abs( theta )>bigtheta ) then
                                         t  = half / theta
                                         cs = one
                                         call stdlib_zrot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *t )
                                         if( rsvec ) then
                                             call stdlib_zrot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*t )
                                         end if
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq1 )
                                         if( aaqq>aapp0 )thsign = -thsign
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         call stdlib_zrot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *sn )
                                         if( rsvec ) then
                                             call stdlib_zrot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*sn )
                                         end if
                                      end if
                                      cwork(p) = -cwork(q) * ompq
                                   else
                    ! .. have to use modified gram-schmidt like transformation
                                    if( aapp>aaqq ) then
                                         call stdlib_zcopy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                                   
                                         call stdlib_zlascl( 'G', 0, 0, aapp, one,m, 1, cwork(n+1)&
                                                   ,lda,ierr )
                                         call stdlib_zlascl( 'G', 0, 0, aaqq, one,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         call stdlib_zaxpy( m, -aapq, cwork(n+1),1, a( 1, q ), 1 )
                                                   
                                         call stdlib_zlascl( 'G', 0, 0, one, aaqq,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         sva( q ) = aaqq*sqrt( max( zero,one-aapq1*aapq1 ) )
                                                   
                                         mxsinj = max( mxsinj, sfmin )
                                    else
                                        call stdlib_zcopy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                         call stdlib_zlascl( 'G', 0, 0, aaqq, one,m, 1, cwork(n+1)&
                                                   ,lda,ierr )
                                         call stdlib_zlascl( 'G', 0, 0, aapp, one,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         call stdlib_zaxpy( m, -conjg(aapq),cwork(n+1), 1, a( 1, &
                                                   p ), 1 )
                                         call stdlib_zlascl( 'G', 0, 0, one, aapp,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         sva( p ) = aapp*sqrt( max( zero,one-aapq1*aapq1 ) )
                                                   
                                         mxsinj = max( mxsinj, sfmin )
                                    end if
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! .. recompute sva(q), sva(p)
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_dznrm2( m, a( 1, q ), 1)
                                       else
                                         t = zero
                                         aaqq = one
                                         call stdlib_zlassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )**2<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_dznrm2( m, a( 1, p ), 1 )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_zlassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )
                                      end if
                                      sva( p ) = aapp
                                   end if
                    ! end of ok rotation
                                else
                                   notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                   ijblsk = ijblsk + 1
                                end if
                             else
                                notrot = notrot + 1
                                pskipped = pskipped + 1
                                ijblsk = ijblsk + 1
                             end if
                             if( ( i<=swband ) .and. ( ijblsk>=blskip ) )then
                                sva( p ) = aapp
                                notrot = 0
                                go to 2011
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                aapp = -aapp
                                notrot = 0
                                go to 2203
                             end if
                          end do loop_2200
              ! end of the q-loop
              2203 continue
                          sva( p ) = aapp
                       else
                          if( aapp==zero )notrot = notrot +min( jgl+kbl-1, n ) - jgl + 1
                          if( aapp<zero )notrot = 0
                       end if
                    end do loop_2100
           ! end of the p-loop
                 end do loop_2010
           ! end of the jbc-loop
           2011 continue
      ! 2011 bailed out of the jbc-loop
                 do p = igl, min( igl+kbl-1, n )
                    sva( p ) = abs( sva( p ) )
                 end do
      ! **
              end do loop_2000
      ! 2000 :: end of the ibr-loop
           ! .. update sva(n)
              if( ( sva( n )<rootbig ) .and. ( sva( n )>rootsfmin ) )then
                 sva( n ) = stdlib_dznrm2( m, a( 1, n ), 1 )
              else
                 t = zero
                 aapp = one
                 call stdlib_zlassq( m, a( 1, n ), 1, t, aapp )
                 sva( n ) = t*sqrt( aapp )
              end if
           ! additional steering devices
              if( ( i<swband ) .and. ( ( mxaapq<=roottol ) .or.( iswrot<=n ) ) )swband = i
              if( ( i>swband+1 ) .and. ( mxaapq<sqrt( real( n,KIND=dp) )*tol ) .and. ( real( n,&
                        KIND=dp)*mxaapq*mxsinj<tol ) ) then
                 go to 1994
              end if
              if( notrot>=emptsw )go to 1994
           end do loop_1993
           ! end i=1:nsweep loop
       ! #:( reaching this point means that the procedure has not converged.
           info = nsweep - 1
           go to 1995
           1994 continue
       ! #:) reaching this point means numerical convergence after the i-th
           ! sweep.
           info = 0
       ! #:) info = 0 confirms successful iterations.
       1995 continue
           ! sort the singular values and find how many are above
           ! the underflow threshold.
           n2 = 0
           n4 = 0
           do p = 1, n - 1
              q = stdlib_idamax( n-p+1, sva( p ), 1 ) + p - 1
              if( p/=q ) then
                 temp1 = sva( p )
                 sva( p ) = sva( q )
                 sva( q ) = temp1
                 call stdlib_zswap( m, a( 1, p ), 1, a( 1, q ), 1 )
                 if( rsvec )call stdlib_zswap( mvl, v( 1, p ), 1, v( 1, q ), 1 )
              end if
              if( sva( p )/=zero ) then
                 n4 = n4 + 1
                 if( sva( p )*skl>sfmin )n2 = n2 + 1
              end if
           end do
           if( sva( n )/=zero ) then
              n4 = n4 + 1
              if( sva( n )*skl>sfmin )n2 = n2 + 1
           end if
           ! normalize the left singular vectors.
           if( lsvec .or. uctol ) then
              do p = 1, n4
                  ! call stdlib_zdscal( m, one / sva( p ), a( 1, p ), 1 )
                 call stdlib_zlascl( 'G',0,0, sva(p), one, m, 1, a(1,p), m, ierr )
              end do
           end if
           ! scale the product of jacobi rotations.
           if( rsvec ) then
                 do p = 1, n
                    temp1 = one / stdlib_dznrm2( mvl, v( 1, p ), 1 )
                    call stdlib_zdscal( mvl, temp1, v( 1, p ), 1 )
                 end do
           end if
           ! undo scaling, if necessary (and possible).
           if( ( ( skl>one ) .and. ( sva( 1 )<( big / skl ) ) ).or. ( ( skl<one ) .and. ( sva( &
                     max( n2, 1 ) ) >( sfmin / skl ) ) ) ) then
              do p = 1, n
                 sva( p ) = skl*sva( p )
              end do
              skl = one
           end if
           rwork( 1 ) = skl
           ! the singular values of a are skl*sva(1:n). if skl/=one
           ! then some of the singular values may overflow or underflow and
           ! the spectrum is given in this factored representation.
           rwork( 2 ) = real( n4,KIND=dp)
           ! n4 is the number of computed nonzero singular values of a.
           rwork( 3 ) = real( n2,KIND=dp)
           ! n2 is the number of singular values of a greater than sfmin.
           ! if n2<n, sva(n2:n) contains zeros and/or denormalized numbers
           ! that may carry some information.
           rwork( 4 ) = real( i,KIND=dp)
           ! i is the index of the last sweep before declaring convergence.
           rwork( 5 ) = mxaapq
           ! mxaapq is the largest absolute value of scaled pivots in the
           ! last sweep
           rwork( 6 ) = mxsinj
           ! mxsinj is the largest absolute value of the sines of jacobi angles
           ! in the last sweep
           return
     end subroutine stdlib_zgesvj

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$gesvj( joba, jobu, jobv, m, n, a, lda, sva, mv, v,ldv, cwork, lwork, rwork, lrwork, info )
     !! ZGESVJ: computes the singular value decomposition (SVD) of a complex
     !! M-by-N matrix A, where M >= N. The SVD of A is written as
     !! [++]   [xx]   [x0]   [xx]
     !! A = U * SIGMA * V^*,  [++] = [xx] * [ox] * [xx]
     !! [++]   [xx]
     !! where SIGMA is an N-by-N diagonal matrix, U is an M-by-N orthonormal
     !! matrix, and V is an N-by-N unitary matrix. The diagonal elements
     !! of SIGMA are the singular values of A. The columns of U and V are the
     !! left and the right singular vectors of A, respectively.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldv, lwork, lrwork, m, mv, n
           character, intent(in) :: joba, jobu, jobv
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*), v(ldv,*), cwork(lwork)
           real(${ck}$), intent(inout) :: rwork(lrwork)
           real(${ck}$), intent(out) :: sva(n)
        ! =====================================================================
           ! Local Parameters 
           integer(ilp), parameter :: nsweep = 30
           
           
           
           ! Local Scalars 
           complex(${ck}$) :: aapq, ompq
           real(${ck}$) :: aapp, aapp0, aapq1, aaqq, apoaq, aqoap, big, bigtheta, cs, ctol, epsln, &
           mxaapq, mxsinj, rootbig, rooteps, rootsfmin, roottol, skl, sfmin, small, sn, t, temp1, &
                     theta, thsign, tol
           integer(ilp) :: blskip, emptsw, i, ibr, ierr, igl, ijblsk, ir1, iswrot, jbc, jgl, kbl, &
                     lkahead, mvl, n2, n34, n4, nbl, notrot, p, pskipped, q, rowskip, swband
           logical(lk) :: applv, goscale, lower, lquery, lsvec, noscale, rotok, rsvec, uctol, &
                     upper
           ! Intrinsic Functions 
           ! from lapack
           ! from lapack
           ! Executable Statements 
           ! test the input arguments
           lsvec = stdlib_lsame( jobu, 'U' ) .or. stdlib_lsame( jobu, 'F' )
           uctol = stdlib_lsame( jobu, 'C' )
           rsvec = stdlib_lsame( jobv, 'V' ) .or. stdlib_lsame( jobv, 'J' )
           applv = stdlib_lsame( jobv, 'A' )
           upper = stdlib_lsame( joba, 'U' )
           lower = stdlib_lsame( joba, 'L' )
           lquery = ( lwork == -1 ) .or. ( lrwork == -1 )
           if( .not.( upper .or. lower .or. stdlib_lsame( joba, 'G' ) ) ) then
              info = -1
           else if( .not.( lsvec .or. uctol .or. stdlib_lsame( jobu, 'N' ) ) ) then
              info = -2
           else if( .not.( rsvec .or. applv .or. stdlib_lsame( jobv, 'N' ) ) ) then
              info = -3
           else if( m<0 ) then
              info = -4
           else if( ( n<0 ) .or. ( n>m ) ) then
              info = -5
           else if( lda<m ) then
              info = -7
           else if( mv<0 ) then
              info = -9
           else if( ( rsvec .and. ( ldv<n ) ) .or.( applv .and. ( ldv<mv ) ) ) then
              info = -11
           else if( uctol .and. ( rwork( 1 )<=one ) ) then
              info = -12
           else if( ( lwork<( m+n ) ) .and. ( .not.lquery ) ) then
              info = -13
           else if( ( lrwork<max( n, 6 ) ) .and. ( .not.lquery ) ) then
              info = -15
           else
              info = 0
           end if
           ! #:(
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGESVJ', -info )
              return
           else if ( lquery ) then
              cwork(1) = m + n
              rwork(1) = max( n, 6 )
              return
           end if
       ! #:) quick return for void matrix
           if( ( m==0 ) .or. ( n==0 ) )return
           ! set numerical parameters
           ! the stopping criterion for jacobi rotations is
           ! max_{i<>j}|a(:,i)^* * a(:,j)| / (||a(:,i)||*||a(:,j)||) < ctol*eps
           ! where eps is the round-off and ctol is defined as follows:
           if( uctol ) then
              ! ... user controlled
              ctol = rwork( 1 )
           else
              ! ... default
              if( lsvec .or. rsvec .or. applv ) then
                 ctol = sqrt( real( m,KIND=${ck}$) )
              else
                 ctol = real( m,KIND=${ck}$)
              end if
           end if
           ! ... and the machine dependent parameters are
      ! [!]  (make sure that stdlib_dlamch() works properly on the target machine.)
           epsln = stdlib_${c2ri(ci)}$lamch( 'EPSILON' )
           rooteps = sqrt( epsln )
           sfmin = stdlib_${c2ri(ci)}$lamch( 'SAFEMINIMUM' )
           rootsfmin = sqrt( sfmin )
           small = sfmin / epsln
           big = stdlib_${c2ri(ci)}$lamch( 'OVERFLOW' )
           ! big         = one    / sfmin
           rootbig = one / rootsfmin
            ! large = big / sqrt( real( m*n,KIND=${ck}$) )
           bigtheta = one / rooteps
           tol = ctol*epsln
           roottol = sqrt( tol )
           if( real( m,KIND=${ck}$)*epsln>=one ) then
              info = -4
              call stdlib_xerbla( 'ZGESVJ', -info )
              return
           end if
           ! initialize the right singular vector matrix.
           if( rsvec ) then
              mvl = n
              call stdlib_${ci}$laset( 'A', mvl, n, czero, cone, v, ldv )
           else if( applv ) then
              mvl = mv
           end if
           rsvec = rsvec .or. applv
           ! initialize sva( 1:n ) = ( ||a e_i||_2, i = 1:n )
      ! (!)  if necessary, scale a to protect the largest singular value
           ! from overflow. it is possible that saving the largest singular
           ! value destroys the information about the small ones.
           ! this initial scaling is almost minimal in the sense that the
           ! goal is to make sure that no column norm overflows, and that
           ! sqrt(n)*max_i sva(i) does not overflow. if infinite entries
           ! in a are detected, the procedure returns with info=-6.
           skl = one / sqrt( real( m,KIND=${ck}$)*real( n,KIND=${ck}$) )
           noscale = .true.
           goscale = .true.
           if( lower ) then
              ! the input matrix is m-by-n lower triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_${ci}$lassq( m-p+1, a( p, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'ZGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else if( upper ) then
              ! the input matrix is m-by-n upper triangular (trapezoidal)
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_${ci}$lassq( p, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'ZGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           else
              ! the input matrix is m-by-n general dense
              do p = 1, n
                 aapp = zero
                 aaqq = one
                 call stdlib_${ci}$lassq( m, a( 1, p ), 1, aapp, aaqq )
                 if( aapp>big ) then
                    info = -6
                    call stdlib_xerbla( 'ZGESVJ', -info )
                    return
                 end if
                 aaqq = sqrt( aaqq )
                 if( ( aapp<( big / aaqq ) ) .and. noscale ) then
                    sva( p ) = aapp*aaqq
                 else
                    noscale = .false.
                    sva( p ) = aapp*( aaqq*skl )
                    if( goscale ) then
                       goscale = .false.
                       do q = 1, p - 1
                          sva( q ) = sva( q )*skl
                       end do
                    end if
                 end if
              end do
           end if
           if( noscale )skl = one
           ! move the smaller part of the spectrum from the underflow threshold
      ! (!)  start by determining the position of the nonzero entries of the
           ! array sva() relative to ( sfmin, big ).
           aapp = zero
           aaqq = big
           do p = 1, n
              if( sva( p )/=zero )aaqq = min( aaqq, sva( p ) )
              aapp = max( aapp, sva( p ) )
           end do
       ! #:) quick return for zero matrix
           if( aapp==zero ) then
              if( lsvec )call stdlib_${ci}$laset( 'G', m, n, czero, cone, a, lda )
              rwork( 1 ) = one
              rwork( 2 ) = zero
              rwork( 3 ) = zero
              rwork( 4 ) = zero
              rwork( 5 ) = zero
              rwork( 6 ) = zero
              return
           end if
       ! #:) quick return for one-column matrix
           if( n==1 ) then
              if( lsvec )call stdlib_${ci}$lascl( 'G', 0, 0, sva( 1 ), skl, m, 1,a( 1, 1 ), lda, ierr )
                        
              rwork( 1 ) = one / skl
              if( sva( 1 )>=sfmin ) then
                 rwork( 2 ) = one
              else
                 rwork( 2 ) = zero
              end if
              rwork( 3 ) = zero
              rwork( 4 ) = zero
              rwork( 5 ) = zero
              rwork( 6 ) = zero
              return
           end if
           ! protect small singular values from underflow, and try to
           ! avoid underflows/overflows in computing jacobi rotations.
           sn = sqrt( sfmin / epsln )
           temp1 = sqrt( big / real( n,KIND=${ck}$) )
           if( ( aapp<=sn ) .or. ( aaqq>=temp1 ) .or.( ( sn<=aaqq ) .and. ( aapp<=temp1 ) ) ) &
                     then
              temp1 = min( big, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp<=temp1 ) ) then
              temp1 = min( sn / aaqq, big / (aapp*sqrt( real(n,KIND=${ck}$)) ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq>=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = max( sn / aaqq, temp1 / aapp )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else if( ( aaqq<=sn ) .and. ( aapp>=temp1 ) ) then
              temp1 = min( sn / aaqq, big / ( sqrt( real( n,KIND=${ck}$) )*aapp ) )
               ! aaqq  = aaqq*temp1
               ! aapp  = aapp*temp1
           else
              temp1 = one
           end if
           ! scale, if necessary
           if( temp1/=one ) then
              call stdlib_${c2ri(ci)}$lascl( 'G', 0, 0, one, temp1, n, 1, sva, n, ierr )
           end if
           skl = temp1*skl
           if( skl/=one ) then
              call stdlib_${ci}$lascl( joba, 0, 0, one, skl, m, n, a, lda, ierr )
              skl = one / skl
           end if
           ! row-cyclic jacobi svd algorithm with column pivoting
           emptsw = ( n*( n-1 ) ) / 2
           notrot = 0
           do q = 1, n
              cwork( q ) = cone
           end do
           swband = 3
      ! [tp] swband is a tuning parameter [tp]. it is meaningful and effective
           ! if stdlib_${ci}$gesvj is used as a computational routine in the preconditioned
           ! jacobi svd algorithm stdlib_${ci}$gejsv. for sweeps i=1:swband the procedure
           ! works on pivots inside a band-like region around the diagonal.
           ! the boundaries are determined dynamically, based on the number of
           ! pivots above a threshold.
           kbl = min( 8, n )
      ! [tp] kbl is a tuning parameter that defines the tile size in the
           ! tiling of the p-q loops of pivot pairs. in general, an optimal
           ! value of kbl depends on the matrix dimensions and on the
           ! parameters of the computer's memory.
           nbl = n / kbl
           if( ( nbl*kbl )/=n )nbl = nbl + 1
           blskip = kbl**2
      ! [tp] blkskip is a tuning parameter that depends on swband and kbl.
           rowskip = min( 5, kbl )
      ! [tp] rowskip is a tuning parameter.
           lkahead = 1
      ! [tp] lkahead is a tuning parameter.
           ! quasi block transformations, using the lower (upper) triangular
           ! structure of the input matrix. the quasi-block-cycling usually
           ! invokes cubic convergence. big part of this cycle is done inside
           ! canonical subspaces of dimensions less than m.
           if( ( lower .or. upper ) .and. ( n>max( 64, 4*kbl ) ) ) then
      ! [tp] the number of partition levels and the actual partition are
           ! tuning parameters.
              n4 = n / 4
              n2 = n / 2
              n34 = 3*n4
              if( applv ) then
                 q = 0
              else
                 q = 1
              end if
              if( lower ) then
           ! this works very well on lower triangular matrices, in particular
           ! in the framework of the preconditioned jacobi svd (xgejsv).
           ! the idea is simple:
           ! [+ 0 0 0]   note that jacobi transformations of [0 0]
           ! [+ + 0 0]                                       [0 0]
           ! [+ + x 0]   actually work on [x 0]              [x 0]
           ! [+ + x x]                    [x x].             [x x]
                 call stdlib_${ci}$gsvj0( jobv, m-n34, n-n34, a( n34+1, n34+1 ), lda,cwork( n34+1 ), &
                 sva( n34+1 ), mvl,v( n34*q+1, n34+1 ), ldv, epsln, sfmin, tol,2, cwork( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_${ci}$gsvj0( jobv, m-n2, n34-n2, a( n2+1, n2+1 ), lda,cwork( n2+1 ), sva( &
                 n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 2,cwork( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_${ci}$gsvj1( jobv, m-n2, n-n2, n4, a( n2+1, n2+1 ), lda,cwork( n2+1 ), &
                 sva( n2+1 ), mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), &
                           lwork-n, ierr )
                 call stdlib_${ci}$gsvj0( jobv, m-n4, n2-n4, a( n4+1, n4+1 ), lda,cwork( n4+1 ), sva( &
                 n4+1 ), mvl,v( n4*q+1, n4+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), lwork-n, &
                           ierr )
                 call stdlib_${ci}$gsvj0( jobv, m, n4, a, lda, cwork, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 1, cwork( n+1 ), lwork-n,ierr )
                 call stdlib_${ci}$gsvj1( jobv, m, n2, n4, a, lda, cwork, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, cwork( n+1 ),lwork-n, ierr )
              else if( upper ) then
                 call stdlib_${ci}$gsvj0( jobv, n4, n4, a, lda, cwork, sva, mvl, v, ldv,epsln, sfmin, &
                           tol, 2, cwork( n+1 ), lwork-n,ierr )
                 call stdlib_${ci}$gsvj0( jobv, n2, n4, a( 1, n4+1 ), lda, cwork( n4+1 ),sva( n4+1 ), &
                 mvl, v( n4*q+1, n4+1 ), ldv,epsln, sfmin, tol, 1, cwork( n+1 ), lwork-n,ierr )
                           
                 call stdlib_${ci}$gsvj1( jobv, n2, n2, n4, a, lda, cwork, sva, mvl, v,ldv, epsln, &
                           sfmin, tol, 1, cwork( n+1 ),lwork-n, ierr )
                 call stdlib_${ci}$gsvj0( jobv, n2+n4, n4, a( 1, n2+1 ), lda,cwork( n2+1 ), sva( n2+1 )&
                 , mvl,v( n2*q+1, n2+1 ), ldv, epsln, sfmin, tol, 1,cwork( n+1 ), lwork-n, ierr )
                           
              end if
           end if
           ! .. row-cyclic pivot strategy with de rijk's pivoting ..
           loop_1993: do i = 1, nsweep
           ! .. go go go ...
              mxaapq = zero
              mxsinj = zero
              iswrot = 0
              notrot = 0
              pskipped = 0
           ! each sweep is unrolled using kbl-by-kbl tiles over the pivot pairs
           ! 1 <= p < q <= n. this is the first step toward a blocked implementation
           ! of the rotations. new implementation, based on block transformations,
           ! is under development.
              loop_2000: do ibr = 1, nbl
                 igl = ( ibr-1 )*kbl + 1
                 loop_1002: do ir1 = 0, min( lkahead, nbl-ibr )
                    igl = igl + ir1*kbl
                    loop_2001: do p = igl, min( igl+kbl-1, n-1 )
           ! .. de rijk's pivoting
                       q = stdlib_i${c2ri(ci)}$amax( n-p+1, sva( p ), 1 ) + p - 1
                       if( p/=q ) then
                          call stdlib_${ci}$swap( m, a( 1, p ), 1, a( 1, q ), 1 )
                          if( rsvec )call stdlib_${ci}$swap( mvl, v( 1, p ), 1,v( 1, q ), 1 )
                          temp1 = sva( p )
                          sva( p ) = sva( q )
                          sva( q ) = temp1
                          aapq = cwork(p)
                          cwork(p) = cwork(q)
                          cwork(q) = aapq
                       end if
                       if( ir1==0 ) then
              ! column norms are periodically updated by explicit
              ! norm computation.
      ! [!]     caveat:
              ! unfortunately, some blas implementations compute stdlib_${c2ri(ci)}$znrm2(m,a(1,p),1)
              ! as sqrt(s=stdlib_zdotc(m,a(1,p),1,a(1,p),1)), which may cause the result to
              ! overflow for ||a(:,p)||_2 > sqrt(overflow_threshold), and to
              ! underflow for ||a(:,p)||_2 < sqrt(underflow_threshold).
              ! hence, stdlib_${c2ri(ci)}$znrm2 cannot be trusted, not even in the case when
              ! the true norm is far from the under(over)flow boundaries.
              ! if properly implemented stdlib_dcnrm2 is available, the if-then-else-end if
              ! below should be replaced with "aapp = stdlib_${c2ri(ci)}$znrm2( m, a(1,p), 1 )".
                          if( ( sva( p )<rootbig ) .and.( sva( p )>rootsfmin ) ) then
                             sva( p ) = stdlib_${c2ri(ci)}$znrm2( m, a( 1, p ), 1 )
                          else
                             temp1 = zero
                             aapp = one
                             call stdlib_${ci}$lassq( m, a( 1, p ), 1, temp1, aapp )
                             sva( p ) = temp1*sqrt( aapp )
                          end if
                          aapp = sva( p )
                       else
                          aapp = sva( p )
                       end if
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2002: do q = p + 1, min( igl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
                                if( aaqq>=one ) then
                                   rotok = ( small*aapp )<=aaqq
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_${ci}$dotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aaqq ) / aapp
                                   else
                                      call stdlib_${ci}$copy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_${ci}$lascl( 'G', 0, 0, aapp, one,m, 1, cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_${ci}$dotc( m, cwork(n+1), 1,a( 1, q ), 1 ) / &
                                                aaqq
                                   end if
                                else
                                   rotok = aapp<=( aaqq / small )
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_${ci}$dotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aapp ) / aaqq
                                   else
                                      call stdlib_${ci}$copy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                      call stdlib_${ci}$lascl( 'G', 0, 0, aaqq,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_${ci}$dotc( m, a(1, p ), 1,cwork(n+1), 1 ) / &
                                                aapp
                                   end if
                                end if
                                 ! aapq = aapq * conjg( cwork(p) ) * cwork(q)
                                aapq1  = -abs(aapq)
                                mxaapq = max( mxaapq, -aapq1 )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq1 )>tol ) then
                                ompq = aapq / abs(aapq)
                 ! Rotate
      ! [rtd]      rotated = rotated + one
                                   if( ir1==0 ) then
                                      notrot = 0
                                      pskipped = 0
                                      iswrot = iswrot + 1
                                   end if
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/aapq1
                                      if( abs( theta )>bigtheta ) then
                                         t  = half / theta
                                         cs = one
                                         call stdlib_${ci}$rot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *t )
                                         if ( rsvec ) then
                                             call stdlib_${ci}$rot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*t )
                                         end if
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq1 )
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         call stdlib_${ci}$rot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *sn )
                                         if ( rsvec ) then
                                             call stdlib_${ci}$rot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*sn )
                                         end if
                                      end if
                                      cwork(p) = -cwork(q) * ompq
                                      else
                    ! .. have to use modified gram-schmidt like transformation
                                      call stdlib_${ci}$copy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_${ci}$lascl( 'G', 0, 0, aapp, one, m,1, cwork(n+1), &
                                                lda,ierr )
                                      call stdlib_${ci}$lascl( 'G', 0, 0, aaqq, one, m,1, a( 1, q ), &
                                                lda, ierr )
                                      call stdlib_${ci}$axpy( m, -aapq, cwork(n+1), 1,a( 1, q ), 1 )
                                                
                                      call stdlib_${ci}$lascl( 'G', 0, 0, one, aaqq, m,1, a( 1, q ), &
                                                lda, ierr )
                                      sva( q ) = aaqq*sqrt( max( zero,one-aapq1*aapq1 ) )
                                      mxsinj = max( mxsinj, sfmin )
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! recompute sva(q), sva(p).
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_${c2ri(ci)}$znrm2( m, a( 1, q ), 1 )
                                      else
                                         t = zero
                                         aaqq = one
                                         call stdlib_${ci}$lassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_${c2ri(ci)}$znrm2( m, a( 1, p ), 1 )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_${ci}$lassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )
                                      end if
                                      sva( p ) = aapp
                                   end if
                                else
                                   ! a(:,p) and a(:,q) already numerically orthogonal
                                   if( ir1==0 )notrot = notrot + 1
      ! [rtd]      skipped  = skipped + 1
                                   pskipped = pskipped + 1
                                end if
                             else
                                ! a(:,q) is zero column
                                if( ir1==0 )notrot = notrot + 1
                                pskipped = pskipped + 1
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                if( ir1==0 )aapp = -aapp
                                notrot = 0
                                go to 2103
                             end if
                          end do loop_2002
           ! end q-loop
           2103 continue
           ! bailed out of q-loop
                          sva( p ) = aapp
                       else
                          sva( p ) = aapp
                          if( ( ir1==0 ) .and. ( aapp==zero ) )notrot = notrot + min( igl+kbl-1, &
                                    n ) - p
                       end if
                    end do loop_2001
           ! end of the p-loop
           ! end of doing the block ( ibr, ibr )
                 end do loop_1002
           ! end of ir1-loop
       ! ... go to the off diagonal blocks
                 igl = ( ibr-1 )*kbl + 1
                 loop_2010: do jbc = ibr + 1, nbl
                    jgl = ( jbc-1 )*kbl + 1
              ! doing the block at ( ibr, jbc )
                    ijblsk = 0
                    loop_2100: do p = igl, min( igl+kbl-1, n )
                       aapp = sva( p )
                       if( aapp>zero ) then
                          pskipped = 0
                          loop_2200: do q = jgl, min( jgl+kbl-1, n )
                             aaqq = sva( q )
                             if( aaqq>zero ) then
                                aapp0 = aapp
           ! M X 2 Jacobi Svd 
              ! safe gram matrix computation
                                if( aaqq>=one ) then
                                   if( aapp>=aaqq ) then
                                      rotok = ( small*aapp )<=aaqq
                                   else
                                      rotok = ( small*aaqq )<=aapp
                                   end if
                                   if( aapp<( big / aaqq ) ) then
                                      aapq = ( stdlib_${ci}$dotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / &
                                                aaqq ) / aapp
                                   else
                                      call stdlib_${ci}$copy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                      call stdlib_${ci}$lascl( 'G', 0, 0, aapp,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_${ci}$dotc( m, cwork(n+1), 1,a( 1, q ), 1 ) / &
                                                aaqq
                                   end if
                                else
                                   if( aapp>=aaqq ) then
                                      rotok = aapp<=( aaqq / small )
                                   else
                                      rotok = aaqq<=( aapp / small )
                                   end if
                                   if( aapp>( small / aaqq ) ) then
                                      aapq = ( stdlib_${ci}$dotc( m, a( 1, p ), 1,a( 1, q ), 1 ) / max(&
                                                aaqq,aapp) )/ min(aaqq,aapp)
                                   else
                                      call stdlib_${ci}$copy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                      call stdlib_${ci}$lascl( 'G', 0, 0, aaqq,one, m, 1,cwork(n+1), &
                                                lda, ierr )
                                      aapq = stdlib_${ci}$dotc( m, a( 1, p ), 1,cwork(n+1),  1 ) / &
                                                aapp
                                   end if
                                end if
                                 ! aapq = aapq * conjg(cwork(p))*cwork(q)
                                aapq1  = -abs(aapq)
                                mxaapq = max( mxaapq, -aapq1 )
              ! to rotate or not to rotate, that is the question ...
                                if( abs( aapq1 )>tol ) then
                                   ompq = aapq / abs(aapq)
                                   notrot = 0
      ! [rtd]      rotated  = rotated + 1
                                   pskipped = 0
                                   iswrot = iswrot + 1
                                   if( rotok ) then
                                      aqoap = aaqq / aapp
                                      apoaq = aapp / aaqq
                                      theta = -half*abs( aqoap-apoaq )/ aapq1
                                      if( aaqq>aapp0 )theta = -theta
                                      if( abs( theta )>bigtheta ) then
                                         t  = half / theta
                                         cs = one
                                         call stdlib_${ci}$rot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *t )
                                         if( rsvec ) then
                                             call stdlib_${ci}$rot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*t )
                                         end if
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         mxsinj = max( mxsinj, abs( t ) )
                                      else
                       ! Choose Correct Signum For Theta And Rotate
                                         thsign = -sign( one, aapq1 )
                                         if( aaqq>aapp0 )thsign = -thsign
                                         t = one / ( theta+thsign*sqrt( one+theta*theta ) )
                                                   
                                         cs = sqrt( one / ( one+t*t ) )
                                         sn = t*cs
                                         mxsinj = max( mxsinj, abs( sn ) )
                                         sva( q ) = aaqq*sqrt( max( zero,one+t*apoaq*aapq1 ) )
                                                   
                                         aapp = aapp*sqrt( max( zero,one-t*aqoap*aapq1 ) )
                                         call stdlib_${ci}$rot( m, a(1,p), 1, a(1,q), 1,cs, conjg(ompq)&
                                                   *sn )
                                         if( rsvec ) then
                                             call stdlib_${ci}$rot( mvl, v(1,p), 1,v(1,q), 1, cs, &
                                                       conjg(ompq)*sn )
                                         end if
                                      end if
                                      cwork(p) = -cwork(q) * ompq
                                   else
                    ! .. have to use modified gram-schmidt like transformation
                                    if( aapp>aaqq ) then
                                         call stdlib_${ci}$copy( m, a( 1, p ), 1,cwork(n+1), 1 )
                                                   
                                         call stdlib_${ci}$lascl( 'G', 0, 0, aapp, one,m, 1, cwork(n+1)&
                                                   ,lda,ierr )
                                         call stdlib_${ci}$lascl( 'G', 0, 0, aaqq, one,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         call stdlib_${ci}$axpy( m, -aapq, cwork(n+1),1, a( 1, q ), 1 )
                                                   
                                         call stdlib_${ci}$lascl( 'G', 0, 0, one, aaqq,m, 1, a( 1, q ),&
                                                    lda,ierr )
                                         sva( q ) = aaqq*sqrt( max( zero,one-aapq1*aapq1 ) )
                                                   
                                         mxsinj = max( mxsinj, sfmin )
                                    else
                                        call stdlib_${ci}$copy( m, a( 1, q ), 1,cwork(n+1), 1 )
                                         call stdlib_${ci}$lascl( 'G', 0, 0, aaqq, one,m, 1, cwork(n+1)&
                                                   ,lda,ierr )
                                         call stdlib_${ci}$lascl( 'G', 0, 0, aapp, one,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         call stdlib_${ci}$axpy( m, -conjg(aapq),cwork(n+1), 1, a( 1, &
                                                   p ), 1 )
                                         call stdlib_${ci}$lascl( 'G', 0, 0, one, aapp,m, 1, a( 1, p ),&
                                                    lda,ierr )
                                         sva( p ) = aapp*sqrt( max( zero,one-aapq1*aapq1 ) )
                                                   
                                         mxsinj = max( mxsinj, sfmin )
                                    end if
                                   end if
                 ! end if rotok then ... else
                 ! in the case of cancellation in updating sva(q), sva(p)
                 ! .. recompute sva(q), sva(p)
                                   if( ( sva( q ) / aaqq )**2<=rooteps )then
                                      if( ( aaqq<rootbig ) .and.( aaqq>rootsfmin ) ) then
                                         sva( q ) = stdlib_${c2ri(ci)}$znrm2( m, a( 1, q ), 1)
                                       else
                                         t = zero
                                         aaqq = one
                                         call stdlib_${ci}$lassq( m, a( 1, q ), 1, t,aaqq )
                                         sva( q ) = t*sqrt( aaqq )
                                      end if
                                   end if
                                   if( ( aapp / aapp0 )**2<=rooteps ) then
                                      if( ( aapp<rootbig ) .and.( aapp>rootsfmin ) ) then
                                         aapp = stdlib_${c2ri(ci)}$znrm2( m, a( 1, p ), 1 )
                                      else
                                         t = zero
                                         aapp = one
                                         call stdlib_${ci}$lassq( m, a( 1, p ), 1, t,aapp )
                                         aapp = t*sqrt( aapp )
                                      end if
                                      sva( p ) = aapp
                                   end if
                    ! end of ok rotation
                                else
                                   notrot = notrot + 1
      ! [rtd]      skipped  = skipped  + 1
                                   pskipped = pskipped + 1
                                   ijblsk = ijblsk + 1
                                end if
                             else
                                notrot = notrot + 1
                                pskipped = pskipped + 1
                                ijblsk = ijblsk + 1
                             end if
                             if( ( i<=swband ) .and. ( ijblsk>=blskip ) )then
                                sva( p ) = aapp
                                notrot = 0
                                go to 2011
                             end if
                             if( ( i<=swband ) .and.( pskipped>rowskip ) ) then
                                aapp = -aapp
                                notrot = 0
                                go to 2203
                             end if
                          end do loop_2200
              ! end of the q-loop
              2203 continue
                          sva( p ) = aapp
                       else
                          if( aapp==zero )notrot = notrot +min( jgl+kbl-1, n ) - jgl + 1
                          if( aapp<zero )notrot = 0
                       end if
                    end do loop_2100
           ! end of the p-loop
                 end do loop_2010
           ! end of the jbc-loop
           2011 continue
      ! 2011 bailed out of the jbc-loop
                 do p = igl, min( igl+kbl-1, n )
                    sva( p ) = abs( sva( p ) )
                 end do
      ! **
              end do loop_2000
      ! 2000 :: end of the ibr-loop
           ! .. update sva(n)
              if( ( sva( n )<rootbig ) .and. ( sva( n )>rootsfmin ) )then
                 sva( n ) = stdlib_${c2ri(ci)}$znrm2( m, a( 1, n ), 1 )
              else
                 t = zero
                 aapp = one
                 call stdlib_${ci}$lassq( m, a( 1, n ), 1, t, aapp )
                 sva( n ) = t*sqrt( aapp )
              end if
           ! additional steering devices
              if( ( i<swband ) .and. ( ( mxaapq<=roottol ) .or.( iswrot<=n ) ) )swband = i
              if( ( i>swband+1 ) .and. ( mxaapq<sqrt( real( n,KIND=${ck}$) )*tol ) .and. ( real( n,&
                        KIND=${ck}$)*mxaapq*mxsinj<tol ) ) then
                 go to 1994
              end if
              if( notrot>=emptsw )go to 1994
           end do loop_1993
           ! end i=1:nsweep loop
       ! #:( reaching this point means that the procedure has not converged.
           info = nsweep - 1
           go to 1995
           1994 continue
       ! #:) reaching this point means numerical convergence after the i-th
           ! sweep.
           info = 0
       ! #:) info = 0 confirms successful iterations.
       1995 continue
           ! sort the singular values and find how many are above
           ! the underflow threshold.
           n2 = 0
           n4 = 0
           do p = 1, n - 1
              q = stdlib_i${c2ri(ci)}$amax( n-p+1, sva( p ), 1 ) + p - 1
              if( p/=q ) then
                 temp1 = sva( p )
                 sva( p ) = sva( q )
                 sva( q ) = temp1
                 call stdlib_${ci}$swap( m, a( 1, p ), 1, a( 1, q ), 1 )
                 if( rsvec )call stdlib_${ci}$swap( mvl, v( 1, p ), 1, v( 1, q ), 1 )
              end if
              if( sva( p )/=zero ) then
                 n4 = n4 + 1
                 if( sva( p )*skl>sfmin )n2 = n2 + 1
              end if
           end do
           if( sva( n )/=zero ) then
              n4 = n4 + 1
              if( sva( n )*skl>sfmin )n2 = n2 + 1
           end if
           ! normalize the left singular vectors.
           if( lsvec .or. uctol ) then
              do p = 1, n4
                  ! call stdlib_${ci}$dscal( m, one / sva( p ), a( 1, p ), 1 )
                 call stdlib_${ci}$lascl( 'G',0,0, sva(p), one, m, 1, a(1,p), m, ierr )
              end do
           end if
           ! scale the product of jacobi rotations.
           if( rsvec ) then
                 do p = 1, n
                    temp1 = one / stdlib_${c2ri(ci)}$znrm2( mvl, v( 1, p ), 1 )
                    call stdlib_${ci}$dscal( mvl, temp1, v( 1, p ), 1 )
                 end do
           end if
           ! undo scaling, if necessary (and possible).
           if( ( ( skl>one ) .and. ( sva( 1 )<( big / skl ) ) ).or. ( ( skl<one ) .and. ( sva( &
                     max( n2, 1 ) ) >( sfmin / skl ) ) ) ) then
              do p = 1, n
                 sva( p ) = skl*sva( p )
              end do
              skl = one
           end if
           rwork( 1 ) = skl
           ! the singular values of a are skl*sva(1:n). if skl/=one
           ! then some of the singular values may overflow or underflow and
           ! the spectrum is given in this factored representation.
           rwork( 2 ) = real( n4,KIND=${ck}$)
           ! n4 is the number of computed nonzero singular values of a.
           rwork( 3 ) = real( n2,KIND=${ck}$)
           ! n2 is the number of singular values of a greater than sfmin.
           ! if n2<n, sva(n2:n) contains zeros and/or denormalized numbers
           ! that may carry some information.
           rwork( 4 ) = real( i,KIND=${ck}$)
           ! i is the index of the last sweep before declaring convergence.
           rwork( 5 ) = mxaapq
           ! mxaapq is the largest absolute value of scaled pivots in the
           ! last sweep
           rwork( 6 ) = mxsinj
           ! mxsinj is the largest absolute value of the sines of jacobi angles
           ! in the last sweep
           return
     end subroutine stdlib_${ci}$gesvj

#:endif
#:endfor



     module pure subroutine stdlib_sbdsdc( uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq,work, iwork, &
     !! SBDSDC computes the singular value decomposition (SVD) of a real
     !! N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
     !! using a divide and conquer method, where S is a diagonal matrix
     !! with non-negative diagonal elements (the singular values of B), and
     !! U and VT are orthogonal matrices of left and right singular vectors,
     !! respectively. SBDSDC can be used to compute all singular values,
     !! and optionally, singular vectors or singular vectors in compact form.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.  See SLASD3 for details.
     !! The code currently calls SLASDQ if singular values only are desired.
     !! However, it can be slightly modified to compute singular values
     !! using the divide and conquer method.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu, ldvt, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iq(*), iwork(*)
           real(sp), intent(inout) :: d(*), e(*)
           real(sp), intent(out) :: q(*), u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
        ! changed dimension statement in comment describing e from (n) to
        ! (n-1).  sven, 17 feb 05.
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: difl, difr, givcol, givnum, givptr, i, ic, icompq, ierr, ii, is, iu, &
           iuplo, ivt, j, k, kk, mlvl, nm1, nsize, perm, poles, qstart, smlsiz, smlszp, sqre, &
                     start, wstart, z
           real(sp) :: cs, eps, orgnrm, p, r, sn
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           iuplo = 0
           if( stdlib_lsame( uplo, 'U' ) )iuplo = 1
           if( stdlib_lsame( uplo, 'L' ) )iuplo = 2
           if( stdlib_lsame( compq, 'N' ) ) then
              icompq = 0
           else if( stdlib_lsame( compq, 'P' ) ) then
              icompq = 1
           else if( stdlib_lsame( compq, 'I' ) ) then
              icompq = 2
           else
              icompq = -1
           end if
           if( iuplo==0 ) then
              info = -1
           else if( icompq<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ( ldu<1 ) .or. ( ( icompq==2 ) .and. ( ldu<n ) ) ) then
              info = -7
           else if( ( ldvt<1 ) .or. ( ( icompq==2 ) .and. ( ldvt<n ) ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SBDSDC', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           smlsiz = stdlib_ilaenv( 9, 'SBDSDC', ' ', 0, 0, 0, 0 )
           if( n==1 ) then
              if( icompq==1 ) then
                 q( 1 ) = sign( one, d( 1 ) )
                 q( 1+smlsiz*n ) = one
              else if( icompq==2 ) then
                 u( 1, 1 ) = sign( one, d( 1 ) )
                 vt( 1, 1 ) = one
              end if
              d( 1 ) = abs( d( 1 ) )
              return
           end if
           nm1 = n - 1
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           wstart = 1
           qstart = 3
           if( icompq==1 ) then
              call stdlib_scopy( n, d, 1, q( 1 ), 1 )
              call stdlib_scopy( n-1, e, 1, q( n+1 ), 1 )
           end if
           if( iuplo==2 ) then
              qstart = 5
              if( icompq == 2 ) wstart = 2*n - 1
              do i = 1, n - 1
                 call stdlib_slartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 if( icompq==1 ) then
                    q( i+2*n ) = cs
                    q( i+3*n ) = sn
                 else if( icompq==2 ) then
                    work( i ) = cs
                    work( nm1+i ) = -sn
                 end if
              end do
           end if
           ! if icompq = 0, use stdlib_slasdq to compute the singular values.
           if( icompq==0 ) then
              ! ignore wstart, instead using work( 1 ), since the two vectors
              ! for cs and -sn above are added only if icompq == 2,
              ! and adding them exceeds documented work size of 4*n.
              call stdlib_slasdq( 'U', 0, n, 0, 0, 0, d, e, vt, ldvt, u, ldu, u,ldu, work( 1 ), &
                        info )
              go to 40
           end if
           ! if n is smaller than the minimum divide size smlsiz, then solve
           ! the problem with another solver.
           if( n<=smlsiz ) then
              if( icompq==2 ) then
                 call stdlib_slaset( 'A', n, n, zero, one, u, ldu )
                 call stdlib_slaset( 'A', n, n, zero, one, vt, ldvt )
                 call stdlib_slasdq( 'U', 0, n, n, n, 0, d, e, vt, ldvt, u, ldu, u,ldu, work( &
                           wstart ), info )
              else if( icompq==1 ) then
                 iu = 1
                 ivt = iu + n
                 call stdlib_slaset( 'A', n, n, zero, one, q( iu+( qstart-1 )*n ),n )
                 call stdlib_slaset( 'A', n, n, zero, one, q( ivt+( qstart-1 )*n ),n )
                 call stdlib_slasdq( 'U', 0, n, n, n, 0, d, e,q( ivt+( qstart-1 )*n ), n,q( iu+( &
                           qstart-1 )*n ), n,q( iu+( qstart-1 )*n ), n, work( wstart ),info )
              end if
              go to 40
           end if
           if( icompq==2 ) then
              call stdlib_slaset( 'A', n, n, zero, one, u, ldu )
              call stdlib_slaset( 'A', n, n, zero, one, vt, ldvt )
           end if
           ! scale.
           orgnrm = stdlib_slanst( 'M', n, d, e )
           if( orgnrm==zero )return
           call stdlib_slascl( 'G', 0, 0, orgnrm, one, n, 1, d, n, ierr )
           call stdlib_slascl( 'G', 0, 0, orgnrm, one, nm1, 1, e, nm1, ierr )
           eps = stdlib_slamch( 'EPSILON' )
           mlvl = int( log( real( n,KIND=sp) / real( smlsiz+1,KIND=sp) ) / log( two ),KIND=ilp) + &
                     1
           smlszp = smlsiz + 1
           if( icompq==1 ) then
              iu = 1
              ivt = 1 + smlsiz
              difl = ivt + smlszp
              difr = difl + mlvl
              z = difr + mlvl*2
              ic = z + mlvl
              is = ic + 1
              poles = is + 1
              givnum = poles + 2*mlvl
              k = 1
              givptr = 2
              perm = 3
              givcol = perm + mlvl
           end if
           do i = 1, n
              if( abs( d( i ) )<eps ) then
                 d( i ) = sign( eps, d( i ) )
              end if
           end do
           start = 1
           sqre = 0
           loop_30: do i = 1, nm1
              if( ( abs( e( i ) )<eps ) .or. ( i==nm1 ) ) then
              ! subproblem found. first determine its size and then
              ! apply divide and conquer on it.
                 if( i<nm1 ) then
              ! a subproblem with e(i) small for i < nm1.
                    nsize = i - start + 1
                 else if( abs( e( i ) )>=eps ) then
              ! a subproblem with e(nm1) not too small but i = nm1.
                    nsize = n - start + 1
                 else
              ! a subproblem with e(nm1) small. this implies an
              ! 1-by-1 subproblem at d(n). solve this 1-by-1 problem
              ! first.
                    nsize = i - start + 1
                    if( icompq==2 ) then
                       u( n, n ) = sign( one, d( n ) )
                       vt( n, n ) = one
                    else if( icompq==1 ) then
                       q( n+( qstart-1 )*n ) = sign( one, d( n ) )
                       q( n+( smlsiz+qstart-1 )*n ) = one
                    end if
                    d( n ) = abs( d( n ) )
                 end if
                 if( icompq==2 ) then
                    call stdlib_slasd0( nsize, sqre, d( start ), e( start ),u( start, start ), &
                              ldu, vt( start, start ),ldvt, smlsiz, iwork, work( wstart ), info )
                 else
                    call stdlib_slasda( icompq, smlsiz, nsize, sqre, d( start ),e( start ), q( &
                    start+( iu+qstart-2 )*n ), n,q( start+( ivt+qstart-2 )*n ),iq( start+k*n ), q(&
                     start+( difl+qstart-2 )*n ), q( start+( difr+qstart-2 )*n ),q( start+( z+&
                     qstart-2 )*n ),q( start+( poles+qstart-2 )*n ),iq( start+givptr*n ), iq( &
                     start+givcol*n ),n, iq( start+perm*n ),q( start+( givnum+qstart-2 )*n ),q( &
                     start+( ic+qstart-2 )*n ),q( start+( is+qstart-2 )*n ),work( wstart ), iwork,&
                                info )
                 end if
                 if( info/=0 ) then
                    return
                 end if
                 start = i + 1
              end if
           end do loop_30
           ! unscale
           call stdlib_slascl( 'G', 0, 0, one, orgnrm, n, 1, d, n, ierr )
           40 continue
           ! use selection sort to minimize swaps of singular vectors
           do ii = 2, n
              i = ii - 1
              kk = i
              p = d( i )
              do j = ii, n
                 if( d( j )>p ) then
                    kk = j
                    p = d( j )
                 end if
              end do
              if( kk/=i ) then
                 d( kk ) = d( i )
                 d( i ) = p
                 if( icompq==1 ) then
                    iq( i ) = kk
                 else if( icompq==2 ) then
                    call stdlib_sswap( n, u( 1, i ), 1, u( 1, kk ), 1 )
                    call stdlib_sswap( n, vt( i, 1 ), ldvt, vt( kk, 1 ), ldvt )
                 end if
              else if( icompq==1 ) then
                 iq( i ) = i
              end if
           end do
           ! if icompq = 1, use iq(n,1) as the indicator for uplo
           if( icompq==1 ) then
              if( iuplo==1 ) then
                 iq( n ) = 1
              else
                 iq( n ) = 0
              end if
           end if
           ! if b is lower bidiagonal, update u by those givens rotations
           ! which rotated b to be upper bidiagonal
           if( ( iuplo==2 ) .and. ( icompq==2 ) )call stdlib_slasr( 'L', 'V', 'B', n, n, work( 1 )&
                     , work( n ), u, ldu )
           return
     end subroutine stdlib_sbdsdc

     module pure subroutine stdlib_dbdsdc( uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq,work, iwork, &
     !! DBDSDC computes the singular value decomposition (SVD) of a real
     !! N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
     !! using a divide and conquer method, where S is a diagonal matrix
     !! with non-negative diagonal elements (the singular values of B), and
     !! U and VT are orthogonal matrices of left and right singular vectors,
     !! respectively. DBDSDC can be used to compute all singular values,
     !! and optionally, singular vectors or singular vectors in compact form.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.  See DLASD3 for details.
     !! The code currently calls DLASDQ if singular values only are desired.
     !! However, it can be slightly modified to compute singular values
     !! using the divide and conquer method.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu, ldvt, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iq(*), iwork(*)
           real(dp), intent(inout) :: d(*), e(*)
           real(dp), intent(out) :: q(*), u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
        ! changed dimension statement in comment describing e from (n) to
        ! (n-1).  sven, 17 feb 05.
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: difl, difr, givcol, givnum, givptr, i, ic, icompq, ierr, ii, is, iu, &
           iuplo, ivt, j, k, kk, mlvl, nm1, nsize, perm, poles, qstart, smlsiz, smlszp, sqre, &
                     start, wstart, z
           real(dp) :: cs, eps, orgnrm, p, r, sn
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           iuplo = 0
           if( stdlib_lsame( uplo, 'U' ) )iuplo = 1
           if( stdlib_lsame( uplo, 'L' ) )iuplo = 2
           if( stdlib_lsame( compq, 'N' ) ) then
              icompq = 0
           else if( stdlib_lsame( compq, 'P' ) ) then
              icompq = 1
           else if( stdlib_lsame( compq, 'I' ) ) then
              icompq = 2
           else
              icompq = -1
           end if
           if( iuplo==0 ) then
              info = -1
           else if( icompq<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ( ldu<1 ) .or. ( ( icompq==2 ) .and. ( ldu<n ) ) ) then
              info = -7
           else if( ( ldvt<1 ) .or. ( ( icompq==2 ) .and. ( ldvt<n ) ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DBDSDC', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           smlsiz = stdlib_ilaenv( 9, 'DBDSDC', ' ', 0, 0, 0, 0 )
           if( n==1 ) then
              if( icompq==1 ) then
                 q( 1 ) = sign( one, d( 1 ) )
                 q( 1+smlsiz*n ) = one
              else if( icompq==2 ) then
                 u( 1, 1 ) = sign( one, d( 1 ) )
                 vt( 1, 1 ) = one
              end if
              d( 1 ) = abs( d( 1 ) )
              return
           end if
           nm1 = n - 1
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           wstart = 1
           qstart = 3
           if( icompq==1 ) then
              call stdlib_dcopy( n, d, 1, q( 1 ), 1 )
              call stdlib_dcopy( n-1, e, 1, q( n+1 ), 1 )
           end if
           if( iuplo==2 ) then
              qstart = 5
              if( icompq == 2 ) wstart = 2*n - 1
              do i = 1, n - 1
                 call stdlib_dlartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 if( icompq==1 ) then
                    q( i+2*n ) = cs
                    q( i+3*n ) = sn
                 else if( icompq==2 ) then
                    work( i ) = cs
                    work( nm1+i ) = -sn
                 end if
              end do
           end if
           ! if icompq = 0, use stdlib_dlasdq to compute the singular values.
           if( icompq==0 ) then
              ! ignore wstart, instead using work( 1 ), since the two vectors
              ! for cs and -sn above are added only if icompq == 2,
              ! and adding them exceeds documented work size of 4*n.
              call stdlib_dlasdq( 'U', 0, n, 0, 0, 0, d, e, vt, ldvt, u, ldu, u,ldu, work( 1 ), &
                        info )
              go to 40
           end if
           ! if n is smaller than the minimum divide size smlsiz, then solve
           ! the problem with another solver.
           if( n<=smlsiz ) then
              if( icompq==2 ) then
                 call stdlib_dlaset( 'A', n, n, zero, one, u, ldu )
                 call stdlib_dlaset( 'A', n, n, zero, one, vt, ldvt )
                 call stdlib_dlasdq( 'U', 0, n, n, n, 0, d, e, vt, ldvt, u, ldu, u,ldu, work( &
                           wstart ), info )
              else if( icompq==1 ) then
                 iu = 1
                 ivt = iu + n
                 call stdlib_dlaset( 'A', n, n, zero, one, q( iu+( qstart-1 )*n ),n )
                 call stdlib_dlaset( 'A', n, n, zero, one, q( ivt+( qstart-1 )*n ),n )
                 call stdlib_dlasdq( 'U', 0, n, n, n, 0, d, e,q( ivt+( qstart-1 )*n ), n,q( iu+( &
                           qstart-1 )*n ), n,q( iu+( qstart-1 )*n ), n, work( wstart ),info )
              end if
              go to 40
           end if
           if( icompq==2 ) then
              call stdlib_dlaset( 'A', n, n, zero, one, u, ldu )
              call stdlib_dlaset( 'A', n, n, zero, one, vt, ldvt )
           end if
           ! scale.
           orgnrm = stdlib_dlanst( 'M', n, d, e )
           if( orgnrm==zero )return
           call stdlib_dlascl( 'G', 0, 0, orgnrm, one, n, 1, d, n, ierr )
           call stdlib_dlascl( 'G', 0, 0, orgnrm, one, nm1, 1, e, nm1, ierr )
           eps = (0.9e+0_dp)*stdlib_dlamch( 'EPSILON' )
           mlvl = int( log( real( n,KIND=dp) / real( smlsiz+1,KIND=dp) ) / log( two ),KIND=ilp) + &
                     1
           smlszp = smlsiz + 1
           if( icompq==1 ) then
              iu = 1
              ivt = 1 + smlsiz
              difl = ivt + smlszp
              difr = difl + mlvl
              z = difr + mlvl*2
              ic = z + mlvl
              is = ic + 1
              poles = is + 1
              givnum = poles + 2*mlvl
              k = 1
              givptr = 2
              perm = 3
              givcol = perm + mlvl
           end if
           do i = 1, n
              if( abs( d( i ) )<eps ) then
                 d( i ) = sign( eps, d( i ) )
              end if
           end do
           start = 1
           sqre = 0
           loop_30: do i = 1, nm1
              if( ( abs( e( i ) )<eps ) .or. ( i==nm1 ) ) then
                 ! subproblem found. first determine its size and then
                 ! apply divide and conquer on it.
                 if( i<nm1 ) then
                    ! a subproblem with e(i) small for i < nm1.
                    nsize = i - start + 1
                 else if( abs( e( i ) )>=eps ) then
                    ! a subproblem with e(nm1) not too small but i = nm1.
                    nsize = n - start + 1
                 else
                    ! a subproblem with e(nm1) small. this implies an
                    ! 1-by-1 subproblem at d(n). solve this 1-by-1 problem
                    ! first.
                    nsize = i - start + 1
                    if( icompq==2 ) then
                       u( n, n ) = sign( one, d( n ) )
                       vt( n, n ) = one
                    else if( icompq==1 ) then
                       q( n+( qstart-1 )*n ) = sign( one, d( n ) )
                       q( n+( smlsiz+qstart-1 )*n ) = one
                    end if
                    d( n ) = abs( d( n ) )
                 end if
                 if( icompq==2 ) then
                    call stdlib_dlasd0( nsize, sqre, d( start ), e( start ),u( start, start ), &
                              ldu, vt( start, start ),ldvt, smlsiz, iwork, work( wstart ), info )
                 else
                    call stdlib_dlasda( icompq, smlsiz, nsize, sqre, d( start ),e( start ), q( &
                    start+( iu+qstart-2 )*n ), n,q( start+( ivt+qstart-2 )*n ),iq( start+k*n ), q(&
                     start+( difl+qstart-2 )*n ), q( start+( difr+qstart-2 )*n ),q( start+( z+&
                     qstart-2 )*n ),q( start+( poles+qstart-2 )*n ),iq( start+givptr*n ), iq( &
                     start+givcol*n ),n, iq( start+perm*n ),q( start+( givnum+qstart-2 )*n ),q( &
                     start+( ic+qstart-2 )*n ),q( start+( is+qstart-2 )*n ),work( wstart ), iwork,&
                                info )
                 end if
                 if( info/=0 ) then
                    return
                 end if
                 start = i + 1
              end if
           end do loop_30
           ! unscale
           call stdlib_dlascl( 'G', 0, 0, one, orgnrm, n, 1, d, n, ierr )
           40 continue
           ! use selection sort to minimize swaps of singular vectors
           do ii = 2, n
              i = ii - 1
              kk = i
              p = d( i )
              do j = ii, n
                 if( d( j )>p ) then
                    kk = j
                    p = d( j )
                 end if
              end do
              if( kk/=i ) then
                 d( kk ) = d( i )
                 d( i ) = p
                 if( icompq==1 ) then
                    iq( i ) = kk
                 else if( icompq==2 ) then
                    call stdlib_dswap( n, u( 1, i ), 1, u( 1, kk ), 1 )
                    call stdlib_dswap( n, vt( i, 1 ), ldvt, vt( kk, 1 ), ldvt )
                 end if
              else if( icompq==1 ) then
                 iq( i ) = i
              end if
           end do
           ! if icompq = 1, use iq(n,1) as the indicator for uplo
           if( icompq==1 ) then
              if( iuplo==1 ) then
                 iq( n ) = 1
              else
                 iq( n ) = 0
              end if
           end if
           ! if b is lower bidiagonal, update u by those givens rotations
           ! which rotated b to be upper bidiagonal
           if( ( iuplo==2 ) .and. ( icompq==2 ) )call stdlib_dlasr( 'L', 'V', 'B', n, n, work( 1 )&
                     , work( n ), u, ldu )
           return
     end subroutine stdlib_dbdsdc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$bdsdc( uplo, compq, n, d, e, u, ldu, vt, ldvt, q, iq,work, iwork, &
     !! DBDSDC: computes the singular value decomposition (SVD) of a real
     !! N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
     !! using a divide and conquer method, where S is a diagonal matrix
     !! with non-negative diagonal elements (the singular values of B), and
     !! U and VT are orthogonal matrices of left and right singular vectors,
     !! respectively. DBDSDC can be used to compute all singular values,
     !! and optionally, singular vectors or singular vectors in compact form.
     !! This code makes very mild assumptions about floating point
     !! arithmetic. It will work on machines with a guard digit in
     !! add/subtract, or on those binary machines without guard digits
     !! which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
     !! It could conceivably fail on hexadecimal or decimal machines
     !! without guard digits, but we know of none.  See DLASD3 for details.
     !! The code currently calls DLASDQ if singular values only are desired.
     !! However, it can be slightly modified to compute singular values
     !! using the divide and conquer method.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu, ldvt, n
           ! Array Arguments 
           integer(ilp), intent(out) :: iq(*), iwork(*)
           real(${rk}$), intent(inout) :: d(*), e(*)
           real(${rk}$), intent(out) :: q(*), u(ldu,*), vt(ldvt,*), work(*)
        ! =====================================================================
        ! changed dimension statement in comment describing e from (n) to
        ! (n-1).  sven, 17 feb 05.
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: difl, difr, givcol, givnum, givptr, i, ic, icompq, ierr, ii, is, iu, &
           iuplo, ivt, j, k, kk, mlvl, nm1, nsize, perm, poles, qstart, smlsiz, smlszp, sqre, &
                     start, wstart, z
           real(${rk}$) :: cs, eps, orgnrm, p, r, sn
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           iuplo = 0
           if( stdlib_lsame( uplo, 'U' ) )iuplo = 1
           if( stdlib_lsame( uplo, 'L' ) )iuplo = 2
           if( stdlib_lsame( compq, 'N' ) ) then
              icompq = 0
           else if( stdlib_lsame( compq, 'P' ) ) then
              icompq = 1
           else if( stdlib_lsame( compq, 'I' ) ) then
              icompq = 2
           else
              icompq = -1
           end if
           if( iuplo==0 ) then
              info = -1
           else if( icompq<0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ( ldu<1 ) .or. ( ( icompq==2 ) .and. ( ldu<n ) ) ) then
              info = -7
           else if( ( ldvt<1 ) .or. ( ( icompq==2 ) .and. ( ldvt<n ) ) ) then
              info = -9
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DBDSDC', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           smlsiz = stdlib_ilaenv( 9, 'DBDSDC', ' ', 0, 0, 0, 0 )
           if( n==1 ) then
              if( icompq==1 ) then
                 q( 1 ) = sign( one, d( 1 ) )
                 q( 1+smlsiz*n ) = one
              else if( icompq==2 ) then
                 u( 1, 1 ) = sign( one, d( 1 ) )
                 vt( 1, 1 ) = one
              end if
              d( 1 ) = abs( d( 1 ) )
              return
           end if
           nm1 = n - 1
           ! if matrix lower bidiagonal, rotate to be upper bidiagonal
           ! by applying givens rotations on the left
           wstart = 1
           qstart = 3
           if( icompq==1 ) then
              call stdlib_${ri}$copy( n, d, 1, q( 1 ), 1 )
              call stdlib_${ri}$copy( n-1, e, 1, q( n+1 ), 1 )
           end if
           if( iuplo==2 ) then
              qstart = 5
              if( icompq == 2 ) wstart = 2*n - 1
              do i = 1, n - 1
                 call stdlib_${ri}$lartg( d( i ), e( i ), cs, sn, r )
                 d( i ) = r
                 e( i ) = sn*d( i+1 )
                 d( i+1 ) = cs*d( i+1 )
                 if( icompq==1 ) then
                    q( i+2*n ) = cs
                    q( i+3*n ) = sn
                 else if( icompq==2 ) then
                    work( i ) = cs
                    work( nm1+i ) = -sn
                 end if
              end do
           end if
           ! if icompq = 0, use stdlib_${ri}$lasdq to compute the singular values.
           if( icompq==0 ) then
              ! ignore wstart, instead using work( 1 ), since the two vectors
              ! for cs and -sn above are added only if icompq == 2,
              ! and adding them exceeds documented work size of 4*n.
              call stdlib_${ri}$lasdq( 'U', 0, n, 0, 0, 0, d, e, vt, ldvt, u, ldu, u,ldu, work( 1 ), &
                        info )
              go to 40
           end if
           ! if n is smaller than the minimum divide size smlsiz, then solve
           ! the problem with another solver.
           if( n<=smlsiz ) then
              if( icompq==2 ) then
                 call stdlib_${ri}$laset( 'A', n, n, zero, one, u, ldu )
                 call stdlib_${ri}$laset( 'A', n, n, zero, one, vt, ldvt )
                 call stdlib_${ri}$lasdq( 'U', 0, n, n, n, 0, d, e, vt, ldvt, u, ldu, u,ldu, work( &
                           wstart ), info )
              else if( icompq==1 ) then
                 iu = 1
                 ivt = iu + n
                 call stdlib_${ri}$laset( 'A', n, n, zero, one, q( iu+( qstart-1 )*n ),n )
                 call stdlib_${ri}$laset( 'A', n, n, zero, one, q( ivt+( qstart-1 )*n ),n )
                 call stdlib_${ri}$lasdq( 'U', 0, n, n, n, 0, d, e,q( ivt+( qstart-1 )*n ), n,q( iu+( &
                           qstart-1 )*n ), n,q( iu+( qstart-1 )*n ), n, work( wstart ),info )
              end if
              go to 40
           end if
           if( icompq==2 ) then
              call stdlib_${ri}$laset( 'A', n, n, zero, one, u, ldu )
              call stdlib_${ri}$laset( 'A', n, n, zero, one, vt, ldvt )
           end if
           ! scale.
           orgnrm = stdlib_${ri}$lanst( 'M', n, d, e )
           if( orgnrm==zero )return
           call stdlib_${ri}$lascl( 'G', 0, 0, orgnrm, one, n, 1, d, n, ierr )
           call stdlib_${ri}$lascl( 'G', 0, 0, orgnrm, one, nm1, 1, e, nm1, ierr )
           eps = (0.9e+0_${rk}$)*stdlib_${ri}$lamch( 'EPSILON' )
           mlvl = int( log( real( n,KIND=${rk}$) / real( smlsiz+1,KIND=${rk}$) ) / log( two ),KIND=ilp) + &
                     1
           smlszp = smlsiz + 1
           if( icompq==1 ) then
              iu = 1
              ivt = 1 + smlsiz
              difl = ivt + smlszp
              difr = difl + mlvl
              z = difr + mlvl*2
              ic = z + mlvl
              is = ic + 1
              poles = is + 1
              givnum = poles + 2*mlvl
              k = 1
              givptr = 2
              perm = 3
              givcol = perm + mlvl
           end if
           do i = 1, n
              if( abs( d( i ) )<eps ) then
                 d( i ) = sign( eps, d( i ) )
              end if
           end do
           start = 1
           sqre = 0
           loop_30: do i = 1, nm1
              if( ( abs( e( i ) )<eps ) .or. ( i==nm1 ) ) then
                 ! subproblem found. first determine its size and then
                 ! apply divide and conquer on it.
                 if( i<nm1 ) then
                    ! a subproblem with e(i) small for i < nm1.
                    nsize = i - start + 1
                 else if( abs( e( i ) )>=eps ) then
                    ! a subproblem with e(nm1) not too small but i = nm1.
                    nsize = n - start + 1
                 else
                    ! a subproblem with e(nm1) small. this implies an
                    ! 1-by-1 subproblem at d(n). solve this 1-by-1 problem
                    ! first.
                    nsize = i - start + 1
                    if( icompq==2 ) then
                       u( n, n ) = sign( one, d( n ) )
                       vt( n, n ) = one
                    else if( icompq==1 ) then
                       q( n+( qstart-1 )*n ) = sign( one, d( n ) )
                       q( n+( smlsiz+qstart-1 )*n ) = one
                    end if
                    d( n ) = abs( d( n ) )
                 end if
                 if( icompq==2 ) then
                    call stdlib_${ri}$lasd0( nsize, sqre, d( start ), e( start ),u( start, start ), &
                              ldu, vt( start, start ),ldvt, smlsiz, iwork, work( wstart ), info )
                 else
                    call stdlib_${ri}$lasda( icompq, smlsiz, nsize, sqre, d( start ),e( start ), q( &
                    start+( iu+qstart-2 )*n ), n,q( start+( ivt+qstart-2 )*n ),iq( start+k*n ), q(&
                     start+( difl+qstart-2 )*n ), q( start+( difr+qstart-2 )*n ),q( start+( z+&
                     qstart-2 )*n ),q( start+( poles+qstart-2 )*n ),iq( start+givptr*n ), iq( &
                     start+givcol*n ),n, iq( start+perm*n ),q( start+( givnum+qstart-2 )*n ),q( &
                     start+( ic+qstart-2 )*n ),q( start+( is+qstart-2 )*n ),work( wstart ), iwork,&
                                info )
                 end if
                 if( info/=0 ) then
                    return
                 end if
                 start = i + 1
              end if
           end do loop_30
           ! unscale
           call stdlib_${ri}$lascl( 'G', 0, 0, one, orgnrm, n, 1, d, n, ierr )
           40 continue
           ! use selection sort to minimize swaps of singular vectors
           do ii = 2, n
              i = ii - 1
              kk = i
              p = d( i )
              do j = ii, n
                 if( d( j )>p ) then
                    kk = j
                    p = d( j )
                 end if
              end do
              if( kk/=i ) then
                 d( kk ) = d( i )
                 d( i ) = p
                 if( icompq==1 ) then
                    iq( i ) = kk
                 else if( icompq==2 ) then
                    call stdlib_${ri}$swap( n, u( 1, i ), 1, u( 1, kk ), 1 )
                    call stdlib_${ri}$swap( n, vt( i, 1 ), ldvt, vt( kk, 1 ), ldvt )
                 end if
              else if( icompq==1 ) then
                 iq( i ) = i
              end if
           end do
           ! if icompq = 1, use iq(n,1) as the indicator for uplo
           if( icompq==1 ) then
              if( iuplo==1 ) then
                 iq( n ) = 1
              else
                 iq( n ) = 0
              end if
           end if
           ! if b is lower bidiagonal, update u by those givens rotations
           ! which rotated b to be upper bidiagonal
           if( ( iuplo==2 ) .and. ( icompq==2 ) )call stdlib_${ri}$lasr( 'L', 'V', 'B', n, n, work( 1 )&
                     , work( n ), u, ldu )
           return
     end subroutine stdlib_${ri}$bdsdc

#:endif
#:endfor




end submodule stdlib_lapack_eigv_svd_drivers2
