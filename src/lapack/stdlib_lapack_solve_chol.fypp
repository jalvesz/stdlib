#:include "common.fypp" 
module stdlib_lapack_solve_chol
  use stdlib_linalg_constants
  use stdlib_linalg_lapack_aux
  use stdlib_linalg_blas
  use stdlib_lapack_blas_like_mnorm
  use stdlib_lapack_solve_chol_comp
  use stdlib_lapack_blas_like_base
  implicit none(type,external)


  contains



     pure subroutine stdlib_sppsv( uplo, n, nrhs, ap, b, ldb, info )
     !! SPPSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric positive definite matrix stored in
     !! packed format and X and B are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**T* U,  if UPLO = 'U', or
     !! A = L * L**T,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is a lower triangular
     !! matrix.  The factored form of A is then used to solve the system of
     !! equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(sp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SPPSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**t*u or a = l*l**t.
           call stdlib_spptrf( uplo, n, ap, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_spptrs( uplo, n, nrhs, ap, b, ldb, info )
           end if
           return
     end subroutine stdlib_sppsv

     pure subroutine stdlib_dppsv( uplo, n, nrhs, ap, b, ldb, info )
     !! DPPSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric positive definite matrix stored in
     !! packed format and X and B are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**T* U,  if UPLO = 'U', or
     !! A = L * L**T,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is a lower triangular
     !! matrix.  The factored form of A is then used to solve the system of
     !! equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(dp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPPSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**t*u or a = l*l**t.
           call stdlib_dpptrf( uplo, n, ap, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_dpptrs( uplo, n, nrhs, ap, b, ldb, info )
           end if
           return
     end subroutine stdlib_dppsv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$ppsv( uplo, n, nrhs, ap, b, ldb, info )
     !! DPPSV: computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric positive definite matrix stored in
     !! packed format and X and B are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**T* U,  if UPLO = 'U', or
     !! A = L * L**T,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is a lower triangular
     !! matrix.  The factored form of A is then used to solve the system of
     !! equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPPSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**t*u or a = l*l**t.
           call stdlib_${ri}$pptrf( uplo, n, ap, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ri}$pptrs( uplo, n, nrhs, ap, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ri}$ppsv

#:endif
#:endfor

     pure subroutine stdlib_cppsv( uplo, n, nrhs, ap, b, ldb, info )
     !! CPPSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian positive definite matrix stored in
     !! packed format and X and B are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**H * U,  if UPLO = 'U', or
     !! A = L * L**H,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is a lower triangular
     !! matrix.  The factored form of A is then used to solve the system of
     !! equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           complex(sp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPPSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**h *u or a = l*l**h.
           call stdlib_cpptrf( uplo, n, ap, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_cpptrs( uplo, n, nrhs, ap, b, ldb, info )
           end if
           return
     end subroutine stdlib_cppsv

     pure subroutine stdlib_zppsv( uplo, n, nrhs, ap, b, ldb, info )
     !! ZPPSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian positive definite matrix stored in
     !! packed format and X and B are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**H * U,  if UPLO = 'U', or
     !! A = L * L**H,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is a lower triangular
     !! matrix.  The factored form of A is then used to solve the system of
     !! equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           complex(dp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZPPSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**h *u or a = l*l**h.
           call stdlib_zpptrf( uplo, n, ap, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_zpptrs( uplo, n, nrhs, ap, b, ldb, info )
           end if
           return
     end subroutine stdlib_zppsv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$ppsv( uplo, n, nrhs, ap, b, ldb, info )
     !! ZPPSV: computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian positive definite matrix stored in
     !! packed format and X and B are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**H * U,  if UPLO = 'U', or
     !! A = L * L**H,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is a lower triangular
     !! matrix.  The factored form of A is then used to solve the system of
     !! equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZPPSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**h *u or a = l*l**h.
           call stdlib_${ci}$pptrf( uplo, n, ap, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ci}$pptrs( uplo, n, nrhs, ap, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ci}$ppsv

#:endif
#:endfor







     pure subroutine stdlib_sptsv( n, nrhs, d, e, b, ldb, info )
     !! SPTSV computes the solution to a real system of linear equations
     !! A*X = B, where A is an N-by-N symmetric positive definite tridiagonal
     !! matrix, and X and B are N-by-NRHS matrices.
     !! A is factored as A = L*D*L**T, and the factored form of A is then
     !! used to solve the system of equations.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(sp), intent(inout) :: b(ldb,*), d(*), e(*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( nrhs<0 ) then
              info = -2
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SPTSV ', -info )
              return
           end if
           ! compute the l*d*l**t (or u**t*d*u) factorization of a.
           call stdlib_spttrf( n, d, e, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_spttrs( n, nrhs, d, e, b, ldb, info )
           end if
           return
     end subroutine stdlib_sptsv

     pure subroutine stdlib_dptsv( n, nrhs, d, e, b, ldb, info )
     !! DPTSV computes the solution to a real system of linear equations
     !! A*X = B, where A is an N-by-N symmetric positive definite tridiagonal
     !! matrix, and X and B are N-by-NRHS matrices.
     !! A is factored as A = L*D*L**T, and the factored form of A is then
     !! used to solve the system of equations.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(dp), intent(inout) :: b(ldb,*), d(*), e(*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( nrhs<0 ) then
              info = -2
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPTSV ', -info )
              return
           end if
           ! compute the l*d*l**t (or u**t*d*u) factorization of a.
           call stdlib_dpttrf( n, d, e, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_dpttrs( n, nrhs, d, e, b, ldb, info )
           end if
           return
     end subroutine stdlib_dptsv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$ptsv( n, nrhs, d, e, b, ldb, info )
     !! DPTSV: computes the solution to a real system of linear equations
     !! A*X = B, where A is an N-by-N symmetric positive definite tridiagonal
     !! matrix, and X and B are N-by-NRHS matrices.
     !! A is factored as A = L*D*L**T, and the factored form of A is then
     !! used to solve the system of equations.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(inout) :: b(ldb,*), d(*), e(*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( nrhs<0 ) then
              info = -2
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPTSV ', -info )
              return
           end if
           ! compute the l*d*l**t (or u**t*d*u) factorization of a.
           call stdlib_${ri}$pttrf( n, d, e, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ri}$pttrs( n, nrhs, d, e, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ri}$ptsv

#:endif
#:endfor

     pure subroutine stdlib_cptsv( n, nrhs, d, e, b, ldb, info )
     !! CPTSV computes the solution to a complex system of linear equations
     !! A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal
     !! matrix, and X and B are N-by-NRHS matrices.
     !! A is factored as A = L*D*L**H, and the factored form of A is then
     !! used to solve the system of equations.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(sp), intent(inout) :: d(*)
           complex(sp), intent(inout) :: b(ldb,*), e(*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( nrhs<0 ) then
              info = -2
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPTSV ', -info )
              return
           end if
           ! compute the l*d*l**h (or u**h*d*u) factorization of a.
           call stdlib_cpttrf( n, d, e, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_cpttrs( 'LOWER', n, nrhs, d, e, b, ldb, info )
           end if
           return
     end subroutine stdlib_cptsv

     pure subroutine stdlib_zptsv( n, nrhs, d, e, b, ldb, info )
     !! ZPTSV computes the solution to a complex system of linear equations
     !! A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal
     !! matrix, and X and B are N-by-NRHS matrices.
     !! A is factored as A = L*D*L**H, and the factored form of A is then
     !! used to solve the system of equations.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(dp), intent(inout) :: d(*)
           complex(dp), intent(inout) :: b(ldb,*), e(*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( nrhs<0 ) then
              info = -2
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZPTSV ', -info )
              return
           end if
           ! compute the l*d*l**h (or u**h*d*u) factorization of a.
           call stdlib_zpttrf( n, d, e, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_zpttrs( 'LOWER', n, nrhs, d, e, b, ldb, info )
           end if
           return
     end subroutine stdlib_zptsv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$ptsv( n, nrhs, d, e, b, ldb, info )
     !! ZPTSV: computes the solution to a complex system of linear equations
     !! A*X = B, where A is an N-by-N Hermitian positive definite tridiagonal
     !! matrix, and X and B are N-by-NRHS matrices.
     !! A is factored as A = L*D*L**H, and the factored form of A is then
     !! used to solve the system of equations.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           real(${ck}$), intent(inout) :: d(*)
           complex(${ck}$), intent(inout) :: b(ldb,*), e(*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( n<0 ) then
              info = -1
           else if( nrhs<0 ) then
              info = -2
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZPTSV ', -info )
              return
           end if
           ! compute the l*d*l**h (or u**h*d*u) factorization of a.
           call stdlib_${ci}$pttrf( n, d, e, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ci}$pttrs( 'LOWER', n, nrhs, d, e, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ci}$ptsv

#:endif
#:endfor



     pure subroutine stdlib_sposv( uplo, n, nrhs, a, lda, b, ldb, info )
     !! SPOSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric positive definite matrix and X and B
     !! are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**T* U,  if UPLO = 'U', or
     !! A = L * L**T,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is a lower triangular
     !! matrix.  The factored form of A is then used to solve the system of
     !! equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SPOSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**t*u or a = l*l**t.
           call stdlib_spotrf( uplo, n, a, lda, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_spotrs( uplo, n, nrhs, a, lda, b, ldb, info )
           end if
           return
     end subroutine stdlib_sposv

     pure subroutine stdlib_dposv( uplo, n, nrhs, a, lda, b, ldb, info )
     !! DPOSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric positive definite matrix and X and B
     !! are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**T* U,  if UPLO = 'U', or
     !! A = L * L**T,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is a lower triangular
     !! matrix.  The factored form of A is then used to solve the system of
     !! equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPOSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**t*u or a = l*l**t.
           call stdlib_dpotrf( uplo, n, a, lda, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_dpotrs( uplo, n, nrhs, a, lda, b, ldb, info )
           end if
           return
     end subroutine stdlib_dposv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$posv( uplo, n, nrhs, a, lda, b, ldb, info )
     !! DPOSV: computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric positive definite matrix and X and B
     !! are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**T* U,  if UPLO = 'U', or
     !! A = L * L**T,  if UPLO = 'L',
     !! where U is an upper triangular matrix and L is a lower triangular
     !! matrix.  The factored form of A is then used to solve the system of
     !! equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPOSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**t*u or a = l*l**t.
           call stdlib_${ri}$potrf( uplo, n, a, lda, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ri}$potrs( uplo, n, nrhs, a, lda, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ri}$posv

#:endif
#:endfor

     pure subroutine stdlib_cposv( uplo, n, nrhs, a, lda, b, ldb, info )
     !! CPOSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian positive definite matrix and X and B
     !! are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**H* U,  if UPLO = 'U', or
     !! A = L * L**H,  if UPLO = 'L',
     !! where U is an upper triangular matrix and  L is a lower triangular
     !! matrix.  The factored form of A is then used to solve the system of
     !! equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPOSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**h*u or a = l*l**h.
           call stdlib_cpotrf( uplo, n, a, lda, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_cpotrs( uplo, n, nrhs, a, lda, b, ldb, info )
           end if
           return
     end subroutine stdlib_cposv

     pure subroutine stdlib_zposv( uplo, n, nrhs, a, lda, b, ldb, info )
     !! ZPOSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian positive definite matrix and X and B
     !! are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**H* U,  if UPLO = 'U', or
     !! A = L * L**H,  if UPLO = 'L',
     !! where U is an upper triangular matrix and  L is a lower triangular
     !! matrix.  The factored form of A is then used to solve the system of
     !! equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZPOSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**h *u or a = l*l**h.
           call stdlib_zpotrf( uplo, n, a, lda, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_zpotrs( uplo, n, nrhs, a, lda, b, ldb, info )
           end if
           return
     end subroutine stdlib_zposv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$posv( uplo, n, nrhs, a, lda, b, ldb, info )
     !! ZPOSV: computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian positive definite matrix and X and B
     !! are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**H* U,  if UPLO = 'U', or
     !! A = L * L**H,  if UPLO = 'L',
     !! where U is an upper triangular matrix and  L is a lower triangular
     !! matrix.  The factored form of A is then used to solve the system of
     !! equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, n, nrhs
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZPOSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**h *u or a = l*l**h.
           call stdlib_${ci}$potrf( uplo, n, a, lda, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ci}$potrs( uplo, n, nrhs, a, lda, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ci}$posv

#:endif
#:endfor



     pure subroutine stdlib_sptsvx( fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx,rcond, ferr, berr,&
     !! SPTSVX uses the factorization A = L*D*L**T to compute the solution
     !! to a real system of linear equations A*X = B, where A is an N-by-N
     !! symmetric positive definite tridiagonal matrix and X and B are
     !! N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
                work, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           real(sp), intent(in) :: b(ldb,*), d(*), e(*)
           real(sp), intent(out) :: berr(*), ferr(*), work(*), x(ldx,*)
           real(sp), intent(inout) :: df(*), ef(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(sp) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SPTSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the l*d*l**t (or u**t*d*u) factorization of a.
              call stdlib_scopy( n, d, 1, df, 1 )
              if( n>1 )call stdlib_scopy( n-1, e, 1, ef, 1 )
              call stdlib_spttrf( n, df, ef, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_slanst( '1', n, d, e )
           ! compute the reciprocal of the condition number of a.
           call stdlib_sptcon( n, df, ef, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_slacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_spttrs( n, nrhs, df, ef, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_sptrfs( n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr,work, info )
                     
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_sptsvx

     pure subroutine stdlib_dptsvx( fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx,rcond, ferr, berr,&
     !! DPTSVX uses the factorization A = L*D*L**T to compute the solution
     !! to a real system of linear equations A*X = B, where A is an N-by-N
     !! symmetric positive definite tridiagonal matrix and X and B are
     !! N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
                work, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(dp), intent(out) :: rcond
           ! Array Arguments 
           real(dp), intent(in) :: b(ldb,*), d(*), e(*)
           real(dp), intent(out) :: berr(*), ferr(*), work(*), x(ldx,*)
           real(dp), intent(inout) :: df(*), ef(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(dp) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPTSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the l*d*l**t (or u**t*d*u) factorization of a.
              call stdlib_dcopy( n, d, 1, df, 1 )
              if( n>1 )call stdlib_dcopy( n-1, e, 1, ef, 1 )
              call stdlib_dpttrf( n, df, ef, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_dlanst( '1', n, d, e )
           ! compute the reciprocal of the condition number of a.
           call stdlib_dptcon( n, df, ef, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_dlacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_dpttrs( n, nrhs, df, ef, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_dptrfs( n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr,work, info )
                     
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_dlamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_dptsvx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$ptsvx( fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx,rcond, ferr, berr,&
     !! DPTSVX: uses the factorization A = L*D*L**T to compute the solution
     !! to a real system of linear equations A*X = B, where A is an N-by-N
     !! symmetric positive definite tridiagonal matrix and X and B are
     !! N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
                work, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           real(${rk}$), intent(in) :: b(ldb,*), d(*), e(*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*), x(ldx,*)
           real(${rk}$), intent(inout) :: df(*), ef(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(${rk}$) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPTSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the l*d*l**t (or u**t*d*u) factorization of a.
              call stdlib_${ri}$copy( n, d, 1, df, 1 )
              if( n>1 )call stdlib_${ri}$copy( n-1, e, 1, ef, 1 )
              call stdlib_${ri}$pttrf( n, df, ef, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_${ri}$lanst( '1', n, d, e )
           ! compute the reciprocal of the condition number of a.
           call stdlib_${ri}$ptcon( n, df, ef, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_${ri}$lacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ri}$pttrs( n, nrhs, df, ef, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_${ri}$ptrfs( n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr, berr,work, info )
                     
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_${ri}$lamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_${ri}$ptsvx

#:endif
#:endfor

     pure subroutine stdlib_cptsvx( fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx,rcond, ferr, berr,&
     !! CPTSVX uses the factorization A = L*D*L**H to compute the solution
     !! to a complex system of linear equations A*X = B, where A is an
     !! N-by-N Hermitian positive definite tridiagonal matrix and X and B
     !! are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
                work, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           real(sp), intent(in) :: d(*)
           real(sp), intent(inout) :: df(*)
           complex(sp), intent(in) :: b(ldb,*), e(*)
           complex(sp), intent(inout) :: ef(*)
           complex(sp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(sp) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPTSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the l*d*l**h (or u**h*d*u) factorization of a.
              call stdlib_scopy( n, d, 1, df, 1 )
              if( n>1 )call stdlib_ccopy( n-1, e, 1, ef, 1 )
              call stdlib_cpttrf( n, df, ef, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_clanht( '1', n, d, e )
           ! compute the reciprocal of the condition number of a.
           call stdlib_cptcon( n, df, ef, anorm, rcond, rwork, info )
           ! compute the solution vectors x.
           call stdlib_clacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_cpttrs( 'LOWER', n, nrhs, df, ef, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_cptrfs( 'LOWER', n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr,berr, work, &
                     rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_cptsvx

     pure subroutine stdlib_zptsvx( fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx,rcond, ferr, berr,&
     !! ZPTSVX uses the factorization A = L*D*L**H to compute the solution
     !! to a complex system of linear equations A*X = B, where A is an
     !! N-by-N Hermitian positive definite tridiagonal matrix and X and B
     !! are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
                work, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(dp), intent(out) :: rcond
           ! Array Arguments 
           real(dp), intent(out) :: berr(*), ferr(*), rwork(*)
           real(dp), intent(in) :: d(*)
           real(dp), intent(inout) :: df(*)
           complex(dp), intent(in) :: b(ldb,*), e(*)
           complex(dp), intent(inout) :: ef(*)
           complex(dp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(dp) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZPTSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the l*d*l**h (or u**h*d*u) factorization of a.
              call stdlib_dcopy( n, d, 1, df, 1 )
              if( n>1 )call stdlib_zcopy( n-1, e, 1, ef, 1 )
              call stdlib_zpttrf( n, df, ef, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_zlanht( '1', n, d, e )
           ! compute the reciprocal of the condition number of a.
           call stdlib_zptcon( n, df, ef, anorm, rcond, rwork, info )
           ! compute the solution vectors x.
           call stdlib_zlacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_zpttrs( 'LOWER', n, nrhs, df, ef, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_zptrfs( 'LOWER', n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr,berr, work, &
                     rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_dlamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_zptsvx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$ptsvx( fact, n, nrhs, d, e, df, ef, b, ldb, x, ldx,rcond, ferr, berr,&
     !! ZPTSVX: uses the factorization A = L*D*L**H to compute the solution
     !! to a complex system of linear equations A*X = B, where A is an
     !! N-by-N Hermitian positive definite tridiagonal matrix and X and B
     !! are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
                work, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(${ck}$), intent(out) :: rcond
           ! Array Arguments 
           real(${ck}$), intent(out) :: berr(*), ferr(*), rwork(*)
           real(${ck}$), intent(in) :: d(*)
           real(${ck}$), intent(inout) :: df(*)
           complex(${ck}$), intent(in) :: b(ldb,*), e(*)
           complex(${ck}$), intent(inout) :: ef(*)
           complex(${ck}$), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(${ck}$) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZPTSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the l*d*l**h (or u**h*d*u) factorization of a.
              call stdlib_${c2ri(ci)}$copy( n, d, 1, df, 1 )
              if( n>1 )call stdlib_${ci}$copy( n-1, e, 1, ef, 1 )
              call stdlib_${ci}$pttrf( n, df, ef, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_${ci}$lanht( '1', n, d, e )
           ! compute the reciprocal of the condition number of a.
           call stdlib_${ci}$ptcon( n, df, ef, anorm, rcond, rwork, info )
           ! compute the solution vectors x.
           call stdlib_${ci}$lacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ci}$pttrs( 'LOWER', n, nrhs, df, ef, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_${ci}$ptrfs( 'LOWER', n, nrhs, d, e, df, ef, b, ldb, x, ldx, ferr,berr, work, &
                     rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_${c2ri(ci)}$lamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_${ci}$ptsvx

#:endif
#:endfor





     pure subroutine stdlib_spbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
     !! SPBSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric positive definite band matrix and X
     !! and B are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**T * U,  if UPLO = 'U', or
     !! A = L * L**T,  if UPLO = 'L',
     !! where U is an upper triangular band matrix, and L is a lower
     !! triangular band matrix, with the same number of superdiagonals or
     !! subdiagonals as A.  The factored form of A is then used to solve the
     !! system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldb, n, nrhs
           ! Array Arguments 
           real(sp), intent(inout) :: ab(ldab,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldab<kd+1 ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SPBSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**t*u or a = l*l**t.
           call stdlib_spbtrf( uplo, n, kd, ab, ldab, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_spbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
           end if
           return
     end subroutine stdlib_spbsv

     pure subroutine stdlib_dpbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
     !! DPBSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric positive definite band matrix and X
     !! and B are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**T * U,  if UPLO = 'U', or
     !! A = L * L**T,  if UPLO = 'L',
     !! where U is an upper triangular band matrix, and L is a lower
     !! triangular band matrix, with the same number of superdiagonals or
     !! subdiagonals as A.  The factored form of A is then used to solve the
     !! system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldb, n, nrhs
           ! Array Arguments 
           real(dp), intent(inout) :: ab(ldab,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldab<kd+1 ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPBSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**t*u or a = l*l**t.
           call stdlib_dpbtrf( uplo, n, kd, ab, ldab, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_dpbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
           end if
           return
     end subroutine stdlib_dpbsv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$pbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
     !! DPBSV: computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric positive definite band matrix and X
     !! and B are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**T * U,  if UPLO = 'U', or
     !! A = L * L**T,  if UPLO = 'L',
     !! where U is an upper triangular band matrix, and L is a lower
     !! triangular band matrix, with the same number of superdiagonals or
     !! subdiagonals as A.  The factored form of A is then used to solve the
     !! system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldb, n, nrhs
           ! Array Arguments 
           real(${rk}$), intent(inout) :: ab(ldab,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldab<kd+1 ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DPBSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**t*u or a = l*l**t.
           call stdlib_${ri}$pbtrf( uplo, n, kd, ab, ldab, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ri}$pbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ri}$pbsv

#:endif
#:endfor

     pure subroutine stdlib_cpbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
     !! CPBSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian positive definite band matrix and X
     !! and B are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**H * U,  if UPLO = 'U', or
     !! A = L * L**H,  if UPLO = 'L',
     !! where U is an upper triangular band matrix, and L is a lower
     !! triangular band matrix, with the same number of superdiagonals or
     !! subdiagonals as A.  The factored form of A is then used to solve the
     !! system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldb, n, nrhs
           ! Array Arguments 
           complex(sp), intent(inout) :: ab(ldab,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldab<kd+1 ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CPBSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**h*u or a = l*l**h.
           call stdlib_cpbtrf( uplo, n, kd, ab, ldab, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_cpbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
           end if
           return
     end subroutine stdlib_cpbsv

     pure subroutine stdlib_zpbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
     !! ZPBSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian positive definite band matrix and X
     !! and B are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**H * U,  if UPLO = 'U', or
     !! A = L * L**H,  if UPLO = 'L',
     !! where U is an upper triangular band matrix, and L is a lower
     !! triangular band matrix, with the same number of superdiagonals or
     !! subdiagonals as A.  The factored form of A is then used to solve the
     !! system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldb, n, nrhs
           ! Array Arguments 
           complex(dp), intent(inout) :: ab(ldab,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldab<kd+1 ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZPBSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**h *u or a = l*l**h.
           call stdlib_zpbtrf( uplo, n, kd, ab, ldab, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_zpbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
           end if
           return
     end subroutine stdlib_zpbsv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$pbsv( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
     !! ZPBSV: computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian positive definite band matrix and X
     !! and B are N-by-NRHS matrices.
     !! The Cholesky decomposition is used to factor A as
     !! A = U**H * U,  if UPLO = 'U', or
     !! A = L * L**H,  if UPLO = 'L',
     !! where U is an upper triangular band matrix, and L is a lower
     !! triangular band matrix, with the same number of superdiagonals or
     !! subdiagonals as A.  The factored form of A is then used to solve the
     !! system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: kd, ldab, ldb, n, nrhs
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: ab(ldab,*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( kd<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldab<kd+1 ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZPBSV ', -info )
              return
           end if
           ! compute the cholesky factorization a = u**h *u or a = l*l**h.
           call stdlib_${ci}$pbtrf( uplo, n, kd, ab, ldab, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ci}$pbtrs( uplo, n, kd, nrhs, ab, ldab, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ci}$pbsv

#:endif
#:endfor




end module stdlib_lapack_solve_chol
