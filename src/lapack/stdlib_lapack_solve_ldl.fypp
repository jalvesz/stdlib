#:include "common.fypp" 
submodule(stdlib_lapack) stdlib_lapack_solve_ldl
  implicit none(type,external)


  contains

     module pure subroutine stdlib_ssysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! SSYSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_ssytrf( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYSV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_ssytrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_ssytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_ssytrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_ssysv

     module pure subroutine stdlib_dsysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! DSYSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_dsytrf( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_dsytrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_dsytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_dsytrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dsysv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! DSYSV: computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_${ri}$sytrf( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_${ri}$sytrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_${ri}$sytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_${ri}$sytrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sysv

#:endif
#:endfor

     module pure subroutine stdlib_csysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! CSYSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_csytrf( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=sp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYSV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_csytrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_csytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_csytrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csysv

     module pure subroutine stdlib_zsysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZSYSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_zsytrf( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=dp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYSV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_zsytrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_zsytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_zsytrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zsysv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZSYSV: computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_${ci}$sytrf( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=${ck}$)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYSV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_${ci}$sytrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_${ci}$sytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_${ci}$sytrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$sysv

#:endif
#:endfor



     module pure subroutine stdlib_chesv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info )
     !! CHESV_RK computes the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N Hermitian matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**H)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**H)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! CHETRF_RK is called to compute the factorization of a complex
     !! Hermitian matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine CHETRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_chetrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=sp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHESV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_chetrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_chetrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chesv_rk

     module pure subroutine stdlib_zhesv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info )
     !! ZHESV_RK computes the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N Hermitian matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**H)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**H)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! ZHETRF_RK is called to compute the factorization of a complex
     !! Hermitian matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine ZHETRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_zhetrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=dp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHESV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = p*u*d*(u**h)*(p**t) or
           ! a = p*u*d*(u**h)*(p**t).
           call stdlib_zhetrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_zhetrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zhesv_rk

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hesv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info )
     !! ZHESV_RK: computes the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N Hermitian matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**H)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**H)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! ZHETRF_RK is called to compute the factorization of a complex
     !! Hermitian matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine ZHETRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_${ci}$hetrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=${ck}$)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHESV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = p*u*d*(u**h)*(p**t) or
           ! a = p*u*d*(u**h)*(p**t).
           call stdlib_${ci}$hetrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_${ci}$hetrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$hesv_rk

#:endif
#:endfor



     module pure subroutine stdlib_ssysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! SSYSV_ROOK computes the solution to a real system of linear
     !! equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! SSYTRF_ROOK is called to compute the factorization of a real
     !! symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling SSYTRS_ROOK.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_ssytrf_rook( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYSV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_ssytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs_rook ( use level 2 blas)
              call stdlib_ssytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_ssysv_rook

     module pure subroutine stdlib_dsysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! DSYSV_ROOK computes the solution to a real system of linear
     !! equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! DSYTRF_ROOK is called to compute the factorization of a real
     !! symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling DSYTRS_ROOK.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_dsytrf_rook( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_dsytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs_rook ( use level 2 blas)
              call stdlib_dsytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dsysv_rook

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! DSYSV_ROOK: computes the solution to a real system of linear
     !! equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! DSYTRF_ROOK is called to compute the factorization of a real
     !! symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling DSYTRS_ROOK.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_${ri}$sytrf_rook( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_${ri}$sytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs_rook ( use level 2 blas)
              call stdlib_${ri}$sytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sysv_rook

#:endif
#:endfor

     module pure subroutine stdlib_csysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! CSYSV_ROOK computes the solution to a complex system of linear
     !! equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! CSYTRF_ROOK is called to compute the factorization of a complex
     !! symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling CSYTRS_ROOK.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_csytrf_rook( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=sp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYSV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_csytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs_rook ( use level 2 blas)
              call stdlib_csytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csysv_rook

     module pure subroutine stdlib_zsysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZSYSV_ROOK computes the solution to a complex system of linear
     !! equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! ZSYTRF_ROOK is called to compute the factorization of a complex
     !! symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling ZSYTRS_ROOK.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_zsytrf_rook( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=dp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYSV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_zsytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs_rook ( use level 2 blas)
              call stdlib_zsytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zsysv_rook

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZSYSV_ROOK: computes the solution to a complex system of linear
     !! equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! ZSYTRF_ROOK is called to compute the factorization of a complex
     !! symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling ZSYTRS_ROOK.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_${ci}$sytrf_rook( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=${ck}$)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYSV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_${ci}$sytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs_rook ( use level 2 blas)
              call stdlib_${ci}$sytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$sysv_rook

#:endif
#:endfor







     module pure subroutine stdlib_sspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! SSPSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is symmetric and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_ssptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_ssptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_sspsv

     module pure subroutine stdlib_dspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! DSPSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is symmetric and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_dsptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_dsptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_dspsv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$spsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! DSPSV: computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is symmetric and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_${ri}$sptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ri}$sptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ri}$spsv

#:endif
#:endfor

     module pure subroutine stdlib_cspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! CSPSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is symmetric and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_csptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_csptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_cspsv

     module pure subroutine stdlib_zspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! ZSPSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is symmetric and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_zsptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_zsptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_zspsv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$spsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! ZSPSV: computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is symmetric and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_${ci}$sptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ci}$sptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ci}$spsv

#:endif
#:endfor



     module subroutine stdlib_chpsvx( fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x,ldx, rcond, ferr, &
     !! CHPSVX uses the diagonal pivoting factorization A = U*D*U**H or
     !! A = L*D*L**H to compute the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N Hermitian matrix stored
     !! in packed format and X and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               berr, work, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(inout) :: afp(*)
           complex(sp), intent(in) :: ap(*), b(ldb,*)
           complex(sp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(sp) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**h or a = l*d*l**h.
              call stdlib_ccopy( n*( n+1 ) / 2, ap, 1, afp, 1 )
              call stdlib_chptrf( uplo, n, afp, ipiv, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_clanhp( 'I', uplo, n, ap, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_chpcon( uplo, n, afp, ipiv, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_clacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_chptrs( uplo, n, nrhs, afp, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_chprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr,berr, work, &
                     rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_chpsvx

     module subroutine stdlib_zhpsvx( fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x,ldx, rcond, ferr, &
     !! ZHPSVX uses the diagonal pivoting factorization A = U*D*U**H or
     !! A = L*D*L**H to compute the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N Hermitian matrix stored
     !! in packed format and X and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               berr, work, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(dp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(dp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(dp), intent(inout) :: afp(*)
           complex(dp), intent(in) :: ap(*), b(ldb,*)
           complex(dp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(dp) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHPSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**h or a = l*d*l**h.
              call stdlib_zcopy( n*( n+1 ) / 2, ap, 1, afp, 1 )
              call stdlib_zhptrf( uplo, n, afp, ipiv, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_zlanhp( 'I', uplo, n, ap, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_zhpcon( uplo, n, afp, ipiv, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_zlacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_zhptrs( uplo, n, nrhs, afp, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_zhprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr,berr, work, &
                     rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_dlamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_zhpsvx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$hpsvx( fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x,ldx, rcond, ferr, &
     !! ZHPSVX: uses the diagonal pivoting factorization A = U*D*U**H or
     !! A = L*D*L**H to compute the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N Hermitian matrix stored
     !! in packed format and X and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               berr, work, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(${ck}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(${ck}$), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(${ck}$), intent(inout) :: afp(*)
           complex(${ck}$), intent(in) :: ap(*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(${ck}$) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHPSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**h or a = l*d*l**h.
              call stdlib_${ci}$copy( n*( n+1 ) / 2, ap, 1, afp, 1 )
              call stdlib_${ci}$hptrf( uplo, n, afp, ipiv, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_${ci}$lanhp( 'I', uplo, n, ap, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_${ci}$hpcon( uplo, n, afp, ipiv, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_${ci}$lacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ci}$hptrs( uplo, n, nrhs, afp, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_${ci}$hprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr,berr, work, &
                     rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_${c2ri(ci)}$lamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_${ci}$hpsvx

#:endif
#:endfor



     module subroutine stdlib_ssysvx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b,ldb, x, ldx, rcond, &
     !! SSYSVX uses the diagonal pivoting factorization to compute the
     !! solution to a real system of linear equations A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               ferr, berr, work, lwork,iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, lwork, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(in) :: a(lda,*), b(ldb,*)
           real(sp), intent(inout) :: af(ldaf,*)
           real(sp), intent(out) :: berr(*), ferr(*), work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, nofact
           integer(ilp) :: lwkopt, nb
           real(sp) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           lquery = ( lwork==-1 )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldaf<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -11
           else if( ldx<max( 1, n ) ) then
              info = -13
           else if( lwork<max( 1, 3*n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info==0 ) then
              lwkopt = max( 1, 3*n )
              if( nofact ) then
                 nb = stdlib_ilaenv( 1, 'SSYTRF', uplo, n, -1, -1, -1 )
                 lwkopt = max( lwkopt, n*nb )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYSVX', -info )
              return
           else if( lquery ) then
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**t or a = l*d*l**t.
              call stdlib_slacpy( uplo, n, n, a, lda, af, ldaf )
              call stdlib_ssytrf( uplo, n, af, ldaf, ipiv, work, lwork, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_slansy( 'I', uplo, n, a, lda, work )
           ! compute the reciprocal of the condition number of a.
           call stdlib_ssycon( uplo, n, af, ldaf, ipiv, anorm, rcond, work, iwork,info )
           ! compute the solution vectors x.
           call stdlib_slacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_ssytrs( uplo, n, nrhs, af, ldaf, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_ssyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x,ldx, ferr, berr, &
                     work, iwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_ssysvx

     module subroutine stdlib_dsysvx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b,ldb, x, ldx, rcond, &
     !! DSYSVX uses the diagonal pivoting factorization to compute the
     !! solution to a real system of linear equations A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               ferr, berr, work, lwork,iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, lwork, n, nrhs
           real(dp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(in) :: a(lda,*), b(ldb,*)
           real(dp), intent(inout) :: af(ldaf,*)
           real(dp), intent(out) :: berr(*), ferr(*), work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, nofact
           integer(ilp) :: lwkopt, nb
           real(dp) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           lquery = ( lwork==-1 )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldaf<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -11
           else if( ldx<max( 1, n ) ) then
              info = -13
           else if( lwork<max( 1, 3*n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info==0 ) then
              lwkopt = max( 1, 3*n )
              if( nofact ) then
                 nb = stdlib_ilaenv( 1, 'DSYTRF', uplo, n, -1, -1, -1 )
                 lwkopt = max( lwkopt, n*nb )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSVX', -info )
              return
           else if( lquery ) then
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**t or a = l*d*l**t.
              call stdlib_dlacpy( uplo, n, n, a, lda, af, ldaf )
              call stdlib_dsytrf( uplo, n, af, ldaf, ipiv, work, lwork, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_dlansy( 'I', uplo, n, a, lda, work )
           ! compute the reciprocal of the condition number of a.
           call stdlib_dsycon( uplo, n, af, ldaf, ipiv, anorm, rcond, work, iwork,info )
           ! compute the solution vectors x.
           call stdlib_dlacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_dsytrs( uplo, n, nrhs, af, ldaf, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_dsyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x,ldx, ferr, berr, &
                     work, iwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_dlamch( 'EPSILON' ) )info = n + 1
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dsysvx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$sysvx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b,ldb, x, ldx, rcond, &
     !! DSYSVX: uses the diagonal pivoting factorization to compute the
     !! solution to a real system of linear equations A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               ferr, berr, work, lwork,iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, lwork, n, nrhs
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(inout) :: af(ldaf,*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, nofact
           integer(ilp) :: lwkopt, nb
           real(${rk}$) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           lquery = ( lwork==-1 )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldaf<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -11
           else if( ldx<max( 1, n ) ) then
              info = -13
           else if( lwork<max( 1, 3*n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info==0 ) then
              lwkopt = max( 1, 3*n )
              if( nofact ) then
                 nb = stdlib_ilaenv( 1, 'DSYTRF', uplo, n, -1, -1, -1 )
                 lwkopt = max( lwkopt, n*nb )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSVX', -info )
              return
           else if( lquery ) then
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**t or a = l*d*l**t.
              call stdlib_${ri}$lacpy( uplo, n, n, a, lda, af, ldaf )
              call stdlib_${ri}$sytrf( uplo, n, af, ldaf, ipiv, work, lwork, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_${ri}$lansy( 'I', uplo, n, a, lda, work )
           ! compute the reciprocal of the condition number of a.
           call stdlib_${ri}$sycon( uplo, n, af, ldaf, ipiv, anorm, rcond, work, iwork,info )
           ! compute the solution vectors x.
           call stdlib_${ri}$lacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ri}$sytrs( uplo, n, nrhs, af, ldaf, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_${ri}$syrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x,ldx, ferr, berr, &
                     work, iwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_${ri}$lamch( 'EPSILON' ) )info = n + 1
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sysvx

#:endif
#:endfor

     module subroutine stdlib_csysvx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b,ldb, x, ldx, rcond, &
     !! CSYSVX uses the diagonal pivoting factorization to compute the
     !! solution to a complex system of linear equations A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               ferr, berr, work, lwork,rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, lwork, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: a(lda,*), b(ldb,*)
           complex(sp), intent(inout) :: af(ldaf,*)
           complex(sp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, nofact
           integer(ilp) :: lwkopt, nb
           real(sp) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           lquery = ( lwork==-1 )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldaf<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -11
           else if( ldx<max( 1, n ) ) then
              info = -13
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info==0 ) then
              lwkopt = max( 1, 2*n )
              if( nofact ) then
                 nb = stdlib_ilaenv( 1, 'CSYTRF', uplo, n, -1, -1, -1 )
                 lwkopt = max( lwkopt, n*nb )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYSVX', -info )
              return
           else if( lquery ) then
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**t or a = l*d*l**t.
              call stdlib_clacpy( uplo, n, n, a, lda, af, ldaf )
              call stdlib_csytrf( uplo, n, af, ldaf, ipiv, work, lwork, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_clansy( 'I', uplo, n, a, lda, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_csycon( uplo, n, af, ldaf, ipiv, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_clacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_csytrs( uplo, n, nrhs, af, ldaf, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_csyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x,ldx, ferr, berr, &
                     work, rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csysvx

     module subroutine stdlib_zsysvx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b,ldb, x, ldx, rcond, &
     !! ZSYSVX uses the diagonal pivoting factorization to compute the
     !! solution to a complex system of linear equations A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               ferr, berr, work, lwork,rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, lwork, n, nrhs
           real(dp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(dp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(dp), intent(in) :: a(lda,*), b(ldb,*)
           complex(dp), intent(inout) :: af(ldaf,*)
           complex(dp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, nofact
           integer(ilp) :: lwkopt, nb
           real(dp) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           lquery = ( lwork==-1 )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldaf<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -11
           else if( ldx<max( 1, n ) ) then
              info = -13
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info==0 ) then
              lwkopt = max( 1, 2*n )
              if( nofact ) then
                 nb = stdlib_ilaenv( 1, 'ZSYTRF', uplo, n, -1, -1, -1 )
                 lwkopt = max( lwkopt, n*nb )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYSVX', -info )
              return
           else if( lquery ) then
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**t or a = l*d*l**t.
              call stdlib_zlacpy( uplo, n, n, a, lda, af, ldaf )
              call stdlib_zsytrf( uplo, n, af, ldaf, ipiv, work, lwork, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_zlansy( 'I', uplo, n, a, lda, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_zsycon( uplo, n, af, ldaf, ipiv, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_zlacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_zsytrs( uplo, n, nrhs, af, ldaf, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_zsyrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x,ldx, ferr, berr, &
                     work, rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_dlamch( 'EPSILON' ) )info = n + 1
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zsysvx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$sysvx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b,ldb, x, ldx, rcond, &
     !! ZSYSVX: uses the diagonal pivoting factorization to compute the
     !! solution to a complex system of linear equations A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               ferr, berr, work, lwork,rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, lwork, n, nrhs
           real(${ck}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(${ck}$), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(${ck}$), intent(in) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(inout) :: af(ldaf,*)
           complex(${ck}$), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, nofact
           integer(ilp) :: lwkopt, nb
           real(${ck}$) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           lquery = ( lwork==-1 )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldaf<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -11
           else if( ldx<max( 1, n ) ) then
              info = -13
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info==0 ) then
              lwkopt = max( 1, 2*n )
              if( nofact ) then
                 nb = stdlib_ilaenv( 1, 'ZSYTRF', uplo, n, -1, -1, -1 )
                 lwkopt = max( lwkopt, n*nb )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYSVX', -info )
              return
           else if( lquery ) then
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**t or a = l*d*l**t.
              call stdlib_${ci}$lacpy( uplo, n, n, a, lda, af, ldaf )
              call stdlib_${ci}$sytrf( uplo, n, af, ldaf, ipiv, work, lwork, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_${ci}$lansy( 'I', uplo, n, a, lda, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_${ci}$sycon( uplo, n, af, ldaf, ipiv, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_${ci}$lacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ci}$sytrs( uplo, n, nrhs, af, ldaf, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_${ci}$syrfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x,ldx, ferr, berr, &
                     work, rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_${c2ri(ci)}$lamch( 'EPSILON' ) )info = n + 1
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$sysvx

#:endif
#:endfor



     module subroutine stdlib_sspsvx( fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x,ldx, rcond, ferr, &
     !! SSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
     !! A = L*D*L**T to compute the solution to a real system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix stored
     !! in packed format and X and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               berr, work, iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: afp(*)
           real(sp), intent(in) :: ap(*), b(ldb,*)
           real(sp), intent(out) :: berr(*), ferr(*), work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(sp) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSPSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**t or a = l*d*l**t.
              call stdlib_scopy( n*( n+1 ) / 2, ap, 1, afp, 1 )
              call stdlib_ssptrf( uplo, n, afp, ipiv, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_slansp( 'I', uplo, n, ap, work )
           ! compute the reciprocal of the condition number of a.
           call stdlib_sspcon( uplo, n, afp, ipiv, anorm, rcond, work, iwork, info )
           ! compute the solution vectors x.
           call stdlib_slacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_ssptrs( uplo, n, nrhs, afp, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_ssprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr,berr, work, &
                     iwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_sspsvx

     module subroutine stdlib_dspsvx( fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x,ldx, rcond, ferr, &
     !! DSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
     !! A = L*D*L**T to compute the solution to a real system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix stored
     !! in packed format and X and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               berr, work, iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(dp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(inout) :: afp(*)
           real(dp), intent(in) :: ap(*), b(ldb,*)
           real(dp), intent(out) :: berr(*), ferr(*), work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(dp) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**t or a = l*d*l**t.
              call stdlib_dcopy( n*( n+1 ) / 2, ap, 1, afp, 1 )
              call stdlib_dsptrf( uplo, n, afp, ipiv, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_dlansp( 'I', uplo, n, ap, work )
           ! compute the reciprocal of the condition number of a.
           call stdlib_dspcon( uplo, n, afp, ipiv, anorm, rcond, work, iwork, info )
           ! compute the solution vectors x.
           call stdlib_dlacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_dsptrs( uplo, n, nrhs, afp, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_dsprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr,berr, work, &
                     iwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_dlamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_dspsvx

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$spsvx( fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x,ldx, rcond, ferr, &
     !! DSPSVX: uses the diagonal pivoting factorization A = U*D*U**T or
     !! A = L*D*L**T to compute the solution to a real system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix stored
     !! in packed format and X and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               berr, work, iwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(${rk}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: afp(*)
           real(${rk}$), intent(in) :: ap(*), b(ldb,*)
           real(${rk}$), intent(out) :: berr(*), ferr(*), work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(${rk}$) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**t or a = l*d*l**t.
              call stdlib_${ri}$copy( n*( n+1 ) / 2, ap, 1, afp, 1 )
              call stdlib_${ri}$sptrf( uplo, n, afp, ipiv, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_${ri}$lansp( 'I', uplo, n, ap, work )
           ! compute the reciprocal of the condition number of a.
           call stdlib_${ri}$spcon( uplo, n, afp, ipiv, anorm, rcond, work, iwork, info )
           ! compute the solution vectors x.
           call stdlib_${ri}$lacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ri}$sptrs( uplo, n, nrhs, afp, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_${ri}$sprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr,berr, work, &
                     iwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_${ri}$lamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_${ri}$spsvx

#:endif
#:endfor

     module subroutine stdlib_cspsvx( fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x,ldx, rcond, ferr, &
     !! CSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
     !! A = L*D*L**T to compute the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix stored
     !! in packed format and X and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               berr, work, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(inout) :: afp(*)
           complex(sp), intent(in) :: ap(*), b(ldb,*)
           complex(sp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(sp) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSPSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**t or a = l*d*l**t.
              call stdlib_ccopy( n*( n+1 ) / 2, ap, 1, afp, 1 )
              call stdlib_csptrf( uplo, n, afp, ipiv, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_clansp( 'I', uplo, n, ap, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_cspcon( uplo, n, afp, ipiv, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_clacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_csptrs( uplo, n, nrhs, afp, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_csprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr,berr, work, &
                     rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_cspsvx

     module subroutine stdlib_zspsvx( fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x,ldx, rcond, ferr, &
     !! ZSPSVX uses the diagonal pivoting factorization A = U*D*U**T or
     !! A = L*D*L**T to compute the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix stored
     !! in packed format and X and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               berr, work, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(dp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(dp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(dp), intent(inout) :: afp(*)
           complex(dp), intent(in) :: ap(*), b(ldb,*)
           complex(dp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(dp) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSPSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**t or a = l*d*l**t.
              call stdlib_zcopy( n*( n+1 ) / 2, ap, 1, afp, 1 )
              call stdlib_zsptrf( uplo, n, afp, ipiv, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_zlansp( 'I', uplo, n, ap, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_zspcon( uplo, n, afp, ipiv, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_zlacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_zsptrs( uplo, n, nrhs, afp, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_zsprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr,berr, work, &
                     rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_dlamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_zspsvx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$spsvx( fact, uplo, n, nrhs, ap, afp, ipiv, b, ldb, x,ldx, rcond, ferr, &
     !! ZSPSVX: uses the diagonal pivoting factorization A = U*D*U**T or
     !! A = L*D*L**T to compute the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix stored
     !! in packed format and X and B are N-by-NRHS matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               berr, work, rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, ldx, n, nrhs
           real(${ck}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(${ck}$), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(${ck}$), intent(inout) :: afp(*)
           complex(${ck}$), intent(in) :: ap(*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: nofact
           real(${ck}$) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldx<max( 1, n ) ) then
              info = -11
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSPSVX', -info )
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**t or a = l*d*l**t.
              call stdlib_${ci}$copy( n*( n+1 ) / 2, ap, 1, afp, 1 )
              call stdlib_${ci}$sptrf( uplo, n, afp, ipiv, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_${ci}$lansp( 'I', uplo, n, ap, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_${ci}$spcon( uplo, n, afp, ipiv, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_${ci}$lacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ci}$sptrs( uplo, n, nrhs, afp, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_${ci}$sprfs( uplo, n, nrhs, ap, afp, ipiv, b, ldb, x, ldx, ferr,berr, work, &
                     rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_${c2ri(ci)}$lamch( 'EPSILON' ) )info = n + 1
           return
     end subroutine stdlib_${ci}$spsvx

#:endif
#:endfor



     module subroutine stdlib_chesvx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b,ldb, x, ldx, rcond, &
     !! CHESVX uses the diagonal pivoting factorization to compute the
     !! solution to a complex system of linear equations A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               ferr, berr, work, lwork,rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, lwork, n, nrhs
           real(sp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(sp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(sp), intent(in) :: a(lda,*), b(ldb,*)
           complex(sp), intent(inout) :: af(ldaf,*)
           complex(sp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, nofact
           integer(ilp) :: lwkopt, nb
           real(sp) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           lquery = ( lwork==-1 )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldaf<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -11
           else if( ldx<max( 1, n ) ) then
              info = -13
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info==0 ) then
              lwkopt = max( 1, 2*n )
              if( nofact ) then
                 nb = stdlib_ilaenv( 1, 'CHETRF', uplo, n, -1, -1, -1 )
                 lwkopt = max( lwkopt, n*nb )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHESVX', -info )
              return
           else if( lquery ) then
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**h or a = l*d*l**h.
              call stdlib_clacpy( uplo, n, n, a, lda, af, ldaf )
              call stdlib_chetrf( uplo, n, af, ldaf, ipiv, work, lwork, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_clanhe( 'I', uplo, n, a, lda, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_checon( uplo, n, af, ldaf, ipiv, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_clacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_chetrs( uplo, n, nrhs, af, ldaf, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_cherfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x,ldx, ferr, berr, &
                     work, rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_slamch( 'EPSILON' ) )info = n + 1
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chesvx

     module subroutine stdlib_zhesvx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b,ldb, x, ldx, rcond, &
     !! ZHESVX uses the diagonal pivoting factorization to compute the
     !! solution to a complex system of linear equations A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               ferr, berr, work, lwork,rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, lwork, n, nrhs
           real(dp), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(dp), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(dp), intent(in) :: a(lda,*), b(ldb,*)
           complex(dp), intent(inout) :: af(ldaf,*)
           complex(dp), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, nofact
           integer(ilp) :: lwkopt, nb
           real(dp) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           lquery = ( lwork==-1 )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldaf<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -11
           else if( ldx<max( 1, n ) ) then
              info = -13
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info==0 ) then
              lwkopt = max( 1, 2*n )
              if( nofact ) then
                 nb = stdlib_ilaenv( 1, 'ZHETRF', uplo, n, -1, -1, -1 )
                 lwkopt = max( lwkopt, n*nb )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHESVX', -info )
              return
           else if( lquery ) then
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**h or a = l*d*l**h.
              call stdlib_zlacpy( uplo, n, n, a, lda, af, ldaf )
              call stdlib_zhetrf( uplo, n, af, ldaf, ipiv, work, lwork, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_zlanhe( 'I', uplo, n, a, lda, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_zhecon( uplo, n, af, ldaf, ipiv, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_zlacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_zhetrs( uplo, n, nrhs, af, ldaf, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_zherfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x,ldx, ferr, berr, &
                     work, rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_dlamch( 'EPSILON' ) )info = n + 1
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zhesvx

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$hesvx( fact, uplo, n, nrhs, a, lda, af, ldaf, ipiv, b,ldb, x, ldx, rcond, &
     !! ZHESVX: uses the diagonal pivoting factorization to compute the
     !! solution to a complex system of linear equations A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! Error bounds on the solution and a condition estimate are also
     !! provided.
               ferr, berr, work, lwork,rwork, info )
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: fact, uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldaf, ldb, ldx, lwork, n, nrhs
           real(${ck}$), intent(out) :: rcond
           ! Array Arguments 
           integer(ilp), intent(inout) :: ipiv(*)
           real(${ck}$), intent(out) :: berr(*), ferr(*), rwork(*)
           complex(${ck}$), intent(in) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(inout) :: af(ldaf,*)
           complex(${ck}$), intent(out) :: work(*), x(ldx,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery, nofact
           integer(ilp) :: lwkopt, nb
           real(${ck}$) :: anorm
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           nofact = stdlib_lsame( fact, 'N' )
           lquery = ( lwork==-1 )
           if( .not.nofact .and. .not.stdlib_lsame( fact, 'F' ) ) then
              info = -1
           else if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) )&
                     then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( nrhs<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldaf<max( 1, n ) ) then
              info = -8
           else if( ldb<max( 1, n ) ) then
              info = -11
           else if( ldx<max( 1, n ) ) then
              info = -13
           else if( lwork<max( 1, 2*n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info==0 ) then
              lwkopt = max( 1, 2*n )
              if( nofact ) then
                 nb = stdlib_ilaenv( 1, 'ZHETRF', uplo, n, -1, -1, -1 )
                 lwkopt = max( lwkopt, n*nb )
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHESVX', -info )
              return
           else if( lquery ) then
              return
           end if
           if( nofact ) then
              ! compute the factorization a = u*d*u**h or a = l*d*l**h.
              call stdlib_${ci}$lacpy( uplo, n, n, a, lda, af, ldaf )
              call stdlib_${ci}$hetrf( uplo, n, af, ldaf, ipiv, work, lwork, info )
              ! return if info is non-zero.
              if( info>0 )then
                 rcond = zero
                 return
              end if
           end if
           ! compute the norm of the matrix a.
           anorm = stdlib_${ci}$lanhe( 'I', uplo, n, a, lda, rwork )
           ! compute the reciprocal of the condition number of a.
           call stdlib_${ci}$hecon( uplo, n, af, ldaf, ipiv, anorm, rcond, work, info )
           ! compute the solution vectors x.
           call stdlib_${ci}$lacpy( 'FULL', n, nrhs, b, ldb, x, ldx )
           call stdlib_${ci}$hetrs( uplo, n, nrhs, af, ldaf, ipiv, x, ldx, info )
           ! use iterative refinement to improve the computed solutions and
           ! compute error bounds and backward error estimates for them.
           call stdlib_${ci}$herfs( uplo, n, nrhs, a, lda, af, ldaf, ipiv, b, ldb, x,ldx, ferr, berr, &
                     work, rwork, info )
           ! set info = n+1 if the matrix is singular to working precision.
           if( rcond<stdlib_${c2ri(ci)}$lamch( 'EPSILON' ) )info = n + 1
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$hesvx

#:endif
#:endfor



     module pure subroutine stdlib_chpsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! CHPSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**H,  if UPLO = 'U', or
     !! A = L * D * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is Hermitian and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_chptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_chptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_chpsv

     module pure subroutine stdlib_zhpsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! ZHPSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**H,  if UPLO = 'U', or
     !! A = L * D * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is Hermitian and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_zhptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_zhptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_zhpsv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hpsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! ZHPSV: computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**H,  if UPLO = 'U', or
     !! A = L * D * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is Hermitian and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_${ci}$hptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ci}$hptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ci}$hpsv

#:endif
#:endfor



     module pure subroutine stdlib_ssysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! SSYSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**T * T * U,  if UPLO = 'U', or
     !! A = L * T * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is symmetric tridiagonal. The factored
     !! form of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_sytrf, lwkopt_sytrs
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max(2*n, 3*n-2) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_ssytrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_sytrf = int( work(1),KIND=ilp)
              call stdlib_ssytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_sytrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_sytrf, lwkopt_sytrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYSV_AA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**t*t*u or a = l*t*l**t.
           call stdlib_ssytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_ssytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_ssysv_aa

     module pure subroutine stdlib_dsysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! DSYSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**T * T * U,  if UPLO = 'U', or
     !! A = L * T * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is symmetric tridiagonal. The factored
     !! form of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_sytrf, lwkopt_sytrs
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max(2*n, 3*n-2) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_dsytrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_sytrf = int( work(1),KIND=ilp)
              call stdlib_dsytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_sytrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_sytrf, lwkopt_sytrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**t*t*u or a = l*t*l**t.
           call stdlib_dsytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_dsytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dsysv_aa

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! DSYSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**T * T * U,  if UPLO = 'U', or
     !! A = L * T * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is symmetric tridiagonal. The factored
     !! form of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_sytrf, lwkopt_sytrs
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max(2*n, 3*n-2) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_${ri}$sytrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_sytrf = int( work(1),KIND=ilp)
              call stdlib_${ri}$sytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_sytrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_sytrf, lwkopt_sytrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**t*t*u or a = l*t*l**t.
           call stdlib_${ri}$sytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ri}$sytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sysv_aa

#:endif
#:endfor

     module pure subroutine stdlib_csysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! CSYSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**T * T * U,  if UPLO = 'U', or
     !! A = L * T * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is symmetric tridiagonal. The factored
     !! form of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_sytrf, lwkopt_sytrs
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max(2*n, 3*n-2) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_csytrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_sytrf = int( work(1),KIND=ilp)
              call stdlib_csytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_sytrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_sytrf, lwkopt_sytrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYSV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**t*t*u or a = l*t*l**t.
           call stdlib_csytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_csytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csysv_aa

     module pure subroutine stdlib_zsysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZSYSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**T * T * U,  if UPLO = 'U', or
     !! A = L * T * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is symmetric tridiagonal. The factored
     !! form of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_sytrf, lwkopt_sytrs
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max(2*n, 3*n-2) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_zsytrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_sytrf = int( work(1),KIND=ilp)
              call stdlib_zsytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_sytrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_sytrf, lwkopt_sytrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYSV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**t*t*u or a = l*t*l**t.
           call stdlib_zsytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_zsytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zsysv_aa

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZSYSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**T * T * U,  if UPLO = 'U', or
     !! A = L * T * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is symmetric tridiagonal. The factored
     !! form of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_sytrf, lwkopt_sytrs
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max(2*n, 3*n-2) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_${ci}$sytrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_sytrf = int( work(1),KIND=ilp)
              call stdlib_${ci}$sytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_sytrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_sytrf, lwkopt_sytrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYSV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**t*t*u or a = l*t*l**t.
           call stdlib_${ci}$sytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ci}$sytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$sysv_aa

#:endif
#:endfor



     module pure subroutine stdlib_chesv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! CHESV_ROOK computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! The bounded Bunch-Kaufman ("rook") diagonal pivoting method is used
     !! to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! CHETRF_ROOK is called to compute the factorization of a complex
     !! Hermition matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling CHETRS_ROOK (uses BLAS 2).
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, nb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'CHETRF_ROOK', uplo, n, -1, -1, -1 )
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHESV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_chetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs ( use level blas 2)
              call stdlib_chetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chesv_rook

     module pure subroutine stdlib_zhesv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZHESV_ROOK computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! The bounded Bunch-Kaufman ("rook") diagonal pivoting method is used
     !! to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! ZHETRF_ROOK is called to compute the factorization of a complex
     !! Hermition matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling ZHETRS_ROOK (uses BLAS 2).
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, nb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'ZHETRF_ROOK', uplo, n, -1, -1, -1 )
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHESV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_zhetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs ( use level blas 2)
              call stdlib_zhetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zhesv_rook

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hesv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZHESV_ROOK: computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! The bounded Bunch-Kaufman ("rook") diagonal pivoting method is used
     !! to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! ZHETRF_ROOK is called to compute the factorization of a complex
     !! Hermition matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling ZHETRS_ROOK (uses BLAS 2).
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, nb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'ZHETRF_ROOK', uplo, n, -1, -1, -1 )
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHESV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_${ci}$hetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs ( use level blas 2)
              call stdlib_${ci}$hetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$hesv_rook

#:endif
#:endfor



     module pure subroutine stdlib_chesv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! CHESV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**H,  if UPLO = 'U', or
     !! A = L * D * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, nb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'CHETRF', uplo, n, -1, -1, -1 )
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHESV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_chetrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_chetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_chetrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chesv

     module pure subroutine stdlib_zhesv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZHESV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**H,  if UPLO = 'U', or
     !! A = L * D * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, nb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'ZHETRF', uplo, n, -1, -1, -1 )
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHESV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_zhetrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_zhetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_zhetrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zhesv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hesv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZHESV: computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**H,  if UPLO = 'U', or
     !! A = L * D * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, nb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'ZHETRF', uplo, n, -1, -1, -1 )
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHESV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_${ci}$hetrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_${ci}$hetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_${ci}$hetrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$hesv

#:endif
#:endfor





     module pure subroutine stdlib_ssysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,work, lwork, info )
     !! SSYSV_RK computes the solution to a real system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! SSYTRF_RK is called to compute the factorization of a real
     !! symmetric matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine SSYTRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_ssytrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYSV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = p*u*d*(u**t)*(p**t) or
           ! a = p*u*d*(u**t)*(p**t).
           call stdlib_ssytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_ssytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_ssysv_rk

     module pure subroutine stdlib_dsysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,work, lwork, info )
     !! DSYSV_RK computes the solution to a real system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! DSYTRF_RK is called to compute the factorization of a real
     !! symmetric matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine DSYTRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_dsytrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = p*u*d*(u**t)*(p**t) or
           ! a = p*u*d*(u**t)*(p**t).
           call stdlib_dsytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_dsytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dsysv_rk

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$sysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,work, lwork, info )
     !! DSYSV_RK: computes the solution to a real system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! DSYTRF_RK is called to compute the factorization of a real
     !! symmetric matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine DSYTRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_${ri}$sytrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = p*u*d*(u**t)*(p**t) or
           ! a = p*u*d*(u**t)*(p**t).
           call stdlib_${ri}$sytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_${ri}$sytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sysv_rk

#:endif
#:endfor

     module pure subroutine stdlib_csysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info )
     !! CSYSV_RK computes the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! CSYTRF_RK is called to compute the factorization of a complex
     !! symmetric matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine CSYTRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_csytrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=sp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYSV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_csytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_csytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csysv_rk

     module pure subroutine stdlib_zsysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info )
     !! ZSYSV_RK computes the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! ZSYTRF_RK is called to compute the factorization of a complex
     !! symmetric matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine ZSYTRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_zsytrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=dp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYSV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = p*u*d*(u**t)*(p**t) or
           ! a = p*u*d*(u**t)*(p**t).
           call stdlib_zsytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_zsytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zsysv_rk

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$sysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info )
     !! ZSYSV_RK: computes the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! ZSYTRF_RK is called to compute the factorization of a complex
     !! symmetric matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine ZSYTRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_${ci}$sytrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=${ck}$)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYSV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = p*u*d*(u**t)*(p**t) or
           ! a = p*u*d*(u**t)*(p**t).
           call stdlib_${ci}$sytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_${ci}$sytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$sysv_rk

#:endif
#:endfor



     module pure subroutine stdlib_chesv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! CHESV_AA computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**H * T * U,  if UPLO = 'U', or
     !! A = L * T * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is Hermitian and tridiagonal. The factored form
     !! of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_hetrf, lwkopt_hetrs
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max( 2*n, 3*n-2 ) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_chetrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_hetrf = int( work(1),KIND=ilp)
              call stdlib_chetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_hetrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_hetrf, lwkopt_hetrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHESV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**h*t*u or a = l*t*l**h.
           call stdlib_chetrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_chetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chesv_aa

     module pure subroutine stdlib_zhesv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZHESV_AA computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**H * T * U,  if UPLO = 'U', or
     !! A = L * T * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is Hermitian and tridiagonal. The factored form
     !! of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_hetrf, lwkopt_hetrs
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max(2*n, 3*n-2) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_zhetrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_hetrf = int( work(1),KIND=ilp)
              call stdlib_zhetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_hetrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_hetrf, lwkopt_hetrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHESV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**h*t*u or a = l*t*l**h.
           call stdlib_zhetrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_zhetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zhesv_aa

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$hesv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZHESV_AA: computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**H * T * U,  if UPLO = 'U', or
     !! A = L * T * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is Hermitian and tridiagonal. The factored form
     !! of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_hetrf, lwkopt_hetrs
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max(2*n, 3*n-2) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_${ci}$hetrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_hetrf = int( work(1),KIND=ilp)
              call stdlib_${ci}$hetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_hetrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_hetrf, lwkopt_hetrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHESV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**h*t*u or a = l*t*l**h.
           call stdlib_${ci}$hetrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ci}$hetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$hesv_aa

#:endif
#:endfor




end submodule stdlib_lapack_solve_ldl
