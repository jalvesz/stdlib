#:include "common.fypp" 
module stdlib_lapack_solve_ldl
  use stdlib_linalg_constants
  use stdlib_linalg_lapack_aux
  use stdlib_linalg_blas
  use stdlib_lapack_solve_ldl_comp
  implicit none(type,external)


  contains





     pure subroutine stdlib_chpsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! CHPSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**H,  if UPLO = 'U', or
     !! A = L * D * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is Hermitian and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_chptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_chptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_chpsv

     pure subroutine stdlib_zhpsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! ZHPSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**H,  if UPLO = 'U', or
     !! A = L * D * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is Hermitian and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_zhptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_zhptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_zhpsv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$hpsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! ZHPSV: computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**H,  if UPLO = 'U', or
     !! A = L * D * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is Hermitian and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_${ci}$hptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ci}$hptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ci}$hpsv

#:endif
#:endfor







     pure subroutine stdlib_chesv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info )
     !! CHESV_RK computes the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N Hermitian matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**H)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**H)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! CHETRF_RK is called to compute the factorization of a complex
     !! Hermitian matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine CHETRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_chetrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=sp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHESV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_chetrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_chetrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chesv_rk

     pure subroutine stdlib_zhesv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info )
     !! ZHESV_RK computes the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N Hermitian matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**H)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**H)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! ZHETRF_RK is called to compute the factorization of a complex
     !! Hermitian matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine ZHETRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_zhetrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=dp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHESV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = p*u*d*(u**h)*(p**t) or
           ! a = p*u*d*(u**h)*(p**t).
           call stdlib_zhetrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_zhetrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zhesv_rk

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$hesv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info )
     !! ZHESV_RK: computes the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N Hermitian matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**H)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**H)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**H (or L**H) is the conjugate of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is Hermitian and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! ZHETRF_RK is called to compute the factorization of a complex
     !! Hermitian matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine ZHETRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_${ci}$hetrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=${ck}$)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHESV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = p*u*d*(u**h)*(p**t) or
           ! a = p*u*d*(u**h)*(p**t).
           call stdlib_${ci}$hetrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_${ci}$hetrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$hesv_rk

#:endif
#:endfor



     pure subroutine stdlib_ssysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! SSYSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**T * T * U,  if UPLO = 'U', or
     !! A = L * T * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is symmetric tridiagonal. The factored
     !! form of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_sytrf, lwkopt_sytrs
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max(2*n, 3*n-2) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_ssytrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_sytrf = int( work(1),KIND=ilp)
              call stdlib_ssytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_sytrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_sytrf, lwkopt_sytrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYSV_AA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**t*t*u or a = l*t*l**t.
           call stdlib_ssytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_ssytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_ssysv_aa

     pure subroutine stdlib_dsysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! DSYSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**T * T * U,  if UPLO = 'U', or
     !! A = L * T * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is symmetric tridiagonal. The factored
     !! form of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_sytrf, lwkopt_sytrs
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max(2*n, 3*n-2) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_dsytrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_sytrf = int( work(1),KIND=ilp)
              call stdlib_dsytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_sytrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_sytrf, lwkopt_sytrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**t*t*u or a = l*t*l**t.
           call stdlib_dsytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_dsytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dsysv_aa

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$sysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! DSYSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**T * T * U,  if UPLO = 'U', or
     !! A = L * T * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is symmetric tridiagonal. The factored
     !! form of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_sytrf, lwkopt_sytrs
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max(2*n, 3*n-2) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_${ri}$sytrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_sytrf = int( work(1),KIND=ilp)
              call stdlib_${ri}$sytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_sytrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_sytrf, lwkopt_sytrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**t*t*u or a = l*t*l**t.
           call stdlib_${ri}$sytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ri}$sytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sysv_aa

#:endif
#:endfor

     pure subroutine stdlib_csysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! CSYSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**T * T * U,  if UPLO = 'U', or
     !! A = L * T * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is symmetric tridiagonal. The factored
     !! form of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_sytrf, lwkopt_sytrs
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max(2*n, 3*n-2) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_csytrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_sytrf = int( work(1),KIND=ilp)
              call stdlib_csytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_sytrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_sytrf, lwkopt_sytrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYSV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**t*t*u or a = l*t*l**t.
           call stdlib_csytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_csytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csysv_aa

     pure subroutine stdlib_zsysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZSYSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**T * T * U,  if UPLO = 'U', or
     !! A = L * T * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is symmetric tridiagonal. The factored
     !! form of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_sytrf, lwkopt_sytrs
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max(2*n, 3*n-2) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_zsytrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_sytrf = int( work(1),KIND=ilp)
              call stdlib_zsytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_sytrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_sytrf, lwkopt_sytrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYSV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**t*t*u or a = l*t*l**t.
           call stdlib_zsytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_zsytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zsysv_aa

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$sysv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZSYSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**T * T * U,  if UPLO = 'U', or
     !! A = L * T * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is symmetric tridiagonal. The factored
     !! form of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_sytrf, lwkopt_sytrs
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max(2*n, 3*n-2) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_${ci}$sytrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_sytrf = int( work(1),KIND=ilp)
              call stdlib_${ci}$sytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_sytrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_sytrf, lwkopt_sytrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYSV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**t*t*u or a = l*t*l**t.
           call stdlib_${ci}$sytrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ci}$sytrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$sysv_aa

#:endif
#:endfor



     pure subroutine stdlib_ssysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,work, lwork, info )
     !! SSYSV_RK computes the solution to a real system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! SSYTRF_RK is called to compute the factorization of a real
     !! symmetric matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine SSYTRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_ssytrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYSV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = p*u*d*(u**t)*(p**t) or
           ! a = p*u*d*(u**t)*(p**t).
           call stdlib_ssytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_ssytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_ssysv_rk

     pure subroutine stdlib_dsysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,work, lwork, info )
     !! DSYSV_RK computes the solution to a real system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! DSYTRF_RK is called to compute the factorization of a real
     !! symmetric matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine DSYTRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_dsytrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = p*u*d*(u**t)*(p**t) or
           ! a = p*u*d*(u**t)*(p**t).
           call stdlib_dsytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_dsytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dsysv_rk

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$sysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb,work, lwork, info )
     !! DSYSV_RK: computes the solution to a real system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! DSYTRF_RK is called to compute the factorization of a real
     !! symmetric matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine DSYTRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_${ri}$sytrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = p*u*d*(u**t)*(p**t) or
           ! a = p*u*d*(u**t)*(p**t).
           call stdlib_${ri}$sytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_${ri}$sytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sysv_rk

#:endif
#:endfor

     pure subroutine stdlib_csysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info )
     !! CSYSV_RK computes the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! CSYTRF_RK is called to compute the factorization of a complex
     !! symmetric matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine CSYTRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_csytrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=sp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYSV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_csytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_csytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csysv_rk

     pure subroutine stdlib_zsysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info )
     !! ZSYSV_RK computes the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! ZSYTRF_RK is called to compute the factorization of a complex
     !! symmetric matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine ZSYTRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_zsytrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=dp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYSV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = p*u*d*(u**t)*(p**t) or
           ! a = p*u*d*(u**t)*(p**t).
           call stdlib_zsytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_zsytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zsysv_rk

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$sysv_rk( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, work,lwork, info )
     !! ZSYSV_RK: computes the solution to a complex system of linear
     !! equations A * X = B, where A is an N-by-N symmetric matrix
     !! and X and B are N-by-NRHS matrices.
     !! The bounded Bunch-Kaufman (rook) diagonal pivoting method is used
     !! to factor A as
     !! A = P*U*D*(U**T)*(P**T),  if UPLO = 'U', or
     !! A = P*L*D*(L**T)*(P**T),  if UPLO = 'L',
     !! where U (or L) is unit upper (or lower) triangular matrix,
     !! U**T (or L**T) is the transpose of U (or L), P is a permutation
     !! matrix, P**T is the transpose of P, and D is symmetric and block
     !! diagonal with 1-by-1 and 2-by-2 diagonal blocks.
     !! ZSYTRF_RK is called to compute the factorization of a complex
     !! symmetric matrix.  The factored form of A is then used to solve
     !! the system of equations A * X = B by calling BLAS3 routine ZSYTRS_3.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: e(*), work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( lwork<1 .and. .not.lquery ) then
              info = -11
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_${ci}$sytrf_rk( uplo, n, a, lda, e, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=${ck}$)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYSV_RK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = p*u*d*(u**t)*(p**t) or
           ! a = p*u*d*(u**t)*(p**t).
           call stdlib_${ci}$sytrf_rk( uplo, n, a, lda, e, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b with blas3 solver, overwriting b with x.
              call stdlib_${ci}$sytrs_3( uplo, n, nrhs, a, lda, e, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$sysv_rk

#:endif
#:endfor



     pure subroutine stdlib_ssysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! SSYSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_ssytrf( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYSV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_ssytrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_ssytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_ssytrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_ssysv

     pure subroutine stdlib_dsysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! DSYSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_dsytrf( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_dsytrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_dsytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_dsytrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dsysv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$sysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! DSYSV: computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_${ri}$sytrf( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_${ri}$sytrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_${ri}$sytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_${ri}$sytrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sysv

#:endif
#:endfor

     pure subroutine stdlib_csysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! CSYSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_csytrf( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=sp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYSV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_csytrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_csytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_csytrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csysv

     pure subroutine stdlib_zsysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZSYSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_zsytrf( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=dp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYSV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_zsytrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_zsytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_zsytrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zsysv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$sysv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZSYSV: computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_${ci}$sytrf( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=${ck}$)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYSV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_${ci}$sytrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_${ci}$sytrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_${ci}$sytrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$sysv

#:endif
#:endfor



     pure subroutine stdlib_chesv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! CHESV_ROOK computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! The bounded Bunch-Kaufman ("rook") diagonal pivoting method is used
     !! to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! CHETRF_ROOK is called to compute the factorization of a complex
     !! Hermition matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling CHETRS_ROOK (uses BLAS 2).
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, nb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'CHETRF_ROOK', uplo, n, -1, -1, -1 )
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHESV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_chetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs ( use level blas 2)
              call stdlib_chetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chesv_rook

     pure subroutine stdlib_zhesv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZHESV_ROOK computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! The bounded Bunch-Kaufman ("rook") diagonal pivoting method is used
     !! to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! ZHETRF_ROOK is called to compute the factorization of a complex
     !! Hermition matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling ZHETRS_ROOK (uses BLAS 2).
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, nb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'ZHETRF_ROOK', uplo, n, -1, -1, -1 )
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHESV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_zhetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs ( use level blas 2)
              call stdlib_zhetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zhesv_rook

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$hesv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZHESV_ROOK: computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! The bounded Bunch-Kaufman ("rook") diagonal pivoting method is used
     !! to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! ZHETRF_ROOK is called to compute the factorization of a complex
     !! Hermition matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling ZHETRS_ROOK (uses BLAS 2).
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, nb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'ZHETRF_ROOK', uplo, n, -1, -1, -1 )
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHESV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_${ci}$hetrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs ( use level blas 2)
              call stdlib_${ci}$hetrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$hesv_rook

#:endif
#:endfor





     pure subroutine stdlib_sspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! SSPSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is symmetric and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_ssptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_ssptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_sspsv

     pure subroutine stdlib_dspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! DSPSV computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is symmetric and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_dsptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_dsptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_dspsv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$spsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! DSPSV: computes the solution to a real system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is symmetric and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_${ri}$sptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ri}$sptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ri}$spsv

#:endif
#:endfor

     pure subroutine stdlib_cspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! CSPSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is symmetric and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_csptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_csptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_cspsv

     pure subroutine stdlib_zspsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! ZSPSV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is symmetric and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_zsptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_zsptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_zspsv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$spsv( uplo, n, nrhs, ap, ipiv, b, ldb, info )
     !! ZSPSV: computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix stored in packed format and X
     !! and B are N-by-NRHS matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, D is symmetric and block diagonal with 1-by-1
     !! and 2-by-2 diagonal blocks.  The factored form of A is then used to
     !! solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldb, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: ap(*), b(ldb,*)
        ! =====================================================================
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( ldb<max( 1, n ) ) then
              info = -7
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSPSV ', -info )
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_${ci}$sptrf( uplo, n, ap, ipiv, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ci}$sptrs( uplo, n, nrhs, ap, ipiv, b, ldb, info )
           end if
           return
     end subroutine stdlib_${ci}$spsv

#:endif
#:endfor





     pure subroutine stdlib_ssysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! SSYSV_ROOK computes the solution to a real system of linear
     !! equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! SSYTRF_ROOK is called to compute the factorization of a real
     !! symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling SSYTRS_ROOK.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_ssytrf_rook( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SSYSV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_ssytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs_rook ( use level 2 blas)
              call stdlib_ssytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_ssysv_rook

     pure subroutine stdlib_dsysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! DSYSV_ROOK computes the solution to a real system of linear
     !! equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! DSYTRF_ROOK is called to compute the factorization of a real
     !! symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling DSYTRS_ROOK.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_dsytrf_rook( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_dsytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs_rook ( use level 2 blas)
              call stdlib_dsytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_dsysv_rook

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$sysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! DSYSV_ROOK: computes the solution to a real system of linear
     !! equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! DSYTRF_ROOK is called to compute the factorization of a real
     !! symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling DSYTRS_ROOK.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_${ri}$sytrf_rook( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = work(1)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DSYSV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_${ri}$sytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs_rook ( use level 2 blas)
              call stdlib_${ri}$sytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ri}$sysv_rook

#:endif
#:endfor

     pure subroutine stdlib_csysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! CSYSV_ROOK computes the solution to a complex system of linear
     !! equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! CSYTRF_ROOK is called to compute the factorization of a complex
     !! symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling CSYTRS_ROOK.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_csytrf_rook( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=sp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CSYSV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_csytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs_rook ( use level 2 blas)
              call stdlib_csytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_csysv_rook

     pure subroutine stdlib_zsysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZSYSV_ROOK computes the solution to a complex system of linear
     !! equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! ZSYTRF_ROOK is called to compute the factorization of a complex
     !! symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling ZSYTRS_ROOK.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_zsytrf_rook( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=dp)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYSV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_zsytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs_rook ( use level 2 blas)
              call stdlib_zsytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zsysv_rook

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$sysv_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZSYSV_ROOK: computes the solution to a complex system of linear
     !! equations
     !! A * X = B,
     !! where A is an N-by-N symmetric matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**T,  if UPLO = 'U', or
     !! A = L * D * L**T,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is symmetric and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.
     !! ZSYTRF_ROOK is called to compute the factorization of a complex
     !! symmetric matrix A using the bounded Bunch-Kaufman ("rook") diagonal
     !! pivoting method.
     !! The factored form of A is then used to solve the system
     !! of equations A * X = B by calling ZSYTRS_ROOK.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 call stdlib_${ci}$sytrf_rook( uplo, n, a, lda, ipiv, work, -1, info )
                 lwkopt = real( work(1),KIND=${ck}$)
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZSYSV_ROOK ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**t or a = l*d*l**t.
           call stdlib_${ci}$sytrf_rook( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              ! solve with trs_rook ( use level 2 blas)
              call stdlib_${ci}$sytrs_rook( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$sysv_rook

#:endif
#:endfor





     pure subroutine stdlib_chesv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! CHESV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**H,  if UPLO = 'U', or
     !! A = L * D * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, nb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'CHETRF', uplo, n, -1, -1, -1 )
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHESV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_chetrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_chetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_chetrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chesv

     pure subroutine stdlib_zhesv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZHESV computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**H,  if UPLO = 'U', or
     !! A = L * D * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, nb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'ZHETRF', uplo, n, -1, -1, -1 )
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHESV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_zhetrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_zhetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_zhetrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zhesv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$hesv( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZHESV: computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! The diagonal pivoting method is used to factor A as
     !! A = U * D * U**H,  if UPLO = 'U', or
     !! A = L * D * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and D is Hermitian and block diagonal with
     !! 1-by-1 and 2-by-2 diagonal blocks.  The factored form of A is then
     !! used to solve the system of equations A * X = B.
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, nb
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<1 .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              if( n==0 ) then
                 lwkopt = 1
              else
                 nb = stdlib_ilaenv( 1, 'ZHETRF', uplo, n, -1, -1, -1 )
                 lwkopt = n*nb
              end if
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHESV ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u*d*u**h or a = l*d*l**h.
           call stdlib_${ci}$hetrf( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              if ( lwork<n ) then
              ! solve with trs ( use level blas 2)
                 call stdlib_${ci}$hetrs( uplo, n, nrhs, a, lda, ipiv, b, ldb, info )
              else
              ! solve with trs2 ( use level blas 3)
                 call stdlib_${ci}$hetrs2( uplo,n,nrhs,a,lda,ipiv,b,ldb,work,info )
              end if
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$hesv

#:endif
#:endfor



     pure subroutine stdlib_chesv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! CHESV_AA computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**H * T * U,  if UPLO = 'U', or
     !! A = L * T * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is Hermitian and tridiagonal. The factored form
     !! of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_hetrf, lwkopt_hetrs
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max( 2*n, 3*n-2 ) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_chetrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_hetrf = int( work(1),KIND=ilp)
              call stdlib_chetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_hetrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_hetrf, lwkopt_hetrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHESV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**h*t*u or a = l*t*l**h.
           call stdlib_chetrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_chetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_chesv_aa

     pure subroutine stdlib_zhesv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZHESV_AA computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**H * T * U,  if UPLO = 'U', or
     !! A = L * T * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is Hermitian and tridiagonal. The factored form
     !! of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_hetrf, lwkopt_hetrs
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max(2*n, 3*n-2) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_zhetrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_hetrf = int( work(1),KIND=ilp)
              call stdlib_zhetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_hetrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_hetrf, lwkopt_hetrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHESV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**h*t*u or a = l*t*l**h.
           call stdlib_zhetrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_zhetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_zhesv_aa

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$hesv_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
     !! ZHESV_AA: computes the solution to a complex system of linear equations
     !! A * X = B,
     !! where A is an N-by-N Hermitian matrix and X and B are N-by-NRHS
     !! matrices.
     !! Aasen's algorithm is used to factor A as
     !! A = U**H * T * U,  if UPLO = 'U', or
     !! A = L * T * L**H,  if UPLO = 'L',
     !! where U (or L) is a product of permutation and unit upper (lower)
     !! triangular matrices, and T is Hermitian and tridiagonal. The factored form
     !! of A is then used to solve the system of equations A * X = B.
               
        ! -- lapack driver routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: uplo
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, lwork, n, nrhs
           ! Array Arguments 
           integer(ilp), intent(out) :: ipiv(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: lwkopt, lwkopt_hetrf, lwkopt_hetrs
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters.
           info = 0
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( uplo, 'U' ) .and. .not.stdlib_lsame( uplo, 'L' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( nrhs<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( lwork<max(2*n, 3*n-2) .and. .not.lquery ) then
              info = -10
           end if
           if( info==0 ) then
              call stdlib_${ci}$hetrf_aa( uplo, n, a, lda, ipiv, work, -1, info )
              lwkopt_hetrf = int( work(1),KIND=ilp)
              call stdlib_${ci}$hetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,-1, info )
              lwkopt_hetrs = int( work(1),KIND=ilp)
              lwkopt = max( lwkopt_hetrf, lwkopt_hetrs )
              work( 1 ) = lwkopt
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHESV_AA ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! compute the factorization a = u**h*t*u or a = l*t*l**h.
           call stdlib_${ci}$hetrf_aa( uplo, n, a, lda, ipiv, work, lwork, info )
           if( info==0 ) then
              ! solve the system a*x = b, overwriting b with x.
              call stdlib_${ci}$hetrs_aa( uplo, n, nrhs, a, lda, ipiv, b, ldb, work,lwork, info )
                        
           end if
           work( 1 ) = lwkopt
           return
     end subroutine stdlib_${ci}$hesv_aa

#:endif
#:endfor




end module stdlib_lapack_solve_ldl
