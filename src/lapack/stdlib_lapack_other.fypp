#:include "common.fypp" 
module stdlib_lapack_other
  use stdlib_linalg_constants
  use stdlib_linalg_lapack_aux
  use stdlib_linalg_blas
  use stdlib_lapack_solve
  implicit none(type,external)

interface 
     real(sp) module function stdlib_sla_syrpvgrw( uplo, n, info, a, lda, af, ldaf, ipiv,work )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, info, lda, ldaf
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(in) :: a(lda,*), af(ldaf,*)
           real(sp), intent(out) :: work(*)
     end function stdlib_sla_syrpvgrw

     real(dp) module function stdlib_dla_syrpvgrw( uplo, n, info, a, lda, af,ldaf, ipiv, work )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, info, lda, ldaf
           integer(ilp), intent(in) :: ipiv(*)
           real(dp), intent(in) :: a(lda,*), af(ldaf,*)
           real(dp), intent(out) :: work(*)
     end function stdlib_dla_syrpvgrw

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     real(${rk}$) module function stdlib_${ri}$la_syrpvgrw( uplo, n, info, a, lda, af,ldaf, ipiv, work )
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, info, lda, ldaf
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(in) :: a(lda,*), af(ldaf,*)
           real(${rk}$), intent(out) :: work(*)
     end function stdlib_${ri}$la_syrpvgrw

#:endif
#:endfor

     real(sp) module function stdlib_cla_syrpvgrw( uplo, n, info, a, lda, af, ldaf, ipiv,work )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, info, lda, ldaf
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*)
           real(sp), intent(out) :: work(*)
           integer(ilp), intent(in) :: ipiv(*)
     end function stdlib_cla_syrpvgrw

     real(dp) module function stdlib_zla_syrpvgrw( uplo, n, info, a, lda, af,ldaf, ipiv, work )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, info, lda, ldaf
           complex(dp), intent(in) :: a(lda,*), af(ldaf,*)
           real(dp), intent(out) :: work(*)
           integer(ilp), intent(in) :: ipiv(*)
     end function stdlib_zla_syrpvgrw

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     real(${ck}$) module function stdlib_${ci}$la_syrpvgrw( uplo, n, info, a, lda, af,ldaf, ipiv, work )
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, info, lda, ldaf
           complex(${ck}$), intent(in) :: a(lda,*), af(ldaf,*)
           real(${ck}$), intent(out) :: work(*)
           integer(ilp), intent(in) :: ipiv(*)
     end function stdlib_${ci}$la_syrpvgrw

#:endif
#:endfor

end interface 


interface 
     pure real(sp) module function stdlib_sla_gerpvgrw( n, ncols, a, lda, af, ldaf )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           integer(ilp), intent(in) :: n, ncols, lda, ldaf
           real(sp), intent(in) :: a(lda,*), af(ldaf,*)
     end function stdlib_sla_gerpvgrw

     pure real(dp) module function stdlib_dla_gerpvgrw( n, ncols, a, lda, af,ldaf )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           integer(ilp), intent(in) :: n, ncols, lda, ldaf
           real(dp), intent(in) :: a(lda,*), af(ldaf,*)
     end function stdlib_dla_gerpvgrw

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure real(${rk}$) module function stdlib_${ri}$la_gerpvgrw( n, ncols, a, lda, af,ldaf )
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           integer(ilp), intent(in) :: n, ncols, lda, ldaf
           real(${rk}$), intent(in) :: a(lda,*), af(ldaf,*)
     end function stdlib_${ri}$la_gerpvgrw

#:endif
#:endfor

     pure real(sp) module function stdlib_cla_gerpvgrw( n, ncols, a, lda, af, ldaf )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           integer(ilp), intent(in) :: n, ncols, lda, ldaf
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*)
     end function stdlib_cla_gerpvgrw

     pure real(dp) module function stdlib_zla_gerpvgrw( n, ncols, a, lda, af,ldaf )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           integer(ilp), intent(in) :: n, ncols, lda, ldaf
           complex(dp), intent(in) :: a(lda,*), af(ldaf,*)
     end function stdlib_zla_gerpvgrw

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure real(${ck}$) module function stdlib_${ci}$la_gerpvgrw( n, ncols, a, lda, af,ldaf )
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           integer(ilp), intent(in) :: n, ncols, lda, ldaf
           complex(${ck}$), intent(in) :: a(lda,*), af(ldaf,*)
     end function stdlib_${ci}$la_gerpvgrw

#:endif
#:endfor

end interface 


interface 
     real(sp) module function stdlib_cla_gbrcond_c( trans, n, kl, ku, ab, ldab, afb,ldafb, ipiv, c, &
               capply, info, work,rwork )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: trans
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, kl, ku, ldab, ldafb
           integer(ilp) :: kd, ke
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: ab(ldab,*), afb(ldafb,*)
           complex(sp), intent(out) :: work(*)
           real(sp), intent(in) :: c(*)
           real(sp), intent(out) :: rwork(*)
     end function stdlib_cla_gbrcond_c

     real(dp) module function stdlib_zla_gbrcond_c( trans, n, kl, ku, ab,ldab, afb, ldafb, ipiv,c, &
               capply, info, work,rwork )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: trans
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, kl, ku, ldab, ldafb
           integer(ilp) :: kd, ke
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: ab(ldab,*), afb(ldafb,*)
           complex(dp), intent(out) :: work(*)
           real(dp), intent(in) :: c(*)
           real(dp), intent(out) :: rwork(*)
     end function stdlib_zla_gbrcond_c

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     real(${ck}$) module function stdlib_${ci}$la_gbrcond_c( trans, n, kl, ku, ab,ldab, afb, ldafb, ipiv,c, &
               capply, info, work,rwork )
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: trans
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, kl, ku, ldab, ldafb
           integer(ilp) :: kd, ke
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: ab(ldab,*), afb(ldafb,*)
           complex(${ck}$), intent(out) :: work(*)
           real(${ck}$), intent(in) :: c(*)
           real(${ck}$), intent(out) :: rwork(*)
     end function stdlib_${ci}$la_gbrcond_c

#:endif
#:endfor

end interface 


interface 
     real(sp) module function stdlib_cla_gercond_c( trans, n, a, lda, af, ldaf, ipiv, c,capply, info, &
               work, rwork )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: trans
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, lda, ldaf
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*)
           complex(sp), intent(out) :: work(*)
           real(sp), intent(in) :: c(*)
           real(sp), intent(out) :: rwork(*)
     end function stdlib_cla_gercond_c

     real(dp) module function stdlib_zla_gercond_c( trans, n, a, lda, af,ldaf, ipiv, c, capply,info, &
               work, rwork )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: trans
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, lda, ldaf
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: a(lda,*), af(ldaf,*)
           complex(dp), intent(out) :: work(*)
           real(dp), intent(in) :: c(*)
           real(dp), intent(out) :: rwork(*)
     end function stdlib_zla_gercond_c

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     real(${ck}$) module function stdlib_${ci}$la_gercond_c( trans, n, a, lda, af,ldaf, ipiv, c, capply,info, &
               work, rwork )
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: trans
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, lda, ldaf
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: a(lda,*), af(ldaf,*)
           complex(${ck}$), intent(out) :: work(*)
           real(${ck}$), intent(in) :: c(*)
           real(${ck}$), intent(out) :: rwork(*)
     end function stdlib_${ci}$la_gercond_c

#:endif
#:endfor

end interface 


interface 
     real(sp) module function stdlib_cla_hercond_c( uplo, n, a, lda, af, ldaf, ipiv, c,capply, info, &
               work, rwork )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: uplo
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, lda, ldaf
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*)
           complex(sp), intent(out) :: work(*)
           real(sp), intent(in) :: c(*)
           real(sp), intent(out) :: rwork(*)
     end function stdlib_cla_hercond_c

     real(dp) module function stdlib_zla_hercond_c( uplo, n, a, lda, af,ldaf, ipiv, c, capply,info, work,&
                rwork )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: uplo
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, lda, ldaf
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: a(lda,*), af(ldaf,*)
           complex(dp), intent(out) :: work(*)
           real(dp), intent(in) :: c(*)
           real(dp), intent(out) :: rwork(*)
     end function stdlib_zla_hercond_c

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     real(${ck}$) module function stdlib_${ci}$la_hercond_c( uplo, n, a, lda, af,ldaf, ipiv, c, capply,info, work,&
                rwork )
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: uplo
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, lda, ldaf
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: a(lda,*), af(ldaf,*)
           complex(${ck}$), intent(out) :: work(*)
           real(${ck}$), intent(in) :: c(*)
           real(${ck}$), intent(out) :: rwork(*)
     end function stdlib_${ci}$la_hercond_c

#:endif
#:endfor

end interface 


interface 
     module subroutine stdlib_sla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           real(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, n, uplo
           real(sp), intent(in) :: a(lda,*), x(*)
           real(sp), intent(inout) :: y(*)
     end subroutine stdlib_sla_syamv

     module subroutine stdlib_dla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           real(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, n, uplo
           real(dp), intent(in) :: a(lda,*), x(*)
           real(dp), intent(inout) :: y(*)
     end subroutine stdlib_dla_syamv

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$la_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           real(${rk}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, n, uplo
           real(${rk}$), intent(in) :: a(lda,*), x(*)
           real(${rk}$), intent(inout) :: y(*)
     end subroutine stdlib_${ri}$la_syamv

#:endif
#:endfor

     module subroutine stdlib_cla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           real(sp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, n
           integer(ilp), intent(in) :: uplo
           complex(sp), intent(in) :: a(lda,*), x(*)
           real(sp), intent(inout) :: y(*)
     end subroutine stdlib_cla_syamv

     module subroutine stdlib_zla_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           real(dp), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, n
           integer(ilp), intent(in) :: uplo
           complex(dp), intent(in) :: a(lda,*), x(*)
           real(dp), intent(inout) :: y(*)
     end subroutine stdlib_zla_syamv

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$la_syamv( uplo, n, alpha, a, lda, x, incx, beta, y,incy )
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           real(${ck}$), intent(in) :: alpha, beta
           integer(ilp), intent(in) :: incx, incy, lda, n
           integer(ilp), intent(in) :: uplo
           complex(${ck}$), intent(in) :: a(lda,*), x(*)
           real(${ck}$), intent(inout) :: y(*)
     end subroutine stdlib_${ci}$la_syamv

#:endif
#:endfor

end interface 


interface 
     real(sp) module function stdlib_sla_syrcond( uplo, n, a, lda, af, ldaf, ipiv, cmode,c, info, work, &
               iwork )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, lda, ldaf, cmode
           integer(ilp), intent(out) :: info
           integer(ilp), intent(out) :: iwork(*)
           integer(ilp), intent(in) :: ipiv(*)
           real(sp), intent(in) :: a(lda,*), af(ldaf,*), c(*)
           real(sp), intent(out) :: work(*)
     end function stdlib_sla_syrcond

     real(dp) module function stdlib_dla_syrcond( uplo, n, a, lda, af, ldaf,ipiv, cmode, c, info, work,&
               iwork )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, lda, ldaf, cmode
           integer(ilp), intent(out) :: info
           integer(ilp), intent(out) :: iwork(*)
           integer(ilp), intent(in) :: ipiv(*)
           real(dp), intent(in) :: a(lda,*), af(ldaf,*), c(*)
           real(dp), intent(out) :: work(*)
     end function stdlib_dla_syrcond

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     real(${rk}$) module function stdlib_${ri}$la_syrcond( uplo, n, a, lda, af, ldaf,ipiv, cmode, c, info, work,&
               iwork )
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: uplo
           integer(ilp), intent(in) :: n, lda, ldaf, cmode
           integer(ilp), intent(out) :: info
           integer(ilp), intent(out) :: iwork(*)
           integer(ilp), intent(in) :: ipiv(*)
           real(${rk}$), intent(in) :: a(lda,*), af(ldaf,*), c(*)
           real(${rk}$), intent(out) :: work(*)
     end function stdlib_${ri}$la_syrcond

#:endif
#:endfor

end interface 


interface 
     real(sp) module function stdlib_cla_syrcond_c( uplo, n, a, lda, af, ldaf, ipiv, c,capply, info, &
               work, rwork )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: uplo
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, lda, ldaf
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ipiv(*)
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*)
           complex(sp), intent(out) :: work(*)
           real(sp), intent(in) :: c(*)
           real(sp), intent(out) :: rwork(*)
     end function stdlib_cla_syrcond_c

     real(dp) module function stdlib_zla_syrcond_c( uplo, n, a, lda, af,ldaf, ipiv, c, capply,info, work,&
                rwork )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: uplo
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, lda, ldaf
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ipiv(*)
           complex(dp), intent(in) :: a(lda,*), af(ldaf,*)
           complex(dp), intent(out) :: work(*)
           real(dp), intent(in) :: c(*)
           real(dp), intent(out) :: rwork(*)
     end function stdlib_zla_syrcond_c

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     real(${ck}$) module function stdlib_${ci}$la_syrcond_c( uplo, n, a, lda, af,ldaf, ipiv, c, capply,info, work,&
                rwork )
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: uplo
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, lda, ldaf
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ipiv(*)
           complex(${ck}$), intent(in) :: a(lda,*), af(ldaf,*)
           complex(${ck}$), intent(out) :: work(*)
           real(${ck}$), intent(in) :: c(*)
           real(${ck}$), intent(out) :: rwork(*)
     end function stdlib_${ci}$la_syrcond_c

#:endif
#:endfor

end interface 


interface 
     real(sp) module function stdlib_cla_porcond_c( uplo, n, a, lda, af, ldaf, c, capply,info, work, &
               rwork )
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: uplo
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, lda, ldaf
           integer(ilp), intent(out) :: info
           complex(sp), intent(in) :: a(lda,*), af(ldaf,*)
           complex(sp), intent(out) :: work(*)
           real(sp), intent(in) :: c(*)
           real(sp), intent(out) :: rwork(*)
     end function stdlib_cla_porcond_c

     real(dp) module function stdlib_zla_porcond_c( uplo, n, a, lda, af,ldaf, c, capply, info,work, &
               rwork )
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: uplo
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, lda, ldaf
           integer(ilp), intent(out) :: info
           complex(dp), intent(in) :: a(lda,*), af(ldaf,*)
           complex(dp), intent(out) :: work(*)
           real(dp), intent(in) :: c(*)
           real(dp), intent(out) :: rwork(*)
     end function stdlib_zla_porcond_c

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     real(${ck}$) module function stdlib_${ci}$la_porcond_c( uplo, n, a, lda, af,ldaf, c, capply, info,work, &
               rwork )
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           character, intent(in) :: uplo
           logical(lk), intent(in) :: capply
           integer(ilp), intent(in) :: n, lda, ldaf
           integer(ilp), intent(out) :: info
           complex(${ck}$), intent(in) :: a(lda,*), af(ldaf,*)
           complex(${ck}$), intent(out) :: work(*)
           real(${ck}$), intent(in) :: c(*)
           real(${ck}$), intent(out) :: rwork(*)
     end function stdlib_${ci}$la_porcond_c

#:endif
#:endfor

end interface 

end module stdlib_lapack_other
