#:include "common.fypp" 
module stdlib_lapack_cosine_sine
  use stdlib_linalg_constants
  use stdlib_linalg_lapack_aux
  use stdlib_linalg_blas
  use stdlib_lapack_svd_comp
  use stdlib_lapack_blas_like_l1
  use stdlib_lapack_givens_jacobi_rot
  implicit none(type,external)


  contains



     pure subroutine stdlib_slapmt( forwrd, m, n, x, ldx, k )
     !! SLAPMT rearranges the columns of the M by N matrix X as specified
     !! by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.
     !! If FORWRD = .TRUE.,  forward permutation:
     !! X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
     !! If FORWRD = .FALSE., backward permutation:
     !! X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: forwrd
           integer(ilp), intent(in) :: ldx, m, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: k(*)
           real(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ii, j, in
           real(sp) :: temp
           ! Executable Statements 
           if( n<=1 )return
           do i = 1, n
              k( i ) = -k( i )
           end do
           if( forwrd ) then
              ! forward permutation
              do i = 1, n
                 if( k( i )>0 )go to 40
                 j = i
                 k( j ) = -k( j )
                 in = k( j )
                 20 continue
                 if( k( in )>0 )go to 40
                 do ii = 1, m
                    temp = x( ii, j )
                    x( ii, j ) = x( ii, in )
                    x( ii, in ) = temp
                 end do
                 k( in ) = -k( in )
                 j = in
                 in = k( in )
                 go to 20
                 40 continue
              end do
           else
              ! backward permutation
              do i = 1, n
                 if( k( i )>0 )go to 100
                 k( i ) = -k( i )
                 j = k( i )
                 80 continue
                 if( j==i )go to 100
                 do ii = 1, m
                    temp = x( ii, i )
                    x( ii, i ) = x( ii, j )
                    x( ii, j ) = temp
                 end do
                 k( j ) = -k( j )
                 j = k( j )
                 go to 80
                 100 continue
              end do
           end if
           return
     end subroutine stdlib_slapmt

     pure subroutine stdlib_dlapmt( forwrd, m, n, x, ldx, k )
     !! DLAPMT rearranges the columns of the M by N matrix X as specified
     !! by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.
     !! If FORWRD = .TRUE.,  forward permutation:
     !! X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
     !! If FORWRD = .FALSE., backward permutation:
     !! X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: forwrd
           integer(ilp), intent(in) :: ldx, m, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: k(*)
           real(dp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ii, in, j
           real(dp) :: temp
           ! Executable Statements 
           if( n<=1 )return
           do i = 1, n
              k( i ) = -k( i )
           end do
           if( forwrd ) then
              ! forward permutation
              do i = 1, n
                 if( k( i )>0 )go to 40
                 j = i
                 k( j ) = -k( j )
                 in = k( j )
                 20 continue
                 if( k( in )>0 )go to 40
                 do ii = 1, m
                    temp = x( ii, j )
                    x( ii, j ) = x( ii, in )
                    x( ii, in ) = temp
                 end do
                 k( in ) = -k( in )
                 j = in
                 in = k( in )
                 go to 20
                 40 continue
              end do
           else
              ! backward permutation
              do i = 1, n
                 if( k( i )>0 )go to 80
                 k( i ) = -k( i )
                 j = k( i )
                 60 continue
                 if( j==i )go to 80
                 do ii = 1, m
                    temp = x( ii, i )
                    x( ii, i ) = x( ii, j )
                    x( ii, j ) = temp
                 end do
                 k( j ) = -k( j )
                 j = k( j )
                 go to 60
                 80 continue
              end do
           end if
           return
     end subroutine stdlib_dlapmt

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$lapmt( forwrd, m, n, x, ldx, k )
     !! DLAPMT: rearranges the columns of the M by N matrix X as specified
     !! by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.
     !! If FORWRD = .TRUE.,  forward permutation:
     !! X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
     !! If FORWRD = .FALSE., backward permutation:
     !! X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: forwrd
           integer(ilp), intent(in) :: ldx, m, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: k(*)
           real(${rk}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ii, in, j
           real(${rk}$) :: temp
           ! Executable Statements 
           if( n<=1 )return
           do i = 1, n
              k( i ) = -k( i )
           end do
           if( forwrd ) then
              ! forward permutation
              do i = 1, n
                 if( k( i )>0 )go to 40
                 j = i
                 k( j ) = -k( j )
                 in = k( j )
                 20 continue
                 if( k( in )>0 )go to 40
                 do ii = 1, m
                    temp = x( ii, j )
                    x( ii, j ) = x( ii, in )
                    x( ii, in ) = temp
                 end do
                 k( in ) = -k( in )
                 j = in
                 in = k( in )
                 go to 20
                 40 continue
              end do
           else
              ! backward permutation
              do i = 1, n
                 if( k( i )>0 )go to 80
                 k( i ) = -k( i )
                 j = k( i )
                 60 continue
                 if( j==i )go to 80
                 do ii = 1, m
                    temp = x( ii, i )
                    x( ii, i ) = x( ii, j )
                    x( ii, j ) = temp
                 end do
                 k( j ) = -k( j )
                 j = k( j )
                 go to 60
                 80 continue
              end do
           end if
           return
     end subroutine stdlib_${ri}$lapmt

#:endif
#:endfor

     pure subroutine stdlib_clapmt( forwrd, m, n, x, ldx, k )
     !! CLAPMT rearranges the columns of the M by N matrix X as specified
     !! by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.
     !! If FORWRD = .TRUE.,  forward permutation:
     !! X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
     !! If FORWRD = .FALSE., backward permutation:
     !! X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: forwrd
           integer(ilp), intent(in) :: ldx, m, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: k(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ii, j, in
           complex(sp) :: temp
           ! Executable Statements 
           if( n<=1 )return
           do i = 1, n
              k( i ) = -k( i )
           end do
           if( forwrd ) then
              ! forward permutation
              do i = 1, n
                 if( k( i )>0 )go to 40
                 j = i
                 k( j ) = -k( j )
                 in = k( j )
                 20 continue
                 if( k( in )>0 )go to 40
                 do ii = 1, m
                    temp = x( ii, j )
                    x( ii, j ) = x( ii, in )
                    x( ii, in ) = temp
                 end do
                 k( in ) = -k( in )
                 j = in
                 in = k( in )
                 go to 20
                 40 continue
              end do
           else
              ! backward permutation
              do i = 1, n
                 if( k( i )>0 )go to 100
                 k( i ) = -k( i )
                 j = k( i )
                 80 continue
                 if( j==i )go to 100
                 do ii = 1, m
                    temp = x( ii, i )
                    x( ii, i ) = x( ii, j )
                    x( ii, j ) = temp
                 end do
                 k( j ) = -k( j )
                 j = k( j )
                 go to 80
                 100 continue
              end do
           end if
           return
     end subroutine stdlib_clapmt

     pure subroutine stdlib_zlapmt( forwrd, m, n, x, ldx, k )
     !! ZLAPMT rearranges the columns of the M by N matrix X as specified
     !! by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.
     !! If FORWRD = .TRUE.,  forward permutation:
     !! X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
     !! If FORWRD = .FALSE., backward permutation:
     !! X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: forwrd
           integer(ilp), intent(in) :: ldx, m, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: k(*)
           complex(dp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ii, in, j
           complex(dp) :: temp
           ! Executable Statements 
           if( n<=1 )return
           do i = 1, n
              k( i ) = -k( i )
           end do
           if( forwrd ) then
              ! forward permutation
              do i = 1, n
                 if( k( i )>0 )go to 40
                 j = i
                 k( j ) = -k( j )
                 in = k( j )
                 20 continue
                 if( k( in )>0 )go to 40
                 do ii = 1, m
                    temp = x( ii, j )
                    x( ii, j ) = x( ii, in )
                    x( ii, in ) = temp
                 end do
                 k( in ) = -k( in )
                 j = in
                 in = k( in )
                 go to 20
                 40 continue
              end do
           else
              ! backward permutation
              do i = 1, n
                 if( k( i )>0 )go to 80
                 k( i ) = -k( i )
                 j = k( i )
                 60 continue
                 if( j==i )go to 80
                 do ii = 1, m
                    temp = x( ii, i )
                    x( ii, i ) = x( ii, j )
                    x( ii, j ) = temp
                 end do
                 k( j ) = -k( j )
                 j = k( j )
                 go to 60
                 80 continue
              end do
           end if
           return
     end subroutine stdlib_zlapmt

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$lapmt( forwrd, m, n, x, ldx, k )
     !! ZLAPMT: rearranges the columns of the M by N matrix X as specified
     !! by the permutation K(1),K(2),...,K(N) of the integers 1,...,N.
     !! If FORWRD = .TRUE.,  forward permutation:
     !! X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
     !! If FORWRD = .FALSE., backward permutation:
     !! X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: forwrd
           integer(ilp), intent(in) :: ldx, m, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: k(*)
           complex(${ck}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, ii, in, j
           complex(${ck}$) :: temp
           ! Executable Statements 
           if( n<=1 )return
           do i = 1, n
              k( i ) = -k( i )
           end do
           if( forwrd ) then
              ! forward permutation
              do i = 1, n
                 if( k( i )>0 )go to 40
                 j = i
                 k( j ) = -k( j )
                 in = k( j )
                 20 continue
                 if( k( in )>0 )go to 40
                 do ii = 1, m
                    temp = x( ii, j )
                    x( ii, j ) = x( ii, in )
                    x( ii, in ) = temp
                 end do
                 k( in ) = -k( in )
                 j = in
                 in = k( in )
                 go to 20
                 40 continue
              end do
           else
              ! backward permutation
              do i = 1, n
                 if( k( i )>0 )go to 80
                 k( i ) = -k( i )
                 j = k( i )
                 60 continue
                 if( j==i )go to 80
                 do ii = 1, m
                    temp = x( ii, i )
                    x( ii, i ) = x( ii, j )
                    x( ii, j ) = temp
                 end do
                 k( j ) = -k( j )
                 j = k( j )
                 go to 60
                 80 continue
              end do
           end if
           return
     end subroutine stdlib_${ci}$lapmt

#:endif
#:endfor



     pure subroutine stdlib_cunbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, lwork, info )
     !! CUNBDB5 orthogonalizes the column vector
     !! X = [ X1 ]
     !! [ X2 ]
     !! with respect to the columns of
     !! Q = [ Q1 ] .
     !! [ Q2 ]
     !! The columns of Q must be orthonormal.
     !! If the projection is zero according to Kahan's "twice is enough"
     !! criterion, then some other vector from the orthogonal complement
     !! is returned. This vector is chosen in an arbitrary but deterministic
     !! way.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x1(*), x2(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: childinfo, i, j
           ! Intrinsic Function 
           ! Executable Statements 
           ! test input arguments
           info = 0
           if( m1 < 0 ) then
              info = -1
           else if( m2 < 0 ) then
              info = -2
           else if( n < 0 ) then
              info = -3
           else if( incx1 < 1 ) then
              info = -5
           else if( incx2 < 1 ) then
              info = -7
           else if( ldq1 < max( 1, m1 ) ) then
              info = -9
           else if( ldq2 < max( 1, m2 ) ) then
              info = -11
           else if( lwork < n ) then
              info = -13
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'CUNBDB5', -info )
              return
           end if
           ! project x onto the orthogonal complement of q
           call stdlib_cunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2, ldq2,work, lwork, &
                     childinfo )
           ! if the projection is nonzero, then return
           if( stdlib_scnrm2(m1,x1,incx1) /= czero.or. stdlib_scnrm2(m2,x2,incx2) /= czero ) &
                     then
              return
           end if
           ! project each standard basis vector e_1,...,e_m1 in turn, stopping
           ! when a nonzero projection is found
           do i = 1, m1
              do j = 1, m1
                 x1(j) = czero
              end do
              x1(i) = cone
              do j = 1, m2
                 x2(j) = czero
              end do
              call stdlib_cunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                        lwork, childinfo )
              if( stdlib_scnrm2(m1,x1,incx1) /= czero.or. stdlib_scnrm2(m2,x2,incx2) /= czero ) &
                        then
                 return
              end if
           end do
           ! project each standard basis vector e_(m1+1),...,e_(m1+m2) in turn,
           ! stopping when a nonzero projection is found
           do i = 1, m2
              do j = 1, m1
                 x1(j) = czero
              end do
              do j = 1, m2
                 x2(j) = czero
              end do
              x2(i) = cone
              call stdlib_cunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                        lwork, childinfo )
              if( stdlib_scnrm2(m1,x1,incx1) /= czero.or. stdlib_scnrm2(m2,x2,incx2) /= czero ) &
                        then
                 return
              end if
           end do
           return
     end subroutine stdlib_cunbdb5

     pure subroutine stdlib_zunbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, lwork, info )
     !! ZUNBDB5 orthogonalizes the column vector
     !! X = [ X1 ]
     !! [ X2 ]
     !! with respect to the columns of
     !! Q = [ Q1 ] .
     !! [ Q2 ]
     !! The columns of Q must be orthonormal.
     !! If the projection is zero according to Kahan's "twice is enough"
     !! criterion, then some other vector from the orthogonal complement
     !! is returned. This vector is chosen in an arbitrary but deterministic
     !! way.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(dp), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           complex(dp), intent(out) :: work(*)
           complex(dp), intent(inout) :: x1(*), x2(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: childinfo, i, j
           ! Intrinsic Function 
           ! Executable Statements 
           ! test input arguments
           info = 0
           if( m1 < 0 ) then
              info = -1
           else if( m2 < 0 ) then
              info = -2
           else if( n < 0 ) then
              info = -3
           else if( incx1 < 1 ) then
              info = -5
           else if( incx2 < 1 ) then
              info = -7
           else if( ldq1 < max( 1, m1 ) ) then
              info = -9
           else if( ldq2 < max( 1, m2 ) ) then
              info = -11
           else if( lwork < n ) then
              info = -13
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'ZUNBDB5', -info )
              return
           end if
           ! project x onto the orthogonal complement of q
           call stdlib_zunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2, ldq2,work, lwork, &
                     childinfo )
           ! if the projection is nonzero, then return
           if( stdlib_dznrm2(m1,x1,incx1) /= czero.or. stdlib_dznrm2(m2,x2,incx2) /= czero ) &
                     then
              return
           end if
           ! project each standard basis vector e_1,...,e_m1 in turn, stopping
           ! when a nonzero projection is found
           do i = 1, m1
              do j = 1, m1
                 x1(j) = czero
              end do
              x1(i) = cone
              do j = 1, m2
                 x2(j) = czero
              end do
              call stdlib_zunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                        lwork, childinfo )
              if( stdlib_dznrm2(m1,x1,incx1) /= czero.or. stdlib_dznrm2(m2,x2,incx2) /= czero ) &
                        then
                 return
              end if
           end do
           ! project each standard basis vector e_(m1+1),...,e_(m1+m2) in turn,
           ! stopping when a nonzero projection is found
           do i = 1, m2
              do j = 1, m1
                 x1(j) = czero
              end do
              do j = 1, m2
                 x2(j) = czero
              end do
              x2(i) = cone
              call stdlib_zunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                        lwork, childinfo )
              if( stdlib_dznrm2(m1,x1,incx1) /= czero.or. stdlib_dznrm2(m2,x2,incx2) /= czero ) &
                        then
                 return
              end if
           end do
           return
     end subroutine stdlib_zunbdb5

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$unbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, lwork, info )
     !! ZUNBDB5: orthogonalizes the column vector
     !! X = [ X1 ]
     !! [ X2 ]
     !! with respect to the columns of
     !! Q = [ Q1 ] .
     !! [ Q2 ]
     !! The columns of Q must be orthonormal.
     !! If the projection is zero according to Kahan's "twice is enough"
     !! criterion, then some other vector from the orthogonal complement
     !! is returned. This vector is chosen in an arbitrary but deterministic
     !! way.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(${ck}$), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           complex(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(inout) :: x1(*), x2(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: childinfo, i, j
           ! Intrinsic Function 
           ! Executable Statements 
           ! test input arguments
           info = 0
           if( m1 < 0 ) then
              info = -1
           else if( m2 < 0 ) then
              info = -2
           else if( n < 0 ) then
              info = -3
           else if( incx1 < 1 ) then
              info = -5
           else if( incx2 < 1 ) then
              info = -7
           else if( ldq1 < max( 1, m1 ) ) then
              info = -9
           else if( ldq2 < max( 1, m2 ) ) then
              info = -11
           else if( lwork < n ) then
              info = -13
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'ZUNBDB5', -info )
              return
           end if
           ! project x onto the orthogonal complement of q
           call stdlib_${ci}$unbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2, ldq2,work, lwork, &
                     childinfo )
           ! if the projection is nonzero, then return
           if( stdlib_${c2ri(ci)}$znrm2(m1,x1,incx1) /= czero.or. stdlib_${c2ri(ci)}$znrm2(m2,x2,incx2) /= czero ) &
                     then
              return
           end if
           ! project each standard basis vector e_1,...,e_m1 in turn, stopping
           ! when a nonzero projection is found
           do i = 1, m1
              do j = 1, m1
                 x1(j) = czero
              end do
              x1(i) = cone
              do j = 1, m2
                 x2(j) = czero
              end do
              call stdlib_${ci}$unbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                        lwork, childinfo )
              if( stdlib_${c2ri(ci)}$znrm2(m1,x1,incx1) /= czero.or. stdlib_${c2ri(ci)}$znrm2(m2,x2,incx2) /= czero ) &
                        then
                 return
              end if
           end do
           ! project each standard basis vector e_(m1+1),...,e_(m1+m2) in turn,
           ! stopping when a nonzero projection is found
           do i = 1, m2
              do j = 1, m1
                 x1(j) = czero
              end do
              do j = 1, m2
                 x2(j) = czero
              end do
              x2(i) = cone
              call stdlib_${ci}$unbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                        lwork, childinfo )
              if( stdlib_${c2ri(ci)}$znrm2(m1,x1,incx1) /= czero.or. stdlib_${c2ri(ci)}$znrm2(m2,x2,incx2) /= czero ) &
                        then
                 return
              end if
           end do
           return
     end subroutine stdlib_${ci}$unbdb5

#:endif
#:endfor











     pure subroutine stdlib_cunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, lwork, info )
     !! CUNBDB6 orthogonalizes the column vector
     !! X = [ X1 ]
     !! [ X2 ]
     !! with respect to the columns of
     !! Q = [ Q1 ] .
     !! [ Q2 ]
     !! The columns of Q must be orthonormal.
     !! If the projection is zero according to Kahan's "twice is enough"
     !! criterion, then the zero vector is returned.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           complex(sp), intent(out) :: work(*)
           complex(sp), intent(inout) :: x1(*), x2(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: alphasq = 0.01_sp
           real(sp), parameter :: realone = 1.0_sp
           real(sp), parameter :: realzero = 0.0_sp
           
           
           ! Local Scalars 
           integer(ilp) :: i
           real(sp) :: normsq1, normsq2, scl1, scl2, ssq1, ssq2
           ! Intrinsic Function 
           ! Executable Statements 
           ! test input arguments
           info = 0
           if( m1 < 0 ) then
              info = -1
           else if( m2 < 0 ) then
              info = -2
           else if( n < 0 ) then
              info = -3
           else if( incx1 < 1 ) then
              info = -5
           else if( incx2 < 1 ) then
              info = -7
           else if( ldq1 < max( 1, m1 ) ) then
              info = -9
           else if( ldq2 < max( 1, m2 ) ) then
              info = -11
           else if( lwork < n ) then
              info = -13
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'CUNBDB6', -info )
              return
           end if
           ! first, project x onto the orthogonal complement of q's column
           ! space
           scl1 = realzero
           ssq1 = realone
           call stdlib_classq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_classq( m2, x2, incx2, scl2, ssq2 )
           normsq1 = scl1**2*ssq1 + scl2**2*ssq2
           if( m1 == 0 ) then
              do i = 1, n
                 work(i) = czero
              end do
           else
              call stdlib_cgemv( 'C', m1, n, cone, q1, ldq1, x1, incx1, czero, work,1 )
           end if
           call stdlib_cgemv( 'C', m2, n, cone, q2, ldq2, x2, incx2, cone, work, 1 )
           call stdlib_cgemv( 'N', m1, n, cnegone, q1, ldq1, work, 1, cone, x1,incx1 )
           call stdlib_cgemv( 'N', m2, n, cnegone, q2, ldq2, work, 1, cone, x2,incx2 )
           scl1 = realzero
           ssq1 = realone
           call stdlib_classq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_classq( m2, x2, incx2, scl2, ssq2 )
           normsq2 = scl1**2*ssq1 + scl2**2*ssq2
           ! if projection is sufficiently large in norm, then stop.
           ! if projection is czero, then stop.
           ! otherwise, project again.
           if( normsq2 >= alphasq*normsq1 ) then
              return
           end if
           if( normsq2 == czero ) then
              return
           end if
           normsq1 = normsq2
           do i = 1, n
              work(i) = czero
           end do
           if( m1 == 0 ) then
              do i = 1, n
                 work(i) = czero
              end do
           else
              call stdlib_cgemv( 'C', m1, n, cone, q1, ldq1, x1, incx1, czero, work,1 )
           end if
           call stdlib_cgemv( 'C', m2, n, cone, q2, ldq2, x2, incx2, cone, work, 1 )
           call stdlib_cgemv( 'N', m1, n, cnegone, q1, ldq1, work, 1, cone, x1,incx1 )
           call stdlib_cgemv( 'N', m2, n, cnegone, q2, ldq2, work, 1, cone, x2,incx2 )
           scl1 = realzero
           ssq1 = realone
           call stdlib_classq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_classq( m1, x1, incx1, scl1, ssq1 )
           normsq2 = scl1**2*ssq1 + scl2**2*ssq2
           ! if second projection is sufficiently large in norm, then do
           ! nothing more. alternatively, if it shrunk significantly, then
           ! truncate it to czero.
           if( normsq2 < alphasq*normsq1 ) then
              do i = 1, m1
                 x1(i) = czero
              end do
              do i = 1, m2
                 x2(i) = czero
              end do
           end if
           return
     end subroutine stdlib_cunbdb6

     pure subroutine stdlib_zunbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, lwork, info )
     !! ZUNBDB6 orthogonalizes the column vector
     !! X = [ X1 ]
     !! [ X2 ]
     !! with respect to the columns of
     !! Q = [ Q1 ] .
     !! [ Q2 ]
     !! The columns of Q must be orthonormal.
     !! If the projection is zero according to Kahan's "twice is enough"
     !! criterion, then the zero vector is returned.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(dp), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           complex(dp), intent(out) :: work(*)
           complex(dp), intent(inout) :: x1(*), x2(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: alphasq = 0.01_dp
           real(dp), parameter :: realone = 1.0_dp
           real(dp), parameter :: realzero = 0.0_dp
           
           
           ! Local Scalars 
           integer(ilp) :: i
           real(dp) :: normsq1, normsq2, scl1, scl2, ssq1, ssq2
           ! Intrinsic Function 
           ! Executable Statements 
           ! test input arguments
           info = 0
           if( m1 < 0 ) then
              info = -1
           else if( m2 < 0 ) then
              info = -2
           else if( n < 0 ) then
              info = -3
           else if( incx1 < 1 ) then
              info = -5
           else if( incx2 < 1 ) then
              info = -7
           else if( ldq1 < max( 1, m1 ) ) then
              info = -9
           else if( ldq2 < max( 1, m2 ) ) then
              info = -11
           else if( lwork < n ) then
              info = -13
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'ZUNBDB6', -info )
              return
           end if
           ! first, project x onto the orthogonal complement of q's column
           ! space
           scl1 = realzero
           ssq1 = realone
           call stdlib_zlassq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_zlassq( m2, x2, incx2, scl2, ssq2 )
           normsq1 = scl1**2*ssq1 + scl2**2*ssq2
           if( m1 == 0 ) then
              do i = 1, n
                 work(i) = czero
              end do
           else
              call stdlib_zgemv( 'C', m1, n, cone, q1, ldq1, x1, incx1, czero, work,1 )
           end if
           call stdlib_zgemv( 'C', m2, n, cone, q2, ldq2, x2, incx2, cone, work, 1 )
           call stdlib_zgemv( 'N', m1, n, cnegone, q1, ldq1, work, 1, cone, x1,incx1 )
           call stdlib_zgemv( 'N', m2, n, cnegone, q2, ldq2, work, 1, cone, x2,incx2 )
           scl1 = realzero
           ssq1 = realone
           call stdlib_zlassq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_zlassq( m2, x2, incx2, scl2, ssq2 )
           normsq2 = scl1**2*ssq1 + scl2**2*ssq2
           ! if projection is sufficiently large in norm, then stop.
           ! if projection is czero, then stop.
           ! otherwise, project again.
           if( normsq2 >= alphasq*normsq1 ) then
              return
           end if
           if( normsq2 == czero ) then
              return
           end if
           normsq1 = normsq2
           do i = 1, n
              work(i) = czero
           end do
           if( m1 == 0 ) then
              do i = 1, n
                 work(i) = czero
              end do
           else
              call stdlib_zgemv( 'C', m1, n, cone, q1, ldq1, x1, incx1, czero, work,1 )
           end if
           call stdlib_zgemv( 'C', m2, n, cone, q2, ldq2, x2, incx2, cone, work, 1 )
           call stdlib_zgemv( 'N', m1, n, cnegone, q1, ldq1, work, 1, cone, x1,incx1 )
           call stdlib_zgemv( 'N', m2, n, cnegone, q2, ldq2, work, 1, cone, x2,incx2 )
           scl1 = realzero
           ssq1 = realone
           call stdlib_zlassq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_zlassq( m1, x1, incx1, scl1, ssq1 )
           normsq2 = scl1**2*ssq1 + scl2**2*ssq2
           ! if second projection is sufficiently large in norm, then do
           ! nothing more. alternatively, if it shrunk significantly, then
           ! truncate it to czero.
           if( normsq2 < alphasq*normsq1 ) then
              do i = 1, m1
                 x1(i) = czero
              end do
              do i = 1, m2
                 x2(i) = czero
              end do
           end if
           return
     end subroutine stdlib_zunbdb6

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$unbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, lwork, info )
     !! ZUNBDB6: orthogonalizes the column vector
     !! X = [ X1 ]
     !! [ X2 ]
     !! with respect to the columns of
     !! Q = [ Q1 ] .
     !! [ Q2 ]
     !! The columns of Q must be orthonormal.
     !! If the projection is zero according to Kahan's "twice is enough"
     !! criterion, then the zero vector is returned.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(${ck}$), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           complex(${ck}$), intent(out) :: work(*)
           complex(${ck}$), intent(inout) :: x1(*), x2(*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: alphasq = 0.01_${ck}$
           real(${ck}$), parameter :: realone = 1.0_${ck}$
           real(${ck}$), parameter :: realzero = 0.0_${ck}$
           
           
           ! Local Scalars 
           integer(ilp) :: i
           real(${ck}$) :: normsq1, normsq2, scl1, scl2, ssq1, ssq2
           ! Intrinsic Function 
           ! Executable Statements 
           ! test input arguments
           info = 0
           if( m1 < 0 ) then
              info = -1
           else if( m2 < 0 ) then
              info = -2
           else if( n < 0 ) then
              info = -3
           else if( incx1 < 1 ) then
              info = -5
           else if( incx2 < 1 ) then
              info = -7
           else if( ldq1 < max( 1, m1 ) ) then
              info = -9
           else if( ldq2 < max( 1, m2 ) ) then
              info = -11
           else if( lwork < n ) then
              info = -13
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'ZUNBDB6', -info )
              return
           end if
           ! first, project x onto the orthogonal complement of q's column
           ! space
           scl1 = realzero
           ssq1 = realone
           call stdlib_${ci}$lassq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_${ci}$lassq( m2, x2, incx2, scl2, ssq2 )
           normsq1 = scl1**2*ssq1 + scl2**2*ssq2
           if( m1 == 0 ) then
              do i = 1, n
                 work(i) = czero
              end do
           else
              call stdlib_${ci}$gemv( 'C', m1, n, cone, q1, ldq1, x1, incx1, czero, work,1 )
           end if
           call stdlib_${ci}$gemv( 'C', m2, n, cone, q2, ldq2, x2, incx2, cone, work, 1 )
           call stdlib_${ci}$gemv( 'N', m1, n, cnegone, q1, ldq1, work, 1, cone, x1,incx1 )
           call stdlib_${ci}$gemv( 'N', m2, n, cnegone, q2, ldq2, work, 1, cone, x2,incx2 )
           scl1 = realzero
           ssq1 = realone
           call stdlib_${ci}$lassq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_${ci}$lassq( m2, x2, incx2, scl2, ssq2 )
           normsq2 = scl1**2*ssq1 + scl2**2*ssq2
           ! if projection is sufficiently large in norm, then stop.
           ! if projection is czero, then stop.
           ! otherwise, project again.
           if( normsq2 >= alphasq*normsq1 ) then
              return
           end if
           if( normsq2 == czero ) then
              return
           end if
           normsq1 = normsq2
           do i = 1, n
              work(i) = czero
           end do
           if( m1 == 0 ) then
              do i = 1, n
                 work(i) = czero
              end do
           else
              call stdlib_${ci}$gemv( 'C', m1, n, cone, q1, ldq1, x1, incx1, czero, work,1 )
           end if
           call stdlib_${ci}$gemv( 'C', m2, n, cone, q2, ldq2, x2, incx2, cone, work, 1 )
           call stdlib_${ci}$gemv( 'N', m1, n, cnegone, q1, ldq1, work, 1, cone, x1,incx1 )
           call stdlib_${ci}$gemv( 'N', m2, n, cnegone, q2, ldq2, work, 1, cone, x2,incx2 )
           scl1 = realzero
           ssq1 = realone
           call stdlib_${ci}$lassq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_${ci}$lassq( m1, x1, incx1, scl1, ssq1 )
           normsq2 = scl1**2*ssq1 + scl2**2*ssq2
           ! if second projection is sufficiently large in norm, then do
           ! nothing more. alternatively, if it shrunk significantly, then
           ! truncate it to czero.
           if( normsq2 < alphasq*normsq1 ) then
              do i = 1, m1
                 x1(i) = czero
              end do
              do i = 1, m2
                 x2(i) = czero
              end do
           end if
           return
     end subroutine stdlib_${ci}$unbdb6

#:endif
#:endfor









     pure subroutine stdlib_sorbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, lwork, info )
     !! SORBDB5 orthogonalizes the column vector
     !! X = [ X1 ]
     !! [ X2 ]
     !! with respect to the columns of
     !! Q = [ Q1 ] .
     !! [ Q2 ]
     !! The columns of Q must be orthonormal.
     !! If the projection is zero according to Kahan's "twice is enough"
     !! criterion, then some other vector from the orthogonal complement
     !! is returned. This vector is chosen in an arbitrary but deterministic
     !! way.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           real(sp), intent(out) :: work(*)
           real(sp), intent(inout) :: x1(*), x2(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: childinfo, i, j
           ! Intrinsic Function 
           ! Executable Statements 
           ! test input arguments
           info = 0
           if( m1 < 0 ) then
              info = -1
           else if( m2 < 0 ) then
              info = -2
           else if( n < 0 ) then
              info = -3
           else if( incx1 < 1 ) then
              info = -5
           else if( incx2 < 1 ) then
              info = -7
           else if( ldq1 < max( 1, m1 ) ) then
              info = -9
           else if( ldq2 < max( 1, m2 ) ) then
              info = -11
           else if( lwork < n ) then
              info = -13
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'SORBDB5', -info )
              return
           end if
           ! project x onto the orthogonal complement of q
           call stdlib_sorbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2, ldq2,work, lwork, &
                     childinfo )
           ! if the projection is nonzero, then return
           if( stdlib_snrm2(m1,x1,incx1) /= zero.or. stdlib_snrm2(m2,x2,incx2) /= zero ) &
                     then
              return
           end if
           ! project each standard basis vector e_1,...,e_m1 in turn, stopping
           ! when a nonzero projection is found
           do i = 1, m1
              do j = 1, m1
                 x1(j) = zero
              end do
              x1(i) = one
              do j = 1, m2
                 x2(j) = zero
              end do
              call stdlib_sorbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                        lwork, childinfo )
              if( stdlib_snrm2(m1,x1,incx1) /= zero.or. stdlib_snrm2(m2,x2,incx2) /= zero ) &
                        then
                 return
              end if
           end do
           ! project each standard basis vector e_(m1+1),...,e_(m1+m2) in turn,
           ! stopping when a nonzero projection is found
           do i = 1, m2
              do j = 1, m1
                 x1(j) = zero
              end do
              do j = 1, m2
                 x2(j) = zero
              end do
              x2(i) = one
              call stdlib_sorbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                        lwork, childinfo )
              if( stdlib_snrm2(m1,x1,incx1) /= zero.or. stdlib_snrm2(m2,x2,incx2) /= zero ) &
                        then
                 return
              end if
           end do
           return
     end subroutine stdlib_sorbdb5

     pure subroutine stdlib_dorbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, lwork, info )
     !! DORBDB5 orthogonalizes the column vector
     !! X = [ X1 ]
     !! [ X2 ]
     !! with respect to the columns of
     !! Q = [ Q1 ] .
     !! [ Q2 ]
     !! The columns of Q must be orthonormal.
     !! If the projection is zero according to Kahan's "twice is enough"
     !! criterion, then some other vector from the orthogonal complement
     !! is returned. This vector is chosen in an arbitrary but deterministic
     !! way.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           real(dp), intent(out) :: work(*)
           real(dp), intent(inout) :: x1(*), x2(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: childinfo, i, j
           ! Intrinsic Function 
           ! Executable Statements 
           ! test input arguments
           info = 0
           if( m1 < 0 ) then
              info = -1
           else if( m2 < 0 ) then
              info = -2
           else if( n < 0 ) then
              info = -3
           else if( incx1 < 1 ) then
              info = -5
           else if( incx2 < 1 ) then
              info = -7
           else if( ldq1 < max( 1, m1 ) ) then
              info = -9
           else if( ldq2 < max( 1, m2 ) ) then
              info = -11
           else if( lwork < n ) then
              info = -13
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'DORBDB5', -info )
              return
           end if
           ! project x onto the orthogonal complement of q
           call stdlib_dorbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2, ldq2,work, lwork, &
                     childinfo )
           ! if the projection is nonzero, then return
           if( stdlib_dnrm2(m1,x1,incx1) /= zero.or. stdlib_dnrm2(m2,x2,incx2) /= zero ) &
                     then
              return
           end if
           ! project each standard basis vector e_1,...,e_m1 in turn, stopping
           ! when a nonzero projection is found
           do i = 1, m1
              do j = 1, m1
                 x1(j) = zero
              end do
              x1(i) = one
              do j = 1, m2
                 x2(j) = zero
              end do
              call stdlib_dorbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                        lwork, childinfo )
              if( stdlib_dnrm2(m1,x1,incx1) /= zero.or. stdlib_dnrm2(m2,x2,incx2) /= zero ) &
                        then
                 return
              end if
           end do
           ! project each standard basis vector e_(m1+1),...,e_(m1+m2) in turn,
           ! stopping when a nonzero projection is found
           do i = 1, m2
              do j = 1, m1
                 x1(j) = zero
              end do
              do j = 1, m2
                 x2(j) = zero
              end do
              x2(i) = one
              call stdlib_dorbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                        lwork, childinfo )
              if( stdlib_dnrm2(m1,x1,incx1) /= zero.or. stdlib_dnrm2(m2,x2,incx2) /= zero ) &
                        then
                 return
              end if
           end do
           return
     end subroutine stdlib_dorbdb5

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$orbdb5( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, lwork, info )
     !! DORBDB5: orthogonalizes the column vector
     !! X = [ X1 ]
     !! [ X2 ]
     !! with respect to the columns of
     !! Q = [ Q1 ] .
     !! [ Q2 ]
     !! The columns of Q must be orthonormal.
     !! If the projection is zero according to Kahan's "twice is enough"
     !! criterion, then some other vector from the orthogonal complement
     !! is returned. This vector is chosen in an arbitrary but deterministic
     !! way.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           real(${rk}$), intent(out) :: work(*)
           real(${rk}$), intent(inout) :: x1(*), x2(*)
        ! =====================================================================
           
           ! Local Scalars 
           integer(ilp) :: childinfo, i, j
           ! Intrinsic Function 
           ! Executable Statements 
           ! test input arguments
           info = 0
           if( m1 < 0 ) then
              info = -1
           else if( m2 < 0 ) then
              info = -2
           else if( n < 0 ) then
              info = -3
           else if( incx1 < 1 ) then
              info = -5
           else if( incx2 < 1 ) then
              info = -7
           else if( ldq1 < max( 1, m1 ) ) then
              info = -9
           else if( ldq2 < max( 1, m2 ) ) then
              info = -11
           else if( lwork < n ) then
              info = -13
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'DORBDB5', -info )
              return
           end if
           ! project x onto the orthogonal complement of q
           call stdlib_${ri}$orbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2, ldq2,work, lwork, &
                     childinfo )
           ! if the projection is nonzero, then return
           if( stdlib_${ri}$nrm2(m1,x1,incx1) /= zero.or. stdlib_${ri}$nrm2(m2,x2,incx2) /= zero ) &
                     then
              return
           end if
           ! project each standard basis vector e_1,...,e_m1 in turn, stopping
           ! when a nonzero projection is found
           do i = 1, m1
              do j = 1, m1
                 x1(j) = zero
              end do
              x1(i) = one
              do j = 1, m2
                 x2(j) = zero
              end do
              call stdlib_${ri}$orbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                        lwork, childinfo )
              if( stdlib_${ri}$nrm2(m1,x1,incx1) /= zero.or. stdlib_${ri}$nrm2(m2,x2,incx2) /= zero ) &
                        then
                 return
              end if
           end do
           ! project each standard basis vector e_(m1+1),...,e_(m1+m2) in turn,
           ! stopping when a nonzero projection is found
           do i = 1, m2
              do j = 1, m1
                 x1(j) = zero
              end do
              do j = 1, m2
                 x2(j) = zero
              end do
              x2(i) = one
              call stdlib_${ri}$orbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, &
                        lwork, childinfo )
              if( stdlib_${ri}$nrm2(m1,x1,incx1) /= zero.or. stdlib_${ri}$nrm2(m2,x2,incx2) /= zero ) &
                        then
                 return
              end if
           end do
           return
     end subroutine stdlib_${ri}$orbdb5

#:endif
#:endfor













     pure subroutine stdlib_sorbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, lwork, info )
     !! SORBDB6 orthogonalizes the column vector
     !! X = [ X1 ]
     !! [ X2 ]
     !! with respect to the columns of
     !! Q = [ Q1 ] .
     !! [ Q2 ]
     !! The columns of Q must be orthonormal.
     !! If the projection is zero according to Kahan's "twice is enough"
     !! criterion, then the zero vector is returned.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           real(sp), intent(out) :: work(*)
           real(sp), intent(inout) :: x1(*), x2(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: alphasq = 0.01_sp
           real(sp), parameter :: realone = 1.0_sp
           real(sp), parameter :: realzero = 0.0_sp
           
           
           ! Local Scalars 
           integer(ilp) :: i
           real(sp) :: normsq1, normsq2, scl1, scl2, ssq1, ssq2
           ! Intrinsic Function 
           ! Executable Statements 
           ! test input arguments
           info = 0
           if( m1 < 0 ) then
              info = -1
           else if( m2 < 0 ) then
              info = -2
           else if( n < 0 ) then
              info = -3
           else if( incx1 < 1 ) then
              info = -5
           else if( incx2 < 1 ) then
              info = -7
           else if( ldq1 < max( 1, m1 ) ) then
              info = -9
           else if( ldq2 < max( 1, m2 ) ) then
              info = -11
           else if( lwork < n ) then
              info = -13
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'SORBDB6', -info )
              return
           end if
           ! first, project x onto the orthogonal complement of q's column
           ! space
           scl1 = realzero
           ssq1 = realone
           call stdlib_slassq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_slassq( m2, x2, incx2, scl2, ssq2 )
           normsq1 = scl1**2*ssq1 + scl2**2*ssq2
           if( m1 == 0 ) then
              do i = 1, n
                 work(i) = zero
              end do
           else
              call stdlib_sgemv( 'C', m1, n, one, q1, ldq1, x1, incx1, zero, work,1 )
           end if
           call stdlib_sgemv( 'C', m2, n, one, q2, ldq2, x2, incx2, one, work, 1 )
           call stdlib_sgemv( 'N', m1, n, negone, q1, ldq1, work, 1, one, x1,incx1 )
           call stdlib_sgemv( 'N', m2, n, negone, q2, ldq2, work, 1, one, x2,incx2 )
           scl1 = realzero
           ssq1 = realone
           call stdlib_slassq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_slassq( m2, x2, incx2, scl2, ssq2 )
           normsq2 = scl1**2*ssq1 + scl2**2*ssq2
           ! if projection is sufficiently large in norm, then stop.
           ! if projection is zero, then stop.
           ! otherwise, project again.
           if( normsq2 >= alphasq*normsq1 ) then
              return
           end if
           if( normsq2 == zero ) then
              return
           end if
           normsq1 = normsq2
           do i = 1, n
              work(i) = zero
           end do
           if( m1 == 0 ) then
              do i = 1, n
                 work(i) = zero
              end do
           else
              call stdlib_sgemv( 'C', m1, n, one, q1, ldq1, x1, incx1, zero, work,1 )
           end if
           call stdlib_sgemv( 'C', m2, n, one, q2, ldq2, x2, incx2, one, work, 1 )
           call stdlib_sgemv( 'N', m1, n, negone, q1, ldq1, work, 1, one, x1,incx1 )
           call stdlib_sgemv( 'N', m2, n, negone, q2, ldq2, work, 1, one, x2,incx2 )
           scl1 = realzero
           ssq1 = realone
           call stdlib_slassq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_slassq( m1, x1, incx1, scl1, ssq1 )
           normsq2 = scl1**2*ssq1 + scl2**2*ssq2
           ! if second projection is sufficiently large in norm, then do
           ! nothing more. alternatively, if it shrunk significantly, then
           ! truncate it to zero.
           if( normsq2 < alphasq*normsq1 ) then
              do i = 1, m1
                 x1(i) = zero
              end do
              do i = 1, m2
                 x2(i) = zero
              end do
           end if
           return
     end subroutine stdlib_sorbdb6

     pure subroutine stdlib_dorbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, lwork, info )
     !! DORBDB6 orthogonalizes the column vector
     !! X = [ X1 ]
     !! [ X2 ]
     !! with respect to the columns of
     !! Q = [ Q1 ] .
     !! [ Q2 ]
     !! The columns of Q must be orthonormal.
     !! If the projection is zero according to Kahan's "twice is enough"
     !! criterion, then the zero vector is returned.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           real(dp), intent(out) :: work(*)
           real(dp), intent(inout) :: x1(*), x2(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: alphasq = 0.01_dp
           real(dp), parameter :: realone = 1.0_dp
           real(dp), parameter :: realzero = 0.0_dp
           
           
           ! Local Scalars 
           integer(ilp) :: i
           real(dp) :: normsq1, normsq2, scl1, scl2, ssq1, ssq2
           ! Intrinsic Function 
           ! Executable Statements 
           ! test input arguments
           info = 0
           if( m1 < 0 ) then
              info = -1
           else if( m2 < 0 ) then
              info = -2
           else if( n < 0 ) then
              info = -3
           else if( incx1 < 1 ) then
              info = -5
           else if( incx2 < 1 ) then
              info = -7
           else if( ldq1 < max( 1, m1 ) ) then
              info = -9
           else if( ldq2 < max( 1, m2 ) ) then
              info = -11
           else if( lwork < n ) then
              info = -13
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'DORBDB6', -info )
              return
           end if
           ! first, project x onto the orthogonal complement of q's column
           ! space
           scl1 = realzero
           ssq1 = realone
           call stdlib_dlassq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_dlassq( m2, x2, incx2, scl2, ssq2 )
           normsq1 = scl1**2*ssq1 + scl2**2*ssq2
           if( m1 == 0 ) then
              do i = 1, n
                 work(i) = zero
              end do
           else
              call stdlib_dgemv( 'C', m1, n, one, q1, ldq1, x1, incx1, zero, work,1 )
           end if
           call stdlib_dgemv( 'C', m2, n, one, q2, ldq2, x2, incx2, one, work, 1 )
           call stdlib_dgemv( 'N', m1, n, negone, q1, ldq1, work, 1, one, x1,incx1 )
           call stdlib_dgemv( 'N', m2, n, negone, q2, ldq2, work, 1, one, x2,incx2 )
           scl1 = realzero
           ssq1 = realone
           call stdlib_dlassq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_dlassq( m2, x2, incx2, scl2, ssq2 )
           normsq2 = scl1**2*ssq1 + scl2**2*ssq2
           ! if projection is sufficiently large in norm, then stop.
           ! if projection is zero, then stop.
           ! otherwise, project again.
           if( normsq2 >= alphasq*normsq1 ) then
              return
           end if
           if( normsq2 == zero ) then
              return
           end if
           normsq1 = normsq2
           do i = 1, n
              work(i) = zero
           end do
           if( m1 == 0 ) then
              do i = 1, n
                 work(i) = zero
              end do
           else
              call stdlib_dgemv( 'C', m1, n, one, q1, ldq1, x1, incx1, zero, work,1 )
           end if
           call stdlib_dgemv( 'C', m2, n, one, q2, ldq2, x2, incx2, one, work, 1 )
           call stdlib_dgemv( 'N', m1, n, negone, q1, ldq1, work, 1, one, x1,incx1 )
           call stdlib_dgemv( 'N', m2, n, negone, q2, ldq2, work, 1, one, x2,incx2 )
           scl1 = realzero
           ssq1 = realone
           call stdlib_dlassq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_dlassq( m1, x1, incx1, scl1, ssq1 )
           normsq2 = scl1**2*ssq1 + scl2**2*ssq2
           ! if second projection is sufficiently large in norm, then do
           ! nothing more. alternatively, if it shrunk significantly, then
           ! truncate it to zero.
           if( normsq2 < alphasq*normsq1 ) then
              do i = 1, m1
                 x1(i) = zero
              end do
              do i = 1, m2
                 x2(i) = zero
              end do
           end if
           return
     end subroutine stdlib_dorbdb6

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$orbdb6( m1, m2, n, x1, incx1, x2, incx2, q1, ldq1, q2,ldq2, work, lwork, info )
     !! DORBDB6: orthogonalizes the column vector
     !! X = [ X1 ]
     !! [ X2 ]
     !! with respect to the columns of
     !! Q = [ Q1 ] .
     !! [ Q2 ]
     !! The columns of Q must be orthonormal.
     !! If the projection is zero according to Kahan's "twice is enough"
     !! criterion, then the zero vector is returned.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: incx1, incx2, ldq1, ldq2, lwork, m1, m2, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(in) :: q1(ldq1,*), q2(ldq2,*)
           real(${rk}$), intent(out) :: work(*)
           real(${rk}$), intent(inout) :: x1(*), x2(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: alphasq = 0.01_${rk}$
           real(${rk}$), parameter :: realone = 1.0_${rk}$
           real(${rk}$), parameter :: realzero = 0.0_${rk}$
           
           
           ! Local Scalars 
           integer(ilp) :: i
           real(${rk}$) :: normsq1, normsq2, scl1, scl2, ssq1, ssq2
           ! Intrinsic Function 
           ! Executable Statements 
           ! test input arguments
           info = 0
           if( m1 < 0 ) then
              info = -1
           else if( m2 < 0 ) then
              info = -2
           else if( n < 0 ) then
              info = -3
           else if( incx1 < 1 ) then
              info = -5
           else if( incx2 < 1 ) then
              info = -7
           else if( ldq1 < max( 1, m1 ) ) then
              info = -9
           else if( ldq2 < max( 1, m2 ) ) then
              info = -11
           else if( lwork < n ) then
              info = -13
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'DORBDB6', -info )
              return
           end if
           ! first, project x onto the orthogonal complement of q's column
           ! space
           scl1 = realzero
           ssq1 = realone
           call stdlib_${ri}$lassq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_${ri}$lassq( m2, x2, incx2, scl2, ssq2 )
           normsq1 = scl1**2*ssq1 + scl2**2*ssq2
           if( m1 == 0 ) then
              do i = 1, n
                 work(i) = zero
              end do
           else
              call stdlib_${ri}$gemv( 'C', m1, n, one, q1, ldq1, x1, incx1, zero, work,1 )
           end if
           call stdlib_${ri}$gemv( 'C', m2, n, one, q2, ldq2, x2, incx2, one, work, 1 )
           call stdlib_${ri}$gemv( 'N', m1, n, negone, q1, ldq1, work, 1, one, x1,incx1 )
           call stdlib_${ri}$gemv( 'N', m2, n, negone, q2, ldq2, work, 1, one, x2,incx2 )
           scl1 = realzero
           ssq1 = realone
           call stdlib_${ri}$lassq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_${ri}$lassq( m2, x2, incx2, scl2, ssq2 )
           normsq2 = scl1**2*ssq1 + scl2**2*ssq2
           ! if projection is sufficiently large in norm, then stop.
           ! if projection is zero, then stop.
           ! otherwise, project again.
           if( normsq2 >= alphasq*normsq1 ) then
              return
           end if
           if( normsq2 == zero ) then
              return
           end if
           normsq1 = normsq2
           do i = 1, n
              work(i) = zero
           end do
           if( m1 == 0 ) then
              do i = 1, n
                 work(i) = zero
              end do
           else
              call stdlib_${ri}$gemv( 'C', m1, n, one, q1, ldq1, x1, incx1, zero, work,1 )
           end if
           call stdlib_${ri}$gemv( 'C', m2, n, one, q2, ldq2, x2, incx2, one, work, 1 )
           call stdlib_${ri}$gemv( 'N', m1, n, negone, q1, ldq1, work, 1, one, x1,incx1 )
           call stdlib_${ri}$gemv( 'N', m2, n, negone, q2, ldq2, work, 1, one, x2,incx2 )
           scl1 = realzero
           ssq1 = realone
           call stdlib_${ri}$lassq( m1, x1, incx1, scl1, ssq1 )
           scl2 = realzero
           ssq2 = realone
           call stdlib_${ri}$lassq( m1, x1, incx1, scl1, ssq1 )
           normsq2 = scl1**2*ssq1 + scl2**2*ssq2
           ! if second projection is sufficiently large in norm, then do
           ! nothing more. alternatively, if it shrunk significantly, then
           ! truncate it to zero.
           if( normsq2 < alphasq*normsq1 ) then
              do i = 1, m1
                 x1(i) = zero
              end do
              do i = 1, m2
                 x2(i) = zero
              end do
           end if
           return
     end subroutine stdlib_${ri}$orbdb6

#:endif
#:endfor





     pure subroutine stdlib_slapmr( forwrd, m, n, x, ldx, k )
     !! SLAPMR rearranges the rows of the M by N matrix X as specified
     !! by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
     !! If FORWRD = .TRUE.,  forward permutation:
     !! X(K(I),*) is moved X(I,*) for I = 1,2,...,M.
     !! If FORWRD = .FALSE., backward permutation:
     !! X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: forwrd
           integer(ilp), intent(in) :: ldx, m, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: k(*)
           real(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, in, j, jj
           real(sp) :: temp
           ! Executable Statements 
           if( m<=1 )return
           do i = 1, m
              k( i ) = -k( i )
           end do
           if( forwrd ) then
              ! forward permutation
              do i = 1, m
                 if( k( i )>0 )go to 40
                 j = i
                 k( j ) = -k( j )
                 in = k( j )
                 20 continue
                 if( k( in )>0 )go to 40
                 do jj = 1, n
                    temp = x( j, jj )
                    x( j, jj ) = x( in, jj )
                    x( in, jj ) = temp
                 end do
                 k( in ) = -k( in )
                 j = in
                 in = k( in )
                 go to 20
                 40 continue
              end do
           else
              ! backward permutation
              do i = 1, m
                 if( k( i )>0 )go to 80
                 k( i ) = -k( i )
                 j = k( i )
                 60 continue
                 if( j==i )go to 80
                 do jj = 1, n
                    temp = x( i, jj )
                    x( i, jj ) = x( j, jj )
                    x( j, jj ) = temp
                 end do
                 k( j ) = -k( j )
                 j = k( j )
                 go to 60
                 80 continue
              end do
           end if
           return
     end subroutine stdlib_slapmr

     pure subroutine stdlib_dlapmr( forwrd, m, n, x, ldx, k )
     !! DLAPMR rearranges the rows of the M by N matrix X as specified
     !! by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
     !! If FORWRD = .TRUE.,  forward permutation:
     !! X(K(I),*) is moved X(I,*) for I = 1,2,...,M.
     !! If FORWRD = .FALSE., backward permutation:
     !! X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: forwrd
           integer(ilp), intent(in) :: ldx, m, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: k(*)
           real(dp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, in, j, jj
           real(dp) :: temp
           ! Executable Statements 
           if( m<=1 )return
           do i = 1, m
              k( i ) = -k( i )
           end do
           if( forwrd ) then
              ! forward permutation
              do i = 1, m
                 if( k( i )>0 )go to 40
                 j = i
                 k( j ) = -k( j )
                 in = k( j )
                 20 continue
                 if( k( in )>0 )go to 40
                 do jj = 1, n
                    temp = x( j, jj )
                    x( j, jj ) = x( in, jj )
                    x( in, jj ) = temp
                 end do
                 k( in ) = -k( in )
                 j = in
                 in = k( in )
                 go to 20
                 40 continue
              end do
           else
              ! backward permutation
              do i = 1, m
                 if( k( i )>0 )go to 80
                 k( i ) = -k( i )
                 j = k( i )
                 60 continue
                 if( j==i )go to 80
                 do jj = 1, n
                    temp = x( i, jj )
                    x( i, jj ) = x( j, jj )
                    x( j, jj ) = temp
                 end do
                 k( j ) = -k( j )
                 j = k( j )
                 go to 60
                 80 continue
              end do
           end if
           return
     end subroutine stdlib_dlapmr

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$lapmr( forwrd, m, n, x, ldx, k )
     !! DLAPMR: rearranges the rows of the M by N matrix X as specified
     !! by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
     !! If FORWRD = .TRUE.,  forward permutation:
     !! X(K(I),*) is moved X(I,*) for I = 1,2,...,M.
     !! If FORWRD = .FALSE., backward permutation:
     !! X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: forwrd
           integer(ilp), intent(in) :: ldx, m, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: k(*)
           real(${rk}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, in, j, jj
           real(${rk}$) :: temp
           ! Executable Statements 
           if( m<=1 )return
           do i = 1, m
              k( i ) = -k( i )
           end do
           if( forwrd ) then
              ! forward permutation
              do i = 1, m
                 if( k( i )>0 )go to 40
                 j = i
                 k( j ) = -k( j )
                 in = k( j )
                 20 continue
                 if( k( in )>0 )go to 40
                 do jj = 1, n
                    temp = x( j, jj )
                    x( j, jj ) = x( in, jj )
                    x( in, jj ) = temp
                 end do
                 k( in ) = -k( in )
                 j = in
                 in = k( in )
                 go to 20
                 40 continue
              end do
           else
              ! backward permutation
              do i = 1, m
                 if( k( i )>0 )go to 80
                 k( i ) = -k( i )
                 j = k( i )
                 60 continue
                 if( j==i )go to 80
                 do jj = 1, n
                    temp = x( i, jj )
                    x( i, jj ) = x( j, jj )
                    x( j, jj ) = temp
                 end do
                 k( j ) = -k( j )
                 j = k( j )
                 go to 60
                 80 continue
              end do
           end if
           return
     end subroutine stdlib_${ri}$lapmr

#:endif
#:endfor

     pure subroutine stdlib_clapmr( forwrd, m, n, x, ldx, k )
     !! CLAPMR rearranges the rows of the M by N matrix X as specified
     !! by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
     !! If FORWRD = .TRUE.,  forward permutation:
     !! X(K(I),*) is moved X(I,*) for I = 1,2,...,M.
     !! If FORWRD = .FALSE., backward permutation:
     !! X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: forwrd
           integer(ilp), intent(in) :: ldx, m, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: k(*)
           complex(sp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, in, j, jj
           complex(sp) :: temp
           ! Executable Statements 
           if( m<=1 )return
           do i = 1, m
              k( i ) = -k( i )
           end do
           if( forwrd ) then
              ! forward permutation
              do i = 1, m
                 if( k( i )>0 )go to 40
                 j = i
                 k( j ) = -k( j )
                 in = k( j )
                 20 continue
                 if( k( in )>0 )go to 40
                 do jj = 1, n
                    temp = x( j, jj )
                    x( j, jj ) = x( in, jj )
                    x( in, jj ) = temp
                 end do
                 k( in ) = -k( in )
                 j = in
                 in = k( in )
                 go to 20
                 40 continue
              end do
           else
              ! backward permutation
              do i = 1, m
                 if( k( i )>0 )go to 80
                 k( i ) = -k( i )
                 j = k( i )
                 60 continue
                 if( j==i )go to 80
                 do jj = 1, n
                    temp = x( i, jj )
                    x( i, jj ) = x( j, jj )
                    x( j, jj ) = temp
                 end do
                 k( j ) = -k( j )
                 j = k( j )
                 go to 60
                 80 continue
              end do
           end if
           return
     end subroutine stdlib_clapmr

     pure subroutine stdlib_zlapmr( forwrd, m, n, x, ldx, k )
     !! ZLAPMR rearranges the rows of the M by N matrix X as specified
     !! by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
     !! If FORWRD = .TRUE.,  forward permutation:
     !! X(K(I),*) is moved X(I,*) for I = 1,2,...,M.
     !! If FORWRD = .FALSE., backward permutation:
     !! X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: forwrd
           integer(ilp), intent(in) :: ldx, m, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: k(*)
           complex(dp), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, in, j, jj
           complex(dp) :: temp
           ! Executable Statements 
           if( m<=1 )return
           do i = 1, m
              k( i ) = -k( i )
           end do
           if( forwrd ) then
              ! forward permutation
              do i = 1, m
                 if( k( i )>0 )go to 40
                 j = i
                 k( j ) = -k( j )
                 in = k( j )
                 20 continue
                 if( k( in )>0 )go to 40
                 do jj = 1, n
                    temp = x( j, jj )
                    x( j, jj ) = x( in, jj )
                    x( in, jj ) = temp
                 end do
                 k( in ) = -k( in )
                 j = in
                 in = k( in )
                 go to 20
                 40 continue
              end do
           else
              ! backward permutation
              do i = 1, m
                 if( k( i )>0 )go to 80
                 k( i ) = -k( i )
                 j = k( i )
                 60 continue
                 if( j==i )go to 80
                 do jj = 1, n
                    temp = x( i, jj )
                    x( i, jj ) = x( j, jj )
                    x( j, jj ) = temp
                 end do
                 k( j ) = -k( j )
                 j = k( j )
                 go to 60
                 80 continue
              end do
           end if
           return
     end subroutine stdlib_zlapmr

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$lapmr( forwrd, m, n, x, ldx, k )
     !! ZLAPMR: rearranges the rows of the M by N matrix X as specified
     !! by the permutation K(1),K(2),...,K(M) of the integers 1,...,M.
     !! If FORWRD = .TRUE.,  forward permutation:
     !! X(K(I),*) is moved X(I,*) for I = 1,2,...,M.
     !! If FORWRD = .FALSE., backward permutation:
     !! X(I,*) is moved to X(K(I),*) for I = 1,2,...,M.
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: forwrd
           integer(ilp), intent(in) :: ldx, m, n
           ! Array Arguments 
           integer(ilp), intent(inout) :: k(*)
           complex(${ck}$), intent(inout) :: x(ldx,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: i, in, j, jj
           complex(${ck}$) :: temp
           ! Executable Statements 
           if( m<=1 )return
           do i = 1, m
              k( i ) = -k( i )
           end do
           if( forwrd ) then
              ! forward permutation
              do i = 1, m
                 if( k( i )>0 )go to 40
                 j = i
                 k( j ) = -k( j )
                 in = k( j )
                 20 continue
                 if( k( in )>0 )go to 40
                 do jj = 1, n
                    temp = x( j, jj )
                    x( j, jj ) = x( in, jj )
                    x( in, jj ) = temp
                 end do
                 k( in ) = -k( in )
                 j = in
                 in = k( in )
                 go to 20
                 40 continue
              end do
           else
              ! backward permutation
              do i = 1, m
                 if( k( i )>0 )go to 80
                 k( i ) = -k( i )
                 j = k( i )
                 60 continue
                 if( j==i )go to 80
                 do jj = 1, n
                    temp = x( i, jj )
                    x( i, jj ) = x( j, jj )
                    x( j, jj ) = temp
                 end do
                 k( j ) = -k( j )
                 j = k( j )
                 go to 60
                 80 continue
              end do
           end if
           return
     end subroutine stdlib_${ci}$lapmr

#:endif
#:endfor



     pure subroutine stdlib_sbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, u1, &
     ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d, b22e, work, lwork, info )
     !! SBBCSD computes the CS decomposition of an orthogonal matrix in
     !! bidiagonal-block form,
     !! [ B11 | B12 0  0 ]
     !! [  0  |  0 -I  0 ]
     !! X = [----------------]
     !! [ B21 | B22 0  0 ]
     !! [  0  |  0  0  I ]
     !! [  C | -S  0  0 ]
     !! [ U1 |    ] [  0 |  0 -I  0 ] [ V1 |    ]**T
     !! = [---------] [---------------] [---------]   .
     !! [    | U2 ] [  S |  C  0  0 ] [    | V2 ]
     !! [  0 |  0  0  I ]
     !! X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
     !! than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
     !! transposed and/or permuted. This can be done in constant time using
     !! the TRANS and SIGNS options. See SORCSD for details.)
     !! The bidiagonal matrices B11, B12, B21, and B22 are represented
     !! implicitly by angles THETA(1:Q) and PHI(1:Q-1).
     !! The orthogonal matrices U1, U2, V1T, and V2T are input/output.
     !! The input matrices are pre- or post-multiplied by the appropriate
     !! singular vector matrices.
     
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero
           ! Scalar Arguments 
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, lwork, m, p, q
           ! Array Arguments 
           real(sp), intent(out) :: b11d(*), b11e(*), b12d(*), b12e(*), b21d(*), b21e(*), b22d(*),&
                      b22e(*), work(*)
           real(sp), intent(inout) :: phi(*), theta(*)
           real(sp), intent(inout) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*)
        ! ===================================================================
           ! Parameters 
           integer(ilp), parameter :: maxitr = 6
           real(sp), parameter :: hundred = 100.0_sp
           real(sp), parameter :: meighth = -0.125_sp
           real(sp), parameter :: piover2 = 1.57079632679489661923132169163975144210_sp
           
           
           
           
           ! Local Scalars 
           logical(lk) :: colmajor, lquery, restart11, restart12, restart21, restart22, wantu1, &
                     wantu2, wantv1t, wantv2t
           integer(ilp) :: i, imin, imax, iter, iu1cs, iu1sn, iu2cs, iu2sn, iv1tcs, iv1tsn, &
                     iv2tcs, iv2tsn, j, lworkmin, lworkopt, maxit, mini
           real(sp) :: b11bulge, b12bulge, b21bulge, b22bulge, dummy, eps, mu, nu, r, sigma11, &
                     sigma21, temp, thetamax, thetamin, thresh, tol, tolmul, unfl, x1, x2, y1, y2
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test input arguments
           info = 0
           lquery = lwork == -1
           wantu1 = stdlib_lsame( jobu1, 'Y' )
           wantu2 = stdlib_lsame( jobu2, 'Y' )
           wantv1t = stdlib_lsame( jobv1t, 'Y' )
           wantv2t = stdlib_lsame( jobv2t, 'Y' )
           colmajor = .not. stdlib_lsame( trans, 'T' )
           if( m < 0 ) then
              info = -6
           else if( p < 0 .or. p > m ) then
              info = -7
           else if( q < 0 .or. q > m ) then
              info = -8
           else if( q > p .or. q > m-p .or. q > m-q ) then
              info = -8
           else if( wantu1 .and. ldu1 < p ) then
              info = -12
           else if( wantu2 .and. ldu2 < m-p ) then
              info = -14
           else if( wantv1t .and. ldv1t < q ) then
              info = -16
           else if( wantv2t .and. ldv2t < m-q ) then
              info = -18
           end if
           ! quick return if q = 0
           if( info == 0 .and. q == 0 ) then
              lworkmin = 1
              work(1) = lworkmin
              return
           end if
           ! compute workspace
           if( info == 0 ) then
              iu1cs = 1
              iu1sn = iu1cs + q
              iu2cs = iu1sn + q
              iu2sn = iu2cs + q
              iv1tcs = iu2sn + q
              iv1tsn = iv1tcs + q
              iv2tcs = iv1tsn + q
              iv2tsn = iv2tcs + q
              lworkopt = iv2tsn + q - 1
              lworkmin = lworkopt
              work(1) = lworkopt
              if( lwork < lworkmin .and. .not. lquery ) then
                 info = -28
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'SBBCSD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'EPSILON' )
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           tolmul = max( ten, min( hundred, eps**meighth ) )
           tol = tolmul*eps
           thresh = max( tol, maxitr*q*q*unfl )
           ! test for negligible sines or cosines
           do i = 1, q
              if( theta(i) < thresh ) then
                 theta(i) = zero
              else if( theta(i) > piover2-thresh ) then
                 theta(i) = piover2
              end if
           end do
           do i = 1, q-1
              if( phi(i) < thresh ) then
                 phi(i) = zero
              else if( phi(i) > piover2-thresh ) then
                 phi(i) = piover2
              end if
           end do
           ! initial deflation
           imax = q
           do while( imax > 1 )
              if( phi(imax-1) /= zero ) then
                 exit
              end if
              imax = imax - 1
           end do
           imin = imax - 1
           if  ( imin > 1 ) then
              do while( phi(imin-1) /= zero )
                 imin = imin - 1
                 if  ( imin <= 1 ) exit
              end do
           end if
           ! initialize iteration counter
           maxit = maxitr*q*q
           iter = 0
           ! begin main iteration loop
           do while( imax > 1 )
              ! compute the matrix entries
              b11d(imin) = cos( theta(imin) )
              b21d(imin) = -sin( theta(imin) )
              do i = imin, imax - 1
                 b11e(i) = -sin( theta(i) ) * sin( phi(i) )
                 b11d(i+1) = cos( theta(i+1) ) * cos( phi(i) )
                 b12d(i) = sin( theta(i) ) * cos( phi(i) )
                 b12e(i) = cos( theta(i+1) ) * sin( phi(i) )
                 b21e(i) = -cos( theta(i) ) * sin( phi(i) )
                 b21d(i+1) = -sin( theta(i+1) ) * cos( phi(i) )
                 b22d(i) = cos( theta(i) ) * cos( phi(i) )
                 b22e(i) = -sin( theta(i+1) ) * sin( phi(i) )
              end do
              b12d(imax) = sin( theta(imax) )
              b22d(imax) = cos( theta(imax) )
              ! abort if not converging; otherwise, increment iter
              if( iter > maxit ) then
                 info = 0
                 do i = 1, q
                    if( phi(i) /= zero )info = info + 1
                 end do
                 return
              end if
              iter = iter + imax - imin
              ! compute shifts
              thetamax = theta(imin)
              thetamin = theta(imin)
              do i = imin+1, imax
                 if( theta(i) > thetamax )thetamax = theta(i)
                 if( theta(i) < thetamin )thetamin = theta(i)
              end do
              if( thetamax > piover2 - thresh ) then
                 ! zero on diagonals of b11 and b22; induce deflation with a
                 ! zero shift
                 mu = zero
                 nu = one
              else if( thetamin < thresh ) then
                 ! zero on diagonals of b12 and b22; induce deflation with a
                 ! zero shift
                 mu = one
                 nu = zero
              else
                 ! compute shifts for b11 and b21 and use the lesser
                 call stdlib_slas2( b11d(imax-1), b11e(imax-1), b11d(imax), sigma11,dummy )
                           
                 call stdlib_slas2( b21d(imax-1), b21e(imax-1), b21d(imax), sigma21,dummy )
                           
                 if( sigma11 <= sigma21 ) then
                    mu = sigma11
                    nu = sqrt( one - mu**2 )
                    if( mu < thresh ) then
                       mu = zero
                       nu = one
                    end if
                 else
                    nu = sigma21
                    mu = sqrt( 1.0_sp - nu**2 )
                    if( nu < thresh ) then
                       mu = one
                       nu = zero
                    end if
                 end if
              end if
              ! rotate to produce bulges in b11 and b21
              if( mu <= nu ) then
                 call stdlib_slartgs( b11d(imin), b11e(imin), mu,work(iv1tcs+imin-1), work(iv1tsn+&
                           imin-1) )
              else
                 call stdlib_slartgs( b21d(imin), b21e(imin), nu,work(iv1tcs+imin-1), work(iv1tsn+&
                           imin-1) )
              end if
              temp = work(iv1tcs+imin-1)*b11d(imin) +work(iv1tsn+imin-1)*b11e(imin)
              b11e(imin) = work(iv1tcs+imin-1)*b11e(imin) -work(iv1tsn+imin-1)*b11d(imin)
              b11d(imin) = temp
              b11bulge = work(iv1tsn+imin-1)*b11d(imin+1)
              b11d(imin+1) = work(iv1tcs+imin-1)*b11d(imin+1)
              temp = work(iv1tcs+imin-1)*b21d(imin) +work(iv1tsn+imin-1)*b21e(imin)
              b21e(imin) = work(iv1tcs+imin-1)*b21e(imin) -work(iv1tsn+imin-1)*b21d(imin)
              b21d(imin) = temp
              b21bulge = work(iv1tsn+imin-1)*b21d(imin+1)
              b21d(imin+1) = work(iv1tcs+imin-1)*b21d(imin+1)
              ! compute theta(imin)
              theta( imin ) = atan2( sqrt( b21d(imin)**2+b21bulge**2 ),sqrt( b11d(imin)**2+&
                        b11bulge**2 ) )
              ! chase the bulges in b11(imin+1,imin) and b21(imin+1,imin)
              if( b11d(imin)**2+b11bulge**2 > thresh**2 ) then
                 call stdlib_slartgp( b11bulge, b11d(imin), work(iu1sn+imin-1),work(iu1cs+imin-1),&
                            r )
              else if( mu <= nu ) then
                 call stdlib_slartgs( b11e( imin ), b11d( imin + 1 ), mu,work(iu1cs+imin-1), work(&
                           iu1sn+imin-1) )
              else
                 call stdlib_slartgs( b12d( imin ), b12e( imin ), nu,work(iu1cs+imin-1), work(&
                           iu1sn+imin-1) )
              end if
              if( b21d(imin)**2+b21bulge**2 > thresh**2 ) then
                 call stdlib_slartgp( b21bulge, b21d(imin), work(iu2sn+imin-1),work(iu2cs+imin-1),&
                            r )
              else if( nu < mu ) then
                 call stdlib_slartgs( b21e( imin ), b21d( imin + 1 ), nu,work(iu2cs+imin-1), work(&
                           iu2sn+imin-1) )
              else
                 call stdlib_slartgs( b22d(imin), b22e(imin), mu,work(iu2cs+imin-1), work(iu2sn+&
                           imin-1) )
              end if
              work(iu2cs+imin-1) = -work(iu2cs+imin-1)
              work(iu2sn+imin-1) = -work(iu2sn+imin-1)
              temp = work(iu1cs+imin-1)*b11e(imin) +work(iu1sn+imin-1)*b11d(imin+1)
              b11d(imin+1) = work(iu1cs+imin-1)*b11d(imin+1) -work(iu1sn+imin-1)*b11e(imin)
                        
              b11e(imin) = temp
              if( imax > imin+1 ) then
                 b11bulge = work(iu1sn+imin-1)*b11e(imin+1)
                 b11e(imin+1) = work(iu1cs+imin-1)*b11e(imin+1)
              end if
              temp = work(iu1cs+imin-1)*b12d(imin) +work(iu1sn+imin-1)*b12e(imin)
              b12e(imin) = work(iu1cs+imin-1)*b12e(imin) -work(iu1sn+imin-1)*b12d(imin)
              b12d(imin) = temp
              b12bulge = work(iu1sn+imin-1)*b12d(imin+1)
              b12d(imin+1) = work(iu1cs+imin-1)*b12d(imin+1)
              temp = work(iu2cs+imin-1)*b21e(imin) +work(iu2sn+imin-1)*b21d(imin+1)
              b21d(imin+1) = work(iu2cs+imin-1)*b21d(imin+1) -work(iu2sn+imin-1)*b21e(imin)
                        
              b21e(imin) = temp
              if( imax > imin+1 ) then
                 b21bulge = work(iu2sn+imin-1)*b21e(imin+1)
                 b21e(imin+1) = work(iu2cs+imin-1)*b21e(imin+1)
              end if
              temp = work(iu2cs+imin-1)*b22d(imin) +work(iu2sn+imin-1)*b22e(imin)
              b22e(imin) = work(iu2cs+imin-1)*b22e(imin) -work(iu2sn+imin-1)*b22d(imin)
              b22d(imin) = temp
              b22bulge = work(iu2sn+imin-1)*b22d(imin+1)
              b22d(imin+1) = work(iu2cs+imin-1)*b22d(imin+1)
              ! inner loop: chase bulges from b11(imin,imin+2),
              ! b12(imin,imin+1), b21(imin,imin+2), and b22(imin,imin+1) to
              ! bottom-right
              do i = imin+1, imax-1
                 ! compute phi(i-1)
                 x1 = sin(theta(i-1))*b11e(i-1) + cos(theta(i-1))*b21e(i-1)
                 x2 = sin(theta(i-1))*b11bulge + cos(theta(i-1))*b21bulge
                 y1 = sin(theta(i-1))*b12d(i-1) + cos(theta(i-1))*b22d(i-1)
                 y2 = sin(theta(i-1))*b12bulge + cos(theta(i-1))*b22bulge
                 phi(i-1) = atan2( sqrt(x1**2+x2**2), sqrt(y1**2+y2**2) )
                 ! determine if there are bulges to chase or if a new direct
                 ! summand has been reached
                 restart11 = b11e(i-1)**2 + b11bulge**2 <= thresh**2
                 restart21 = b21e(i-1)**2 + b21bulge**2 <= thresh**2
                 restart12 = b12d(i-1)**2 + b12bulge**2 <= thresh**2
                 restart22 = b22d(i-1)**2 + b22bulge**2 <= thresh**2
                 ! if possible, chase bulges from b11(i-1,i+1), b12(i-1,i),
                 ! b21(i-1,i+1), and b22(i-1,i). if necessary, restart bulge-
                 ! chasing by applying the original shift again.
                 if( .not. restart11 .and. .not. restart21 ) then
                    call stdlib_slartgp( x2, x1, work(iv1tsn+i-1), work(iv1tcs+i-1),r )
                 else if( .not. restart11 .and. restart21 ) then
                    call stdlib_slartgp( b11bulge, b11e(i-1), work(iv1tsn+i-1),work(iv1tcs+i-1), &
                              r )
                 else if( restart11 .and. .not. restart21 ) then
                    call stdlib_slartgp( b21bulge, b21e(i-1), work(iv1tsn+i-1),work(iv1tcs+i-1), &
                              r )
                 else if( mu <= nu ) then
                    call stdlib_slartgs( b11d(i), b11e(i), mu, work(iv1tcs+i-1),work(iv1tsn+i-1) )
                              
                 else
                    call stdlib_slartgs( b21d(i), b21e(i), nu, work(iv1tcs+i-1),work(iv1tsn+i-1) )
                              
                 end if
                 work(iv1tcs+i-1) = -work(iv1tcs+i-1)
                 work(iv1tsn+i-1) = -work(iv1tsn+i-1)
                 if( .not. restart12 .and. .not. restart22 ) then
                    call stdlib_slartgp( y2, y1, work(iv2tsn+i-1-1),work(iv2tcs+i-1-1), r )
                              
                 else if( .not. restart12 .and. restart22 ) then
                    call stdlib_slartgp( b12bulge, b12d(i-1), work(iv2tsn+i-1-1),work(iv2tcs+i-1-&
                              1), r )
                 else if( restart12 .and. .not. restart22 ) then
                    call stdlib_slartgp( b22bulge, b22d(i-1), work(iv2tsn+i-1-1),work(iv2tcs+i-1-&
                              1), r )
                 else if( nu < mu ) then
                    call stdlib_slartgs( b12e(i-1), b12d(i), nu, work(iv2tcs+i-1-1),work(iv2tsn+i-&
                              1-1) )
                 else
                    call stdlib_slartgs( b22e(i-1), b22d(i), mu, work(iv2tcs+i-1-1),work(iv2tsn+i-&
                              1-1) )
                 end if
                 temp = work(iv1tcs+i-1)*b11d(i) + work(iv1tsn+i-1)*b11e(i)
                 b11e(i) = work(iv1tcs+i-1)*b11e(i) -work(iv1tsn+i-1)*b11d(i)
                 b11d(i) = temp
                 b11bulge = work(iv1tsn+i-1)*b11d(i+1)
                 b11d(i+1) = work(iv1tcs+i-1)*b11d(i+1)
                 temp = work(iv1tcs+i-1)*b21d(i) + work(iv1tsn+i-1)*b21e(i)
                 b21e(i) = work(iv1tcs+i-1)*b21e(i) -work(iv1tsn+i-1)*b21d(i)
                 b21d(i) = temp
                 b21bulge = work(iv1tsn+i-1)*b21d(i+1)
                 b21d(i+1) = work(iv1tcs+i-1)*b21d(i+1)
                 temp = work(iv2tcs+i-1-1)*b12e(i-1) +work(iv2tsn+i-1-1)*b12d(i)
                 b12d(i) = work(iv2tcs+i-1-1)*b12d(i) -work(iv2tsn+i-1-1)*b12e(i-1)
                 b12e(i-1) = temp
                 b12bulge = work(iv2tsn+i-1-1)*b12e(i)
                 b12e(i) = work(iv2tcs+i-1-1)*b12e(i)
                 temp = work(iv2tcs+i-1-1)*b22e(i-1) +work(iv2tsn+i-1-1)*b22d(i)
                 b22d(i) = work(iv2tcs+i-1-1)*b22d(i) -work(iv2tsn+i-1-1)*b22e(i-1)
                 b22e(i-1) = temp
                 b22bulge = work(iv2tsn+i-1-1)*b22e(i)
                 b22e(i) = work(iv2tcs+i-1-1)*b22e(i)
                 ! compute theta(i)
                 x1 = cos(phi(i-1))*b11d(i) + sin(phi(i-1))*b12e(i-1)
                 x2 = cos(phi(i-1))*b11bulge + sin(phi(i-1))*b12bulge
                 y1 = cos(phi(i-1))*b21d(i) + sin(phi(i-1))*b22e(i-1)
                 y2 = cos(phi(i-1))*b21bulge + sin(phi(i-1))*b22bulge
                 theta(i) = atan2( sqrt(y1**2+y2**2), sqrt(x1**2+x2**2) )
                 ! determine if there are bulges to chase or if a new direct
                 ! summand has been reached
                 restart11 =   b11d(i)**2 + b11bulge**2 <= thresh**2
                 restart12 = b12e(i-1)**2 + b12bulge**2 <= thresh**2
                 restart21 =   b21d(i)**2 + b21bulge**2 <= thresh**2
                 restart22 = b22e(i-1)**2 + b22bulge**2 <= thresh**2
                 ! if possible, chase bulges from b11(i+1,i), b12(i+1,i-1),
                 ! b21(i+1,i), and b22(i+1,i-1). if necessary, restart bulge-
                 ! chasing by applying the original shift again.
                 if( .not. restart11 .and. .not. restart12 ) then
                    call stdlib_slartgp( x2, x1, work(iu1sn+i-1), work(iu1cs+i-1),r )
                 else if( .not. restart11 .and. restart12 ) then
                    call stdlib_slartgp( b11bulge, b11d(i), work(iu1sn+i-1),work(iu1cs+i-1), r )
                              
                 else if( restart11 .and. .not. restart12 ) then
                    call stdlib_slartgp( b12bulge, b12e(i-1), work(iu1sn+i-1),work(iu1cs+i-1), r )
                              
                 else if( mu <= nu ) then
                    call stdlib_slartgs( b11e(i), b11d(i+1), mu, work(iu1cs+i-1),work(iu1sn+i-1) )
                              
                 else
                    call stdlib_slartgs( b12d(i), b12e(i), nu, work(iu1cs+i-1),work(iu1sn+i-1) )
                              
                 end if
                 if( .not. restart21 .and. .not. restart22 ) then
                    call stdlib_slartgp( y2, y1, work(iu2sn+i-1), work(iu2cs+i-1),r )
                 else if( .not. restart21 .and. restart22 ) then
                    call stdlib_slartgp( b21bulge, b21d(i), work(iu2sn+i-1),work(iu2cs+i-1), r )
                              
                 else if( restart21 .and. .not. restart22 ) then
                    call stdlib_slartgp( b22bulge, b22e(i-1), work(iu2sn+i-1),work(iu2cs+i-1), r )
                              
                 else if( nu < mu ) then
                    call stdlib_slartgs( b21e(i), b21e(i+1), nu, work(iu2cs+i-1),work(iu2sn+i-1) )
                              
                 else
                    call stdlib_slartgs( b22d(i), b22e(i), mu, work(iu2cs+i-1),work(iu2sn+i-1) )
                              
                 end if
                 work(iu2cs+i-1) = -work(iu2cs+i-1)
                 work(iu2sn+i-1) = -work(iu2sn+i-1)
                 temp = work(iu1cs+i-1)*b11e(i) + work(iu1sn+i-1)*b11d(i+1)
                 b11d(i+1) = work(iu1cs+i-1)*b11d(i+1) -work(iu1sn+i-1)*b11e(i)
                 b11e(i) = temp
                 if( i < imax - 1 ) then
                    b11bulge = work(iu1sn+i-1)*b11e(i+1)
                    b11e(i+1) = work(iu1cs+i-1)*b11e(i+1)
                 end if
                 temp = work(iu2cs+i-1)*b21e(i) + work(iu2sn+i-1)*b21d(i+1)
                 b21d(i+1) = work(iu2cs+i-1)*b21d(i+1) -work(iu2sn+i-1)*b21e(i)
                 b21e(i) = temp
                 if( i < imax - 1 ) then
                    b21bulge = work(iu2sn+i-1)*b21e(i+1)
                    b21e(i+1) = work(iu2cs+i-1)*b21e(i+1)
                 end if
                 temp = work(iu1cs+i-1)*b12d(i) + work(iu1sn+i-1)*b12e(i)
                 b12e(i) = work(iu1cs+i-1)*b12e(i) - work(iu1sn+i-1)*b12d(i)
                 b12d(i) = temp
                 b12bulge = work(iu1sn+i-1)*b12d(i+1)
                 b12d(i+1) = work(iu1cs+i-1)*b12d(i+1)
                 temp = work(iu2cs+i-1)*b22d(i) + work(iu2sn+i-1)*b22e(i)
                 b22e(i) = work(iu2cs+i-1)*b22e(i) - work(iu2sn+i-1)*b22d(i)
                 b22d(i) = temp
                 b22bulge = work(iu2sn+i-1)*b22d(i+1)
                 b22d(i+1) = work(iu2cs+i-1)*b22d(i+1)
              end do
              ! compute phi(imax-1)
              x1 = sin(theta(imax-1))*b11e(imax-1) +cos(theta(imax-1))*b21e(imax-1)
              y1 = sin(theta(imax-1))*b12d(imax-1) +cos(theta(imax-1))*b22d(imax-1)
              y2 = sin(theta(imax-1))*b12bulge + cos(theta(imax-1))*b22bulge
              phi(imax-1) = atan2( abs(x1), sqrt(y1**2+y2**2) )
              ! chase bulges from b12(imax-1,imax) and b22(imax-1,imax)
              restart12 = b12d(imax-1)**2 + b12bulge**2 <= thresh**2
              restart22 = b22d(imax-1)**2 + b22bulge**2 <= thresh**2
              if( .not. restart12 .and. .not. restart22 ) then
                 call stdlib_slartgp( y2, y1, work(iv2tsn+imax-1-1),work(iv2tcs+imax-1-1), r )
                           
              else if( .not. restart12 .and. restart22 ) then
                 call stdlib_slartgp( b12bulge, b12d(imax-1), work(iv2tsn+imax-1-1),work(iv2tcs+&
                           imax-1-1), r )
              else if( restart12 .and. .not. restart22 ) then
                 call stdlib_slartgp( b22bulge, b22d(imax-1), work(iv2tsn+imax-1-1),work(iv2tcs+&
                           imax-1-1), r )
              else if( nu < mu ) then
                 call stdlib_slartgs( b12e(imax-1), b12d(imax), nu,work(iv2tcs+imax-1-1), work(&
                           iv2tsn+imax-1-1) )
              else
                 call stdlib_slartgs( b22e(imax-1), b22d(imax), mu,work(iv2tcs+imax-1-1), work(&
                           iv2tsn+imax-1-1) )
              end if
              temp = work(iv2tcs+imax-1-1)*b12e(imax-1) +work(iv2tsn+imax-1-1)*b12d(imax)
              b12d(imax) = work(iv2tcs+imax-1-1)*b12d(imax) -work(iv2tsn+imax-1-1)*b12e(imax-1)
                        
              b12e(imax-1) = temp
              temp = work(iv2tcs+imax-1-1)*b22e(imax-1) +work(iv2tsn+imax-1-1)*b22d(imax)
              b22d(imax) = work(iv2tcs+imax-1-1)*b22d(imax) -work(iv2tsn+imax-1-1)*b22e(imax-1)
                        
              b22e(imax-1) = temp
              ! update singular vectors
              if( wantu1 ) then
                 if( colmajor ) then
                    call stdlib_slasr( 'R', 'V', 'F', p, imax-imin+1,work(iu1cs+imin-1), work(&
                              iu1sn+imin-1),u1(1,imin), ldu1 )
                 else
                    call stdlib_slasr( 'L', 'V', 'F', imax-imin+1, p,work(iu1cs+imin-1), work(&
                              iu1sn+imin-1),u1(imin,1), ldu1 )
                 end if
              end if
              if( wantu2 ) then
                 if( colmajor ) then
                    call stdlib_slasr( 'R', 'V', 'F', m-p, imax-imin+1,work(iu2cs+imin-1), work(&
                              iu2sn+imin-1),u2(1,imin), ldu2 )
                 else
                    call stdlib_slasr( 'L', 'V', 'F', imax-imin+1, m-p,work(iu2cs+imin-1), work(&
                              iu2sn+imin-1),u2(imin,1), ldu2 )
                 end if
              end if
              if( wantv1t ) then
                 if( colmajor ) then
                    call stdlib_slasr( 'L', 'V', 'F', imax-imin+1, q,work(iv1tcs+imin-1), work(&
                              iv1tsn+imin-1),v1t(imin,1), ldv1t )
                 else
                    call stdlib_slasr( 'R', 'V', 'F', q, imax-imin+1,work(iv1tcs+imin-1), work(&
                              iv1tsn+imin-1),v1t(1,imin), ldv1t )
                 end if
              end if
              if( wantv2t ) then
                 if( colmajor ) then
                    call stdlib_slasr( 'L', 'V', 'F', imax-imin+1, m-q,work(iv2tcs+imin-1), work(&
                              iv2tsn+imin-1),v2t(imin,1), ldv2t )
                 else
                    call stdlib_slasr( 'R', 'V', 'F', m-q, imax-imin+1,work(iv2tcs+imin-1), work(&
                              iv2tsn+imin-1),v2t(1,imin), ldv2t )
                 end if
              end if
              ! fix signs on b11(imax-1,imax) and b21(imax-1,imax)
              if( b11e(imax-1)+b21e(imax-1) > 0 ) then
                 b11d(imax) = -b11d(imax)
                 b21d(imax) = -b21d(imax)
                 if( wantv1t ) then
                    if( colmajor ) then
                       call stdlib_sscal( q, negone, v1t(imax,1), ldv1t )
                    else
                       call stdlib_sscal( q, negone, v1t(1,imax), 1 )
                    end if
                 end if
              end if
              ! compute theta(imax)
              x1 = cos(phi(imax-1))*b11d(imax) +sin(phi(imax-1))*b12e(imax-1)
              y1 = cos(phi(imax-1))*b21d(imax) +sin(phi(imax-1))*b22e(imax-1)
              theta(imax) = atan2( abs(y1), abs(x1) )
              ! fix signs on b11(imax,imax), b12(imax,imax-1), b21(imax,imax),
              ! and b22(imax,imax-1)
              if( b11d(imax)+b12e(imax-1) < 0 ) then
                 b12d(imax) = -b12d(imax)
                 if( wantu1 ) then
                    if( colmajor ) then
                       call stdlib_sscal( p, negone, u1(1,imax), 1 )
                    else
                       call stdlib_sscal( p, negone, u1(imax,1), ldu1 )
                    end if
                 end if
              end if
              if( b21d(imax)+b22e(imax-1) > 0 ) then
                 b22d(imax) = -b22d(imax)
                 if( wantu2 ) then
                    if( colmajor ) then
                       call stdlib_sscal( m-p, negone, u2(1,imax), 1 )
                    else
                       call stdlib_sscal( m-p, negone, u2(imax,1), ldu2 )
                    end if
                 end if
              end if
              ! fix signs on b12(imax,imax) and b22(imax,imax)
              if( b12d(imax)+b22d(imax) < 0 ) then
                 if( wantv2t ) then
                    if( colmajor ) then
                       call stdlib_sscal( m-q, negone, v2t(imax,1), ldv2t )
                    else
                       call stdlib_sscal( m-q, negone, v2t(1,imax), 1 )
                    end if
                 end if
              end if
              ! test for negligible sines or cosines
              do i = imin, imax
                 if( theta(i) < thresh ) then
                    theta(i) = zero
                 else if( theta(i) > piover2-thresh ) then
                    theta(i) = piover2
                 end if
              end do
              do i = imin, imax-1
                 if( phi(i) < thresh ) then
                    phi(i) = zero
                 else if( phi(i) > piover2-thresh ) then
                    phi(i) = piover2
                 end if
              end do
              ! deflate
              if (imax > 1) then
                 do while( phi(imax-1) == zero )
                    imax = imax - 1
                    if (imax <= 1) exit
                 end do
              end if
              if( imin > imax - 1 )imin = imax - 1
              if (imin > 1) then
                 do while (phi(imin-1) /= zero)
                     imin = imin - 1
                     if (imin <= 1) exit
                 end do
              end if
              ! repeat main iteration loop
           end do
           ! postprocessing: order theta from least to greatest
           do i = 1, q
              mini = i
              thetamin = theta(i)
              do j = i+1, q
                 if( theta(j) < thetamin ) then
                    mini = j
                    thetamin = theta(j)
                 end if
              end do
              if( mini /= i ) then
                 theta(mini) = theta(i)
                 theta(i) = thetamin
                 if( colmajor ) then
                    if( wantu1 )call stdlib_sswap( p, u1(1,i), 1, u1(1,mini), 1 )
                    if( wantu2 )call stdlib_sswap( m-p, u2(1,i), 1, u2(1,mini), 1 )
                    if( wantv1t )call stdlib_sswap( q, v1t(i,1), ldv1t, v1t(mini,1), ldv1t )
                              
                    if( wantv2t )call stdlib_sswap( m-q, v2t(i,1), ldv2t, v2t(mini,1),ldv2t )
                              
                 else
                    if( wantu1 )call stdlib_sswap( p, u1(i,1), ldu1, u1(mini,1), ldu1 )
                    if( wantu2 )call stdlib_sswap( m-p, u2(i,1), ldu2, u2(mini,1), ldu2 )
                    if( wantv1t )call stdlib_sswap( q, v1t(1,i), 1, v1t(1,mini), 1 )
                    if( wantv2t )call stdlib_sswap( m-q, v2t(1,i), 1, v2t(1,mini), 1 )
                 end if
              end if
           end do
           return
     end subroutine stdlib_sbbcsd

     pure subroutine stdlib_dbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, u1, &
     ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d, b22e, work, lwork, info )
     !! DBBCSD computes the CS decomposition of an orthogonal matrix in
     !! bidiagonal-block form,
     !! [ B11 | B12 0  0 ]
     !! [  0  |  0 -I  0 ]
     !! X = [----------------]
     !! [ B21 | B22 0  0 ]
     !! [  0  |  0  0  I ]
     !! [  C | -S  0  0 ]
     !! [ U1 |    ] [  0 |  0 -I  0 ] [ V1 |    ]**T
     !! = [---------] [---------------] [---------]   .
     !! [    | U2 ] [  S |  C  0  0 ] [    | V2 ]
     !! [  0 |  0  0  I ]
     !! X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
     !! than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
     !! transposed and/or permuted. This can be done in constant time using
     !! the TRANS and SIGNS options. See DORCSD for details.)
     !! The bidiagonal matrices B11, B12, B21, and B22 are represented
     !! implicitly by angles THETA(1:Q) and PHI(1:Q-1).
     !! The orthogonal matrices U1, U2, V1T, and V2T are input/output.
     !! The input matrices are pre- or post-multiplied by the appropriate
     !! singular vector matrices.
     
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero
           ! Scalar Arguments 
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, lwork, m, p, q
           ! Array Arguments 
           real(dp), intent(out) :: b11d(*), b11e(*), b12d(*), b12e(*), b21d(*), b21e(*), b22d(*),&
                      b22e(*), work(*)
           real(dp), intent(inout) :: phi(*), theta(*)
           real(dp), intent(inout) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*)
        ! ===================================================================
           ! Parameters 
           integer(ilp), parameter :: maxitr = 6
           real(dp), parameter :: hundred = 100.0_dp
           real(dp), parameter :: meighth = -0.125_dp
           real(dp), parameter :: piover2 = 1.57079632679489661923132169163975144210_dp
           
           
           
           
           ! Local Scalars 
           logical(lk) :: colmajor, lquery, restart11, restart12, restart21, restart22, wantu1, &
                     wantu2, wantv1t, wantv2t
           integer(ilp) :: i, imin, imax, iter, iu1cs, iu1sn, iu2cs, iu2sn, iv1tcs, iv1tsn, &
                     iv2tcs, iv2tsn, j, lworkmin, lworkopt, maxit, mini
           real(dp) :: b11bulge, b12bulge, b21bulge, b22bulge, dummy, eps, mu, nu, r, sigma11, &
                     sigma21, temp, thetamax, thetamin, thresh, tol, tolmul, unfl, x1, x2, y1, y2
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test input arguments
           info = 0
           lquery = lwork == -1
           wantu1 = stdlib_lsame( jobu1, 'Y' )
           wantu2 = stdlib_lsame( jobu2, 'Y' )
           wantv1t = stdlib_lsame( jobv1t, 'Y' )
           wantv2t = stdlib_lsame( jobv2t, 'Y' )
           colmajor = .not. stdlib_lsame( trans, 'T' )
           if( m < 0 ) then
              info = -6
           else if( p < 0 .or. p > m ) then
              info = -7
           else if( q < 0 .or. q > m ) then
              info = -8
           else if( q > p .or. q > m-p .or. q > m-q ) then
              info = -8
           else if( wantu1 .and. ldu1 < p ) then
              info = -12
           else if( wantu2 .and. ldu2 < m-p ) then
              info = -14
           else if( wantv1t .and. ldv1t < q ) then
              info = -16
           else if( wantv2t .and. ldv2t < m-q ) then
              info = -18
           end if
           ! quick return if q = 0
           if( info == 0 .and. q == 0 ) then
              lworkmin = 1
              work(1) = lworkmin
              return
           end if
           ! compute workspace
           if( info == 0 ) then
              iu1cs = 1
              iu1sn = iu1cs + q
              iu2cs = iu1sn + q
              iu2sn = iu2cs + q
              iv1tcs = iu2sn + q
              iv1tsn = iv1tcs + q
              iv2tcs = iv1tsn + q
              iv2tsn = iv2tcs + q
              lworkopt = iv2tsn + q - 1
              lworkmin = lworkopt
              work(1) = lworkopt
              if( lwork < lworkmin .and. .not. lquery ) then
                 info = -28
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'DBBCSD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'EPSILON' )
           unfl = stdlib_dlamch( 'SAFE MINIMUM' )
           tolmul = max( ten, min( hundred, eps**meighth ) )
           tol = tolmul*eps
           thresh = max( tol, maxitr*q*q*unfl )
           ! test for negligible sines or cosines
           do i = 1, q
              if( theta(i) < thresh ) then
                 theta(i) = zero
              else if( theta(i) > piover2-thresh ) then
                 theta(i) = piover2
              end if
           end do
           do i = 1, q-1
              if( phi(i) < thresh ) then
                 phi(i) = zero
              else if( phi(i) > piover2-thresh ) then
                 phi(i) = piover2
              end if
           end do
           ! initial deflation
           imax = q
           do while( imax > 1 )
              if( phi(imax-1) /= zero ) then
                 exit
              end if
              imax = imax - 1
           end do
           imin = imax - 1
           if  ( imin > 1 ) then
              do while( phi(imin-1) /= zero )
                 imin = imin - 1
                 if  ( imin <= 1 ) exit
              end do
           end if
           ! initialize iteration counter
           maxit = maxitr*q*q
           iter = 0
           ! begin main iteration loop
           do while( imax > 1 )
              ! compute the matrix entries
              b11d(imin) = cos( theta(imin) )
              b21d(imin) = -sin( theta(imin) )
              do i = imin, imax - 1
                 b11e(i) = -sin( theta(i) ) * sin( phi(i) )
                 b11d(i+1) = cos( theta(i+1) ) * cos( phi(i) )
                 b12d(i) = sin( theta(i) ) * cos( phi(i) )
                 b12e(i) = cos( theta(i+1) ) * sin( phi(i) )
                 b21e(i) = -cos( theta(i) ) * sin( phi(i) )
                 b21d(i+1) = -sin( theta(i+1) ) * cos( phi(i) )
                 b22d(i) = cos( theta(i) ) * cos( phi(i) )
                 b22e(i) = -sin( theta(i+1) ) * sin( phi(i) )
              end do
              b12d(imax) = sin( theta(imax) )
              b22d(imax) = cos( theta(imax) )
              ! abort if not converging; otherwise, increment iter
              if( iter > maxit ) then
                 info = 0
                 do i = 1, q
                    if( phi(i) /= zero )info = info + 1
                 end do
                 return
              end if
              iter = iter + imax - imin
              ! compute shifts
              thetamax = theta(imin)
              thetamin = theta(imin)
              do i = imin+1, imax
                 if( theta(i) > thetamax )thetamax = theta(i)
                 if( theta(i) < thetamin )thetamin = theta(i)
              end do
              if( thetamax > piover2 - thresh ) then
                 ! zero on diagonals of b11 and b22; induce deflation with a
                 ! zero shift
                 mu = zero
                 nu = one
              else if( thetamin < thresh ) then
                 ! zero on diagonals of b12 and b22; induce deflation with a
                 ! zero shift
                 mu = one
                 nu = zero
              else
                 ! compute shifts for b11 and b21 and use the lesser
                 call stdlib_dlas2( b11d(imax-1), b11e(imax-1), b11d(imax), sigma11,dummy )
                           
                 call stdlib_dlas2( b21d(imax-1), b21e(imax-1), b21d(imax), sigma21,dummy )
                           
                 if( sigma11 <= sigma21 ) then
                    mu = sigma11
                    nu = sqrt( one - mu**2 )
                    if( mu < thresh ) then
                       mu = zero
                       nu = one
                    end if
                 else
                    nu = sigma21
                    mu = sqrt( 1.0_dp - nu**2 )
                    if( nu < thresh ) then
                       mu = one
                       nu = zero
                    end if
                 end if
              end if
              ! rotate to produce bulges in b11 and b21
              if( mu <= nu ) then
                 call stdlib_dlartgs( b11d(imin), b11e(imin), mu,work(iv1tcs+imin-1), work(iv1tsn+&
                           imin-1) )
              else
                 call stdlib_dlartgs( b21d(imin), b21e(imin), nu,work(iv1tcs+imin-1), work(iv1tsn+&
                           imin-1) )
              end if
              temp = work(iv1tcs+imin-1)*b11d(imin) +work(iv1tsn+imin-1)*b11e(imin)
              b11e(imin) = work(iv1tcs+imin-1)*b11e(imin) -work(iv1tsn+imin-1)*b11d(imin)
              b11d(imin) = temp
              b11bulge = work(iv1tsn+imin-1)*b11d(imin+1)
              b11d(imin+1) = work(iv1tcs+imin-1)*b11d(imin+1)
              temp = work(iv1tcs+imin-1)*b21d(imin) +work(iv1tsn+imin-1)*b21e(imin)
              b21e(imin) = work(iv1tcs+imin-1)*b21e(imin) -work(iv1tsn+imin-1)*b21d(imin)
              b21d(imin) = temp
              b21bulge = work(iv1tsn+imin-1)*b21d(imin+1)
              b21d(imin+1) = work(iv1tcs+imin-1)*b21d(imin+1)
              ! compute theta(imin)
              theta( imin ) = atan2( sqrt( b21d(imin)**2+b21bulge**2 ),sqrt( b11d(imin)**2+&
                        b11bulge**2 ) )
              ! chase the bulges in b11(imin+1,imin) and b21(imin+1,imin)
              if( b11d(imin)**2+b11bulge**2 > thresh**2 ) then
                 call stdlib_dlartgp( b11bulge, b11d(imin), work(iu1sn+imin-1),work(iu1cs+imin-1),&
                            r )
              else if( mu <= nu ) then
                 call stdlib_dlartgs( b11e( imin ), b11d( imin + 1 ), mu,work(iu1cs+imin-1), work(&
                           iu1sn+imin-1) )
              else
                 call stdlib_dlartgs( b12d( imin ), b12e( imin ), nu,work(iu1cs+imin-1), work(&
                           iu1sn+imin-1) )
              end if
              if( b21d(imin)**2+b21bulge**2 > thresh**2 ) then
                 call stdlib_dlartgp( b21bulge, b21d(imin), work(iu2sn+imin-1),work(iu2cs+imin-1),&
                            r )
              else if( nu < mu ) then
                 call stdlib_dlartgs( b21e( imin ), b21d( imin + 1 ), nu,work(iu2cs+imin-1), work(&
                           iu2sn+imin-1) )
              else
                 call stdlib_dlartgs( b22d(imin), b22e(imin), mu,work(iu2cs+imin-1), work(iu2sn+&
                           imin-1) )
              end if
              work(iu2cs+imin-1) = -work(iu2cs+imin-1)
              work(iu2sn+imin-1) = -work(iu2sn+imin-1)
              temp = work(iu1cs+imin-1)*b11e(imin) +work(iu1sn+imin-1)*b11d(imin+1)
              b11d(imin+1) = work(iu1cs+imin-1)*b11d(imin+1) -work(iu1sn+imin-1)*b11e(imin)
                        
              b11e(imin) = temp
              if( imax > imin+1 ) then
                 b11bulge = work(iu1sn+imin-1)*b11e(imin+1)
                 b11e(imin+1) = work(iu1cs+imin-1)*b11e(imin+1)
              end if
              temp = work(iu1cs+imin-1)*b12d(imin) +work(iu1sn+imin-1)*b12e(imin)
              b12e(imin) = work(iu1cs+imin-1)*b12e(imin) -work(iu1sn+imin-1)*b12d(imin)
              b12d(imin) = temp
              b12bulge = work(iu1sn+imin-1)*b12d(imin+1)
              b12d(imin+1) = work(iu1cs+imin-1)*b12d(imin+1)
              temp = work(iu2cs+imin-1)*b21e(imin) +work(iu2sn+imin-1)*b21d(imin+1)
              b21d(imin+1) = work(iu2cs+imin-1)*b21d(imin+1) -work(iu2sn+imin-1)*b21e(imin)
                        
              b21e(imin) = temp
              if( imax > imin+1 ) then
                 b21bulge = work(iu2sn+imin-1)*b21e(imin+1)
                 b21e(imin+1) = work(iu2cs+imin-1)*b21e(imin+1)
              end if
              temp = work(iu2cs+imin-1)*b22d(imin) +work(iu2sn+imin-1)*b22e(imin)
              b22e(imin) = work(iu2cs+imin-1)*b22e(imin) -work(iu2sn+imin-1)*b22d(imin)
              b22d(imin) = temp
              b22bulge = work(iu2sn+imin-1)*b22d(imin+1)
              b22d(imin+1) = work(iu2cs+imin-1)*b22d(imin+1)
              ! inner loop: chase bulges from b11(imin,imin+2),
              ! b12(imin,imin+1), b21(imin,imin+2), and b22(imin,imin+1) to
              ! bottom-right
              do i = imin+1, imax-1
                 ! compute phi(i-1)
                 x1 = sin(theta(i-1))*b11e(i-1) + cos(theta(i-1))*b21e(i-1)
                 x2 = sin(theta(i-1))*b11bulge + cos(theta(i-1))*b21bulge
                 y1 = sin(theta(i-1))*b12d(i-1) + cos(theta(i-1))*b22d(i-1)
                 y2 = sin(theta(i-1))*b12bulge + cos(theta(i-1))*b22bulge
                 phi(i-1) = atan2( sqrt(x1**2+x2**2), sqrt(y1**2+y2**2) )
                 ! determine if there are bulges to chase or if a new direct
                 ! summand has been reached
                 restart11 = b11e(i-1)**2 + b11bulge**2 <= thresh**2
                 restart21 = b21e(i-1)**2 + b21bulge**2 <= thresh**2
                 restart12 = b12d(i-1)**2 + b12bulge**2 <= thresh**2
                 restart22 = b22d(i-1)**2 + b22bulge**2 <= thresh**2
                 ! if possible, chase bulges from b11(i-1,i+1), b12(i-1,i),
                 ! b21(i-1,i+1), and b22(i-1,i). if necessary, restart bulge-
                 ! chasing by applying the original shift again.
                 if( .not. restart11 .and. .not. restart21 ) then
                    call stdlib_dlartgp( x2, x1, work(iv1tsn+i-1), work(iv1tcs+i-1),r )
                 else if( .not. restart11 .and. restart21 ) then
                    call stdlib_dlartgp( b11bulge, b11e(i-1), work(iv1tsn+i-1),work(iv1tcs+i-1), &
                              r )
                 else if( restart11 .and. .not. restart21 ) then
                    call stdlib_dlartgp( b21bulge, b21e(i-1), work(iv1tsn+i-1),work(iv1tcs+i-1), &
                              r )
                 else if( mu <= nu ) then
                    call stdlib_dlartgs( b11d(i), b11e(i), mu, work(iv1tcs+i-1),work(iv1tsn+i-1) )
                              
                 else
                    call stdlib_dlartgs( b21d(i), b21e(i), nu, work(iv1tcs+i-1),work(iv1tsn+i-1) )
                              
                 end if
                 work(iv1tcs+i-1) = -work(iv1tcs+i-1)
                 work(iv1tsn+i-1) = -work(iv1tsn+i-1)
                 if( .not. restart12 .and. .not. restart22 ) then
                    call stdlib_dlartgp( y2, y1, work(iv2tsn+i-1-1),work(iv2tcs+i-1-1), r )
                              
                 else if( .not. restart12 .and. restart22 ) then
                    call stdlib_dlartgp( b12bulge, b12d(i-1), work(iv2tsn+i-1-1),work(iv2tcs+i-1-&
                              1), r )
                 else if( restart12 .and. .not. restart22 ) then
                    call stdlib_dlartgp( b22bulge, b22d(i-1), work(iv2tsn+i-1-1),work(iv2tcs+i-1-&
                              1), r )
                 else if( nu < mu ) then
                    call stdlib_dlartgs( b12e(i-1), b12d(i), nu, work(iv2tcs+i-1-1),work(iv2tsn+i-&
                              1-1) )
                 else
                    call stdlib_dlartgs( b22e(i-1), b22d(i), mu, work(iv2tcs+i-1-1),work(iv2tsn+i-&
                              1-1) )
                 end if
                 temp = work(iv1tcs+i-1)*b11d(i) + work(iv1tsn+i-1)*b11e(i)
                 b11e(i) = work(iv1tcs+i-1)*b11e(i) -work(iv1tsn+i-1)*b11d(i)
                 b11d(i) = temp
                 b11bulge = work(iv1tsn+i-1)*b11d(i+1)
                 b11d(i+1) = work(iv1tcs+i-1)*b11d(i+1)
                 temp = work(iv1tcs+i-1)*b21d(i) + work(iv1tsn+i-1)*b21e(i)
                 b21e(i) = work(iv1tcs+i-1)*b21e(i) -work(iv1tsn+i-1)*b21d(i)
                 b21d(i) = temp
                 b21bulge = work(iv1tsn+i-1)*b21d(i+1)
                 b21d(i+1) = work(iv1tcs+i-1)*b21d(i+1)
                 temp = work(iv2tcs+i-1-1)*b12e(i-1) +work(iv2tsn+i-1-1)*b12d(i)
                 b12d(i) = work(iv2tcs+i-1-1)*b12d(i) -work(iv2tsn+i-1-1)*b12e(i-1)
                 b12e(i-1) = temp
                 b12bulge = work(iv2tsn+i-1-1)*b12e(i)
                 b12e(i) = work(iv2tcs+i-1-1)*b12e(i)
                 temp = work(iv2tcs+i-1-1)*b22e(i-1) +work(iv2tsn+i-1-1)*b22d(i)
                 b22d(i) = work(iv2tcs+i-1-1)*b22d(i) -work(iv2tsn+i-1-1)*b22e(i-1)
                 b22e(i-1) = temp
                 b22bulge = work(iv2tsn+i-1-1)*b22e(i)
                 b22e(i) = work(iv2tcs+i-1-1)*b22e(i)
                 ! compute theta(i)
                 x1 = cos(phi(i-1))*b11d(i) + sin(phi(i-1))*b12e(i-1)
                 x2 = cos(phi(i-1))*b11bulge + sin(phi(i-1))*b12bulge
                 y1 = cos(phi(i-1))*b21d(i) + sin(phi(i-1))*b22e(i-1)
                 y2 = cos(phi(i-1))*b21bulge + sin(phi(i-1))*b22bulge
                 theta(i) = atan2( sqrt(y1**2+y2**2), sqrt(x1**2+x2**2) )
                 ! determine if there are bulges to chase or if a new direct
                 ! summand has been reached
                 restart11 =   b11d(i)**2 + b11bulge**2 <= thresh**2
                 restart12 = b12e(i-1)**2 + b12bulge**2 <= thresh**2
                 restart21 =   b21d(i)**2 + b21bulge**2 <= thresh**2
                 restart22 = b22e(i-1)**2 + b22bulge**2 <= thresh**2
                 ! if possible, chase bulges from b11(i+1,i), b12(i+1,i-1),
                 ! b21(i+1,i), and b22(i+1,i-1). if necessary, restart bulge-
                 ! chasing by applying the original shift again.
                 if( .not. restart11 .and. .not. restart12 ) then
                    call stdlib_dlartgp( x2, x1, work(iu1sn+i-1), work(iu1cs+i-1),r )
                 else if( .not. restart11 .and. restart12 ) then
                    call stdlib_dlartgp( b11bulge, b11d(i), work(iu1sn+i-1),work(iu1cs+i-1), r )
                              
                 else if( restart11 .and. .not. restart12 ) then
                    call stdlib_dlartgp( b12bulge, b12e(i-1), work(iu1sn+i-1),work(iu1cs+i-1), r )
                              
                 else if( mu <= nu ) then
                    call stdlib_dlartgs( b11e(i), b11d(i+1), mu, work(iu1cs+i-1),work(iu1sn+i-1) )
                              
                 else
                    call stdlib_dlartgs( b12d(i), b12e(i), nu, work(iu1cs+i-1),work(iu1sn+i-1) )
                              
                 end if
                 if( .not. restart21 .and. .not. restart22 ) then
                    call stdlib_dlartgp( y2, y1, work(iu2sn+i-1), work(iu2cs+i-1),r )
                 else if( .not. restart21 .and. restart22 ) then
                    call stdlib_dlartgp( b21bulge, b21d(i), work(iu2sn+i-1),work(iu2cs+i-1), r )
                              
                 else if( restart21 .and. .not. restart22 ) then
                    call stdlib_dlartgp( b22bulge, b22e(i-1), work(iu2sn+i-1),work(iu2cs+i-1), r )
                              
                 else if( nu < mu ) then
                    call stdlib_dlartgs( b21e(i), b21e(i+1), nu, work(iu2cs+i-1),work(iu2sn+i-1) )
                              
                 else
                    call stdlib_dlartgs( b22d(i), b22e(i), mu, work(iu2cs+i-1),work(iu2sn+i-1) )
                              
                 end if
                 work(iu2cs+i-1) = -work(iu2cs+i-1)
                 work(iu2sn+i-1) = -work(iu2sn+i-1)
                 temp = work(iu1cs+i-1)*b11e(i) + work(iu1sn+i-1)*b11d(i+1)
                 b11d(i+1) = work(iu1cs+i-1)*b11d(i+1) -work(iu1sn+i-1)*b11e(i)
                 b11e(i) = temp
                 if( i < imax - 1 ) then
                    b11bulge = work(iu1sn+i-1)*b11e(i+1)
                    b11e(i+1) = work(iu1cs+i-1)*b11e(i+1)
                 end if
                 temp = work(iu2cs+i-1)*b21e(i) + work(iu2sn+i-1)*b21d(i+1)
                 b21d(i+1) = work(iu2cs+i-1)*b21d(i+1) -work(iu2sn+i-1)*b21e(i)
                 b21e(i) = temp
                 if( i < imax - 1 ) then
                    b21bulge = work(iu2sn+i-1)*b21e(i+1)
                    b21e(i+1) = work(iu2cs+i-1)*b21e(i+1)
                 end if
                 temp = work(iu1cs+i-1)*b12d(i) + work(iu1sn+i-1)*b12e(i)
                 b12e(i) = work(iu1cs+i-1)*b12e(i) - work(iu1sn+i-1)*b12d(i)
                 b12d(i) = temp
                 b12bulge = work(iu1sn+i-1)*b12d(i+1)
                 b12d(i+1) = work(iu1cs+i-1)*b12d(i+1)
                 temp = work(iu2cs+i-1)*b22d(i) + work(iu2sn+i-1)*b22e(i)
                 b22e(i) = work(iu2cs+i-1)*b22e(i) - work(iu2sn+i-1)*b22d(i)
                 b22d(i) = temp
                 b22bulge = work(iu2sn+i-1)*b22d(i+1)
                 b22d(i+1) = work(iu2cs+i-1)*b22d(i+1)
              end do
              ! compute phi(imax-1)
              x1 = sin(theta(imax-1))*b11e(imax-1) +cos(theta(imax-1))*b21e(imax-1)
              y1 = sin(theta(imax-1))*b12d(imax-1) +cos(theta(imax-1))*b22d(imax-1)
              y2 = sin(theta(imax-1))*b12bulge + cos(theta(imax-1))*b22bulge
              phi(imax-1) = atan2( abs(x1), sqrt(y1**2+y2**2) )
              ! chase bulges from b12(imax-1,imax) and b22(imax-1,imax)
              restart12 = b12d(imax-1)**2 + b12bulge**2 <= thresh**2
              restart22 = b22d(imax-1)**2 + b22bulge**2 <= thresh**2
              if( .not. restart12 .and. .not. restart22 ) then
                 call stdlib_dlartgp( y2, y1, work(iv2tsn+imax-1-1),work(iv2tcs+imax-1-1), r )
                           
              else if( .not. restart12 .and. restart22 ) then
                 call stdlib_dlartgp( b12bulge, b12d(imax-1), work(iv2tsn+imax-1-1),work(iv2tcs+&
                           imax-1-1), r )
              else if( restart12 .and. .not. restart22 ) then
                 call stdlib_dlartgp( b22bulge, b22d(imax-1), work(iv2tsn+imax-1-1),work(iv2tcs+&
                           imax-1-1), r )
              else if( nu < mu ) then
                 call stdlib_dlartgs( b12e(imax-1), b12d(imax), nu,work(iv2tcs+imax-1-1), work(&
                           iv2tsn+imax-1-1) )
              else
                 call stdlib_dlartgs( b22e(imax-1), b22d(imax), mu,work(iv2tcs+imax-1-1), work(&
                           iv2tsn+imax-1-1) )
              end if
              temp = work(iv2tcs+imax-1-1)*b12e(imax-1) +work(iv2tsn+imax-1-1)*b12d(imax)
              b12d(imax) = work(iv2tcs+imax-1-1)*b12d(imax) -work(iv2tsn+imax-1-1)*b12e(imax-1)
                        
              b12e(imax-1) = temp
              temp = work(iv2tcs+imax-1-1)*b22e(imax-1) +work(iv2tsn+imax-1-1)*b22d(imax)
              b22d(imax) = work(iv2tcs+imax-1-1)*b22d(imax) -work(iv2tsn+imax-1-1)*b22e(imax-1)
                        
              b22e(imax-1) = temp
              ! update singular vectors
              if( wantu1 ) then
                 if( colmajor ) then
                    call stdlib_dlasr( 'R', 'V', 'F', p, imax-imin+1,work(iu1cs+imin-1), work(&
                              iu1sn+imin-1),u1(1,imin), ldu1 )
                 else
                    call stdlib_dlasr( 'L', 'V', 'F', imax-imin+1, p,work(iu1cs+imin-1), work(&
                              iu1sn+imin-1),u1(imin,1), ldu1 )
                 end if
              end if
              if( wantu2 ) then
                 if( colmajor ) then
                    call stdlib_dlasr( 'R', 'V', 'F', m-p, imax-imin+1,work(iu2cs+imin-1), work(&
                              iu2sn+imin-1),u2(1,imin), ldu2 )
                 else
                    call stdlib_dlasr( 'L', 'V', 'F', imax-imin+1, m-p,work(iu2cs+imin-1), work(&
                              iu2sn+imin-1),u2(imin,1), ldu2 )
                 end if
              end if
              if( wantv1t ) then
                 if( colmajor ) then
                    call stdlib_dlasr( 'L', 'V', 'F', imax-imin+1, q,work(iv1tcs+imin-1), work(&
                              iv1tsn+imin-1),v1t(imin,1), ldv1t )
                 else
                    call stdlib_dlasr( 'R', 'V', 'F', q, imax-imin+1,work(iv1tcs+imin-1), work(&
                              iv1tsn+imin-1),v1t(1,imin), ldv1t )
                 end if
              end if
              if( wantv2t ) then
                 if( colmajor ) then
                    call stdlib_dlasr( 'L', 'V', 'F', imax-imin+1, m-q,work(iv2tcs+imin-1), work(&
                              iv2tsn+imin-1),v2t(imin,1), ldv2t )
                 else
                    call stdlib_dlasr( 'R', 'V', 'F', m-q, imax-imin+1,work(iv2tcs+imin-1), work(&
                              iv2tsn+imin-1),v2t(1,imin), ldv2t )
                 end if
              end if
              ! fix signs on b11(imax-1,imax) and b21(imax-1,imax)
              if( b11e(imax-1)+b21e(imax-1) > 0 ) then
                 b11d(imax) = -b11d(imax)
                 b21d(imax) = -b21d(imax)
                 if( wantv1t ) then
                    if( colmajor ) then
                       call stdlib_dscal( q, negone, v1t(imax,1), ldv1t )
                    else
                       call stdlib_dscal( q, negone, v1t(1,imax), 1 )
                    end if
                 end if
              end if
              ! compute theta(imax)
              x1 = cos(phi(imax-1))*b11d(imax) +sin(phi(imax-1))*b12e(imax-1)
              y1 = cos(phi(imax-1))*b21d(imax) +sin(phi(imax-1))*b22e(imax-1)
              theta(imax) = atan2( abs(y1), abs(x1) )
              ! fix signs on b11(imax,imax), b12(imax,imax-1), b21(imax,imax),
              ! and b22(imax,imax-1)
              if( b11d(imax)+b12e(imax-1) < 0 ) then
                 b12d(imax) = -b12d(imax)
                 if( wantu1 ) then
                    if( colmajor ) then
                       call stdlib_dscal( p, negone, u1(1,imax), 1 )
                    else
                       call stdlib_dscal( p, negone, u1(imax,1), ldu1 )
                    end if
                 end if
              end if
              if( b21d(imax)+b22e(imax-1) > 0 ) then
                 b22d(imax) = -b22d(imax)
                 if( wantu2 ) then
                    if( colmajor ) then
                       call stdlib_dscal( m-p, negone, u2(1,imax), 1 )
                    else
                       call stdlib_dscal( m-p, negone, u2(imax,1), ldu2 )
                    end if
                 end if
              end if
              ! fix signs on b12(imax,imax) and b22(imax,imax)
              if( b12d(imax)+b22d(imax) < 0 ) then
                 if( wantv2t ) then
                    if( colmajor ) then
                       call stdlib_dscal( m-q, negone, v2t(imax,1), ldv2t )
                    else
                       call stdlib_dscal( m-q, negone, v2t(1,imax), 1 )
                    end if
                 end if
              end if
              ! test for negligible sines or cosines
              do i = imin, imax
                 if( theta(i) < thresh ) then
                    theta(i) = zero
                 else if( theta(i) > piover2-thresh ) then
                    theta(i) = piover2
                 end if
              end do
              do i = imin, imax-1
                 if( phi(i) < thresh ) then
                    phi(i) = zero
                 else if( phi(i) > piover2-thresh ) then
                    phi(i) = piover2
                 end if
              end do
              ! deflate
              if (imax > 1) then
                 do while( phi(imax-1) == zero )
                    imax = imax - 1
                    if (imax <= 1) exit
                 end do
              end if
              if( imin > imax - 1 )imin = imax - 1
              if (imin > 1) then
                 do while (phi(imin-1) /= zero)
                     imin = imin - 1
                     if (imin <= 1) exit
                 end do
              end if
              ! repeat main iteration loop
           end do
           ! postprocessing: order theta from least to greatest
           do i = 1, q
              mini = i
              thetamin = theta(i)
              do j = i+1, q
                 if( theta(j) < thetamin ) then
                    mini = j
                    thetamin = theta(j)
                 end if
              end do
              if( mini /= i ) then
                 theta(mini) = theta(i)
                 theta(i) = thetamin
                 if( colmajor ) then
                    if( wantu1 )call stdlib_dswap( p, u1(1,i), 1, u1(1,mini), 1 )
                    if( wantu2 )call stdlib_dswap( m-p, u2(1,i), 1, u2(1,mini), 1 )
                    if( wantv1t )call stdlib_dswap( q, v1t(i,1), ldv1t, v1t(mini,1), ldv1t )
                              
                    if( wantv2t )call stdlib_dswap( m-q, v2t(i,1), ldv2t, v2t(mini,1),ldv2t )
                              
                 else
                    if( wantu1 )call stdlib_dswap( p, u1(i,1), ldu1, u1(mini,1), ldu1 )
                    if( wantu2 )call stdlib_dswap( m-p, u2(i,1), ldu2, u2(mini,1), ldu2 )
                    if( wantv1t )call stdlib_dswap( q, v1t(1,i), 1, v1t(1,mini), 1 )
                    if( wantv2t )call stdlib_dswap( m-q, v2t(1,i), 1, v2t(1,mini), 1 )
                 end if
              end if
           end do
           return
     end subroutine stdlib_dbbcsd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     pure subroutine stdlib_${ri}$bbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, u1, &
     ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d, b22e, work, lwork, info )
     !! DBBCSD: computes the CS decomposition of an orthogonal matrix in
     !! bidiagonal-block form,
     !! [ B11 | B12 0  0 ]
     !! [  0  |  0 -I  0 ]
     !! X = [----------------]
     !! [ B21 | B22 0  0 ]
     !! [  0  |  0  0  I ]
     !! [  C | -S  0  0 ]
     !! [ U1 |    ] [  0 |  0 -I  0 ] [ V1 |    ]**T
     !! = [---------] [---------------] [---------]   .
     !! [    | U2 ] [  S |  C  0  0 ] [    | V2 ]
     !! [  0 |  0  0  I ]
     !! X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
     !! than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
     !! transposed and/or permuted. This can be done in constant time using
     !! the TRANS and SIGNS options. See DORCSD for details.)
     !! The bidiagonal matrices B11, B12, B21, and B22 are represented
     !! implicitly by angles THETA(1:Q) and PHI(1:Q-1).
     !! The orthogonal matrices U1, U2, V1T, and V2T are input/output.
     !! The input matrices are pre- or post-multiplied by the appropriate
     !! singular vector matrices.
     
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero
           ! Scalar Arguments 
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, lwork, m, p, q
           ! Array Arguments 
           real(${rk}$), intent(out) :: b11d(*), b11e(*), b12d(*), b12e(*), b21d(*), b21e(*), b22d(*),&
                      b22e(*), work(*)
           real(${rk}$), intent(inout) :: phi(*), theta(*)
           real(${rk}$), intent(inout) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*)
        ! ===================================================================
           ! Parameters 
           integer(ilp), parameter :: maxitr = 6
           real(${rk}$), parameter :: hundred = 100.0_${rk}$
           real(${rk}$), parameter :: meighth = -0.125_${rk}$
           real(${rk}$), parameter :: piover2 = 1.57079632679489661923132169163975144210_${rk}$
           
           
           
           
           ! Local Scalars 
           logical(lk) :: colmajor, lquery, restart11, restart12, restart21, restart22, wantu1, &
                     wantu2, wantv1t, wantv2t
           integer(ilp) :: i, imin, imax, iter, iu1cs, iu1sn, iu2cs, iu2sn, iv1tcs, iv1tsn, &
                     iv2tcs, iv2tsn, j, lworkmin, lworkopt, maxit, mini
           real(${rk}$) :: b11bulge, b12bulge, b21bulge, b22bulge, dummy, eps, mu, nu, r, sigma11, &
                     sigma21, temp, thetamax, thetamin, thresh, tol, tolmul, unfl, x1, x2, y1, y2
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test input arguments
           info = 0
           lquery = lwork == -1
           wantu1 = stdlib_lsame( jobu1, 'Y' )
           wantu2 = stdlib_lsame( jobu2, 'Y' )
           wantv1t = stdlib_lsame( jobv1t, 'Y' )
           wantv2t = stdlib_lsame( jobv2t, 'Y' )
           colmajor = .not. stdlib_lsame( trans, 'T' )
           if( m < 0 ) then
              info = -6
           else if( p < 0 .or. p > m ) then
              info = -7
           else if( q < 0 .or. q > m ) then
              info = -8
           else if( q > p .or. q > m-p .or. q > m-q ) then
              info = -8
           else if( wantu1 .and. ldu1 < p ) then
              info = -12
           else if( wantu2 .and. ldu2 < m-p ) then
              info = -14
           else if( wantv1t .and. ldv1t < q ) then
              info = -16
           else if( wantv2t .and. ldv2t < m-q ) then
              info = -18
           end if
           ! quick return if q = 0
           if( info == 0 .and. q == 0 ) then
              lworkmin = 1
              work(1) = lworkmin
              return
           end if
           ! compute workspace
           if( info == 0 ) then
              iu1cs = 1
              iu1sn = iu1cs + q
              iu2cs = iu1sn + q
              iu2sn = iu2cs + q
              iv1tcs = iu2sn + q
              iv1tsn = iv1tcs + q
              iv2tcs = iv1tsn + q
              iv2tsn = iv2tcs + q
              lworkopt = iv2tsn + q - 1
              lworkmin = lworkopt
              work(1) = lworkopt
              if( lwork < lworkmin .and. .not. lquery ) then
                 info = -28
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'DBBCSD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'EPSILON' )
           unfl = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           tolmul = max( ten, min( hundred, eps**meighth ) )
           tol = tolmul*eps
           thresh = max( tol, maxitr*q*q*unfl )
           ! test for negligible sines or cosines
           do i = 1, q
              if( theta(i) < thresh ) then
                 theta(i) = zero
              else if( theta(i) > piover2-thresh ) then
                 theta(i) = piover2
              end if
           end do
           do i = 1, q-1
              if( phi(i) < thresh ) then
                 phi(i) = zero
              else if( phi(i) > piover2-thresh ) then
                 phi(i) = piover2
              end if
           end do
           ! initial deflation
           imax = q
           do while( imax > 1 )
              if( phi(imax-1) /= zero ) then
                 exit
              end if
              imax = imax - 1
           end do
           imin = imax - 1
           if  ( imin > 1 ) then
              do while( phi(imin-1) /= zero )
                 imin = imin - 1
                 if  ( imin <= 1 ) exit
              end do
           end if
           ! initialize iteration counter
           maxit = maxitr*q*q
           iter = 0
           ! begin main iteration loop
           do while( imax > 1 )
              ! compute the matrix entries
              b11d(imin) = cos( theta(imin) )
              b21d(imin) = -sin( theta(imin) )
              do i = imin, imax - 1
                 b11e(i) = -sin( theta(i) ) * sin( phi(i) )
                 b11d(i+1) = cos( theta(i+1) ) * cos( phi(i) )
                 b12d(i) = sin( theta(i) ) * cos( phi(i) )
                 b12e(i) = cos( theta(i+1) ) * sin( phi(i) )
                 b21e(i) = -cos( theta(i) ) * sin( phi(i) )
                 b21d(i+1) = -sin( theta(i+1) ) * cos( phi(i) )
                 b22d(i) = cos( theta(i) ) * cos( phi(i) )
                 b22e(i) = -sin( theta(i+1) ) * sin( phi(i) )
              end do
              b12d(imax) = sin( theta(imax) )
              b22d(imax) = cos( theta(imax) )
              ! abort if not converging; otherwise, increment iter
              if( iter > maxit ) then
                 info = 0
                 do i = 1, q
                    if( phi(i) /= zero )info = info + 1
                 end do
                 return
              end if
              iter = iter + imax - imin
              ! compute shifts
              thetamax = theta(imin)
              thetamin = theta(imin)
              do i = imin+1, imax
                 if( theta(i) > thetamax )thetamax = theta(i)
                 if( theta(i) < thetamin )thetamin = theta(i)
              end do
              if( thetamax > piover2 - thresh ) then
                 ! zero on diagonals of b11 and b22; induce deflation with a
                 ! zero shift
                 mu = zero
                 nu = one
              else if( thetamin < thresh ) then
                 ! zero on diagonals of b12 and b22; induce deflation with a
                 ! zero shift
                 mu = one
                 nu = zero
              else
                 ! compute shifts for b11 and b21 and use the lesser
                 call stdlib_${ri}$las2( b11d(imax-1), b11e(imax-1), b11d(imax), sigma11,dummy )
                           
                 call stdlib_${ri}$las2( b21d(imax-1), b21e(imax-1), b21d(imax), sigma21,dummy )
                           
                 if( sigma11 <= sigma21 ) then
                    mu = sigma11
                    nu = sqrt( one - mu**2 )
                    if( mu < thresh ) then
                       mu = zero
                       nu = one
                    end if
                 else
                    nu = sigma21
                    mu = sqrt( 1.0_${rk}$ - nu**2 )
                    if( nu < thresh ) then
                       mu = one
                       nu = zero
                    end if
                 end if
              end if
              ! rotate to produce bulges in b11 and b21
              if( mu <= nu ) then
                 call stdlib_${ri}$lartgs( b11d(imin), b11e(imin), mu,work(iv1tcs+imin-1), work(iv1tsn+&
                           imin-1) )
              else
                 call stdlib_${ri}$lartgs( b21d(imin), b21e(imin), nu,work(iv1tcs+imin-1), work(iv1tsn+&
                           imin-1) )
              end if
              temp = work(iv1tcs+imin-1)*b11d(imin) +work(iv1tsn+imin-1)*b11e(imin)
              b11e(imin) = work(iv1tcs+imin-1)*b11e(imin) -work(iv1tsn+imin-1)*b11d(imin)
              b11d(imin) = temp
              b11bulge = work(iv1tsn+imin-1)*b11d(imin+1)
              b11d(imin+1) = work(iv1tcs+imin-1)*b11d(imin+1)
              temp = work(iv1tcs+imin-1)*b21d(imin) +work(iv1tsn+imin-1)*b21e(imin)
              b21e(imin) = work(iv1tcs+imin-1)*b21e(imin) -work(iv1tsn+imin-1)*b21d(imin)
              b21d(imin) = temp
              b21bulge = work(iv1tsn+imin-1)*b21d(imin+1)
              b21d(imin+1) = work(iv1tcs+imin-1)*b21d(imin+1)
              ! compute theta(imin)
              theta( imin ) = atan2( sqrt( b21d(imin)**2+b21bulge**2 ),sqrt( b11d(imin)**2+&
                        b11bulge**2 ) )
              ! chase the bulges in b11(imin+1,imin) and b21(imin+1,imin)
              if( b11d(imin)**2+b11bulge**2 > thresh**2 ) then
                 call stdlib_${ri}$lartgp( b11bulge, b11d(imin), work(iu1sn+imin-1),work(iu1cs+imin-1),&
                            r )
              else if( mu <= nu ) then
                 call stdlib_${ri}$lartgs( b11e( imin ), b11d( imin + 1 ), mu,work(iu1cs+imin-1), work(&
                           iu1sn+imin-1) )
              else
                 call stdlib_${ri}$lartgs( b12d( imin ), b12e( imin ), nu,work(iu1cs+imin-1), work(&
                           iu1sn+imin-1) )
              end if
              if( b21d(imin)**2+b21bulge**2 > thresh**2 ) then
                 call stdlib_${ri}$lartgp( b21bulge, b21d(imin), work(iu2sn+imin-1),work(iu2cs+imin-1),&
                            r )
              else if( nu < mu ) then
                 call stdlib_${ri}$lartgs( b21e( imin ), b21d( imin + 1 ), nu,work(iu2cs+imin-1), work(&
                           iu2sn+imin-1) )
              else
                 call stdlib_${ri}$lartgs( b22d(imin), b22e(imin), mu,work(iu2cs+imin-1), work(iu2sn+&
                           imin-1) )
              end if
              work(iu2cs+imin-1) = -work(iu2cs+imin-1)
              work(iu2sn+imin-1) = -work(iu2sn+imin-1)
              temp = work(iu1cs+imin-1)*b11e(imin) +work(iu1sn+imin-1)*b11d(imin+1)
              b11d(imin+1) = work(iu1cs+imin-1)*b11d(imin+1) -work(iu1sn+imin-1)*b11e(imin)
                        
              b11e(imin) = temp
              if( imax > imin+1 ) then
                 b11bulge = work(iu1sn+imin-1)*b11e(imin+1)
                 b11e(imin+1) = work(iu1cs+imin-1)*b11e(imin+1)
              end if
              temp = work(iu1cs+imin-1)*b12d(imin) +work(iu1sn+imin-1)*b12e(imin)
              b12e(imin) = work(iu1cs+imin-1)*b12e(imin) -work(iu1sn+imin-1)*b12d(imin)
              b12d(imin) = temp
              b12bulge = work(iu1sn+imin-1)*b12d(imin+1)
              b12d(imin+1) = work(iu1cs+imin-1)*b12d(imin+1)
              temp = work(iu2cs+imin-1)*b21e(imin) +work(iu2sn+imin-1)*b21d(imin+1)
              b21d(imin+1) = work(iu2cs+imin-1)*b21d(imin+1) -work(iu2sn+imin-1)*b21e(imin)
                        
              b21e(imin) = temp
              if( imax > imin+1 ) then
                 b21bulge = work(iu2sn+imin-1)*b21e(imin+1)
                 b21e(imin+1) = work(iu2cs+imin-1)*b21e(imin+1)
              end if
              temp = work(iu2cs+imin-1)*b22d(imin) +work(iu2sn+imin-1)*b22e(imin)
              b22e(imin) = work(iu2cs+imin-1)*b22e(imin) -work(iu2sn+imin-1)*b22d(imin)
              b22d(imin) = temp
              b22bulge = work(iu2sn+imin-1)*b22d(imin+1)
              b22d(imin+1) = work(iu2cs+imin-1)*b22d(imin+1)
              ! inner loop: chase bulges from b11(imin,imin+2),
              ! b12(imin,imin+1), b21(imin,imin+2), and b22(imin,imin+1) to
              ! bottom-right
              do i = imin+1, imax-1
                 ! compute phi(i-1)
                 x1 = sin(theta(i-1))*b11e(i-1) + cos(theta(i-1))*b21e(i-1)
                 x2 = sin(theta(i-1))*b11bulge + cos(theta(i-1))*b21bulge
                 y1 = sin(theta(i-1))*b12d(i-1) + cos(theta(i-1))*b22d(i-1)
                 y2 = sin(theta(i-1))*b12bulge + cos(theta(i-1))*b22bulge
                 phi(i-1) = atan2( sqrt(x1**2+x2**2), sqrt(y1**2+y2**2) )
                 ! determine if there are bulges to chase or if a new direct
                 ! summand has been reached
                 restart11 = b11e(i-1)**2 + b11bulge**2 <= thresh**2
                 restart21 = b21e(i-1)**2 + b21bulge**2 <= thresh**2
                 restart12 = b12d(i-1)**2 + b12bulge**2 <= thresh**2
                 restart22 = b22d(i-1)**2 + b22bulge**2 <= thresh**2
                 ! if possible, chase bulges from b11(i-1,i+1), b12(i-1,i),
                 ! b21(i-1,i+1), and b22(i-1,i). if necessary, restart bulge-
                 ! chasing by applying the original shift again.
                 if( .not. restart11 .and. .not. restart21 ) then
                    call stdlib_${ri}$lartgp( x2, x1, work(iv1tsn+i-1), work(iv1tcs+i-1),r )
                 else if( .not. restart11 .and. restart21 ) then
                    call stdlib_${ri}$lartgp( b11bulge, b11e(i-1), work(iv1tsn+i-1),work(iv1tcs+i-1), &
                              r )
                 else if( restart11 .and. .not. restart21 ) then
                    call stdlib_${ri}$lartgp( b21bulge, b21e(i-1), work(iv1tsn+i-1),work(iv1tcs+i-1), &
                              r )
                 else if( mu <= nu ) then
                    call stdlib_${ri}$lartgs( b11d(i), b11e(i), mu, work(iv1tcs+i-1),work(iv1tsn+i-1) )
                              
                 else
                    call stdlib_${ri}$lartgs( b21d(i), b21e(i), nu, work(iv1tcs+i-1),work(iv1tsn+i-1) )
                              
                 end if
                 work(iv1tcs+i-1) = -work(iv1tcs+i-1)
                 work(iv1tsn+i-1) = -work(iv1tsn+i-1)
                 if( .not. restart12 .and. .not. restart22 ) then
                    call stdlib_${ri}$lartgp( y2, y1, work(iv2tsn+i-1-1),work(iv2tcs+i-1-1), r )
                              
                 else if( .not. restart12 .and. restart22 ) then
                    call stdlib_${ri}$lartgp( b12bulge, b12d(i-1), work(iv2tsn+i-1-1),work(iv2tcs+i-1-&
                              1), r )
                 else if( restart12 .and. .not. restart22 ) then
                    call stdlib_${ri}$lartgp( b22bulge, b22d(i-1), work(iv2tsn+i-1-1),work(iv2tcs+i-1-&
                              1), r )
                 else if( nu < mu ) then
                    call stdlib_${ri}$lartgs( b12e(i-1), b12d(i), nu, work(iv2tcs+i-1-1),work(iv2tsn+i-&
                              1-1) )
                 else
                    call stdlib_${ri}$lartgs( b22e(i-1), b22d(i), mu, work(iv2tcs+i-1-1),work(iv2tsn+i-&
                              1-1) )
                 end if
                 temp = work(iv1tcs+i-1)*b11d(i) + work(iv1tsn+i-1)*b11e(i)
                 b11e(i) = work(iv1tcs+i-1)*b11e(i) -work(iv1tsn+i-1)*b11d(i)
                 b11d(i) = temp
                 b11bulge = work(iv1tsn+i-1)*b11d(i+1)
                 b11d(i+1) = work(iv1tcs+i-1)*b11d(i+1)
                 temp = work(iv1tcs+i-1)*b21d(i) + work(iv1tsn+i-1)*b21e(i)
                 b21e(i) = work(iv1tcs+i-1)*b21e(i) -work(iv1tsn+i-1)*b21d(i)
                 b21d(i) = temp
                 b21bulge = work(iv1tsn+i-1)*b21d(i+1)
                 b21d(i+1) = work(iv1tcs+i-1)*b21d(i+1)
                 temp = work(iv2tcs+i-1-1)*b12e(i-1) +work(iv2tsn+i-1-1)*b12d(i)
                 b12d(i) = work(iv2tcs+i-1-1)*b12d(i) -work(iv2tsn+i-1-1)*b12e(i-1)
                 b12e(i-1) = temp
                 b12bulge = work(iv2tsn+i-1-1)*b12e(i)
                 b12e(i) = work(iv2tcs+i-1-1)*b12e(i)
                 temp = work(iv2tcs+i-1-1)*b22e(i-1) +work(iv2tsn+i-1-1)*b22d(i)
                 b22d(i) = work(iv2tcs+i-1-1)*b22d(i) -work(iv2tsn+i-1-1)*b22e(i-1)
                 b22e(i-1) = temp
                 b22bulge = work(iv2tsn+i-1-1)*b22e(i)
                 b22e(i) = work(iv2tcs+i-1-1)*b22e(i)
                 ! compute theta(i)
                 x1 = cos(phi(i-1))*b11d(i) + sin(phi(i-1))*b12e(i-1)
                 x2 = cos(phi(i-1))*b11bulge + sin(phi(i-1))*b12bulge
                 y1 = cos(phi(i-1))*b21d(i) + sin(phi(i-1))*b22e(i-1)
                 y2 = cos(phi(i-1))*b21bulge + sin(phi(i-1))*b22bulge
                 theta(i) = atan2( sqrt(y1**2+y2**2), sqrt(x1**2+x2**2) )
                 ! determine if there are bulges to chase or if a new direct
                 ! summand has been reached
                 restart11 =   b11d(i)**2 + b11bulge**2 <= thresh**2
                 restart12 = b12e(i-1)**2 + b12bulge**2 <= thresh**2
                 restart21 =   b21d(i)**2 + b21bulge**2 <= thresh**2
                 restart22 = b22e(i-1)**2 + b22bulge**2 <= thresh**2
                 ! if possible, chase bulges from b11(i+1,i), b12(i+1,i-1),
                 ! b21(i+1,i), and b22(i+1,i-1). if necessary, restart bulge-
                 ! chasing by applying the original shift again.
                 if( .not. restart11 .and. .not. restart12 ) then
                    call stdlib_${ri}$lartgp( x2, x1, work(iu1sn+i-1), work(iu1cs+i-1),r )
                 else if( .not. restart11 .and. restart12 ) then
                    call stdlib_${ri}$lartgp( b11bulge, b11d(i), work(iu1sn+i-1),work(iu1cs+i-1), r )
                              
                 else if( restart11 .and. .not. restart12 ) then
                    call stdlib_${ri}$lartgp( b12bulge, b12e(i-1), work(iu1sn+i-1),work(iu1cs+i-1), r )
                              
                 else if( mu <= nu ) then
                    call stdlib_${ri}$lartgs( b11e(i), b11d(i+1), mu, work(iu1cs+i-1),work(iu1sn+i-1) )
                              
                 else
                    call stdlib_${ri}$lartgs( b12d(i), b12e(i), nu, work(iu1cs+i-1),work(iu1sn+i-1) )
                              
                 end if
                 if( .not. restart21 .and. .not. restart22 ) then
                    call stdlib_${ri}$lartgp( y2, y1, work(iu2sn+i-1), work(iu2cs+i-1),r )
                 else if( .not. restart21 .and. restart22 ) then
                    call stdlib_${ri}$lartgp( b21bulge, b21d(i), work(iu2sn+i-1),work(iu2cs+i-1), r )
                              
                 else if( restart21 .and. .not. restart22 ) then
                    call stdlib_${ri}$lartgp( b22bulge, b22e(i-1), work(iu2sn+i-1),work(iu2cs+i-1), r )
                              
                 else if( nu < mu ) then
                    call stdlib_${ri}$lartgs( b21e(i), b21e(i+1), nu, work(iu2cs+i-1),work(iu2sn+i-1) )
                              
                 else
                    call stdlib_${ri}$lartgs( b22d(i), b22e(i), mu, work(iu2cs+i-1),work(iu2sn+i-1) )
                              
                 end if
                 work(iu2cs+i-1) = -work(iu2cs+i-1)
                 work(iu2sn+i-1) = -work(iu2sn+i-1)
                 temp = work(iu1cs+i-1)*b11e(i) + work(iu1sn+i-1)*b11d(i+1)
                 b11d(i+1) = work(iu1cs+i-1)*b11d(i+1) -work(iu1sn+i-1)*b11e(i)
                 b11e(i) = temp
                 if( i < imax - 1 ) then
                    b11bulge = work(iu1sn+i-1)*b11e(i+1)
                    b11e(i+1) = work(iu1cs+i-1)*b11e(i+1)
                 end if
                 temp = work(iu2cs+i-1)*b21e(i) + work(iu2sn+i-1)*b21d(i+1)
                 b21d(i+1) = work(iu2cs+i-1)*b21d(i+1) -work(iu2sn+i-1)*b21e(i)
                 b21e(i) = temp
                 if( i < imax - 1 ) then
                    b21bulge = work(iu2sn+i-1)*b21e(i+1)
                    b21e(i+1) = work(iu2cs+i-1)*b21e(i+1)
                 end if
                 temp = work(iu1cs+i-1)*b12d(i) + work(iu1sn+i-1)*b12e(i)
                 b12e(i) = work(iu1cs+i-1)*b12e(i) - work(iu1sn+i-1)*b12d(i)
                 b12d(i) = temp
                 b12bulge = work(iu1sn+i-1)*b12d(i+1)
                 b12d(i+1) = work(iu1cs+i-1)*b12d(i+1)
                 temp = work(iu2cs+i-1)*b22d(i) + work(iu2sn+i-1)*b22e(i)
                 b22e(i) = work(iu2cs+i-1)*b22e(i) - work(iu2sn+i-1)*b22d(i)
                 b22d(i) = temp
                 b22bulge = work(iu2sn+i-1)*b22d(i+1)
                 b22d(i+1) = work(iu2cs+i-1)*b22d(i+1)
              end do
              ! compute phi(imax-1)
              x1 = sin(theta(imax-1))*b11e(imax-1) +cos(theta(imax-1))*b21e(imax-1)
              y1 = sin(theta(imax-1))*b12d(imax-1) +cos(theta(imax-1))*b22d(imax-1)
              y2 = sin(theta(imax-1))*b12bulge + cos(theta(imax-1))*b22bulge
              phi(imax-1) = atan2( abs(x1), sqrt(y1**2+y2**2) )
              ! chase bulges from b12(imax-1,imax) and b22(imax-1,imax)
              restart12 = b12d(imax-1)**2 + b12bulge**2 <= thresh**2
              restart22 = b22d(imax-1)**2 + b22bulge**2 <= thresh**2
              if( .not. restart12 .and. .not. restart22 ) then
                 call stdlib_${ri}$lartgp( y2, y1, work(iv2tsn+imax-1-1),work(iv2tcs+imax-1-1), r )
                           
              else if( .not. restart12 .and. restart22 ) then
                 call stdlib_${ri}$lartgp( b12bulge, b12d(imax-1), work(iv2tsn+imax-1-1),work(iv2tcs+&
                           imax-1-1), r )
              else if( restart12 .and. .not. restart22 ) then
                 call stdlib_${ri}$lartgp( b22bulge, b22d(imax-1), work(iv2tsn+imax-1-1),work(iv2tcs+&
                           imax-1-1), r )
              else if( nu < mu ) then
                 call stdlib_${ri}$lartgs( b12e(imax-1), b12d(imax), nu,work(iv2tcs+imax-1-1), work(&
                           iv2tsn+imax-1-1) )
              else
                 call stdlib_${ri}$lartgs( b22e(imax-1), b22d(imax), mu,work(iv2tcs+imax-1-1), work(&
                           iv2tsn+imax-1-1) )
              end if
              temp = work(iv2tcs+imax-1-1)*b12e(imax-1) +work(iv2tsn+imax-1-1)*b12d(imax)
              b12d(imax) = work(iv2tcs+imax-1-1)*b12d(imax) -work(iv2tsn+imax-1-1)*b12e(imax-1)
                        
              b12e(imax-1) = temp
              temp = work(iv2tcs+imax-1-1)*b22e(imax-1) +work(iv2tsn+imax-1-1)*b22d(imax)
              b22d(imax) = work(iv2tcs+imax-1-1)*b22d(imax) -work(iv2tsn+imax-1-1)*b22e(imax-1)
                        
              b22e(imax-1) = temp
              ! update singular vectors
              if( wantu1 ) then
                 if( colmajor ) then
                    call stdlib_${ri}$lasr( 'R', 'V', 'F', p, imax-imin+1,work(iu1cs+imin-1), work(&
                              iu1sn+imin-1),u1(1,imin), ldu1 )
                 else
                    call stdlib_${ri}$lasr( 'L', 'V', 'F', imax-imin+1, p,work(iu1cs+imin-1), work(&
                              iu1sn+imin-1),u1(imin,1), ldu1 )
                 end if
              end if
              if( wantu2 ) then
                 if( colmajor ) then
                    call stdlib_${ri}$lasr( 'R', 'V', 'F', m-p, imax-imin+1,work(iu2cs+imin-1), work(&
                              iu2sn+imin-1),u2(1,imin), ldu2 )
                 else
                    call stdlib_${ri}$lasr( 'L', 'V', 'F', imax-imin+1, m-p,work(iu2cs+imin-1), work(&
                              iu2sn+imin-1),u2(imin,1), ldu2 )
                 end if
              end if
              if( wantv1t ) then
                 if( colmajor ) then
                    call stdlib_${ri}$lasr( 'L', 'V', 'F', imax-imin+1, q,work(iv1tcs+imin-1), work(&
                              iv1tsn+imin-1),v1t(imin,1), ldv1t )
                 else
                    call stdlib_${ri}$lasr( 'R', 'V', 'F', q, imax-imin+1,work(iv1tcs+imin-1), work(&
                              iv1tsn+imin-1),v1t(1,imin), ldv1t )
                 end if
              end if
              if( wantv2t ) then
                 if( colmajor ) then
                    call stdlib_${ri}$lasr( 'L', 'V', 'F', imax-imin+1, m-q,work(iv2tcs+imin-1), work(&
                              iv2tsn+imin-1),v2t(imin,1), ldv2t )
                 else
                    call stdlib_${ri}$lasr( 'R', 'V', 'F', m-q, imax-imin+1,work(iv2tcs+imin-1), work(&
                              iv2tsn+imin-1),v2t(1,imin), ldv2t )
                 end if
              end if
              ! fix signs on b11(imax-1,imax) and b21(imax-1,imax)
              if( b11e(imax-1)+b21e(imax-1) > 0 ) then
                 b11d(imax) = -b11d(imax)
                 b21d(imax) = -b21d(imax)
                 if( wantv1t ) then
                    if( colmajor ) then
                       call stdlib_${ri}$scal( q, negone, v1t(imax,1), ldv1t )
                    else
                       call stdlib_${ri}$scal( q, negone, v1t(1,imax), 1 )
                    end if
                 end if
              end if
              ! compute theta(imax)
              x1 = cos(phi(imax-1))*b11d(imax) +sin(phi(imax-1))*b12e(imax-1)
              y1 = cos(phi(imax-1))*b21d(imax) +sin(phi(imax-1))*b22e(imax-1)
              theta(imax) = atan2( abs(y1), abs(x1) )
              ! fix signs on b11(imax,imax), b12(imax,imax-1), b21(imax,imax),
              ! and b22(imax,imax-1)
              if( b11d(imax)+b12e(imax-1) < 0 ) then
                 b12d(imax) = -b12d(imax)
                 if( wantu1 ) then
                    if( colmajor ) then
                       call stdlib_${ri}$scal( p, negone, u1(1,imax), 1 )
                    else
                       call stdlib_${ri}$scal( p, negone, u1(imax,1), ldu1 )
                    end if
                 end if
              end if
              if( b21d(imax)+b22e(imax-1) > 0 ) then
                 b22d(imax) = -b22d(imax)
                 if( wantu2 ) then
                    if( colmajor ) then
                       call stdlib_${ri}$scal( m-p, negone, u2(1,imax), 1 )
                    else
                       call stdlib_${ri}$scal( m-p, negone, u2(imax,1), ldu2 )
                    end if
                 end if
              end if
              ! fix signs on b12(imax,imax) and b22(imax,imax)
              if( b12d(imax)+b22d(imax) < 0 ) then
                 if( wantv2t ) then
                    if( colmajor ) then
                       call stdlib_${ri}$scal( m-q, negone, v2t(imax,1), ldv2t )
                    else
                       call stdlib_${ri}$scal( m-q, negone, v2t(1,imax), 1 )
                    end if
                 end if
              end if
              ! test for negligible sines or cosines
              do i = imin, imax
                 if( theta(i) < thresh ) then
                    theta(i) = zero
                 else if( theta(i) > piover2-thresh ) then
                    theta(i) = piover2
                 end if
              end do
              do i = imin, imax-1
                 if( phi(i) < thresh ) then
                    phi(i) = zero
                 else if( phi(i) > piover2-thresh ) then
                    phi(i) = piover2
                 end if
              end do
              ! deflate
              if (imax > 1) then
                 do while( phi(imax-1) == zero )
                    imax = imax - 1
                    if (imax <= 1) exit
                 end do
              end if
              if( imin > imax - 1 )imin = imax - 1
              if (imin > 1) then
                 do while (phi(imin-1) /= zero)
                     imin = imin - 1
                     if (imin <= 1) exit
                 end do
              end if
              ! repeat main iteration loop
           end do
           ! postprocessing: order theta from least to greatest
           do i = 1, q
              mini = i
              thetamin = theta(i)
              do j = i+1, q
                 if( theta(j) < thetamin ) then
                    mini = j
                    thetamin = theta(j)
                 end if
              end do
              if( mini /= i ) then
                 theta(mini) = theta(i)
                 theta(i) = thetamin
                 if( colmajor ) then
                    if( wantu1 )call stdlib_${ri}$swap( p, u1(1,i), 1, u1(1,mini), 1 )
                    if( wantu2 )call stdlib_${ri}$swap( m-p, u2(1,i), 1, u2(1,mini), 1 )
                    if( wantv1t )call stdlib_${ri}$swap( q, v1t(i,1), ldv1t, v1t(mini,1), ldv1t )
                              
                    if( wantv2t )call stdlib_${ri}$swap( m-q, v2t(i,1), ldv2t, v2t(mini,1),ldv2t )
                              
                 else
                    if( wantu1 )call stdlib_${ri}$swap( p, u1(i,1), ldu1, u1(mini,1), ldu1 )
                    if( wantu2 )call stdlib_${ri}$swap( m-p, u2(i,1), ldu2, u2(mini,1), ldu2 )
                    if( wantv1t )call stdlib_${ri}$swap( q, v1t(1,i), 1, v1t(1,mini), 1 )
                    if( wantv2t )call stdlib_${ri}$swap( m-q, v2t(1,i), 1, v2t(1,mini), 1 )
                 end if
              end if
           end do
           return
     end subroutine stdlib_${ri}$bbcsd

#:endif
#:endfor

     pure subroutine stdlib_cbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, u1, &
     ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d, b22e, rwork, &
               lrwork, info )
     !! CBBCSD computes the CS decomposition of a unitary matrix in
     !! bidiagonal-block form,
     !! [ B11 | B12 0  0 ]
     !! [  0  |  0 -I  0 ]
     !! X = [----------------]
     !! [ B21 | B22 0  0 ]
     !! [  0  |  0  0  I ]
     !! [  C | -S  0  0 ]
     !! [ U1 |    ] [  0 |  0 -I  0 ] [ V1 |    ]**H
     !! = [---------] [---------------] [---------]   .
     !! [    | U2 ] [  S |  C  0  0 ] [    | V2 ]
     !! [  0 |  0  0  I ]
     !! X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
     !! than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
     !! transposed and/or permuted. This can be done in constant time using
     !! the TRANS and SIGNS options. See CUNCSD for details.)
     !! The bidiagonal matrices B11, B12, B21, and B22 are represented
     !! implicitly by angles THETA(1:Q) and PHI(1:Q-1).
     !! The unitary matrices U1, U2, V1T, and V2T are input/output.
     !! The input matrices are pre- or post-multiplied by the appropriate
     !! singular vector matrices.
     
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero
           ! Scalar Arguments 
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, lrwork, m, p, q
           ! Array Arguments 
           real(sp), intent(out) :: b11d(*), b11e(*), b12d(*), b12e(*), b21d(*), b21e(*), b22d(*),&
                      b22e(*), rwork(*)
           real(sp), intent(inout) :: phi(*), theta(*)
           complex(sp), intent(inout) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*)
                     
        ! ===================================================================
           ! Parameters 
           integer(ilp), parameter :: maxitr = 6
           real(sp), parameter :: hundred = 100.0_sp
           real(sp), parameter :: meighth = -0.125_sp
           real(sp), parameter :: piover2 = 1.57079632679489661923132169163975144210_sp
           
           
           
           
           ! Local Scalars 
           logical(lk) :: colmajor, lquery, restart11, restart12, restart21, restart22, wantu1, &
                     wantu2, wantv1t, wantv2t
           integer(ilp) :: i, imin, imax, iter, iu1cs, iu1sn, iu2cs, iu2sn, iv1tcs, iv1tsn, &
                     iv2tcs, iv2tsn, j, lrworkmin, lrworkopt, maxit, mini
           real(sp) :: b11bulge, b12bulge, b21bulge, b22bulge, dummy, eps, mu, nu, r, sigma11, &
                     sigma21, temp, thetamax, thetamin, thresh, tol, tolmul, unfl, x1, x2, y1, y2
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test input arguments
           info = 0
           lquery = lrwork == -1
           wantu1 = stdlib_lsame( jobu1, 'Y' )
           wantu2 = stdlib_lsame( jobu2, 'Y' )
           wantv1t = stdlib_lsame( jobv1t, 'Y' )
           wantv2t = stdlib_lsame( jobv2t, 'Y' )
           colmajor = .not. stdlib_lsame( trans, 'T' )
           if( m < 0 ) then
              info = -6
           else if( p < 0 .or. p > m ) then
              info = -7
           else if( q < 0 .or. q > m ) then
              info = -8
           else if( q > p .or. q > m-p .or. q > m-q ) then
              info = -8
           else if( wantu1 .and. ldu1 < p ) then
              info = -12
           else if( wantu2 .and. ldu2 < m-p ) then
              info = -14
           else if( wantv1t .and. ldv1t < q ) then
              info = -16
           else if( wantv2t .and. ldv2t < m-q ) then
              info = -18
           end if
           ! quick return if q = 0
           if( info == 0 .and. q == 0 ) then
              lrworkmin = 1
              rwork(1) = lrworkmin
              return
           end if
           ! compute workspace
           if( info == 0 ) then
              iu1cs = 1
              iu1sn = iu1cs + q
              iu2cs = iu1sn + q
              iu2sn = iu2cs + q
              iv1tcs = iu2sn + q
              iv1tsn = iv1tcs + q
              iv2tcs = iv1tsn + q
              iv2tsn = iv2tcs + q
              lrworkopt = iv2tsn + q - 1
              lrworkmin = lrworkopt
              rwork(1) = lrworkopt
              if( lrwork < lrworkmin .and. .not. lquery ) then
                 info = -28
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'CBBCSD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'EPSILON' )
           unfl = stdlib_slamch( 'SAFE MINIMUM' )
           tolmul = max( ten, min( hundred, eps**meighth ) )
           tol = tolmul*eps
           thresh = max( tol, maxitr*q*q*unfl )
           ! test for negligible sines or cosines
           do i = 1, q
              if( theta(i) < thresh ) then
                 theta(i) = zero
              else if( theta(i) > piover2-thresh ) then
                 theta(i) = piover2
              end if
           end do
           do i = 1, q-1
              if( phi(i) < thresh ) then
                 phi(i) = zero
              else if( phi(i) > piover2-thresh ) then
                 phi(i) = piover2
              end if
           end do
           ! initial deflation
           imax = q
           do while( imax > 1 )
              if( phi(imax-1) /= zero ) then
                 exit
              end if
              imax = imax - 1
           end do
           imin = imax - 1
           if  ( imin > 1 ) then
              do while( phi(imin-1) /= zero )
                 imin = imin - 1
                 if  ( imin <= 1 ) exit
              end do
           end if
           ! initialize iteration counter
           maxit = maxitr*q*q
           iter = 0
           ! begin main iteration loop
           do while( imax > 1 )
              ! compute the matrix entries
              b11d(imin) = cos( theta(imin) )
              b21d(imin) = -sin( theta(imin) )
              do i = imin, imax - 1
                 b11e(i) = -sin( theta(i) ) * sin( phi(i) )
                 b11d(i+1) = cos( theta(i+1) ) * cos( phi(i) )
                 b12d(i) = sin( theta(i) ) * cos( phi(i) )
                 b12e(i) = cos( theta(i+1) ) * sin( phi(i) )
                 b21e(i) = -cos( theta(i) ) * sin( phi(i) )
                 b21d(i+1) = -sin( theta(i+1) ) * cos( phi(i) )
                 b22d(i) = cos( theta(i) ) * cos( phi(i) )
                 b22e(i) = -sin( theta(i+1) ) * sin( phi(i) )
              end do
              b12d(imax) = sin( theta(imax) )
              b22d(imax) = cos( theta(imax) )
              ! abort if not converging; otherwise, increment iter
              if( iter > maxit ) then
                 info = 0
                 do i = 1, q
                    if( phi(i) /= zero )info = info + 1
                 end do
                 return
              end if
              iter = iter + imax - imin
              ! compute shifts
              thetamax = theta(imin)
              thetamin = theta(imin)
              do i = imin+1, imax
                 if( theta(i) > thetamax )thetamax = theta(i)
                 if( theta(i) < thetamin )thetamin = theta(i)
              end do
              if( thetamax > piover2 - thresh ) then
                 ! zero on diagonals of b11 and b22; induce deflation with a
                 ! zero shift
                 mu = zero
                 nu = one
              else if( thetamin < thresh ) then
                 ! zero on diagonals of b12 and b22; induce deflation with a
                 ! zero shift
                 mu = one
                 nu = zero
              else
                 ! compute shifts for b11 and b21 and use the lesser
                 call stdlib_slas2( b11d(imax-1), b11e(imax-1), b11d(imax), sigma11,dummy )
                           
                 call stdlib_slas2( b21d(imax-1), b21e(imax-1), b21d(imax), sigma21,dummy )
                           
                 if( sigma11 <= sigma21 ) then
                    mu = sigma11
                    nu = sqrt( one - mu**2 )
                    if( mu < thresh ) then
                       mu = zero
                       nu = one
                    end if
                 else
                    nu = sigma21
                    mu = sqrt( 1.0_sp - nu**2 )
                    if( nu < thresh ) then
                       mu = one
                       nu = zero
                    end if
                 end if
              end if
              ! rotate to produce bulges in b11 and b21
              if( mu <= nu ) then
                 call stdlib_slartgs( b11d(imin), b11e(imin), mu,rwork(iv1tcs+imin-1), rwork(&
                           iv1tsn+imin-1) )
              else
                 call stdlib_slartgs( b21d(imin), b21e(imin), nu,rwork(iv1tcs+imin-1), rwork(&
                           iv1tsn+imin-1) )
              end if
              temp = rwork(iv1tcs+imin-1)*b11d(imin) +rwork(iv1tsn+imin-1)*b11e(imin)
              b11e(imin) = rwork(iv1tcs+imin-1)*b11e(imin) -rwork(iv1tsn+imin-1)*b11d(imin)
                        
              b11d(imin) = temp
              b11bulge = rwork(iv1tsn+imin-1)*b11d(imin+1)
              b11d(imin+1) = rwork(iv1tcs+imin-1)*b11d(imin+1)
              temp = rwork(iv1tcs+imin-1)*b21d(imin) +rwork(iv1tsn+imin-1)*b21e(imin)
              b21e(imin) = rwork(iv1tcs+imin-1)*b21e(imin) -rwork(iv1tsn+imin-1)*b21d(imin)
                        
              b21d(imin) = temp
              b21bulge = rwork(iv1tsn+imin-1)*b21d(imin+1)
              b21d(imin+1) = rwork(iv1tcs+imin-1)*b21d(imin+1)
              ! compute theta(imin)
              theta( imin ) = atan2( sqrt( b21d(imin)**2+b21bulge**2 ),sqrt( b11d(imin)**2+&
                        b11bulge**2 ) )
              ! chase the bulges in b11(imin+1,imin) and b21(imin+1,imin)
              if( b11d(imin)**2+b11bulge**2 > thresh**2 ) then
                 call stdlib_slartgp( b11bulge, b11d(imin), rwork(iu1sn+imin-1),rwork(iu1cs+imin-&
                           1), r )
              else if( mu <= nu ) then
                 call stdlib_slartgs( b11e( imin ), b11d( imin + 1 ), mu,rwork(iu1cs+imin-1), &
                           rwork(iu1sn+imin-1) )
              else
                 call stdlib_slartgs( b12d( imin ), b12e( imin ), nu,rwork(iu1cs+imin-1), rwork(&
                           iu1sn+imin-1) )
              end if
              if( b21d(imin)**2+b21bulge**2 > thresh**2 ) then
                 call stdlib_slartgp( b21bulge, b21d(imin), rwork(iu2sn+imin-1),rwork(iu2cs+imin-&
                           1), r )
              else if( nu < mu ) then
                 call stdlib_slartgs( b21e( imin ), b21d( imin + 1 ), nu,rwork(iu2cs+imin-1), &
                           rwork(iu2sn+imin-1) )
              else
                 call stdlib_slartgs( b22d(imin), b22e(imin), mu,rwork(iu2cs+imin-1), rwork(iu2sn+&
                           imin-1) )
              end if
              rwork(iu2cs+imin-1) = -rwork(iu2cs+imin-1)
              rwork(iu2sn+imin-1) = -rwork(iu2sn+imin-1)
              temp = rwork(iu1cs+imin-1)*b11e(imin) +rwork(iu1sn+imin-1)*b11d(imin+1)
              b11d(imin+1) = rwork(iu1cs+imin-1)*b11d(imin+1) -rwork(iu1sn+imin-1)*b11e(imin)
                        
              b11e(imin) = temp
              if( imax > imin+1 ) then
                 b11bulge = rwork(iu1sn+imin-1)*b11e(imin+1)
                 b11e(imin+1) = rwork(iu1cs+imin-1)*b11e(imin+1)
              end if
              temp = rwork(iu1cs+imin-1)*b12d(imin) +rwork(iu1sn+imin-1)*b12e(imin)
              b12e(imin) = rwork(iu1cs+imin-1)*b12e(imin) -rwork(iu1sn+imin-1)*b12d(imin)
              b12d(imin) = temp
              b12bulge = rwork(iu1sn+imin-1)*b12d(imin+1)
              b12d(imin+1) = rwork(iu1cs+imin-1)*b12d(imin+1)
              temp = rwork(iu2cs+imin-1)*b21e(imin) +rwork(iu2sn+imin-1)*b21d(imin+1)
              b21d(imin+1) = rwork(iu2cs+imin-1)*b21d(imin+1) -rwork(iu2sn+imin-1)*b21e(imin)
                        
              b21e(imin) = temp
              if( imax > imin+1 ) then
                 b21bulge = rwork(iu2sn+imin-1)*b21e(imin+1)
                 b21e(imin+1) = rwork(iu2cs+imin-1)*b21e(imin+1)
              end if
              temp = rwork(iu2cs+imin-1)*b22d(imin) +rwork(iu2sn+imin-1)*b22e(imin)
              b22e(imin) = rwork(iu2cs+imin-1)*b22e(imin) -rwork(iu2sn+imin-1)*b22d(imin)
              b22d(imin) = temp
              b22bulge = rwork(iu2sn+imin-1)*b22d(imin+1)
              b22d(imin+1) = rwork(iu2cs+imin-1)*b22d(imin+1)
              ! inner loop: chase bulges from b11(imin,imin+2),
              ! b12(imin,imin+1), b21(imin,imin+2), and b22(imin,imin+1) to
              ! bottom-right
              do i = imin+1, imax-1
                 ! compute phi(i-1)
                 x1 = sin(theta(i-1))*b11e(i-1) + cos(theta(i-1))*b21e(i-1)
                 x2 = sin(theta(i-1))*b11bulge + cos(theta(i-1))*b21bulge
                 y1 = sin(theta(i-1))*b12d(i-1) + cos(theta(i-1))*b22d(i-1)
                 y2 = sin(theta(i-1))*b12bulge + cos(theta(i-1))*b22bulge
                 phi(i-1) = atan2( sqrt(x1**2+x2**2), sqrt(y1**2+y2**2) )
                 ! determine if there are bulges to chase or if a new direct
                 ! summand has been reached
                 restart11 = b11e(i-1)**2 + b11bulge**2 <= thresh**2
                 restart21 = b21e(i-1)**2 + b21bulge**2 <= thresh**2
                 restart12 = b12d(i-1)**2 + b12bulge**2 <= thresh**2
                 restart22 = b22d(i-1)**2 + b22bulge**2 <= thresh**2
                 ! if possible, chase bulges from b11(i-1,i+1), b12(i-1,i),
                 ! b21(i-1,i+1), and b22(i-1,i). if necessary, restart bulge-
                 ! chasing by applying the original shift again.
                 if( .not. restart11 .and. .not. restart21 ) then
                    call stdlib_slartgp( x2, x1, rwork(iv1tsn+i-1),rwork(iv1tcs+i-1), r )
                 else if( .not. restart11 .and. restart21 ) then
                    call stdlib_slartgp( b11bulge, b11e(i-1), rwork(iv1tsn+i-1),rwork(iv1tcs+i-1),&
                               r )
                 else if( restart11 .and. .not. restart21 ) then
                    call stdlib_slartgp( b21bulge, b21e(i-1), rwork(iv1tsn+i-1),rwork(iv1tcs+i-1),&
                               r )
                 else if( mu <= nu ) then
                    call stdlib_slartgs( b11d(i), b11e(i), mu, rwork(iv1tcs+i-1),rwork(iv1tsn+i-1)&
                               )
                 else
                    call stdlib_slartgs( b21d(i), b21e(i), nu, rwork(iv1tcs+i-1),rwork(iv1tsn+i-1)&
                               )
                 end if
                 rwork(iv1tcs+i-1) = -rwork(iv1tcs+i-1)
                 rwork(iv1tsn+i-1) = -rwork(iv1tsn+i-1)
                 if( .not. restart12 .and. .not. restart22 ) then
                    call stdlib_slartgp( y2, y1, rwork(iv2tsn+i-1-1),rwork(iv2tcs+i-1-1), r )
                              
                 else if( .not. restart12 .and. restart22 ) then
                    call stdlib_slartgp( b12bulge, b12d(i-1), rwork(iv2tsn+i-1-1),rwork(iv2tcs+i-&
                              1-1), r )
                 else if( restart12 .and. .not. restart22 ) then
                    call stdlib_slartgp( b22bulge, b22d(i-1), rwork(iv2tsn+i-1-1),rwork(iv2tcs+i-&
                              1-1), r )
                 else if( nu < mu ) then
                    call stdlib_slartgs( b12e(i-1), b12d(i), nu,rwork(iv2tcs+i-1-1), rwork(iv2tsn+&
                              i-1-1) )
                 else
                    call stdlib_slartgs( b22e(i-1), b22d(i), mu,rwork(iv2tcs+i-1-1), rwork(iv2tsn+&
                              i-1-1) )
                 end if
                 temp = rwork(iv1tcs+i-1)*b11d(i) + rwork(iv1tsn+i-1)*b11e(i)
                 b11e(i) = rwork(iv1tcs+i-1)*b11e(i) -rwork(iv1tsn+i-1)*b11d(i)
                 b11d(i) = temp
                 b11bulge = rwork(iv1tsn+i-1)*b11d(i+1)
                 b11d(i+1) = rwork(iv1tcs+i-1)*b11d(i+1)
                 temp = rwork(iv1tcs+i-1)*b21d(i) + rwork(iv1tsn+i-1)*b21e(i)
                 b21e(i) = rwork(iv1tcs+i-1)*b21e(i) -rwork(iv1tsn+i-1)*b21d(i)
                 b21d(i) = temp
                 b21bulge = rwork(iv1tsn+i-1)*b21d(i+1)
                 b21d(i+1) = rwork(iv1tcs+i-1)*b21d(i+1)
                 temp = rwork(iv2tcs+i-1-1)*b12e(i-1) +rwork(iv2tsn+i-1-1)*b12d(i)
                 b12d(i) = rwork(iv2tcs+i-1-1)*b12d(i) -rwork(iv2tsn+i-1-1)*b12e(i-1)
                 b12e(i-1) = temp
                 b12bulge = rwork(iv2tsn+i-1-1)*b12e(i)
                 b12e(i) = rwork(iv2tcs+i-1-1)*b12e(i)
                 temp = rwork(iv2tcs+i-1-1)*b22e(i-1) +rwork(iv2tsn+i-1-1)*b22d(i)
                 b22d(i) = rwork(iv2tcs+i-1-1)*b22d(i) -rwork(iv2tsn+i-1-1)*b22e(i-1)
                 b22e(i-1) = temp
                 b22bulge = rwork(iv2tsn+i-1-1)*b22e(i)
                 b22e(i) = rwork(iv2tcs+i-1-1)*b22e(i)
                 ! compute theta(i)
                 x1 = cos(phi(i-1))*b11d(i) + sin(phi(i-1))*b12e(i-1)
                 x2 = cos(phi(i-1))*b11bulge + sin(phi(i-1))*b12bulge
                 y1 = cos(phi(i-1))*b21d(i) + sin(phi(i-1))*b22e(i-1)
                 y2 = cos(phi(i-1))*b21bulge + sin(phi(i-1))*b22bulge
                 theta(i) = atan2( sqrt(y1**2+y2**2), sqrt(x1**2+x2**2) )
                 ! determine if there are bulges to chase or if a new direct
                 ! summand has been reached
                 restart11 =   b11d(i)**2 + b11bulge**2 <= thresh**2
                 restart12 = b12e(i-1)**2 + b12bulge**2 <= thresh**2
                 restart21 =   b21d(i)**2 + b21bulge**2 <= thresh**2
                 restart22 = b22e(i-1)**2 + b22bulge**2 <= thresh**2
                 ! if possible, chase bulges from b11(i+1,i), b12(i+1,i-1),
                 ! b21(i+1,i), and b22(i+1,i-1). if necessary, restart bulge-
                 ! chasing by applying the original shift again.
                 if( .not. restart11 .and. .not. restart12 ) then
                    call stdlib_slartgp( x2, x1, rwork(iu1sn+i-1), rwork(iu1cs+i-1),r )
                 else if( .not. restart11 .and. restart12 ) then
                    call stdlib_slartgp( b11bulge, b11d(i), rwork(iu1sn+i-1),rwork(iu1cs+i-1), r )
                              
                 else if( restart11 .and. .not. restart12 ) then
                    call stdlib_slartgp( b12bulge, b12e(i-1), rwork(iu1sn+i-1),rwork(iu1cs+i-1), &
                              r )
                 else if( mu <= nu ) then
                    call stdlib_slartgs( b11e(i), b11d(i+1), mu, rwork(iu1cs+i-1),rwork(iu1sn+i-1)&
                               )
                 else
                    call stdlib_slartgs( b12d(i), b12e(i), nu, rwork(iu1cs+i-1),rwork(iu1sn+i-1) )
                              
                 end if
                 if( .not. restart21 .and. .not. restart22 ) then
                    call stdlib_slartgp( y2, y1, rwork(iu2sn+i-1), rwork(iu2cs+i-1),r )
                 else if( .not. restart21 .and. restart22 ) then
                    call stdlib_slartgp( b21bulge, b21d(i), rwork(iu2sn+i-1),rwork(iu2cs+i-1), r )
                              
                 else if( restart21 .and. .not. restart22 ) then
                    call stdlib_slartgp( b22bulge, b22e(i-1), rwork(iu2sn+i-1),rwork(iu2cs+i-1), &
                              r )
                 else if( nu < mu ) then
                    call stdlib_slartgs( b21e(i), b21e(i+1), nu, rwork(iu2cs+i-1),rwork(iu2sn+i-1)&
                               )
                 else
                    call stdlib_slartgs( b22d(i), b22e(i), mu, rwork(iu2cs+i-1),rwork(iu2sn+i-1) )
                              
                 end if
                 rwork(iu2cs+i-1) = -rwork(iu2cs+i-1)
                 rwork(iu2sn+i-1) = -rwork(iu2sn+i-1)
                 temp = rwork(iu1cs+i-1)*b11e(i) + rwork(iu1sn+i-1)*b11d(i+1)
                 b11d(i+1) = rwork(iu1cs+i-1)*b11d(i+1) -rwork(iu1sn+i-1)*b11e(i)
                 b11e(i) = temp
                 if( i < imax - 1 ) then
                    b11bulge = rwork(iu1sn+i-1)*b11e(i+1)
                    b11e(i+1) = rwork(iu1cs+i-1)*b11e(i+1)
                 end if
                 temp = rwork(iu2cs+i-1)*b21e(i) + rwork(iu2sn+i-1)*b21d(i+1)
                 b21d(i+1) = rwork(iu2cs+i-1)*b21d(i+1) -rwork(iu2sn+i-1)*b21e(i)
                 b21e(i) = temp
                 if( i < imax - 1 ) then
                    b21bulge = rwork(iu2sn+i-1)*b21e(i+1)
                    b21e(i+1) = rwork(iu2cs+i-1)*b21e(i+1)
                 end if
                 temp = rwork(iu1cs+i-1)*b12d(i) + rwork(iu1sn+i-1)*b12e(i)
                 b12e(i) = rwork(iu1cs+i-1)*b12e(i) -rwork(iu1sn+i-1)*b12d(i)
                 b12d(i) = temp
                 b12bulge = rwork(iu1sn+i-1)*b12d(i+1)
                 b12d(i+1) = rwork(iu1cs+i-1)*b12d(i+1)
                 temp = rwork(iu2cs+i-1)*b22d(i) + rwork(iu2sn+i-1)*b22e(i)
                 b22e(i) = rwork(iu2cs+i-1)*b22e(i) -rwork(iu2sn+i-1)*b22d(i)
                 b22d(i) = temp
                 b22bulge = rwork(iu2sn+i-1)*b22d(i+1)
                 b22d(i+1) = rwork(iu2cs+i-1)*b22d(i+1)
              end do
              ! compute phi(imax-1)
              x1 = sin(theta(imax-1))*b11e(imax-1) +cos(theta(imax-1))*b21e(imax-1)
              y1 = sin(theta(imax-1))*b12d(imax-1) +cos(theta(imax-1))*b22d(imax-1)
              y2 = sin(theta(imax-1))*b12bulge + cos(theta(imax-1))*b22bulge
              phi(imax-1) = atan2( abs(x1), sqrt(y1**2+y2**2) )
              ! chase bulges from b12(imax-1,imax) and b22(imax-1,imax)
              restart12 = b12d(imax-1)**2 + b12bulge**2 <= thresh**2
              restart22 = b22d(imax-1)**2 + b22bulge**2 <= thresh**2
              if( .not. restart12 .and. .not. restart22 ) then
                 call stdlib_slartgp( y2, y1, rwork(iv2tsn+imax-1-1),rwork(iv2tcs+imax-1-1), r )
                           
              else if( .not. restart12 .and. restart22 ) then
                 call stdlib_slartgp( b12bulge, b12d(imax-1),rwork(iv2tsn+imax-1-1),rwork(iv2tcs+&
                           imax-1-1), r )
              else if( restart12 .and. .not. restart22 ) then
                 call stdlib_slartgp( b22bulge, b22d(imax-1),rwork(iv2tsn+imax-1-1),rwork(iv2tcs+&
                           imax-1-1), r )
              else if( nu < mu ) then
                 call stdlib_slartgs( b12e(imax-1), b12d(imax), nu,rwork(iv2tcs+imax-1-1),rwork(&
                           iv2tsn+imax-1-1) )
              else
                 call stdlib_slartgs( b22e(imax-1), b22d(imax), mu,rwork(iv2tcs+imax-1-1),rwork(&
                           iv2tsn+imax-1-1) )
              end if
              temp = rwork(iv2tcs+imax-1-1)*b12e(imax-1) +rwork(iv2tsn+imax-1-1)*b12d(imax)
                        
              b12d(imax) = rwork(iv2tcs+imax-1-1)*b12d(imax) -rwork(iv2tsn+imax-1-1)*b12e(imax-1)
                        
              b12e(imax-1) = temp
              temp = rwork(iv2tcs+imax-1-1)*b22e(imax-1) +rwork(iv2tsn+imax-1-1)*b22d(imax)
                        
              b22d(imax) = rwork(iv2tcs+imax-1-1)*b22d(imax) -rwork(iv2tsn+imax-1-1)*b22e(imax-1)
                        
              b22e(imax-1) = temp
              ! update singular vectors
              if( wantu1 ) then
                 if( colmajor ) then
                    call stdlib_clasr( 'R', 'V', 'F', p, imax-imin+1,rwork(iu1cs+imin-1), rwork(&
                              iu1sn+imin-1),u1(1,imin), ldu1 )
                 else
                    call stdlib_clasr( 'L', 'V', 'F', imax-imin+1, p,rwork(iu1cs+imin-1), rwork(&
                              iu1sn+imin-1),u1(imin,1), ldu1 )
                 end if
              end if
              if( wantu2 ) then
                 if( colmajor ) then
                    call stdlib_clasr( 'R', 'V', 'F', m-p, imax-imin+1,rwork(iu2cs+imin-1), rwork(&
                              iu2sn+imin-1),u2(1,imin), ldu2 )
                 else
                    call stdlib_clasr( 'L', 'V', 'F', imax-imin+1, m-p,rwork(iu2cs+imin-1), rwork(&
                              iu2sn+imin-1),u2(imin,1), ldu2 )
                 end if
              end if
              if( wantv1t ) then
                 if( colmajor ) then
                    call stdlib_clasr( 'L', 'V', 'F', imax-imin+1, q,rwork(iv1tcs+imin-1), rwork(&
                              iv1tsn+imin-1),v1t(imin,1), ldv1t )
                 else
                    call stdlib_clasr( 'R', 'V', 'F', q, imax-imin+1,rwork(iv1tcs+imin-1), rwork(&
                              iv1tsn+imin-1),v1t(1,imin), ldv1t )
                 end if
              end if
              if( wantv2t ) then
                 if( colmajor ) then
                    call stdlib_clasr( 'L', 'V', 'F', imax-imin+1, m-q,rwork(iv2tcs+imin-1), &
                              rwork(iv2tsn+imin-1),v2t(imin,1), ldv2t )
                 else
                    call stdlib_clasr( 'R', 'V', 'F', m-q, imax-imin+1,rwork(iv2tcs+imin-1), &
                              rwork(iv2tsn+imin-1),v2t(1,imin), ldv2t )
                 end if
              end if
              ! fix signs on b11(imax-1,imax) and b21(imax-1,imax)
              if( b11e(imax-1)+b21e(imax-1) > 0 ) then
                 b11d(imax) = -b11d(imax)
                 b21d(imax) = -b21d(imax)
                 if( wantv1t ) then
                    if( colmajor ) then
                       call stdlib_cscal( q, cnegone, v1t(imax,1), ldv1t )
                    else
                       call stdlib_cscal( q, cnegone, v1t(1,imax), 1 )
                    end if
                 end if
              end if
              ! compute theta(imax)
              x1 = cos(phi(imax-1))*b11d(imax) +sin(phi(imax-1))*b12e(imax-1)
              y1 = cos(phi(imax-1))*b21d(imax) +sin(phi(imax-1))*b22e(imax-1)
              theta(imax) = atan2( abs(y1), abs(x1) )
              ! fix signs on b11(imax,imax), b12(imax,imax-1), b21(imax,imax),
              ! and b22(imax,imax-1)
              if( b11d(imax)+b12e(imax-1) < 0 ) then
                 b12d(imax) = -b12d(imax)
                 if( wantu1 ) then
                    if( colmajor ) then
                       call stdlib_cscal( p, cnegone, u1(1,imax), 1 )
                    else
                       call stdlib_cscal( p, cnegone, u1(imax,1), ldu1 )
                    end if
                 end if
              end if
              if( b21d(imax)+b22e(imax-1) > 0 ) then
                 b22d(imax) = -b22d(imax)
                 if( wantu2 ) then
                    if( colmajor ) then
                       call stdlib_cscal( m-p, cnegone, u2(1,imax), 1 )
                    else
                       call stdlib_cscal( m-p, cnegone, u2(imax,1), ldu2 )
                    end if
                 end if
              end if
              ! fix signs on b12(imax,imax) and b22(imax,imax)
              if( b12d(imax)+b22d(imax) < 0 ) then
                 if( wantv2t ) then
                    if( colmajor ) then
                       call stdlib_cscal( m-q, cnegone, v2t(imax,1), ldv2t )
                    else
                       call stdlib_cscal( m-q, cnegone, v2t(1,imax), 1 )
                    end if
                 end if
              end if
              ! test for negligible sines or cosines
              do i = imin, imax
                 if( theta(i) < thresh ) then
                    theta(i) = zero
                 else if( theta(i) > piover2-thresh ) then
                    theta(i) = piover2
                 end if
              end do
              do i = imin, imax-1
                 if( phi(i) < thresh ) then
                    phi(i) = zero
                 else if( phi(i) > piover2-thresh ) then
                    phi(i) = piover2
                 end if
              end do
              ! deflate
              if (imax > 1) then
                 do while( phi(imax-1) == zero )
                    imax = imax - 1
                    if (imax <= 1) exit
                 end do
              end if
              if( imin > imax - 1 )imin = imax - 1
              if (imin > 1) then
                 do while (phi(imin-1) /= zero)
                     imin = imin - 1
                     if (imin <= 1) exit
                 end do
              end if
              ! repeat main iteration loop
           end do
           ! postprocessing: order theta from least to greatest
           do i = 1, q
              mini = i
              thetamin = theta(i)
              do j = i+1, q
                 if( theta(j) < thetamin ) then
                    mini = j
                    thetamin = theta(j)
                 end if
              end do
              if( mini /= i ) then
                 theta(mini) = theta(i)
                 theta(i) = thetamin
                 if( colmajor ) then
                    if( wantu1 )call stdlib_cswap( p, u1(1,i), 1, u1(1,mini), 1 )
                    if( wantu2 )call stdlib_cswap( m-p, u2(1,i), 1, u2(1,mini), 1 )
                    if( wantv1t )call stdlib_cswap( q, v1t(i,1), ldv1t, v1t(mini,1), ldv1t )
                              
                    if( wantv2t )call stdlib_cswap( m-q, v2t(i,1), ldv2t, v2t(mini,1),ldv2t )
                              
                 else
                    if( wantu1 )call stdlib_cswap( p, u1(i,1), ldu1, u1(mini,1), ldu1 )
                    if( wantu2 )call stdlib_cswap( m-p, u2(i,1), ldu2, u2(mini,1), ldu2 )
                    if( wantv1t )call stdlib_cswap( q, v1t(1,i), 1, v1t(1,mini), 1 )
                    if( wantv2t )call stdlib_cswap( m-q, v2t(1,i), 1, v2t(1,mini), 1 )
                 end if
              end if
           end do
           return
     end subroutine stdlib_cbbcsd

     pure subroutine stdlib_zbbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, u1, &
     ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d, b22e, rwork, &
               lrwork, info )
     !! ZBBCSD computes the CS decomposition of a unitary matrix in
     !! bidiagonal-block form,
     !! [ B11 | B12 0  0 ]
     !! [  0  |  0 -I  0 ]
     !! X = [----------------]
     !! [ B21 | B22 0  0 ]
     !! [  0  |  0  0  I ]
     !! [  C | -S  0  0 ]
     !! [ U1 |    ] [  0 |  0 -I  0 ] [ V1 |    ]**H
     !! = [---------] [---------------] [---------]   .
     !! [    | U2 ] [  S |  C  0  0 ] [    | V2 ]
     !! [  0 |  0  0  I ]
     !! X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
     !! than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
     !! transposed and/or permuted. This can be done in constant time using
     !! the TRANS and SIGNS options. See ZUNCSD for details.)
     !! The bidiagonal matrices B11, B12, B21, and B22 are represented
     !! implicitly by angles THETA(1:Q) and PHI(1:Q-1).
     !! The unitary matrices U1, U2, V1T, and V2T are input/output.
     !! The input matrices are pre- or post-multiplied by the appropriate
     !! singular vector matrices.
     
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero
           ! Scalar Arguments 
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, lrwork, m, p, q
           ! Array Arguments 
           real(dp), intent(out) :: b11d(*), b11e(*), b12d(*), b12e(*), b21d(*), b21e(*), b22d(*),&
                      b22e(*), rwork(*)
           real(dp), intent(inout) :: phi(*), theta(*)
           complex(dp), intent(inout) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*)
                     
        ! ===================================================================
           ! Parameters 
           integer(ilp), parameter :: maxitr = 6
           real(dp), parameter :: hundred = 100.0_dp
           real(dp), parameter :: meighth = -0.125_dp
           real(dp), parameter :: piover2 = 1.57079632679489661923132169163975144210_dp
           
           
           
           
           ! Local Scalars 
           logical(lk) :: colmajor, lquery, restart11, restart12, restart21, restart22, wantu1, &
                     wantu2, wantv1t, wantv2t
           integer(ilp) :: i, imin, imax, iter, iu1cs, iu1sn, iu2cs, iu2sn, iv1tcs, iv1tsn, &
                     iv2tcs, iv2tsn, j, lrworkmin, lrworkopt, maxit, mini
           real(dp) :: b11bulge, b12bulge, b21bulge, b22bulge, dummy, eps, mu, nu, r, sigma11, &
                     sigma21, temp, thetamax, thetamin, thresh, tol, tolmul, unfl, x1, x2, y1, y2
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test input arguments
           info = 0
           lquery = lrwork == -1
           wantu1 = stdlib_lsame( jobu1, 'Y' )
           wantu2 = stdlib_lsame( jobu2, 'Y' )
           wantv1t = stdlib_lsame( jobv1t, 'Y' )
           wantv2t = stdlib_lsame( jobv2t, 'Y' )
           colmajor = .not. stdlib_lsame( trans, 'T' )
           if( m < 0 ) then
              info = -6
           else if( p < 0 .or. p > m ) then
              info = -7
           else if( q < 0 .or. q > m ) then
              info = -8
           else if( q > p .or. q > m-p .or. q > m-q ) then
              info = -8
           else if( wantu1 .and. ldu1 < p ) then
              info = -12
           else if( wantu2 .and. ldu2 < m-p ) then
              info = -14
           else if( wantv1t .and. ldv1t < q ) then
              info = -16
           else if( wantv2t .and. ldv2t < m-q ) then
              info = -18
           end if
           ! quick return if q = 0
           if( info == 0 .and. q == 0 ) then
              lrworkmin = 1
              rwork(1) = lrworkmin
              return
           end if
           ! compute workspace
           if( info == 0 ) then
              iu1cs = 1
              iu1sn = iu1cs + q
              iu2cs = iu1sn + q
              iu2sn = iu2cs + q
              iv1tcs = iu2sn + q
              iv1tsn = iv1tcs + q
              iv2tcs = iv1tsn + q
              iv2tsn = iv2tcs + q
              lrworkopt = iv2tsn + q - 1
              lrworkmin = lrworkopt
              rwork(1) = lrworkopt
              if( lrwork < lrworkmin .and. .not. lquery ) then
                 info = -28
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'ZBBCSD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'EPSILON' )
           unfl = stdlib_dlamch( 'SAFE MINIMUM' )
           tolmul = max( ten, min( hundred, eps**meighth ) )
           tol = tolmul*eps
           thresh = max( tol, maxitr*q*q*unfl )
           ! test for negligible sines or cosines
           do i = 1, q
              if( theta(i) < thresh ) then
                 theta(i) = zero
              else if( theta(i) > piover2-thresh ) then
                 theta(i) = piover2
              end if
           end do
           do i = 1, q-1
              if( phi(i) < thresh ) then
                 phi(i) = zero
              else if( phi(i) > piover2-thresh ) then
                 phi(i) = piover2
              end if
           end do
           ! initial deflation
           imax = q
           do while( imax > 1 )
              if( phi(imax-1) /= zero ) then
                 exit
              end if
              imax = imax - 1
           end do
           imin = imax - 1
           if  ( imin > 1 ) then
              do while( phi(imin-1) /= zero )
                 imin = imin - 1
                 if  ( imin <= 1 ) exit
              end do
           end if
           ! initialize iteration counter
           maxit = maxitr*q*q
           iter = 0
           ! begin main iteration loop
           do while( imax > 1 )
              ! compute the matrix entries
              b11d(imin) = cos( theta(imin) )
              b21d(imin) = -sin( theta(imin) )
              do i = imin, imax - 1
                 b11e(i) = -sin( theta(i) ) * sin( phi(i) )
                 b11d(i+1) = cos( theta(i+1) ) * cos( phi(i) )
                 b12d(i) = sin( theta(i) ) * cos( phi(i) )
                 b12e(i) = cos( theta(i+1) ) * sin( phi(i) )
                 b21e(i) = -cos( theta(i) ) * sin( phi(i) )
                 b21d(i+1) = -sin( theta(i+1) ) * cos( phi(i) )
                 b22d(i) = cos( theta(i) ) * cos( phi(i) )
                 b22e(i) = -sin( theta(i+1) ) * sin( phi(i) )
              end do
              b12d(imax) = sin( theta(imax) )
              b22d(imax) = cos( theta(imax) )
              ! abort if not converging; otherwise, increment iter
              if( iter > maxit ) then
                 info = 0
                 do i = 1, q
                    if( phi(i) /= zero )info = info + 1
                 end do
                 return
              end if
              iter = iter + imax - imin
              ! compute shifts
              thetamax = theta(imin)
              thetamin = theta(imin)
              do i = imin+1, imax
                 if( theta(i) > thetamax )thetamax = theta(i)
                 if( theta(i) < thetamin )thetamin = theta(i)
              end do
              if( thetamax > piover2 - thresh ) then
                 ! zero on diagonals of b11 and b22; induce deflation with a
                 ! zero shift
                 mu = zero
                 nu = one
              else if( thetamin < thresh ) then
                 ! zero on diagonals of b12 and b22; induce deflation with a
                 ! zero shift
                 mu = one
                 nu = zero
              else
                 ! compute shifts for b11 and b21 and use the lesser
                 call stdlib_dlas2( b11d(imax-1), b11e(imax-1), b11d(imax), sigma11,dummy )
                           
                 call stdlib_dlas2( b21d(imax-1), b21e(imax-1), b21d(imax), sigma21,dummy )
                           
                 if( sigma11 <= sigma21 ) then
                    mu = sigma11
                    nu = sqrt( one - mu**2 )
                    if( mu < thresh ) then
                       mu = zero
                       nu = one
                    end if
                 else
                    nu = sigma21
                    mu = sqrt( 1.0_dp - nu**2 )
                    if( nu < thresh ) then
                       mu = one
                       nu = zero
                    end if
                 end if
              end if
              ! rotate to produce bulges in b11 and b21
              if( mu <= nu ) then
                 call stdlib_dlartgs( b11d(imin), b11e(imin), mu,rwork(iv1tcs+imin-1), rwork(&
                           iv1tsn+imin-1) )
              else
                 call stdlib_dlartgs( b21d(imin), b21e(imin), nu,rwork(iv1tcs+imin-1), rwork(&
                           iv1tsn+imin-1) )
              end if
              temp = rwork(iv1tcs+imin-1)*b11d(imin) +rwork(iv1tsn+imin-1)*b11e(imin)
              b11e(imin) = rwork(iv1tcs+imin-1)*b11e(imin) -rwork(iv1tsn+imin-1)*b11d(imin)
                        
              b11d(imin) = temp
              b11bulge = rwork(iv1tsn+imin-1)*b11d(imin+1)
              b11d(imin+1) = rwork(iv1tcs+imin-1)*b11d(imin+1)
              temp = rwork(iv1tcs+imin-1)*b21d(imin) +rwork(iv1tsn+imin-1)*b21e(imin)
              b21e(imin) = rwork(iv1tcs+imin-1)*b21e(imin) -rwork(iv1tsn+imin-1)*b21d(imin)
                        
              b21d(imin) = temp
              b21bulge = rwork(iv1tsn+imin-1)*b21d(imin+1)
              b21d(imin+1) = rwork(iv1tcs+imin-1)*b21d(imin+1)
              ! compute theta(imin)
              theta( imin ) = atan2( sqrt( b21d(imin)**2+b21bulge**2 ),sqrt( b11d(imin)**2+&
                        b11bulge**2 ) )
              ! chase the bulges in b11(imin+1,imin) and b21(imin+1,imin)
              if( b11d(imin)**2+b11bulge**2 > thresh**2 ) then
                 call stdlib_dlartgp( b11bulge, b11d(imin), rwork(iu1sn+imin-1),rwork(iu1cs+imin-&
                           1), r )
              else if( mu <= nu ) then
                 call stdlib_dlartgs( b11e( imin ), b11d( imin + 1 ), mu,rwork(iu1cs+imin-1), &
                           rwork(iu1sn+imin-1) )
              else
                 call stdlib_dlartgs( b12d( imin ), b12e( imin ), nu,rwork(iu1cs+imin-1), rwork(&
                           iu1sn+imin-1) )
              end if
              if( b21d(imin)**2+b21bulge**2 > thresh**2 ) then
                 call stdlib_dlartgp( b21bulge, b21d(imin), rwork(iu2sn+imin-1),rwork(iu2cs+imin-&
                           1), r )
              else if( nu < mu ) then
                 call stdlib_dlartgs( b21e( imin ), b21d( imin + 1 ), nu,rwork(iu2cs+imin-1), &
                           rwork(iu2sn+imin-1) )
              else
                 call stdlib_dlartgs( b22d(imin), b22e(imin), mu,rwork(iu2cs+imin-1), rwork(iu2sn+&
                           imin-1) )
              end if
              rwork(iu2cs+imin-1) = -rwork(iu2cs+imin-1)
              rwork(iu2sn+imin-1) = -rwork(iu2sn+imin-1)
              temp = rwork(iu1cs+imin-1)*b11e(imin) +rwork(iu1sn+imin-1)*b11d(imin+1)
              b11d(imin+1) = rwork(iu1cs+imin-1)*b11d(imin+1) -rwork(iu1sn+imin-1)*b11e(imin)
                        
              b11e(imin) = temp
              if( imax > imin+1 ) then
                 b11bulge = rwork(iu1sn+imin-1)*b11e(imin+1)
                 b11e(imin+1) = rwork(iu1cs+imin-1)*b11e(imin+1)
              end if
              temp = rwork(iu1cs+imin-1)*b12d(imin) +rwork(iu1sn+imin-1)*b12e(imin)
              b12e(imin) = rwork(iu1cs+imin-1)*b12e(imin) -rwork(iu1sn+imin-1)*b12d(imin)
              b12d(imin) = temp
              b12bulge = rwork(iu1sn+imin-1)*b12d(imin+1)
              b12d(imin+1) = rwork(iu1cs+imin-1)*b12d(imin+1)
              temp = rwork(iu2cs+imin-1)*b21e(imin) +rwork(iu2sn+imin-1)*b21d(imin+1)
              b21d(imin+1) = rwork(iu2cs+imin-1)*b21d(imin+1) -rwork(iu2sn+imin-1)*b21e(imin)
                        
              b21e(imin) = temp
              if( imax > imin+1 ) then
                 b21bulge = rwork(iu2sn+imin-1)*b21e(imin+1)
                 b21e(imin+1) = rwork(iu2cs+imin-1)*b21e(imin+1)
              end if
              temp = rwork(iu2cs+imin-1)*b22d(imin) +rwork(iu2sn+imin-1)*b22e(imin)
              b22e(imin) = rwork(iu2cs+imin-1)*b22e(imin) -rwork(iu2sn+imin-1)*b22d(imin)
              b22d(imin) = temp
              b22bulge = rwork(iu2sn+imin-1)*b22d(imin+1)
              b22d(imin+1) = rwork(iu2cs+imin-1)*b22d(imin+1)
              ! inner loop: chase bulges from b11(imin,imin+2),
              ! b12(imin,imin+1), b21(imin,imin+2), and b22(imin,imin+1) to
              ! bottom-right
              do i = imin+1, imax-1
                 ! compute phi(i-1)
                 x1 = sin(theta(i-1))*b11e(i-1) + cos(theta(i-1))*b21e(i-1)
                 x2 = sin(theta(i-1))*b11bulge + cos(theta(i-1))*b21bulge
                 y1 = sin(theta(i-1))*b12d(i-1) + cos(theta(i-1))*b22d(i-1)
                 y2 = sin(theta(i-1))*b12bulge + cos(theta(i-1))*b22bulge
                 phi(i-1) = atan2( sqrt(x1**2+x2**2), sqrt(y1**2+y2**2) )
                 ! determine if there are bulges to chase or if a new direct
                 ! summand has been reached
                 restart11 = b11e(i-1)**2 + b11bulge**2 <= thresh**2
                 restart21 = b21e(i-1)**2 + b21bulge**2 <= thresh**2
                 restart12 = b12d(i-1)**2 + b12bulge**2 <= thresh**2
                 restart22 = b22d(i-1)**2 + b22bulge**2 <= thresh**2
                 ! if possible, chase bulges from b11(i-1,i+1), b12(i-1,i),
                 ! b21(i-1,i+1), and b22(i-1,i). if necessary, restart bulge-
                 ! chasing by applying the original shift again.
                 if( .not. restart11 .and. .not. restart21 ) then
                    call stdlib_dlartgp( x2, x1, rwork(iv1tsn+i-1),rwork(iv1tcs+i-1), r )
                 else if( .not. restart11 .and. restart21 ) then
                    call stdlib_dlartgp( b11bulge, b11e(i-1), rwork(iv1tsn+i-1),rwork(iv1tcs+i-1),&
                               r )
                 else if( restart11 .and. .not. restart21 ) then
                    call stdlib_dlartgp( b21bulge, b21e(i-1), rwork(iv1tsn+i-1),rwork(iv1tcs+i-1),&
                               r )
                 else if( mu <= nu ) then
                    call stdlib_dlartgs( b11d(i), b11e(i), mu, rwork(iv1tcs+i-1),rwork(iv1tsn+i-1)&
                               )
                 else
                    call stdlib_dlartgs( b21d(i), b21e(i), nu, rwork(iv1tcs+i-1),rwork(iv1tsn+i-1)&
                               )
                 end if
                 rwork(iv1tcs+i-1) = -rwork(iv1tcs+i-1)
                 rwork(iv1tsn+i-1) = -rwork(iv1tsn+i-1)
                 if( .not. restart12 .and. .not. restart22 ) then
                    call stdlib_dlartgp( y2, y1, rwork(iv2tsn+i-1-1),rwork(iv2tcs+i-1-1), r )
                              
                 else if( .not. restart12 .and. restart22 ) then
                    call stdlib_dlartgp( b12bulge, b12d(i-1), rwork(iv2tsn+i-1-1),rwork(iv2tcs+i-&
                              1-1), r )
                 else if( restart12 .and. .not. restart22 ) then
                    call stdlib_dlartgp( b22bulge, b22d(i-1), rwork(iv2tsn+i-1-1),rwork(iv2tcs+i-&
                              1-1), r )
                 else if( nu < mu ) then
                    call stdlib_dlartgs( b12e(i-1), b12d(i), nu,rwork(iv2tcs+i-1-1), rwork(iv2tsn+&
                              i-1-1) )
                 else
                    call stdlib_dlartgs( b22e(i-1), b22d(i), mu,rwork(iv2tcs+i-1-1), rwork(iv2tsn+&
                              i-1-1) )
                 end if
                 temp = rwork(iv1tcs+i-1)*b11d(i) + rwork(iv1tsn+i-1)*b11e(i)
                 b11e(i) = rwork(iv1tcs+i-1)*b11e(i) -rwork(iv1tsn+i-1)*b11d(i)
                 b11d(i) = temp
                 b11bulge = rwork(iv1tsn+i-1)*b11d(i+1)
                 b11d(i+1) = rwork(iv1tcs+i-1)*b11d(i+1)
                 temp = rwork(iv1tcs+i-1)*b21d(i) + rwork(iv1tsn+i-1)*b21e(i)
                 b21e(i) = rwork(iv1tcs+i-1)*b21e(i) -rwork(iv1tsn+i-1)*b21d(i)
                 b21d(i) = temp
                 b21bulge = rwork(iv1tsn+i-1)*b21d(i+1)
                 b21d(i+1) = rwork(iv1tcs+i-1)*b21d(i+1)
                 temp = rwork(iv2tcs+i-1-1)*b12e(i-1) +rwork(iv2tsn+i-1-1)*b12d(i)
                 b12d(i) = rwork(iv2tcs+i-1-1)*b12d(i) -rwork(iv2tsn+i-1-1)*b12e(i-1)
                 b12e(i-1) = temp
                 b12bulge = rwork(iv2tsn+i-1-1)*b12e(i)
                 b12e(i) = rwork(iv2tcs+i-1-1)*b12e(i)
                 temp = rwork(iv2tcs+i-1-1)*b22e(i-1) +rwork(iv2tsn+i-1-1)*b22d(i)
                 b22d(i) = rwork(iv2tcs+i-1-1)*b22d(i) -rwork(iv2tsn+i-1-1)*b22e(i-1)
                 b22e(i-1) = temp
                 b22bulge = rwork(iv2tsn+i-1-1)*b22e(i)
                 b22e(i) = rwork(iv2tcs+i-1-1)*b22e(i)
                 ! compute theta(i)
                 x1 = cos(phi(i-1))*b11d(i) + sin(phi(i-1))*b12e(i-1)
                 x2 = cos(phi(i-1))*b11bulge + sin(phi(i-1))*b12bulge
                 y1 = cos(phi(i-1))*b21d(i) + sin(phi(i-1))*b22e(i-1)
                 y2 = cos(phi(i-1))*b21bulge + sin(phi(i-1))*b22bulge
                 theta(i) = atan2( sqrt(y1**2+y2**2), sqrt(x1**2+x2**2) )
                 ! determine if there are bulges to chase or if a new direct
                 ! summand has been reached
                 restart11 =   b11d(i)**2 + b11bulge**2 <= thresh**2
                 restart12 = b12e(i-1)**2 + b12bulge**2 <= thresh**2
                 restart21 =   b21d(i)**2 + b21bulge**2 <= thresh**2
                 restart22 = b22e(i-1)**2 + b22bulge**2 <= thresh**2
                 ! if possible, chase bulges from b11(i+1,i), b12(i+1,i-1),
                 ! b21(i+1,i), and b22(i+1,i-1). if necessary, restart bulge-
                 ! chasing by applying the original shift again.
                 if( .not. restart11 .and. .not. restart12 ) then
                    call stdlib_dlartgp( x2, x1, rwork(iu1sn+i-1), rwork(iu1cs+i-1),r )
                 else if( .not. restart11 .and. restart12 ) then
                    call stdlib_dlartgp( b11bulge, b11d(i), rwork(iu1sn+i-1),rwork(iu1cs+i-1), r )
                              
                 else if( restart11 .and. .not. restart12 ) then
                    call stdlib_dlartgp( b12bulge, b12e(i-1), rwork(iu1sn+i-1),rwork(iu1cs+i-1), &
                              r )
                 else if( mu <= nu ) then
                    call stdlib_dlartgs( b11e(i), b11d(i+1), mu, rwork(iu1cs+i-1),rwork(iu1sn+i-1)&
                               )
                 else
                    call stdlib_dlartgs( b12d(i), b12e(i), nu, rwork(iu1cs+i-1),rwork(iu1sn+i-1) )
                              
                 end if
                 if( .not. restart21 .and. .not. restart22 ) then
                    call stdlib_dlartgp( y2, y1, rwork(iu2sn+i-1), rwork(iu2cs+i-1),r )
                 else if( .not. restart21 .and. restart22 ) then
                    call stdlib_dlartgp( b21bulge, b21d(i), rwork(iu2sn+i-1),rwork(iu2cs+i-1), r )
                              
                 else if( restart21 .and. .not. restart22 ) then
                    call stdlib_dlartgp( b22bulge, b22e(i-1), rwork(iu2sn+i-1),rwork(iu2cs+i-1), &
                              r )
                 else if( nu < mu ) then
                    call stdlib_dlartgs( b21e(i), b21e(i+1), nu, rwork(iu2cs+i-1),rwork(iu2sn+i-1)&
                               )
                 else
                    call stdlib_dlartgs( b22d(i), b22e(i), mu, rwork(iu2cs+i-1),rwork(iu2sn+i-1) )
                              
                 end if
                 rwork(iu2cs+i-1) = -rwork(iu2cs+i-1)
                 rwork(iu2sn+i-1) = -rwork(iu2sn+i-1)
                 temp = rwork(iu1cs+i-1)*b11e(i) + rwork(iu1sn+i-1)*b11d(i+1)
                 b11d(i+1) = rwork(iu1cs+i-1)*b11d(i+1) -rwork(iu1sn+i-1)*b11e(i)
                 b11e(i) = temp
                 if( i < imax - 1 ) then
                    b11bulge = rwork(iu1sn+i-1)*b11e(i+1)
                    b11e(i+1) = rwork(iu1cs+i-1)*b11e(i+1)
                 end if
                 temp = rwork(iu2cs+i-1)*b21e(i) + rwork(iu2sn+i-1)*b21d(i+1)
                 b21d(i+1) = rwork(iu2cs+i-1)*b21d(i+1) -rwork(iu2sn+i-1)*b21e(i)
                 b21e(i) = temp
                 if( i < imax - 1 ) then
                    b21bulge = rwork(iu2sn+i-1)*b21e(i+1)
                    b21e(i+1) = rwork(iu2cs+i-1)*b21e(i+1)
                 end if
                 temp = rwork(iu1cs+i-1)*b12d(i) + rwork(iu1sn+i-1)*b12e(i)
                 b12e(i) = rwork(iu1cs+i-1)*b12e(i) -rwork(iu1sn+i-1)*b12d(i)
                 b12d(i) = temp
                 b12bulge = rwork(iu1sn+i-1)*b12d(i+1)
                 b12d(i+1) = rwork(iu1cs+i-1)*b12d(i+1)
                 temp = rwork(iu2cs+i-1)*b22d(i) + rwork(iu2sn+i-1)*b22e(i)
                 b22e(i) = rwork(iu2cs+i-1)*b22e(i) -rwork(iu2sn+i-1)*b22d(i)
                 b22d(i) = temp
                 b22bulge = rwork(iu2sn+i-1)*b22d(i+1)
                 b22d(i+1) = rwork(iu2cs+i-1)*b22d(i+1)
              end do
              ! compute phi(imax-1)
              x1 = sin(theta(imax-1))*b11e(imax-1) +cos(theta(imax-1))*b21e(imax-1)
              y1 = sin(theta(imax-1))*b12d(imax-1) +cos(theta(imax-1))*b22d(imax-1)
              y2 = sin(theta(imax-1))*b12bulge + cos(theta(imax-1))*b22bulge
              phi(imax-1) = atan2( abs(x1), sqrt(y1**2+y2**2) )
              ! chase bulges from b12(imax-1,imax) and b22(imax-1,imax)
              restart12 = b12d(imax-1)**2 + b12bulge**2 <= thresh**2
              restart22 = b22d(imax-1)**2 + b22bulge**2 <= thresh**2
              if( .not. restart12 .and. .not. restart22 ) then
                 call stdlib_dlartgp( y2, y1, rwork(iv2tsn+imax-1-1),rwork(iv2tcs+imax-1-1), r )
                           
              else if( .not. restart12 .and. restart22 ) then
                 call stdlib_dlartgp( b12bulge, b12d(imax-1),rwork(iv2tsn+imax-1-1),rwork(iv2tcs+&
                           imax-1-1), r )
              else if( restart12 .and. .not. restart22 ) then
                 call stdlib_dlartgp( b22bulge, b22d(imax-1),rwork(iv2tsn+imax-1-1),rwork(iv2tcs+&
                           imax-1-1), r )
              else if( nu < mu ) then
                 call stdlib_dlartgs( b12e(imax-1), b12d(imax), nu,rwork(iv2tcs+imax-1-1),rwork(&
                           iv2tsn+imax-1-1) )
              else
                 call stdlib_dlartgs( b22e(imax-1), b22d(imax), mu,rwork(iv2tcs+imax-1-1),rwork(&
                           iv2tsn+imax-1-1) )
              end if
              temp = rwork(iv2tcs+imax-1-1)*b12e(imax-1) +rwork(iv2tsn+imax-1-1)*b12d(imax)
                        
              b12d(imax) = rwork(iv2tcs+imax-1-1)*b12d(imax) -rwork(iv2tsn+imax-1-1)*b12e(imax-1)
                        
              b12e(imax-1) = temp
              temp = rwork(iv2tcs+imax-1-1)*b22e(imax-1) +rwork(iv2tsn+imax-1-1)*b22d(imax)
                        
              b22d(imax) = rwork(iv2tcs+imax-1-1)*b22d(imax) -rwork(iv2tsn+imax-1-1)*b22e(imax-1)
                        
              b22e(imax-1) = temp
              ! update singular vectors
              if( wantu1 ) then
                 if( colmajor ) then
                    call stdlib_zlasr( 'R', 'V', 'F', p, imax-imin+1,rwork(iu1cs+imin-1), rwork(&
                              iu1sn+imin-1),u1(1,imin), ldu1 )
                 else
                    call stdlib_zlasr( 'L', 'V', 'F', imax-imin+1, p,rwork(iu1cs+imin-1), rwork(&
                              iu1sn+imin-1),u1(imin,1), ldu1 )
                 end if
              end if
              if( wantu2 ) then
                 if( colmajor ) then
                    call stdlib_zlasr( 'R', 'V', 'F', m-p, imax-imin+1,rwork(iu2cs+imin-1), rwork(&
                              iu2sn+imin-1),u2(1,imin), ldu2 )
                 else
                    call stdlib_zlasr( 'L', 'V', 'F', imax-imin+1, m-p,rwork(iu2cs+imin-1), rwork(&
                              iu2sn+imin-1),u2(imin,1), ldu2 )
                 end if
              end if
              if( wantv1t ) then
                 if( colmajor ) then
                    call stdlib_zlasr( 'L', 'V', 'F', imax-imin+1, q,rwork(iv1tcs+imin-1), rwork(&
                              iv1tsn+imin-1),v1t(imin,1), ldv1t )
                 else
                    call stdlib_zlasr( 'R', 'V', 'F', q, imax-imin+1,rwork(iv1tcs+imin-1), rwork(&
                              iv1tsn+imin-1),v1t(1,imin), ldv1t )
                 end if
              end if
              if( wantv2t ) then
                 if( colmajor ) then
                    call stdlib_zlasr( 'L', 'V', 'F', imax-imin+1, m-q,rwork(iv2tcs+imin-1), &
                              rwork(iv2tsn+imin-1),v2t(imin,1), ldv2t )
                 else
                    call stdlib_zlasr( 'R', 'V', 'F', m-q, imax-imin+1,rwork(iv2tcs+imin-1), &
                              rwork(iv2tsn+imin-1),v2t(1,imin), ldv2t )
                 end if
              end if
              ! fix signs on b11(imax-1,imax) and b21(imax-1,imax)
              if( b11e(imax-1)+b21e(imax-1) > 0 ) then
                 b11d(imax) = -b11d(imax)
                 b21d(imax) = -b21d(imax)
                 if( wantv1t ) then
                    if( colmajor ) then
                       call stdlib_zscal( q, cnegone, v1t(imax,1), ldv1t )
                    else
                       call stdlib_zscal( q, cnegone, v1t(1,imax), 1 )
                    end if
                 end if
              end if
              ! compute theta(imax)
              x1 = cos(phi(imax-1))*b11d(imax) +sin(phi(imax-1))*b12e(imax-1)
              y1 = cos(phi(imax-1))*b21d(imax) +sin(phi(imax-1))*b22e(imax-1)
              theta(imax) = atan2( abs(y1), abs(x1) )
              ! fix signs on b11(imax,imax), b12(imax,imax-1), b21(imax,imax),
              ! and b22(imax,imax-1)
              if( b11d(imax)+b12e(imax-1) < 0 ) then
                 b12d(imax) = -b12d(imax)
                 if( wantu1 ) then
                    if( colmajor ) then
                       call stdlib_zscal( p, cnegone, u1(1,imax), 1 )
                    else
                       call stdlib_zscal( p, cnegone, u1(imax,1), ldu1 )
                    end if
                 end if
              end if
              if( b21d(imax)+b22e(imax-1) > 0 ) then
                 b22d(imax) = -b22d(imax)
                 if( wantu2 ) then
                    if( colmajor ) then
                       call stdlib_zscal( m-p, cnegone, u2(1,imax), 1 )
                    else
                       call stdlib_zscal( m-p, cnegone, u2(imax,1), ldu2 )
                    end if
                 end if
              end if
              ! fix signs on b12(imax,imax) and b22(imax,imax)
              if( b12d(imax)+b22d(imax) < 0 ) then
                 if( wantv2t ) then
                    if( colmajor ) then
                       call stdlib_zscal( m-q, cnegone, v2t(imax,1), ldv2t )
                    else
                       call stdlib_zscal( m-q, cnegone, v2t(1,imax), 1 )
                    end if
                 end if
              end if
              ! test for negligible sines or cosines
              do i = imin, imax
                 if( theta(i) < thresh ) then
                    theta(i) = zero
                 else if( theta(i) > piover2-thresh ) then
                    theta(i) = piover2
                 end if
              end do
              do i = imin, imax-1
                 if( phi(i) < thresh ) then
                    phi(i) = zero
                 else if( phi(i) > piover2-thresh ) then
                    phi(i) = piover2
                 end if
              end do
              ! deflate
              if (imax > 1) then
                 do while( phi(imax-1) == zero )
                    imax = imax - 1
                    if (imax <= 1) exit
                 end do
              end if
              if( imin > imax - 1 )imin = imax - 1
              if (imin > 1) then
                 do while (phi(imin-1) /= zero)
                     imin = imin - 1
                     if (imin <= 1) exit
                 end do
              end if
              ! repeat main iteration loop
           end do
           ! postprocessing: order theta from least to greatest
           do i = 1, q
              mini = i
              thetamin = theta(i)
              do j = i+1, q
                 if( theta(j) < thetamin ) then
                    mini = j
                    thetamin = theta(j)
                 end if
              end do
              if( mini /= i ) then
                 theta(mini) = theta(i)
                 theta(i) = thetamin
                 if( colmajor ) then
                    if( wantu1 )call stdlib_zswap( p, u1(1,i), 1, u1(1,mini), 1 )
                    if( wantu2 )call stdlib_zswap( m-p, u2(1,i), 1, u2(1,mini), 1 )
                    if( wantv1t )call stdlib_zswap( q, v1t(i,1), ldv1t, v1t(mini,1), ldv1t )
                              
                    if( wantv2t )call stdlib_zswap( m-q, v2t(i,1), ldv2t, v2t(mini,1),ldv2t )
                              
                 else
                    if( wantu1 )call stdlib_zswap( p, u1(i,1), ldu1, u1(mini,1), ldu1 )
                    if( wantu2 )call stdlib_zswap( m-p, u2(i,1), ldu2, u2(mini,1), ldu2 )
                    if( wantv1t )call stdlib_zswap( q, v1t(1,i), 1, v1t(1,mini), 1 )
                    if( wantv2t )call stdlib_zswap( m-q, v2t(1,i), 1, v2t(1,mini), 1 )
                 end if
              end if
           end do
           return
     end subroutine stdlib_zbbcsd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     pure subroutine stdlib_${ci}$bbcsd( jobu1, jobu2, jobv1t, jobv2t, trans, m, p, q,theta, phi, u1, &
     ldu1, u2, ldu2, v1t, ldv1t,v2t, ldv2t, b11d, b11e, b12d, b12e, b21d, b21e,b22d, b22e, rwork, lrwork, info )
     !! ZBBCSD: computes the CS decomposition of a unitary matrix in
     !! bidiagonal-block form,
     !! [ B11 | B12 0  0 ]
     !! [  0  |  0 -I  0 ]
     !! X = [----------------]
     !! [ B21 | B22 0  0 ]
     !! [  0  |  0  0  I ]
     !! [  C | -S  0  0 ]
     !! [ U1 |    ] [  0 |  0 -I  0 ] [ V1 |    ]**H
     !! = [---------] [---------------] [---------]   .
     !! [    | U2 ] [  S |  C  0  0 ] [    | V2 ]
     !! [  0 |  0  0  I ]
     !! X is M-by-M, its top-left block is P-by-Q, and Q must be no larger
     !! than P, M-P, or M-Q. (If Q is not the smallest index, then X must be
     !! transposed and/or permuted. This can be done in constant time using
     !! the TRANS and SIGNS options. See ZUNCSD for details.)
     !! The bidiagonal matrices B11, B12, B21, and B22 are represented
     !! implicitly by angles THETA(1:Q) and PHI(1:Q-1).
     !! The unitary matrices U1, U2, V1T, and V2T are input/output.
     !! The input matrices are pre- or post-multiplied by the appropriate
     !! singular vector matrices.
     
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero
           ! Scalar Arguments 
           character, intent(in) :: jobu1, jobu2, jobv1t, jobv2t, trans
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: ldu1, ldu2, ldv1t, ldv2t, lrwork, m, p, q
           ! Array Arguments 
           real(${ck}$), intent(out) :: b11d(*), b11e(*), b12d(*), b12e(*), b21d(*), b21e(*), b22d(*),&
                      b22e(*), rwork(*)
           real(${ck}$), intent(inout) :: phi(*), theta(*)
           complex(${ck}$), intent(inout) :: u1(ldu1,*), u2(ldu2,*), v1t(ldv1t,*), v2t(ldv2t,*)
                     
        ! ===================================================================
           ! Parameters 
           integer(ilp), parameter :: maxitr = 6
           real(${ck}$), parameter :: hundred = 100.0_${ck}$
           real(${ck}$), parameter :: meighth = -0.125_${ck}$
           real(${ck}$), parameter :: piover2 = 1.57079632679489661923132169163975144210_${ck}$
           
           
           
           
           ! Local Scalars 
           logical(lk) :: colmajor, lquery, restart11, restart12, restart21, restart22, wantu1, &
                     wantu2, wantv1t, wantv2t
           integer(ilp) :: i, imin, imax, iter, iu1cs, iu1sn, iu2cs, iu2sn, iv1tcs, iv1tsn, &
                     iv2tcs, iv2tsn, j, lrworkmin, lrworkopt, maxit, mini
           real(${ck}$) :: b11bulge, b12bulge, b21bulge, b22bulge, dummy, eps, mu, nu, r, sigma11, &
                     sigma21, temp, thetamax, thetamin, thresh, tol, tolmul, unfl, x1, x2, y1, y2
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test input arguments
           info = 0
           lquery = lrwork == -1
           wantu1 = stdlib_lsame( jobu1, 'Y' )
           wantu2 = stdlib_lsame( jobu2, 'Y' )
           wantv1t = stdlib_lsame( jobv1t, 'Y' )
           wantv2t = stdlib_lsame( jobv2t, 'Y' )
           colmajor = .not. stdlib_lsame( trans, 'T' )
           if( m < 0 ) then
              info = -6
           else if( p < 0 .or. p > m ) then
              info = -7
           else if( q < 0 .or. q > m ) then
              info = -8
           else if( q > p .or. q > m-p .or. q > m-q ) then
              info = -8
           else if( wantu1 .and. ldu1 < p ) then
              info = -12
           else if( wantu2 .and. ldu2 < m-p ) then
              info = -14
           else if( wantv1t .and. ldv1t < q ) then
              info = -16
           else if( wantv2t .and. ldv2t < m-q ) then
              info = -18
           end if
           ! quick return if q = 0
           if( info == 0 .and. q == 0 ) then
              lrworkmin = 1
              rwork(1) = lrworkmin
              return
           end if
           ! compute workspace
           if( info == 0 ) then
              iu1cs = 1
              iu1sn = iu1cs + q
              iu2cs = iu1sn + q
              iu2sn = iu2cs + q
              iv1tcs = iu2sn + q
              iv1tsn = iv1tcs + q
              iv2tcs = iv1tsn + q
              iv2tsn = iv2tcs + q
              lrworkopt = iv2tsn + q - 1
              lrworkmin = lrworkopt
              rwork(1) = lrworkopt
              if( lrwork < lrworkmin .and. .not. lquery ) then
                 info = -28
              end if
           end if
           if( info /= 0 ) then
              call stdlib_xerbla( 'ZBBCSD', -info )
              return
           else if( lquery ) then
              return
           end if
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'EPSILON' )
           unfl = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           tolmul = max( ten, min( hundred, eps**meighth ) )
           tol = tolmul*eps
           thresh = max( tol, maxitr*q*q*unfl )
           ! test for negligible sines or cosines
           do i = 1, q
              if( theta(i) < thresh ) then
                 theta(i) = zero
              else if( theta(i) > piover2-thresh ) then
                 theta(i) = piover2
              end if
           end do
           do i = 1, q-1
              if( phi(i) < thresh ) then
                 phi(i) = zero
              else if( phi(i) > piover2-thresh ) then
                 phi(i) = piover2
              end if
           end do
           ! initial deflation
           imax = q
           do while( imax > 1 )
              if( phi(imax-1) /= zero ) then
                 exit
              end if
              imax = imax - 1
           end do
           imin = imax - 1
           if  ( imin > 1 ) then
              do while( phi(imin-1) /= zero )
                 imin = imin - 1
                 if  ( imin <= 1 ) exit
              end do
           end if
           ! initialize iteration counter
           maxit = maxitr*q*q
           iter = 0
           ! begin main iteration loop
           do while( imax > 1 )
              ! compute the matrix entries
              b11d(imin) = cos( theta(imin) )
              b21d(imin) = -sin( theta(imin) )
              do i = imin, imax - 1
                 b11e(i) = -sin( theta(i) ) * sin( phi(i) )
                 b11d(i+1) = cos( theta(i+1) ) * cos( phi(i) )
                 b12d(i) = sin( theta(i) ) * cos( phi(i) )
                 b12e(i) = cos( theta(i+1) ) * sin( phi(i) )
                 b21e(i) = -cos( theta(i) ) * sin( phi(i) )
                 b21d(i+1) = -sin( theta(i+1) ) * cos( phi(i) )
                 b22d(i) = cos( theta(i) ) * cos( phi(i) )
                 b22e(i) = -sin( theta(i+1) ) * sin( phi(i) )
              end do
              b12d(imax) = sin( theta(imax) )
              b22d(imax) = cos( theta(imax) )
              ! abort if not converging; otherwise, increment iter
              if( iter > maxit ) then
                 info = 0
                 do i = 1, q
                    if( phi(i) /= zero )info = info + 1
                 end do
                 return
              end if
              iter = iter + imax - imin
              ! compute shifts
              thetamax = theta(imin)
              thetamin = theta(imin)
              do i = imin+1, imax
                 if( theta(i) > thetamax )thetamax = theta(i)
                 if( theta(i) < thetamin )thetamin = theta(i)
              end do
              if( thetamax > piover2 - thresh ) then
                 ! zero on diagonals of b11 and b22; induce deflation with a
                 ! zero shift
                 mu = zero
                 nu = one
              else if( thetamin < thresh ) then
                 ! zero on diagonals of b12 and b22; induce deflation with a
                 ! zero shift
                 mu = one
                 nu = zero
              else
                 ! compute shifts for b11 and b21 and use the lesser
                 call stdlib_${c2ri(ci)}$las2( b11d(imax-1), b11e(imax-1), b11d(imax), sigma11,dummy )
                           
                 call stdlib_${c2ri(ci)}$las2( b21d(imax-1), b21e(imax-1), b21d(imax), sigma21,dummy )
                           
                 if( sigma11 <= sigma21 ) then
                    mu = sigma11
                    nu = sqrt( one - mu**2 )
                    if( mu < thresh ) then
                       mu = zero
                       nu = one
                    end if
                 else
                    nu = sigma21
                    mu = sqrt( 1.0_${ck}$ - nu**2 )
                    if( nu < thresh ) then
                       mu = one
                       nu = zero
                    end if
                 end if
              end if
              ! rotate to produce bulges in b11 and b21
              if( mu <= nu ) then
                 call stdlib_${c2ri(ci)}$lartgs( b11d(imin), b11e(imin), mu,rwork(iv1tcs+imin-1), rwork(&
                           iv1tsn+imin-1) )
              else
                 call stdlib_${c2ri(ci)}$lartgs( b21d(imin), b21e(imin), nu,rwork(iv1tcs+imin-1), rwork(&
                           iv1tsn+imin-1) )
              end if
              temp = rwork(iv1tcs+imin-1)*b11d(imin) +rwork(iv1tsn+imin-1)*b11e(imin)
              b11e(imin) = rwork(iv1tcs+imin-1)*b11e(imin) -rwork(iv1tsn+imin-1)*b11d(imin)
                        
              b11d(imin) = temp
              b11bulge = rwork(iv1tsn+imin-1)*b11d(imin+1)
              b11d(imin+1) = rwork(iv1tcs+imin-1)*b11d(imin+1)
              temp = rwork(iv1tcs+imin-1)*b21d(imin) +rwork(iv1tsn+imin-1)*b21e(imin)
              b21e(imin) = rwork(iv1tcs+imin-1)*b21e(imin) -rwork(iv1tsn+imin-1)*b21d(imin)
                        
              b21d(imin) = temp
              b21bulge = rwork(iv1tsn+imin-1)*b21d(imin+1)
              b21d(imin+1) = rwork(iv1tcs+imin-1)*b21d(imin+1)
              ! compute theta(imin)
              theta( imin ) = atan2( sqrt( b21d(imin)**2+b21bulge**2 ),sqrt( b11d(imin)**2+&
                        b11bulge**2 ) )
              ! chase the bulges in b11(imin+1,imin) and b21(imin+1,imin)
              if( b11d(imin)**2+b11bulge**2 > thresh**2 ) then
                 call stdlib_${c2ri(ci)}$lartgp( b11bulge, b11d(imin), rwork(iu1sn+imin-1),rwork(iu1cs+imin-&
                           1), r )
              else if( mu <= nu ) then
                 call stdlib_${c2ri(ci)}$lartgs( b11e( imin ), b11d( imin + 1 ), mu,rwork(iu1cs+imin-1), &
                           rwork(iu1sn+imin-1) )
              else
                 call stdlib_${c2ri(ci)}$lartgs( b12d( imin ), b12e( imin ), nu,rwork(iu1cs+imin-1), rwork(&
                           iu1sn+imin-1) )
              end if
              if( b21d(imin)**2+b21bulge**2 > thresh**2 ) then
                 call stdlib_${c2ri(ci)}$lartgp( b21bulge, b21d(imin), rwork(iu2sn+imin-1),rwork(iu2cs+imin-&
                           1), r )
              else if( nu < mu ) then
                 call stdlib_${c2ri(ci)}$lartgs( b21e( imin ), b21d( imin + 1 ), nu,rwork(iu2cs+imin-1), &
                           rwork(iu2sn+imin-1) )
              else
                 call stdlib_${c2ri(ci)}$lartgs( b22d(imin), b22e(imin), mu,rwork(iu2cs+imin-1), rwork(iu2sn+&
                           imin-1) )
              end if
              rwork(iu2cs+imin-1) = -rwork(iu2cs+imin-1)
              rwork(iu2sn+imin-1) = -rwork(iu2sn+imin-1)
              temp = rwork(iu1cs+imin-1)*b11e(imin) +rwork(iu1sn+imin-1)*b11d(imin+1)
              b11d(imin+1) = rwork(iu1cs+imin-1)*b11d(imin+1) -rwork(iu1sn+imin-1)*b11e(imin)
                        
              b11e(imin) = temp
              if( imax > imin+1 ) then
                 b11bulge = rwork(iu1sn+imin-1)*b11e(imin+1)
                 b11e(imin+1) = rwork(iu1cs+imin-1)*b11e(imin+1)
              end if
              temp = rwork(iu1cs+imin-1)*b12d(imin) +rwork(iu1sn+imin-1)*b12e(imin)
              b12e(imin) = rwork(iu1cs+imin-1)*b12e(imin) -rwork(iu1sn+imin-1)*b12d(imin)
              b12d(imin) = temp
              b12bulge = rwork(iu1sn+imin-1)*b12d(imin+1)
              b12d(imin+1) = rwork(iu1cs+imin-1)*b12d(imin+1)
              temp = rwork(iu2cs+imin-1)*b21e(imin) +rwork(iu2sn+imin-1)*b21d(imin+1)
              b21d(imin+1) = rwork(iu2cs+imin-1)*b21d(imin+1) -rwork(iu2sn+imin-1)*b21e(imin)
                        
              b21e(imin) = temp
              if( imax > imin+1 ) then
                 b21bulge = rwork(iu2sn+imin-1)*b21e(imin+1)
                 b21e(imin+1) = rwork(iu2cs+imin-1)*b21e(imin+1)
              end if
              temp = rwork(iu2cs+imin-1)*b22d(imin) +rwork(iu2sn+imin-1)*b22e(imin)
              b22e(imin) = rwork(iu2cs+imin-1)*b22e(imin) -rwork(iu2sn+imin-1)*b22d(imin)
              b22d(imin) = temp
              b22bulge = rwork(iu2sn+imin-1)*b22d(imin+1)
              b22d(imin+1) = rwork(iu2cs+imin-1)*b22d(imin+1)
              ! inner loop: chase bulges from b11(imin,imin+2),
              ! b12(imin,imin+1), b21(imin,imin+2), and b22(imin,imin+1) to
              ! bottom-right
              do i = imin+1, imax-1
                 ! compute phi(i-1)
                 x1 = sin(theta(i-1))*b11e(i-1) + cos(theta(i-1))*b21e(i-1)
                 x2 = sin(theta(i-1))*b11bulge + cos(theta(i-1))*b21bulge
                 y1 = sin(theta(i-1))*b12d(i-1) + cos(theta(i-1))*b22d(i-1)
                 y2 = sin(theta(i-1))*b12bulge + cos(theta(i-1))*b22bulge
                 phi(i-1) = atan2( sqrt(x1**2+x2**2), sqrt(y1**2+y2**2) )
                 ! determine if there are bulges to chase or if a new direct
                 ! summand has been reached
                 restart11 = b11e(i-1)**2 + b11bulge**2 <= thresh**2
                 restart21 = b21e(i-1)**2 + b21bulge**2 <= thresh**2
                 restart12 = b12d(i-1)**2 + b12bulge**2 <= thresh**2
                 restart22 = b22d(i-1)**2 + b22bulge**2 <= thresh**2
                 ! if possible, chase bulges from b11(i-1,i+1), b12(i-1,i),
                 ! b21(i-1,i+1), and b22(i-1,i). if necessary, restart bulge-
                 ! chasing by applying the original shift again.
                 if( .not. restart11 .and. .not. restart21 ) then
                    call stdlib_${c2ri(ci)}$lartgp( x2, x1, rwork(iv1tsn+i-1),rwork(iv1tcs+i-1), r )
                 else if( .not. restart11 .and. restart21 ) then
                    call stdlib_${c2ri(ci)}$lartgp( b11bulge, b11e(i-1), rwork(iv1tsn+i-1),rwork(iv1tcs+i-1),&
                               r )
                 else if( restart11 .and. .not. restart21 ) then
                    call stdlib_${c2ri(ci)}$lartgp( b21bulge, b21e(i-1), rwork(iv1tsn+i-1),rwork(iv1tcs+i-1),&
                               r )
                 else if( mu <= nu ) then
                    call stdlib_${c2ri(ci)}$lartgs( b11d(i), b11e(i), mu, rwork(iv1tcs+i-1),rwork(iv1tsn+i-1)&
                               )
                 else
                    call stdlib_${c2ri(ci)}$lartgs( b21d(i), b21e(i), nu, rwork(iv1tcs+i-1),rwork(iv1tsn+i-1)&
                               )
                 end if
                 rwork(iv1tcs+i-1) = -rwork(iv1tcs+i-1)
                 rwork(iv1tsn+i-1) = -rwork(iv1tsn+i-1)
                 if( .not. restart12 .and. .not. restart22 ) then
                    call stdlib_${c2ri(ci)}$lartgp( y2, y1, rwork(iv2tsn+i-1-1),rwork(iv2tcs+i-1-1), r )
                              
                 else if( .not. restart12 .and. restart22 ) then
                    call stdlib_${c2ri(ci)}$lartgp( b12bulge, b12d(i-1), rwork(iv2tsn+i-1-1),rwork(iv2tcs+i-&
                              1-1), r )
                 else if( restart12 .and. .not. restart22 ) then
                    call stdlib_${c2ri(ci)}$lartgp( b22bulge, b22d(i-1), rwork(iv2tsn+i-1-1),rwork(iv2tcs+i-&
                              1-1), r )
                 else if( nu < mu ) then
                    call stdlib_${c2ri(ci)}$lartgs( b12e(i-1), b12d(i), nu,rwork(iv2tcs+i-1-1), rwork(iv2tsn+&
                              i-1-1) )
                 else
                    call stdlib_${c2ri(ci)}$lartgs( b22e(i-1), b22d(i), mu,rwork(iv2tcs+i-1-1), rwork(iv2tsn+&
                              i-1-1) )
                 end if
                 temp = rwork(iv1tcs+i-1)*b11d(i) + rwork(iv1tsn+i-1)*b11e(i)
                 b11e(i) = rwork(iv1tcs+i-1)*b11e(i) -rwork(iv1tsn+i-1)*b11d(i)
                 b11d(i) = temp
                 b11bulge = rwork(iv1tsn+i-1)*b11d(i+1)
                 b11d(i+1) = rwork(iv1tcs+i-1)*b11d(i+1)
                 temp = rwork(iv1tcs+i-1)*b21d(i) + rwork(iv1tsn+i-1)*b21e(i)
                 b21e(i) = rwork(iv1tcs+i-1)*b21e(i) -rwork(iv1tsn+i-1)*b21d(i)
                 b21d(i) = temp
                 b21bulge = rwork(iv1tsn+i-1)*b21d(i+1)
                 b21d(i+1) = rwork(iv1tcs+i-1)*b21d(i+1)
                 temp = rwork(iv2tcs+i-1-1)*b12e(i-1) +rwork(iv2tsn+i-1-1)*b12d(i)
                 b12d(i) = rwork(iv2tcs+i-1-1)*b12d(i) -rwork(iv2tsn+i-1-1)*b12e(i-1)
                 b12e(i-1) = temp
                 b12bulge = rwork(iv2tsn+i-1-1)*b12e(i)
                 b12e(i) = rwork(iv2tcs+i-1-1)*b12e(i)
                 temp = rwork(iv2tcs+i-1-1)*b22e(i-1) +rwork(iv2tsn+i-1-1)*b22d(i)
                 b22d(i) = rwork(iv2tcs+i-1-1)*b22d(i) -rwork(iv2tsn+i-1-1)*b22e(i-1)
                 b22e(i-1) = temp
                 b22bulge = rwork(iv2tsn+i-1-1)*b22e(i)
                 b22e(i) = rwork(iv2tcs+i-1-1)*b22e(i)
                 ! compute theta(i)
                 x1 = cos(phi(i-1))*b11d(i) + sin(phi(i-1))*b12e(i-1)
                 x2 = cos(phi(i-1))*b11bulge + sin(phi(i-1))*b12bulge
                 y1 = cos(phi(i-1))*b21d(i) + sin(phi(i-1))*b22e(i-1)
                 y2 = cos(phi(i-1))*b21bulge + sin(phi(i-1))*b22bulge
                 theta(i) = atan2( sqrt(y1**2+y2**2), sqrt(x1**2+x2**2) )
                 ! determine if there are bulges to chase or if a new direct
                 ! summand has been reached
                 restart11 =   b11d(i)**2 + b11bulge**2 <= thresh**2
                 restart12 = b12e(i-1)**2 + b12bulge**2 <= thresh**2
                 restart21 =   b21d(i)**2 + b21bulge**2 <= thresh**2
                 restart22 = b22e(i-1)**2 + b22bulge**2 <= thresh**2
                 ! if possible, chase bulges from b11(i+1,i), b12(i+1,i-1),
                 ! b21(i+1,i), and b22(i+1,i-1). if necessary, restart bulge-
                 ! chasing by applying the original shift again.
                 if( .not. restart11 .and. .not. restart12 ) then
                    call stdlib_${c2ri(ci)}$lartgp( x2, x1, rwork(iu1sn+i-1), rwork(iu1cs+i-1),r )
                 else if( .not. restart11 .and. restart12 ) then
                    call stdlib_${c2ri(ci)}$lartgp( b11bulge, b11d(i), rwork(iu1sn+i-1),rwork(iu1cs+i-1), r )
                              
                 else if( restart11 .and. .not. restart12 ) then
                    call stdlib_${c2ri(ci)}$lartgp( b12bulge, b12e(i-1), rwork(iu1sn+i-1),rwork(iu1cs+i-1), &
                              r )
                 else if( mu <= nu ) then
                    call stdlib_${c2ri(ci)}$lartgs( b11e(i), b11d(i+1), mu, rwork(iu1cs+i-1),rwork(iu1sn+i-1)&
                               )
                 else
                    call stdlib_${c2ri(ci)}$lartgs( b12d(i), b12e(i), nu, rwork(iu1cs+i-1),rwork(iu1sn+i-1) )
                              
                 end if
                 if( .not. restart21 .and. .not. restart22 ) then
                    call stdlib_${c2ri(ci)}$lartgp( y2, y1, rwork(iu2sn+i-1), rwork(iu2cs+i-1),r )
                 else if( .not. restart21 .and. restart22 ) then
                    call stdlib_${c2ri(ci)}$lartgp( b21bulge, b21d(i), rwork(iu2sn+i-1),rwork(iu2cs+i-1), r )
                              
                 else if( restart21 .and. .not. restart22 ) then
                    call stdlib_${c2ri(ci)}$lartgp( b22bulge, b22e(i-1), rwork(iu2sn+i-1),rwork(iu2cs+i-1), &
                              r )
                 else if( nu < mu ) then
                    call stdlib_${c2ri(ci)}$lartgs( b21e(i), b21e(i+1), nu, rwork(iu2cs+i-1),rwork(iu2sn+i-1)&
                               )
                 else
                    call stdlib_${c2ri(ci)}$lartgs( b22d(i), b22e(i), mu, rwork(iu2cs+i-1),rwork(iu2sn+i-1) )
                              
                 end if
                 rwork(iu2cs+i-1) = -rwork(iu2cs+i-1)
                 rwork(iu2sn+i-1) = -rwork(iu2sn+i-1)
                 temp = rwork(iu1cs+i-1)*b11e(i) + rwork(iu1sn+i-1)*b11d(i+1)
                 b11d(i+1) = rwork(iu1cs+i-1)*b11d(i+1) -rwork(iu1sn+i-1)*b11e(i)
                 b11e(i) = temp
                 if( i < imax - 1 ) then
                    b11bulge = rwork(iu1sn+i-1)*b11e(i+1)
                    b11e(i+1) = rwork(iu1cs+i-1)*b11e(i+1)
                 end if
                 temp = rwork(iu2cs+i-1)*b21e(i) + rwork(iu2sn+i-1)*b21d(i+1)
                 b21d(i+1) = rwork(iu2cs+i-1)*b21d(i+1) -rwork(iu2sn+i-1)*b21e(i)
                 b21e(i) = temp
                 if( i < imax - 1 ) then
                    b21bulge = rwork(iu2sn+i-1)*b21e(i+1)
                    b21e(i+1) = rwork(iu2cs+i-1)*b21e(i+1)
                 end if
                 temp = rwork(iu1cs+i-1)*b12d(i) + rwork(iu1sn+i-1)*b12e(i)
                 b12e(i) = rwork(iu1cs+i-1)*b12e(i) -rwork(iu1sn+i-1)*b12d(i)
                 b12d(i) = temp
                 b12bulge = rwork(iu1sn+i-1)*b12d(i+1)
                 b12d(i+1) = rwork(iu1cs+i-1)*b12d(i+1)
                 temp = rwork(iu2cs+i-1)*b22d(i) + rwork(iu2sn+i-1)*b22e(i)
                 b22e(i) = rwork(iu2cs+i-1)*b22e(i) -rwork(iu2sn+i-1)*b22d(i)
                 b22d(i) = temp
                 b22bulge = rwork(iu2sn+i-1)*b22d(i+1)
                 b22d(i+1) = rwork(iu2cs+i-1)*b22d(i+1)
              end do
              ! compute phi(imax-1)
              x1 = sin(theta(imax-1))*b11e(imax-1) +cos(theta(imax-1))*b21e(imax-1)
              y1 = sin(theta(imax-1))*b12d(imax-1) +cos(theta(imax-1))*b22d(imax-1)
              y2 = sin(theta(imax-1))*b12bulge + cos(theta(imax-1))*b22bulge
              phi(imax-1) = atan2( abs(x1), sqrt(y1**2+y2**2) )
              ! chase bulges from b12(imax-1,imax) and b22(imax-1,imax)
              restart12 = b12d(imax-1)**2 + b12bulge**2 <= thresh**2
              restart22 = b22d(imax-1)**2 + b22bulge**2 <= thresh**2
              if( .not. restart12 .and. .not. restart22 ) then
                 call stdlib_${c2ri(ci)}$lartgp( y2, y1, rwork(iv2tsn+imax-1-1),rwork(iv2tcs+imax-1-1), r )
                           
              else if( .not. restart12 .and. restart22 ) then
                 call stdlib_${c2ri(ci)}$lartgp( b12bulge, b12d(imax-1),rwork(iv2tsn+imax-1-1),rwork(iv2tcs+&
                           imax-1-1), r )
              else if( restart12 .and. .not. restart22 ) then
                 call stdlib_${c2ri(ci)}$lartgp( b22bulge, b22d(imax-1),rwork(iv2tsn+imax-1-1),rwork(iv2tcs+&
                           imax-1-1), r )
              else if( nu < mu ) then
                 call stdlib_${c2ri(ci)}$lartgs( b12e(imax-1), b12d(imax), nu,rwork(iv2tcs+imax-1-1),rwork(&
                           iv2tsn+imax-1-1) )
              else
                 call stdlib_${c2ri(ci)}$lartgs( b22e(imax-1), b22d(imax), mu,rwork(iv2tcs+imax-1-1),rwork(&
                           iv2tsn+imax-1-1) )
              end if
              temp = rwork(iv2tcs+imax-1-1)*b12e(imax-1) +rwork(iv2tsn+imax-1-1)*b12d(imax)
                        
              b12d(imax) = rwork(iv2tcs+imax-1-1)*b12d(imax) -rwork(iv2tsn+imax-1-1)*b12e(imax-1)
                        
              b12e(imax-1) = temp
              temp = rwork(iv2tcs+imax-1-1)*b22e(imax-1) +rwork(iv2tsn+imax-1-1)*b22d(imax)
                        
              b22d(imax) = rwork(iv2tcs+imax-1-1)*b22d(imax) -rwork(iv2tsn+imax-1-1)*b22e(imax-1)
                        
              b22e(imax-1) = temp
              ! update singular vectors
              if( wantu1 ) then
                 if( colmajor ) then
                    call stdlib_${ci}$lasr( 'R', 'V', 'F', p, imax-imin+1,rwork(iu1cs+imin-1), rwork(&
                              iu1sn+imin-1),u1(1,imin), ldu1 )
                 else
                    call stdlib_${ci}$lasr( 'L', 'V', 'F', imax-imin+1, p,rwork(iu1cs+imin-1), rwork(&
                              iu1sn+imin-1),u1(imin,1), ldu1 )
                 end if
              end if
              if( wantu2 ) then
                 if( colmajor ) then
                    call stdlib_${ci}$lasr( 'R', 'V', 'F', m-p, imax-imin+1,rwork(iu2cs+imin-1), rwork(&
                              iu2sn+imin-1),u2(1,imin), ldu2 )
                 else
                    call stdlib_${ci}$lasr( 'L', 'V', 'F', imax-imin+1, m-p,rwork(iu2cs+imin-1), rwork(&
                              iu2sn+imin-1),u2(imin,1), ldu2 )
                 end if
              end if
              if( wantv1t ) then
                 if( colmajor ) then
                    call stdlib_${ci}$lasr( 'L', 'V', 'F', imax-imin+1, q,rwork(iv1tcs+imin-1), rwork(&
                              iv1tsn+imin-1),v1t(imin,1), ldv1t )
                 else
                    call stdlib_${ci}$lasr( 'R', 'V', 'F', q, imax-imin+1,rwork(iv1tcs+imin-1), rwork(&
                              iv1tsn+imin-1),v1t(1,imin), ldv1t )
                 end if
              end if
              if( wantv2t ) then
                 if( colmajor ) then
                    call stdlib_${ci}$lasr( 'L', 'V', 'F', imax-imin+1, m-q,rwork(iv2tcs+imin-1), &
                              rwork(iv2tsn+imin-1),v2t(imin,1), ldv2t )
                 else
                    call stdlib_${ci}$lasr( 'R', 'V', 'F', m-q, imax-imin+1,rwork(iv2tcs+imin-1), &
                              rwork(iv2tsn+imin-1),v2t(1,imin), ldv2t )
                 end if
              end if
              ! fix signs on b11(imax-1,imax) and b21(imax-1,imax)
              if( b11e(imax-1)+b21e(imax-1) > 0 ) then
                 b11d(imax) = -b11d(imax)
                 b21d(imax) = -b21d(imax)
                 if( wantv1t ) then
                    if( colmajor ) then
                       call stdlib_${ci}$scal( q, cnegone, v1t(imax,1), ldv1t )
                    else
                       call stdlib_${ci}$scal( q, cnegone, v1t(1,imax), 1 )
                    end if
                 end if
              end if
              ! compute theta(imax)
              x1 = cos(phi(imax-1))*b11d(imax) +sin(phi(imax-1))*b12e(imax-1)
              y1 = cos(phi(imax-1))*b21d(imax) +sin(phi(imax-1))*b22e(imax-1)
              theta(imax) = atan2( abs(y1), abs(x1) )
              ! fix signs on b11(imax,imax), b12(imax,imax-1), b21(imax,imax),
              ! and b22(imax,imax-1)
              if( b11d(imax)+b12e(imax-1) < 0 ) then
                 b12d(imax) = -b12d(imax)
                 if( wantu1 ) then
                    if( colmajor ) then
                       call stdlib_${ci}$scal( p, cnegone, u1(1,imax), 1 )
                    else
                       call stdlib_${ci}$scal( p, cnegone, u1(imax,1), ldu1 )
                    end if
                 end if
              end if
              if( b21d(imax)+b22e(imax-1) > 0 ) then
                 b22d(imax) = -b22d(imax)
                 if( wantu2 ) then
                    if( colmajor ) then
                       call stdlib_${ci}$scal( m-p, cnegone, u2(1,imax), 1 )
                    else
                       call stdlib_${ci}$scal( m-p, cnegone, u2(imax,1), ldu2 )
                    end if
                 end if
              end if
              ! fix signs on b12(imax,imax) and b22(imax,imax)
              if( b12d(imax)+b22d(imax) < 0 ) then
                 if( wantv2t ) then
                    if( colmajor ) then
                       call stdlib_${ci}$scal( m-q, cnegone, v2t(imax,1), ldv2t )
                    else
                       call stdlib_${ci}$scal( m-q, cnegone, v2t(1,imax), 1 )
                    end if
                 end if
              end if
              ! test for negligible sines or cosines
              do i = imin, imax
                 if( theta(i) < thresh ) then
                    theta(i) = zero
                 else if( theta(i) > piover2-thresh ) then
                    theta(i) = piover2
                 end if
              end do
              do i = imin, imax-1
                 if( phi(i) < thresh ) then
                    phi(i) = zero
                 else if( phi(i) > piover2-thresh ) then
                    phi(i) = piover2
                 end if
              end do
              ! deflate
              if (imax > 1) then
                 do while( phi(imax-1) == zero )
                    imax = imax - 1
                    if (imax <= 1) exit
                 end do
              end if
              if( imin > imax - 1 )imin = imax - 1
              if (imin > 1) then
                 do while (phi(imin-1) /= zero)
                     imin = imin - 1
                     if (imin <= 1) exit
                 end do
              end if
              ! repeat main iteration loop
           end do
           ! postprocessing: order theta from least to greatest
           do i = 1, q
              mini = i
              thetamin = theta(i)
              do j = i+1, q
                 if( theta(j) < thetamin ) then
                    mini = j
                    thetamin = theta(j)
                 end if
              end do
              if( mini /= i ) then
                 theta(mini) = theta(i)
                 theta(i) = thetamin
                 if( colmajor ) then
                    if( wantu1 )call stdlib_${ci}$swap( p, u1(1,i), 1, u1(1,mini), 1 )
                    if( wantu2 )call stdlib_${ci}$swap( m-p, u2(1,i), 1, u2(1,mini), 1 )
                    if( wantv1t )call stdlib_${ci}$swap( q, v1t(i,1), ldv1t, v1t(mini,1), ldv1t )
                              
                    if( wantv2t )call stdlib_${ci}$swap( m-q, v2t(i,1), ldv2t, v2t(mini,1),ldv2t )
                              
                 else
                    if( wantu1 )call stdlib_${ci}$swap( p, u1(i,1), ldu1, u1(mini,1), ldu1 )
                    if( wantu2 )call stdlib_${ci}$swap( m-p, u2(i,1), ldu2, u2(mini,1), ldu2 )
                    if( wantv1t )call stdlib_${ci}$swap( q, v1t(1,i), 1, v1t(1,mini), 1 )
                    if( wantv2t )call stdlib_${ci}$swap( m-q, v2t(1,i), 1, v2t(1,mini), 1 )
                 end if
              end if
           end do
           return
     end subroutine stdlib_${ci}$bbcsd

#:endif
#:endfor


end module stdlib_lapack_cosine_sine
