#:include "common.fypp" 
submodule(stdlib_lapack) stdlib_lapack_eigv_comp
  implicit none(type,external)


  contains

     module subroutine stdlib_shgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alphar, alphai, &
     !! SHGEQZ computes the eigenvalues of a real matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the double-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a real matrix pair (A,B):
     !! A = Q1*H*Z1**T,  B = Q1*T*Z1**T,
     !! as computed by SGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**T,  T = Q*P*Z**T,
     !! where Q and Z are orthogonal matrices, P is an upper triangular
     !! matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
     !! diagonal blocks.
     !! The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
     !! (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
     !! eigenvalues.
     !! Additionally, the 2-by-2 upper triangular diagonal blocks of P
     !! corresponding to 2-by-2 blocks of S are reduced to positive diagonal
     !! form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
     !! P(j,j) > 0, and P(j+1,j+1) > 0.
     !! Optionally, the orthogonal matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! orthogonal matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the orthogonal matrices from SGGHRD that reduced
     !! the matrix pair (A,B) to generalized upper Hessenberg form, then the
     !! output matrices Q1*Q and Z1*Z are the orthogonal factors from the
     !! generalized Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
     !! of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
     !! complex and beta real.
     !! If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
     !! generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! Real eigenvalues can be read directly from the generalized Schur
     !! form:
     !! alpha = S(i,i), beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
               beta, q, ldq, z, ldz, work,lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz, job
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(out) :: alphai(*), alphar(*), beta(*), work(*)
           real(sp), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: safety = 1.0e+2_sp
          ! $                     safety = one )
           
           ! Local Scalars 
           logical(lk) :: ilazr2, ilazro, ilpivt, ilq, ilschr, ilz, lquery
           integer(ilp) :: icompq, icompz, ifirst, ifrstm, iiter, ilast, ilastm, in, ischur, &
                     istart, j, jc, jch, jiter, jr, maxit
           real(sp) :: a11, a12, a1i, a1r, a21, a22, a2i, a2r, ad11, ad11l, ad12, ad12l, ad21, &
           ad21l, ad22, ad22l, ad32l, an, anorm, ascale, atol, b11, b1a, b1i, b1r, b22, b2a, b2i, &
           b2r, bn, bnorm, bscale, btol, c, c11i, c11r, c12, c21, c22i, c22r, cl, cq, cr, cz, &
           eshift, s, s1, s1inv, s2, safmax, safmin, scale, sl, sqi, sqr, sr, szi, szr, t1, tau, &
           temp, temp2, tempi, tempr, u1, u12, u12l, u2, ulp, vs, w11, w12, w21, w22, wabs, wi, &
                     wr, wr2
           ! Local Arrays 
           real(sp) :: v(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode job, compq, compz
           if( stdlib_lsame( job, 'E' ) ) then
              ilschr = .false.
              ischur = 1
           else if( stdlib_lsame( job, 'S' ) ) then
              ilschr = .true.
              ischur = 2
           else
              ischur = 0
           end if
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! check argument values
           info = 0
           work( 1 ) = max( 1, n )
           lquery = ( lwork==-1 )
           if( ischur==0 ) then
              info = -1
           else if( icompq==0 ) then
              info = -2
           else if( icompz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( ldh<n ) then
              info = -8
           else if( ldt<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -15
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -17
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SHGEQZ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              work( 1 ) = real( 1,KIND=sp)
              return
           end if
           ! initialize q and z
           if( icompq==3 )call stdlib_slaset( 'FULL', n, n, zero, one, q, ldq )
           if( icompz==3 )call stdlib_slaset( 'FULL', n, n, zero, one, z, ldz )
           ! machine constants
           in = ihi + 1 - ilo
           safmin = stdlib_slamch( 'S' )
           safmax = one / safmin
           ulp = stdlib_slamch( 'E' )*stdlib_slamch( 'B' )
           anorm = stdlib_slanhs( 'F', in, h( ilo, ilo ), ldh, work )
           bnorm = stdlib_slanhs( 'F', in, t( ilo, ilo ), ldt, work )
           atol = max( safmin, ulp*anorm )
           btol = max( safmin, ulp*bnorm )
           ascale = one / max( safmin, anorm )
           bscale = one / max( safmin, bnorm )
           ! set eigenvalues ihi+1:n
           do j = ihi + 1, n
              if( t( j, j )<zero ) then
                 if( ilschr ) then
                    do jr = 1, j
                       h( jr, j ) = -h( jr, j )
                       t( jr, j ) = -t( jr, j )
                    end do
                 else
                    h( j, j ) = -h( j, j )
                    t( j, j ) = -t( j, j )
                 end if
                 if( ilz ) then
                    do jr = 1, n
                       z( jr, j ) = -z( jr, j )
                    end do
                 end if
              end if
              alphar( j ) = h( j, j )
              alphai( j ) = zero
              beta( j ) = t( j, j )
           end do
           ! if ihi < ilo, skip qz steps
           if( ihi<ilo )go to 380
           ! main qz iteration loop
           ! initialize dynamic indices
           ! eigenvalues ilast+1:n have been found.
              ! column operations modify rows ifrstm:whatever.
              ! row operations modify columns whatever:ilastm.
           ! if only eigenvalues are being computed, then
              ! ifrstm is the row of the last splitting row above row ilast;
              ! this is always at least ilo.
           ! iiter counts iterations since the last eigenvalue was found,
              ! to tell when to use an extraordinary shift.
           ! maxit is the maximum number of qz sweeps allowed.
           ilast = ihi
           if( ilschr ) then
              ifrstm = 1
              ilastm = n
           else
              ifrstm = ilo
              ilastm = ihi
           end if
           iiter = 0
           eshift = zero
           maxit = 30*( ihi-ilo+1 )
           loop_360: do jiter = 1, maxit
              ! split the matrix if possible.
              ! two tests:
                 ! 1: h(j,j-1)=0  or  j=ilo
                 ! 2: t(j,j)=0
              if( ilast==ilo ) then
                 ! special case: j=ilast
                 go to 80
              else
                 if( abs( h( ilast, ilast-1 ) )<=max( safmin, ulp*(abs( h( ilast, ilast ) ) + abs(&
                            h( ilast-1, ilast-1 ) )) ) ) then
                    h( ilast, ilast-1 ) = zero
                    go to 80
                 end if
              end if
              if( abs( t( ilast, ilast ) )<=max( safmin, ulp*(abs( t( ilast - 1, ilast ) ) + abs( &
                        t( ilast-1, ilast-1 )) ) ) ) then
                 t( ilast, ilast ) = zero
                 go to 70
              end if
              ! general case: j<ilast
              loop_60: do j = ilast - 1, ilo, -1
                 ! test 1: for h(j,j-1)=0 or j=ilo
                 if( j==ilo ) then
                    ilazro = .true.
                 else
                    if( abs( h( j, j-1 ) )<=max( safmin, ulp*(abs( h( j, j ) ) + abs( h( j-1, j-1 &
                              ) )) ) ) then
                       h( j, j-1 ) = zero
                       ilazro = .true.
                    else
                       ilazro = .false.
                    end if
                 end if
                 ! test 2: for t(j,j)=0
                 temp = abs ( t( j, j + 1 ) )
                 if ( j > ilo )temp = temp + abs ( t( j - 1, j ) )
                 if( abs( t( j, j ) )<max( safmin,ulp*temp ) ) then
                    t( j, j ) = zero
                    ! test 1a: check for 2 consecutive small subdiagonals in a
                    ilazr2 = .false.
                    if( .not.ilazro ) then
                       temp = abs( h( j, j-1 ) )
                       temp2 = abs( h( j, j ) )
                       tempr = max( temp, temp2 )
                       if( tempr<one .and. tempr/=zero ) then
                          temp = temp / tempr
                          temp2 = temp2 / tempr
                       end if
                       if( temp*( ascale*abs( h( j+1, j ) ) )<=temp2*( ascale*atol ) )ilazr2 = &
                                 .true.
                    end if
                    ! if both tests pass (1
                    ! element of b in the block is zero, split a 1x1 block off
                    ! at the top. (i.e., at the j-th row/column) the leading
                    ! diagonal element of the remainder can also be zero, so
                    ! this may have to be done repeatedly.
                    if( ilazro .or. ilazr2 ) then
                       do jch = j, ilast - 1
                          temp = h( jch, jch )
                          call stdlib_slartg( temp, h( jch+1, jch ), c, s,h( jch, jch ) )
                          h( jch+1, jch ) = zero
                          call stdlib_srot( ilastm-jch, h( jch, jch+1 ), ldh,h( jch+1, jch+1 ), &
                                    ldh, c, s )
                          call stdlib_srot( ilastm-jch, t( jch, jch+1 ), ldt,t( jch+1, jch+1 ), &
                                    ldt, c, s )
                          if( ilq )call stdlib_srot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, s )
                                    
                          if( ilazr2 )h( jch, jch-1 ) = h( jch, jch-1 )*c
                          ilazr2 = .false.
                          if( abs( t( jch+1, jch+1 ) )>=btol ) then
                             if( jch+1>=ilast ) then
                                go to 80
                             else
                                ifirst = jch + 1
                                go to 110
                             end if
                          end if
                          t( jch+1, jch+1 ) = zero
                       end do
                       go to 70
                    else
                       ! only test 2 passed -- chase the zero to t(ilast,ilast)
                       ! then process as in the case t(ilast,ilast)=0
                       do jch = j, ilast - 1
                          temp = t( jch, jch+1 )
                          call stdlib_slartg( temp, t( jch+1, jch+1 ), c, s,t( jch, jch+1 ) )
                                    
                          t( jch+1, jch+1 ) = zero
                          if( jch<ilastm-1 )call stdlib_srot( ilastm-jch-1, t( jch, jch+2 ), ldt,&
                                    t( jch+1, jch+2 ), ldt, c, s )
                          call stdlib_srot( ilastm-jch+2, h( jch, jch-1 ), ldh,h( jch+1, jch-1 ), &
                                    ldh, c, s )
                          if( ilq )call stdlib_srot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, s )
                                    
                          temp = h( jch+1, jch )
                          call stdlib_slartg( temp, h( jch+1, jch-1 ), c, s,h( jch+1, jch ) )
                                    
                          h( jch+1, jch-1 ) = zero
                          call stdlib_srot( jch+1-ifrstm, h( ifrstm, jch ), 1,h( ifrstm, jch-1 ), &
                                    1, c, s )
                          call stdlib_srot( jch-ifrstm, t( ifrstm, jch ), 1,t( ifrstm, jch-1 ), 1,&
                                     c, s )
                          if( ilz )call stdlib_srot( n, z( 1, jch ), 1, z( 1, jch-1 ), 1,c, s )
                                    
                       end do
                       go to 70
                    end if
                 else if( ilazro ) then
                    ! only test 1 passed -- work on j:ilast
                    ifirst = j
                    go to 110
                 end if
                 ! neither test passed -- try next j
              end do loop_60
              ! (drop-through is "impossible")
              info = n + 1
              go to 420
              ! t(ilast,ilast)=0 -- clear h(ilast,ilast-1) to split off a
              ! 1x1 block.
              70 continue
              temp = h( ilast, ilast )
              call stdlib_slartg( temp, h( ilast, ilast-1 ), c, s,h( ilast, ilast ) )
              h( ilast, ilast-1 ) = zero
              call stdlib_srot( ilast-ifrstm, h( ifrstm, ilast ), 1,h( ifrstm, ilast-1 ), 1, c, s &
                        )
              call stdlib_srot( ilast-ifrstm, t( ifrstm, ilast ), 1,t( ifrstm, ilast-1 ), 1, c, s &
                        )
              if( ilz )call stdlib_srot( n, z( 1, ilast ), 1, z( 1, ilast-1 ), 1, c, s )
              ! h(ilast,ilast-1)=0 -- standardize b, set alphar, alphai,
                                    ! and beta
                                    80 continue
              if( t( ilast, ilast )<zero ) then
                 if( ilschr ) then
                    do j = ifrstm, ilast
                       h( j, ilast ) = -h( j, ilast )
                       t( j, ilast ) = -t( j, ilast )
                    end do
                 else
                    h( ilast, ilast ) = -h( ilast, ilast )
                    t( ilast, ilast ) = -t( ilast, ilast )
                 end if
                 if( ilz ) then
                    do j = 1, n
                       z( j, ilast ) = -z( j, ilast )
                    end do
                 end if
              end if
              alphar( ilast ) = h( ilast, ilast )
              alphai( ilast ) = zero
              beta( ilast ) = t( ilast, ilast )
              ! go to next block -- exit if finished.
              ilast = ilast - 1
              if( ilast<ilo )go to 380
              ! reset counters
              iiter = 0
              eshift = zero
              if( .not.ilschr ) then
                 ilastm = ilast
                 if( ifrstm>ilast )ifrstm = ilo
              end if
              go to 350
              ! qz step
              ! this iteration only involves rows/columns ifirst:ilast. we
              ! assume ifirst < ilast, and that the diagonal of b is non-zero.
              110 continue
              iiter = iiter + 1
              if( .not.ilschr ) then
                 ifrstm = ifirst
              end if
              ! compute single shifts.
              ! at this point, ifirst < ilast, and the diagonal elements of
              ! t(ifirst:ilast,ifirst,ilast) are larger than btol (in
              ! magnitude)
              if( ( iiter / 10 )*10==iiter ) then
                 ! exceptional shift.  chosen for no particularly good reason.
                 ! (single shift only.)
                 if( ( real( maxit,KIND=sp)*safmin )*abs( h( ilast, ilast-1 ) )<abs( t( ilast-1, &
                           ilast-1 ) ) ) then
                    eshift = h( ilast, ilast-1 ) /t( ilast-1, ilast-1 )
                 else
                    eshift = eshift + one / ( safmin*real( maxit,KIND=sp) )
                 end if
                 s1 = one
                 wr = eshift
              else
                 ! shifts based on the generalized eigenvalues of the
                 ! bottom-right 2x2 block of a and b. the first eigenvalue
                 ! returned by stdlib_slag2 is the wilkinson shift (aep p.512_sp),
                 call stdlib_slag2( h( ilast-1, ilast-1 ), ldh,t( ilast-1, ilast-1 ), ldt, &
                           safmin*safety, s1,s2, wr, wr2, wi )
                 if ( abs( (wr/s1)*t( ilast, ilast ) - h( ilast, ilast ) )> abs( (wr2/s2)*t( &
                           ilast, ilast )- h( ilast, ilast ) ) ) then
                    temp = wr
                    wr = wr2
                    wr2 = temp
                    temp = s1
                    s1 = s2
                    s2 = temp
                 end if
                 temp = max( s1, safmin*max( one, abs( wr ), abs( wi ) ) )
                 if( wi/=zero )go to 200
              end if
              ! fiddle with shift to avoid overflow
              temp = min( ascale, one )*( half*safmax )
              if( s1>temp ) then
                 scale = temp / s1
              else
                 scale = one
              end if
              temp = min( bscale, one )*( half*safmax )
              if( abs( wr )>temp )scale = min( scale, temp / abs( wr ) )
              s1 = scale*s1
              wr = scale*wr
              ! now check for two consecutive small subdiagonals.
              do j = ilast - 1, ifirst + 1, -1
                 istart = j
                 temp = abs( s1*h( j, j-1 ) )
                 temp2 = abs( s1*h( j, j )-wr*t( j, j ) )
                 tempr = max( temp, temp2 )
                 if( tempr<one .and. tempr/=zero ) then
                    temp = temp / tempr
                    temp2 = temp2 / tempr
                 end if
                 if( abs( ( ascale*h( j+1, j ) )*temp )<=( ascale*atol )*temp2 )go to 130
              end do
              istart = ifirst
              130 continue
              ! do an implicit single-shift qz sweep.
              ! initial q
              temp = s1*h( istart, istart ) - wr*t( istart, istart )
              temp2 = s1*h( istart+1, istart )
              call stdlib_slartg( temp, temp2, c, s, tempr )
              ! sweep
              loop_190: do j = istart, ilast - 1
                 if( j>istart ) then
                    temp = h( j, j-1 )
                    call stdlib_slartg( temp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                    h( j+1, j-1 ) = zero
                 end if
                 do jc = j, ilastm
                    temp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -s*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = temp
                    temp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -s*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = temp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       temp = c*q( jr, j ) + s*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = temp
                    end do
                 end if
                 temp = t( j+1, j+1 )
                 call stdlib_slartg( temp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = zero
                 do jr = ifrstm, min( j+2, ilast )
                    temp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -s*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = temp
                 end do
                 do jr = ifrstm, j
                    temp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -s*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = temp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       temp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -s*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = temp
                    end do
                 end if
              end do loop_190
              go to 350
              ! use francis double-shift
              ! note: the francis double-shift should work with real shifts,
                    ! but only if the block is at least 3x3.
                    ! this code may break if this point is reached with
                    ! a 2x2 block with real eigenvalues.
                    200 continue
              if( ifirst+1==ilast ) then
                 ! special case -- 2x2 block with complex eigenvectors
                 ! step 1: standardize, that is, rotate so that
                             ! ( b11  0  )
                         ! b = (         )  with b11 non-negative.
                             ! (  0  b22 )
                 call stdlib_slasv2( t( ilast-1, ilast-1 ), t( ilast-1, ilast ),t( ilast, ilast ),&
                            b22, b11, sr, cr, sl, cl )
                 if( b11<zero ) then
                    cr = -cr
                    sr = -sr
                    b11 = -b11
                    b22 = -b22
                 end if
                 call stdlib_srot( ilastm+1-ifirst, h( ilast-1, ilast-1 ), ldh,h( ilast, ilast-1 )&
                           , ldh, cl, sl )
                 call stdlib_srot( ilast+1-ifrstm, h( ifrstm, ilast-1 ), 1,h( ifrstm, ilast ), 1, &
                           cr, sr )
                 if( ilast<ilastm )call stdlib_srot( ilastm-ilast, t( ilast-1, ilast+1 ), ldt,t( &
                           ilast, ilast+1 ), ldt, cl, sl )
                 if( ifrstm<ilast-1 )call stdlib_srot( ifirst-ifrstm, t( ifrstm, ilast-1 ), 1,t( &
                           ifrstm, ilast ), 1, cr, sr )
                 if( ilq )call stdlib_srot( n, q( 1, ilast-1 ), 1, q( 1, ilast ), 1, cl,sl )
                           
                 if( ilz )call stdlib_srot( n, z( 1, ilast-1 ), 1, z( 1, ilast ), 1, cr,sr )
                           
                 t( ilast-1, ilast-1 ) = b11
                 t( ilast-1, ilast ) = zero
                 t( ilast, ilast-1 ) = zero
                 t( ilast, ilast ) = b22
                 ! if b22 is negative, negate column ilast
                 if( b22<zero ) then
                    do j = ifrstm, ilast
                       h( j, ilast ) = -h( j, ilast )
                       t( j, ilast ) = -t( j, ilast )
                    end do
                    if( ilz ) then
                       do j = 1, n
                          z( j, ilast ) = -z( j, ilast )
                       end do
                    end if
                    b22 = -b22
                 end if
                 ! step 2: compute alphar, alphai, and beta (see refs.)
                 ! recompute shift
                 call stdlib_slag2( h( ilast-1, ilast-1 ), ldh,t( ilast-1, ilast-1 ), ldt, &
                           safmin*safety, s1,temp, wr, temp2, wi )
                 ! if standardization has perturbed the shift onto real line,
                 ! do another (real single-shift) qr step.
                 if( wi==zero )go to 350
                 s1inv = one / s1
                 ! do eispack (qzval) computation of alpha and beta
                 a11 = h( ilast-1, ilast-1 )
                 a21 = h( ilast, ilast-1 )
                 a12 = h( ilast-1, ilast )
                 a22 = h( ilast, ilast )
                 ! compute complex givens rotation on right
                 ! (assume some element of c = (sa - wb) > unfl )
                                  ! __
                 ! (sa - wb) ( cz   -sz )
                           ! ( sz    cz )
                 c11r = s1*a11 - wr*b11
                 c11i = -wi*b11
                 c12 = s1*a12
                 c21 = s1*a21
                 c22r = s1*a22 - wr*b22
                 c22i = -wi*b22
                 if( abs( c11r )+abs( c11i )+abs( c12 )>abs( c21 )+abs( c22r )+abs( c22i ) ) &
                           then
                    t1 = stdlib_slapy3( c12, c11r, c11i )
                    cz = c12 / t1
                    szr = -c11r / t1
                    szi = -c11i / t1
                 else
                    cz = stdlib_slapy2( c22r, c22i )
                    if( cz<=safmin ) then
                       cz = zero
                       szr = one
                       szi = zero
                    else
                       tempr = c22r / cz
                       tempi = c22i / cz
                       t1 = stdlib_slapy2( cz, c21 )
                       cz = cz / t1
                       szr = -c21*tempr / t1
                       szi = c21*tempi / t1
                    end if
                 end if
                 ! compute givens rotation on left
                 ! (  cq   sq )
                 ! (  __      )  a or b
                 ! ( -sq   cq )
                 an = abs( a11 ) + abs( a12 ) + abs( a21 ) + abs( a22 )
                 bn = abs( b11 ) + abs( b22 )
                 wabs = abs( wr ) + abs( wi )
                 if( s1*an>wabs*bn ) then
                    cq = cz*b11
                    sqr = szr*b22
                    sqi = -szi*b22
                 else
                    a1r = cz*a11 + szr*a12
                    a1i = szi*a12
                    a2r = cz*a21 + szr*a22
                    a2i = szi*a22
                    cq = stdlib_slapy2( a1r, a1i )
                    if( cq<=safmin ) then
                       cq = zero
                       sqr = one
                       sqi = zero
                    else
                       tempr = a1r / cq
                       tempi = a1i / cq
                       sqr = tempr*a2r + tempi*a2i
                       sqi = tempi*a2r - tempr*a2i
                    end if
                 end if
                 t1 = stdlib_slapy3( cq, sqr, sqi )
                 cq = cq / t1
                 sqr = sqr / t1
                 sqi = sqi / t1
                 ! compute diagonal elements of qbz
                 tempr = sqr*szr - sqi*szi
                 tempi = sqr*szi + sqi*szr
                 b1r = cq*cz*b11 + tempr*b22
                 b1i = tempi*b22
                 b1a = stdlib_slapy2( b1r, b1i )
                 b2r = cq*cz*b22 + tempr*b11
                 b2i = -tempi*b11
                 b2a = stdlib_slapy2( b2r, b2i )
                 ! normalize so beta > 0, and im( alpha1 ) > 0
                 beta( ilast-1 ) = b1a
                 beta( ilast ) = b2a
                 alphar( ilast-1 ) = ( wr*b1a )*s1inv
                 alphai( ilast-1 ) = ( wi*b1a )*s1inv
                 alphar( ilast ) = ( wr*b2a )*s1inv
                 alphai( ilast ) = -( wi*b2a )*s1inv
                 ! step 3: go to next block -- exit if finished.
                 ilast = ifirst - 1
                 if( ilast<ilo )go to 380
                 ! reset counters
                 iiter = 0
                 eshift = zero
                 if( .not.ilschr ) then
                    ilastm = ilast
                    if( ifrstm>ilast )ifrstm = ilo
                 end if
                 go to 350
              else
                 ! usual case: 3x3 or larger block, using francis implicit
                             ! double-shift
                                          ! 2
                 ! eigenvalue equation is  w  - c w + d = 0,
                                               ! -1 2        -1
                 ! so compute 1st column of  (a b  )  - c a b   + d
                 ! using the formula in qzit (from eispack)
                 ! we assume that the block is at least 3x3
                 ad11 = ( ascale*h( ilast-1, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad21 = ( ascale*h( ilast, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad12 = ( ascale*h( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad22 = ( ascale*h( ilast, ilast ) ) /( bscale*t( ilast, ilast ) )
                 u12 = t( ilast-1, ilast ) / t( ilast, ilast )
                 ad11l = ( ascale*h( ifirst, ifirst ) ) /( bscale*t( ifirst, ifirst ) )
                 ad21l = ( ascale*h( ifirst+1, ifirst ) ) /( bscale*t( ifirst, ifirst ) )
                 ad12l = ( ascale*h( ifirst, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 ad22l = ( ascale*h( ifirst+1, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 ad32l = ( ascale*h( ifirst+2, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 u12l = t( ifirst, ifirst+1 ) / t( ifirst+1, ifirst+1 )
                 v( 1 ) = ( ad11-ad11l )*( ad22-ad11l ) - ad12*ad21 +ad21*u12*ad11l + ( ad12l-&
                           ad11l*u12l )*ad21l
                 v( 2 ) = ( ( ad22l-ad11l )-ad21l*u12l-( ad11-ad11l )-( ad22-ad11l )+ad21*u12 )&
                           *ad21l
                 v( 3 ) = ad32l*ad21l
                 istart = ifirst
                 call stdlib_slarfg( 3, v( 1 ), v( 2 ), 1, tau )
                 v( 1 ) = one
                 ! sweep
                 loop_290: do j = istart, ilast - 2
                    ! all but last elements: use 3x3 householder transforms.
                    ! zero (j-1)st column of a
                    if( j>istart ) then
                       v( 1 ) = h( j, j-1 )
                       v( 2 ) = h( j+1, j-1 )
                       v( 3 ) = h( j+2, j-1 )
                       call stdlib_slarfg( 3, h( j, j-1 ), v( 2 ), 1, tau )
                       v( 1 ) = one
                       h( j+1, j-1 ) = zero
                       h( j+2, j-1 ) = zero
                    end if
                    do jc = j, ilastm
                       temp = tau*( h( j, jc )+v( 2 )*h( j+1, jc )+v( 3 )*h( j+2, jc ) )
                       h( j, jc ) = h( j, jc ) - temp
                       h( j+1, jc ) = h( j+1, jc ) - temp*v( 2 )
                       h( j+2, jc ) = h( j+2, jc ) - temp*v( 3 )
                       temp2 = tau*( t( j, jc )+v( 2 )*t( j+1, jc )+v( 3 )*t( j+2, jc ) )
                       t( j, jc ) = t( j, jc ) - temp2
                       t( j+1, jc ) = t( j+1, jc ) - temp2*v( 2 )
                       t( j+2, jc ) = t( j+2, jc ) - temp2*v( 3 )
                    end do
                    if( ilq ) then
                       do jr = 1, n
                          temp = tau*( q( jr, j )+v( 2 )*q( jr, j+1 )+v( 3 )*q( jr, j+2 ) )
                                    
                          q( jr, j ) = q( jr, j ) - temp
                          q( jr, j+1 ) = q( jr, j+1 ) - temp*v( 2 )
                          q( jr, j+2 ) = q( jr, j+2 ) - temp*v( 3 )
                       end do
                    end if
                    ! zero j-th column of b (see slagbc for details)
                    ! swap rows to pivot
                    ilpivt = .false.
                    temp = max( abs( t( j+1, j+1 ) ), abs( t( j+1, j+2 ) ) )
                    temp2 = max( abs( t( j+2, j+1 ) ), abs( t( j+2, j+2 ) ) )
                    if( max( temp, temp2 )<safmin ) then
                       scale = zero
                       u1 = one
                       u2 = zero
                       go to 250
                    else if( temp>=temp2 ) then
                       w11 = t( j+1, j+1 )
                       w21 = t( j+2, j+1 )
                       w12 = t( j+1, j+2 )
                       w22 = t( j+2, j+2 )
                       u1 = t( j+1, j )
                       u2 = t( j+2, j )
                    else
                       w21 = t( j+1, j+1 )
                       w11 = t( j+2, j+1 )
                       w22 = t( j+1, j+2 )
                       w12 = t( j+2, j+2 )
                       u2 = t( j+1, j )
                       u1 = t( j+2, j )
                    end if
                    ! swap columns if nec.
                    if( abs( w12 )>abs( w11 ) ) then
                       ilpivt = .true.
                       temp = w12
                       temp2 = w22
                       w12 = w11
                       w22 = w21
                       w11 = temp
                       w21 = temp2
                    end if
                    ! lu-factor
                    temp = w21 / w11
                    u2 = u2 - temp*u1
                    w22 = w22 - temp*w12
                    w21 = zero
                    ! compute scale
                    scale = one
                    if( abs( w22 )<safmin ) then
                       scale = zero
                       u2 = one
                       u1 = -w12 / w11
                       go to 250
                    end if
                    if( abs( w22 )<abs( u2 ) )scale = abs( w22 / u2 )
                    if( abs( w11 )<abs( u1 ) )scale = min( scale, abs( w11 / u1 ) )
                    ! solve
                    u2 = ( scale*u2 ) / w22
                    u1 = ( scale*u1-w12*u2 ) / w11
                    250 continue
                    if( ilpivt ) then
                       temp = u2
                       u2 = u1
                       u1 = temp
                    end if
                    ! compute householder vector
                    t1 = sqrt( scale**2+u1**2+u2**2 )
                    tau = one + scale / t1
                    vs = -one / ( scale+t1 )
                    v( 1 ) = one
                    v( 2 ) = vs*u1
                    v( 3 ) = vs*u2
                    ! apply transformations from the right.
                    do jr = ifrstm, min( j+3, ilast )
                       temp = tau*( h( jr, j )+v( 2 )*h( jr, j+1 )+v( 3 )*h( jr, j+2 ) )
                       h( jr, j ) = h( jr, j ) - temp
                       h( jr, j+1 ) = h( jr, j+1 ) - temp*v( 2 )
                       h( jr, j+2 ) = h( jr, j+2 ) - temp*v( 3 )
                    end do
                    do jr = ifrstm, j + 2
                       temp = tau*( t( jr, j )+v( 2 )*t( jr, j+1 )+v( 3 )*t( jr, j+2 ) )
                       t( jr, j ) = t( jr, j ) - temp
                       t( jr, j+1 ) = t( jr, j+1 ) - temp*v( 2 )
                       t( jr, j+2 ) = t( jr, j+2 ) - temp*v( 3 )
                    end do
                    if( ilz ) then
                       do jr = 1, n
                          temp = tau*( z( jr, j )+v( 2 )*z( jr, j+1 )+v( 3 )*z( jr, j+2 ) )
                                    
                          z( jr, j ) = z( jr, j ) - temp
                          z( jr, j+1 ) = z( jr, j+1 ) - temp*v( 2 )
                          z( jr, j+2 ) = z( jr, j+2 ) - temp*v( 3 )
                       end do
                    end if
                    t( j+1, j ) = zero
                    t( j+2, j ) = zero
                 end do loop_290
                 ! last elements: use givens rotations
                 ! rotations from the left
                 j = ilast - 1
                 temp = h( j, j-1 )
                 call stdlib_slartg( temp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                 h( j+1, j-1 ) = zero
                 do jc = j, ilastm
                    temp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -s*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = temp
                    temp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -s*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = temp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       temp = c*q( jr, j ) + s*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = temp
                    end do
                 end if
                 ! rotations from the right.
                 temp = t( j+1, j+1 )
                 call stdlib_slartg( temp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = zero
                 do jr = ifrstm, ilast
                    temp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -s*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = temp
                 end do
                 do jr = ifrstm, ilast - 1
                    temp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -s*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = temp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       temp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -s*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = temp
                    end do
                 end if
                 ! end of double-shift code
              end if
              go to 350
              ! end of iteration loop
              350 continue
           end do loop_360
           ! drop-through = non-convergence
           info = ilast
           go to 420
           ! successful completion of all qz steps
           380 continue
           ! set eigenvalues 1:ilo-1
           do j = 1, ilo - 1
              if( t( j, j )<zero ) then
                 if( ilschr ) then
                    do jr = 1, j
                       h( jr, j ) = -h( jr, j )
                       t( jr, j ) = -t( jr, j )
                    end do
                 else
                    h( j, j ) = -h( j, j )
                    t( j, j ) = -t( j, j )
                 end if
                 if( ilz ) then
                    do jr = 1, n
                       z( jr, j ) = -z( jr, j )
                    end do
                 end if
              end if
              alphar( j ) = h( j, j )
              alphai( j ) = zero
              beta( j ) = t( j, j )
           end do
           ! normal termination
           info = 0
           ! exit (other than argument error) -- return optimal workspace size
           420 continue
           work( 1 ) = real( n,KIND=sp)
           return
     end subroutine stdlib_shgeqz

     module subroutine stdlib_dhgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alphar, alphai, &
     !! DHGEQZ computes the eigenvalues of a real matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the double-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a real matrix pair (A,B):
     !! A = Q1*H*Z1**T,  B = Q1*T*Z1**T,
     !! as computed by DGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**T,  T = Q*P*Z**T,
     !! where Q and Z are orthogonal matrices, P is an upper triangular
     !! matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
     !! diagonal blocks.
     !! The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
     !! (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
     !! eigenvalues.
     !! Additionally, the 2-by-2 upper triangular diagonal blocks of P
     !! corresponding to 2-by-2 blocks of S are reduced to positive diagonal
     !! form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
     !! P(j,j) > 0, and P(j+1,j+1) > 0.
     !! Optionally, the orthogonal matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! orthogonal matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the orthogonal matrices from DGGHRD that reduced
     !! the matrix pair (A,B) to generalized upper Hessenberg form, then the
     !! output matrices Q1*Q and Z1*Z are the orthogonal factors from the
     !! generalized Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
     !! of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
     !! complex and beta real.
     !! If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
     !! generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! Real eigenvalues can be read directly from the generalized Schur
     !! form:
     !! alpha = S(i,i), beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
               beta, q, ldq, z, ldz, work,lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz, job
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(out) :: alphai(*), alphar(*), beta(*), work(*)
           real(dp), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: safety = 1.0e+2_dp
          ! $                     safety = one )
           
           ! Local Scalars 
           logical(lk) :: ilazr2, ilazro, ilpivt, ilq, ilschr, ilz, lquery
           integer(ilp) :: icompq, icompz, ifirst, ifrstm, iiter, ilast, ilastm, in, ischur, &
                     istart, j, jc, jch, jiter, jr, maxit
           real(dp) :: a11, a12, a1i, a1r, a21, a22, a2i, a2r, ad11, ad11l, ad12, ad12l, ad21, &
           ad21l, ad22, ad22l, ad32l, an, anorm, ascale, atol, b11, b1a, b1i, b1r, b22, b2a, b2i, &
           b2r, bn, bnorm, bscale, btol, c, c11i, c11r, c12, c21, c22i, c22r, cl, cq, cr, cz, &
           eshift, s, s1, s1inv, s2, safmax, safmin, scale, sl, sqi, sqr, sr, szi, szr, t1, tau, &
           temp, temp2, tempi, tempr, u1, u12, u12l, u2, ulp, vs, w11, w12, w21, w22, wabs, wi, &
                     wr, wr2
           ! Local Arrays 
           real(dp) :: v(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode job, compq, compz
           if( stdlib_lsame( job, 'E' ) ) then
              ilschr = .false.
              ischur = 1
           else if( stdlib_lsame( job, 'S' ) ) then
              ilschr = .true.
              ischur = 2
           else
              ischur = 0
           end if
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! check argument values
           info = 0
           work( 1 ) = max( 1, n )
           lquery = ( lwork==-1 )
           if( ischur==0 ) then
              info = -1
           else if( icompq==0 ) then
              info = -2
           else if( icompz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( ldh<n ) then
              info = -8
           else if( ldt<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -15
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -17
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DHGEQZ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              work( 1 ) = real( 1,KIND=dp)
              return
           end if
           ! initialize q and z
           if( icompq==3 )call stdlib_dlaset( 'FULL', n, n, zero, one, q, ldq )
           if( icompz==3 )call stdlib_dlaset( 'FULL', n, n, zero, one, z, ldz )
           ! machine constants
           in = ihi + 1 - ilo
           safmin = stdlib_dlamch( 'S' )
           safmax = one / safmin
           ulp = stdlib_dlamch( 'E' )*stdlib_dlamch( 'B' )
           anorm = stdlib_dlanhs( 'F', in, h( ilo, ilo ), ldh, work )
           bnorm = stdlib_dlanhs( 'F', in, t( ilo, ilo ), ldt, work )
           atol = max( safmin, ulp*anorm )
           btol = max( safmin, ulp*bnorm )
           ascale = one / max( safmin, anorm )
           bscale = one / max( safmin, bnorm )
           ! set eigenvalues ihi+1:n
           do j = ihi + 1, n
              if( t( j, j )<zero ) then
                 if( ilschr ) then
                    do jr = 1, j
                       h( jr, j ) = -h( jr, j )
                       t( jr, j ) = -t( jr, j )
                    end do
                 else
                    h( j, j ) = -h( j, j )
                    t( j, j ) = -t( j, j )
                 end if
                 if( ilz ) then
                    do jr = 1, n
                       z( jr, j ) = -z( jr, j )
                    end do
                 end if
              end if
              alphar( j ) = h( j, j )
              alphai( j ) = zero
              beta( j ) = t( j, j )
           end do
           ! if ihi < ilo, skip qz steps
           if( ihi<ilo )go to 380
           ! main qz iteration loop
           ! initialize dynamic indices
           ! eigenvalues ilast+1:n have been found.
              ! column operations modify rows ifrstm:whatever.
              ! row operations modify columns whatever:ilastm.
           ! if only eigenvalues are being computed, then
              ! ifrstm is the row of the last splitting row above row ilast;
              ! this is always at least ilo.
           ! iiter counts iterations since the last eigenvalue was found,
              ! to tell when to use an extraordinary shift.
           ! maxit is the maximum number of qz sweeps allowed.
           ilast = ihi
           if( ilschr ) then
              ifrstm = 1
              ilastm = n
           else
              ifrstm = ilo
              ilastm = ihi
           end if
           iiter = 0
           eshift = zero
           maxit = 30*( ihi-ilo+1 )
           loop_360: do jiter = 1, maxit
              ! split the matrix if possible.
              ! two tests:
                 ! 1: h(j,j-1)=0  or  j=ilo
                 ! 2: t(j,j)=0
              if( ilast==ilo ) then
                 ! special case: j=ilast
                 go to 80
              else
                 if( abs( h( ilast, ilast-1 ) )<=max( safmin, ulp*(abs( h( ilast, ilast ) ) + abs(&
                            h( ilast-1, ilast-1 ) )) ) ) then
                    h( ilast, ilast-1 ) = zero
                    go to 80
                 end if
              end if
              if( abs( t( ilast, ilast ) )<=max( safmin, ulp*(abs( t( ilast - 1, ilast ) ) + abs( &
                        t( ilast-1, ilast-1 )) ) ) ) then
                 t( ilast, ilast ) = zero
                 go to 70
              end if
              ! general case: j<ilast
              loop_60: do j = ilast - 1, ilo, -1
                 ! test 1: for h(j,j-1)=0 or j=ilo
                 if( j==ilo ) then
                    ilazro = .true.
                 else
                    if( abs( h( j, j-1 ) )<=max( safmin, ulp*(abs( h( j, j ) ) + abs( h( j-1, j-1 &
                              ) )) ) ) then
                       h( j, j-1 ) = zero
                       ilazro = .true.
                    else
                       ilazro = .false.
                    end if
                 end if
                 ! test 2: for t(j,j)=0
                 temp = abs ( t( j, j + 1 ) )
                 if ( j > ilo )temp = temp + abs ( t( j - 1, j ) )
                 if( abs( t( j, j ) )<max( safmin,ulp*temp ) ) then
                    t( j, j ) = zero
                    ! test 1a: check for 2 consecutive small subdiagonals in a
                    ilazr2 = .false.
                    if( .not.ilazro ) then
                       temp = abs( h( j, j-1 ) )
                       temp2 = abs( h( j, j ) )
                       tempr = max( temp, temp2 )
                       if( tempr<one .and. tempr/=zero ) then
                          temp = temp / tempr
                          temp2 = temp2 / tempr
                       end if
                       if( temp*( ascale*abs( h( j+1, j ) ) )<=temp2*( ascale*atol ) )ilazr2 = &
                                 .true.
                    end if
                    ! if both tests pass (1
                    ! element of b in the block is zero, split a 1x1 block off
                    ! at the top. (i.e., at the j-th row/column) the leading
                    ! diagonal element of the remainder can also be zero, so
                    ! this may have to be done repeatedly.
                    if( ilazro .or. ilazr2 ) then
                       do jch = j, ilast - 1
                          temp = h( jch, jch )
                          call stdlib_dlartg( temp, h( jch+1, jch ), c, s,h( jch, jch ) )
                          h( jch+1, jch ) = zero
                          call stdlib_drot( ilastm-jch, h( jch, jch+1 ), ldh,h( jch+1, jch+1 ), &
                                    ldh, c, s )
                          call stdlib_drot( ilastm-jch, t( jch, jch+1 ), ldt,t( jch+1, jch+1 ), &
                                    ldt, c, s )
                          if( ilq )call stdlib_drot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, s )
                                    
                          if( ilazr2 )h( jch, jch-1 ) = h( jch, jch-1 )*c
                          ilazr2 = .false.
                          if( abs( t( jch+1, jch+1 ) )>=btol ) then
                             if( jch+1>=ilast ) then
                                go to 80
                             else
                                ifirst = jch + 1
                                go to 110
                             end if
                          end if
                          t( jch+1, jch+1 ) = zero
                       end do
                       go to 70
                    else
                       ! only test 2 passed -- chase the zero to t(ilast,ilast)
                       ! then process as in the case t(ilast,ilast)=0
                       do jch = j, ilast - 1
                          temp = t( jch, jch+1 )
                          call stdlib_dlartg( temp, t( jch+1, jch+1 ), c, s,t( jch, jch+1 ) )
                                    
                          t( jch+1, jch+1 ) = zero
                          if( jch<ilastm-1 )call stdlib_drot( ilastm-jch-1, t( jch, jch+2 ), ldt,&
                                    t( jch+1, jch+2 ), ldt, c, s )
                          call stdlib_drot( ilastm-jch+2, h( jch, jch-1 ), ldh,h( jch+1, jch-1 ), &
                                    ldh, c, s )
                          if( ilq )call stdlib_drot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, s )
                                    
                          temp = h( jch+1, jch )
                          call stdlib_dlartg( temp, h( jch+1, jch-1 ), c, s,h( jch+1, jch ) )
                                    
                          h( jch+1, jch-1 ) = zero
                          call stdlib_drot( jch+1-ifrstm, h( ifrstm, jch ), 1,h( ifrstm, jch-1 ), &
                                    1, c, s )
                          call stdlib_drot( jch-ifrstm, t( ifrstm, jch ), 1,t( ifrstm, jch-1 ), 1,&
                                     c, s )
                          if( ilz )call stdlib_drot( n, z( 1, jch ), 1, z( 1, jch-1 ), 1,c, s )
                                    
                       end do
                       go to 70
                    end if
                 else if( ilazro ) then
                    ! only test 1 passed -- work on j:ilast
                    ifirst = j
                    go to 110
                 end if
                 ! neither test passed -- try next j
              end do loop_60
              ! (drop-through is "impossible")
              info = n + 1
              go to 420
              ! t(ilast,ilast)=0 -- clear h(ilast,ilast-1) to split off a
              ! 1x1 block.
              70 continue
              temp = h( ilast, ilast )
              call stdlib_dlartg( temp, h( ilast, ilast-1 ), c, s,h( ilast, ilast ) )
              h( ilast, ilast-1 ) = zero
              call stdlib_drot( ilast-ifrstm, h( ifrstm, ilast ), 1,h( ifrstm, ilast-1 ), 1, c, s &
                        )
              call stdlib_drot( ilast-ifrstm, t( ifrstm, ilast ), 1,t( ifrstm, ilast-1 ), 1, c, s &
                        )
              if( ilz )call stdlib_drot( n, z( 1, ilast ), 1, z( 1, ilast-1 ), 1, c, s )
              ! h(ilast,ilast-1)=0 -- standardize b, set alphar, alphai,
                                    ! and beta
                                    80 continue
              if( t( ilast, ilast )<zero ) then
                 if( ilschr ) then
                    do j = ifrstm, ilast
                       h( j, ilast ) = -h( j, ilast )
                       t( j, ilast ) = -t( j, ilast )
                    end do
                 else
                    h( ilast, ilast ) = -h( ilast, ilast )
                    t( ilast, ilast ) = -t( ilast, ilast )
                 end if
                 if( ilz ) then
                    do j = 1, n
                       z( j, ilast ) = -z( j, ilast )
                    end do
                 end if
              end if
              alphar( ilast ) = h( ilast, ilast )
              alphai( ilast ) = zero
              beta( ilast ) = t( ilast, ilast )
              ! go to next block -- exit if finished.
              ilast = ilast - 1
              if( ilast<ilo )go to 380
              ! reset counters
              iiter = 0
              eshift = zero
              if( .not.ilschr ) then
                 ilastm = ilast
                 if( ifrstm>ilast )ifrstm = ilo
              end if
              go to 350
              ! qz step
              ! this iteration only involves rows/columns ifirst:ilast. we
              ! assume ifirst < ilast, and that the diagonal of b is non-zero.
              110 continue
              iiter = iiter + 1
              if( .not.ilschr ) then
                 ifrstm = ifirst
              end if
              ! compute single shifts.
              ! at this point, ifirst < ilast, and the diagonal elements of
              ! t(ifirst:ilast,ifirst,ilast) are larger than btol (in
              ! magnitude)
              if( ( iiter / 10 )*10==iiter ) then
                 ! exceptional shift.  chosen for no particularly good reason.
                 ! (single shift only.)
                 if( ( real( maxit,KIND=dp)*safmin )*abs( h( ilast, ilast-1 ) )<abs( t( ilast-1, &
                           ilast-1 ) ) ) then
                    eshift = h( ilast, ilast-1 ) /t( ilast-1, ilast-1 )
                 else
                    eshift = eshift + one / ( safmin*real( maxit,KIND=dp) )
                 end if
                 s1 = one
                 wr = eshift
              else
                 ! shifts based on the generalized eigenvalues of the
                 ! bottom-right 2x2 block of a and b. the first eigenvalue
                 ! returned by stdlib_dlag2 is the wilkinson shift (aep p.512_dp),
                 call stdlib_dlag2( h( ilast-1, ilast-1 ), ldh,t( ilast-1, ilast-1 ), ldt, &
                           safmin*safety, s1,s2, wr, wr2, wi )
                 if ( abs( (wr/s1)*t( ilast, ilast ) - h( ilast, ilast ) )> abs( (wr2/s2)*t( &
                           ilast, ilast )- h( ilast, ilast ) ) ) then
                    temp = wr
                    wr = wr2
                    wr2 = temp
                    temp = s1
                    s1 = s2
                    s2 = temp
                 end if
                 temp = max( s1, safmin*max( one, abs( wr ), abs( wi ) ) )
                 if( wi/=zero )go to 200
              end if
              ! fiddle with shift to avoid overflow
              temp = min( ascale, one )*( half*safmax )
              if( s1>temp ) then
                 scale = temp / s1
              else
                 scale = one
              end if
              temp = min( bscale, one )*( half*safmax )
              if( abs( wr )>temp )scale = min( scale, temp / abs( wr ) )
              s1 = scale*s1
              wr = scale*wr
              ! now check for two consecutive small subdiagonals.
              do j = ilast - 1, ifirst + 1, -1
                 istart = j
                 temp = abs( s1*h( j, j-1 ) )
                 temp2 = abs( s1*h( j, j )-wr*t( j, j ) )
                 tempr = max( temp, temp2 )
                 if( tempr<one .and. tempr/=zero ) then
                    temp = temp / tempr
                    temp2 = temp2 / tempr
                 end if
                 if( abs( ( ascale*h( j+1, j ) )*temp )<=( ascale*atol )*temp2 )go to 130
              end do
              istart = ifirst
              130 continue
              ! do an implicit single-shift qz sweep.
              ! initial q
              temp = s1*h( istart, istart ) - wr*t( istart, istart )
              temp2 = s1*h( istart+1, istart )
              call stdlib_dlartg( temp, temp2, c, s, tempr )
              ! sweep
              loop_190: do j = istart, ilast - 1
                 if( j>istart ) then
                    temp = h( j, j-1 )
                    call stdlib_dlartg( temp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                    h( j+1, j-1 ) = zero
                 end if
                 do jc = j, ilastm
                    temp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -s*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = temp
                    temp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -s*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = temp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       temp = c*q( jr, j ) + s*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = temp
                    end do
                 end if
                 temp = t( j+1, j+1 )
                 call stdlib_dlartg( temp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = zero
                 do jr = ifrstm, min( j+2, ilast )
                    temp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -s*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = temp
                 end do
                 do jr = ifrstm, j
                    temp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -s*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = temp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       temp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -s*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = temp
                    end do
                 end if
              end do loop_190
              go to 350
              ! use francis double-shift
              ! note: the francis double-shift should work with real shifts,
                    ! but only if the block is at least 3x3.
                    ! this code may break if this point is reached with
                    ! a 2x2 block with real eigenvalues.
                    200 continue
              if( ifirst+1==ilast ) then
                 ! special case -- 2x2 block with complex eigenvectors
                 ! step 1: standardize, that is, rotate so that
                             ! ( b11  0  )
                         ! b = (         )  with b11 non-negative.
                             ! (  0  b22 )
                 call stdlib_dlasv2( t( ilast-1, ilast-1 ), t( ilast-1, ilast ),t( ilast, ilast ),&
                            b22, b11, sr, cr, sl, cl )
                 if( b11<zero ) then
                    cr = -cr
                    sr = -sr
                    b11 = -b11
                    b22 = -b22
                 end if
                 call stdlib_drot( ilastm+1-ifirst, h( ilast-1, ilast-1 ), ldh,h( ilast, ilast-1 )&
                           , ldh, cl, sl )
                 call stdlib_drot( ilast+1-ifrstm, h( ifrstm, ilast-1 ), 1,h( ifrstm, ilast ), 1, &
                           cr, sr )
                 if( ilast<ilastm )call stdlib_drot( ilastm-ilast, t( ilast-1, ilast+1 ), ldt,t( &
                           ilast, ilast+1 ), ldt, cl, sl )
                 if( ifrstm<ilast-1 )call stdlib_drot( ifirst-ifrstm, t( ifrstm, ilast-1 ), 1,t( &
                           ifrstm, ilast ), 1, cr, sr )
                 if( ilq )call stdlib_drot( n, q( 1, ilast-1 ), 1, q( 1, ilast ), 1, cl,sl )
                           
                 if( ilz )call stdlib_drot( n, z( 1, ilast-1 ), 1, z( 1, ilast ), 1, cr,sr )
                           
                 t( ilast-1, ilast-1 ) = b11
                 t( ilast-1, ilast ) = zero
                 t( ilast, ilast-1 ) = zero
                 t( ilast, ilast ) = b22
                 ! if b22 is negative, negate column ilast
                 if( b22<zero ) then
                    do j = ifrstm, ilast
                       h( j, ilast ) = -h( j, ilast )
                       t( j, ilast ) = -t( j, ilast )
                    end do
                    if( ilz ) then
                       do j = 1, n
                          z( j, ilast ) = -z( j, ilast )
                       end do
                    end if
                    b22 = -b22
                 end if
                 ! step 2: compute alphar, alphai, and beta (see refs.)
                 ! recompute shift
                 call stdlib_dlag2( h( ilast-1, ilast-1 ), ldh,t( ilast-1, ilast-1 ), ldt, &
                           safmin*safety, s1,temp, wr, temp2, wi )
                 ! if standardization has perturbed the shift onto real line,
                 ! do another (real single-shift) qr step.
                 if( wi==zero )go to 350
                 s1inv = one / s1
                 ! do eispack (qzval) computation of alpha and beta
                 a11 = h( ilast-1, ilast-1 )
                 a21 = h( ilast, ilast-1 )
                 a12 = h( ilast-1, ilast )
                 a22 = h( ilast, ilast )
                 ! compute complex givens rotation on right
                 ! (assume some element of c = (sa - wb) > unfl )
                                  ! __
                 ! (sa - wb) ( cz   -sz )
                           ! ( sz    cz )
                 c11r = s1*a11 - wr*b11
                 c11i = -wi*b11
                 c12 = s1*a12
                 c21 = s1*a21
                 c22r = s1*a22 - wr*b22
                 c22i = -wi*b22
                 if( abs( c11r )+abs( c11i )+abs( c12 )>abs( c21 )+abs( c22r )+abs( c22i ) ) &
                           then
                    t1 = stdlib_dlapy3( c12, c11r, c11i )
                    cz = c12 / t1
                    szr = -c11r / t1
                    szi = -c11i / t1
                 else
                    cz = stdlib_dlapy2( c22r, c22i )
                    if( cz<=safmin ) then
                       cz = zero
                       szr = one
                       szi = zero
                    else
                       tempr = c22r / cz
                       tempi = c22i / cz
                       t1 = stdlib_dlapy2( cz, c21 )
                       cz = cz / t1
                       szr = -c21*tempr / t1
                       szi = c21*tempi / t1
                    end if
                 end if
                 ! compute givens rotation on left
                 ! (  cq   sq )
                 ! (  __      )  a or b
                 ! ( -sq   cq )
                 an = abs( a11 ) + abs( a12 ) + abs( a21 ) + abs( a22 )
                 bn = abs( b11 ) + abs( b22 )
                 wabs = abs( wr ) + abs( wi )
                 if( s1*an>wabs*bn ) then
                    cq = cz*b11
                    sqr = szr*b22
                    sqi = -szi*b22
                 else
                    a1r = cz*a11 + szr*a12
                    a1i = szi*a12
                    a2r = cz*a21 + szr*a22
                    a2i = szi*a22
                    cq = stdlib_dlapy2( a1r, a1i )
                    if( cq<=safmin ) then
                       cq = zero
                       sqr = one
                       sqi = zero
                    else
                       tempr = a1r / cq
                       tempi = a1i / cq
                       sqr = tempr*a2r + tempi*a2i
                       sqi = tempi*a2r - tempr*a2i
                    end if
                 end if
                 t1 = stdlib_dlapy3( cq, sqr, sqi )
                 cq = cq / t1
                 sqr = sqr / t1
                 sqi = sqi / t1
                 ! compute diagonal elements of qbz
                 tempr = sqr*szr - sqi*szi
                 tempi = sqr*szi + sqi*szr
                 b1r = cq*cz*b11 + tempr*b22
                 b1i = tempi*b22
                 b1a = stdlib_dlapy2( b1r, b1i )
                 b2r = cq*cz*b22 + tempr*b11
                 b2i = -tempi*b11
                 b2a = stdlib_dlapy2( b2r, b2i )
                 ! normalize so beta > 0, and im( alpha1 ) > 0
                 beta( ilast-1 ) = b1a
                 beta( ilast ) = b2a
                 alphar( ilast-1 ) = ( wr*b1a )*s1inv
                 alphai( ilast-1 ) = ( wi*b1a )*s1inv
                 alphar( ilast ) = ( wr*b2a )*s1inv
                 alphai( ilast ) = -( wi*b2a )*s1inv
                 ! step 3: go to next block -- exit if finished.
                 ilast = ifirst - 1
                 if( ilast<ilo )go to 380
                 ! reset counters
                 iiter = 0
                 eshift = zero
                 if( .not.ilschr ) then
                    ilastm = ilast
                    if( ifrstm>ilast )ifrstm = ilo
                 end if
                 go to 350
              else
                 ! usual case: 3x3 or larger block, using francis implicit
                             ! double-shift
                                          ! 2
                 ! eigenvalue equation is  w  - c w + d = 0,
                                               ! -1 2        -1
                 ! so compute 1st column of  (a b  )  - c a b   + d
                 ! using the formula in qzit (from eispack)
                 ! we assume that the block is at least 3x3
                 ad11 = ( ascale*h( ilast-1, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad21 = ( ascale*h( ilast, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad12 = ( ascale*h( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad22 = ( ascale*h( ilast, ilast ) ) /( bscale*t( ilast, ilast ) )
                 u12 = t( ilast-1, ilast ) / t( ilast, ilast )
                 ad11l = ( ascale*h( ifirst, ifirst ) ) /( bscale*t( ifirst, ifirst ) )
                 ad21l = ( ascale*h( ifirst+1, ifirst ) ) /( bscale*t( ifirst, ifirst ) )
                 ad12l = ( ascale*h( ifirst, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 ad22l = ( ascale*h( ifirst+1, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 ad32l = ( ascale*h( ifirst+2, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 u12l = t( ifirst, ifirst+1 ) / t( ifirst+1, ifirst+1 )
                 v( 1 ) = ( ad11-ad11l )*( ad22-ad11l ) - ad12*ad21 +ad21*u12*ad11l + ( ad12l-&
                           ad11l*u12l )*ad21l
                 v( 2 ) = ( ( ad22l-ad11l )-ad21l*u12l-( ad11-ad11l )-( ad22-ad11l )+ad21*u12 )&
                           *ad21l
                 v( 3 ) = ad32l*ad21l
                 istart = ifirst
                 call stdlib_dlarfg( 3, v( 1 ), v( 2 ), 1, tau )
                 v( 1 ) = one
                 ! sweep
                 loop_290: do j = istart, ilast - 2
                    ! all but last elements: use 3x3 householder transforms.
                    ! zero (j-1)st column of a
                    if( j>istart ) then
                       v( 1 ) = h( j, j-1 )
                       v( 2 ) = h( j+1, j-1 )
                       v( 3 ) = h( j+2, j-1 )
                       call stdlib_dlarfg( 3, h( j, j-1 ), v( 2 ), 1, tau )
                       v( 1 ) = one
                       h( j+1, j-1 ) = zero
                       h( j+2, j-1 ) = zero
                    end if
                    do jc = j, ilastm
                       temp = tau*( h( j, jc )+v( 2 )*h( j+1, jc )+v( 3 )*h( j+2, jc ) )
                       h( j, jc ) = h( j, jc ) - temp
                       h( j+1, jc ) = h( j+1, jc ) - temp*v( 2 )
                       h( j+2, jc ) = h( j+2, jc ) - temp*v( 3 )
                       temp2 = tau*( t( j, jc )+v( 2 )*t( j+1, jc )+v( 3 )*t( j+2, jc ) )
                       t( j, jc ) = t( j, jc ) - temp2
                       t( j+1, jc ) = t( j+1, jc ) - temp2*v( 2 )
                       t( j+2, jc ) = t( j+2, jc ) - temp2*v( 3 )
                    end do
                    if( ilq ) then
                       do jr = 1, n
                          temp = tau*( q( jr, j )+v( 2 )*q( jr, j+1 )+v( 3 )*q( jr, j+2 ) )
                                    
                          q( jr, j ) = q( jr, j ) - temp
                          q( jr, j+1 ) = q( jr, j+1 ) - temp*v( 2 )
                          q( jr, j+2 ) = q( jr, j+2 ) - temp*v( 3 )
                       end do
                    end if
                    ! zero j-th column of b (see dlagbc for details)
                    ! swap rows to pivot
                    ilpivt = .false.
                    temp = max( abs( t( j+1, j+1 ) ), abs( t( j+1, j+2 ) ) )
                    temp2 = max( abs( t( j+2, j+1 ) ), abs( t( j+2, j+2 ) ) )
                    if( max( temp, temp2 )<safmin ) then
                       scale = zero
                       u1 = one
                       u2 = zero
                       go to 250
                    else if( temp>=temp2 ) then
                       w11 = t( j+1, j+1 )
                       w21 = t( j+2, j+1 )
                       w12 = t( j+1, j+2 )
                       w22 = t( j+2, j+2 )
                       u1 = t( j+1, j )
                       u2 = t( j+2, j )
                    else
                       w21 = t( j+1, j+1 )
                       w11 = t( j+2, j+1 )
                       w22 = t( j+1, j+2 )
                       w12 = t( j+2, j+2 )
                       u2 = t( j+1, j )
                       u1 = t( j+2, j )
                    end if
                    ! swap columns if nec.
                    if( abs( w12 )>abs( w11 ) ) then
                       ilpivt = .true.
                       temp = w12
                       temp2 = w22
                       w12 = w11
                       w22 = w21
                       w11 = temp
                       w21 = temp2
                    end if
                    ! lu-factor
                    temp = w21 / w11
                    u2 = u2 - temp*u1
                    w22 = w22 - temp*w12
                    w21 = zero
                    ! compute scale
                    scale = one
                    if( abs( w22 )<safmin ) then
                       scale = zero
                       u2 = one
                       u1 = -w12 / w11
                       go to 250
                    end if
                    if( abs( w22 )<abs( u2 ) )scale = abs( w22 / u2 )
                    if( abs( w11 )<abs( u1 ) )scale = min( scale, abs( w11 / u1 ) )
                    ! solve
                    u2 = ( scale*u2 ) / w22
                    u1 = ( scale*u1-w12*u2 ) / w11
                    250 continue
                    if( ilpivt ) then
                       temp = u2
                       u2 = u1
                       u1 = temp
                    end if
                    ! compute householder vector
                    t1 = sqrt( scale**2+u1**2+u2**2 )
                    tau = one + scale / t1
                    vs = -one / ( scale+t1 )
                    v( 1 ) = one
                    v( 2 ) = vs*u1
                    v( 3 ) = vs*u2
                    ! apply transformations from the right.
                    do jr = ifrstm, min( j+3, ilast )
                       temp = tau*( h( jr, j )+v( 2 )*h( jr, j+1 )+v( 3 )*h( jr, j+2 ) )
                       h( jr, j ) = h( jr, j ) - temp
                       h( jr, j+1 ) = h( jr, j+1 ) - temp*v( 2 )
                       h( jr, j+2 ) = h( jr, j+2 ) - temp*v( 3 )
                    end do
                    do jr = ifrstm, j + 2
                       temp = tau*( t( jr, j )+v( 2 )*t( jr, j+1 )+v( 3 )*t( jr, j+2 ) )
                       t( jr, j ) = t( jr, j ) - temp
                       t( jr, j+1 ) = t( jr, j+1 ) - temp*v( 2 )
                       t( jr, j+2 ) = t( jr, j+2 ) - temp*v( 3 )
                    end do
                    if( ilz ) then
                       do jr = 1, n
                          temp = tau*( z( jr, j )+v( 2 )*z( jr, j+1 )+v( 3 )*z( jr, j+2 ) )
                                    
                          z( jr, j ) = z( jr, j ) - temp
                          z( jr, j+1 ) = z( jr, j+1 ) - temp*v( 2 )
                          z( jr, j+2 ) = z( jr, j+2 ) - temp*v( 3 )
                       end do
                    end if
                    t( j+1, j ) = zero
                    t( j+2, j ) = zero
                 end do loop_290
                 ! last elements: use givens rotations
                 ! rotations from the left
                 j = ilast - 1
                 temp = h( j, j-1 )
                 call stdlib_dlartg( temp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                 h( j+1, j-1 ) = zero
                 do jc = j, ilastm
                    temp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -s*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = temp
                    temp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -s*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = temp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       temp = c*q( jr, j ) + s*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = temp
                    end do
                 end if
                 ! rotations from the right.
                 temp = t( j+1, j+1 )
                 call stdlib_dlartg( temp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = zero
                 do jr = ifrstm, ilast
                    temp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -s*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = temp
                 end do
                 do jr = ifrstm, ilast - 1
                    temp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -s*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = temp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       temp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -s*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = temp
                    end do
                 end if
                 ! end of double-shift code
              end if
              go to 350
              ! end of iteration loop
              350 continue
           end do loop_360
           ! drop-through = non-convergence
           info = ilast
           go to 420
           ! successful completion of all qz steps
           380 continue
           ! set eigenvalues 1:ilo-1
           do j = 1, ilo - 1
              if( t( j, j )<zero ) then
                 if( ilschr ) then
                    do jr = 1, j
                       h( jr, j ) = -h( jr, j )
                       t( jr, j ) = -t( jr, j )
                    end do
                 else
                    h( j, j ) = -h( j, j )
                    t( j, j ) = -t( j, j )
                 end if
                 if( ilz ) then
                    do jr = 1, n
                       z( jr, j ) = -z( jr, j )
                    end do
                 end if
              end if
              alphar( j ) = h( j, j )
              alphai( j ) = zero
              beta( j ) = t( j, j )
           end do
           ! normal termination
           info = 0
           ! exit (other than argument error) -- return optimal workspace size
           420 continue
           work( 1 ) = real( n,KIND=dp)
           return
     end subroutine stdlib_dhgeqz

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module subroutine stdlib_${ri}$hgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alphar, alphai, &
     !! DHGEQZ: computes the eigenvalues of a real matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the double-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a real matrix pair (A,B):
     !! A = Q1*H*Z1**T,  B = Q1*T*Z1**T,
     !! as computed by DGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**T,  T = Q*P*Z**T,
     !! where Q and Z are orthogonal matrices, P is an upper triangular
     !! matrix, and S is a quasi-triangular matrix with 1-by-1 and 2-by-2
     !! diagonal blocks.
     !! The 1-by-1 blocks correspond to real eigenvalues of the matrix pair
     !! (H,T) and the 2-by-2 blocks correspond to complex conjugate pairs of
     !! eigenvalues.
     !! Additionally, the 2-by-2 upper triangular diagonal blocks of P
     !! corresponding to 2-by-2 blocks of S are reduced to positive diagonal
     !! form, i.e., if S(j+1,j) is non-zero, then P(j+1,j) = P(j,j+1) = 0,
     !! P(j,j) > 0, and P(j+1,j+1) > 0.
     !! Optionally, the orthogonal matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! orthogonal matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the orthogonal matrices from DGGHRD that reduced
     !! the matrix pair (A,B) to generalized upper Hessenberg form, then the
     !! output matrices Q1*Q and Z1*Z are the orthogonal factors from the
     !! generalized Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**T,  B = (Q1*Q)*P*(Z1*Z)**T.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T) (equivalently,
     !! of (A,B)) are computed as a pair of values (alpha,beta), where alpha is
     !! complex and beta real.
     !! If beta is nonzero, lambda = alpha / beta is an eigenvalue of the
     !! generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! Real eigenvalues can be read directly from the generalized Schur
     !! form:
     !! alpha = S(i,i), beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
               beta, q, ldq, z, ldz, work,lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz, job
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), work(*)
           real(${rk}$), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: safety = 1.0e+2_${rk}$
          ! $                     safety = one )
           
           ! Local Scalars 
           logical(lk) :: ilazr2, ilazro, ilpivt, ilq, ilschr, ilz, lquery
           integer(ilp) :: icompq, icompz, ifirst, ifrstm, iiter, ilast, ilastm, in, ischur, &
                     istart, j, jc, jch, jiter, jr, maxit
           real(${rk}$) :: a11, a12, a1i, a1r, a21, a22, a2i, a2r, ad11, ad11l, ad12, ad12l, ad21, &
           ad21l, ad22, ad22l, ad32l, an, anorm, ascale, atol, b11, b1a, b1i, b1r, b22, b2a, b2i, &
           b2r, bn, bnorm, bscale, btol, c, c11i, c11r, c12, c21, c22i, c22r, cl, cq, cr, cz, &
           eshift, s, s1, s1inv, s2, safmax, safmin, scale, sl, sqi, sqr, sr, szi, szr, t1, tau, &
           temp, temp2, tempi, tempr, u1, u12, u12l, u2, ulp, vs, w11, w12, w21, w22, wabs, wi, &
                     wr, wr2
           ! Local Arrays 
           real(${rk}$) :: v(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode job, compq, compz
           if( stdlib_lsame( job, 'E' ) ) then
              ilschr = .false.
              ischur = 1
           else if( stdlib_lsame( job, 'S' ) ) then
              ilschr = .true.
              ischur = 2
           else
              ischur = 0
           end if
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! check argument values
           info = 0
           work( 1 ) = max( 1, n )
           lquery = ( lwork==-1 )
           if( ischur==0 ) then
              info = -1
           else if( icompq==0 ) then
              info = -2
           else if( icompz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( ldh<n ) then
              info = -8
           else if( ldt<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -15
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -17
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -19
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DHGEQZ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n<=0 ) then
              work( 1 ) = real( 1,KIND=${rk}$)
              return
           end if
           ! initialize q and z
           if( icompq==3 )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, q, ldq )
           if( icompz==3 )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, z, ldz )
           ! machine constants
           in = ihi + 1 - ilo
           safmin = stdlib_${ri}$lamch( 'S' )
           safmax = one / safmin
           ulp = stdlib_${ri}$lamch( 'E' )*stdlib_${ri}$lamch( 'B' )
           anorm = stdlib_${ri}$lanhs( 'F', in, h( ilo, ilo ), ldh, work )
           bnorm = stdlib_${ri}$lanhs( 'F', in, t( ilo, ilo ), ldt, work )
           atol = max( safmin, ulp*anorm )
           btol = max( safmin, ulp*bnorm )
           ascale = one / max( safmin, anorm )
           bscale = one / max( safmin, bnorm )
           ! set eigenvalues ihi+1:n
           do j = ihi + 1, n
              if( t( j, j )<zero ) then
                 if( ilschr ) then
                    do jr = 1, j
                       h( jr, j ) = -h( jr, j )
                       t( jr, j ) = -t( jr, j )
                    end do
                 else
                    h( j, j ) = -h( j, j )
                    t( j, j ) = -t( j, j )
                 end if
                 if( ilz ) then
                    do jr = 1, n
                       z( jr, j ) = -z( jr, j )
                    end do
                 end if
              end if
              alphar( j ) = h( j, j )
              alphai( j ) = zero
              beta( j ) = t( j, j )
           end do
           ! if ihi < ilo, skip qz steps
           if( ihi<ilo )go to 380
           ! main qz iteration loop
           ! initialize dynamic indices
           ! eigenvalues ilast+1:n have been found.
              ! column operations modify rows ifrstm:whatever.
              ! row operations modify columns whatever:ilastm.
           ! if only eigenvalues are being computed, then
              ! ifrstm is the row of the last splitting row above row ilast;
              ! this is always at least ilo.
           ! iiter counts iterations since the last eigenvalue was found,
              ! to tell when to use an extraordinary shift.
           ! maxit is the maximum number of qz sweeps allowed.
           ilast = ihi
           if( ilschr ) then
              ifrstm = 1
              ilastm = n
           else
              ifrstm = ilo
              ilastm = ihi
           end if
           iiter = 0
           eshift = zero
           maxit = 30*( ihi-ilo+1 )
           loop_360: do jiter = 1, maxit
              ! split the matrix if possible.
              ! two tests:
                 ! 1: h(j,j-1)=0  or  j=ilo
                 ! 2: t(j,j)=0
              if( ilast==ilo ) then
                 ! special case: j=ilast
                 go to 80
              else
                 if( abs( h( ilast, ilast-1 ) )<=max( safmin, ulp*(abs( h( ilast, ilast ) ) + abs(&
                            h( ilast-1, ilast-1 ) )) ) ) then
                    h( ilast, ilast-1 ) = zero
                    go to 80
                 end if
              end if
              if( abs( t( ilast, ilast ) )<=max( safmin, ulp*(abs( t( ilast - 1, ilast ) ) + abs( &
                        t( ilast-1, ilast-1 )) ) ) ) then
                 t( ilast, ilast ) = zero
                 go to 70
              end if
              ! general case: j<ilast
              loop_60: do j = ilast - 1, ilo, -1
                 ! test 1: for h(j,j-1)=0 or j=ilo
                 if( j==ilo ) then
                    ilazro = .true.
                 else
                    if( abs( h( j, j-1 ) )<=max( safmin, ulp*(abs( h( j, j ) ) + abs( h( j-1, j-1 &
                              ) )) ) ) then
                       h( j, j-1 ) = zero
                       ilazro = .true.
                    else
                       ilazro = .false.
                    end if
                 end if
                 ! test 2: for t(j,j)=0
                 temp = abs ( t( j, j + 1 ) )
                 if ( j > ilo )temp = temp + abs ( t( j - 1, j ) )
                 if( abs( t( j, j ) )<max( safmin,ulp*temp ) ) then
                    t( j, j ) = zero
                    ! test 1a: check for 2 consecutive small subdiagonals in a
                    ilazr2 = .false.
                    if( .not.ilazro ) then
                       temp = abs( h( j, j-1 ) )
                       temp2 = abs( h( j, j ) )
                       tempr = max( temp, temp2 )
                       if( tempr<one .and. tempr/=zero ) then
                          temp = temp / tempr
                          temp2 = temp2 / tempr
                       end if
                       if( temp*( ascale*abs( h( j+1, j ) ) )<=temp2*( ascale*atol ) )ilazr2 = &
                                 .true.
                    end if
                    ! if both tests pass (1
                    ! element of b in the block is zero, split a 1x1 block off
                    ! at the top. (i.e., at the j-th row/column) the leading
                    ! diagonal element of the remainder can also be zero, so
                    ! this may have to be done repeatedly.
                    if( ilazro .or. ilazr2 ) then
                       do jch = j, ilast - 1
                          temp = h( jch, jch )
                          call stdlib_${ri}$lartg( temp, h( jch+1, jch ), c, s,h( jch, jch ) )
                          h( jch+1, jch ) = zero
                          call stdlib_${ri}$rot( ilastm-jch, h( jch, jch+1 ), ldh,h( jch+1, jch+1 ), &
                                    ldh, c, s )
                          call stdlib_${ri}$rot( ilastm-jch, t( jch, jch+1 ), ldt,t( jch+1, jch+1 ), &
                                    ldt, c, s )
                          if( ilq )call stdlib_${ri}$rot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, s )
                                    
                          if( ilazr2 )h( jch, jch-1 ) = h( jch, jch-1 )*c
                          ilazr2 = .false.
                          if( abs( t( jch+1, jch+1 ) )>=btol ) then
                             if( jch+1>=ilast ) then
                                go to 80
                             else
                                ifirst = jch + 1
                                go to 110
                             end if
                          end if
                          t( jch+1, jch+1 ) = zero
                       end do
                       go to 70
                    else
                       ! only test 2 passed -- chase the zero to t(ilast,ilast)
                       ! then process as in the case t(ilast,ilast)=0
                       do jch = j, ilast - 1
                          temp = t( jch, jch+1 )
                          call stdlib_${ri}$lartg( temp, t( jch+1, jch+1 ), c, s,t( jch, jch+1 ) )
                                    
                          t( jch+1, jch+1 ) = zero
                          if( jch<ilastm-1 )call stdlib_${ri}$rot( ilastm-jch-1, t( jch, jch+2 ), ldt,&
                                    t( jch+1, jch+2 ), ldt, c, s )
                          call stdlib_${ri}$rot( ilastm-jch+2, h( jch, jch-1 ), ldh,h( jch+1, jch-1 ), &
                                    ldh, c, s )
                          if( ilq )call stdlib_${ri}$rot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, s )
                                    
                          temp = h( jch+1, jch )
                          call stdlib_${ri}$lartg( temp, h( jch+1, jch-1 ), c, s,h( jch+1, jch ) )
                                    
                          h( jch+1, jch-1 ) = zero
                          call stdlib_${ri}$rot( jch+1-ifrstm, h( ifrstm, jch ), 1,h( ifrstm, jch-1 ), &
                                    1, c, s )
                          call stdlib_${ri}$rot( jch-ifrstm, t( ifrstm, jch ), 1,t( ifrstm, jch-1 ), 1,&
                                     c, s )
                          if( ilz )call stdlib_${ri}$rot( n, z( 1, jch ), 1, z( 1, jch-1 ), 1,c, s )
                                    
                       end do
                       go to 70
                    end if
                 else if( ilazro ) then
                    ! only test 1 passed -- work on j:ilast
                    ifirst = j
                    go to 110
                 end if
                 ! neither test passed -- try next j
              end do loop_60
              ! (drop-through is "impossible")
              info = n + 1
              go to 420
              ! t(ilast,ilast)=0 -- clear h(ilast,ilast-1) to split off a
              ! 1x1 block.
              70 continue
              temp = h( ilast, ilast )
              call stdlib_${ri}$lartg( temp, h( ilast, ilast-1 ), c, s,h( ilast, ilast ) )
              h( ilast, ilast-1 ) = zero
              call stdlib_${ri}$rot( ilast-ifrstm, h( ifrstm, ilast ), 1,h( ifrstm, ilast-1 ), 1, c, s &
                        )
              call stdlib_${ri}$rot( ilast-ifrstm, t( ifrstm, ilast ), 1,t( ifrstm, ilast-1 ), 1, c, s &
                        )
              if( ilz )call stdlib_${ri}$rot( n, z( 1, ilast ), 1, z( 1, ilast-1 ), 1, c, s )
              ! h(ilast,ilast-1)=0 -- standardize b, set alphar, alphai,
                                    ! and beta
                                    80 continue
              if( t( ilast, ilast )<zero ) then
                 if( ilschr ) then
                    do j = ifrstm, ilast
                       h( j, ilast ) = -h( j, ilast )
                       t( j, ilast ) = -t( j, ilast )
                    end do
                 else
                    h( ilast, ilast ) = -h( ilast, ilast )
                    t( ilast, ilast ) = -t( ilast, ilast )
                 end if
                 if( ilz ) then
                    do j = 1, n
                       z( j, ilast ) = -z( j, ilast )
                    end do
                 end if
              end if
              alphar( ilast ) = h( ilast, ilast )
              alphai( ilast ) = zero
              beta( ilast ) = t( ilast, ilast )
              ! go to next block -- exit if finished.
              ilast = ilast - 1
              if( ilast<ilo )go to 380
              ! reset counters
              iiter = 0
              eshift = zero
              if( .not.ilschr ) then
                 ilastm = ilast
                 if( ifrstm>ilast )ifrstm = ilo
              end if
              go to 350
              ! qz step
              ! this iteration only involves rows/columns ifirst:ilast. we
              ! assume ifirst < ilast, and that the diagonal of b is non-zero.
              110 continue
              iiter = iiter + 1
              if( .not.ilschr ) then
                 ifrstm = ifirst
              end if
              ! compute single shifts.
              ! at this point, ifirst < ilast, and the diagonal elements of
              ! t(ifirst:ilast,ifirst,ilast) are larger than btol (in
              ! magnitude)
              if( ( iiter / 10 )*10==iiter ) then
                 ! exceptional shift.  chosen for no particularly good reason.
                 ! (single shift only.)
                 if( ( real( maxit,KIND=${rk}$)*safmin )*abs( h( ilast, ilast-1 ) )<abs( t( ilast-1, &
                           ilast-1 ) ) ) then
                    eshift = h( ilast, ilast-1 ) /t( ilast-1, ilast-1 )
                 else
                    eshift = eshift + one / ( safmin*real( maxit,KIND=${rk}$) )
                 end if
                 s1 = one
                 wr = eshift
              else
                 ! shifts based on the generalized eigenvalues of the
                 ! bottom-right 2x2 block of a and b. the first eigenvalue
                 ! returned by stdlib_${ri}$lag2 is the wilkinson shift (aep p.512_${rk}$),
                 call stdlib_${ri}$lag2( h( ilast-1, ilast-1 ), ldh,t( ilast-1, ilast-1 ), ldt, &
                           safmin*safety, s1,s2, wr, wr2, wi )
                 if ( abs( (wr/s1)*t( ilast, ilast ) - h( ilast, ilast ) )> abs( (wr2/s2)*t( &
                           ilast, ilast )- h( ilast, ilast ) ) ) then
                    temp = wr
                    wr = wr2
                    wr2 = temp
                    temp = s1
                    s1 = s2
                    s2 = temp
                 end if
                 temp = max( s1, safmin*max( one, abs( wr ), abs( wi ) ) )
                 if( wi/=zero )go to 200
              end if
              ! fiddle with shift to avoid overflow
              temp = min( ascale, one )*( half*safmax )
              if( s1>temp ) then
                 scale = temp / s1
              else
                 scale = one
              end if
              temp = min( bscale, one )*( half*safmax )
              if( abs( wr )>temp )scale = min( scale, temp / abs( wr ) )
              s1 = scale*s1
              wr = scale*wr
              ! now check for two consecutive small subdiagonals.
              do j = ilast - 1, ifirst + 1, -1
                 istart = j
                 temp = abs( s1*h( j, j-1 ) )
                 temp2 = abs( s1*h( j, j )-wr*t( j, j ) )
                 tempr = max( temp, temp2 )
                 if( tempr<one .and. tempr/=zero ) then
                    temp = temp / tempr
                    temp2 = temp2 / tempr
                 end if
                 if( abs( ( ascale*h( j+1, j ) )*temp )<=( ascale*atol )*temp2 )go to 130
              end do
              istart = ifirst
              130 continue
              ! do an implicit single-shift qz sweep.
              ! initial q
              temp = s1*h( istart, istart ) - wr*t( istart, istart )
              temp2 = s1*h( istart+1, istart )
              call stdlib_${ri}$lartg( temp, temp2, c, s, tempr )
              ! sweep
              loop_190: do j = istart, ilast - 1
                 if( j>istart ) then
                    temp = h( j, j-1 )
                    call stdlib_${ri}$lartg( temp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                    h( j+1, j-1 ) = zero
                 end if
                 do jc = j, ilastm
                    temp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -s*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = temp
                    temp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -s*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = temp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       temp = c*q( jr, j ) + s*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = temp
                    end do
                 end if
                 temp = t( j+1, j+1 )
                 call stdlib_${ri}$lartg( temp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = zero
                 do jr = ifrstm, min( j+2, ilast )
                    temp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -s*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = temp
                 end do
                 do jr = ifrstm, j
                    temp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -s*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = temp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       temp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -s*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = temp
                    end do
                 end if
              end do loop_190
              go to 350
              ! use francis double-shift
              ! note: the francis double-shift should work with real shifts,
                    ! but only if the block is at least 3x3.
                    ! this code may break if this point is reached with
                    ! a 2x2 block with real eigenvalues.
                    200 continue
              if( ifirst+1==ilast ) then
                 ! special case -- 2x2 block with complex eigenvectors
                 ! step 1: standardize, that is, rotate so that
                             ! ( b11  0  )
                         ! b = (         )  with b11 non-negative.
                             ! (  0  b22 )
                 call stdlib_${ri}$lasv2( t( ilast-1, ilast-1 ), t( ilast-1, ilast ),t( ilast, ilast ),&
                            b22, b11, sr, cr, sl, cl )
                 if( b11<zero ) then
                    cr = -cr
                    sr = -sr
                    b11 = -b11
                    b22 = -b22
                 end if
                 call stdlib_${ri}$rot( ilastm+1-ifirst, h( ilast-1, ilast-1 ), ldh,h( ilast, ilast-1 )&
                           , ldh, cl, sl )
                 call stdlib_${ri}$rot( ilast+1-ifrstm, h( ifrstm, ilast-1 ), 1,h( ifrstm, ilast ), 1, &
                           cr, sr )
                 if( ilast<ilastm )call stdlib_${ri}$rot( ilastm-ilast, t( ilast-1, ilast+1 ), ldt,t( &
                           ilast, ilast+1 ), ldt, cl, sl )
                 if( ifrstm<ilast-1 )call stdlib_${ri}$rot( ifirst-ifrstm, t( ifrstm, ilast-1 ), 1,t( &
                           ifrstm, ilast ), 1, cr, sr )
                 if( ilq )call stdlib_${ri}$rot( n, q( 1, ilast-1 ), 1, q( 1, ilast ), 1, cl,sl )
                           
                 if( ilz )call stdlib_${ri}$rot( n, z( 1, ilast-1 ), 1, z( 1, ilast ), 1, cr,sr )
                           
                 t( ilast-1, ilast-1 ) = b11
                 t( ilast-1, ilast ) = zero
                 t( ilast, ilast-1 ) = zero
                 t( ilast, ilast ) = b22
                 ! if b22 is negative, negate column ilast
                 if( b22<zero ) then
                    do j = ifrstm, ilast
                       h( j, ilast ) = -h( j, ilast )
                       t( j, ilast ) = -t( j, ilast )
                    end do
                    if( ilz ) then
                       do j = 1, n
                          z( j, ilast ) = -z( j, ilast )
                       end do
                    end if
                    b22 = -b22
                 end if
                 ! step 2: compute alphar, alphai, and beta (see refs.)
                 ! recompute shift
                 call stdlib_${ri}$lag2( h( ilast-1, ilast-1 ), ldh,t( ilast-1, ilast-1 ), ldt, &
                           safmin*safety, s1,temp, wr, temp2, wi )
                 ! if standardization has perturbed the shift onto real line,
                 ! do another (real single-shift) qr step.
                 if( wi==zero )go to 350
                 s1inv = one / s1
                 ! do eispack (qzval) computation of alpha and beta
                 a11 = h( ilast-1, ilast-1 )
                 a21 = h( ilast, ilast-1 )
                 a12 = h( ilast-1, ilast )
                 a22 = h( ilast, ilast )
                 ! compute complex givens rotation on right
                 ! (assume some element of c = (sa - wb) > unfl )
                                  ! __
                 ! (sa - wb) ( cz   -sz )
                           ! ( sz    cz )
                 c11r = s1*a11 - wr*b11
                 c11i = -wi*b11
                 c12 = s1*a12
                 c21 = s1*a21
                 c22r = s1*a22 - wr*b22
                 c22i = -wi*b22
                 if( abs( c11r )+abs( c11i )+abs( c12 )>abs( c21 )+abs( c22r )+abs( c22i ) ) &
                           then
                    t1 = stdlib_${ri}$lapy3( c12, c11r, c11i )
                    cz = c12 / t1
                    szr = -c11r / t1
                    szi = -c11i / t1
                 else
                    cz = stdlib_${ri}$lapy2( c22r, c22i )
                    if( cz<=safmin ) then
                       cz = zero
                       szr = one
                       szi = zero
                    else
                       tempr = c22r / cz
                       tempi = c22i / cz
                       t1 = stdlib_${ri}$lapy2( cz, c21 )
                       cz = cz / t1
                       szr = -c21*tempr / t1
                       szi = c21*tempi / t1
                    end if
                 end if
                 ! compute givens rotation on left
                 ! (  cq   sq )
                 ! (  __      )  a or b
                 ! ( -sq   cq )
                 an = abs( a11 ) + abs( a12 ) + abs( a21 ) + abs( a22 )
                 bn = abs( b11 ) + abs( b22 )
                 wabs = abs( wr ) + abs( wi )
                 if( s1*an>wabs*bn ) then
                    cq = cz*b11
                    sqr = szr*b22
                    sqi = -szi*b22
                 else
                    a1r = cz*a11 + szr*a12
                    a1i = szi*a12
                    a2r = cz*a21 + szr*a22
                    a2i = szi*a22
                    cq = stdlib_${ri}$lapy2( a1r, a1i )
                    if( cq<=safmin ) then
                       cq = zero
                       sqr = one
                       sqi = zero
                    else
                       tempr = a1r / cq
                       tempi = a1i / cq
                       sqr = tempr*a2r + tempi*a2i
                       sqi = tempi*a2r - tempr*a2i
                    end if
                 end if
                 t1 = stdlib_${ri}$lapy3( cq, sqr, sqi )
                 cq = cq / t1
                 sqr = sqr / t1
                 sqi = sqi / t1
                 ! compute diagonal elements of qbz
                 tempr = sqr*szr - sqi*szi
                 tempi = sqr*szi + sqi*szr
                 b1r = cq*cz*b11 + tempr*b22
                 b1i = tempi*b22
                 b1a = stdlib_${ri}$lapy2( b1r, b1i )
                 b2r = cq*cz*b22 + tempr*b11
                 b2i = -tempi*b11
                 b2a = stdlib_${ri}$lapy2( b2r, b2i )
                 ! normalize so beta > 0, and im( alpha1 ) > 0
                 beta( ilast-1 ) = b1a
                 beta( ilast ) = b2a
                 alphar( ilast-1 ) = ( wr*b1a )*s1inv
                 alphai( ilast-1 ) = ( wi*b1a )*s1inv
                 alphar( ilast ) = ( wr*b2a )*s1inv
                 alphai( ilast ) = -( wi*b2a )*s1inv
                 ! step 3: go to next block -- exit if finished.
                 ilast = ifirst - 1
                 if( ilast<ilo )go to 380
                 ! reset counters
                 iiter = 0
                 eshift = zero
                 if( .not.ilschr ) then
                    ilastm = ilast
                    if( ifrstm>ilast )ifrstm = ilo
                 end if
                 go to 350
              else
                 ! usual case: 3x3 or larger block, using francis implicit
                             ! double-shift
                                          ! 2
                 ! eigenvalue equation is  w  - c w + d = 0,
                                               ! -1 2        -1
                 ! so compute 1st column of  (a b  )  - c a b   + d
                 ! using the formula in qzit (from eispack)
                 ! we assume that the block is at least 3x3
                 ad11 = ( ascale*h( ilast-1, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad21 = ( ascale*h( ilast, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad12 = ( ascale*h( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad22 = ( ascale*h( ilast, ilast ) ) /( bscale*t( ilast, ilast ) )
                 u12 = t( ilast-1, ilast ) / t( ilast, ilast )
                 ad11l = ( ascale*h( ifirst, ifirst ) ) /( bscale*t( ifirst, ifirst ) )
                 ad21l = ( ascale*h( ifirst+1, ifirst ) ) /( bscale*t( ifirst, ifirst ) )
                 ad12l = ( ascale*h( ifirst, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 ad22l = ( ascale*h( ifirst+1, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 ad32l = ( ascale*h( ifirst+2, ifirst+1 ) ) /( bscale*t( ifirst+1, ifirst+1 ) )
                           
                 u12l = t( ifirst, ifirst+1 ) / t( ifirst+1, ifirst+1 )
                 v( 1 ) = ( ad11-ad11l )*( ad22-ad11l ) - ad12*ad21 +ad21*u12*ad11l + ( ad12l-&
                           ad11l*u12l )*ad21l
                 v( 2 ) = ( ( ad22l-ad11l )-ad21l*u12l-( ad11-ad11l )-( ad22-ad11l )+ad21*u12 )&
                           *ad21l
                 v( 3 ) = ad32l*ad21l
                 istart = ifirst
                 call stdlib_${ri}$larfg( 3, v( 1 ), v( 2 ), 1, tau )
                 v( 1 ) = one
                 ! sweep
                 loop_290: do j = istart, ilast - 2
                    ! all but last elements: use 3x3 householder transforms.
                    ! zero (j-1)st column of a
                    if( j>istart ) then
                       v( 1 ) = h( j, j-1 )
                       v( 2 ) = h( j+1, j-1 )
                       v( 3 ) = h( j+2, j-1 )
                       call stdlib_${ri}$larfg( 3, h( j, j-1 ), v( 2 ), 1, tau )
                       v( 1 ) = one
                       h( j+1, j-1 ) = zero
                       h( j+2, j-1 ) = zero
                    end if
                    do jc = j, ilastm
                       temp = tau*( h( j, jc )+v( 2 )*h( j+1, jc )+v( 3 )*h( j+2, jc ) )
                       h( j, jc ) = h( j, jc ) - temp
                       h( j+1, jc ) = h( j+1, jc ) - temp*v( 2 )
                       h( j+2, jc ) = h( j+2, jc ) - temp*v( 3 )
                       temp2 = tau*( t( j, jc )+v( 2 )*t( j+1, jc )+v( 3 )*t( j+2, jc ) )
                       t( j, jc ) = t( j, jc ) - temp2
                       t( j+1, jc ) = t( j+1, jc ) - temp2*v( 2 )
                       t( j+2, jc ) = t( j+2, jc ) - temp2*v( 3 )
                    end do
                    if( ilq ) then
                       do jr = 1, n
                          temp = tau*( q( jr, j )+v( 2 )*q( jr, j+1 )+v( 3 )*q( jr, j+2 ) )
                                    
                          q( jr, j ) = q( jr, j ) - temp
                          q( jr, j+1 ) = q( jr, j+1 ) - temp*v( 2 )
                          q( jr, j+2 ) = q( jr, j+2 ) - temp*v( 3 )
                       end do
                    end if
                    ! zero j-th column of b (see dlagbc for details)
                    ! swap rows to pivot
                    ilpivt = .false.
                    temp = max( abs( t( j+1, j+1 ) ), abs( t( j+1, j+2 ) ) )
                    temp2 = max( abs( t( j+2, j+1 ) ), abs( t( j+2, j+2 ) ) )
                    if( max( temp, temp2 )<safmin ) then
                       scale = zero
                       u1 = one
                       u2 = zero
                       go to 250
                    else if( temp>=temp2 ) then
                       w11 = t( j+1, j+1 )
                       w21 = t( j+2, j+1 )
                       w12 = t( j+1, j+2 )
                       w22 = t( j+2, j+2 )
                       u1 = t( j+1, j )
                       u2 = t( j+2, j )
                    else
                       w21 = t( j+1, j+1 )
                       w11 = t( j+2, j+1 )
                       w22 = t( j+1, j+2 )
                       w12 = t( j+2, j+2 )
                       u2 = t( j+1, j )
                       u1 = t( j+2, j )
                    end if
                    ! swap columns if nec.
                    if( abs( w12 )>abs( w11 ) ) then
                       ilpivt = .true.
                       temp = w12
                       temp2 = w22
                       w12 = w11
                       w22 = w21
                       w11 = temp
                       w21 = temp2
                    end if
                    ! lu-factor
                    temp = w21 / w11
                    u2 = u2 - temp*u1
                    w22 = w22 - temp*w12
                    w21 = zero
                    ! compute scale
                    scale = one
                    if( abs( w22 )<safmin ) then
                       scale = zero
                       u2 = one
                       u1 = -w12 / w11
                       go to 250
                    end if
                    if( abs( w22 )<abs( u2 ) )scale = abs( w22 / u2 )
                    if( abs( w11 )<abs( u1 ) )scale = min( scale, abs( w11 / u1 ) )
                    ! solve
                    u2 = ( scale*u2 ) / w22
                    u1 = ( scale*u1-w12*u2 ) / w11
                    250 continue
                    if( ilpivt ) then
                       temp = u2
                       u2 = u1
                       u1 = temp
                    end if
                    ! compute householder vector
                    t1 = sqrt( scale**2+u1**2+u2**2 )
                    tau = one + scale / t1
                    vs = -one / ( scale+t1 )
                    v( 1 ) = one
                    v( 2 ) = vs*u1
                    v( 3 ) = vs*u2
                    ! apply transformations from the right.
                    do jr = ifrstm, min( j+3, ilast )
                       temp = tau*( h( jr, j )+v( 2 )*h( jr, j+1 )+v( 3 )*h( jr, j+2 ) )
                       h( jr, j ) = h( jr, j ) - temp
                       h( jr, j+1 ) = h( jr, j+1 ) - temp*v( 2 )
                       h( jr, j+2 ) = h( jr, j+2 ) - temp*v( 3 )
                    end do
                    do jr = ifrstm, j + 2
                       temp = tau*( t( jr, j )+v( 2 )*t( jr, j+1 )+v( 3 )*t( jr, j+2 ) )
                       t( jr, j ) = t( jr, j ) - temp
                       t( jr, j+1 ) = t( jr, j+1 ) - temp*v( 2 )
                       t( jr, j+2 ) = t( jr, j+2 ) - temp*v( 3 )
                    end do
                    if( ilz ) then
                       do jr = 1, n
                          temp = tau*( z( jr, j )+v( 2 )*z( jr, j+1 )+v( 3 )*z( jr, j+2 ) )
                                    
                          z( jr, j ) = z( jr, j ) - temp
                          z( jr, j+1 ) = z( jr, j+1 ) - temp*v( 2 )
                          z( jr, j+2 ) = z( jr, j+2 ) - temp*v( 3 )
                       end do
                    end if
                    t( j+1, j ) = zero
                    t( j+2, j ) = zero
                 end do loop_290
                 ! last elements: use givens rotations
                 ! rotations from the left
                 j = ilast - 1
                 temp = h( j, j-1 )
                 call stdlib_${ri}$lartg( temp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                 h( j+1, j-1 ) = zero
                 do jc = j, ilastm
                    temp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -s*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = temp
                    temp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -s*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = temp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       temp = c*q( jr, j ) + s*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = temp
                    end do
                 end if
                 ! rotations from the right.
                 temp = t( j+1, j+1 )
                 call stdlib_${ri}$lartg( temp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = zero
                 do jr = ifrstm, ilast
                    temp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -s*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = temp
                 end do
                 do jr = ifrstm, ilast - 1
                    temp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -s*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = temp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       temp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -s*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = temp
                    end do
                 end if
                 ! end of double-shift code
              end if
              go to 350
              ! end of iteration loop
              350 continue
           end do loop_360
           ! drop-through = non-convergence
           info = ilast
           go to 420
           ! successful completion of all qz steps
           380 continue
           ! set eigenvalues 1:ilo-1
           do j = 1, ilo - 1
              if( t( j, j )<zero ) then
                 if( ilschr ) then
                    do jr = 1, j
                       h( jr, j ) = -h( jr, j )
                       t( jr, j ) = -t( jr, j )
                    end do
                 else
                    h( j, j ) = -h( j, j )
                    t( j, j ) = -t( j, j )
                 end if
                 if( ilz ) then
                    do jr = 1, n
                       z( jr, j ) = -z( jr, j )
                    end do
                 end if
              end if
              alphar( j ) = h( j, j )
              alphai( j ) = zero
              beta( j ) = t( j, j )
           end do
           ! normal termination
           info = 0
           ! exit (other than argument error) -- return optimal workspace size
           420 continue
           work( 1 ) = real( n,KIND=${rk}$)
           return
     end subroutine stdlib_${ri}$hgeqz

#:endif
#:endfor

     module subroutine stdlib_chgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alpha, beta, q, ldq,&
     !! CHGEQZ computes the eigenvalues of a complex matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the single-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a complex matrix pair (A,B):
     !! A = Q1*H*Z1**H,  B = Q1*T*Z1**H,
     !! as computed by CGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**H,  T = Q*P*Z**H,
     !! where Q and Z are unitary matrices and S and P are upper triangular.
     !! Optionally, the unitary matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! unitary matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the unitary matrices from CGGHRD that reduced
     !! the matrix pair (A,B) to generalized Hessenberg form, then the output
     !! matrices Q1*Q and Z1*Z are the unitary factors from the generalized
     !! Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T)
     !! (equivalently, of (A,B)) are computed as a pair of complex values
     !! (alpha,beta).  If beta is nonzero, lambda = alpha / beta is an
     !! eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! The values of alpha and beta for the i-th eigenvalue can be read
     !! directly from the generalized Schur form:  alpha = S(i,i),
     !! beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
                z, ldz, work, lwork,rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz, job
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(out) :: alpha(*), beta(*), work(*)
           complex(sp), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
        ! =====================================================================
           
           
           
           ! Local Scalars 
           logical(lk) :: ilazr2, ilazro, ilq, ilschr, ilz, lquery
           integer(ilp) :: icompq, icompz, ifirst, ifrstm, iiter, ilast, ilastm, in, ischur, &
                     istart, j, jc, jch, jiter, jr, maxit
           real(sp) :: absb, anorm, ascale, atol, bnorm, bscale, btol, c, safmin, temp, temp2, &
                     tempr, ulp
           complex(sp) :: abi22, ad11, ad12, ad21, ad22, ctemp, ctemp2, ctemp3, eshift, s, shift, &
                     signbc, u12, x, abi12, y
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=sp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode job, compq, compz
           if( stdlib_lsame( job, 'E' ) ) then
              ilschr = .false.
              ischur = 1
           else if( stdlib_lsame( job, 'S' ) ) then
              ilschr = .true.
              ischur = 2
           else
              ilschr = .true.
              ischur = 0
           end if
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              ilq = .true.
              icompq = 0
           end if
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              ilz = .true.
              icompz = 0
           end if
           ! check argument values
           info = 0
           work( 1 ) = max( 1, n )
           lquery = ( lwork==-1 )
           if( ischur==0 ) then
              info = -1
           else if( icompq==0 ) then
              info = -2
           else if( icompz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( ldh<n ) then
              info = -8
           else if( ldt<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -14
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -16
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CHGEQZ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           ! work( 1 ) = cmplx( 1,KIND=sp)
           if( n<=0 ) then
              work( 1 ) = cmplx( 1,KIND=sp)
              return
           end if
           ! initialize q and z
           if( icompq==3 )call stdlib_claset( 'FULL', n, n, czero, cone, q, ldq )
           if( icompz==3 )call stdlib_claset( 'FULL', n, n, czero, cone, z, ldz )
           ! machine constants
           in = ihi + 1 - ilo
           safmin = stdlib_slamch( 'S' )
           ulp = stdlib_slamch( 'E' )*stdlib_slamch( 'B' )
           anorm = stdlib_clanhs( 'F', in, h( ilo, ilo ), ldh, rwork )
           bnorm = stdlib_clanhs( 'F', in, t( ilo, ilo ), ldt, rwork )
           atol = max( safmin, ulp*anorm )
           btol = max( safmin, ulp*bnorm )
           ascale = one / max( safmin, anorm )
           bscale = one / max( safmin, bnorm )
           ! set eigenvalues ihi+1:n
           do j = ihi + 1, n
              absb = abs( t( j, j ) )
              if( absb>safmin ) then
                 signbc = conjg( t( j, j ) / absb )
                 t( j, j ) = absb
                 if( ilschr ) then
                    call stdlib_cscal( j-1, signbc, t( 1, j ), 1 )
                    call stdlib_cscal( j, signbc, h( 1, j ), 1 )
                 else
                    call stdlib_cscal( 1, signbc, h( j, j ), 1 )
                 end if
                 if( ilz )call stdlib_cscal( n, signbc, z( 1, j ), 1 )
              else
                 t( j, j ) = czero
              end if
              alpha( j ) = h( j, j )
              beta( j ) = t( j, j )
           end do
           ! if ihi < ilo, skip qz steps
           if( ihi<ilo )go to 190
           ! main qz iteration loop
           ! initialize dynamic indices
           ! eigenvalues ilast+1:n have been found.
              ! column operations modify rows ifrstm:whatever
              ! row operations modify columns whatever:ilastm
           ! if only eigenvalues are being computed, then
              ! ifrstm is the row of the last splitting row above row ilast;
              ! this is always at least ilo.
           ! iiter counts iterations since the last eigenvalue was found,
              ! to tell when to use an extraordinary shift.
           ! maxit is the maximum number of qz sweeps allowed.
           ilast = ihi
           if( ilschr ) then
              ifrstm = 1
              ilastm = n
           else
              ifrstm = ilo
              ilastm = ihi
           end if
           iiter = 0
           eshift = czero
           maxit = 30*( ihi-ilo+1 )
           loop_170: do jiter = 1, maxit
              ! check for too many iterations.
              if( jiter>maxit )go to 180
              ! split the matrix if possible.
              ! two tests:
                 ! 1: h(j,j-1)=0  or  j=ilo
                 ! 2: t(j,j)=0
              ! special case: j=ilast
              if( ilast==ilo ) then
                 go to 60
              else
                 if( abs1( h( ilast, ilast-1 ) )<=max( safmin, ulp*(abs1( h( ilast, ilast ) ) + &
                           abs1( h( ilast-1, ilast-1 )) ) ) ) then
                    h( ilast, ilast-1 ) = czero
                    go to 60
                 end if
              end if
              if( abs( t( ilast, ilast ) )<=max( safmin, ulp*(abs( t( ilast - 1, ilast ) ) + abs( &
                        t( ilast-1, ilast-1 )) ) ) ) then
                 t( ilast, ilast ) = czero
                 go to 50
              end if
              ! general case: j<ilast
              loop_40: do j = ilast - 1, ilo, -1
                 ! test 1: for h(j,j-1)=0 or j=ilo
                 if( j==ilo ) then
                    ilazro = .true.
                 else
                    if( abs1( h( j, j-1 ) )<=max( safmin, ulp*(abs1( h( j, j ) ) + abs1( h( j-1, &
                              j-1 ) )) ) ) then
                       h( j, j-1 ) = czero
                       ilazro = .true.
                    else
                       ilazro = .false.
                    end if
                 end if
                 ! test 2: for t(j,j)=0
                 temp = abs ( t( j, j + 1 ) )
                 if ( j > ilo )temp = temp + abs ( t( j - 1, j ) )
                 if( abs( t( j, j ) )<max( safmin,ulp*temp ) ) then
                    t( j, j ) = czero
                    ! test 1a: check for 2 consecutive small subdiagonals in a
                    ilazr2 = .false.
                    if( .not.ilazro ) then
                       if( abs1( h( j, j-1 ) )*( ascale*abs1( h( j+1,j ) ) )<=abs1( h( j, j ) )*( &
                                 ascale*atol ) )ilazr2 = .true.
                    end if
                    ! if both tests pass (1
                    ! element of b in the block is zero, split a 1x1 block off
                    ! at the top. (i.e., at the j-th row/column) the leading
                    ! diagonal element of the remainder can also be zero, so
                    ! this may have to be done repeatedly.
                    if( ilazro .or. ilazr2 ) then
                       do jch = j, ilast - 1
                          ctemp = h( jch, jch )
                          call stdlib_clartg( ctemp, h( jch+1, jch ), c, s,h( jch, jch ) )
                          h( jch+1, jch ) = czero
                          call stdlib_crot( ilastm-jch, h( jch, jch+1 ), ldh,h( jch+1, jch+1 ), &
                                    ldh, c, s )
                          call stdlib_crot( ilastm-jch, t( jch, jch+1 ), ldt,t( jch+1, jch+1 ), &
                                    ldt, c, s )
                          if( ilq )call stdlib_crot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, conjg(&
                                     s ) )
                          if( ilazr2 )h( jch, jch-1 ) = h( jch, jch-1 )*c
                          ilazr2 = .false.
                          if( abs1( t( jch+1, jch+1 ) )>=btol ) then
                             if( jch+1>=ilast ) then
                                go to 60
                             else
                                ifirst = jch + 1
                                go to 70
                             end if
                          end if
                          t( jch+1, jch+1 ) = czero
                       end do
                       go to 50
                    else
                       ! only test 2 passed -- chase the zero to t(ilast,ilast)
                       ! then process as in the case t(ilast,ilast)=0
                       do jch = j, ilast - 1
                          ctemp = t( jch, jch+1 )
                          call stdlib_clartg( ctemp, t( jch+1, jch+1 ), c, s,t( jch, jch+1 ) )
                                    
                          t( jch+1, jch+1 ) = czero
                          if( jch<ilastm-1 )call stdlib_crot( ilastm-jch-1, t( jch, jch+2 ), ldt,&
                                    t( jch+1, jch+2 ), ldt, c, s )
                          call stdlib_crot( ilastm-jch+2, h( jch, jch-1 ), ldh,h( jch+1, jch-1 ), &
                                    ldh, c, s )
                          if( ilq )call stdlib_crot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, conjg(&
                                     s ) )
                          ctemp = h( jch+1, jch )
                          call stdlib_clartg( ctemp, h( jch+1, jch-1 ), c, s,h( jch+1, jch ) )
                                    
                          h( jch+1, jch-1 ) = czero
                          call stdlib_crot( jch+1-ifrstm, h( ifrstm, jch ), 1,h( ifrstm, jch-1 ), &
                                    1, c, s )
                          call stdlib_crot( jch-ifrstm, t( ifrstm, jch ), 1,t( ifrstm, jch-1 ), 1,&
                                     c, s )
                          if( ilz )call stdlib_crot( n, z( 1, jch ), 1, z( 1, jch-1 ), 1,c, s )
                                    
                       end do
                       go to 50
                    end if
                 else if( ilazro ) then
                    ! only test 1 passed -- work on j:ilast
                    ifirst = j
                    go to 70
                 end if
                 ! neither test passed -- try next j
              end do loop_40
              ! (drop-through is "impossible")
              info = 2*n + 1
              go to 210
              ! t(ilast,ilast)=0 -- clear h(ilast,ilast-1) to split off a
              ! 1x1 block.
              50 continue
              ctemp = h( ilast, ilast )
              call stdlib_clartg( ctemp, h( ilast, ilast-1 ), c, s,h( ilast, ilast ) )
              h( ilast, ilast-1 ) = czero
              call stdlib_crot( ilast-ifrstm, h( ifrstm, ilast ), 1,h( ifrstm, ilast-1 ), 1, c, s &
                        )
              call stdlib_crot( ilast-ifrstm, t( ifrstm, ilast ), 1,t( ifrstm, ilast-1 ), 1, c, s &
                        )
              if( ilz )call stdlib_crot( n, z( 1, ilast ), 1, z( 1, ilast-1 ), 1, c, s )
              ! h(ilast,ilast-1)=0 -- standardize b, set alpha and beta
              60 continue
              absb = abs( t( ilast, ilast ) )
              if( absb>safmin ) then
                 signbc = conjg( t( ilast, ilast ) / absb )
                 t( ilast, ilast ) = absb
                 if( ilschr ) then
                    call stdlib_cscal( ilast-ifrstm, signbc, t( ifrstm, ilast ), 1 )
                    call stdlib_cscal( ilast+1-ifrstm, signbc, h( ifrstm, ilast ),1 )
                 else
                    call stdlib_cscal( 1, signbc, h( ilast, ilast ), 1 )
                 end if
                 if( ilz )call stdlib_cscal( n, signbc, z( 1, ilast ), 1 )
              else
                 t( ilast, ilast ) = czero
              end if
              alpha( ilast ) = h( ilast, ilast )
              beta( ilast ) = t( ilast, ilast )
              ! go to next block -- exit if finished.
              ilast = ilast - 1
              if( ilast<ilo )go to 190
              ! reset counters
              iiter = 0
              eshift = czero
              if( .not.ilschr ) then
                 ilastm = ilast
                 if( ifrstm>ilast )ifrstm = ilo
              end if
              go to 160
              ! qz step
              ! this iteration only involves rows/columns ifirst:ilast.  we
              ! assume ifirst < ilast, and that the diagonal of b is non-zero.
              70 continue
              iiter = iiter + 1
              if( .not.ilschr ) then
                 ifrstm = ifirst
              end if
              ! compute the shift.
              ! at this point, ifirst < ilast, and the diagonal elements of
              ! t(ifirst:ilast,ifirst,ilast) are larger than btol (in
              ! magnitude)
              if( ( iiter / 10 )*10/=iiter ) then
                 ! the wilkinson shift (aep p.512_sp), i.e., the eigenvalue of
                 ! the bottom-right 2x2 block of a inv(b) which is nearest to
                 ! the bottom-right element.
                 ! we factor b as u*d, where u has unit diagonals, and
                 ! compute (a*inv(d))*inv(u).
                 u12 = ( bscale*t( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad11 = ( ascale*h( ilast-1, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad21 = ( ascale*h( ilast, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad12 = ( ascale*h( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad22 = ( ascale*h( ilast, ilast ) ) /( bscale*t( ilast, ilast ) )
                 abi22 = ad22 - u12*ad21
                 abi12 = ad12 - u12*ad11
                 shift = abi22
                 ctemp = sqrt( abi12 )*sqrt( ad21 )
                 temp = abs1( ctemp )
                 if( ctemp/=zero ) then
                    x = half*( ad11-shift )
                    temp2 = abs1( x )
                    temp = max( temp, abs1( x ) )
                    y = temp*sqrt( ( x / temp )**2+( ctemp / temp )**2 )
                    if( temp2>zero ) then
                       if( real( x / temp2,KIND=sp)*real( y,KIND=sp)+aimag( x / temp2 )*aimag( y )&
                                 <zero )y = -y
                    end if
                    shift = shift - ctemp*stdlib_cladiv( ctemp, ( x+y ) )
                 end if
              else
                 ! exceptional shift.  chosen for no particularly good reason.
                 if( ( iiter / 20 )*20==iiter .and.bscale*abs1(t( ilast, ilast ))>safmin ) &
                           then
                    eshift = eshift + ( ascale*h( ilast,ilast ) )/( bscale*t( ilast, ilast ) )
                              
                 else
                    eshift = eshift + ( ascale*h( ilast,ilast-1 ) )/( bscale*t( ilast-1, ilast-1 )&
                               )
                 end if
                 shift = eshift
              end if
              ! now check for two consecutive small subdiagonals.
              do j = ilast - 1, ifirst + 1, -1
                 istart = j
                 ctemp = ascale*h( j, j ) - shift*( bscale*t( j, j ) )
                 temp = abs1( ctemp )
                 temp2 = ascale*abs1( h( j+1, j ) )
                 tempr = max( temp, temp2 )
                 if( tempr<one .and. tempr/=zero ) then
                    temp = temp / tempr
                    temp2 = temp2 / tempr
                 end if
                 if( abs1( h( j, j-1 ) )*temp2<=temp*atol )go to 90
              end do
              istart = ifirst
              ctemp = ascale*h( ifirst, ifirst ) -shift*( bscale*t( ifirst, ifirst ) )
              90 continue
              ! do an implicit-shift qz sweep.
              ! initial q
              ctemp2 = ascale*h( istart+1, istart )
              call stdlib_clartg( ctemp, ctemp2, c, s, ctemp3 )
              ! sweep
              loop_150: do j = istart, ilast - 1
                 if( j>istart ) then
                    ctemp = h( j, j-1 )
                    call stdlib_clartg( ctemp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                    h( j+1, j-1 ) = czero
                 end if
                 do jc = j, ilastm
                    ctemp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -conjg( s )*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = ctemp
                    ctemp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -conjg( s )*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = ctemp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       ctemp = c*q( jr, j ) + conjg( s )*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = ctemp
                    end do
                 end if
                 ctemp = t( j+1, j+1 )
                 call stdlib_clartg( ctemp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = czero
                 do jr = ifrstm, min( j+2, ilast )
                    ctemp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -conjg( s )*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = ctemp
                 end do
                 do jr = ifrstm, j
                    ctemp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -conjg( s )*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = ctemp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       ctemp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -conjg( s )*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = ctemp
                    end do
                 end if
              end do loop_150
              160 continue
           end do loop_170
           ! drop-through = non-convergence
           180 continue
           info = ilast
           go to 210
           ! successful completion of all qz steps
           190 continue
           ! set eigenvalues 1:ilo-1
           do j = 1, ilo - 1
              absb = abs( t( j, j ) )
              if( absb>safmin ) then
                 signbc = conjg( t( j, j ) / absb )
                 t( j, j ) = absb
                 if( ilschr ) then
                    call stdlib_cscal( j-1, signbc, t( 1, j ), 1 )
                    call stdlib_cscal( j, signbc, h( 1, j ), 1 )
                 else
                    call stdlib_cscal( 1, signbc, h( j, j ), 1 )
                 end if
                 if( ilz )call stdlib_cscal( n, signbc, z( 1, j ), 1 )
              else
                 t( j, j ) = czero
              end if
              alpha( j ) = h( j, j )
              beta( j ) = t( j, j )
           end do
           ! normal termination
           info = 0
           ! exit (other than argument error) -- return optimal workspace size
           210 continue
           work( 1 ) = cmplx( n,KIND=sp)
           return
     end subroutine stdlib_chgeqz

     module subroutine stdlib_zhgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alpha, beta, q, ldq,&
     !! ZHGEQZ computes the eigenvalues of a complex matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the single-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a complex matrix pair (A,B):
     !! A = Q1*H*Z1**H,  B = Q1*T*Z1**H,
     !! as computed by ZGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**H,  T = Q*P*Z**H,
     !! where Q and Z are unitary matrices and S and P are upper triangular.
     !! Optionally, the unitary matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! unitary matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the unitary matrices from ZGGHRD that reduced
     !! the matrix pair (A,B) to generalized Hessenberg form, then the output
     !! matrices Q1*Q and Z1*Z are the unitary factors from the generalized
     !! Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T)
     !! (equivalently, of (A,B)) are computed as a pair of complex values
     !! (alpha,beta).  If beta is nonzero, lambda = alpha / beta is an
     !! eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! The values of alpha and beta for the i-th eigenvalue can be read
     !! directly from the generalized Schur form:  alpha = S(i,i),
     !! beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
                z, ldz, work, lwork,rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz, job
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(out) :: alpha(*), beta(*), work(*)
           complex(dp), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
        ! =====================================================================
           
           
           
           ! Local Scalars 
           logical(lk) :: ilazr2, ilazro, ilq, ilschr, ilz, lquery
           integer(ilp) :: icompq, icompz, ifirst, ifrstm, iiter, ilast, ilastm, in, ischur, &
                     istart, j, jc, jch, jiter, jr, maxit
           real(dp) :: absb, anorm, ascale, atol, bnorm, bscale, btol, c, safmin, temp, temp2, &
                     tempr, ulp
           complex(dp) :: abi22, ad11, ad12, ad21, ad22, ctemp, ctemp2, ctemp3, eshift, s, shift, &
                     signbc, u12, x, abi12, y
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=dp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode job, compq, compz
           if( stdlib_lsame( job, 'E' ) ) then
              ilschr = .false.
              ischur = 1
           else if( stdlib_lsame( job, 'S' ) ) then
              ilschr = .true.
              ischur = 2
           else
              ilschr = .true.
              ischur = 0
           end if
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              ilq = .true.
              icompq = 0
           end if
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              ilz = .true.
              icompz = 0
           end if
           ! check argument values
           info = 0
           work( 1 ) = max( 1, n )
           lquery = ( lwork==-1 )
           if( ischur==0 ) then
              info = -1
           else if( icompq==0 ) then
              info = -2
           else if( icompz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( ldh<n ) then
              info = -8
           else if( ldt<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -14
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -16
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHGEQZ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           ! work( 1 ) = cmplx( 1,KIND=dp)
           if( n<=0 ) then
              work( 1 ) = cmplx( 1,KIND=dp)
              return
           end if
           ! initialize q and z
           if( icompq==3 )call stdlib_zlaset( 'FULL', n, n, czero, cone, q, ldq )
           if( icompz==3 )call stdlib_zlaset( 'FULL', n, n, czero, cone, z, ldz )
           ! machine constants
           in = ihi + 1 - ilo
           safmin = stdlib_dlamch( 'S' )
           ulp = stdlib_dlamch( 'E' )*stdlib_dlamch( 'B' )
           anorm = stdlib_zlanhs( 'F', in, h( ilo, ilo ), ldh, rwork )
           bnorm = stdlib_zlanhs( 'F', in, t( ilo, ilo ), ldt, rwork )
           atol = max( safmin, ulp*anorm )
           btol = max( safmin, ulp*bnorm )
           ascale = one / max( safmin, anorm )
           bscale = one / max( safmin, bnorm )
           ! set eigenvalues ihi+1:n
           do j = ihi + 1, n
              absb = abs( t( j, j ) )
              if( absb>safmin ) then
                 signbc = conjg( t( j, j ) / absb )
                 t( j, j ) = absb
                 if( ilschr ) then
                    call stdlib_zscal( j-1, signbc, t( 1, j ), 1 )
                    call stdlib_zscal( j, signbc, h( 1, j ), 1 )
                 else
                    call stdlib_zscal( 1, signbc, h( j, j ), 1 )
                 end if
                 if( ilz )call stdlib_zscal( n, signbc, z( 1, j ), 1 )
              else
                 t( j, j ) = czero
              end if
              alpha( j ) = h( j, j )
              beta( j ) = t( j, j )
           end do
           ! if ihi < ilo, skip qz steps
           if( ihi<ilo )go to 190
           ! main qz iteration loop
           ! initialize dynamic indices
           ! eigenvalues ilast+1:n have been found.
              ! column operations modify rows ifrstm:whatever
              ! row operations modify columns whatever:ilastm
           ! if only eigenvalues are being computed, then
              ! ifrstm is the row of the last splitting row above row ilast;
              ! this is always at least ilo.
           ! iiter counts iterations since the last eigenvalue was found,
              ! to tell when to use an extraordinary shift.
           ! maxit is the maximum number of qz sweeps allowed.
           ilast = ihi
           if( ilschr ) then
              ifrstm = 1
              ilastm = n
           else
              ifrstm = ilo
              ilastm = ihi
           end if
           iiter = 0
           eshift = czero
           maxit = 30*( ihi-ilo+1 )
           loop_170: do jiter = 1, maxit
              ! check for too many iterations.
              if( jiter>maxit )go to 180
              ! split the matrix if possible.
              ! two tests:
                 ! 1: h(j,j-1)=0  or  j=ilo
                 ! 2: t(j,j)=0
              ! special case: j=ilast
              if( ilast==ilo ) then
                 go to 60
              else
                 if( abs1( h( ilast, ilast-1 ) )<=max( safmin, ulp*(abs1( h( ilast, ilast ) ) + &
                           abs1( h( ilast-1, ilast-1 )) ) ) ) then
                    h( ilast, ilast-1 ) = czero
                    go to 60
                 end if
              end if
              if( abs( t( ilast, ilast ) )<=max( safmin, ulp*(abs( t( ilast - 1, ilast ) ) + abs( &
                        t( ilast-1, ilast-1 )) ) ) ) then
                 t( ilast, ilast ) = czero
                 go to 50
              end if
              ! general case: j<ilast
              loop_40: do j = ilast - 1, ilo, -1
                 ! test 1: for h(j,j-1)=0 or j=ilo
                 if( j==ilo ) then
                    ilazro = .true.
                 else
                    if( abs1( h( j, j-1 ) )<=max( safmin, ulp*(abs1( h( j, j ) ) + abs1( h( j-1, &
                              j-1 ) )) ) ) then
                       h( j, j-1 ) = czero
                       ilazro = .true.
                    else
                       ilazro = .false.
                    end if
                 end if
                 ! test 2: for t(j,j)=0
                 temp = abs ( t( j, j + 1 ) )
                 if ( j > ilo )temp = temp + abs ( t( j - 1, j ) )
                 if( abs( t( j, j ) )<max( safmin,ulp*temp ) ) then
                    t( j, j ) = czero
                    ! test 1a: check for 2 consecutive small subdiagonals in a
                    ilazr2 = .false.
                    if( .not.ilazro ) then
                       if( abs1( h( j, j-1 ) )*( ascale*abs1( h( j+1,j ) ) )<=abs1( h( j, j ) )*( &
                                 ascale*atol ) )ilazr2 = .true.
                    end if
                    ! if both tests pass (1
                    ! element of b in the block is zero, split a 1x1 block off
                    ! at the top. (i.e., at the j-th row/column) the leading
                    ! diagonal element of the remainder can also be zero, so
                    ! this may have to be done repeatedly.
                    if( ilazro .or. ilazr2 ) then
                       do jch = j, ilast - 1
                          ctemp = h( jch, jch )
                          call stdlib_zlartg( ctemp, h( jch+1, jch ), c, s,h( jch, jch ) )
                          h( jch+1, jch ) = czero
                          call stdlib_zrot( ilastm-jch, h( jch, jch+1 ), ldh,h( jch+1, jch+1 ), &
                                    ldh, c, s )
                          call stdlib_zrot( ilastm-jch, t( jch, jch+1 ), ldt,t( jch+1, jch+1 ), &
                                    ldt, c, s )
                          if( ilq )call stdlib_zrot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, conjg(&
                                     s ) )
                          if( ilazr2 )h( jch, jch-1 ) = h( jch, jch-1 )*c
                          ilazr2 = .false.
                          if( abs1( t( jch+1, jch+1 ) )>=btol ) then
                             if( jch+1>=ilast ) then
                                go to 60
                             else
                                ifirst = jch + 1
                                go to 70
                             end if
                          end if
                          t( jch+1, jch+1 ) = czero
                       end do
                       go to 50
                    else
                       ! only test 2 passed -- chase the zero to t(ilast,ilast)
                       ! then process as in the case t(ilast,ilast)=0
                       do jch = j, ilast - 1
                          ctemp = t( jch, jch+1 )
                          call stdlib_zlartg( ctemp, t( jch+1, jch+1 ), c, s,t( jch, jch+1 ) )
                                    
                          t( jch+1, jch+1 ) = czero
                          if( jch<ilastm-1 )call stdlib_zrot( ilastm-jch-1, t( jch, jch+2 ), ldt,&
                                    t( jch+1, jch+2 ), ldt, c, s )
                          call stdlib_zrot( ilastm-jch+2, h( jch, jch-1 ), ldh,h( jch+1, jch-1 ), &
                                    ldh, c, s )
                          if( ilq )call stdlib_zrot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, conjg(&
                                     s ) )
                          ctemp = h( jch+1, jch )
                          call stdlib_zlartg( ctemp, h( jch+1, jch-1 ), c, s,h( jch+1, jch ) )
                                    
                          h( jch+1, jch-1 ) = czero
                          call stdlib_zrot( jch+1-ifrstm, h( ifrstm, jch ), 1,h( ifrstm, jch-1 ), &
                                    1, c, s )
                          call stdlib_zrot( jch-ifrstm, t( ifrstm, jch ), 1,t( ifrstm, jch-1 ), 1,&
                                     c, s )
                          if( ilz )call stdlib_zrot( n, z( 1, jch ), 1, z( 1, jch-1 ), 1,c, s )
                                    
                       end do
                       go to 50
                    end if
                 else if( ilazro ) then
                    ! only test 1 passed -- work on j:ilast
                    ifirst = j
                    go to 70
                 end if
                 ! neither test passed -- try next j
              end do loop_40
              ! (drop-through is "impossible")
              info = 2*n + 1
              go to 210
              ! t(ilast,ilast)=0 -- clear h(ilast,ilast-1) to split off a
              ! 1x1 block.
              50 continue
              ctemp = h( ilast, ilast )
              call stdlib_zlartg( ctemp, h( ilast, ilast-1 ), c, s,h( ilast, ilast ) )
              h( ilast, ilast-1 ) = czero
              call stdlib_zrot( ilast-ifrstm, h( ifrstm, ilast ), 1,h( ifrstm, ilast-1 ), 1, c, s &
                        )
              call stdlib_zrot( ilast-ifrstm, t( ifrstm, ilast ), 1,t( ifrstm, ilast-1 ), 1, c, s &
                        )
              if( ilz )call stdlib_zrot( n, z( 1, ilast ), 1, z( 1, ilast-1 ), 1, c, s )
              ! h(ilast,ilast-1)=0 -- standardize b, set alpha and beta
              60 continue
              absb = abs( t( ilast, ilast ) )
              if( absb>safmin ) then
                 signbc = conjg( t( ilast, ilast ) / absb )
                 t( ilast, ilast ) = absb
                 if( ilschr ) then
                    call stdlib_zscal( ilast-ifrstm, signbc, t( ifrstm, ilast ), 1 )
                    call stdlib_zscal( ilast+1-ifrstm, signbc, h( ifrstm, ilast ),1 )
                 else
                    call stdlib_zscal( 1, signbc, h( ilast, ilast ), 1 )
                 end if
                 if( ilz )call stdlib_zscal( n, signbc, z( 1, ilast ), 1 )
              else
                 t( ilast, ilast ) = czero
              end if
              alpha( ilast ) = h( ilast, ilast )
              beta( ilast ) = t( ilast, ilast )
              ! go to next block -- exit if finished.
              ilast = ilast - 1
              if( ilast<ilo )go to 190
              ! reset counters
              iiter = 0
              eshift = czero
              if( .not.ilschr ) then
                 ilastm = ilast
                 if( ifrstm>ilast )ifrstm = ilo
              end if
              go to 160
              ! qz step
              ! this iteration only involves rows/columns ifirst:ilast.  we
              ! assume ifirst < ilast, and that the diagonal of b is non-zero.
              70 continue
              iiter = iiter + 1
              if( .not.ilschr ) then
                 ifrstm = ifirst
              end if
              ! compute the shift.
              ! at this point, ifirst < ilast, and the diagonal elements of
              ! t(ifirst:ilast,ifirst,ilast) are larger than btol (in
              ! magnitude)
              if( ( iiter / 10 )*10/=iiter ) then
                 ! the wilkinson shift (aep p.512_dp), i.e., the eigenvalue of
                 ! the bottom-right 2x2 block of a inv(b) which is nearest to
                 ! the bottom-right element.
                 ! we factor b as u*d, where u has unit diagonals, and
                 ! compute (a*inv(d))*inv(u).
                 u12 = ( bscale*t( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad11 = ( ascale*h( ilast-1, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad21 = ( ascale*h( ilast, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad12 = ( ascale*h( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad22 = ( ascale*h( ilast, ilast ) ) /( bscale*t( ilast, ilast ) )
                 abi22 = ad22 - u12*ad21
                 abi12 = ad12 - u12*ad11
                 shift = abi22
                 ctemp = sqrt( abi12 )*sqrt( ad21 )
                 temp = abs1( ctemp )
                 if( ctemp/=zero ) then
                    x = half*( ad11-shift )
                    temp2 = abs1( x )
                    temp = max( temp, abs1( x ) )
                    y = temp*sqrt( ( x / temp )**2+( ctemp / temp )**2 )
                    if( temp2>zero ) then
                       if( real( x / temp2,KIND=dp)*real( y,KIND=dp)+aimag( x / temp2 )*aimag( y )&
                                 <zero )y = -y
                    end if
                    shift = shift - ctemp*stdlib_zladiv( ctemp, ( x+y ) )
                 end if
              else
                 ! exceptional shift.  chosen for no particularly good reason.
                 if( ( iiter / 20 )*20==iiter .and.bscale*abs1(t( ilast, ilast ))>safmin ) &
                           then
                    eshift = eshift + ( ascale*h( ilast,ilast ) )/( bscale*t( ilast, ilast ) )
                              
                 else
                    eshift = eshift + ( ascale*h( ilast,ilast-1 ) )/( bscale*t( ilast-1, ilast-1 )&
                               )
                 end if
                 shift = eshift
              end if
              ! now check for two consecutive small subdiagonals.
              do j = ilast - 1, ifirst + 1, -1
                 istart = j
                 ctemp = ascale*h( j, j ) - shift*( bscale*t( j, j ) )
                 temp = abs1( ctemp )
                 temp2 = ascale*abs1( h( j+1, j ) )
                 tempr = max( temp, temp2 )
                 if( tempr<one .and. tempr/=zero ) then
                    temp = temp / tempr
                    temp2 = temp2 / tempr
                 end if
                 if( abs1( h( j, j-1 ) )*temp2<=temp*atol )go to 90
              end do
              istart = ifirst
              ctemp = ascale*h( ifirst, ifirst ) -shift*( bscale*t( ifirst, ifirst ) )
              90 continue
              ! do an implicit-shift qz sweep.
              ! initial q
              ctemp2 = ascale*h( istart+1, istart )
              call stdlib_zlartg( ctemp, ctemp2, c, s, ctemp3 )
              ! sweep
              loop_150: do j = istart, ilast - 1
                 if( j>istart ) then
                    ctemp = h( j, j-1 )
                    call stdlib_zlartg( ctemp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                    h( j+1, j-1 ) = czero
                 end if
                 do jc = j, ilastm
                    ctemp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -conjg( s )*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = ctemp
                    ctemp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -conjg( s )*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = ctemp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       ctemp = c*q( jr, j ) + conjg( s )*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = ctemp
                    end do
                 end if
                 ctemp = t( j+1, j+1 )
                 call stdlib_zlartg( ctemp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = czero
                 do jr = ifrstm, min( j+2, ilast )
                    ctemp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -conjg( s )*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = ctemp
                 end do
                 do jr = ifrstm, j
                    ctemp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -conjg( s )*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = ctemp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       ctemp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -conjg( s )*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = ctemp
                    end do
                 end if
              end do loop_150
              160 continue
           end do loop_170
           ! drop-through = non-convergence
           180 continue
           info = ilast
           go to 210
           ! successful completion of all qz steps
           190 continue
           ! set eigenvalues 1:ilo-1
           do j = 1, ilo - 1
              absb = abs( t( j, j ) )
              if( absb>safmin ) then
                 signbc = conjg( t( j, j ) / absb )
                 t( j, j ) = absb
                 if( ilschr ) then
                    call stdlib_zscal( j-1, signbc, t( 1, j ), 1 )
                    call stdlib_zscal( j, signbc, h( 1, j ), 1 )
                 else
                    call stdlib_zscal( 1, signbc, h( j, j ), 1 )
                 end if
                 if( ilz )call stdlib_zscal( n, signbc, z( 1, j ), 1 )
              else
                 t( j, j ) = czero
              end if
              alpha( j ) = h( j, j )
              beta( j ) = t( j, j )
           end do
           ! normal termination
           info = 0
           ! exit (other than argument error) -- return optimal workspace size
           210 continue
           work( 1 ) = cmplx( n,KIND=dp)
           return
     end subroutine stdlib_zhgeqz

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module subroutine stdlib_${ci}$hgeqz( job, compq, compz, n, ilo, ihi, h, ldh, t, ldt,alpha, beta, q, ldq,&
     !! ZHGEQZ: computes the eigenvalues of a complex matrix pair (H,T),
     !! where H is an upper Hessenberg matrix and T is upper triangular,
     !! using the single-shift QZ method.
     !! Matrix pairs of this type are produced by the reduction to
     !! generalized upper Hessenberg form of a complex matrix pair (A,B):
     !! A = Q1*H*Z1**H,  B = Q1*T*Z1**H,
     !! as computed by ZGGHRD.
     !! If JOB='S', then the Hessenberg-triangular pair (H,T) is
     !! also reduced to generalized Schur form,
     !! H = Q*S*Z**H,  T = Q*P*Z**H,
     !! where Q and Z are unitary matrices and S and P are upper triangular.
     !! Optionally, the unitary matrix Q from the generalized Schur
     !! factorization may be postmultiplied into an input matrix Q1, and the
     !! unitary matrix Z may be postmultiplied into an input matrix Z1.
     !! If Q1 and Z1 are the unitary matrices from ZGGHRD that reduced
     !! the matrix pair (A,B) to generalized Hessenberg form, then the output
     !! matrices Q1*Q and Z1*Z are the unitary factors from the generalized
     !! Schur factorization of (A,B):
     !! A = (Q1*Q)*S*(Z1*Z)**H,  B = (Q1*Q)*P*(Z1*Z)**H.
     !! To avoid overflow, eigenvalues of the matrix pair (H,T)
     !! (equivalently, of (A,B)) are computed as a pair of complex values
     !! (alpha,beta).  If beta is nonzero, lambda = alpha / beta is an
     !! eigenvalue of the generalized nonsymmetric eigenvalue problem (GNEP)
     !! A*x = lambda*B*x
     !! and if alpha is nonzero, mu = beta / alpha is an eigenvalue of the
     !! alternate form of the GNEP
     !! mu*A*y = B*y.
     !! The values of alpha and beta for the i-th eigenvalue can be read
     !! directly from the generalized Schur form:  alpha = S(i,i),
     !! beta = P(i,i).
     !! Ref: C.B. Moler
     !! Eigenvalue Problems", SIAM J. Numer. Anal., 10(1973),
     !! pp. 241--256.
                z, ldz, work, lwork,rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz, job
           integer(ilp), intent(in) :: ihi, ilo, ldh, ldq, ldt, ldz, lwork, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(out) :: alpha(*), beta(*), work(*)
           complex(${ck}$), intent(inout) :: h(ldh,*), q(ldq,*), t(ldt,*), z(ldz,*)
        ! =====================================================================
           
           
           
           ! Local Scalars 
           logical(lk) :: ilazr2, ilazro, ilq, ilschr, ilz, lquery
           integer(ilp) :: icompq, icompz, ifirst, ifrstm, iiter, ilast, ilastm, in, ischur, &
                     istart, j, jc, jch, jiter, jr, maxit
           real(${ck}$) :: absb, anorm, ascale, atol, bnorm, bscale, btol, c, safmin, temp, temp2, &
                     tempr, ulp
           complex(${ck}$) :: abi22, ad11, ad12, ad21, ad22, ctemp, ctemp2, ctemp3, eshift, s, shift, &
                     signbc, u12, x, abi12, y
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=${ck}$) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode job, compq, compz
           if( stdlib_lsame( job, 'E' ) ) then
              ilschr = .false.
              ischur = 1
           else if( stdlib_lsame( job, 'S' ) ) then
              ilschr = .true.
              ischur = 2
           else
              ilschr = .true.
              ischur = 0
           end if
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              ilq = .true.
              icompq = 0
           end if
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              ilz = .true.
              icompz = 0
           end if
           ! check argument values
           info = 0
           work( 1 ) = max( 1, n )
           lquery = ( lwork==-1 )
           if( ischur==0 ) then
              info = -1
           else if( icompq==0 ) then
              info = -2
           else if( icompz==0 ) then
              info = -3
           else if( n<0 ) then
              info = -4
           else if( ilo<1 ) then
              info = -5
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -6
           else if( ldh<n ) then
              info = -8
           else if( ldt<n ) then
              info = -10
           else if( ldq<1 .or. ( ilq .and. ldq<n ) ) then
              info = -14
           else if( ldz<1 .or. ( ilz .and. ldz<n ) ) then
              info = -16
           else if( lwork<max( 1, n ) .and. .not.lquery ) then
              info = -18
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZHGEQZ', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           ! work( 1 ) = cmplx( 1,KIND=${ck}$)
           if( n<=0 ) then
              work( 1 ) = cmplx( 1,KIND=${ck}$)
              return
           end if
           ! initialize q and z
           if( icompq==3 )call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, q, ldq )
           if( icompz==3 )call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, z, ldz )
           ! machine constants
           in = ihi + 1 - ilo
           safmin = stdlib_${c2ri(ci)}$lamch( 'S' )
           ulp = stdlib_${c2ri(ci)}$lamch( 'E' )*stdlib_${c2ri(ci)}$lamch( 'B' )
           anorm = stdlib_${ci}$lanhs( 'F', in, h( ilo, ilo ), ldh, rwork )
           bnorm = stdlib_${ci}$lanhs( 'F', in, t( ilo, ilo ), ldt, rwork )
           atol = max( safmin, ulp*anorm )
           btol = max( safmin, ulp*bnorm )
           ascale = one / max( safmin, anorm )
           bscale = one / max( safmin, bnorm )
           ! set eigenvalues ihi+1:n
           do j = ihi + 1, n
              absb = abs( t( j, j ) )
              if( absb>safmin ) then
                 signbc = conjg( t( j, j ) / absb )
                 t( j, j ) = absb
                 if( ilschr ) then
                    call stdlib_${ci}$scal( j-1, signbc, t( 1, j ), 1 )
                    call stdlib_${ci}$scal( j, signbc, h( 1, j ), 1 )
                 else
                    call stdlib_${ci}$scal( 1, signbc, h( j, j ), 1 )
                 end if
                 if( ilz )call stdlib_${ci}$scal( n, signbc, z( 1, j ), 1 )
              else
                 t( j, j ) = czero
              end if
              alpha( j ) = h( j, j )
              beta( j ) = t( j, j )
           end do
           ! if ihi < ilo, skip qz steps
           if( ihi<ilo )go to 190
           ! main qz iteration loop
           ! initialize dynamic indices
           ! eigenvalues ilast+1:n have been found.
              ! column operations modify rows ifrstm:whatever
              ! row operations modify columns whatever:ilastm
           ! if only eigenvalues are being computed, then
              ! ifrstm is the row of the last splitting row above row ilast;
              ! this is always at least ilo.
           ! iiter counts iterations since the last eigenvalue was found,
              ! to tell when to use an extraordinary shift.
           ! maxit is the maximum number of qz sweeps allowed.
           ilast = ihi
           if( ilschr ) then
              ifrstm = 1
              ilastm = n
           else
              ifrstm = ilo
              ilastm = ihi
           end if
           iiter = 0
           eshift = czero
           maxit = 30*( ihi-ilo+1 )
           loop_170: do jiter = 1, maxit
              ! check for too many iterations.
              if( jiter>maxit )go to 180
              ! split the matrix if possible.
              ! two tests:
                 ! 1: h(j,j-1)=0  or  j=ilo
                 ! 2: t(j,j)=0
              ! special case: j=ilast
              if( ilast==ilo ) then
                 go to 60
              else
                 if( abs1( h( ilast, ilast-1 ) )<=max( safmin, ulp*(abs1( h( ilast, ilast ) ) + &
                           abs1( h( ilast-1, ilast-1 )) ) ) ) then
                    h( ilast, ilast-1 ) = czero
                    go to 60
                 end if
              end if
              if( abs( t( ilast, ilast ) )<=max( safmin, ulp*(abs( t( ilast - 1, ilast ) ) + abs( &
                        t( ilast-1, ilast-1 )) ) ) ) then
                 t( ilast, ilast ) = czero
                 go to 50
              end if
              ! general case: j<ilast
              loop_40: do j = ilast - 1, ilo, -1
                 ! test 1: for h(j,j-1)=0 or j=ilo
                 if( j==ilo ) then
                    ilazro = .true.
                 else
                    if( abs1( h( j, j-1 ) )<=max( safmin, ulp*(abs1( h( j, j ) ) + abs1( h( j-1, &
                              j-1 ) )) ) ) then
                       h( j, j-1 ) = czero
                       ilazro = .true.
                    else
                       ilazro = .false.
                    end if
                 end if
                 ! test 2: for t(j,j)=0
                 temp = abs ( t( j, j + 1 ) )
                 if ( j > ilo )temp = temp + abs ( t( j - 1, j ) )
                 if( abs( t( j, j ) )<max( safmin,ulp*temp ) ) then
                    t( j, j ) = czero
                    ! test 1a: check for 2 consecutive small subdiagonals in a
                    ilazr2 = .false.
                    if( .not.ilazro ) then
                       if( abs1( h( j, j-1 ) )*( ascale*abs1( h( j+1,j ) ) )<=abs1( h( j, j ) )*( &
                                 ascale*atol ) )ilazr2 = .true.
                    end if
                    ! if both tests pass (1
                    ! element of b in the block is zero, split a 1x1 block off
                    ! at the top. (i.e., at the j-th row/column) the leading
                    ! diagonal element of the remainder can also be zero, so
                    ! this may have to be done repeatedly.
                    if( ilazro .or. ilazr2 ) then
                       do jch = j, ilast - 1
                          ctemp = h( jch, jch )
                          call stdlib_${ci}$lartg( ctemp, h( jch+1, jch ), c, s,h( jch, jch ) )
                          h( jch+1, jch ) = czero
                          call stdlib_${ci}$rot( ilastm-jch, h( jch, jch+1 ), ldh,h( jch+1, jch+1 ), &
                                    ldh, c, s )
                          call stdlib_${ci}$rot( ilastm-jch, t( jch, jch+1 ), ldt,t( jch+1, jch+1 ), &
                                    ldt, c, s )
                          if( ilq )call stdlib_${ci}$rot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, conjg(&
                                     s ) )
                          if( ilazr2 )h( jch, jch-1 ) = h( jch, jch-1 )*c
                          ilazr2 = .false.
                          if( abs1( t( jch+1, jch+1 ) )>=btol ) then
                             if( jch+1>=ilast ) then
                                go to 60
                             else
                                ifirst = jch + 1
                                go to 70
                             end if
                          end if
                          t( jch+1, jch+1 ) = czero
                       end do
                       go to 50
                    else
                       ! only test 2 passed -- chase the zero to t(ilast,ilast)
                       ! then process as in the case t(ilast,ilast)=0
                       do jch = j, ilast - 1
                          ctemp = t( jch, jch+1 )
                          call stdlib_${ci}$lartg( ctemp, t( jch+1, jch+1 ), c, s,t( jch, jch+1 ) )
                                    
                          t( jch+1, jch+1 ) = czero
                          if( jch<ilastm-1 )call stdlib_${ci}$rot( ilastm-jch-1, t( jch, jch+2 ), ldt,&
                                    t( jch+1, jch+2 ), ldt, c, s )
                          call stdlib_${ci}$rot( ilastm-jch+2, h( jch, jch-1 ), ldh,h( jch+1, jch-1 ), &
                                    ldh, c, s )
                          if( ilq )call stdlib_${ci}$rot( n, q( 1, jch ), 1, q( 1, jch+1 ), 1,c, conjg(&
                                     s ) )
                          ctemp = h( jch+1, jch )
                          call stdlib_${ci}$lartg( ctemp, h( jch+1, jch-1 ), c, s,h( jch+1, jch ) )
                                    
                          h( jch+1, jch-1 ) = czero
                          call stdlib_${ci}$rot( jch+1-ifrstm, h( ifrstm, jch ), 1,h( ifrstm, jch-1 ), &
                                    1, c, s )
                          call stdlib_${ci}$rot( jch-ifrstm, t( ifrstm, jch ), 1,t( ifrstm, jch-1 ), 1,&
                                     c, s )
                          if( ilz )call stdlib_${ci}$rot( n, z( 1, jch ), 1, z( 1, jch-1 ), 1,c, s )
                                    
                       end do
                       go to 50
                    end if
                 else if( ilazro ) then
                    ! only test 1 passed -- work on j:ilast
                    ifirst = j
                    go to 70
                 end if
                 ! neither test passed -- try next j
              end do loop_40
              ! (drop-through is "impossible")
              info = 2*n + 1
              go to 210
              ! t(ilast,ilast)=0 -- clear h(ilast,ilast-1) to split off a
              ! 1x1 block.
              50 continue
              ctemp = h( ilast, ilast )
              call stdlib_${ci}$lartg( ctemp, h( ilast, ilast-1 ), c, s,h( ilast, ilast ) )
              h( ilast, ilast-1 ) = czero
              call stdlib_${ci}$rot( ilast-ifrstm, h( ifrstm, ilast ), 1,h( ifrstm, ilast-1 ), 1, c, s &
                        )
              call stdlib_${ci}$rot( ilast-ifrstm, t( ifrstm, ilast ), 1,t( ifrstm, ilast-1 ), 1, c, s &
                        )
              if( ilz )call stdlib_${ci}$rot( n, z( 1, ilast ), 1, z( 1, ilast-1 ), 1, c, s )
              ! h(ilast,ilast-1)=0 -- standardize b, set alpha and beta
              60 continue
              absb = abs( t( ilast, ilast ) )
              if( absb>safmin ) then
                 signbc = conjg( t( ilast, ilast ) / absb )
                 t( ilast, ilast ) = absb
                 if( ilschr ) then
                    call stdlib_${ci}$scal( ilast-ifrstm, signbc, t( ifrstm, ilast ), 1 )
                    call stdlib_${ci}$scal( ilast+1-ifrstm, signbc, h( ifrstm, ilast ),1 )
                 else
                    call stdlib_${ci}$scal( 1, signbc, h( ilast, ilast ), 1 )
                 end if
                 if( ilz )call stdlib_${ci}$scal( n, signbc, z( 1, ilast ), 1 )
              else
                 t( ilast, ilast ) = czero
              end if
              alpha( ilast ) = h( ilast, ilast )
              beta( ilast ) = t( ilast, ilast )
              ! go to next block -- exit if finished.
              ilast = ilast - 1
              if( ilast<ilo )go to 190
              ! reset counters
              iiter = 0
              eshift = czero
              if( .not.ilschr ) then
                 ilastm = ilast
                 if( ifrstm>ilast )ifrstm = ilo
              end if
              go to 160
              ! qz step
              ! this iteration only involves rows/columns ifirst:ilast.  we
              ! assume ifirst < ilast, and that the diagonal of b is non-zero.
              70 continue
              iiter = iiter + 1
              if( .not.ilschr ) then
                 ifrstm = ifirst
              end if
              ! compute the shift.
              ! at this point, ifirst < ilast, and the diagonal elements of
              ! t(ifirst:ilast,ifirst,ilast) are larger than btol (in
              ! magnitude)
              if( ( iiter / 10 )*10/=iiter ) then
                 ! the wilkinson shift (aep p.512_${ck}$), i.e., the eigenvalue of
                 ! the bottom-right 2x2 block of a inv(b) which is nearest to
                 ! the bottom-right element.
                 ! we factor b as u*d, where u has unit diagonals, and
                 ! compute (a*inv(d))*inv(u).
                 u12 = ( bscale*t( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad11 = ( ascale*h( ilast-1, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad21 = ( ascale*h( ilast, ilast-1 ) ) /( bscale*t( ilast-1, ilast-1 ) )
                 ad12 = ( ascale*h( ilast-1, ilast ) ) /( bscale*t( ilast, ilast ) )
                 ad22 = ( ascale*h( ilast, ilast ) ) /( bscale*t( ilast, ilast ) )
                 abi22 = ad22 - u12*ad21
                 abi12 = ad12 - u12*ad11
                 shift = abi22
                 ctemp = sqrt( abi12 )*sqrt( ad21 )
                 temp = abs1( ctemp )
                 if( ctemp/=zero ) then
                    x = half*( ad11-shift )
                    temp2 = abs1( x )
                    temp = max( temp, abs1( x ) )
                    y = temp*sqrt( ( x / temp )**2+( ctemp / temp )**2 )
                    if( temp2>zero ) then
                       if( real( x / temp2,KIND=${ck}$)*real( y,KIND=${ck}$)+aimag( x / temp2 )*aimag( y )&
                                 <zero )y = -y
                    end if
                    shift = shift - ctemp*stdlib_${ci}$ladiv( ctemp, ( x+y ) )
                 end if
              else
                 ! exceptional shift.  chosen for no particularly good reason.
                 if( ( iiter / 20 )*20==iiter .and.bscale*abs1(t( ilast, ilast ))>safmin ) &
                           then
                    eshift = eshift + ( ascale*h( ilast,ilast ) )/( bscale*t( ilast, ilast ) )
                              
                 else
                    eshift = eshift + ( ascale*h( ilast,ilast-1 ) )/( bscale*t( ilast-1, ilast-1 )&
                               )
                 end if
                 shift = eshift
              end if
              ! now check for two consecutive small subdiagonals.
              do j = ilast - 1, ifirst + 1, -1
                 istart = j
                 ctemp = ascale*h( j, j ) - shift*( bscale*t( j, j ) )
                 temp = abs1( ctemp )
                 temp2 = ascale*abs1( h( j+1, j ) )
                 tempr = max( temp, temp2 )
                 if( tempr<one .and. tempr/=zero ) then
                    temp = temp / tempr
                    temp2 = temp2 / tempr
                 end if
                 if( abs1( h( j, j-1 ) )*temp2<=temp*atol )go to 90
              end do
              istart = ifirst
              ctemp = ascale*h( ifirst, ifirst ) -shift*( bscale*t( ifirst, ifirst ) )
              90 continue
              ! do an implicit-shift qz sweep.
              ! initial q
              ctemp2 = ascale*h( istart+1, istart )
              call stdlib_${ci}$lartg( ctemp, ctemp2, c, s, ctemp3 )
              ! sweep
              loop_150: do j = istart, ilast - 1
                 if( j>istart ) then
                    ctemp = h( j, j-1 )
                    call stdlib_${ci}$lartg( ctemp, h( j+1, j-1 ), c, s, h( j, j-1 ) )
                    h( j+1, j-1 ) = czero
                 end if
                 do jc = j, ilastm
                    ctemp = c*h( j, jc ) + s*h( j+1, jc )
                    h( j+1, jc ) = -conjg( s )*h( j, jc ) + c*h( j+1, jc )
                    h( j, jc ) = ctemp
                    ctemp2 = c*t( j, jc ) + s*t( j+1, jc )
                    t( j+1, jc ) = -conjg( s )*t( j, jc ) + c*t( j+1, jc )
                    t( j, jc ) = ctemp2
                 end do
                 if( ilq ) then
                    do jr = 1, n
                       ctemp = c*q( jr, j ) + conjg( s )*q( jr, j+1 )
                       q( jr, j+1 ) = -s*q( jr, j ) + c*q( jr, j+1 )
                       q( jr, j ) = ctemp
                    end do
                 end if
                 ctemp = t( j+1, j+1 )
                 call stdlib_${ci}$lartg( ctemp, t( j+1, j ), c, s, t( j+1, j+1 ) )
                 t( j+1, j ) = czero
                 do jr = ifrstm, min( j+2, ilast )
                    ctemp = c*h( jr, j+1 ) + s*h( jr, j )
                    h( jr, j ) = -conjg( s )*h( jr, j+1 ) + c*h( jr, j )
                    h( jr, j+1 ) = ctemp
                 end do
                 do jr = ifrstm, j
                    ctemp = c*t( jr, j+1 ) + s*t( jr, j )
                    t( jr, j ) = -conjg( s )*t( jr, j+1 ) + c*t( jr, j )
                    t( jr, j+1 ) = ctemp
                 end do
                 if( ilz ) then
                    do jr = 1, n
                       ctemp = c*z( jr, j+1 ) + s*z( jr, j )
                       z( jr, j ) = -conjg( s )*z( jr, j+1 ) + c*z( jr, j )
                       z( jr, j+1 ) = ctemp
                    end do
                 end if
              end do loop_150
              160 continue
           end do loop_170
           ! drop-through = non-convergence
           180 continue
           info = ilast
           go to 210
           ! successful completion of all qz steps
           190 continue
           ! set eigenvalues 1:ilo-1
           do j = 1, ilo - 1
              absb = abs( t( j, j ) )
              if( absb>safmin ) then
                 signbc = conjg( t( j, j ) / absb )
                 t( j, j ) = absb
                 if( ilschr ) then
                    call stdlib_${ci}$scal( j-1, signbc, t( 1, j ), 1 )
                    call stdlib_${ci}$scal( j, signbc, h( 1, j ), 1 )
                 else
                    call stdlib_${ci}$scal( 1, signbc, h( j, j ), 1 )
                 end if
                 if( ilz )call stdlib_${ci}$scal( n, signbc, z( 1, j ), 1 )
              else
                 t( j, j ) = czero
              end if
              alpha( j ) = h( j, j )
              beta( j ) = t( j, j )
           end do
           ! normal termination
           info = 0
           ! exit (other than argument error) -- return optimal workspace size
           210 continue
           work( 1 ) = cmplx( n,KIND=${ck}$)
           return
     end subroutine stdlib_${ci}$hgeqz

#:endif
#:endfor



     module pure subroutine stdlib_stgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
     !! STGEXC reorders the generalized real Schur decomposition of a real
     !! matrix pair (A,B) using an orthogonal equivalence transformation
     !! (A, B) = Q * (A, B) * Z**T,
     !! so that the diagonal block of (A, B) with row index IFST is moved
     !! to row ILST.
     !! (A, B) must be in generalized real Schur canonical form (as returned
     !! by SGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
     !! diagonal blocks. B is upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
     !! Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(inout) :: ifst, ilst
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldq, ldz, lwork, n
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: here, lwmin, nbf, nbl, nbnext
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input arguments.
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldq<1 .or. wantq .and. ( ldq<max( 1, n ) ) ) then
              info = -9
           else if( ldz<1 .or. wantz .and. ( ldz<max( 1, n ) ) ) then
              info = -11
           else if( ifst<1 .or. ifst>n ) then
              info = -12
           else if( ilst<1 .or. ilst>n ) then
              info = -13
           end if
           if( info==0 ) then
              if( n<=1 ) then
                 lwmin = 1
              else
                 lwmin = 4*n + 16
              end if
              work(1) = lwmin
              if (lwork<lwmin .and. .not.lquery) then
                 info = -15
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STGEXC', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           ! determine the first row of the specified block and find out
           ! if it is 1-by-1 or 2-by-2.
           if( ifst>1 ) then
              if( a( ifst, ifst-1 )/=zero )ifst = ifst - 1
           end if
           nbf = 1
           if( ifst<n ) then
              if( a( ifst+1, ifst )/=zero )nbf = 2
           end if
           ! determine the first row of the final block
           ! and find out if it is 1-by-1 or 2-by-2.
           if( ilst>1 ) then
              if( a( ilst, ilst-1 )/=zero )ilst = ilst - 1
           end if
           nbl = 1
           if( ilst<n ) then
              if( a( ilst+1, ilst )/=zero )nbl = 2
           end if
           if( ifst==ilst )return
           if( ifst<ilst ) then
              ! update ilst.
              if( nbf==2 .and. nbl==1 )ilst = ilst - 1
              if( nbf==1 .and. nbl==2 )ilst = ilst + 1
              here = ifst
              10 continue
              ! swap with next one below.
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1-by-1 or 2-by-2.
                 nbnext = 1
                 if( here+nbf+1<=n ) then
                    if( a( here+nbf+1, here+nbf )/=zero )nbnext = 2
                 end if
                 call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, nbf, &
                           nbnext, work, lwork, info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here + nbnext
                 ! test if 2-by-2 block breaks into two 1-by-1 blocks.
                 if( nbf==2 ) then
                    if( a( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1-by-1 blocks, each of which
                 ! must be swapped individually.
                 nbnext = 1
                 if( here+3<=n ) then
                    if( a( here+3, here+2 )/=zero )nbnext = 2
                 end if
                 call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here+1, 1, &
                           nbnext, work, lwork, info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1-by-1 blocks.
                    call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, 1, &
                              1, work, lwork, info )
                    if( info/=0 ) then
                       ilst = here
                       return
                    end if
                    here = here + 1
                 else
                    ! recompute nbnext in case of 2-by-2 split.
                    if( a( here+2, here+1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2-by-2 block did not split.
                       call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, nbnext, work, lwork,info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 2
                    else
                       ! 2-by-2 block did split.
                       call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 1
                       call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 1
                    end if
                 end if
              end if
              if( here<ilst )go to 10
           else
              here = ifst
              20 continue
              ! swap with next one below.
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1-by-1 or 2-by-2.
                 nbnext = 1
                 if( here>=3 ) then
                    if( a( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here-nbnext, &
                           nbnext, nbf, work, lwork,info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here - nbnext
                 ! test if 2-by-2 block breaks into two 1-by-1 blocks.
                 if( nbf==2 ) then
                    if( a( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1-by-1 blocks, each of which
                 ! must be swapped individually.
                 nbnext = 1
                 if( here>=3 ) then
                    if( a( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here-nbnext, &
                           nbnext, 1, work, lwork,info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1-by-1 blocks.
                    call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, &
                              nbnext, 1, work, lwork, info )
                    if( info/=0 ) then
                       ilst = here
                       return
                    end if
                    here = here - 1
                 else
                   ! recompute nbnext in case of 2-by-2 split.
                    if( a( here, here-1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2-by-2 block did not split.
                       call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here-1,&
                                  2, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 2
                    else
                       ! 2-by-2 block did split.
                       call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 1
                       call stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 1
                    end if
                 end if
              end if
              if( here>ilst )go to 20
           end if
           ilst = here
           work( 1 ) = lwmin
           return
     end subroutine stdlib_stgexc

     module pure subroutine stdlib_dtgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
     !! DTGEXC reorders the generalized real Schur decomposition of a real
     !! matrix pair (A,B) using an orthogonal equivalence transformation
     !! (A, B) = Q * (A, B) * Z**T,
     !! so that the diagonal block of (A, B) with row index IFST is moved
     !! to row ILST.
     !! (A, B) must be in generalized real Schur canonical form (as returned
     !! by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
     !! diagonal blocks. B is upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
     !! Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(inout) :: ifst, ilst
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldq, ldz, lwork, n
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: here, lwmin, nbf, nbl, nbnext
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input arguments.
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldq<1 .or. wantq .and. ( ldq<max( 1, n ) ) ) then
              info = -9
           else if( ldz<1 .or. wantz .and. ( ldz<max( 1, n ) ) ) then
              info = -11
           else if( ifst<1 .or. ifst>n ) then
              info = -12
           else if( ilst<1 .or. ilst>n ) then
              info = -13
           end if
           if( info==0 ) then
              if( n<=1 ) then
                 lwmin = 1
              else
                 lwmin = 4*n + 16
              end if
              work(1) = lwmin
              if (lwork<lwmin .and. .not.lquery) then
                 info = -15
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGEXC', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           ! determine the first row of the specified block and find out
           ! if it is 1-by-1 or 2-by-2.
           if( ifst>1 ) then
              if( a( ifst, ifst-1 )/=zero )ifst = ifst - 1
           end if
           nbf = 1
           if( ifst<n ) then
              if( a( ifst+1, ifst )/=zero )nbf = 2
           end if
           ! determine the first row of the final block
           ! and find out if it is 1-by-1 or 2-by-2.
           if( ilst>1 ) then
              if( a( ilst, ilst-1 )/=zero )ilst = ilst - 1
           end if
           nbl = 1
           if( ilst<n ) then
              if( a( ilst+1, ilst )/=zero )nbl = 2
           end if
           if( ifst==ilst )return
           if( ifst<ilst ) then
              ! update ilst.
              if( nbf==2 .and. nbl==1 )ilst = ilst - 1
              if( nbf==1 .and. nbl==2 )ilst = ilst + 1
              here = ifst
              10 continue
              ! swap with next one below.
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1-by-1 or 2-by-2.
                 nbnext = 1
                 if( here+nbf+1<=n ) then
                    if( a( here+nbf+1, here+nbf )/=zero )nbnext = 2
                 end if
                 call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, nbf, &
                           nbnext, work, lwork, info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here + nbnext
                 ! test if 2-by-2 block breaks into two 1-by-1 blocks.
                 if( nbf==2 ) then
                    if( a( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1-by-1 blocks, each of which
                 ! must be swapped individually.
                 nbnext = 1
                 if( here+3<=n ) then
                    if( a( here+3, here+2 )/=zero )nbnext = 2
                 end if
                 call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here+1, 1, &
                           nbnext, work, lwork, info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1-by-1 blocks.
                    call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, 1, &
                              1, work, lwork, info )
                    if( info/=0 ) then
                       ilst = here
                       return
                    end if
                    here = here + 1
                 else
                    ! recompute nbnext in case of 2-by-2 split.
                    if( a( here+2, here+1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2-by-2 block did not split.
                       call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, nbnext, work, lwork,info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 2
                    else
                       ! 2-by-2 block did split.
                       call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 1
                       call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 1
                    end if
                 end if
              end if
              if( here<ilst )go to 10
           else
              here = ifst
              20 continue
              ! swap with next one below.
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1-by-1 or 2-by-2.
                 nbnext = 1
                 if( here>=3 ) then
                    if( a( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here-nbnext, &
                           nbnext, nbf, work, lwork,info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here - nbnext
                 ! test if 2-by-2 block breaks into two 1-by-1 blocks.
                 if( nbf==2 ) then
                    if( a( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1-by-1 blocks, each of which
                 ! must be swapped individually.
                 nbnext = 1
                 if( here>=3 ) then
                    if( a( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here-nbnext, &
                           nbnext, 1, work, lwork,info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1-by-1 blocks.
                    call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, &
                              nbnext, 1, work, lwork, info )
                    if( info/=0 ) then
                       ilst = here
                       return
                    end if
                    here = here - 1
                 else
                   ! recompute nbnext in case of 2-by-2 split.
                    if( a( here, here-1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2-by-2 block did not split.
                       call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here-1,&
                                  2, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 2
                    else
                       ! 2-by-2 block did split.
                       call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 1
                       call stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 1
                    end if
                 end if
              end if
              if( here>ilst )go to 20
           end if
           ilst = here
           work( 1 ) = lwmin
           return
     end subroutine stdlib_dtgexc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$tgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
     !! DTGEXC: reorders the generalized real Schur decomposition of a real
     !! matrix pair (A,B) using an orthogonal equivalence transformation
     !! (A, B) = Q * (A, B) * Z**T,
     !! so that the diagonal block of (A, B) with row index IFST is moved
     !! to row ILST.
     !! (A, B) must be in generalized real Schur canonical form (as returned
     !! by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
     !! diagonal blocks. B is upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
     !! Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(inout) :: ifst, ilst
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: lda, ldb, ldq, ldz, lwork, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: lquery
           integer(ilp) :: here, lwmin, nbf, nbl, nbnext
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input arguments.
           info = 0
           lquery = ( lwork==-1 )
           if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldq<1 .or. wantq .and. ( ldq<max( 1, n ) ) ) then
              info = -9
           else if( ldz<1 .or. wantz .and. ( ldz<max( 1, n ) ) ) then
              info = -11
           else if( ifst<1 .or. ifst>n ) then
              info = -12
           else if( ilst<1 .or. ilst>n ) then
              info = -13
           end if
           if( info==0 ) then
              if( n<=1 ) then
                 lwmin = 1
              else
                 lwmin = 4*n + 16
              end if
              work(1) = lwmin
              if (lwork<lwmin .and. .not.lquery) then
                 info = -15
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGEXC', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           ! determine the first row of the specified block and find out
           ! if it is 1-by-1 or 2-by-2.
           if( ifst>1 ) then
              if( a( ifst, ifst-1 )/=zero )ifst = ifst - 1
           end if
           nbf = 1
           if( ifst<n ) then
              if( a( ifst+1, ifst )/=zero )nbf = 2
           end if
           ! determine the first row of the final block
           ! and find out if it is 1-by-1 or 2-by-2.
           if( ilst>1 ) then
              if( a( ilst, ilst-1 )/=zero )ilst = ilst - 1
           end if
           nbl = 1
           if( ilst<n ) then
              if( a( ilst+1, ilst )/=zero )nbl = 2
           end if
           if( ifst==ilst )return
           if( ifst<ilst ) then
              ! update ilst.
              if( nbf==2 .and. nbl==1 )ilst = ilst - 1
              if( nbf==1 .and. nbl==2 )ilst = ilst + 1
              here = ifst
              10 continue
              ! swap with next one below.
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1-by-1 or 2-by-2.
                 nbnext = 1
                 if( here+nbf+1<=n ) then
                    if( a( here+nbf+1, here+nbf )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, nbf, &
                           nbnext, work, lwork, info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here + nbnext
                 ! test if 2-by-2 block breaks into two 1-by-1 blocks.
                 if( nbf==2 ) then
                    if( a( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1-by-1 blocks, each of which
                 ! must be swapped individually.
                 nbnext = 1
                 if( here+3<=n ) then
                    if( a( here+3, here+2 )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here+1, 1, &
                           nbnext, work, lwork, info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1-by-1 blocks.
                    call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, 1, &
                              1, work, lwork, info )
                    if( info/=0 ) then
                       ilst = here
                       return
                    end if
                    here = here + 1
                 else
                    ! recompute nbnext in case of 2-by-2 split.
                    if( a( here+2, here+1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2-by-2 block did not split.
                       call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, nbnext, work, lwork,info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 2
                    else
                       ! 2-by-2 block did split.
                       call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 1
                       call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here + 1
                    end if
                 end if
              end if
              if( here<ilst )go to 10
           else
              here = ifst
              20 continue
              ! swap with next one below.
              if( nbf==1 .or. nbf==2 ) then
                 ! current block either 1-by-1 or 2-by-2.
                 nbnext = 1
                 if( here>=3 ) then
                    if( a( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here-nbnext, &
                           nbnext, nbf, work, lwork,info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 here = here - nbnext
                 ! test if 2-by-2 block breaks into two 1-by-1 blocks.
                 if( nbf==2 ) then
                    if( a( here+1, here )==zero )nbf = 3
                 end if
              else
                 ! current block consists of two 1-by-1 blocks, each of which
                 ! must be swapped individually.
                 nbnext = 1
                 if( here>=3 ) then
                    if( a( here-1, here-2 )/=zero )nbnext = 2
                 end if
                 call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here-nbnext, &
                           nbnext, 1, work, lwork,info )
                 if( info/=0 ) then
                    ilst = here
                    return
                 end if
                 if( nbnext==1 ) then
                    ! swap two 1-by-1 blocks.
                    call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, here, &
                              nbnext, 1, work, lwork, info )
                    if( info/=0 ) then
                       ilst = here
                       return
                    end if
                    here = here - 1
                 else
                   ! recompute nbnext in case of 2-by-2 split.
                    if( a( here, here-1 )==zero )nbnext = 1
                    if( nbnext==2 ) then
                       ! 2-by-2 block did not split.
                       call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here-1,&
                                  2, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 2
                    else
                       ! 2-by-2 block did split.
                       call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 1
                       call stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz, here, &
                                 1, 1, work, lwork, info )
                       if( info/=0 ) then
                          ilst = here
                          return
                       end if
                       here = here - 1
                    end if
                 end if
              end if
              if( here>ilst )go to 20
           end if
           ilst = here
           work( 1 ) = lwmin
           return
     end subroutine stdlib_${ri}$tgexc

#:endif
#:endfor

     module pure subroutine stdlib_ctgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
     !! CTGEXC reorders the generalized Schur decomposition of a complex
     !! matrix pair (A,B), using an unitary equivalence transformation
     !! (A, B) := Q * (A, B) * Z**H, so that the diagonal block of (A, B) with
     !! row index IFST is moved to row ILST.
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
     !! Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ifst, lda, ldb, ldq, ldz, n
           integer(ilp), intent(inout) :: ilst
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: here
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input arguments.
           info = 0
           if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldq<1 .or. wantq .and. ( ldq<max( 1, n ) ) ) then
              info = -9
           else if( ldz<1 .or. wantz .and. ( ldz<max( 1, n ) ) ) then
              info = -11
           else if( ifst<1 .or. ifst>n ) then
              info = -12
           else if( ilst<1 .or. ilst>n ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGEXC', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           if( ifst==ilst )return
           if( ifst<ilst ) then
              here = ifst
              10 continue
              ! swap with next one below
              call stdlib_ctgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz,here, info )
                        
              if( info/=0 ) then
                 ilst = here
                 return
              end if
              here = here + 1
              if( here<ilst )go to 10
              here = here - 1
           else
              here = ifst - 1
              20 continue
              ! swap with next one above
              call stdlib_ctgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz,here, info )
                        
              if( info/=0 ) then
                 ilst = here
                 return
              end if
              here = here - 1
              if( here>=ilst )go to 20
              here = here + 1
           end if
           ilst = here
           return
     end subroutine stdlib_ctgexc

     module pure subroutine stdlib_ztgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
     !! ZTGEXC reorders the generalized Schur decomposition of a complex
     !! matrix pair (A,B), using an unitary equivalence transformation
     !! (A, B) := Q * (A, B) * Z**H, so that the diagonal block of (A, B) with
     !! row index IFST is moved to row ILST.
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
     !! Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ifst, lda, ldb, ldq, ldz, n
           integer(ilp), intent(inout) :: ilst
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: here
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input arguments.
           info = 0
           if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldq<1 .or. wantq .and. ( ldq<max( 1, n ) ) ) then
              info = -9
           else if( ldz<1 .or. wantz .and. ( ldz<max( 1, n ) ) ) then
              info = -11
           else if( ifst<1 .or. ifst>n ) then
              info = -12
           else if( ilst<1 .or. ilst>n ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGEXC', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           if( ifst==ilst )return
           if( ifst<ilst ) then
              here = ifst
              10 continue
              ! swap with next one below
              call stdlib_ztgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz,here, info )
                        
              if( info/=0 ) then
                 ilst = here
                 return
              end if
              here = here + 1
              if( here<ilst )go to 10
              here = here - 1
           else
              here = ifst - 1
              20 continue
              ! swap with next one above
              call stdlib_ztgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz,here, info )
                        
              if( info/=0 ) then
                 ilst = here
                 return
              end if
              here = here - 1
              if( here>=ilst )go to 20
              here = here + 1
           end if
           ilst = here
           return
     end subroutine stdlib_ztgexc

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$tgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, ifst, ilst, &
     !! ZTGEXC: reorders the generalized Schur decomposition of a complex
     !! matrix pair (A,B), using an unitary equivalence transformation
     !! (A, B) := Q * (A, B) * Z**H, so that the diagonal block of (A, B) with
     !! row index IFST is moved to row ILST.
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
     !! Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ifst, lda, ldb, ldq, ldz, n
           integer(ilp), intent(inout) :: ilst
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           ! Local Scalars 
           integer(ilp) :: here
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input arguments.
           info = 0
           if( n<0 ) then
              info = -3
           else if( lda<max( 1, n ) ) then
              info = -5
           else if( ldb<max( 1, n ) ) then
              info = -7
           else if( ldq<1 .or. wantq .and. ( ldq<max( 1, n ) ) ) then
              info = -9
           else if( ldz<1 .or. wantz .and. ( ldz<max( 1, n ) ) ) then
              info = -11
           else if( ifst<1 .or. ifst>n ) then
              info = -12
           else if( ilst<1 .or. ilst>n ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGEXC', -info )
              return
           end if
           ! quick return if possible
           if( n<=1 )return
           if( ifst==ilst )return
           if( ifst<ilst ) then
              here = ifst
              10 continue
              ! swap with next one below
              call stdlib_${ci}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz,here, info )
                        
              if( info/=0 ) then
                 ilst = here
                 return
              end if
              here = here + 1
              if( here<ilst )go to 10
              here = here - 1
           else
              here = ifst - 1
              20 continue
              ! swap with next one above
              call stdlib_${ci}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z, ldz,here, info )
                        
              if( info/=0 ) then
                 ilst = here
                 return
              end if
              here = here - 1
              if( here>=ilst )go to 20
              here = here + 1
           end if
           ilst = here
           return
     end subroutine stdlib_${ci}$tgexc

#:endif
#:endfor



     module pure subroutine stdlib_stgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! STGSYL solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C                 (1)
     !! D * R - L * E = scale * F
     !! where R and L are unknown m-by-n matrices, (A, D), (B, E) and
     !! (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
     !! respectively, with real entries. (A, D) and (B, E) must be in
     !! generalized (real) Schur canonical form, i.e. A, B are upper quasi
     !! triangular and D, E are upper triangular.
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
     !! scaling factor chosen to avoid overflow.
     !! In matrix notation (1) is equivalent to solve  Zx = scale b, where
     !! Z is defined as
     !! Z = [ kron(In, A)  -kron(B**T, Im) ]         (2)
     !! [ kron(In, D)  -kron(E**T, Im) ].
     !! Here Ik is the identity matrix of size k and X**T is the transpose of
     !! X. kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! If TRANS = 'T', STGSYL solves the transposed system Z**T*y = scale*b,
     !! which is equivalent to solve for R and L in
     !! A**T * R + D**T * L = scale * C           (3)
     !! R * B**T + L * E**T = scale * -F
     !! This case (TRANS = 'T') is used to compute an one-norm-based estimate
     !! of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
     !! and (B,E), using SLACON.
     !! If IJOB >= 1, STGSYL computes a Frobenius norm-based estimate
     !! of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
     !! reciprocal of the smallest singular value of Z. See [1-2] for more
     !! information.
     !! This is a level 3 BLAS algorithm.
               ldf, scale, dif, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(ilp), intent(out) :: info
           real(sp), intent(out) :: dif, scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(sp), intent(inout) :: c(ldc,*), f(ldf,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_scopy by calls to stdlib_slaset.
        ! sven hammarling, 1/5/02.
           
           ! Local Scalars 
           logical(lk) :: lquery, notran
           integer(ilp) :: i, ie, ifunc, iround, is, isolve, j, je, js, k, linfo, lwmin, mb, nb, &
                     p, ppqq, pq, q
           real(sp) :: dscale, dsum, scale2, scaloc
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>4 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info==0 ) then
              if( notran ) then
                 if( ijob==1 .or. ijob==2 ) then
                    lwmin = max( 1, 2*m*n )
                 else
                    lwmin = 1
                 end if
              else
                 lwmin = 1
              end if
              work( 1 ) = lwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STGSYL', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              scale = 1
              if( notran ) then
                 if( ijob/=0 ) then
                    dif = 0
                 end if
              end if
              return
           end if
           ! determine optimal block sizes mb and nb
           mb = stdlib_ilaenv( 2, 'STGSYL', trans, m, n, -1, -1 )
           nb = stdlib_ilaenv( 5, 'STGSYL', trans, m, n, -1, -1 )
           isolve = 1
           ifunc = 0
           if( notran ) then
              if( ijob>=3 ) then
                 ifunc = ijob - 2
                 call stdlib_slaset( 'F', m, n, zero, zero, c, ldc )
                 call stdlib_slaset( 'F', m, n, zero, zero, f, ldf )
              else if( ijob>=1 .and. notran ) then
                 isolve = 2
              end if
           end if
           if( ( mb<=1 .and. nb<=1 ) .or. ( mb>=m .and. nb>=n ) )then
              loop_30: do iround = 1, isolve
                 ! use unblocked level 2 solver
                 dscale = zero
                 dsum = one
                 pq = 0
                 call stdlib_stgsy2( trans, ifunc, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f,&
                            ldf, scale, dsum, dscale,iwork, pq, info )
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_slacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_slacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_slaset( 'F', m, n, zero, zero, c, ldc )
                    call stdlib_slaset( 'F', m, n, zero, zero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_slacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_slacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_30
              return
           end if
           ! determine block structure of a
           p = 0
           i = 1
           40 continue
           if( i>m )go to 50
           p = p + 1
           iwork( p ) = i
           i = i + mb
           if( i>=m )go to 50
           if( a( i, i-1 )/=zero )i = i + 1
           go to 40
           50 continue
           iwork( p+1 ) = m + 1
           if( iwork( p )==iwork( p+1 ) )p = p - 1
           ! determine block structure of b
           q = p + 1
           j = 1
           60 continue
           if( j>n )go to 70
           q = q + 1
           iwork( q ) = j
           j = j + nb
           if( j>=n )go to 70
           if( b( j, j-1 )/=zero )j = j + 1
           go to 60
           70 continue
           iwork( q+1 ) = n + 1
           if( iwork( q )==iwork( q+1 ) )q = q - 1
           if( notran ) then
              loop_150: do iround = 1, isolve
                 ! solve (i, j)-subsystem
                     ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                     ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
                 ! for i = p, p - 1,..., 1; j = 1, 2,..., q
                 dscale = zero
                 dsum = one
                 pq = 0
                 scale = one
                 loop_130: do j = p + 2, q
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    loop_120: do i = p, 1, -1
                       is = iwork( i )
                       ie = iwork( i+1 ) - 1
                       mb = ie - is + 1
                       ppqq = 0
                       call stdlib_stgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), &
                       ldb, c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, &
                                 scaloc, dsum, dscale,iwork( q+2 ), ppqq, linfo )
                       if( linfo>0 )info = linfo
                       pq = pq + ppqq
                       if( scaloc/=one ) then
                          do k = 1, js - 1
                             call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          do k = js, je
                             call stdlib_sscal( is-1, scaloc, c( 1, k ), 1 )
                             call stdlib_sscal( is-1, scaloc, f( 1, k ), 1 )
                          end do
                          do k = js, je
                             call stdlib_sscal( m-ie, scaloc, c( ie+1, k ), 1 )
                             call stdlib_sscal( m-ie, scaloc, f( ie+1, k ), 1 )
                          end do
                          do k = je + 1, n
                             call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_sgemm( 'N', 'N', is-1, nb, mb, -one,a( 1, is ), lda, c( is, &
                                    js ), ldc, one,c( 1, js ), ldc )
                          call stdlib_sgemm( 'N', 'N', is-1, nb, mb, -one,d( 1, is ), ldd, c( is, &
                                    js ), ldc, one,f( 1, js ), ldf )
                       end if
                       if( j<q ) then
                          call stdlib_sgemm( 'N', 'N', mb, n-je, nb, one,f( is, js ), ldf, b( js, &
                                    je+1 ), ldb,one, c( is, je+1 ), ldc )
                          call stdlib_sgemm( 'N', 'N', mb, n-je, nb, one,f( is, js ), ldf, e( js, &
                                    je+1 ), lde,one, f( is, je+1 ), ldf )
                       end if
                    end do loop_120
                 end do loop_130
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_slacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_slacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_slaset( 'F', m, n, zero, zero, c, ldc )
                    call stdlib_slaset( 'F', m, n, zero, zero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_slacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_slacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_150
           else
              ! solve transposed (i, j)-subsystem
                   ! a(i, i)**t * r(i, j)  + d(i, i)**t * l(i, j)  =  c(i, j)
                   ! r(i, j)  * b(j, j)**t + l(i, j)  * e(j, j)**t = -f(i, j)
              ! for i = 1,2,..., p; j = q, q-1,..., 1
              scale = one
              loop_210: do i = 1, p
                 is = iwork( i )
                 ie = iwork( i+1 ) - 1
                 mb = ie - is + 1
                 loop_200: do j = q, p + 2, -1
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    call stdlib_stgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), ldb, &
                    c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, scaloc, &
                              dsum, dscale,iwork( q+2 ), ppqq, linfo )
                    if( linfo>0 )info = linfo
                    if( scaloc/=one ) then
                       do k = 1, js - 1
                          call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                          call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                       end do
                       do k = js, je
                          call stdlib_sscal( is-1, scaloc, c( 1, k ), 1 )
                          call stdlib_sscal( is-1, scaloc, f( 1, k ), 1 )
                       end do
                       do k = js, je
                          call stdlib_sscal( m-ie, scaloc, c( ie+1, k ), 1 )
                          call stdlib_sscal( m-ie, scaloc, f( ie+1, k ), 1 )
                       end do
                       do k = je + 1, n
                          call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                          call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    if( j>p+2 ) then
                       call stdlib_sgemm( 'N', 'T', mb, js-1, nb, one, c( is, js ),ldc, b( 1, js )&
                                 , ldb, one, f( is, 1 ),ldf )
                       call stdlib_sgemm( 'N', 'T', mb, js-1, nb, one, f( is, js ),ldf, e( 1, js )&
                                 , lde, one, f( is, 1 ),ldf )
                    end if
                    if( i<p ) then
                       call stdlib_sgemm( 'T', 'N', m-ie, nb, mb, -one,a( is, ie+1 ), lda, c( is, &
                                 js ), ldc, one,c( ie+1, js ), ldc )
                       call stdlib_sgemm( 'T', 'N', m-ie, nb, mb, -one,d( is, ie+1 ), ldd, f( is, &
                                 js ), ldf, one,c( ie+1, js ), ldc )
                    end if
                 end do loop_200
              end do loop_210
           end if
           work( 1 ) = lwmin
           return
     end subroutine stdlib_stgsyl

     module pure subroutine stdlib_dtgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! DTGSYL solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C                 (1)
     !! D * R - L * E = scale * F
     !! where R and L are unknown m-by-n matrices, (A, D), (B, E) and
     !! (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
     !! respectively, with real entries. (A, D) and (B, E) must be in
     !! generalized (real) Schur canonical form, i.e. A, B are upper quasi
     !! triangular and D, E are upper triangular.
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
     !! scaling factor chosen to avoid overflow.
     !! In matrix notation (1) is equivalent to solve  Zx = scale b, where
     !! Z is defined as
     !! Z = [ kron(In, A)  -kron(B**T, Im) ]         (2)
     !! [ kron(In, D)  -kron(E**T, Im) ].
     !! Here Ik is the identity matrix of size k and X**T is the transpose of
     !! X. kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! If TRANS = 'T', DTGSYL solves the transposed system Z**T*y = scale*b,
     !! which is equivalent to solve for R and L in
     !! A**T * R + D**T * L = scale * C           (3)
     !! R * B**T + L * E**T = scale * -F
     !! This case (TRANS = 'T') is used to compute an one-norm-based estimate
     !! of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
     !! and (B,E), using DLACON.
     !! If IJOB >= 1, DTGSYL computes a Frobenius norm-based estimate
     !! of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
     !! reciprocal of the smallest singular value of Z. See [1-2] for more
     !! information.
     !! This is a level 3 BLAS algorithm.
               ldf, scale, dif, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(ilp), intent(out) :: info
           real(dp), intent(out) :: dif, scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(dp), intent(inout) :: c(ldc,*), f(ldf,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_dcopy by calls to stdlib_dlaset.
        ! sven hammarling, 1/5/02.
           
           ! Local Scalars 
           logical(lk) :: lquery, notran
           integer(ilp) :: i, ie, ifunc, iround, is, isolve, j, je, js, k, linfo, lwmin, mb, nb, &
                     p, ppqq, pq, q
           real(dp) :: dscale, dsum, scale2, scaloc
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>4 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info==0 ) then
              if( notran ) then
                 if( ijob==1 .or. ijob==2 ) then
                    lwmin = max( 1, 2*m*n )
                 else
                    lwmin = 1
                 end if
              else
                 lwmin = 1
              end if
              work( 1 ) = lwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSYL', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              scale = 1
              if( notran ) then
                 if( ijob/=0 ) then
                    dif = 0
                 end if
              end if
              return
           end if
           ! determine optimal block sizes mb and nb
           mb = stdlib_ilaenv( 2, 'DTGSYL', trans, m, n, -1, -1 )
           nb = stdlib_ilaenv( 5, 'DTGSYL', trans, m, n, -1, -1 )
           isolve = 1
           ifunc = 0
           if( notran ) then
              if( ijob>=3 ) then
                 ifunc = ijob - 2
                 call stdlib_dlaset( 'F', m, n, zero, zero, c, ldc )
                 call stdlib_dlaset( 'F', m, n, zero, zero, f, ldf )
              else if( ijob>=1 ) then
                 isolve = 2
              end if
           end if
           if( ( mb<=1 .and. nb<=1 ) .or. ( mb>=m .and. nb>=n ) )then
              loop_30: do iround = 1, isolve
                 ! use unblocked level 2 solver
                 dscale = zero
                 dsum = one
                 pq = 0
                 call stdlib_dtgsy2( trans, ifunc, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f,&
                            ldf, scale, dsum, dscale,iwork, pq, info )
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=dp) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=dp) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_dlacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_dlacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_dlaset( 'F', m, n, zero, zero, c, ldc )
                    call stdlib_dlaset( 'F', m, n, zero, zero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_dlacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_dlacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_30
              return
           end if
           ! determine block structure of a
           p = 0
           i = 1
           40 continue
           if( i>m )go to 50
           p = p + 1
           iwork( p ) = i
           i = i + mb
           if( i>=m )go to 50
           if( a( i, i-1 )/=zero )i = i + 1
           go to 40
           50 continue
           iwork( p+1 ) = m + 1
           if( iwork( p )==iwork( p+1 ) )p = p - 1
           ! determine block structure of b
           q = p + 1
           j = 1
           60 continue
           if( j>n )go to 70
           q = q + 1
           iwork( q ) = j
           j = j + nb
           if( j>=n )go to 70
           if( b( j, j-1 )/=zero )j = j + 1
           go to 60
           70 continue
           iwork( q+1 ) = n + 1
           if( iwork( q )==iwork( q+1 ) )q = q - 1
           if( notran ) then
              loop_150: do iround = 1, isolve
                 ! solve (i, j)-subsystem
                     ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                     ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
                 ! for i = p, p - 1,..., 1; j = 1, 2,..., q
                 dscale = zero
                 dsum = one
                 pq = 0
                 scale = one
                 loop_130: do j = p + 2, q
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    loop_120: do i = p, 1, -1
                       is = iwork( i )
                       ie = iwork( i+1 ) - 1
                       mb = ie - is + 1
                       ppqq = 0
                       call stdlib_dtgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), &
                       ldb, c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, &
                                 scaloc, dsum, dscale,iwork( q+2 ), ppqq, linfo )
                       if( linfo>0 )info = linfo
                       pq = pq + ppqq
                       if( scaloc/=one ) then
                          do k = 1, js - 1
                             call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          do k = js, je
                             call stdlib_dscal( is-1, scaloc, c( 1, k ), 1 )
                             call stdlib_dscal( is-1, scaloc, f( 1, k ), 1 )
                          end do
                          do k = js, je
                             call stdlib_dscal( m-ie, scaloc, c( ie+1, k ), 1 )
                             call stdlib_dscal( m-ie, scaloc, f( ie+1, k ), 1 )
                          end do
                          do k = je + 1, n
                             call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_dgemm( 'N', 'N', is-1, nb, mb, -one,a( 1, is ), lda, c( is, &
                                    js ), ldc, one,c( 1, js ), ldc )
                          call stdlib_dgemm( 'N', 'N', is-1, nb, mb, -one,d( 1, is ), ldd, c( is, &
                                    js ), ldc, one,f( 1, js ), ldf )
                       end if
                       if( j<q ) then
                          call stdlib_dgemm( 'N', 'N', mb, n-je, nb, one,f( is, js ), ldf, b( js, &
                                    je+1 ), ldb,one, c( is, je+1 ), ldc )
                          call stdlib_dgemm( 'N', 'N', mb, n-je, nb, one,f( is, js ), ldf, e( js, &
                                    je+1 ), lde,one, f( is, je+1 ), ldf )
                       end if
                    end do loop_120
                 end do loop_130
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=dp) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=dp) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_dlacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_dlacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_dlaset( 'F', m, n, zero, zero, c, ldc )
                    call stdlib_dlaset( 'F', m, n, zero, zero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_dlacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_dlacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_150
           else
              ! solve transposed (i, j)-subsystem
                   ! a(i, i)**t * r(i, j)  + d(i, i)**t * l(i, j)  =  c(i, j)
                   ! r(i, j)  * b(j, j)**t + l(i, j)  * e(j, j)**t = -f(i, j)
              ! for i = 1,2,..., p; j = q, q-1,..., 1
              scale = one
              loop_210: do i = 1, p
                 is = iwork( i )
                 ie = iwork( i+1 ) - 1
                 mb = ie - is + 1
                 loop_200: do j = q, p + 2, -1
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    call stdlib_dtgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), ldb, &
                    c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, scaloc, &
                              dsum, dscale,iwork( q+2 ), ppqq, linfo )
                    if( linfo>0 )info = linfo
                    if( scaloc/=one ) then
                       do k = 1, js - 1
                          call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                          call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                       end do
                       do k = js, je
                          call stdlib_dscal( is-1, scaloc, c( 1, k ), 1 )
                          call stdlib_dscal( is-1, scaloc, f( 1, k ), 1 )
                       end do
                       do k = js, je
                          call stdlib_dscal( m-ie, scaloc, c( ie+1, k ), 1 )
                          call stdlib_dscal( m-ie, scaloc, f( ie+1, k ), 1 )
                       end do
                       do k = je + 1, n
                          call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                          call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    if( j>p+2 ) then
                       call stdlib_dgemm( 'N', 'T', mb, js-1, nb, one, c( is, js ),ldc, b( 1, js )&
                                 , ldb, one, f( is, 1 ),ldf )
                       call stdlib_dgemm( 'N', 'T', mb, js-1, nb, one, f( is, js ),ldf, e( 1, js )&
                                 , lde, one, f( is, 1 ),ldf )
                    end if
                    if( i<p ) then
                       call stdlib_dgemm( 'T', 'N', m-ie, nb, mb, -one,a( is, ie+1 ), lda, c( is, &
                                 js ), ldc, one,c( ie+1, js ), ldc )
                       call stdlib_dgemm( 'T', 'N', m-ie, nb, mb, -one,d( is, ie+1 ), ldd, f( is, &
                                 js ), ldf, one,c( ie+1, js ), ldc )
                    end if
                 end do loop_200
              end do loop_210
           end if
           work( 1 ) = lwmin
           return
     end subroutine stdlib_dtgsyl

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$tgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! DTGSYL: solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C                 (1)
     !! D * R - L * E = scale * F
     !! where R and L are unknown m-by-n matrices, (A, D), (B, E) and
     !! (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
     !! respectively, with real entries. (A, D) and (B, E) must be in
     !! generalized (real) Schur canonical form, i.e. A, B are upper quasi
     !! triangular and D, E are upper triangular.
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
     !! scaling factor chosen to avoid overflow.
     !! In matrix notation (1) is equivalent to solve  Zx = scale b, where
     !! Z is defined as
     !! Z = [ kron(In, A)  -kron(B**T, Im) ]         (2)
     !! [ kron(In, D)  -kron(E**T, Im) ].
     !! Here Ik is the identity matrix of size k and X**T is the transpose of
     !! X. kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! If TRANS = 'T', DTGSYL solves the transposed system Z**T*y = scale*b,
     !! which is equivalent to solve for R and L in
     !! A**T * R + D**T * L = scale * C           (3)
     !! R * B**T + L * E**T = scale * -F
     !! This case (TRANS = 'T') is used to compute an one-norm-based estimate
     !! of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
     !! and (B,E), using DLACON.
     !! If IJOB >= 1, DTGSYL computes a Frobenius norm-based estimate
     !! of Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
     !! reciprocal of the smallest singular value of Z. See [1-2] for more
     !! information.
     !! This is a level 3 BLAS algorithm.
               ldf, scale, dif, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(ilp), intent(out) :: info
           real(${rk}$), intent(out) :: dif, scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(${rk}$), intent(inout) :: c(ldc,*), f(ldf,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_${ri}$copy by calls to stdlib_${ri}$laset.
        ! sven hammarling, 1/5/02.
           
           ! Local Scalars 
           logical(lk) :: lquery, notran
           integer(ilp) :: i, ie, ifunc, iround, is, isolve, j, je, js, k, linfo, lwmin, mb, nb, &
                     p, ppqq, pq, q
           real(${rk}$) :: dscale, dsum, scale2, scaloc
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>4 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info==0 ) then
              if( notran ) then
                 if( ijob==1 .or. ijob==2 ) then
                    lwmin = max( 1, 2*m*n )
                 else
                    lwmin = 1
                 end if
              else
                 lwmin = 1
              end if
              work( 1 ) = lwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSYL', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              scale = 1
              if( notran ) then
                 if( ijob/=0 ) then
                    dif = 0
                 end if
              end if
              return
           end if
           ! determine optimal block sizes mb and nb
           mb = stdlib_ilaenv( 2, 'DTGSYL', trans, m, n, -1, -1 )
           nb = stdlib_ilaenv( 5, 'DTGSYL', trans, m, n, -1, -1 )
           isolve = 1
           ifunc = 0
           if( notran ) then
              if( ijob>=3 ) then
                 ifunc = ijob - 2
                 call stdlib_${ri}$laset( 'F', m, n, zero, zero, c, ldc )
                 call stdlib_${ri}$laset( 'F', m, n, zero, zero, f, ldf )
              else if( ijob>=1 ) then
                 isolve = 2
              end if
           end if
           if( ( mb<=1 .and. nb<=1 ) .or. ( mb>=m .and. nb>=n ) )then
              loop_30: do iround = 1, isolve
                 ! use unblocked level 2 solver
                 dscale = zero
                 dsum = one
                 pq = 0
                 call stdlib_${ri}$tgsy2( trans, ifunc, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f,&
                            ldf, scale, dsum, dscale,iwork, pq, info )
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=${rk}$) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=${rk}$) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_${ri}$lacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_${ri}$lacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_${ri}$laset( 'F', m, n, zero, zero, c, ldc )
                    call stdlib_${ri}$laset( 'F', m, n, zero, zero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_${ri}$lacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_${ri}$lacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_30
              return
           end if
           ! determine block structure of a
           p = 0
           i = 1
           40 continue
           if( i>m )go to 50
           p = p + 1
           iwork( p ) = i
           i = i + mb
           if( i>=m )go to 50
           if( a( i, i-1 )/=zero )i = i + 1
           go to 40
           50 continue
           iwork( p+1 ) = m + 1
           if( iwork( p )==iwork( p+1 ) )p = p - 1
           ! determine block structure of b
           q = p + 1
           j = 1
           60 continue
           if( j>n )go to 70
           q = q + 1
           iwork( q ) = j
           j = j + nb
           if( j>=n )go to 70
           if( b( j, j-1 )/=zero )j = j + 1
           go to 60
           70 continue
           iwork( q+1 ) = n + 1
           if( iwork( q )==iwork( q+1 ) )q = q - 1
           if( notran ) then
              loop_150: do iround = 1, isolve
                 ! solve (i, j)-subsystem
                     ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                     ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
                 ! for i = p, p - 1,..., 1; j = 1, 2,..., q
                 dscale = zero
                 dsum = one
                 pq = 0
                 scale = one
                 loop_130: do j = p + 2, q
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    loop_120: do i = p, 1, -1
                       is = iwork( i )
                       ie = iwork( i+1 ) - 1
                       mb = ie - is + 1
                       ppqq = 0
                       call stdlib_${ri}$tgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), &
                       ldb, c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, &
                                 scaloc, dsum, dscale,iwork( q+2 ), ppqq, linfo )
                       if( linfo>0 )info = linfo
                       pq = pq + ppqq
                       if( scaloc/=one ) then
                          do k = 1, js - 1
                             call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                          end do
                          do k = js, je
                             call stdlib_${ri}$scal( is-1, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( is-1, scaloc, f( 1, k ), 1 )
                          end do
                          do k = js, je
                             call stdlib_${ri}$scal( m-ie, scaloc, c( ie+1, k ), 1 )
                             call stdlib_${ri}$scal( m-ie, scaloc, f( ie+1, k ), 1 )
                          end do
                          do k = je + 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_${ri}$gemm( 'N', 'N', is-1, nb, mb, -one,a( 1, is ), lda, c( is, &
                                    js ), ldc, one,c( 1, js ), ldc )
                          call stdlib_${ri}$gemm( 'N', 'N', is-1, nb, mb, -one,d( 1, is ), ldd, c( is, &
                                    js ), ldc, one,f( 1, js ), ldf )
                       end if
                       if( j<q ) then
                          call stdlib_${ri}$gemm( 'N', 'N', mb, n-je, nb, one,f( is, js ), ldf, b( js, &
                                    je+1 ), ldb,one, c( is, je+1 ), ldc )
                          call stdlib_${ri}$gemm( 'N', 'N', mb, n-je, nb, one,f( is, js ), ldf, e( js, &
                                    je+1 ), lde,one, f( is, je+1 ), ldf )
                       end if
                    end do loop_120
                 end do loop_130
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=${rk}$) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=${rk}$) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_${ri}$lacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_${ri}$lacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_${ri}$laset( 'F', m, n, zero, zero, c, ldc )
                    call stdlib_${ri}$laset( 'F', m, n, zero, zero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_${ri}$lacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_${ri}$lacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_150
           else
              ! solve transposed (i, j)-subsystem
                   ! a(i, i)**t * r(i, j)  + d(i, i)**t * l(i, j)  =  c(i, j)
                   ! r(i, j)  * b(j, j)**t + l(i, j)  * e(j, j)**t = -f(i, j)
              ! for i = 1,2,..., p; j = q, q-1,..., 1
              scale = one
              loop_210: do i = 1, p
                 is = iwork( i )
                 ie = iwork( i+1 ) - 1
                 mb = ie - is + 1
                 loop_200: do j = q, p + 2, -1
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    call stdlib_${ri}$tgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), ldb, &
                    c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, scaloc, &
                              dsum, dscale,iwork( q+2 ), ppqq, linfo )
                    if( linfo>0 )info = linfo
                    if( scaloc/=one ) then
                       do k = 1, js - 1
                          call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                          call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                       end do
                       do k = js, je
                          call stdlib_${ri}$scal( is-1, scaloc, c( 1, k ), 1 )
                          call stdlib_${ri}$scal( is-1, scaloc, f( 1, k ), 1 )
                       end do
                       do k = js, je
                          call stdlib_${ri}$scal( m-ie, scaloc, c( ie+1, k ), 1 )
                          call stdlib_${ri}$scal( m-ie, scaloc, f( ie+1, k ), 1 )
                       end do
                       do k = je + 1, n
                          call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                          call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                       end do
                       scale = scale*scaloc
                    end if
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    if( j>p+2 ) then
                       call stdlib_${ri}$gemm( 'N', 'T', mb, js-1, nb, one, c( is, js ),ldc, b( 1, js )&
                                 , ldb, one, f( is, 1 ),ldf )
                       call stdlib_${ri}$gemm( 'N', 'T', mb, js-1, nb, one, f( is, js ),ldf, e( 1, js )&
                                 , lde, one, f( is, 1 ),ldf )
                    end if
                    if( i<p ) then
                       call stdlib_${ri}$gemm( 'T', 'N', m-ie, nb, mb, -one,a( is, ie+1 ), lda, c( is, &
                                 js ), ldc, one,c( ie+1, js ), ldc )
                       call stdlib_${ri}$gemm( 'T', 'N', m-ie, nb, mb, -one,d( is, ie+1 ), ldd, f( is, &
                                 js ), ldf, one,c( ie+1, js ), ldc )
                    end if
                 end do loop_200
              end do loop_210
           end if
           work( 1 ) = lwmin
           return
     end subroutine stdlib_${ri}$tgsyl

#:endif
#:endfor

     module pure subroutine stdlib_ctgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! CTGSYL solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C            (1)
     !! D * R - L * E = scale * F
     !! where R and L are unknown m-by-n matrices, (A, D), (B, E) and
     !! (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
     !! respectively, with complex entries. A, B, D and E are upper
     !! triangular (i.e., (A,D) and (B,E) in generalized Schur form).
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1
     !! is an output scaling factor chosen to avoid overflow.
     !! In matrix notation (1) is equivalent to solve Zx = scale*b, where Z
     !! is defined as
     !! Z = [ kron(In, A)  -kron(B**H, Im) ]        (2)
     !! [ kron(In, D)  -kron(E**H, Im) ],
     !! Here Ix is the identity matrix of size x and X**H is the conjugate
     !! transpose of X. Kron(X, Y) is the Kronecker product between the
     !! matrices X and Y.
     !! If TRANS = 'C', y in the conjugate transposed system Z**H *y = scale*b
     !! is solved for, which is equivalent to solve for R and L in
     !! A**H * R + D**H * L = scale * C           (3)
     !! R * B**H + L * E**H = scale * -F
     !! This case (TRANS = 'C') is used to compute an one-norm-based estimate
     !! of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
     !! and (B,E), using CLACON.
     !! If IJOB >= 1, CTGSYL computes a Frobenius norm-based estimate of
     !! Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
     !! reciprocal of the smallest singular value of Z.
     !! This is a level-3 BLAS algorithm.
               ldf, scale, dif, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(ilp), intent(out) :: info
           real(sp), intent(out) :: dif, scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           complex(sp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(sp), intent(inout) :: c(ldc,*), f(ldf,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_ccopy by calls to stdlib_claset.
        ! sven hammarling, 1/5/02.
           
           
           ! Local Scalars 
           logical(lk) :: lquery, notran
           integer(ilp) :: i, ie, ifunc, iround, is, isolve, j, je, js, k, linfo, lwmin, mb, nb, &
                     p, pq, q
           real(sp) :: dscale, dsum, scale2, scaloc
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>4 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info==0 ) then
              if( notran ) then
                 if( ijob==1 .or. ijob==2 ) then
                    lwmin = max( 1, 2*m*n )
                 else
                    lwmin = 1
                 end if
              else
                 lwmin = 1
              end if
              work( 1 ) = lwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGSYL', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              scale = 1
              if( notran ) then
                 if( ijob/=0 ) then
                    dif = 0
                 end if
              end if
              return
           end if
           ! determine  optimal block sizes mb and nb
           mb = stdlib_ilaenv( 2, 'CTGSYL', trans, m, n, -1, -1 )
           nb = stdlib_ilaenv( 5, 'CTGSYL', trans, m, n, -1, -1 )
           isolve = 1
           ifunc = 0
           if( notran ) then
              if( ijob>=3 ) then
                 ifunc = ijob - 2
                 call stdlib_claset( 'F', m, n, czero, czero, c, ldc )
                 call stdlib_claset( 'F', m, n, czero, czero, f, ldf )
              else if( ijob>=1 .and. notran ) then
                 isolve = 2
              end if
           end if
           if( ( mb<=1 .and. nb<=1 ) .or. ( mb>=m .and. nb>=n ) )then
              ! use unblocked level 2 solver
              loop_30: do iround = 1, isolve
                 scale = one
                 dscale = zero
                 dsum = one
                 pq = m*n
                 call stdlib_ctgsy2( trans, ifunc, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f,&
                            ldf, scale, dsum, dscale,info )
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_clacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_clacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_claset( 'F', m, n, czero, czero, c, ldc )
                    call stdlib_claset( 'F', m, n, czero, czero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_clacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_clacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_30
              return
           end if
           ! determine block structure of a
           p = 0
           i = 1
           40 continue
           if( i>m )go to 50
           p = p + 1
           iwork( p ) = i
           i = i + mb
           if( i>=m )go to 50
           go to 40
           50 continue
           iwork( p+1 ) = m + 1
           if( iwork( p )==iwork( p+1 ) )p = p - 1
           ! determine block structure of b
           q = p + 1
           j = 1
           60 continue
           if( j>n )go to 70
           q = q + 1
           iwork( q ) = j
           j = j + nb
           if( j>=n )go to 70
           go to 60
           70 continue
           iwork( q+1 ) = n + 1
           if( iwork( q )==iwork( q+1 ) )q = q - 1
           if( notran ) then
              loop_150: do iround = 1, isolve
                 ! solve (i, j) - subsystem
                     ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                     ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
                 ! for i = p, p - 1, ..., 1; j = 1, 2, ..., q
                 pq = 0
                 scale = one
                 dscale = zero
                 dsum = one
                 loop_130: do j = p + 2, q
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    loop_120: do i = p, 1, -1
                       is = iwork( i )
                       ie = iwork( i+1 ) - 1
                       mb = ie - is + 1
                       call stdlib_ctgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), &
                       ldb, c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, &
                                 scaloc, dsum, dscale,linfo )
                       if( linfo>0 )info = linfo
                       pq = pq + mb*nb
                       if( scaloc/=one ) then
                          do k = 1, js - 1
                             call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                       
                             call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                       
                          end do
                          do k = js, je
                             call stdlib_cscal( is-1, cmplx( scaloc, zero,KIND=sp),c( 1, k ), 1 )
                                       
                             call stdlib_cscal( is-1, cmplx( scaloc, zero,KIND=sp),f( 1, k ), 1 )
                                       
                          end do
                          do k = js, je
                             call stdlib_cscal( m-ie, cmplx( scaloc, zero,KIND=sp),c( ie+1, k ), &
                                       1 )
                             call stdlib_cscal( m-ie, cmplx( scaloc, zero,KIND=sp),f( ie+1, k ), &
                                       1 )
                          end do
                          do k = je + 1, n
                             call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                       
                             call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                       
                          end do
                          scale = scale*scaloc
                       end if
                       ! substitute r(i,j) and l(i,j) into remaining equation.
                       if( i>1 ) then
                          call stdlib_cgemm( 'N', 'N', is-1, nb, mb,cmplx( -one, zero,KIND=sp), a(&
                           1, is ), lda,c( is, js ), ldc, cmplx( one, zero,KIND=sp),c( 1, js ), &
                                     ldc )
                          call stdlib_cgemm( 'N', 'N', is-1, nb, mb,cmplx( -one, zero,KIND=sp), d(&
                           1, is ), ldd,c( is, js ), ldc, cmplx( one, zero,KIND=sp),f( 1, js ), &
                                     ldf )
                       end if
                       if( j<q ) then
                          call stdlib_cgemm( 'N', 'N', mb, n-je, nb,cmplx( one, zero,KIND=sp), f( &
                          is, js ), ldf,b( js, je+1 ), ldb, cmplx( one, zero,KIND=sp),c( is, je+1 &
                                    ), ldc )
                          call stdlib_cgemm( 'N', 'N', mb, n-je, nb,cmplx( one, zero,KIND=sp), f( &
                          is, js ), ldf,e( js, je+1 ), lde, cmplx( one, zero,KIND=sp),f( is, je+1 &
                                    ), ldf )
                       end if
                    end do loop_120
                 end do loop_130
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=sp) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_clacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_clacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_claset( 'F', m, n, czero, czero, c, ldc )
                    call stdlib_claset( 'F', m, n, czero, czero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_clacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_clacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_150
           else
              ! solve transposed (i, j)-subsystem
                  ! a(i, i)**h * r(i, j) + d(i, i)**h * l(i, j) = c(i, j)
                  ! r(i, j) * b(j, j)  + l(i, j) * e(j, j) = -f(i, j)
              ! for i = 1,2,..., p; j = q, q-1,..., 1
              scale = one
              loop_210: do i = 1, p
                 is = iwork( i )
                 ie = iwork( i+1 ) - 1
                 mb = ie - is + 1
                 loop_200: do j = q, p + 2, -1
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    call stdlib_ctgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), ldb, &
                    c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, scaloc, &
                              dsum, dscale,linfo )
                    if( linfo>0 )info = linfo
                    if( scaloc/=one ) then
                       do k = 1, js - 1
                          call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                    
                          call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                    
                       end do
                       do k = js, je
                          call stdlib_cscal( is-1, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                    
                          call stdlib_cscal( is-1, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                    
                       end do
                       do k = js, je
                          call stdlib_cscal( m-ie, cmplx( scaloc, zero,KIND=sp),c( ie+1, k ), 1 )
                                    
                          call stdlib_cscal( m-ie, cmplx( scaloc, zero,KIND=sp),f( ie+1, k ), 1 )
                                    
                       end do
                       do k = je + 1, n
                          call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                    
                          call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                    
                       end do
                       scale = scale*scaloc
                    end if
                    ! substitute r(i,j) and l(i,j) into remaining equation.
                    if( j>p+2 ) then
                       call stdlib_cgemm( 'N', 'C', mb, js-1, nb,cmplx( one, zero,KIND=sp), c( is,&
                        js ), ldc,b( 1, js ), ldb, cmplx( one, zero,KIND=sp),f( is, 1 ), ldf )
                                  
                       call stdlib_cgemm( 'N', 'C', mb, js-1, nb,cmplx( one, zero,KIND=sp), f( is,&
                        js ), ldf,e( 1, js ), lde, cmplx( one, zero,KIND=sp),f( is, 1 ), ldf )
                                  
                    end if
                    if( i<p ) then
                       call stdlib_cgemm( 'C', 'N', m-ie, nb, mb,cmplx( -one, zero,KIND=sp), a( &
                       is, ie+1 ), lda,c( is, js ), ldc, cmplx( one, zero,KIND=sp),c( ie+1, js ), &
                                 ldc )
                       call stdlib_cgemm( 'C', 'N', m-ie, nb, mb,cmplx( -one, zero,KIND=sp), d( &
                       is, ie+1 ), ldd,f( is, js ), ldf, cmplx( one, zero,KIND=sp),c( ie+1, js ), &
                                 ldc )
                    end if
                 end do loop_200
              end do loop_210
           end if
           work( 1 ) = lwmin
           return
     end subroutine stdlib_ctgsyl

     module pure subroutine stdlib_ztgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! ZTGSYL solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C            (1)
     !! D * R - L * E = scale * F
     !! where R and L are unknown m-by-n matrices, (A, D), (B, E) and
     !! (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
     !! respectively, with complex entries. A, B, D and E are upper
     !! triangular (i.e., (A,D) and (B,E) in generalized Schur form).
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1
     !! is an output scaling factor chosen to avoid overflow.
     !! In matrix notation (1) is equivalent to solve Zx = scale*b, where Z
     !! is defined as
     !! Z = [ kron(In, A)  -kron(B**H, Im) ]        (2)
     !! [ kron(In, D)  -kron(E**H, Im) ],
     !! Here Ix is the identity matrix of size x and X**H is the conjugate
     !! transpose of X. Kron(X, Y) is the Kronecker product between the
     !! matrices X and Y.
     !! If TRANS = 'C', y in the conjugate transposed system Z**H *y = scale*b
     !! is solved for, which is equivalent to solve for R and L in
     !! A**H * R + D**H * L = scale * C           (3)
     !! R * B**H + L * E**H = scale * -F
     !! This case (TRANS = 'C') is used to compute an one-norm-based estimate
     !! of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
     !! and (B,E), using ZLACON.
     !! If IJOB >= 1, ZTGSYL computes a Frobenius norm-based estimate of
     !! Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
     !! reciprocal of the smallest singular value of Z.
     !! This is a level-3 BLAS algorithm.
               ldf, scale, dif, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(ilp), intent(out) :: info
           real(dp), intent(out) :: dif, scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           complex(dp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(dp), intent(inout) :: c(ldc,*), f(ldf,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_ccopy by calls to stdlib_claset.
        ! sven hammarling, 1/5/02.
           
           
           ! Local Scalars 
           logical(lk) :: lquery, notran
           integer(ilp) :: i, ie, ifunc, iround, is, isolve, j, je, js, k, linfo, lwmin, mb, nb, &
                     p, pq, q
           real(dp) :: dscale, dsum, scale2, scaloc
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>4 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info==0 ) then
              if( notran ) then
                 if( ijob==1 .or. ijob==2 ) then
                    lwmin = max( 1, 2*m*n )
                 else
                    lwmin = 1
                 end if
              else
                 lwmin = 1
              end if
              work( 1 ) = lwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSYL', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              scale = 1
              if( notran ) then
                 if( ijob/=0 ) then
                    dif = 0
                 end if
              end if
              return
           end if
           ! determine  optimal block sizes mb and nb
           mb = stdlib_ilaenv( 2, 'ZTGSYL', trans, m, n, -1, -1 )
           nb = stdlib_ilaenv( 5, 'ZTGSYL', trans, m, n, -1, -1 )
           isolve = 1
           ifunc = 0
           if( notran ) then
              if( ijob>=3 ) then
                 ifunc = ijob - 2
                 call stdlib_zlaset( 'F', m, n, czero, czero, c, ldc )
                 call stdlib_zlaset( 'F', m, n, czero, czero, f, ldf )
              else if( ijob>=1 .and. notran ) then
                 isolve = 2
              end if
           end if
           if( ( mb<=1 .and. nb<=1 ) .or. ( mb>=m .and. nb>=n ) )then
              ! use unblocked level 2 solver
              loop_30: do iround = 1, isolve
                 scale = one
                 dscale = zero
                 dsum = one
                 pq = m*n
                 call stdlib_ztgsy2( trans, ifunc, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f,&
                            ldf, scale, dsum, dscale,info )
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=dp) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=dp) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_zlacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_zlacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_zlaset( 'F', m, n, czero, czero, c, ldc )
                    call stdlib_zlaset( 'F', m, n, czero, czero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_zlacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_zlacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_30
              return
           end if
           ! determine block structure of a
           p = 0
           i = 1
           40 continue
           if( i>m )go to 50
           p = p + 1
           iwork( p ) = i
           i = i + mb
           if( i>=m )go to 50
           go to 40
           50 continue
           iwork( p+1 ) = m + 1
           if( iwork( p )==iwork( p+1 ) )p = p - 1
           ! determine block structure of b
           q = p + 1
           j = 1
           60 continue
           if( j>n )go to 70
           q = q + 1
           iwork( q ) = j
           j = j + nb
           if( j>=n )go to 70
           go to 60
           70 continue
           iwork( q+1 ) = n + 1
           if( iwork( q )==iwork( q+1 ) )q = q - 1
           if( notran ) then
              loop_150: do iround = 1, isolve
                 ! solve (i, j) - subsystem
                     ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                     ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
                 ! for i = p, p - 1, ..., 1; j = 1, 2, ..., q
                 pq = 0
                 scale = one
                 dscale = zero
                 dsum = one
                 loop_130: do j = p + 2, q
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    loop_120: do i = p, 1, -1
                       is = iwork( i )
                       ie = iwork( i+1 ) - 1
                       mb = ie - is + 1
                       call stdlib_ztgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), &
                       ldb, c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, &
                                 scaloc, dsum, dscale,linfo )
                       if( linfo>0 )info = linfo
                       pq = pq + mb*nb
                       if( scaloc/=one ) then
                          do k = 1, js - 1
                             call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp),c( 1, k ), 1 )
                                       
                             call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp),f( 1, k ), 1 )
                                       
                          end do
                          do k = js, je
                             call stdlib_zscal( is-1, cmplx( scaloc, zero,KIND=dp),c( 1, k ), 1 )
                                       
                             call stdlib_zscal( is-1, cmplx( scaloc, zero,KIND=dp),f( 1, k ), 1 )
                                       
                          end do
                          do k = js, je
                             call stdlib_zscal( m-ie, cmplx( scaloc, zero,KIND=dp),c( ie+1, k ), &
                                       1 )
                             call stdlib_zscal( m-ie, cmplx( scaloc, zero,KIND=dp),f( ie+1, k ), &
                                       1 )
                          end do
                          do k = je + 1, n
                             call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp),c( 1, k ), 1 )
                                       
                             call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp),f( 1, k ), 1 )
                                       
                          end do
                          scale = scale*scaloc
                       end if
                       ! substitute r(i,j) and l(i,j) into remaining equation.
                       if( i>1 ) then
                          call stdlib_zgemm( 'N', 'N', is-1, nb, mb,cmplx( -one, zero,KIND=dp), a(&
                           1, is ), lda,c( is, js ), ldc, cmplx( one, zero,KIND=dp),c( 1, js ), &
                                     ldc )
                          call stdlib_zgemm( 'N', 'N', is-1, nb, mb,cmplx( -one, zero,KIND=dp), d(&
                           1, is ), ldd,c( is, js ), ldc, cmplx( one, zero,KIND=dp),f( 1, js ), &
                                     ldf )
                       end if
                       if( j<q ) then
                          call stdlib_zgemm( 'N', 'N', mb, n-je, nb,cmplx( one, zero,KIND=dp), f( &
                          is, js ), ldf,b( js, je+1 ), ldb,cmplx( one, zero,KIND=dp), c( is, je+1 &
                                    ),ldc )
                          call stdlib_zgemm( 'N', 'N', mb, n-je, nb,cmplx( one, zero,KIND=dp), f( &
                          is, js ), ldf,e( js, je+1 ), lde,cmplx( one, zero,KIND=dp), f( is, je+1 &
                                    ),ldf )
                       end if
                    end do loop_120
                 end do loop_130
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=dp) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=dp) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_zlacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_zlacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_zlaset( 'F', m, n, czero, czero, c, ldc )
                    call stdlib_zlaset( 'F', m, n, czero, czero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_zlacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_zlacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_150
           else
              ! solve transposed (i, j)-subsystem
                  ! a(i, i)**h * r(i, j) + d(i, i)**h * l(i, j) = c(i, j)
                  ! r(i, j) * b(j, j)  + l(i, j) * e(j, j) = -f(i, j)
              ! for i = 1,2,..., p; j = q, q-1,..., 1
              scale = one
              loop_210: do i = 1, p
                 is = iwork( i )
                 ie = iwork( i+1 ) - 1
                 mb = ie - is + 1
                 loop_200: do j = q, p + 2, -1
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    call stdlib_ztgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), ldb, &
                    c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, scaloc, &
                              dsum, dscale,linfo )
                    if( linfo>0 )info = linfo
                    if( scaloc/=one ) then
                       do k = 1, js - 1
                          call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp), c( 1, k ),1 )
                                    
                          call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp), f( 1, k ),1 )
                                    
                       end do
                       do k = js, je
                          call stdlib_zscal( is-1, cmplx( scaloc, zero,KIND=dp),c( 1, k ), 1 )
                                    
                          call stdlib_zscal( is-1, cmplx( scaloc, zero,KIND=dp),f( 1, k ), 1 )
                                    
                       end do
                       do k = js, je
                          call stdlib_zscal( m-ie, cmplx( scaloc, zero,KIND=dp),c( ie+1, k ), 1 )
                                    
                          call stdlib_zscal( m-ie, cmplx( scaloc, zero,KIND=dp),f( ie+1, k ), 1 )
                                    
                       end do
                       do k = je + 1, n
                          call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp), c( 1, k ),1 )
                                    
                          call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp), f( 1, k ),1 )
                                    
                       end do
                       scale = scale*scaloc
                    end if
                    ! substitute r(i,j) and l(i,j) into remaining equation.
                    if( j>p+2 ) then
                       call stdlib_zgemm( 'N', 'C', mb, js-1, nb,cmplx( one, zero,KIND=dp), c( is,&
                        js ), ldc,b( 1, js ), ldb, cmplx( one, zero,KIND=dp),f( is, 1 ), ldf )
                                  
                       call stdlib_zgemm( 'N', 'C', mb, js-1, nb,cmplx( one, zero,KIND=dp), f( is,&
                        js ), ldf,e( 1, js ), lde, cmplx( one, zero,KIND=dp),f( is, 1 ), ldf )
                                  
                    end if
                    if( i<p ) then
                       call stdlib_zgemm( 'C', 'N', m-ie, nb, mb,cmplx( -one, zero,KIND=dp), a( &
                       is, ie+1 ), lda,c( is, js ), ldc, cmplx( one, zero,KIND=dp),c( ie+1, js ), &
                                 ldc )
                       call stdlib_zgemm( 'C', 'N', m-ie, nb, mb,cmplx( -one, zero,KIND=dp), d( &
                       is, ie+1 ), ldd,f( is, js ), ldf, cmplx( one, zero,KIND=dp),c( ie+1, js ), &
                                 ldc )
                    end if
                 end do loop_200
              end do loop_210
           end if
           work( 1 ) = lwmin
           return
     end subroutine stdlib_ztgsyl

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$tgsyl( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! ZTGSYL: solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C            (1)
     !! D * R - L * E = scale * F
     !! where R and L are unknown m-by-n matrices, (A, D), (B, E) and
     !! (C, F) are given matrix pairs of size m-by-m, n-by-n and m-by-n,
     !! respectively, with complex entries. A, B, D and E are upper
     !! triangular (i.e., (A,D) and (B,E) in generalized Schur form).
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1
     !! is an output scaling factor chosen to avoid overflow.
     !! In matrix notation (1) is equivalent to solve Zx = scale*b, where Z
     !! is defined as
     !! Z = [ kron(In, A)  -kron(B**H, Im) ]        (2)
     !! [ kron(In, D)  -kron(E**H, Im) ],
     !! Here Ix is the identity matrix of size x and X**H is the conjugate
     !! transpose of X. Kron(X, Y) is the Kronecker product between the
     !! matrices X and Y.
     !! If TRANS = 'C', y in the conjugate transposed system Z**H *y = scale*b
     !! is solved for, which is equivalent to solve for R and L in
     !! A**H * R + D**H * L = scale * C           (3)
     !! R * B**H + L * E**H = scale * -F
     !! This case (TRANS = 'C') is used to compute an one-norm-based estimate
     !! of Dif[(A,D), (B,E)], the separation between the matrix pairs (A,D)
     !! and (B,E), using ZLACON.
     !! If IJOB >= 1, ZTGSYL computes a Frobenius norm-based estimate of
     !! Dif[(A,D),(B,E)]. That is, the reciprocal of a lower bound on the
     !! reciprocal of the smallest singular value of Z.
     !! This is a level-3 BLAS algorithm.
               ldf, scale, dif, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, lwork, m, n
           integer(ilp), intent(out) :: info
           real(${ck}$), intent(out) :: dif, scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           complex(${ck}$), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(${ck}$), intent(inout) :: c(ldc,*), f(ldf,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_zcopy by calls to stdlib_zlaset.
        ! sven hammarling, 1/5/02.
           
           
           ! Local Scalars 
           logical(lk) :: lquery, notran
           integer(ilp) :: i, ie, ifunc, iround, is, isolve, j, je, js, k, linfo, lwmin, mb, nb, &
                     p, pq, q
           real(${ck}$) :: dscale, dsum, scale2, scaloc
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           notran = stdlib_lsame( trans, 'N' )
           lquery = ( lwork==-1 )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>4 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info==0 ) then
              if( notran ) then
                 if( ijob==1 .or. ijob==2 ) then
                    lwmin = max( 1, 2*m*n )
                 else
                    lwmin = 1
                 end if
              else
                 lwmin = 1
              end if
              work( 1 ) = lwmin
              if( lwork<lwmin .and. .not.lquery ) then
                 info = -20
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSYL', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( m==0 .or. n==0 ) then
              scale = 1
              if( notran ) then
                 if( ijob/=0 ) then
                    dif = 0
                 end if
              end if
              return
           end if
           ! determine  optimal block sizes mb and nb
           mb = stdlib_ilaenv( 2, 'ZTGSYL', trans, m, n, -1, -1 )
           nb = stdlib_ilaenv( 5, 'ZTGSYL', trans, m, n, -1, -1 )
           isolve = 1
           ifunc = 0
           if( notran ) then
              if( ijob>=3 ) then
                 ifunc = ijob - 2
                 call stdlib_${ci}$laset( 'F', m, n, czero, czero, c, ldc )
                 call stdlib_${ci}$laset( 'F', m, n, czero, czero, f, ldf )
              else if( ijob>=1 .and. notran ) then
                 isolve = 2
              end if
           end if
           if( ( mb<=1 .and. nb<=1 ) .or. ( mb>=m .and. nb>=n ) )then
              ! use unblocked level 2 solver
              loop_30: do iround = 1, isolve
                 scale = one
                 dscale = zero
                 dsum = one
                 pq = m*n
                 call stdlib_${ci}$tgsy2( trans, ifunc, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f,&
                            ldf, scale, dsum, dscale,info )
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=${ck}$) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=${ck}$) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_${ci}$lacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_${ci}$lacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_${ci}$laset( 'F', m, n, czero, czero, c, ldc )
                    call stdlib_${ci}$laset( 'F', m, n, czero, czero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_${ci}$lacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_${ci}$lacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_30
              return
           end if
           ! determine block structure of a
           p = 0
           i = 1
           40 continue
           if( i>m )go to 50
           p = p + 1
           iwork( p ) = i
           i = i + mb
           if( i>=m )go to 50
           go to 40
           50 continue
           iwork( p+1 ) = m + 1
           if( iwork( p )==iwork( p+1 ) )p = p - 1
           ! determine block structure of b
           q = p + 1
           j = 1
           60 continue
           if( j>n )go to 70
           q = q + 1
           iwork( q ) = j
           j = j + nb
           if( j>=n )go to 70
           go to 60
           70 continue
           iwork( q+1 ) = n + 1
           if( iwork( q )==iwork( q+1 ) )q = q - 1
           if( notran ) then
              loop_150: do iround = 1, isolve
                 ! solve (i, j) - subsystem
                     ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                     ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
                 ! for i = p, p - 1, ..., 1; j = 1, 2, ..., q
                 pq = 0
                 scale = one
                 dscale = zero
                 dsum = one
                 loop_130: do j = p + 2, q
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    loop_120: do i = p, 1, -1
                       is = iwork( i )
                       ie = iwork( i+1 ) - 1
                       mb = ie - is + 1
                       call stdlib_${ci}$tgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), &
                       ldb, c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, &
                                 scaloc, dsum, dscale,linfo )
                       if( linfo>0 )info = linfo
                       pq = pq + mb*nb
                       if( scaloc/=one ) then
                          do k = 1, js - 1
                             call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$),c( 1, k ), 1 )
                                       
                             call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$),f( 1, k ), 1 )
                                       
                          end do
                          do k = js, je
                             call stdlib_${ci}$scal( is-1, cmplx( scaloc, zero,KIND=${ck}$),c( 1, k ), 1 )
                                       
                             call stdlib_${ci}$scal( is-1, cmplx( scaloc, zero,KIND=${ck}$),f( 1, k ), 1 )
                                       
                          end do
                          do k = js, je
                             call stdlib_${ci}$scal( m-ie, cmplx( scaloc, zero,KIND=${ck}$),c( ie+1, k ), &
                                       1 )
                             call stdlib_${ci}$scal( m-ie, cmplx( scaloc, zero,KIND=${ck}$),f( ie+1, k ), &
                                       1 )
                          end do
                          do k = je + 1, n
                             call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$),c( 1, k ), 1 )
                                       
                             call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$),f( 1, k ), 1 )
                                       
                          end do
                          scale = scale*scaloc
                       end if
                       ! substitute r(i,j) and l(i,j) into remaining equation.
                       if( i>1 ) then
                          call stdlib_${ci}$gemm( 'N', 'N', is-1, nb, mb,cmplx( -one, zero,KIND=${ck}$), a(&
                           1, is ), lda,c( is, js ), ldc, cmplx( one, zero,KIND=${ck}$),c( 1, js ), &
                                     ldc )
                          call stdlib_${ci}$gemm( 'N', 'N', is-1, nb, mb,cmplx( -one, zero,KIND=${ck}$), d(&
                           1, is ), ldd,c( is, js ), ldc, cmplx( one, zero,KIND=${ck}$),f( 1, js ), &
                                     ldf )
                       end if
                       if( j<q ) then
                          call stdlib_${ci}$gemm( 'N', 'N', mb, n-je, nb,cmplx( one, zero,KIND=${ck}$), f( &
                          is, js ), ldf,b( js, je+1 ), ldb,cmplx( one, zero,KIND=${ck}$), c( is, je+1 &
                                    ),ldc )
                          call stdlib_${ci}$gemm( 'N', 'N', mb, n-je, nb,cmplx( one, zero,KIND=${ck}$), f( &
                          is, js ), ldf,e( js, je+1 ), lde,cmplx( one, zero,KIND=${ck}$), f( is, je+1 &
                                    ),ldf )
                       end if
                    end do loop_120
                 end do loop_130
                 if( dscale/=zero ) then
                    if( ijob==1 .or. ijob==3 ) then
                       dif = sqrt( real( 2*m*n,KIND=${ck}$) ) / ( dscale*sqrt( dsum ) )
                    else
                       dif = sqrt( real( pq,KIND=${ck}$) ) / ( dscale*sqrt( dsum ) )
                    end if
                 end if
                 if( isolve==2 .and. iround==1 ) then
                    if( notran ) then
                       ifunc = ijob
                    end if
                    scale2 = scale
                    call stdlib_${ci}$lacpy( 'F', m, n, c, ldc, work, m )
                    call stdlib_${ci}$lacpy( 'F', m, n, f, ldf, work( m*n+1 ), m )
                    call stdlib_${ci}$laset( 'F', m, n, czero, czero, c, ldc )
                    call stdlib_${ci}$laset( 'F', m, n, czero, czero, f, ldf )
                 else if( isolve==2 .and. iround==2 ) then
                    call stdlib_${ci}$lacpy( 'F', m, n, work, m, c, ldc )
                    call stdlib_${ci}$lacpy( 'F', m, n, work( m*n+1 ), m, f, ldf )
                    scale = scale2
                 end if
              end do loop_150
           else
              ! solve transposed (i, j)-subsystem
                  ! a(i, i)**h * r(i, j) + d(i, i)**h * l(i, j) = c(i, j)
                  ! r(i, j) * b(j, j)  + l(i, j) * e(j, j) = -f(i, j)
              ! for i = 1,2,..., p; j = q, q-1,..., 1
              scale = one
              loop_210: do i = 1, p
                 is = iwork( i )
                 ie = iwork( i+1 ) - 1
                 mb = ie - is + 1
                 loop_200: do j = q, p + 2, -1
                    js = iwork( j )
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    call stdlib_${ci}$tgsy2( trans, ifunc, mb, nb, a( is, is ), lda,b( js, js ), ldb, &
                    c( is, js ), ldc,d( is, is ), ldd, e( js, js ), lde,f( is, js ), ldf, scaloc, &
                              dsum, dscale,linfo )
                    if( linfo>0 )info = linfo
                    if( scaloc/=one ) then
                       do k = 1, js - 1
                          call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$), c( 1, k ),1 )
                                    
                          call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$), f( 1, k ),1 )
                                    
                       end do
                       do k = js, je
                          call stdlib_${ci}$scal( is-1, cmplx( scaloc, zero,KIND=${ck}$),c( 1, k ), 1 )
                                    
                          call stdlib_${ci}$scal( is-1, cmplx( scaloc, zero,KIND=${ck}$),f( 1, k ), 1 )
                                    
                       end do
                       do k = js, je
                          call stdlib_${ci}$scal( m-ie, cmplx( scaloc, zero,KIND=${ck}$),c( ie+1, k ), 1 )
                                    
                          call stdlib_${ci}$scal( m-ie, cmplx( scaloc, zero,KIND=${ck}$),f( ie+1, k ), 1 )
                                    
                       end do
                       do k = je + 1, n
                          call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$), c( 1, k ),1 )
                                    
                          call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$), f( 1, k ),1 )
                                    
                       end do
                       scale = scale*scaloc
                    end if
                    ! substitute r(i,j) and l(i,j) into remaining equation.
                    if( j>p+2 ) then
                       call stdlib_${ci}$gemm( 'N', 'C', mb, js-1, nb,cmplx( one, zero,KIND=${ck}$), c( is,&
                        js ), ldc,b( 1, js ), ldb, cmplx( one, zero,KIND=${ck}$),f( is, 1 ), ldf )
                                  
                       call stdlib_${ci}$gemm( 'N', 'C', mb, js-1, nb,cmplx( one, zero,KIND=${ck}$), f( is,&
                        js ), ldf,e( 1, js ), lde, cmplx( one, zero,KIND=${ck}$),f( is, 1 ), ldf )
                                  
                    end if
                    if( i<p ) then
                       call stdlib_${ci}$gemm( 'C', 'N', m-ie, nb, mb,cmplx( -one, zero,KIND=${ck}$), a( &
                       is, ie+1 ), lda,c( is, js ), ldc, cmplx( one, zero,KIND=${ck}$),c( ie+1, js ), &
                                 ldc )
                       call stdlib_${ci}$gemm( 'C', 'N', m-ie, nb, mb,cmplx( -one, zero,KIND=${ck}$), d( &
                       is, ie+1 ), ldd,f( is, js ), ldf, cmplx( one, zero,KIND=${ck}$),c( ie+1, js ), &
                                 ldc )
                    end if
                 end do loop_200
              end do loop_210
           end if
           work( 1 ) = lwmin
           return
     end subroutine stdlib_${ci}$tgsyl

#:endif
#:endfor



     module pure subroutine stdlib_stgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! STGSY2 solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C                (1)
     !! D * R - L * E = scale * F,
     !! using Level 1 and 2 BLAS. where R and L are unknown M-by-N matrices,
     !! (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
     !! N-by-N and M-by-N, respectively, with real entries. (A, D) and (B, E)
     !! must be in generalized Schur canonical form, i.e. A, B are upper
     !! quasi triangular and D, E are upper triangular. The solution (R, L)
     !! overwrites (C, F). 0 <= SCALE <= 1 is an output scaling factor
     !! chosen to avoid overflow.
     !! In matrix notation solving equation (1) corresponds to solve
     !! Z*x = scale*b, where Z is defined as
     !! Z = [ kron(In, A)  -kron(B**T, Im) ]             (2)
     !! [ kron(In, D)  -kron(E**T, Im) ],
     !! Ik is the identity matrix of size k and X**T is the transpose of X.
     !! kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! In the process of solving (1), we solve a number of such systems
     !! where Dim(In), Dim(In) = 1 or 2.
     !! If TRANS = 'T', solve the transposed system Z**T*y = scale*b for y,
     !! which is equivalent to solve for R and L in
     !! A**T * R  + D**T * L   = scale * C           (3)
     !! R  * B**T + L  * E**T  = scale * -F
     !! This case is used to compute an estimate of Dif[(A, D), (B, E)] =
     !! sigma_min(Z) using reverse communication with SLACON.
     !! STGSY2 also (IJOB >= 1) contributes to the computation in STGSYL
     !! of an upper bound on the separation between to matrix pairs. Then
     !! the input (A, D), (B, E) are sub-pencils of the matrix pair in
     !! STGSYL. See STGSYL for details.
               ldf, scale, rdsum, rdscal,iwork, pq, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(ilp), intent(out) :: info, pq
           real(sp), intent(inout) :: rdscal, rdsum
           real(sp), intent(out) :: scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(sp), intent(inout) :: c(ldc,*), f(ldf,*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_scopy by calls to stdlib_slaset.
        ! sven hammarling, 27/5/02.
           ! Parameters 
           integer(ilp), parameter :: ldz = 8
           
           
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: i, ie, ierr, ii, is, isp1, j, je, jj, js, jsp1, k, mb, nb, p, q, &
                     zdim
           real(sp) :: alpha, scaloc
           ! Local Arrays 
           integer(ilp) :: ipiv(ldz), jpiv(ldz)
           real(sp) :: rhs(ldz), z(ldz,ldz)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           ierr = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>2 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STGSY2', -info )
              return
           end if
           ! determine block structure of a
           pq = 0
           p = 0
           i = 1
           10 continue
           if( i>m )go to 20
           p = p + 1
           iwork( p ) = i
           if( i==m )go to 20
           if( a( i+1, i )/=zero ) then
              i = i + 2
           else
              i = i + 1
           end if
           go to 10
           20 continue
           iwork( p+1 ) = m + 1
           ! determine block structure of b
           q = p + 1
           j = 1
           30 continue
           if( j>n )go to 40
           q = q + 1
           iwork( q ) = j
           if( j==n )go to 40
           if( b( j+1, j )/=zero ) then
              j = j + 2
           else
              j = j + 1
           end if
           go to 30
           40 continue
           iwork( q+1 ) = n + 1
           pq = p*( q-p-1 )
           if( notran ) then
              ! solve (i, j) - subsystem
                 ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                 ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
              ! for i = p, p - 1, ..., 1; j = 1, 2, ..., q
              scale = one
              scaloc = one
              loop_120: do j = p + 2, q
                 js = iwork( j )
                 jsp1 = js + 1
                 je = iwork( j+1 ) - 1
                 nb = je - js + 1
                 loop_110: do i = p, 1, -1
                    is = iwork( i )
                    isp1 = is + 1
                    ie = iwork( i+1 ) - 1
                    mb = ie - is + 1
                    zdim = mb*nb*2
                    if( ( mb==1 ) .and. ( nb==1 ) ) then
                       ! build a 2-by-2 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = d( is, is )
                       z( 1, 2 ) = -b( js, js )
                       z( 2, 2 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = f( is, js )
                       ! solve z * x = rhs
                       call stdlib_sgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_sgesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_slatdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       f( is, js ) = rhs( 2 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          alpha = -rhs( 1 )
                          call stdlib_saxpy( is-1, alpha, a( 1, is ), 1, c( 1, js ),1 )
                          call stdlib_saxpy( is-1, alpha, d( 1, is ), 1, f( 1, js ),1 )
                       end if
                       if( j<q ) then
                          call stdlib_saxpy( n-je, rhs( 2 ), b( js, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_saxpy( n-je, rhs( 2 ), e( js, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                       end if
                    else if( ( mb==1 ) .and. ( nb==2 ) ) then
                       ! build a 4-by-4 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = zero
                       z( 3, 1 ) = d( is, is )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = zero
                       z( 2, 2 ) = a( is, is )
                       z( 3, 2 ) = zero
                       z( 4, 2 ) = d( is, is )
                       z( 1, 3 ) = -b( js, js )
                       z( 2, 3 ) = -b( js, jsp1 )
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = -e( js, jsp1 )
                       z( 1, 4 ) = -b( jsp1, js )
                       z( 2, 4 ) = -b( jsp1, jsp1 )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( is, jsp1 )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( is, jsp1 )
                       ! solve z * x = rhs
                       call stdlib_sgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_sgesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_slatdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( is, jsp1 ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( is, jsp1 ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_sger( is-1, nb, -one, a( 1, is ), 1, rhs( 1 ),1, c( 1, js ),&
                                     ldc )
                          call stdlib_sger( is-1, nb, -one, d( 1, is ), 1, rhs( 1 ),1, f( 1, js ),&
                                     ldf )
                       end if
                       if( j<q ) then
                          call stdlib_saxpy( n-je, rhs( 3 ), b( js, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_saxpy( n-je, rhs( 3 ), e( js, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                          call stdlib_saxpy( n-je, rhs( 4 ), b( jsp1, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_saxpy( n-je, rhs( 4 ), e( jsp1, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                       end if
                    else if( ( mb==2 ) .and. ( nb==1 ) ) then
                       ! build a 4-by-4 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( isp1, is )
                       z( 3, 1 ) = d( is, is )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = a( is, isp1 )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 3, 2 ) = d( is, isp1 )
                       z( 4, 2 ) = d( isp1, isp1 )
                       z( 1, 3 ) = -b( js, js )
                       z( 2, 3 ) = zero
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = -b( js, js )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( isp1, js )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( isp1, js )
                       ! solve z * x = rhs
                       call stdlib_sgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_sgesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_slatdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( isp1, js ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( isp1, js ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_sgemv( 'N', is-1, mb, -one, a( 1, is ), lda,rhs( 1 ), 1, &
                                    one, c( 1, js ), 1 )
                          call stdlib_sgemv( 'N', is-1, mb, -one, d( 1, is ), ldd,rhs( 1 ), 1, &
                                    one, f( 1, js ), 1 )
                       end if
                       if( j<q ) then
                          call stdlib_sger( mb, n-je, one, rhs( 3 ), 1,b( js, je+1 ), ldb, c( is, &
                                    je+1 ), ldc )
                          call stdlib_sger( mb, n-je, one, rhs( 3 ), 1,e( js, je+1 ), lde, f( is, &
                                    je+1 ), ldf )
                       end if
                    else if( ( mb==2 ) .and. ( nb==2 ) ) then
                       ! build an 8-by-8 system z * x = rhs
                       call stdlib_slaset( 'F', ldz, ldz, zero, zero, z, ldz )
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( isp1, is )
                       z( 5, 1 ) = d( is, is )
                       z( 1, 2 ) = a( is, isp1 )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 5, 2 ) = d( is, isp1 )
                       z( 6, 2 ) = d( isp1, isp1 )
                       z( 3, 3 ) = a( is, is )
                       z( 4, 3 ) = a( isp1, is )
                       z( 7, 3 ) = d( is, is )
                       z( 3, 4 ) = a( is, isp1 )
                       z( 4, 4 ) = a( isp1, isp1 )
                       z( 7, 4 ) = d( is, isp1 )
                       z( 8, 4 ) = d( isp1, isp1 )
                       z( 1, 5 ) = -b( js, js )
                       z( 3, 5 ) = -b( js, jsp1 )
                       z( 5, 5 ) = -e( js, js )
                       z( 7, 5 ) = -e( js, jsp1 )
                       z( 2, 6 ) = -b( js, js )
                       z( 4, 6 ) = -b( js, jsp1 )
                       z( 6, 6 ) = -e( js, js )
                       z( 8, 6 ) = -e( js, jsp1 )
                       z( 1, 7 ) = -b( jsp1, js )
                       z( 3, 7 ) = -b( jsp1, jsp1 )
                       z( 7, 7 ) = -e( jsp1, jsp1 )
                       z( 2, 8 ) = -b( jsp1, js )
                       z( 4, 8 ) = -b( jsp1, jsp1 )
                       z( 8, 8 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_scopy( mb, c( is, js+jj ), 1, rhs( k ), 1 )
                          call stdlib_scopy( mb, f( is, js+jj ), 1, rhs( ii ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! solve z * x = rhs
                       call stdlib_sgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_sgesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_slatdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_scopy( mb, rhs( k ), 1, c( is, js+jj ), 1 )
                          call stdlib_scopy( mb, rhs( ii ), 1, f( is, js+jj ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_sgemm( 'N', 'N', is-1, nb, mb, -one,a( 1, is ), lda, rhs( 1 &
                                    ), mb, one,c( 1, js ), ldc )
                          call stdlib_sgemm( 'N', 'N', is-1, nb, mb, -one,d( 1, is ), ldd, rhs( 1 &
                                    ), mb, one,f( 1, js ), ldf )
                       end if
                       if( j<q ) then
                          k = mb*nb + 1
                          call stdlib_sgemm( 'N', 'N', mb, n-je, nb, one, rhs( k ),mb, b( js, je+&
                                    1 ), ldb, one,c( is, je+1 ), ldc )
                          call stdlib_sgemm( 'N', 'N', mb, n-je, nb, one, rhs( k ),mb, e( js, je+&
                                    1 ), lde, one,f( is, je+1 ), ldf )
                       end if
                    end if
                 end do loop_110
              end do loop_120
           else
              ! solve (i, j) - subsystem
                   ! a(i, i)**t * r(i, j) + d(i, i)**t * l(j, j)  =  c(i, j)
                   ! r(i, i)  * b(j, j) + l(i, j)  * e(j, j)  = -f(i, j)
              ! for i = 1, 2, ..., p, j = q, q - 1, ..., 1
              scale = one
              scaloc = one
              loop_200: do i = 1, p
                 is = iwork( i )
                 isp1 = is + 1
                 ie = iwork( i+1 ) - 1
                 mb = ie - is + 1
                 loop_190: do j = q, p + 2, -1
                    js = iwork( j )
                    jsp1 = js + 1
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    zdim = mb*nb*2
                    if( ( mb==1 ) .and. ( nb==1 ) ) then
                       ! build a 2-by-2 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = -b( js, js )
                       z( 1, 2 ) = d( is, is )
                       z( 2, 2 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = f( is, js )
                       ! solve z**t * x = rhs
                       call stdlib_sgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_sgesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       f( is, js ) = rhs( 2 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          alpha = rhs( 1 )
                          call stdlib_saxpy( js-1, alpha, b( 1, js ), 1, f( is, 1 ),ldf )
                          alpha = rhs( 2 )
                          call stdlib_saxpy( js-1, alpha, e( 1, js ), 1, f( is, 1 ),ldf )
                       end if
                       if( i<p ) then
                          alpha = -rhs( 1 )
                          call stdlib_saxpy( m-ie, alpha, a( is, ie+1 ), lda,c( ie+1, js ), 1 )
                                    
                          alpha = -rhs( 2 )
                          call stdlib_saxpy( m-ie, alpha, d( is, ie+1 ), ldd,c( ie+1, js ), 1 )
                                    
                       end if
                    else if( ( mb==1 ) .and. ( nb==2 ) ) then
                       ! build a 4-by-4 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = zero
                       z( 3, 1 ) = -b( js, js )
                       z( 4, 1 ) = -b( jsp1, js )
                       z( 1, 2 ) = zero
                       z( 2, 2 ) = a( is, is )
                       z( 3, 2 ) = -b( js, jsp1 )
                       z( 4, 2 ) = -b( jsp1, jsp1 )
                       z( 1, 3 ) = d( is, is )
                       z( 2, 3 ) = zero
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = d( is, is )
                       z( 3, 4 ) = -e( js, jsp1 )
                       z( 4, 4 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( is, jsp1 )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( is, jsp1 )
                       ! solve z**t * x = rhs
                       call stdlib_sgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_sgesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( is, jsp1 ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( is, jsp1 ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_saxpy( js-1, rhs( 1 ), b( 1, js ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_saxpy( js-1, rhs( 2 ), b( 1, jsp1 ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_saxpy( js-1, rhs( 3 ), e( 1, js ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_saxpy( js-1, rhs( 4 ), e( 1, jsp1 ), 1,f( is, 1 ), ldf )
                                    
                       end if
                       if( i<p ) then
                          call stdlib_sger( m-ie, nb, -one, a( is, ie+1 ), lda,rhs( 1 ), 1, c( ie+&
                                    1, js ), ldc )
                          call stdlib_sger( m-ie, nb, -one, d( is, ie+1 ), ldd,rhs( 3 ), 1, c( ie+&
                                    1, js ), ldc )
                       end if
                    else if( ( mb==2 ) .and. ( nb==1 ) ) then
                       ! build a 4-by-4 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( is, isp1 )
                       z( 3, 1 ) = -b( js, js )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = a( isp1, is )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 3, 2 ) = zero
                       z( 4, 2 ) = -b( js, js )
                       z( 1, 3 ) = d( is, is )
                       z( 2, 3 ) = d( is, isp1 )
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = d( isp1, isp1 )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( isp1, js )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( isp1, js )
                       ! solve z**t * x = rhs
                       call stdlib_sgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_sgesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( isp1, js ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( isp1, js ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_sger( mb, js-1, one, rhs( 1 ), 1, b( 1, js ),1, f( is, 1 ), &
                                    ldf )
                          call stdlib_sger( mb, js-1, one, rhs( 3 ), 1, e( 1, js ),1, f( is, 1 ), &
                                    ldf )
                       end if
                       if( i<p ) then
                          call stdlib_sgemv( 'T', mb, m-ie, -one, a( is, ie+1 ),lda, rhs( 1 ), 1, &
                                    one, c( ie+1, js ),1 )
                          call stdlib_sgemv( 'T', mb, m-ie, -one, d( is, ie+1 ),ldd, rhs( 3 ), 1, &
                                    one, c( ie+1, js ),1 )
                       end if
                    else if( ( mb==2 ) .and. ( nb==2 ) ) then
                       ! build an 8-by-8 system z**t * x = rhs
                       call stdlib_slaset( 'F', ldz, ldz, zero, zero, z, ldz )
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( is, isp1 )
                       z( 5, 1 ) = -b( js, js )
                       z( 7, 1 ) = -b( jsp1, js )
                       z( 1, 2 ) = a( isp1, is )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 6, 2 ) = -b( js, js )
                       z( 8, 2 ) = -b( jsp1, js )
                       z( 3, 3 ) = a( is, is )
                       z( 4, 3 ) = a( is, isp1 )
                       z( 5, 3 ) = -b( js, jsp1 )
                       z( 7, 3 ) = -b( jsp1, jsp1 )
                       z( 3, 4 ) = a( isp1, is )
                       z( 4, 4 ) = a( isp1, isp1 )
                       z( 6, 4 ) = -b( js, jsp1 )
                       z( 8, 4 ) = -b( jsp1, jsp1 )
                       z( 1, 5 ) = d( is, is )
                       z( 2, 5 ) = d( is, isp1 )
                       z( 5, 5 ) = -e( js, js )
                       z( 2, 6 ) = d( isp1, isp1 )
                       z( 6, 6 ) = -e( js, js )
                       z( 3, 7 ) = d( is, is )
                       z( 4, 7 ) = d( is, isp1 )
                       z( 5, 7 ) = -e( js, jsp1 )
                       z( 7, 7 ) = -e( jsp1, jsp1 )
                       z( 4, 8 ) = d( isp1, isp1 )
                       z( 6, 8 ) = -e( js, jsp1 )
                       z( 8, 8 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_scopy( mb, c( is, js+jj ), 1, rhs( k ), 1 )
                          call stdlib_scopy( mb, f( is, js+jj ), 1, rhs( ii ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! solve z**t * x = rhs
                       call stdlib_sgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_sgesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_sscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_sscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_scopy( mb, rhs( k ), 1, c( is, js+jj ), 1 )
                          call stdlib_scopy( mb, rhs( ii ), 1, f( is, js+jj ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_sgemm( 'N', 'T', mb, js-1, nb, one,c( is, js ), ldc, b( 1, &
                                    js ), ldb, one,f( is, 1 ), ldf )
                          call stdlib_sgemm( 'N', 'T', mb, js-1, nb, one,f( is, js ), ldf, e( 1, &
                                    js ), lde, one,f( is, 1 ), ldf )
                       end if
                       if( i<p ) then
                          call stdlib_sgemm( 'T', 'N', m-ie, nb, mb, -one,a( is, ie+1 ), lda, c( &
                                    is, js ), ldc,one, c( ie+1, js ), ldc )
                          call stdlib_sgemm( 'T', 'N', m-ie, nb, mb, -one,d( is, ie+1 ), ldd, f( &
                                    is, js ), ldf,one, c( ie+1, js ), ldc )
                       end if
                    end if
                 end do loop_190
              end do loop_200
           end if
           return
     end subroutine stdlib_stgsy2

     module pure subroutine stdlib_dtgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! DTGSY2 solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C                (1)
     !! D * R - L * E = scale * F,
     !! using Level 1 and 2 BLAS. where R and L are unknown M-by-N matrices,
     !! (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
     !! N-by-N and M-by-N, respectively, with real entries. (A, D) and (B, E)
     !! must be in generalized Schur canonical form, i.e. A, B are upper
     !! quasi triangular and D, E are upper triangular. The solution (R, L)
     !! overwrites (C, F). 0 <= SCALE <= 1 is an output scaling factor
     !! chosen to avoid overflow.
     !! In matrix notation solving equation (1) corresponds to solve
     !! Z*x = scale*b, where Z is defined as
     !! Z = [ kron(In, A)  -kron(B**T, Im) ]             (2)
     !! [ kron(In, D)  -kron(E**T, Im) ],
     !! Ik is the identity matrix of size k and X**T is the transpose of X.
     !! kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! In the process of solving (1), we solve a number of such systems
     !! where Dim(In), Dim(In) = 1 or 2.
     !! If TRANS = 'T', solve the transposed system Z**T*y = scale*b for y,
     !! which is equivalent to solve for R and L in
     !! A**T * R  + D**T * L   = scale * C           (3)
     !! R  * B**T + L  * E**T  = scale * -F
     !! This case is used to compute an estimate of Dif[(A, D), (B, E)] =
     !! sigma_min(Z) using reverse communication with DLACON.
     !! DTGSY2 also (IJOB >= 1) contributes to the computation in DTGSYL
     !! of an upper bound on the separation between to matrix pairs. Then
     !! the input (A, D), (B, E) are sub-pencils of the matrix pair in
     !! DTGSYL. See DTGSYL for details.
               ldf, scale, rdsum, rdscal,iwork, pq, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(ilp), intent(out) :: info, pq
           real(dp), intent(inout) :: rdscal, rdsum
           real(dp), intent(out) :: scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(dp), intent(inout) :: c(ldc,*), f(ldf,*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_dcopy by calls to stdlib_dlaset.
        ! sven hammarling, 27/5/02.
           ! Parameters 
           integer(ilp), parameter :: ldz = 8
           
           
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: i, ie, ierr, ii, is, isp1, j, je, jj, js, jsp1, k, mb, nb, p, q, &
                     zdim
           real(dp) :: alpha, scaloc
           ! Local Arrays 
           integer(ilp) :: ipiv(ldz), jpiv(ldz)
           real(dp) :: rhs(ldz), z(ldz,ldz)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           ierr = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>2 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSY2', -info )
              return
           end if
           ! determine block structure of a
           pq = 0
           p = 0
           i = 1
           10 continue
           if( i>m )go to 20
           p = p + 1
           iwork( p ) = i
           if( i==m )go to 20
           if( a( i+1, i )/=zero ) then
              i = i + 2
           else
              i = i + 1
           end if
           go to 10
           20 continue
           iwork( p+1 ) = m + 1
           ! determine block structure of b
           q = p + 1
           j = 1
           30 continue
           if( j>n )go to 40
           q = q + 1
           iwork( q ) = j
           if( j==n )go to 40
           if( b( j+1, j )/=zero ) then
              j = j + 2
           else
              j = j + 1
           end if
           go to 30
           40 continue
           iwork( q+1 ) = n + 1
           pq = p*( q-p-1 )
           if( notran ) then
              ! solve (i, j) - subsystem
                 ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                 ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
              ! for i = p, p - 1, ..., 1; j = 1, 2, ..., q
              scale = one
              scaloc = one
              loop_120: do j = p + 2, q
                 js = iwork( j )
                 jsp1 = js + 1
                 je = iwork( j+1 ) - 1
                 nb = je - js + 1
                 loop_110: do i = p, 1, -1
                    is = iwork( i )
                    isp1 = is + 1
                    ie = iwork( i+1 ) - 1
                    mb = ie - is + 1
                    zdim = mb*nb*2
                    if( ( mb==1 ) .and. ( nb==1 ) ) then
                       ! build a 2-by-2 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = d( is, is )
                       z( 1, 2 ) = -b( js, js )
                       z( 2, 2 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = f( is, js )
                       ! solve z * x = rhs
                       call stdlib_dgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_dgesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_dlatdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       f( is, js ) = rhs( 2 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          alpha = -rhs( 1 )
                          call stdlib_daxpy( is-1, alpha, a( 1, is ), 1, c( 1, js ),1 )
                          call stdlib_daxpy( is-1, alpha, d( 1, is ), 1, f( 1, js ),1 )
                       end if
                       if( j<q ) then
                          call stdlib_daxpy( n-je, rhs( 2 ), b( js, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_daxpy( n-je, rhs( 2 ), e( js, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                       end if
                    else if( ( mb==1 ) .and. ( nb==2 ) ) then
                       ! build a 4-by-4 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = zero
                       z( 3, 1 ) = d( is, is )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = zero
                       z( 2, 2 ) = a( is, is )
                       z( 3, 2 ) = zero
                       z( 4, 2 ) = d( is, is )
                       z( 1, 3 ) = -b( js, js )
                       z( 2, 3 ) = -b( js, jsp1 )
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = -e( js, jsp1 )
                       z( 1, 4 ) = -b( jsp1, js )
                       z( 2, 4 ) = -b( jsp1, jsp1 )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( is, jsp1 )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( is, jsp1 )
                       ! solve z * x = rhs
                       call stdlib_dgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_dgesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_dlatdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( is, jsp1 ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( is, jsp1 ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_dger( is-1, nb, -one, a( 1, is ), 1, rhs( 1 ),1, c( 1, js ),&
                                     ldc )
                          call stdlib_dger( is-1, nb, -one, d( 1, is ), 1, rhs( 1 ),1, f( 1, js ),&
                                     ldf )
                       end if
                       if( j<q ) then
                          call stdlib_daxpy( n-je, rhs( 3 ), b( js, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_daxpy( n-je, rhs( 3 ), e( js, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                          call stdlib_daxpy( n-je, rhs( 4 ), b( jsp1, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_daxpy( n-je, rhs( 4 ), e( jsp1, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                       end if
                    else if( ( mb==2 ) .and. ( nb==1 ) ) then
                       ! build a 4-by-4 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( isp1, is )
                       z( 3, 1 ) = d( is, is )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = a( is, isp1 )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 3, 2 ) = d( is, isp1 )
                       z( 4, 2 ) = d( isp1, isp1 )
                       z( 1, 3 ) = -b( js, js )
                       z( 2, 3 ) = zero
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = -b( js, js )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( isp1, js )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( isp1, js )
                       ! solve z * x = rhs
                       call stdlib_dgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_dgesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_dlatdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( isp1, js ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( isp1, js ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_dgemv( 'N', is-1, mb, -one, a( 1, is ), lda,rhs( 1 ), 1, &
                                    one, c( 1, js ), 1 )
                          call stdlib_dgemv( 'N', is-1, mb, -one, d( 1, is ), ldd,rhs( 1 ), 1, &
                                    one, f( 1, js ), 1 )
                       end if
                       if( j<q ) then
                          call stdlib_dger( mb, n-je, one, rhs( 3 ), 1,b( js, je+1 ), ldb, c( is, &
                                    je+1 ), ldc )
                          call stdlib_dger( mb, n-je, one, rhs( 3 ), 1,e( js, je+1 ), lde, f( is, &
                                    je+1 ), ldf )
                       end if
                    else if( ( mb==2 ) .and. ( nb==2 ) ) then
                       ! build an 8-by-8 system z * x = rhs
                       call stdlib_dlaset( 'F', ldz, ldz, zero, zero, z, ldz )
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( isp1, is )
                       z( 5, 1 ) = d( is, is )
                       z( 1, 2 ) = a( is, isp1 )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 5, 2 ) = d( is, isp1 )
                       z( 6, 2 ) = d( isp1, isp1 )
                       z( 3, 3 ) = a( is, is )
                       z( 4, 3 ) = a( isp1, is )
                       z( 7, 3 ) = d( is, is )
                       z( 3, 4 ) = a( is, isp1 )
                       z( 4, 4 ) = a( isp1, isp1 )
                       z( 7, 4 ) = d( is, isp1 )
                       z( 8, 4 ) = d( isp1, isp1 )
                       z( 1, 5 ) = -b( js, js )
                       z( 3, 5 ) = -b( js, jsp1 )
                       z( 5, 5 ) = -e( js, js )
                       z( 7, 5 ) = -e( js, jsp1 )
                       z( 2, 6 ) = -b( js, js )
                       z( 4, 6 ) = -b( js, jsp1 )
                       z( 6, 6 ) = -e( js, js )
                       z( 8, 6 ) = -e( js, jsp1 )
                       z( 1, 7 ) = -b( jsp1, js )
                       z( 3, 7 ) = -b( jsp1, jsp1 )
                       z( 7, 7 ) = -e( jsp1, jsp1 )
                       z( 2, 8 ) = -b( jsp1, js )
                       z( 4, 8 ) = -b( jsp1, jsp1 )
                       z( 8, 8 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_dcopy( mb, c( is, js+jj ), 1, rhs( k ), 1 )
                          call stdlib_dcopy( mb, f( is, js+jj ), 1, rhs( ii ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! solve z * x = rhs
                       call stdlib_dgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_dgesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_dlatdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_dcopy( mb, rhs( k ), 1, c( is, js+jj ), 1 )
                          call stdlib_dcopy( mb, rhs( ii ), 1, f( is, js+jj ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_dgemm( 'N', 'N', is-1, nb, mb, -one,a( 1, is ), lda, rhs( 1 &
                                    ), mb, one,c( 1, js ), ldc )
                          call stdlib_dgemm( 'N', 'N', is-1, nb, mb, -one,d( 1, is ), ldd, rhs( 1 &
                                    ), mb, one,f( 1, js ), ldf )
                       end if
                       if( j<q ) then
                          k = mb*nb + 1
                          call stdlib_dgemm( 'N', 'N', mb, n-je, nb, one, rhs( k ),mb, b( js, je+&
                                    1 ), ldb, one,c( is, je+1 ), ldc )
                          call stdlib_dgemm( 'N', 'N', mb, n-je, nb, one, rhs( k ),mb, e( js, je+&
                                    1 ), lde, one,f( is, je+1 ), ldf )
                       end if
                    end if
                 end do loop_110
              end do loop_120
           else
              ! solve (i, j) - subsystem
                   ! a(i, i)**t * r(i, j) + d(i, i)**t * l(j, j)  =  c(i, j)
                   ! r(i, i)  * b(j, j) + l(i, j)  * e(j, j)  = -f(i, j)
              ! for i = 1, 2, ..., p, j = q, q - 1, ..., 1
              scale = one
              scaloc = one
              loop_200: do i = 1, p
                 is = iwork( i )
                 isp1 = is + 1
                 ie = iwork ( i+1 ) - 1
                 mb = ie - is + 1
                 loop_190: do j = q, p + 2, -1
                    js = iwork( j )
                    jsp1 = js + 1
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    zdim = mb*nb*2
                    if( ( mb==1 ) .and. ( nb==1 ) ) then
                       ! build a 2-by-2 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = -b( js, js )
                       z( 1, 2 ) = d( is, is )
                       z( 2, 2 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = f( is, js )
                       ! solve z**t * x = rhs
                       call stdlib_dgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_dgesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       f( is, js ) = rhs( 2 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          alpha = rhs( 1 )
                          call stdlib_daxpy( js-1, alpha, b( 1, js ), 1, f( is, 1 ),ldf )
                          alpha = rhs( 2 )
                          call stdlib_daxpy( js-1, alpha, e( 1, js ), 1, f( is, 1 ),ldf )
                       end if
                       if( i<p ) then
                          alpha = -rhs( 1 )
                          call stdlib_daxpy( m-ie, alpha, a( is, ie+1 ), lda,c( ie+1, js ), 1 )
                                    
                          alpha = -rhs( 2 )
                          call stdlib_daxpy( m-ie, alpha, d( is, ie+1 ), ldd,c( ie+1, js ), 1 )
                                    
                       end if
                    else if( ( mb==1 ) .and. ( nb==2 ) ) then
                       ! build a 4-by-4 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = zero
                       z( 3, 1 ) = -b( js, js )
                       z( 4, 1 ) = -b( jsp1, js )
                       z( 1, 2 ) = zero
                       z( 2, 2 ) = a( is, is )
                       z( 3, 2 ) = -b( js, jsp1 )
                       z( 4, 2 ) = -b( jsp1, jsp1 )
                       z( 1, 3 ) = d( is, is )
                       z( 2, 3 ) = zero
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = d( is, is )
                       z( 3, 4 ) = -e( js, jsp1 )
                       z( 4, 4 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( is, jsp1 )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( is, jsp1 )
                       ! solve z**t * x = rhs
                       call stdlib_dgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_dgesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( is, jsp1 ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( is, jsp1 ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_daxpy( js-1, rhs( 1 ), b( 1, js ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_daxpy( js-1, rhs( 2 ), b( 1, jsp1 ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_daxpy( js-1, rhs( 3 ), e( 1, js ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_daxpy( js-1, rhs( 4 ), e( 1, jsp1 ), 1,f( is, 1 ), ldf )
                                    
                       end if
                       if( i<p ) then
                          call stdlib_dger( m-ie, nb, -one, a( is, ie+1 ), lda,rhs( 1 ), 1, c( ie+&
                                    1, js ), ldc )
                          call stdlib_dger( m-ie, nb, -one, d( is, ie+1 ), ldd,rhs( 3 ), 1, c( ie+&
                                    1, js ), ldc )
                       end if
                    else if( ( mb==2 ) .and. ( nb==1 ) ) then
                       ! build a 4-by-4 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( is, isp1 )
                       z( 3, 1 ) = -b( js, js )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = a( isp1, is )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 3, 2 ) = zero
                       z( 4, 2 ) = -b( js, js )
                       z( 1, 3 ) = d( is, is )
                       z( 2, 3 ) = d( is, isp1 )
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = d( isp1, isp1 )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( isp1, js )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( isp1, js )
                       ! solve z**t * x = rhs
                       call stdlib_dgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_dgesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( isp1, js ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( isp1, js ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_dger( mb, js-1, one, rhs( 1 ), 1, b( 1, js ),1, f( is, 1 ), &
                                    ldf )
                          call stdlib_dger( mb, js-1, one, rhs( 3 ), 1, e( 1, js ),1, f( is, 1 ), &
                                    ldf )
                       end if
                       if( i<p ) then
                          call stdlib_dgemv( 'T', mb, m-ie, -one, a( is, ie+1 ),lda, rhs( 1 ), 1, &
                                    one, c( ie+1, js ),1 )
                          call stdlib_dgemv( 'T', mb, m-ie, -one, d( is, ie+1 ),ldd, rhs( 3 ), 1, &
                                    one, c( ie+1, js ),1 )
                       end if
                    else if( ( mb==2 ) .and. ( nb==2 ) ) then
                       ! build an 8-by-8 system z**t * x = rhs
                       call stdlib_dlaset( 'F', ldz, ldz, zero, zero, z, ldz )
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( is, isp1 )
                       z( 5, 1 ) = -b( js, js )
                       z( 7, 1 ) = -b( jsp1, js )
                       z( 1, 2 ) = a( isp1, is )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 6, 2 ) = -b( js, js )
                       z( 8, 2 ) = -b( jsp1, js )
                       z( 3, 3 ) = a( is, is )
                       z( 4, 3 ) = a( is, isp1 )
                       z( 5, 3 ) = -b( js, jsp1 )
                       z( 7, 3 ) = -b( jsp1, jsp1 )
                       z( 3, 4 ) = a( isp1, is )
                       z( 4, 4 ) = a( isp1, isp1 )
                       z( 6, 4 ) = -b( js, jsp1 )
                       z( 8, 4 ) = -b( jsp1, jsp1 )
                       z( 1, 5 ) = d( is, is )
                       z( 2, 5 ) = d( is, isp1 )
                       z( 5, 5 ) = -e( js, js )
                       z( 2, 6 ) = d( isp1, isp1 )
                       z( 6, 6 ) = -e( js, js )
                       z( 3, 7 ) = d( is, is )
                       z( 4, 7 ) = d( is, isp1 )
                       z( 5, 7 ) = -e( js, jsp1 )
                       z( 7, 7 ) = -e( jsp1, jsp1 )
                       z( 4, 8 ) = d( isp1, isp1 )
                       z( 6, 8 ) = -e( js, jsp1 )
                       z( 8, 8 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_dcopy( mb, c( is, js+jj ), 1, rhs( k ), 1 )
                          call stdlib_dcopy( mb, f( is, js+jj ), 1, rhs( ii ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! solve z**t * x = rhs
                       call stdlib_dgetc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_dgesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_dscal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_dscal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_dcopy( mb, rhs( k ), 1, c( is, js+jj ), 1 )
                          call stdlib_dcopy( mb, rhs( ii ), 1, f( is, js+jj ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_dgemm( 'N', 'T', mb, js-1, nb, one,c( is, js ), ldc, b( 1, &
                                    js ), ldb, one,f( is, 1 ), ldf )
                          call stdlib_dgemm( 'N', 'T', mb, js-1, nb, one,f( is, js ), ldf, e( 1, &
                                    js ), lde, one,f( is, 1 ), ldf )
                       end if
                       if( i<p ) then
                          call stdlib_dgemm( 'T', 'N', m-ie, nb, mb, -one,a( is, ie+1 ), lda, c( &
                                    is, js ), ldc,one, c( ie+1, js ), ldc )
                          call stdlib_dgemm( 'T', 'N', m-ie, nb, mb, -one,d( is, ie+1 ), ldd, f( &
                                    is, js ), ldf,one, c( ie+1, js ), ldc )
                       end if
                    end if
                 end do loop_190
              end do loop_200
           end if
           return
     end subroutine stdlib_dtgsy2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$tgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! DTGSY2: solves the generalized Sylvester equation:
     !! A * R - L * B = scale * C                (1)
     !! D * R - L * E = scale * F,
     !! using Level 1 and 2 BLAS. where R and L are unknown M-by-N matrices,
     !! (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
     !! N-by-N and M-by-N, respectively, with real entries. (A, D) and (B, E)
     !! must be in generalized Schur canonical form, i.e. A, B are upper
     !! quasi triangular and D, E are upper triangular. The solution (R, L)
     !! overwrites (C, F). 0 <= SCALE <= 1 is an output scaling factor
     !! chosen to avoid overflow.
     !! In matrix notation solving equation (1) corresponds to solve
     !! Z*x = scale*b, where Z is defined as
     !! Z = [ kron(In, A)  -kron(B**T, Im) ]             (2)
     !! [ kron(In, D)  -kron(E**T, Im) ],
     !! Ik is the identity matrix of size k and X**T is the transpose of X.
     !! kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! In the process of solving (1), we solve a number of such systems
     !! where Dim(In), Dim(In) = 1 or 2.
     !! If TRANS = 'T', solve the transposed system Z**T*y = scale*b for y,
     !! which is equivalent to solve for R and L in
     !! A**T * R  + D**T * L   = scale * C           (3)
     !! R  * B**T + L  * E**T  = scale * -F
     !! This case is used to compute an estimate of Dif[(A, D), (B, E)] =
     !! sigma_min(Z) using reverse communication with DLACON.
     !! DTGSY2 also (IJOB >= 1) contributes to the computation in DTGSYL
     !! of an upper bound on the separation between to matrix pairs. Then
     !! the input (A, D), (B, E) are sub-pencils of the matrix pair in
     !! DTGSYL. See DTGSYL for details.
               ldf, scale, rdsum, rdscal,iwork, pq, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(ilp), intent(out) :: info, pq
           real(${rk}$), intent(inout) :: rdscal, rdsum
           real(${rk}$), intent(out) :: scale
           ! Array Arguments 
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           real(${rk}$), intent(inout) :: c(ldc,*), f(ldf,*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_${ri}$copy by calls to stdlib_${ri}$laset.
        ! sven hammarling, 27/5/02.
           ! Parameters 
           integer(ilp), parameter :: ldz = 8
           
           
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: i, ie, ierr, ii, is, isp1, j, je, jj, js, jsp1, k, mb, nb, p, q, &
                     zdim
           real(${rk}$) :: alpha, scaloc
           ! Local Arrays 
           integer(ilp) :: ipiv(ldz), jpiv(ldz)
           real(${rk}$) :: rhs(ldz), z(ldz,ldz)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           ierr = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'T' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>2 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSY2', -info )
              return
           end if
           ! determine block structure of a
           pq = 0
           p = 0
           i = 1
           10 continue
           if( i>m )go to 20
           p = p + 1
           iwork( p ) = i
           if( i==m )go to 20
           if( a( i+1, i )/=zero ) then
              i = i + 2
           else
              i = i + 1
           end if
           go to 10
           20 continue
           iwork( p+1 ) = m + 1
           ! determine block structure of b
           q = p + 1
           j = 1
           30 continue
           if( j>n )go to 40
           q = q + 1
           iwork( q ) = j
           if( j==n )go to 40
           if( b( j+1, j )/=zero ) then
              j = j + 2
           else
              j = j + 1
           end if
           go to 30
           40 continue
           iwork( q+1 ) = n + 1
           pq = p*( q-p-1 )
           if( notran ) then
              ! solve (i, j) - subsystem
                 ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                 ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
              ! for i = p, p - 1, ..., 1; j = 1, 2, ..., q
              scale = one
              scaloc = one
              loop_120: do j = p + 2, q
                 js = iwork( j )
                 jsp1 = js + 1
                 je = iwork( j+1 ) - 1
                 nb = je - js + 1
                 loop_110: do i = p, 1, -1
                    is = iwork( i )
                    isp1 = is + 1
                    ie = iwork( i+1 ) - 1
                    mb = ie - is + 1
                    zdim = mb*nb*2
                    if( ( mb==1 ) .and. ( nb==1 ) ) then
                       ! build a 2-by-2 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = d( is, is )
                       z( 1, 2 ) = -b( js, js )
                       z( 2, 2 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = f( is, js )
                       ! solve z * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_${ri}$latdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       f( is, js ) = rhs( 2 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          alpha = -rhs( 1 )
                          call stdlib_${ri}$axpy( is-1, alpha, a( 1, is ), 1, c( 1, js ),1 )
                          call stdlib_${ri}$axpy( is-1, alpha, d( 1, is ), 1, f( 1, js ),1 )
                       end if
                       if( j<q ) then
                          call stdlib_${ri}$axpy( n-je, rhs( 2 ), b( js, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_${ri}$axpy( n-je, rhs( 2 ), e( js, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                       end if
                    else if( ( mb==1 ) .and. ( nb==2 ) ) then
                       ! build a 4-by-4 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = zero
                       z( 3, 1 ) = d( is, is )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = zero
                       z( 2, 2 ) = a( is, is )
                       z( 3, 2 ) = zero
                       z( 4, 2 ) = d( is, is )
                       z( 1, 3 ) = -b( js, js )
                       z( 2, 3 ) = -b( js, jsp1 )
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = -e( js, jsp1 )
                       z( 1, 4 ) = -b( jsp1, js )
                       z( 2, 4 ) = -b( jsp1, jsp1 )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( is, jsp1 )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( is, jsp1 )
                       ! solve z * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_${ri}$latdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( is, jsp1 ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( is, jsp1 ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_${ri}$ger( is-1, nb, -one, a( 1, is ), 1, rhs( 1 ),1, c( 1, js ),&
                                     ldc )
                          call stdlib_${ri}$ger( is-1, nb, -one, d( 1, is ), 1, rhs( 1 ),1, f( 1, js ),&
                                     ldf )
                       end if
                       if( j<q ) then
                          call stdlib_${ri}$axpy( n-je, rhs( 3 ), b( js, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_${ri}$axpy( n-je, rhs( 3 ), e( js, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                          call stdlib_${ri}$axpy( n-je, rhs( 4 ), b( jsp1, je+1 ), ldb,c( is, je+1 ), &
                                    ldc )
                          call stdlib_${ri}$axpy( n-je, rhs( 4 ), e( jsp1, je+1 ), lde,f( is, je+1 ), &
                                    ldf )
                       end if
                    else if( ( mb==2 ) .and. ( nb==1 ) ) then
                       ! build a 4-by-4 system z * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( isp1, is )
                       z( 3, 1 ) = d( is, is )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = a( is, isp1 )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 3, 2 ) = d( is, isp1 )
                       z( 4, 2 ) = d( isp1, isp1 )
                       z( 1, 3 ) = -b( js, js )
                       z( 2, 3 ) = zero
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = -b( js, js )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( isp1, js )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( isp1, js )
                       ! solve z * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_${ri}$latdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( isp1, js ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( isp1, js ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_${ri}$gemv( 'N', is-1, mb, -one, a( 1, is ), lda,rhs( 1 ), 1, &
                                    one, c( 1, js ), 1 )
                          call stdlib_${ri}$gemv( 'N', is-1, mb, -one, d( 1, is ), ldd,rhs( 1 ), 1, &
                                    one, f( 1, js ), 1 )
                       end if
                       if( j<q ) then
                          call stdlib_${ri}$ger( mb, n-je, one, rhs( 3 ), 1,b( js, je+1 ), ldb, c( is, &
                                    je+1 ), ldc )
                          call stdlib_${ri}$ger( mb, n-je, one, rhs( 3 ), 1,e( js, je+1 ), lde, f( is, &
                                    je+1 ), ldf )
                       end if
                    else if( ( mb==2 ) .and. ( nb==2 ) ) then
                       ! build an 8-by-8 system z * x = rhs
                       call stdlib_${ri}$laset( 'F', ldz, ldz, zero, zero, z, ldz )
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( isp1, is )
                       z( 5, 1 ) = d( is, is )
                       z( 1, 2 ) = a( is, isp1 )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 5, 2 ) = d( is, isp1 )
                       z( 6, 2 ) = d( isp1, isp1 )
                       z( 3, 3 ) = a( is, is )
                       z( 4, 3 ) = a( isp1, is )
                       z( 7, 3 ) = d( is, is )
                       z( 3, 4 ) = a( is, isp1 )
                       z( 4, 4 ) = a( isp1, isp1 )
                       z( 7, 4 ) = d( is, isp1 )
                       z( 8, 4 ) = d( isp1, isp1 )
                       z( 1, 5 ) = -b( js, js )
                       z( 3, 5 ) = -b( js, jsp1 )
                       z( 5, 5 ) = -e( js, js )
                       z( 7, 5 ) = -e( js, jsp1 )
                       z( 2, 6 ) = -b( js, js )
                       z( 4, 6 ) = -b( js, jsp1 )
                       z( 6, 6 ) = -e( js, js )
                       z( 8, 6 ) = -e( js, jsp1 )
                       z( 1, 7 ) = -b( jsp1, js )
                       z( 3, 7 ) = -b( jsp1, jsp1 )
                       z( 7, 7 ) = -e( jsp1, jsp1 )
                       z( 2, 8 ) = -b( jsp1, js )
                       z( 4, 8 ) = -b( jsp1, jsp1 )
                       z( 8, 8 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_${ri}$copy( mb, c( is, js+jj ), 1, rhs( k ), 1 )
                          call stdlib_${ri}$copy( mb, f( is, js+jj ), 1, rhs( ii ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! solve z * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       if( ijob==0 ) then
                          call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv,scaloc )
                          if( scaloc/=one ) then
                             do k = 1, n
                                call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                                call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                             end do
                             scale = scale*scaloc
                          end if
                       else
                          call stdlib_${ri}$latdf( ijob, zdim, z, ldz, rhs, rdsum,rdscal, ipiv, jpiv )
                                    
                       end if
                       ! unpack solution vector(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_${ri}$copy( mb, rhs( k ), 1, c( is, js+jj ), 1 )
                          call stdlib_${ri}$copy( mb, rhs( ii ), 1, f( is, js+jj ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( i>1 ) then
                          call stdlib_${ri}$gemm( 'N', 'N', is-1, nb, mb, -one,a( 1, is ), lda, rhs( 1 &
                                    ), mb, one,c( 1, js ), ldc )
                          call stdlib_${ri}$gemm( 'N', 'N', is-1, nb, mb, -one,d( 1, is ), ldd, rhs( 1 &
                                    ), mb, one,f( 1, js ), ldf )
                       end if
                       if( j<q ) then
                          k = mb*nb + 1
                          call stdlib_${ri}$gemm( 'N', 'N', mb, n-je, nb, one, rhs( k ),mb, b( js, je+&
                                    1 ), ldb, one,c( is, je+1 ), ldc )
                          call stdlib_${ri}$gemm( 'N', 'N', mb, n-je, nb, one, rhs( k ),mb, e( js, je+&
                                    1 ), lde, one,f( is, je+1 ), ldf )
                       end if
                    end if
                 end do loop_110
              end do loop_120
           else
              ! solve (i, j) - subsystem
                   ! a(i, i)**t * r(i, j) + d(i, i)**t * l(j, j)  =  c(i, j)
                   ! r(i, i)  * b(j, j) + l(i, j)  * e(j, j)  = -f(i, j)
              ! for i = 1, 2, ..., p, j = q, q - 1, ..., 1
              scale = one
              scaloc = one
              loop_200: do i = 1, p
                 is = iwork( i )
                 isp1 = is + 1
                 ie = iwork ( i+1 ) - 1
                 mb = ie - is + 1
                 loop_190: do j = q, p + 2, -1
                    js = iwork( j )
                    jsp1 = js + 1
                    je = iwork( j+1 ) - 1
                    nb = je - js + 1
                    zdim = mb*nb*2
                    if( ( mb==1 ) .and. ( nb==1 ) ) then
                       ! build a 2-by-2 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = -b( js, js )
                       z( 1, 2 ) = d( is, is )
                       z( 2, 2 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = f( is, js )
                       ! solve z**t * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       f( is, js ) = rhs( 2 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          alpha = rhs( 1 )
                          call stdlib_${ri}$axpy( js-1, alpha, b( 1, js ), 1, f( is, 1 ),ldf )
                          alpha = rhs( 2 )
                          call stdlib_${ri}$axpy( js-1, alpha, e( 1, js ), 1, f( is, 1 ),ldf )
                       end if
                       if( i<p ) then
                          alpha = -rhs( 1 )
                          call stdlib_${ri}$axpy( m-ie, alpha, a( is, ie+1 ), lda,c( ie+1, js ), 1 )
                                    
                          alpha = -rhs( 2 )
                          call stdlib_${ri}$axpy( m-ie, alpha, d( is, ie+1 ), ldd,c( ie+1, js ), 1 )
                                    
                       end if
                    else if( ( mb==1 ) .and. ( nb==2 ) ) then
                       ! build a 4-by-4 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = zero
                       z( 3, 1 ) = -b( js, js )
                       z( 4, 1 ) = -b( jsp1, js )
                       z( 1, 2 ) = zero
                       z( 2, 2 ) = a( is, is )
                       z( 3, 2 ) = -b( js, jsp1 )
                       z( 4, 2 ) = -b( jsp1, jsp1 )
                       z( 1, 3 ) = d( is, is )
                       z( 2, 3 ) = zero
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = d( is, is )
                       z( 3, 4 ) = -e( js, jsp1 )
                       z( 4, 4 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( is, jsp1 )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( is, jsp1 )
                       ! solve z**t * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( is, jsp1 ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( is, jsp1 ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_${ri}$axpy( js-1, rhs( 1 ), b( 1, js ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_${ri}$axpy( js-1, rhs( 2 ), b( 1, jsp1 ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_${ri}$axpy( js-1, rhs( 3 ), e( 1, js ), 1,f( is, 1 ), ldf )
                                    
                          call stdlib_${ri}$axpy( js-1, rhs( 4 ), e( 1, jsp1 ), 1,f( is, 1 ), ldf )
                                    
                       end if
                       if( i<p ) then
                          call stdlib_${ri}$ger( m-ie, nb, -one, a( is, ie+1 ), lda,rhs( 1 ), 1, c( ie+&
                                    1, js ), ldc )
                          call stdlib_${ri}$ger( m-ie, nb, -one, d( is, ie+1 ), ldd,rhs( 3 ), 1, c( ie+&
                                    1, js ), ldc )
                       end if
                    else if( ( mb==2 ) .and. ( nb==1 ) ) then
                       ! build a 4-by-4 system z**t * x = rhs
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( is, isp1 )
                       z( 3, 1 ) = -b( js, js )
                       z( 4, 1 ) = zero
                       z( 1, 2 ) = a( isp1, is )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 3, 2 ) = zero
                       z( 4, 2 ) = -b( js, js )
                       z( 1, 3 ) = d( is, is )
                       z( 2, 3 ) = d( is, isp1 )
                       z( 3, 3 ) = -e( js, js )
                       z( 4, 3 ) = zero
                       z( 1, 4 ) = zero
                       z( 2, 4 ) = d( isp1, isp1 )
                       z( 3, 4 ) = zero
                       z( 4, 4 ) = -e( js, js )
                       ! set up right hand side(s)
                       rhs( 1 ) = c( is, js )
                       rhs( 2 ) = c( isp1, js )
                       rhs( 3 ) = f( is, js )
                       rhs( 4 ) = f( isp1, js )
                       ! solve z**t * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       c( is, js ) = rhs( 1 )
                       c( isp1, js ) = rhs( 2 )
                       f( is, js ) = rhs( 3 )
                       f( isp1, js ) = rhs( 4 )
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_${ri}$ger( mb, js-1, one, rhs( 1 ), 1, b( 1, js ),1, f( is, 1 ), &
                                    ldf )
                          call stdlib_${ri}$ger( mb, js-1, one, rhs( 3 ), 1, e( 1, js ),1, f( is, 1 ), &
                                    ldf )
                       end if
                       if( i<p ) then
                          call stdlib_${ri}$gemv( 'T', mb, m-ie, -one, a( is, ie+1 ),lda, rhs( 1 ), 1, &
                                    one, c( ie+1, js ),1 )
                          call stdlib_${ri}$gemv( 'T', mb, m-ie, -one, d( is, ie+1 ),ldd, rhs( 3 ), 1, &
                                    one, c( ie+1, js ),1 )
                       end if
                    else if( ( mb==2 ) .and. ( nb==2 ) ) then
                       ! build an 8-by-8 system z**t * x = rhs
                       call stdlib_${ri}$laset( 'F', ldz, ldz, zero, zero, z, ldz )
                       z( 1, 1 ) = a( is, is )
                       z( 2, 1 ) = a( is, isp1 )
                       z( 5, 1 ) = -b( js, js )
                       z( 7, 1 ) = -b( jsp1, js )
                       z( 1, 2 ) = a( isp1, is )
                       z( 2, 2 ) = a( isp1, isp1 )
                       z( 6, 2 ) = -b( js, js )
                       z( 8, 2 ) = -b( jsp1, js )
                       z( 3, 3 ) = a( is, is )
                       z( 4, 3 ) = a( is, isp1 )
                       z( 5, 3 ) = -b( js, jsp1 )
                       z( 7, 3 ) = -b( jsp1, jsp1 )
                       z( 3, 4 ) = a( isp1, is )
                       z( 4, 4 ) = a( isp1, isp1 )
                       z( 6, 4 ) = -b( js, jsp1 )
                       z( 8, 4 ) = -b( jsp1, jsp1 )
                       z( 1, 5 ) = d( is, is )
                       z( 2, 5 ) = d( is, isp1 )
                       z( 5, 5 ) = -e( js, js )
                       z( 2, 6 ) = d( isp1, isp1 )
                       z( 6, 6 ) = -e( js, js )
                       z( 3, 7 ) = d( is, is )
                       z( 4, 7 ) = d( is, isp1 )
                       z( 5, 7 ) = -e( js, jsp1 )
                       z( 7, 7 ) = -e( jsp1, jsp1 )
                       z( 4, 8 ) = d( isp1, isp1 )
                       z( 6, 8 ) = -e( js, jsp1 )
                       z( 8, 8 ) = -e( jsp1, jsp1 )
                       ! set up right hand side(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_${ri}$copy( mb, c( is, js+jj ), 1, rhs( k ), 1 )
                          call stdlib_${ri}$copy( mb, f( is, js+jj ), 1, rhs( ii ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! solve z**t * x = rhs
                       call stdlib_${ri}$getc2( zdim, z, ldz, ipiv, jpiv, ierr )
                       if( ierr>0 )info = ierr
                       call stdlib_${ri}$gesc2( zdim, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_${ri}$scal( m, scaloc, c( 1, k ), 1 )
                             call stdlib_${ri}$scal( m, scaloc, f( 1, k ), 1 )
                          end do
                          scale = scale*scaloc
                       end if
                       ! unpack solution vector(s)
                       k = 1
                       ii = mb*nb + 1
                       do jj = 0, nb - 1
                          call stdlib_${ri}$copy( mb, rhs( k ), 1, c( is, js+jj ), 1 )
                          call stdlib_${ri}$copy( mb, rhs( ii ), 1, f( is, js+jj ), 1 )
                          k = k + mb
                          ii = ii + mb
                       end do
                       ! substitute r(i, j) and l(i, j) into remaining
                       ! equation.
                       if( j>p+2 ) then
                          call stdlib_${ri}$gemm( 'N', 'T', mb, js-1, nb, one,c( is, js ), ldc, b( 1, &
                                    js ), ldb, one,f( is, 1 ), ldf )
                          call stdlib_${ri}$gemm( 'N', 'T', mb, js-1, nb, one,f( is, js ), ldf, e( 1, &
                                    js ), lde, one,f( is, 1 ), ldf )
                       end if
                       if( i<p ) then
                          call stdlib_${ri}$gemm( 'T', 'N', m-ie, nb, mb, -one,a( is, ie+1 ), lda, c( &
                                    is, js ), ldc,one, c( ie+1, js ), ldc )
                          call stdlib_${ri}$gemm( 'T', 'N', m-ie, nb, mb, -one,d( is, ie+1 ), ldd, f( &
                                    is, js ), ldf,one, c( ie+1, js ), ldc )
                       end if
                    end if
                 end do loop_190
              end do loop_200
           end if
           return
     end subroutine stdlib_${ri}$tgsy2

#:endif
#:endfor

     module pure subroutine stdlib_ctgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! CTGSY2 solves the generalized Sylvester equation
     !! A * R - L * B = scale *  C               (1)
     !! D * R - L * E = scale * F
     !! using Level 1 and 2 BLAS, where R and L are unknown M-by-N matrices,
     !! (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
     !! N-by-N and M-by-N, respectively. A, B, D and E are upper triangular
     !! (i.e., (A,D) and (B,E) in generalized Schur form).
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
     !! scaling factor chosen to avoid overflow.
     !! In matrix notation solving equation (1) corresponds to solve
     !! Zx = scale * b, where Z is defined as
     !! Z = [ kron(In, A)  -kron(B**H, Im) ]             (2)
     !! [ kron(In, D)  -kron(E**H, Im) ],
     !! Ik is the identity matrix of size k and X**H is the transpose of X.
     !! kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! If TRANS = 'C', y in the conjugate transposed system Z**H*y = scale*b
     !! is solved for, which is equivalent to solve for R and L in
     !! A**H * R  + D**H * L   = scale * C           (3)
     !! R  * B**H + L  * E**H  = scale * -F
     !! This case is used to compute an estimate of Dif[(A, D), (B, E)] =
     !! = sigma_min(Z) using reverse communication with CLACON.
     !! CTGSY2 also (IJOB >= 1) contributes to the computation in CTGSYL
     !! of an upper bound on the separation between to matrix pairs. Then
     !! the input (A, D), (B, E) are sub-pencils of two matrix pairs in
     !! CTGSYL.
               ldf, scale, rdsum, rdscal,info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(ilp), intent(out) :: info
           real(sp), intent(inout) :: rdscal, rdsum
           real(sp), intent(out) :: scale
           ! Array Arguments 
           complex(sp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(sp), intent(inout) :: c(ldc,*), f(ldf,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ldz = 2
           
           
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: i, ierr, j, k
           real(sp) :: scaloc
           complex(sp) :: alpha
           ! Local Arrays 
           integer(ilp) :: ipiv(ldz), jpiv(ldz)
           complex(sp) :: rhs(ldz), z(ldz,ldz)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           ierr = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>2 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGSY2', -info )
              return
           end if
           if( notran ) then
              ! solve (i, j) - system
                 ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                 ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
              ! for i = m, m - 1, ..., 1; j = 1, 2, ..., n
              scale = one
              scaloc = one
              loop_30: do j = 1, n
                 loop_20: do i = m, 1, -1
                    ! build 2 by 2 system
                    z( 1, 1 ) = a( i, i )
                    z( 2, 1 ) = d( i, i )
                    z( 1, 2 ) = -b( j, j )
                    z( 2, 2 ) = -e( j, j )
                    ! set up right hand side(s)
                    rhs( 1 ) = c( i, j )
                    rhs( 2 ) = f( i, j )
                    ! solve z * x = rhs
                    call stdlib_cgetc2( ldz, z, ldz, ipiv, jpiv, ierr )
                    if( ierr>0 )info = ierr
                    if( ijob==0 ) then
                       call stdlib_cgesc2( ldz, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                       
                             call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                       
                          end do
                          scale = scale*scaloc
                       end if
                    else
                       call stdlib_clatdf( ijob, ldz, z, ldz, rhs, rdsum, rdscal,ipiv, jpiv )
                                 
                    end if
                    ! unpack solution vector(s)
                    c( i, j ) = rhs( 1 )
                    f( i, j ) = rhs( 2 )
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    if( i>1 ) then
                       alpha = -rhs( 1 )
                       call stdlib_caxpy( i-1, alpha, a( 1, i ), 1, c( 1, j ), 1 )
                       call stdlib_caxpy( i-1, alpha, d( 1, i ), 1, f( 1, j ), 1 )
                    end if
                    if( j<n ) then
                       call stdlib_caxpy( n-j, rhs( 2 ), b( j, j+1 ), ldb,c( i, j+1 ), ldc )
                                 
                       call stdlib_caxpy( n-j, rhs( 2 ), e( j, j+1 ), lde,f( i, j+1 ), ldf )
                                 
                    end if
                 end do loop_20
              end do loop_30
           else
              ! solve transposed (i, j) - system:
                 ! a(i, i)**h * r(i, j) + d(i, i)**h * l(j, j) = c(i, j)
                 ! r(i, i) * b(j, j) + l(i, j) * e(j, j)   = -f(i, j)
              ! for i = 1, 2, ..., m, j = n, n - 1, ..., 1
              scale = one
              scaloc = one
              loop_80: do i = 1, m
                 loop_70: do j = n, 1, -1
                    ! build 2 by 2 system z**h
                    z( 1, 1 ) = conjg( a( i, i ) )
                    z( 2, 1 ) = -conjg( b( j, j ) )
                    z( 1, 2 ) = conjg( d( i, i ) )
                    z( 2, 2 ) = -conjg( e( j, j ) )
                    ! set up right hand side(s)
                    rhs( 1 ) = c( i, j )
                    rhs( 2 ) = f( i, j )
                    ! solve z**h * x = rhs
                    call stdlib_cgetc2( ldz, z, ldz, ipiv, jpiv, ierr )
                    if( ierr>0 )info = ierr
                    call stdlib_cgesc2( ldz, z, ldz, rhs, ipiv, jpiv, scaloc )
                    if( scaloc/=one ) then
                       do k = 1, n
                          call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), c( 1, k ),1 )
                                    
                          call stdlib_cscal( m, cmplx( scaloc, zero,KIND=sp), f( 1, k ),1 )
                                    
                       end do
                       scale = scale*scaloc
                    end if
                    ! unpack solution vector(s)
                    c( i, j ) = rhs( 1 )
                    f( i, j ) = rhs( 2 )
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    do k = 1, j - 1
                       f( i, k ) = f( i, k ) + rhs( 1 )*conjg( b( k, j ) ) +rhs( 2 )*conjg( e( k, &
                                 j ) )
                    end do
                    do k = i + 1, m
                       c( k, j ) = c( k, j ) - conjg( a( i, k ) )*rhs( 1 ) -conjg( d( i, k ) )&
                                 *rhs( 2 )
                    end do
                 end do loop_70
              end do loop_80
           end if
           return
     end subroutine stdlib_ctgsy2

     module pure subroutine stdlib_ztgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! ZTGSY2 solves the generalized Sylvester equation
     !! A * R - L * B = scale * C               (1)
     !! D * R - L * E = scale * F
     !! using Level 1 and 2 BLAS, where R and L are unknown M-by-N matrices,
     !! (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
     !! N-by-N and M-by-N, respectively. A, B, D and E are upper triangular
     !! (i.e., (A,D) and (B,E) in generalized Schur form).
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
     !! scaling factor chosen to avoid overflow.
     !! In matrix notation solving equation (1) corresponds to solve
     !! Zx = scale * b, where Z is defined as
     !! Z = [ kron(In, A)  -kron(B**H, Im) ]             (2)
     !! [ kron(In, D)  -kron(E**H, Im) ],
     !! Ik is the identity matrix of size k and X**H is the conjuguate transpose of X.
     !! kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! If TRANS = 'C', y in the conjugate transposed system Z**H*y = scale*b
     !! is solved for, which is equivalent to solve for R and L in
     !! A**H * R  + D**H * L   = scale * C           (3)
     !! R  * B**H + L  * E**H  = scale * -F
     !! This case is used to compute an estimate of Dif[(A, D), (B, E)] =
     !! = sigma_min(Z) using reverse communication with ZLACON.
     !! ZTGSY2 also (IJOB >= 1) contributes to the computation in ZTGSYL
     !! of an upper bound on the separation between to matrix pairs. Then
     !! the input (A, D), (B, E) are sub-pencils of two matrix pairs in
     !! ZTGSYL.
               ldf, scale, rdsum, rdscal,info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(ilp), intent(out) :: info
           real(dp), intent(inout) :: rdscal, rdsum
           real(dp), intent(out) :: scale
           ! Array Arguments 
           complex(dp), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(dp), intent(inout) :: c(ldc,*), f(ldf,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ldz = 2
           
           
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: i, ierr, j, k
           real(dp) :: scaloc
           complex(dp) :: alpha
           ! Local Arrays 
           integer(ilp) :: ipiv(ldz), jpiv(ldz)
           complex(dp) :: rhs(ldz), z(ldz,ldz)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           ierr = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>2 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSY2', -info )
              return
           end if
           if( notran ) then
              ! solve (i, j) - system
                 ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                 ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
              ! for i = m, m - 1, ..., 1; j = 1, 2, ..., n
              scale = one
              scaloc = one
              loop_30: do j = 1, n
                 loop_20: do i = m, 1, -1
                    ! build 2 by 2 system
                    z( 1, 1 ) = a( i, i )
                    z( 2, 1 ) = d( i, i )
                    z( 1, 2 ) = -b( j, j )
                    z( 2, 2 ) = -e( j, j )
                    ! set up right hand side(s)
                    rhs( 1 ) = c( i, j )
                    rhs( 2 ) = f( i, j )
                    ! solve z * x = rhs
                    call stdlib_zgetc2( ldz, z, ldz, ipiv, jpiv, ierr )
                    if( ierr>0 )info = ierr
                    if( ijob==0 ) then
                       call stdlib_zgesc2( ldz, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp),c( 1, k ), 1 )
                                       
                             call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp),f( 1, k ), 1 )
                                       
                          end do
                          scale = scale*scaloc
                       end if
                    else
                       call stdlib_zlatdf( ijob, ldz, z, ldz, rhs, rdsum, rdscal,ipiv, jpiv )
                                 
                    end if
                    ! unpack solution vector(s)
                    c( i, j ) = rhs( 1 )
                    f( i, j ) = rhs( 2 )
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    if( i>1 ) then
                       alpha = -rhs( 1 )
                       call stdlib_zaxpy( i-1, alpha, a( 1, i ), 1, c( 1, j ), 1 )
                       call stdlib_zaxpy( i-1, alpha, d( 1, i ), 1, f( 1, j ), 1 )
                    end if
                    if( j<n ) then
                       call stdlib_zaxpy( n-j, rhs( 2 ), b( j, j+1 ), ldb,c( i, j+1 ), ldc )
                                 
                       call stdlib_zaxpy( n-j, rhs( 2 ), e( j, j+1 ), lde,f( i, j+1 ), ldf )
                                 
                    end if
                 end do loop_20
              end do loop_30
           else
              ! solve transposed (i, j) - system:
                 ! a(i, i)**h * r(i, j) + d(i, i)**h * l(j, j) = c(i, j)
                 ! r(i, i) * b(j, j) + l(i, j) * e(j, j)   = -f(i, j)
              ! for i = 1, 2, ..., m, j = n, n - 1, ..., 1
              scale = one
              scaloc = one
              loop_80: do i = 1, m
                 loop_70: do j = n, 1, -1
                    ! build 2 by 2 system z**h
                    z( 1, 1 ) = conjg( a( i, i ) )
                    z( 2, 1 ) = -conjg( b( j, j ) )
                    z( 1, 2 ) = conjg( d( i, i ) )
                    z( 2, 2 ) = -conjg( e( j, j ) )
                    ! set up right hand side(s)
                    rhs( 1 ) = c( i, j )
                    rhs( 2 ) = f( i, j )
                    ! solve z**h * x = rhs
                    call stdlib_zgetc2( ldz, z, ldz, ipiv, jpiv, ierr )
                    if( ierr>0 )info = ierr
                    call stdlib_zgesc2( ldz, z, ldz, rhs, ipiv, jpiv, scaloc )
                    if( scaloc/=one ) then
                       do k = 1, n
                          call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp), c( 1, k ),1 )
                                    
                          call stdlib_zscal( m, cmplx( scaloc, zero,KIND=dp), f( 1, k ),1 )
                                    
                       end do
                       scale = scale*scaloc
                    end if
                    ! unpack solution vector(s)
                    c( i, j ) = rhs( 1 )
                    f( i, j ) = rhs( 2 )
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    do k = 1, j - 1
                       f( i, k ) = f( i, k ) + rhs( 1 )*conjg( b( k, j ) ) +rhs( 2 )*conjg( e( k, &
                                 j ) )
                    end do
                    do k = i + 1, m
                       c( k, j ) = c( k, j ) - conjg( a( i, k ) )*rhs( 1 ) -conjg( d( i, k ) )&
                                 *rhs( 2 )
                    end do
                 end do loop_70
              end do loop_80
           end if
           return
     end subroutine stdlib_ztgsy2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$tgsy2( trans, ijob, m, n, a, lda, b, ldb, c, ldc, d,ldd, e, lde, f, &
     !! ZTGSY2: solves the generalized Sylvester equation
     !! A * R - L * B = scale * C               (1)
     !! D * R - L * E = scale * F
     !! using Level 1 and 2 BLAS, where R and L are unknown M-by-N matrices,
     !! (A, D), (B, E) and (C, F) are given matrix pairs of size M-by-M,
     !! N-by-N and M-by-N, respectively. A, B, D and E are upper triangular
     !! (i.e., (A,D) and (B,E) in generalized Schur form).
     !! The solution (R, L) overwrites (C, F). 0 <= SCALE <= 1 is an output
     !! scaling factor chosen to avoid overflow.
     !! In matrix notation solving equation (1) corresponds to solve
     !! Zx = scale * b, where Z is defined as
     !! Z = [ kron(In, A)  -kron(B**H, Im) ]             (2)
     !! [ kron(In, D)  -kron(E**H, Im) ],
     !! Ik is the identity matrix of size k and X**H is the conjuguate transpose of X.
     !! kron(X, Y) is the Kronecker product between the matrices X and Y.
     !! If TRANS = 'C', y in the conjugate transposed system Z**H*y = scale*b
     !! is solved for, which is equivalent to solve for R and L in
     !! A**H * R  + D**H * L   = scale * C           (3)
     !! R  * B**H + L  * E**H  = scale * -F
     !! This case is used to compute an estimate of Dif[(A, D), (B, E)] =
     !! = sigma_min(Z) using reverse communication with ZLACON.
     !! ZTGSY2 also (IJOB >= 1) contributes to the computation in ZTGSYL
     !! of an upper bound on the separation between to matrix pairs. Then
     !! the input (A, D), (B, E) are sub-pencils of two matrix pairs in
     !! ZTGSYL.
               ldf, scale, rdsum, rdscal,info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: trans
           integer(ilp), intent(in) :: ijob, lda, ldb, ldc, ldd, lde, ldf, m, n
           integer(ilp), intent(out) :: info
           real(${ck}$), intent(inout) :: rdscal, rdsum
           real(${ck}$), intent(out) :: scale
           ! Array Arguments 
           complex(${ck}$), intent(in) :: a(lda,*), b(ldb,*), d(ldd,*), e(lde,*)
           complex(${ck}$), intent(inout) :: c(ldc,*), f(ldf,*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: ldz = 2
           
           
           ! Local Scalars 
           logical(lk) :: notran
           integer(ilp) :: i, ierr, j, k
           real(${ck}$) :: scaloc
           complex(${ck}$) :: alpha
           ! Local Arrays 
           integer(ilp) :: ipiv(ldz), jpiv(ldz)
           complex(${ck}$) :: rhs(ldz), z(ldz,ldz)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test input parameters
           info = 0
           ierr = 0
           notran = stdlib_lsame( trans, 'N' )
           if( .not.notran .and. .not.stdlib_lsame( trans, 'C' ) ) then
              info = -1
           else if( notran ) then
              if( ( ijob<0 ) .or. ( ijob>2 ) ) then
                 info = -2
              end if
           end if
           if( info==0 ) then
              if( m<=0 ) then
                 info = -3
              else if( n<=0 ) then
                 info = -4
              else if( lda<max( 1, m ) ) then
                 info = -6
              else if( ldb<max( 1, n ) ) then
                 info = -8
              else if( ldc<max( 1, m ) ) then
                 info = -10
              else if( ldd<max( 1, m ) ) then
                 info = -12
              else if( lde<max( 1, n ) ) then
                 info = -14
              else if( ldf<max( 1, m ) ) then
                 info = -16
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSY2', -info )
              return
           end if
           if( notran ) then
              ! solve (i, j) - system
                 ! a(i, i) * r(i, j) - l(i, j) * b(j, j) = c(i, j)
                 ! d(i, i) * r(i, j) - l(i, j) * e(j, j) = f(i, j)
              ! for i = m, m - 1, ..., 1; j = 1, 2, ..., n
              scale = one
              scaloc = one
              loop_30: do j = 1, n
                 loop_20: do i = m, 1, -1
                    ! build 2 by 2 system
                    z( 1, 1 ) = a( i, i )
                    z( 2, 1 ) = d( i, i )
                    z( 1, 2 ) = -b( j, j )
                    z( 2, 2 ) = -e( j, j )
                    ! set up right hand side(s)
                    rhs( 1 ) = c( i, j )
                    rhs( 2 ) = f( i, j )
                    ! solve z * x = rhs
                    call stdlib_${ci}$getc2( ldz, z, ldz, ipiv, jpiv, ierr )
                    if( ierr>0 )info = ierr
                    if( ijob==0 ) then
                       call stdlib_${ci}$gesc2( ldz, z, ldz, rhs, ipiv, jpiv, scaloc )
                       if( scaloc/=one ) then
                          do k = 1, n
                             call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$),c( 1, k ), 1 )
                                       
                             call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$),f( 1, k ), 1 )
                                       
                          end do
                          scale = scale*scaloc
                       end if
                    else
                       call stdlib_${ci}$latdf( ijob, ldz, z, ldz, rhs, rdsum, rdscal,ipiv, jpiv )
                                 
                    end if
                    ! unpack solution vector(s)
                    c( i, j ) = rhs( 1 )
                    f( i, j ) = rhs( 2 )
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    if( i>1 ) then
                       alpha = -rhs( 1 )
                       call stdlib_${ci}$axpy( i-1, alpha, a( 1, i ), 1, c( 1, j ), 1 )
                       call stdlib_${ci}$axpy( i-1, alpha, d( 1, i ), 1, f( 1, j ), 1 )
                    end if
                    if( j<n ) then
                       call stdlib_${ci}$axpy( n-j, rhs( 2 ), b( j, j+1 ), ldb,c( i, j+1 ), ldc )
                                 
                       call stdlib_${ci}$axpy( n-j, rhs( 2 ), e( j, j+1 ), lde,f( i, j+1 ), ldf )
                                 
                    end if
                 end do loop_20
              end do loop_30
           else
              ! solve transposed (i, j) - system:
                 ! a(i, i)**h * r(i, j) + d(i, i)**h * l(j, j) = c(i, j)
                 ! r(i, i) * b(j, j) + l(i, j) * e(j, j)   = -f(i, j)
              ! for i = 1, 2, ..., m, j = n, n - 1, ..., 1
              scale = one
              scaloc = one
              loop_80: do i = 1, m
                 loop_70: do j = n, 1, -1
                    ! build 2 by 2 system z**h
                    z( 1, 1 ) = conjg( a( i, i ) )
                    z( 2, 1 ) = -conjg( b( j, j ) )
                    z( 1, 2 ) = conjg( d( i, i ) )
                    z( 2, 2 ) = -conjg( e( j, j ) )
                    ! set up right hand side(s)
                    rhs( 1 ) = c( i, j )
                    rhs( 2 ) = f( i, j )
                    ! solve z**h * x = rhs
                    call stdlib_${ci}$getc2( ldz, z, ldz, ipiv, jpiv, ierr )
                    if( ierr>0 )info = ierr
                    call stdlib_${ci}$gesc2( ldz, z, ldz, rhs, ipiv, jpiv, scaloc )
                    if( scaloc/=one ) then
                       do k = 1, n
                          call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$), c( 1, k ),1 )
                                    
                          call stdlib_${ci}$scal( m, cmplx( scaloc, zero,KIND=${ck}$), f( 1, k ),1 )
                                    
                       end do
                       scale = scale*scaloc
                    end if
                    ! unpack solution vector(s)
                    c( i, j ) = rhs( 1 )
                    f( i, j ) = rhs( 2 )
                    ! substitute r(i, j) and l(i, j) into remaining equation.
                    do k = 1, j - 1
                       f( i, k ) = f( i, k ) + rhs( 1 )*conjg( b( k, j ) ) +rhs( 2 )*conjg( e( k, &
                                 j ) )
                    end do
                    do k = i + 1, m
                       c( k, j ) = c( k, j ) - conjg( a( i, k ) )*rhs( 1 ) -conjg( d( i, k ) )&
                                 *rhs( 2 )
                    end do
                 end do loop_70
              end do loop_80
           end if
           return
     end subroutine stdlib_${ci}$tgsy2

#:endif
#:endfor



     module pure subroutine stdlib_sggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
     !! SGGBAL balances a pair of general real matrices (A,B).  This
     !! involves, first, permuting A and B by similarity transformations to
     !! isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
     !! elements on the diagonal; and second, applying a diagonal similarity
     !! transformation to rows and columns ILO to IHI to make the rows
     !! and columns as close in norm as possible. Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrices, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors in the
     !! generalized eigenvalue problem A*x = lambda*B*x.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, n
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: lscale(*), rscale(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sclfac = 1.0e+1_sp
           
           
           ! Local Scalars 
           integer(ilp) :: i, icab, iflow, ip1, ir, irab, it, j, jc, jp1, k, kount, l, lcab, lm1, &
                     lrab, lsfmax, lsfmin, m, nr, nrp2
           real(sp) :: alpha, basl, beta, cab, cmax, coef, coef2, coef5, cor, ew, ewc, gamma, &
                     pgamma, rab, sfmax, sfmin, sum, t, ta, tb, tc
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGGBAL', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              ilo = 1
              ihi = n
              return
           end if
           if( n==1 ) then
              ilo = 1
              ihi = n
              lscale( 1 ) = one
              rscale( 1 ) = one
              return
           end if
           if( stdlib_lsame( job, 'N' ) ) then
              ilo = 1
              ihi = n
              do i = 1, n
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           k = 1
           l = n
           if( stdlib_lsame( job, 'S' ) )go to 190
           go to 30
           ! permute the matrices a and b to isolate the eigenvalues.
           ! find row with one nonzero in columns 1 through l
           20 continue
           l = lm1
           if( l/=1 )go to 30
           rscale( 1 ) = one
           lscale( 1 ) = one
           go to 190
           30 continue
           lm1 = l - 1
           loop_80: do i = l, 1, -1
              do j = 1, lm1
                 jp1 = j + 1
                 if( a( i, j )/=zero .or. b( i, j )/=zero )go to 50
              end do
              j = l
              go to 70
              50 continue
              do j = jp1, l
                 if( a( i, j )/=zero .or. b( i, j )/=zero )cycle loop_80
              end do
              j = jp1 - 1
              70 continue
              m = l
              iflow = 1
              go to 160
           end do loop_80
           go to 100
           ! find column with one nonzero in rows k through n
           90 continue
           k = k + 1
           100 continue
           loop_150: do j = k, l
              do i = k, lm1
                 ip1 = i + 1
                 if( a( i, j )/=zero .or. b( i, j )/=zero )go to 120
              end do
              i = l
              go to 140
              120 continue
              do i = ip1, l
                 if( a( i, j )/=zero .or. b( i, j )/=zero )cycle loop_150
              end do
              i = ip1 - 1
              140 continue
              m = k
              iflow = 2
              go to 160
           end do loop_150
           go to 190
           ! permute rows m and i
           160 continue
           lscale( m ) = i
           if( i==m )go to 170
           call stdlib_sswap( n-k+1, a( i, k ), lda, a( m, k ), lda )
           call stdlib_sswap( n-k+1, b( i, k ), ldb, b( m, k ), ldb )
           ! permute columns m and j
           170 continue
           rscale( m ) = j
           if( j==m )go to 180
           call stdlib_sswap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_sswap( l, b( 1, j ), 1, b( 1, m ), 1 )
           180 continue
           go to ( 20, 90 )iflow
           190 continue
           ilo = k
           ihi = l
           if( stdlib_lsame( job, 'P' ) ) then
              do i = ilo, ihi
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           if( ilo==ihi )return
           ! balance the submatrix in rows ilo to ihi.
           nr = ihi - ilo + 1
           do i = ilo, ihi
              rscale( i ) = zero
              lscale( i ) = zero
              work( i ) = zero
              work( i+n ) = zero
              work( i+2*n ) = zero
              work( i+3*n ) = zero
              work( i+4*n ) = zero
              work( i+5*n ) = zero
           end do
           ! compute right side vector in resulting linear equations
           basl = log10( sclfac )
           do i = ilo, ihi
              do j = ilo, ihi
                 tb = b( i, j )
                 ta = a( i, j )
                 if( ta==zero )go to 210
                 ta = log10( abs( ta ) ) / basl
                 210 continue
                 if( tb==zero )go to 220
                 tb = log10( abs( tb ) ) / basl
                 220 continue
                 work( i+4*n ) = work( i+4*n ) - ta - tb
                 work( j+5*n ) = work( j+5*n ) - ta - tb
              end do
           end do
           coef = one / real( 2*nr,KIND=sp)
           coef2 = coef*coef
           coef5 = half*coef2
           nrp2 = nr + 2
           beta = zero
           it = 1
           ! start generalized conjugate gradient iteration
           250 continue
           gamma = stdlib_sdot( nr, work( ilo+4*n ), 1, work( ilo+4*n ), 1 ) +stdlib_sdot( nr, &
                     work( ilo+5*n ), 1, work( ilo+5*n ), 1 )
           ew = zero
           ewc = zero
           do i = ilo, ihi
              ew = ew + work( i+4*n )
              ewc = ewc + work( i+5*n )
           end do
           gamma = coef*gamma - coef2*( ew**2+ewc**2 ) - coef5*( ew-ewc )**2
           if( gamma==zero )go to 350
           if( it/=1 )beta = gamma / pgamma
           t = coef5*( ewc-three*ew )
           tc = coef5*( ew-three*ewc )
           call stdlib_sscal( nr, beta, work( ilo ), 1 )
           call stdlib_sscal( nr, beta, work( ilo+n ), 1 )
           call stdlib_saxpy( nr, coef, work( ilo+4*n ), 1, work( ilo+n ), 1 )
           call stdlib_saxpy( nr, coef, work( ilo+5*n ), 1, work( ilo ), 1 )
           do i = ilo, ihi
              work( i ) = work( i ) + tc
              work( i+n ) = work( i+n ) + t
           end do
           ! apply matrix to vector
           do i = ilo, ihi
              kount = 0
              sum = zero
              loop_290: do j = ilo, ihi
                 if( a( i, j )==zero )go to 280
                 kount = kount + 1
                 sum = sum + work( j )
                 280 continue
                 if( b( i, j )==zero )cycle loop_290
                 kount = kount + 1
                 sum = sum + work( j )
              end do loop_290
              work( i+2*n ) = real( kount,KIND=sp)*work( i+n ) + sum
           end do
           do j = ilo, ihi
              kount = 0
              sum = zero
              loop_320: do i = ilo, ihi
                 if( a( i, j )==zero )go to 310
                 kount = kount + 1
                 sum = sum + work( i+n )
                 310 continue
                 if( b( i, j )==zero )cycle loop_320
                 kount = kount + 1
                 sum = sum + work( i+n )
              end do loop_320
              work( j+3*n ) = real( kount,KIND=sp)*work( j ) + sum
           end do
           sum = stdlib_sdot( nr, work( ilo+n ), 1, work( ilo+2*n ), 1 ) +stdlib_sdot( nr, work( &
                     ilo ), 1, work( ilo+3*n ), 1 )
           alpha = gamma / sum
           ! determine correction to current iteration
           cmax = zero
           do i = ilo, ihi
              cor = alpha*work( i+n )
              if( abs( cor )>cmax )cmax = abs( cor )
              lscale( i ) = lscale( i ) + cor
              cor = alpha*work( i )
              if( abs( cor )>cmax )cmax = abs( cor )
              rscale( i ) = rscale( i ) + cor
           end do
           if( cmax<half )go to 350
           call stdlib_saxpy( nr, -alpha, work( ilo+2*n ), 1, work( ilo+4*n ), 1 )
           call stdlib_saxpy( nr, -alpha, work( ilo+3*n ), 1, work( ilo+5*n ), 1 )
           pgamma = gamma
           it = it + 1
           if( it<=nrp2 )go to 250
           ! end generalized conjugate gradient iteration
           350 continue
           sfmin = stdlib_slamch( 'S' )
           sfmax = one / sfmin
           lsfmin = int( log10( sfmin ) / basl+one,KIND=ilp)
           lsfmax = int( log10( sfmax ) / basl,KIND=ilp)
           do i = ilo, ihi
              irab = stdlib_isamax( n-ilo+1, a( i, ilo ), lda )
              rab = abs( a( i, irab+ilo-1 ) )
              irab = stdlib_isamax( n-ilo+1, b( i, ilo ), ldb )
              rab = max( rab, abs( b( i, irab+ilo-1 ) ) )
              lrab = int( log10( rab+sfmin ) / basl+one,KIND=ilp)
              ir = lscale( i ) + sign( half, lscale( i ) )
              ir = min( max( ir, lsfmin ), lsfmax, lsfmax-lrab )
              lscale( i ) = sclfac**ir
              icab = stdlib_isamax( ihi, a( 1, i ), 1 )
              cab = abs( a( icab, i ) )
              icab = stdlib_isamax( ihi, b( 1, i ), 1 )
              cab = max( cab, abs( b( icab, i ) ) )
              lcab = int( log10( cab+sfmin ) / basl+one,KIND=ilp)
              jc = rscale( i ) + sign( half, rscale( i ) )
              jc = min( max( jc, lsfmin ), lsfmax, lsfmax-lcab )
              rscale( i ) = sclfac**jc
           end do
           ! row scaling of matrices a and b
           do i = ilo, ihi
              call stdlib_sscal( n-ilo+1, lscale( i ), a( i, ilo ), lda )
              call stdlib_sscal( n-ilo+1, lscale( i ), b( i, ilo ), ldb )
           end do
           ! column scaling of matrices a and b
           do j = ilo, ihi
              call stdlib_sscal( ihi, rscale( j ), a( 1, j ), 1 )
              call stdlib_sscal( ihi, rscale( j ), b( 1, j ), 1 )
           end do
           return
     end subroutine stdlib_sggbal

     module pure subroutine stdlib_dggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
     !! DGGBAL balances a pair of general real matrices (A,B).  This
     !! involves, first, permuting A and B by similarity transformations to
     !! isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
     !! elements on the diagonal; and second, applying a diagonal similarity
     !! transformation to rows and columns ILO to IHI to make the rows
     !! and columns as close in norm as possible. Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrices, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors in the
     !! generalized eigenvalue problem A*x = lambda*B*x.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, n
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: lscale(*), rscale(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sclfac = 1.0e+1_dp
           
           
           ! Local Scalars 
           integer(ilp) :: i, icab, iflow, ip1, ir, irab, it, j, jc, jp1, k, kount, l, lcab, lm1, &
                     lrab, lsfmax, lsfmin, m, nr, nrp2
           real(dp) :: alpha, basl, beta, cab, cmax, coef, coef2, coef5, cor, ew, ewc, gamma, &
                     pgamma, rab, sfmax, sfmin, sum, t, ta, tb, tc
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGBAL', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              ilo = 1
              ihi = n
              return
           end if
           if( n==1 ) then
              ilo = 1
              ihi = n
              lscale( 1 ) = one
              rscale( 1 ) = one
              return
           end if
           if( stdlib_lsame( job, 'N' ) ) then
              ilo = 1
              ihi = n
              do i = 1, n
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           k = 1
           l = n
           if( stdlib_lsame( job, 'S' ) )go to 190
           go to 30
           ! permute the matrices a and b to isolate the eigenvalues.
           ! find row with one nonzero in columns 1 through l
           20 continue
           l = lm1
           if( l/=1 )go to 30
           rscale( 1 ) = one
           lscale( 1 ) = one
           go to 190
           30 continue
           lm1 = l - 1
           loop_80: do i = l, 1, -1
              do j = 1, lm1
                 jp1 = j + 1
                 if( a( i, j )/=zero .or. b( i, j )/=zero )go to 50
              end do
              j = l
              go to 70
              50 continue
              do j = jp1, l
                 if( a( i, j )/=zero .or. b( i, j )/=zero )cycle loop_80
              end do
              j = jp1 - 1
              70 continue
              m = l
              iflow = 1
              go to 160
           end do loop_80
           go to 100
           ! find column with one nonzero in rows k through n
           90 continue
           k = k + 1
           100 continue
           loop_150: do j = k, l
              do i = k, lm1
                 ip1 = i + 1
                 if( a( i, j )/=zero .or. b( i, j )/=zero )go to 120
              end do
              i = l
              go to 140
              120 continue
              do i = ip1, l
                 if( a( i, j )/=zero .or. b( i, j )/=zero )cycle loop_150
              end do
              i = ip1 - 1
              140 continue
              m = k
              iflow = 2
              go to 160
           end do loop_150
           go to 190
           ! permute rows m and i
           160 continue
           lscale( m ) = i
           if( i==m )go to 170
           call stdlib_dswap( n-k+1, a( i, k ), lda, a( m, k ), lda )
           call stdlib_dswap( n-k+1, b( i, k ), ldb, b( m, k ), ldb )
           ! permute columns m and j
           170 continue
           rscale( m ) = j
           if( j==m )go to 180
           call stdlib_dswap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_dswap( l, b( 1, j ), 1, b( 1, m ), 1 )
           180 continue
           go to ( 20, 90 )iflow
           190 continue
           ilo = k
           ihi = l
           if( stdlib_lsame( job, 'P' ) ) then
              do i = ilo, ihi
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           if( ilo==ihi )return
           ! balance the submatrix in rows ilo to ihi.
           nr = ihi - ilo + 1
           do i = ilo, ihi
              rscale( i ) = zero
              lscale( i ) = zero
              work( i ) = zero
              work( i+n ) = zero
              work( i+2*n ) = zero
              work( i+3*n ) = zero
              work( i+4*n ) = zero
              work( i+5*n ) = zero
           end do
           ! compute right side vector in resulting linear equations
           basl = log10( sclfac )
           do i = ilo, ihi
              do j = ilo, ihi
                 tb = b( i, j )
                 ta = a( i, j )
                 if( ta==zero )go to 210
                 ta = log10( abs( ta ) ) / basl
                 210 continue
                 if( tb==zero )go to 220
                 tb = log10( abs( tb ) ) / basl
                 220 continue
                 work( i+4*n ) = work( i+4*n ) - ta - tb
                 work( j+5*n ) = work( j+5*n ) - ta - tb
              end do
           end do
           coef = one / real( 2*nr,KIND=dp)
           coef2 = coef*coef
           coef5 = half*coef2
           nrp2 = nr + 2
           beta = zero
           it = 1
           ! start generalized conjugate gradient iteration
           250 continue
           gamma = stdlib_ddot( nr, work( ilo+4*n ), 1, work( ilo+4*n ), 1 ) +stdlib_ddot( nr, &
                     work( ilo+5*n ), 1, work( ilo+5*n ), 1 )
           ew = zero
           ewc = zero
           do i = ilo, ihi
              ew = ew + work( i+4*n )
              ewc = ewc + work( i+5*n )
           end do
           gamma = coef*gamma - coef2*( ew**2+ewc**2 ) - coef5*( ew-ewc )**2
           if( gamma==zero )go to 350
           if( it/=1 )beta = gamma / pgamma
           t = coef5*( ewc-three*ew )
           tc = coef5*( ew-three*ewc )
           call stdlib_dscal( nr, beta, work( ilo ), 1 )
           call stdlib_dscal( nr, beta, work( ilo+n ), 1 )
           call stdlib_daxpy( nr, coef, work( ilo+4*n ), 1, work( ilo+n ), 1 )
           call stdlib_daxpy( nr, coef, work( ilo+5*n ), 1, work( ilo ), 1 )
           do i = ilo, ihi
              work( i ) = work( i ) + tc
              work( i+n ) = work( i+n ) + t
           end do
           ! apply matrix to vector
           do i = ilo, ihi
              kount = 0
              sum = zero
              loop_290: do j = ilo, ihi
                 if( a( i, j )==zero )go to 280
                 kount = kount + 1
                 sum = sum + work( j )
                 280 continue
                 if( b( i, j )==zero )cycle loop_290
                 kount = kount + 1
                 sum = sum + work( j )
              end do loop_290
              work( i+2*n ) = real( kount,KIND=dp)*work( i+n ) + sum
           end do
           do j = ilo, ihi
              kount = 0
              sum = zero
              loop_320: do i = ilo, ihi
                 if( a( i, j )==zero )go to 310
                 kount = kount + 1
                 sum = sum + work( i+n )
                 310 continue
                 if( b( i, j )==zero )cycle loop_320
                 kount = kount + 1
                 sum = sum + work( i+n )
              end do loop_320
              work( j+3*n ) = real( kount,KIND=dp)*work( j ) + sum
           end do
           sum = stdlib_ddot( nr, work( ilo+n ), 1, work( ilo+2*n ), 1 ) +stdlib_ddot( nr, work( &
                     ilo ), 1, work( ilo+3*n ), 1 )
           alpha = gamma / sum
           ! determine correction to current iteration
           cmax = zero
           do i = ilo, ihi
              cor = alpha*work( i+n )
              if( abs( cor )>cmax )cmax = abs( cor )
              lscale( i ) = lscale( i ) + cor
              cor = alpha*work( i )
              if( abs( cor )>cmax )cmax = abs( cor )
              rscale( i ) = rscale( i ) + cor
           end do
           if( cmax<half )go to 350
           call stdlib_daxpy( nr, -alpha, work( ilo+2*n ), 1, work( ilo+4*n ), 1 )
           call stdlib_daxpy( nr, -alpha, work( ilo+3*n ), 1, work( ilo+5*n ), 1 )
           pgamma = gamma
           it = it + 1
           if( it<=nrp2 )go to 250
           ! end generalized conjugate gradient iteration
           350 continue
           sfmin = stdlib_dlamch( 'S' )
           sfmax = one / sfmin
           lsfmin = int( log10( sfmin ) / basl+one,KIND=ilp)
           lsfmax = int( log10( sfmax ) / basl,KIND=ilp)
           do i = ilo, ihi
              irab = stdlib_idamax( n-ilo+1, a( i, ilo ), lda )
              rab = abs( a( i, irab+ilo-1 ) )
              irab = stdlib_idamax( n-ilo+1, b( i, ilo ), ldb )
              rab = max( rab, abs( b( i, irab+ilo-1 ) ) )
              lrab = int( log10( rab+sfmin ) / basl+one,KIND=ilp)
              ir = int(lscale( i ) + sign( half, lscale( i ) ),KIND=ilp)
              ir = min( max( ir, lsfmin ), lsfmax, lsfmax-lrab )
              lscale( i ) = sclfac**ir
              icab = stdlib_idamax( ihi, a( 1, i ), 1 )
              cab = abs( a( icab, i ) )
              icab = stdlib_idamax( ihi, b( 1, i ), 1 )
              cab = max( cab, abs( b( icab, i ) ) )
              lcab = int( log10( cab+sfmin ) / basl+one,KIND=ilp)
              jc = int(rscale( i ) + sign( half, rscale( i ) ),KIND=ilp)
              jc = min( max( jc, lsfmin ), lsfmax, lsfmax-lcab )
              rscale( i ) = sclfac**jc
           end do
           ! row scaling of matrices a and b
           do i = ilo, ihi
              call stdlib_dscal( n-ilo+1, lscale( i ), a( i, ilo ), lda )
              call stdlib_dscal( n-ilo+1, lscale( i ), b( i, ilo ), ldb )
           end do
           ! column scaling of matrices a and b
           do j = ilo, ihi
              call stdlib_dscal( ihi, rscale( j ), a( 1, j ), 1 )
              call stdlib_dscal( ihi, rscale( j ), b( 1, j ), 1 )
           end do
           return
     end subroutine stdlib_dggbal

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$ggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
     !! DGGBAL: balances a pair of general real matrices (A,B).  This
     !! involves, first, permuting A and B by similarity transformations to
     !! isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
     !! elements on the diagonal; and second, applying a diagonal similarity
     !! transformation to rows and columns ILO to IHI to make the rows
     !! and columns as close in norm as possible. Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrices, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors in the
     !! generalized eigenvalue problem A*x = lambda*B*x.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, n
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: lscale(*), rscale(*), work(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: sclfac = 1.0e+1_${rk}$
           
           
           ! Local Scalars 
           integer(ilp) :: i, icab, iflow, ip1, ir, irab, it, j, jc, jp1, k, kount, l, lcab, lm1, &
                     lrab, lsfmax, lsfmin, m, nr, nrp2
           real(${rk}$) :: alpha, basl, beta, cab, cmax, coef, coef2, coef5, cor, ew, ewc, gamma, &
                     pgamma, rab, sfmax, sfmin, sum, t, ta, tb, tc
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGBAL', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              ilo = 1
              ihi = n
              return
           end if
           if( n==1 ) then
              ilo = 1
              ihi = n
              lscale( 1 ) = one
              rscale( 1 ) = one
              return
           end if
           if( stdlib_lsame( job, 'N' ) ) then
              ilo = 1
              ihi = n
              do i = 1, n
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           k = 1
           l = n
           if( stdlib_lsame( job, 'S' ) )go to 190
           go to 30
           ! permute the matrices a and b to isolate the eigenvalues.
           ! find row with one nonzero in columns 1 through l
           20 continue
           l = lm1
           if( l/=1 )go to 30
           rscale( 1 ) = one
           lscale( 1 ) = one
           go to 190
           30 continue
           lm1 = l - 1
           loop_80: do i = l, 1, -1
              do j = 1, lm1
                 jp1 = j + 1
                 if( a( i, j )/=zero .or. b( i, j )/=zero )go to 50
              end do
              j = l
              go to 70
              50 continue
              do j = jp1, l
                 if( a( i, j )/=zero .or. b( i, j )/=zero )cycle loop_80
              end do
              j = jp1 - 1
              70 continue
              m = l
              iflow = 1
              go to 160
           end do loop_80
           go to 100
           ! find column with one nonzero in rows k through n
           90 continue
           k = k + 1
           100 continue
           loop_150: do j = k, l
              do i = k, lm1
                 ip1 = i + 1
                 if( a( i, j )/=zero .or. b( i, j )/=zero )go to 120
              end do
              i = l
              go to 140
              120 continue
              do i = ip1, l
                 if( a( i, j )/=zero .or. b( i, j )/=zero )cycle loop_150
              end do
              i = ip1 - 1
              140 continue
              m = k
              iflow = 2
              go to 160
           end do loop_150
           go to 190
           ! permute rows m and i
           160 continue
           lscale( m ) = i
           if( i==m )go to 170
           call stdlib_${ri}$swap( n-k+1, a( i, k ), lda, a( m, k ), lda )
           call stdlib_${ri}$swap( n-k+1, b( i, k ), ldb, b( m, k ), ldb )
           ! permute columns m and j
           170 continue
           rscale( m ) = j
           if( j==m )go to 180
           call stdlib_${ri}$swap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_${ri}$swap( l, b( 1, j ), 1, b( 1, m ), 1 )
           180 continue
           go to ( 20, 90 )iflow
           190 continue
           ilo = k
           ihi = l
           if( stdlib_lsame( job, 'P' ) ) then
              do i = ilo, ihi
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           if( ilo==ihi )return
           ! balance the submatrix in rows ilo to ihi.
           nr = ihi - ilo + 1
           do i = ilo, ihi
              rscale( i ) = zero
              lscale( i ) = zero
              work( i ) = zero
              work( i+n ) = zero
              work( i+2*n ) = zero
              work( i+3*n ) = zero
              work( i+4*n ) = zero
              work( i+5*n ) = zero
           end do
           ! compute right side vector in resulting linear equations
           basl = log10( sclfac )
           do i = ilo, ihi
              do j = ilo, ihi
                 tb = b( i, j )
                 ta = a( i, j )
                 if( ta==zero )go to 210
                 ta = log10( abs( ta ) ) / basl
                 210 continue
                 if( tb==zero )go to 220
                 tb = log10( abs( tb ) ) / basl
                 220 continue
                 work( i+4*n ) = work( i+4*n ) - ta - tb
                 work( j+5*n ) = work( j+5*n ) - ta - tb
              end do
           end do
           coef = one / real( 2*nr,KIND=${rk}$)
           coef2 = coef*coef
           coef5 = half*coef2
           nrp2 = nr + 2
           beta = zero
           it = 1
           ! start generalized conjugate gradient iteration
           250 continue
           gamma = stdlib_${ri}$dot( nr, work( ilo+4*n ), 1, work( ilo+4*n ), 1 ) +stdlib_${ri}$dot( nr, &
                     work( ilo+5*n ), 1, work( ilo+5*n ), 1 )
           ew = zero
           ewc = zero
           do i = ilo, ihi
              ew = ew + work( i+4*n )
              ewc = ewc + work( i+5*n )
           end do
           gamma = coef*gamma - coef2*( ew**2+ewc**2 ) - coef5*( ew-ewc )**2
           if( gamma==zero )go to 350
           if( it/=1 )beta = gamma / pgamma
           t = coef5*( ewc-three*ew )
           tc = coef5*( ew-three*ewc )
           call stdlib_${ri}$scal( nr, beta, work( ilo ), 1 )
           call stdlib_${ri}$scal( nr, beta, work( ilo+n ), 1 )
           call stdlib_${ri}$axpy( nr, coef, work( ilo+4*n ), 1, work( ilo+n ), 1 )
           call stdlib_${ri}$axpy( nr, coef, work( ilo+5*n ), 1, work( ilo ), 1 )
           do i = ilo, ihi
              work( i ) = work( i ) + tc
              work( i+n ) = work( i+n ) + t
           end do
           ! apply matrix to vector
           do i = ilo, ihi
              kount = 0
              sum = zero
              loop_290: do j = ilo, ihi
                 if( a( i, j )==zero )go to 280
                 kount = kount + 1
                 sum = sum + work( j )
                 280 continue
                 if( b( i, j )==zero )cycle loop_290
                 kount = kount + 1
                 sum = sum + work( j )
              end do loop_290
              work( i+2*n ) = real( kount,KIND=${rk}$)*work( i+n ) + sum
           end do
           do j = ilo, ihi
              kount = 0
              sum = zero
              loop_320: do i = ilo, ihi
                 if( a( i, j )==zero )go to 310
                 kount = kount + 1
                 sum = sum + work( i+n )
                 310 continue
                 if( b( i, j )==zero )cycle loop_320
                 kount = kount + 1
                 sum = sum + work( i+n )
              end do loop_320
              work( j+3*n ) = real( kount,KIND=${rk}$)*work( j ) + sum
           end do
           sum = stdlib_${ri}$dot( nr, work( ilo+n ), 1, work( ilo+2*n ), 1 ) +stdlib_${ri}$dot( nr, work( &
                     ilo ), 1, work( ilo+3*n ), 1 )
           alpha = gamma / sum
           ! determine correction to current iteration
           cmax = zero
           do i = ilo, ihi
              cor = alpha*work( i+n )
              if( abs( cor )>cmax )cmax = abs( cor )
              lscale( i ) = lscale( i ) + cor
              cor = alpha*work( i )
              if( abs( cor )>cmax )cmax = abs( cor )
              rscale( i ) = rscale( i ) + cor
           end do
           if( cmax<half )go to 350
           call stdlib_${ri}$axpy( nr, -alpha, work( ilo+2*n ), 1, work( ilo+4*n ), 1 )
           call stdlib_${ri}$axpy( nr, -alpha, work( ilo+3*n ), 1, work( ilo+5*n ), 1 )
           pgamma = gamma
           it = it + 1
           if( it<=nrp2 )go to 250
           ! end generalized conjugate gradient iteration
           350 continue
           sfmin = stdlib_${ri}$lamch( 'S' )
           sfmax = one / sfmin
           lsfmin = int( log10( sfmin ) / basl+one,KIND=ilp)
           lsfmax = int( log10( sfmax ) / basl,KIND=ilp)
           do i = ilo, ihi
              irab = stdlib_i${ri}$amax( n-ilo+1, a( i, ilo ), lda )
              rab = abs( a( i, irab+ilo-1 ) )
              irab = stdlib_i${ri}$amax( n-ilo+1, b( i, ilo ), ldb )
              rab = max( rab, abs( b( i, irab+ilo-1 ) ) )
              lrab = int( log10( rab+sfmin ) / basl+one,KIND=ilp)
              ir = int(lscale( i ) + sign( half, lscale( i ) ),KIND=ilp)
              ir = min( max( ir, lsfmin ), lsfmax, lsfmax-lrab )
              lscale( i ) = sclfac**ir
              icab = stdlib_i${ri}$amax( ihi, a( 1, i ), 1 )
              cab = abs( a( icab, i ) )
              icab = stdlib_i${ri}$amax( ihi, b( 1, i ), 1 )
              cab = max( cab, abs( b( icab, i ) ) )
              lcab = int( log10( cab+sfmin ) / basl+one,KIND=ilp)
              jc = int(rscale( i ) + sign( half, rscale( i ) ),KIND=ilp)
              jc = min( max( jc, lsfmin ), lsfmax, lsfmax-lcab )
              rscale( i ) = sclfac**jc
           end do
           ! row scaling of matrices a and b
           do i = ilo, ihi
              call stdlib_${ri}$scal( n-ilo+1, lscale( i ), a( i, ilo ), lda )
              call stdlib_${ri}$scal( n-ilo+1, lscale( i ), b( i, ilo ), ldb )
           end do
           ! column scaling of matrices a and b
           do j = ilo, ihi
              call stdlib_${ri}$scal( ihi, rscale( j ), a( 1, j ), 1 )
              call stdlib_${ri}$scal( ihi, rscale( j ), b( 1, j ), 1 )
           end do
           return
     end subroutine stdlib_${ri}$ggbal

#:endif
#:endfor

     module pure subroutine stdlib_cggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
     !! CGGBAL balances a pair of general complex matrices (A,B).  This
     !! involves, first, permuting A and B by similarity transformations to
     !! isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
     !! elements on the diagonal; and second, applying a diagonal similarity
     !! transformation to rows and columns ILO to IHI to make the rows
     !! and columns as close in norm as possible. Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrices, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors in the
     !! generalized eigenvalue problem A*x = lambda*B*x.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, n
           ! Array Arguments 
           real(sp), intent(out) :: lscale(*), rscale(*), work(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: sclfac = 1.0e+1_sp
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, icab, iflow, ip1, ir, irab, it, j, jc, jp1, k, kount, l, lcab, lm1, &
                     lrab, lsfmax, lsfmin, m, nr, nrp2
           real(sp) :: alpha, basl, beta, cab, cmax, coef, coef2, coef5, cor, ew, ewc, gamma, &
                     pgamma, rab, sfmax, sfmin, sum, t, ta, tb, tc
           complex(sp) :: cdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=sp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGBAL', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              ilo = 1
              ihi = n
              return
           end if
           if( n==1 ) then
              ilo = 1
              ihi = n
              lscale( 1 ) = one
              rscale( 1 ) = one
              return
           end if
           if( stdlib_lsame( job, 'N' ) ) then
              ilo = 1
              ihi = n
              do i = 1, n
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           k = 1
           l = n
           if( stdlib_lsame( job, 'S' ) )go to 190
           go to 30
           ! permute the matrices a and b to isolate the eigenvalues.
           ! find row with one nonzero in columns 1 through l
           20 continue
           l = lm1
           if( l/=1 )go to 30
           rscale( 1 ) = one
           lscale( 1 ) = one
           go to 190
           30 continue
           lm1 = l - 1
           loop_80: do i = l, 1, -1
              do j = 1, lm1
                 jp1 = j + 1
                 if( a( i, j )/=czero .or. b( i, j )/=czero )go to 50
              end do
              j = l
              go to 70
              50 continue
              do j = jp1, l
                 if( a( i, j )/=czero .or. b( i, j )/=czero )cycle loop_80
              end do
              j = jp1 - 1
              70 continue
              m = l
              iflow = 1
              go to 160
           end do loop_80
           go to 100
           ! find column with one nonzero in rows k through n
           90 continue
           k = k + 1
           100 continue
           loop_150: do j = k, l
              do i = k, lm1
                 ip1 = i + 1
                 if( a( i, j )/=czero .or. b( i, j )/=czero )go to 120
              end do
              i = l
              go to 140
              120 continue
              do i = ip1, l
                 if( a( i, j )/=czero .or. b( i, j )/=czero )cycle loop_150
              end do
              i = ip1 - 1
              140 continue
              m = k
              iflow = 2
              go to 160
           end do loop_150
           go to 190
           ! permute rows m and i
           160 continue
           lscale( m ) = i
           if( i==m )go to 170
           call stdlib_cswap( n-k+1, a( i, k ), lda, a( m, k ), lda )
           call stdlib_cswap( n-k+1, b( i, k ), ldb, b( m, k ), ldb )
           ! permute columns m and j
           170 continue
           rscale( m ) = j
           if( j==m )go to 180
           call stdlib_cswap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_cswap( l, b( 1, j ), 1, b( 1, m ), 1 )
           180 continue
           go to ( 20, 90 )iflow
           190 continue
           ilo = k
           ihi = l
           if( stdlib_lsame( job, 'P' ) ) then
              do i = ilo, ihi
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           if( ilo==ihi )return
           ! balance the submatrix in rows ilo to ihi.
           nr = ihi - ilo + 1
           do i = ilo, ihi
              rscale( i ) = zero
              lscale( i ) = zero
              work( i ) = zero
              work( i+n ) = zero
              work( i+2*n ) = zero
              work( i+3*n ) = zero
              work( i+4*n ) = zero
              work( i+5*n ) = zero
           end do
           ! compute right side vector in resulting linear equations
           basl = log10( sclfac )
           do i = ilo, ihi
              do j = ilo, ihi
                 if( a( i, j )==czero ) then
                    ta = zero
                    go to 210
                 end if
                 ta = log10( cabs1( a( i, j ) ) ) / basl
                 210 continue
                 if( b( i, j )==czero ) then
                    tb = zero
                    go to 220
                 end if
                 tb = log10( cabs1( b( i, j ) ) ) / basl
                 220 continue
                 work( i+4*n ) = work( i+4*n ) - ta - tb
                 work( j+5*n ) = work( j+5*n ) - ta - tb
              end do
           end do
           coef = one / real( 2*nr,KIND=sp)
           coef2 = coef*coef
           coef5 = half*coef2
           nrp2 = nr + 2
           beta = zero
           it = 1
           ! start generalized conjugate gradient iteration
           250 continue
           gamma = stdlib_sdot( nr, work( ilo+4*n ), 1, work( ilo+4*n ), 1 ) +stdlib_sdot( nr, &
                     work( ilo+5*n ), 1, work( ilo+5*n ), 1 )
           ew = zero
           ewc = zero
           do i = ilo, ihi
              ew = ew + work( i+4*n )
              ewc = ewc + work( i+5*n )
           end do
           gamma = coef*gamma - coef2*( ew**2+ewc**2 ) - coef5*( ew-ewc )**2
           if( gamma==zero )go to 350
           if( it/=1 )beta = gamma / pgamma
           t = coef5*( ewc-three*ew )
           tc = coef5*( ew-three*ewc )
           call stdlib_sscal( nr, beta, work( ilo ), 1 )
           call stdlib_sscal( nr, beta, work( ilo+n ), 1 )
           call stdlib_saxpy( nr, coef, work( ilo+4*n ), 1, work( ilo+n ), 1 )
           call stdlib_saxpy( nr, coef, work( ilo+5*n ), 1, work( ilo ), 1 )
           do i = ilo, ihi
              work( i ) = work( i ) + tc
              work( i+n ) = work( i+n ) + t
           end do
           ! apply matrix to vector
           do i = ilo, ihi
              kount = 0
              sum = zero
              loop_290: do j = ilo, ihi
                 if( a( i, j )==czero )go to 280
                 kount = kount + 1
                 sum = sum + work( j )
                 280 continue
                 if( b( i, j )==czero )cycle loop_290
                 kount = kount + 1
                 sum = sum + work( j )
              end do loop_290
              work( i+2*n ) = real( kount,KIND=sp)*work( i+n ) + sum
           end do
           do j = ilo, ihi
              kount = 0
              sum = zero
              loop_320: do i = ilo, ihi
                 if( a( i, j )==czero )go to 310
                 kount = kount + 1
                 sum = sum + work( i+n )
                 310 continue
                 if( b( i, j )==czero )cycle loop_320
                 kount = kount + 1
                 sum = sum + work( i+n )
              end do loop_320
              work( j+3*n ) = real( kount,KIND=sp)*work( j ) + sum
           end do
           sum = stdlib_sdot( nr, work( ilo+n ), 1, work( ilo+2*n ), 1 ) +stdlib_sdot( nr, work( &
                     ilo ), 1, work( ilo+3*n ), 1 )
           alpha = gamma / sum
           ! determine correction to current iteration
           cmax = zero
           do i = ilo, ihi
              cor = alpha*work( i+n )
              if( abs( cor )>cmax )cmax = abs( cor )
              lscale( i ) = lscale( i ) + cor
              cor = alpha*work( i )
              if( abs( cor )>cmax )cmax = abs( cor )
              rscale( i ) = rscale( i ) + cor
           end do
           if( cmax<half )go to 350
           call stdlib_saxpy( nr, -alpha, work( ilo+2*n ), 1, work( ilo+4*n ), 1 )
           call stdlib_saxpy( nr, -alpha, work( ilo+3*n ), 1, work( ilo+5*n ), 1 )
           pgamma = gamma
           it = it + 1
           if( it<=nrp2 )go to 250
           ! end generalized conjugate gradient iteration
           350 continue
           sfmin = stdlib_slamch( 'S' )
           sfmax = one / sfmin
           lsfmin = int( log10( sfmin ) / basl+one,KIND=ilp)
           lsfmax = int( log10( sfmax ) / basl,KIND=ilp)
           do i = ilo, ihi
              irab = stdlib_icamax( n-ilo+1, a( i, ilo ), lda )
              rab = abs( a( i, irab+ilo-1 ) )
              irab = stdlib_icamax( n-ilo+1, b( i, ilo ), ldb )
              rab = max( rab, abs( b( i, irab+ilo-1 ) ) )
              lrab = int( log10( rab+sfmin ) / basl+one,KIND=ilp)
              ir = lscale( i ) + sign( half, lscale( i ) )
              ir = min( max( ir, lsfmin ), lsfmax, lsfmax-lrab )
              lscale( i ) = sclfac**ir
              icab = stdlib_icamax( ihi, a( 1, i ), 1 )
              cab = abs( a( icab, i ) )
              icab = stdlib_icamax( ihi, b( 1, i ), 1 )
              cab = max( cab, abs( b( icab, i ) ) )
              lcab = int( log10( cab+sfmin ) / basl+one,KIND=ilp)
              jc = rscale( i ) + sign( half, rscale( i ) )
              jc = min( max( jc, lsfmin ), lsfmax, lsfmax-lcab )
              rscale( i ) = sclfac**jc
           end do
           ! row scaling of matrices a and b
           do i = ilo, ihi
              call stdlib_csscal( n-ilo+1, lscale( i ), a( i, ilo ), lda )
              call stdlib_csscal( n-ilo+1, lscale( i ), b( i, ilo ), ldb )
           end do
           ! column scaling of matrices a and b
           do j = ilo, ihi
              call stdlib_csscal( ihi, rscale( j ), a( 1, j ), 1 )
              call stdlib_csscal( ihi, rscale( j ), b( 1, j ), 1 )
           end do
           return
     end subroutine stdlib_cggbal

     module pure subroutine stdlib_zggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
     !! ZGGBAL balances a pair of general complex matrices (A,B).  This
     !! involves, first, permuting A and B by similarity transformations to
     !! isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
     !! elements on the diagonal; and second, applying a diagonal similarity
     !! transformation to rows and columns ILO to IHI to make the rows
     !! and columns as close in norm as possible. Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrices, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors in the
     !! generalized eigenvalue problem A*x = lambda*B*x.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, n
           ! Array Arguments 
           real(dp), intent(out) :: lscale(*), rscale(*), work(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: sclfac = 1.0e+1_dp
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, icab, iflow, ip1, ir, irab, it, j, jc, jp1, k, kount, l, lcab, lm1, &
                     lrab, lsfmax, lsfmin, m, nr, nrp2
           real(dp) :: alpha, basl, beta, cab, cmax, coef, coef2, coef5, cor, ew, ewc, gamma, &
                     pgamma, rab, sfmax, sfmin, sum, t, ta, tb, tc
           complex(dp) :: cdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=dp) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGBAL', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              ilo = 1
              ihi = n
              return
           end if
           if( n==1 ) then
              ilo = 1
              ihi = n
              lscale( 1 ) = one
              rscale( 1 ) = one
              return
           end if
           if( stdlib_lsame( job, 'N' ) ) then
              ilo = 1
              ihi = n
              do i = 1, n
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           k = 1
           l = n
           if( stdlib_lsame( job, 'S' ) )go to 190
           go to 30
           ! permute the matrices a and b to isolate the eigenvalues.
           ! find row with one nonzero in columns 1 through l
           20 continue
           l = lm1
           if( l/=1 )go to 30
           rscale( 1 ) = 1
           lscale( 1 ) = 1
           go to 190
           30 continue
           lm1 = l - 1
           loop_80: do i = l, 1, -1
              do j = 1, lm1
                 jp1 = j + 1
                 if( a( i, j )/=czero .or. b( i, j )/=czero )go to 50
              end do
              j = l
              go to 70
              50 continue
              do j = jp1, l
                 if( a( i, j )/=czero .or. b( i, j )/=czero )cycle loop_80
              end do
              j = jp1 - 1
              70 continue
              m = l
              iflow = 1
              go to 160
           end do loop_80
           go to 100
           ! find column with one nonzero in rows k through n
           90 continue
           k = k + 1
           100 continue
           loop_150: do j = k, l
              do i = k, lm1
                 ip1 = i + 1
                 if( a( i, j )/=czero .or. b( i, j )/=czero )go to 120
              end do
              i = l
              go to 140
              120 continue
              do i = ip1, l
                 if( a( i, j )/=czero .or. b( i, j )/=czero )cycle loop_150
              end do
              i = ip1 - 1
              140 continue
              m = k
              iflow = 2
              go to 160
           end do loop_150
           go to 190
           ! permute rows m and i
           160 continue
           lscale( m ) = i
           if( i==m )go to 170
           call stdlib_zswap( n-k+1, a( i, k ), lda, a( m, k ), lda )
           call stdlib_zswap( n-k+1, b( i, k ), ldb, b( m, k ), ldb )
           ! permute columns m and j
           170 continue
           rscale( m ) = j
           if( j==m )go to 180
           call stdlib_zswap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_zswap( l, b( 1, j ), 1, b( 1, m ), 1 )
           180 continue
           go to ( 20, 90 )iflow
           190 continue
           ilo = k
           ihi = l
           if( stdlib_lsame( job, 'P' ) ) then
              do i = ilo, ihi
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           if( ilo==ihi )return
           ! balance the submatrix in rows ilo to ihi.
           nr = ihi - ilo + 1
           do i = ilo, ihi
              rscale( i ) = zero
              lscale( i ) = zero
              work( i ) = zero
              work( i+n ) = zero
              work( i+2*n ) = zero
              work( i+3*n ) = zero
              work( i+4*n ) = zero
              work( i+5*n ) = zero
           end do
           ! compute right side vector in resulting linear equations
           basl = log10( sclfac )
           do i = ilo, ihi
              do j = ilo, ihi
                 if( a( i, j )==czero ) then
                    ta = zero
                    go to 210
                 end if
                 ta = log10( cabs1( a( i, j ) ) ) / basl
                 210 continue
                 if( b( i, j )==czero ) then
                    tb = zero
                    go to 220
                 end if
                 tb = log10( cabs1( b( i, j ) ) ) / basl
                 220 continue
                 work( i+4*n ) = work( i+4*n ) - ta - tb
                 work( j+5*n ) = work( j+5*n ) - ta - tb
              end do
           end do
           coef = one / real( 2*nr,KIND=dp)
           coef2 = coef*coef
           coef5 = half*coef2
           nrp2 = nr + 2
           beta = zero
           it = 1
           ! start generalized conjugate gradient iteration
           250 continue
           gamma = stdlib_ddot( nr, work( ilo+4*n ), 1, work( ilo+4*n ), 1 ) +stdlib_ddot( nr, &
                     work( ilo+5*n ), 1, work( ilo+5*n ), 1 )
           ew = zero
           ewc = zero
           do i = ilo, ihi
              ew = ew + work( i+4*n )
              ewc = ewc + work( i+5*n )
           end do
           gamma = coef*gamma - coef2*( ew**2+ewc**2 ) - coef5*( ew-ewc )**2
           if( gamma==zero )go to 350
           if( it/=1 )beta = gamma / pgamma
           t = coef5*( ewc-three*ew )
           tc = coef5*( ew-three*ewc )
           call stdlib_dscal( nr, beta, work( ilo ), 1 )
           call stdlib_dscal( nr, beta, work( ilo+n ), 1 )
           call stdlib_daxpy( nr, coef, work( ilo+4*n ), 1, work( ilo+n ), 1 )
           call stdlib_daxpy( nr, coef, work( ilo+5*n ), 1, work( ilo ), 1 )
           do i = ilo, ihi
              work( i ) = work( i ) + tc
              work( i+n ) = work( i+n ) + t
           end do
           ! apply matrix to vector
           do i = ilo, ihi
              kount = 0
              sum = zero
              loop_290: do j = ilo, ihi
                 if( a( i, j )==czero )go to 280
                 kount = kount + 1
                 sum = sum + work( j )
                 280 continue
                 if( b( i, j )==czero )cycle loop_290
                 kount = kount + 1
                 sum = sum + work( j )
              end do loop_290
              work( i+2*n ) = real( kount,KIND=dp)*work( i+n ) + sum
           end do
           do j = ilo, ihi
              kount = 0
              sum = zero
              loop_320: do i = ilo, ihi
                 if( a( i, j )==czero )go to 310
                 kount = kount + 1
                 sum = sum + work( i+n )
                 310 continue
                 if( b( i, j )==czero )cycle loop_320
                 kount = kount + 1
                 sum = sum + work( i+n )
              end do loop_320
              work( j+3*n ) = real( kount,KIND=dp)*work( j ) + sum
           end do
           sum = stdlib_ddot( nr, work( ilo+n ), 1, work( ilo+2*n ), 1 ) +stdlib_ddot( nr, work( &
                     ilo ), 1, work( ilo+3*n ), 1 )
           alpha = gamma / sum
           ! determine correction to current iteration
           cmax = zero
           do i = ilo, ihi
              cor = alpha*work( i+n )
              if( abs( cor )>cmax )cmax = abs( cor )
              lscale( i ) = lscale( i ) + cor
              cor = alpha*work( i )
              if( abs( cor )>cmax )cmax = abs( cor )
              rscale( i ) = rscale( i ) + cor
           end do
           if( cmax<half )go to 350
           call stdlib_daxpy( nr, -alpha, work( ilo+2*n ), 1, work( ilo+4*n ), 1 )
           call stdlib_daxpy( nr, -alpha, work( ilo+3*n ), 1, work( ilo+5*n ), 1 )
           pgamma = gamma
           it = it + 1
           if( it<=nrp2 )go to 250
           ! end generalized conjugate gradient iteration
           350 continue
           sfmin = stdlib_dlamch( 'S' )
           sfmax = one / sfmin
           lsfmin = int( log10( sfmin ) / basl+one,KIND=ilp)
           lsfmax = int( log10( sfmax ) / basl,KIND=ilp)
           do i = ilo, ihi
              irab = stdlib_izamax( n-ilo+1, a( i, ilo ), lda )
              rab = abs( a( i, irab+ilo-1 ) )
              irab = stdlib_izamax( n-ilo+1, b( i, ilo ), ldb )
              rab = max( rab, abs( b( i, irab+ilo-1 ) ) )
              lrab = int( log10( rab+sfmin ) / basl+one,KIND=ilp)
              ir = int(lscale( i ) + sign( half, lscale( i ) ),KIND=ilp)
              ir = min( max( ir, lsfmin ), lsfmax, lsfmax-lrab )
              lscale( i ) = sclfac**ir
              icab = stdlib_izamax( ihi, a( 1, i ), 1 )
              cab = abs( a( icab, i ) )
              icab = stdlib_izamax( ihi, b( 1, i ), 1 )
              cab = max( cab, abs( b( icab, i ) ) )
              lcab = int( log10( cab+sfmin ) / basl+one,KIND=ilp)
              jc = int(rscale( i ) + sign( half, rscale( i ) ),KIND=ilp)
              jc = min( max( jc, lsfmin ), lsfmax, lsfmax-lcab )
              rscale( i ) = sclfac**jc
           end do
           ! row scaling of matrices a and b
           do i = ilo, ihi
              call stdlib_zdscal( n-ilo+1, lscale( i ), a( i, ilo ), lda )
              call stdlib_zdscal( n-ilo+1, lscale( i ), b( i, ilo ), ldb )
           end do
           ! column scaling of matrices a and b
           do j = ilo, ihi
              call stdlib_zdscal( ihi, rscale( j ), a( 1, j ), 1 )
              call stdlib_zdscal( ihi, rscale( j ), b( 1, j ), 1 )
           end do
           return
     end subroutine stdlib_zggbal

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$ggbal( job, n, a, lda, b, ldb, ilo, ihi, lscale,rscale, work, info )
     !! ZGGBAL: balances a pair of general complex matrices (A,B).  This
     !! involves, first, permuting A and B by similarity transformations to
     !! isolate eigenvalues in the first 1 to ILO$-$1 and last IHI+1 to N
     !! elements on the diagonal; and second, applying a diagonal similarity
     !! transformation to rows and columns ILO to IHI to make the rows
     !! and columns as close in norm as possible. Both steps are optional.
     !! Balancing may reduce the 1-norm of the matrices, and improve the
     !! accuracy of the computed eigenvalues and/or eigenvectors in the
     !! generalized eigenvalue problem A*x = lambda*B*x.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job
           integer(ilp), intent(out) :: ihi, ilo, info
           integer(ilp), intent(in) :: lda, ldb, n
           ! Array Arguments 
           real(${ck}$), intent(out) :: lscale(*), rscale(*), work(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: sclfac = 1.0e+1_${ck}$
           
           
           
           ! Local Scalars 
           integer(ilp) :: i, icab, iflow, ip1, ir, irab, it, j, jc, jp1, k, kount, l, lcab, lm1, &
                     lrab, lsfmax, lsfmin, m, nr, nrp2
           real(${ck}$) :: alpha, basl, beta, cab, cmax, coef, coef2, coef5, cor, ew, ewc, gamma, &
                     pgamma, rab, sfmax, sfmin, sum, t, ta, tb, tc
           complex(${ck}$) :: cdum
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: cabs1
           ! Statement Function Definitions 
           cabs1( cdum ) = abs( real( cdum,KIND=${ck}$) ) + abs( aimag( cdum ) )
           ! Executable Statements 
           ! test the input parameters
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( n<0 ) then
              info = -2
           else if( lda<max( 1, n ) ) then
              info = -4
           else if( ldb<max( 1, n ) ) then
              info = -6
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGBAL', -info )
              return
           end if
           ! quick return if possible
           if( n==0 ) then
              ilo = 1
              ihi = n
              return
           end if
           if( n==1 ) then
              ilo = 1
              ihi = n
              lscale( 1 ) = one
              rscale( 1 ) = one
              return
           end if
           if( stdlib_lsame( job, 'N' ) ) then
              ilo = 1
              ihi = n
              do i = 1, n
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           k = 1
           l = n
           if( stdlib_lsame( job, 'S' ) )go to 190
           go to 30
           ! permute the matrices a and b to isolate the eigenvalues.
           ! find row with one nonzero in columns 1 through l
           20 continue
           l = lm1
           if( l/=1 )go to 30
           rscale( 1 ) = 1
           lscale( 1 ) = 1
           go to 190
           30 continue
           lm1 = l - 1
           loop_80: do i = l, 1, -1
              do j = 1, lm1
                 jp1 = j + 1
                 if( a( i, j )/=czero .or. b( i, j )/=czero )go to 50
              end do
              j = l
              go to 70
              50 continue
              do j = jp1, l
                 if( a( i, j )/=czero .or. b( i, j )/=czero )cycle loop_80
              end do
              j = jp1 - 1
              70 continue
              m = l
              iflow = 1
              go to 160
           end do loop_80
           go to 100
           ! find column with one nonzero in rows k through n
           90 continue
           k = k + 1
           100 continue
           loop_150: do j = k, l
              do i = k, lm1
                 ip1 = i + 1
                 if( a( i, j )/=czero .or. b( i, j )/=czero )go to 120
              end do
              i = l
              go to 140
              120 continue
              do i = ip1, l
                 if( a( i, j )/=czero .or. b( i, j )/=czero )cycle loop_150
              end do
              i = ip1 - 1
              140 continue
              m = k
              iflow = 2
              go to 160
           end do loop_150
           go to 190
           ! permute rows m and i
           160 continue
           lscale( m ) = i
           if( i==m )go to 170
           call stdlib_${ci}$swap( n-k+1, a( i, k ), lda, a( m, k ), lda )
           call stdlib_${ci}$swap( n-k+1, b( i, k ), ldb, b( m, k ), ldb )
           ! permute columns m and j
           170 continue
           rscale( m ) = j
           if( j==m )go to 180
           call stdlib_${ci}$swap( l, a( 1, j ), 1, a( 1, m ), 1 )
           call stdlib_${ci}$swap( l, b( 1, j ), 1, b( 1, m ), 1 )
           180 continue
           go to ( 20, 90 )iflow
           190 continue
           ilo = k
           ihi = l
           if( stdlib_lsame( job, 'P' ) ) then
              do i = ilo, ihi
                 lscale( i ) = one
                 rscale( i ) = one
              end do
              return
           end if
           if( ilo==ihi )return
           ! balance the submatrix in rows ilo to ihi.
           nr = ihi - ilo + 1
           do i = ilo, ihi
              rscale( i ) = zero
              lscale( i ) = zero
              work( i ) = zero
              work( i+n ) = zero
              work( i+2*n ) = zero
              work( i+3*n ) = zero
              work( i+4*n ) = zero
              work( i+5*n ) = zero
           end do
           ! compute right side vector in resulting linear equations
           basl = log10( sclfac )
           do i = ilo, ihi
              do j = ilo, ihi
                 if( a( i, j )==czero ) then
                    ta = zero
                    go to 210
                 end if
                 ta = log10( cabs1( a( i, j ) ) ) / basl
                 210 continue
                 if( b( i, j )==czero ) then
                    tb = zero
                    go to 220
                 end if
                 tb = log10( cabs1( b( i, j ) ) ) / basl
                 220 continue
                 work( i+4*n ) = work( i+4*n ) - ta - tb
                 work( j+5*n ) = work( j+5*n ) - ta - tb
              end do
           end do
           coef = one / real( 2*nr,KIND=${ck}$)
           coef2 = coef*coef
           coef5 = half*coef2
           nrp2 = nr + 2
           beta = zero
           it = 1
           ! start generalized conjugate gradient iteration
           250 continue
           gamma = stdlib_${c2ri(ci)}$dot( nr, work( ilo+4*n ), 1, work( ilo+4*n ), 1 ) +stdlib_${c2ri(ci)}$dot( nr, &
                     work( ilo+5*n ), 1, work( ilo+5*n ), 1 )
           ew = zero
           ewc = zero
           do i = ilo, ihi
              ew = ew + work( i+4*n )
              ewc = ewc + work( i+5*n )
           end do
           gamma = coef*gamma - coef2*( ew**2+ewc**2 ) - coef5*( ew-ewc )**2
           if( gamma==zero )go to 350
           if( it/=1 )beta = gamma / pgamma
           t = coef5*( ewc-three*ew )
           tc = coef5*( ew-three*ewc )
           call stdlib_${c2ri(ci)}$scal( nr, beta, work( ilo ), 1 )
           call stdlib_${c2ri(ci)}$scal( nr, beta, work( ilo+n ), 1 )
           call stdlib_${c2ri(ci)}$axpy( nr, coef, work( ilo+4*n ), 1, work( ilo+n ), 1 )
           call stdlib_${c2ri(ci)}$axpy( nr, coef, work( ilo+5*n ), 1, work( ilo ), 1 )
           do i = ilo, ihi
              work( i ) = work( i ) + tc
              work( i+n ) = work( i+n ) + t
           end do
           ! apply matrix to vector
           do i = ilo, ihi
              kount = 0
              sum = zero
              loop_290: do j = ilo, ihi
                 if( a( i, j )==czero )go to 280
                 kount = kount + 1
                 sum = sum + work( j )
                 280 continue
                 if( b( i, j )==czero )cycle loop_290
                 kount = kount + 1
                 sum = sum + work( j )
              end do loop_290
              work( i+2*n ) = real( kount,KIND=${ck}$)*work( i+n ) + sum
           end do
           do j = ilo, ihi
              kount = 0
              sum = zero
              loop_320: do i = ilo, ihi
                 if( a( i, j )==czero )go to 310
                 kount = kount + 1
                 sum = sum + work( i+n )
                 310 continue
                 if( b( i, j )==czero )cycle loop_320
                 kount = kount + 1
                 sum = sum + work( i+n )
              end do loop_320
              work( j+3*n ) = real( kount,KIND=${ck}$)*work( j ) + sum
           end do
           sum = stdlib_${c2ri(ci)}$dot( nr, work( ilo+n ), 1, work( ilo+2*n ), 1 ) +stdlib_${c2ri(ci)}$dot( nr, work( &
                     ilo ), 1, work( ilo+3*n ), 1 )
           alpha = gamma / sum
           ! determine correction to current iteration
           cmax = zero
           do i = ilo, ihi
              cor = alpha*work( i+n )
              if( abs( cor )>cmax )cmax = abs( cor )
              lscale( i ) = lscale( i ) + cor
              cor = alpha*work( i )
              if( abs( cor )>cmax )cmax = abs( cor )
              rscale( i ) = rscale( i ) + cor
           end do
           if( cmax<half )go to 350
           call stdlib_${c2ri(ci)}$axpy( nr, -alpha, work( ilo+2*n ), 1, work( ilo+4*n ), 1 )
           call stdlib_${c2ri(ci)}$axpy( nr, -alpha, work( ilo+3*n ), 1, work( ilo+5*n ), 1 )
           pgamma = gamma
           it = it + 1
           if( it<=nrp2 )go to 250
           ! end generalized conjugate gradient iteration
           350 continue
           sfmin = stdlib_${c2ri(ci)}$lamch( 'S' )
           sfmax = one / sfmin
           lsfmin = int( log10( sfmin ) / basl+one,KIND=ilp)
           lsfmax = int( log10( sfmax ) / basl,KIND=ilp)
           do i = ilo, ihi
              irab = stdlib_i${ci}$amax( n-ilo+1, a( i, ilo ), lda )
              rab = abs( a( i, irab+ilo-1 ) )
              irab = stdlib_i${ci}$amax( n-ilo+1, b( i, ilo ), ldb )
              rab = max( rab, abs( b( i, irab+ilo-1 ) ) )
              lrab = int( log10( rab+sfmin ) / basl+one,KIND=ilp)
              ir = int(lscale( i ) + sign( half, lscale( i ) ),KIND=ilp)
              ir = min( max( ir, lsfmin ), lsfmax, lsfmax-lrab )
              lscale( i ) = sclfac**ir
              icab = stdlib_i${ci}$amax( ihi, a( 1, i ), 1 )
              cab = abs( a( icab, i ) )
              icab = stdlib_i${ci}$amax( ihi, b( 1, i ), 1 )
              cab = max( cab, abs( b( icab, i ) ) )
              lcab = int( log10( cab+sfmin ) / basl+one,KIND=ilp)
              jc = int(rscale( i ) + sign( half, rscale( i ) ),KIND=ilp)
              jc = min( max( jc, lsfmin ), lsfmax, lsfmax-lcab )
              rscale( i ) = sclfac**jc
           end do
           ! row scaling of matrices a and b
           do i = ilo, ihi
              call stdlib_${ci}$dscal( n-ilo+1, lscale( i ), a( i, ilo ), lda )
              call stdlib_${ci}$dscal( n-ilo+1, lscale( i ), b( i, ilo ), ldb )
           end do
           ! column scaling of matrices a and b
           do j = ilo, ihi
              call stdlib_${ci}$dscal( ihi, rscale( j ), a( 1, j ), 1 )
              call stdlib_${ci}$dscal( ihi, rscale( j ), b( 1, j ), 1 )
           end do
           return
     end subroutine stdlib_${ci}$ggbal

#:endif
#:endfor



     module pure subroutine stdlib_sgghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! SGGHD3 reduces a pair of real matrices (A,B) to generalized upper
     !! Hessenberg form using orthogonal transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the orthogonal matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**T*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**T*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**T*x.
     !! The orthogonal matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T
     !! Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T
     !! If Q1 is the orthogonal matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then SGGHD3 reduces the original
     !! problem to generalized Hessenberg form.
     !! This is a blocked variant of SGGHRD, using matrix-matrix
     !! multiplications for parts of the computation to enhance performance.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: blk22, initq, initz, lquery, wantq, wantz
           character :: compq2, compz2
           integer(ilp) :: cola, i, ierr, j, j0, jcol, jj, jrow, k, kacc22, len, lwkopt, n2nb, nb,&
                      nblst, nbmin, nh, nnb, nx, ppw, ppwo, pw, top, topq
           real(sp) :: c, c1, c2, s, s1, s2, temp, temp1, temp2, temp3
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           nb = stdlib_ilaenv( 1, 'SGGHD3', ' ', n, ilo, ihi, -1 )
           lwkopt = max( 6*n*nb, 1 )
           work( 1 ) = real( lwkopt,KIND=sp)
           initq = stdlib_lsame( compq, 'I' )
           wantq = initq .or. stdlib_lsame( compq, 'V' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( wantq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( wantz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           else if( lwork<1 .and. .not.lquery ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGGHD3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! initialize q and z if desired.
           if( initq )call stdlib_slaset( 'ALL', n, n, zero, one, q, ldq )
           if( initz )call stdlib_slaset( 'ALL', n, n, zero, one, z, ldz )
           ! zero out lower triangle of b.
           if( n>1 )call stdlib_slaset( 'LOWER', n-1, n-1, zero, zero, b(2, 1), ldb )
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = one
              return
           end if
           ! determine the blocksize.
           nbmin = stdlib_ilaenv( 2, 'SGGHD3', ' ', n, ilo, ihi, -1 )
           if( nb>1 .and. nb<nh ) then
              ! determine when to use unblocked instead of blocked code.
              nx = max( nb, stdlib_ilaenv( 3, 'SGGHD3', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code.
                 if( lwork<lwkopt ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code.
                    nbmin = max( 2, stdlib_ilaenv( 2, 'SGGHD3', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=6*n*nbmin ) then
                       nb = lwork / ( 6*n )
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              jcol = ilo
           else
              ! use blocked code
              kacc22 = stdlib_ilaenv( 16, 'SGGHD3', ' ', n, ilo, ihi, -1 )
              blk22 = kacc22==2
              do jcol = ilo, ihi-2, nb
                 nnb = min( nb, ihi-jcol-1 )
                 ! initialize small orthogonal factors that will hold the
                 ! accumulated givens rotations in workspace.
                 ! n2nb   denotes the number of 2*nnb-by-2*nnb factors
                 ! nblst  denotes the (possibly smaller) order of the last
                        ! factor.
                 n2nb = ( ihi-jcol-1 ) / nnb - 1
                 nblst = ihi - jcol - n2nb*nnb
                 call stdlib_slaset( 'ALL', nblst, nblst, zero, one, work, nblst )
                 pw = nblst * nblst + 1
                 do i = 1, n2nb
                    call stdlib_slaset( 'ALL', 2*nnb, 2*nnb, zero, one,work( pw ), 2*nnb )
                    pw = pw + 4*nnb*nnb
                 end do
                 ! reduce columns jcol:jcol+nnb-1 of a to hessenberg form.
                 do j = jcol, jcol+nnb-1
                    ! reduce jth column of a. store cosines and sines in jth
                    ! column of a and b, respectively.
                    do i = ihi, j+2, -1
                       temp = a( i-1, j )
                       call stdlib_slartg( temp, a( i, j ), c, s, a( i-1, j ) )
                       a( i, j ) = c
                       b( i, j ) = s
                    end do
                    ! accumulate givens rotations into workspace array.
                    ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                    len  = 2 + j - jcol
                    jrow = j + n2nb*nnb + 2
                    do i = ihi, jrow, -1
                       c = a( i, j )
                       s = b( i, j )
                       do jj = ppw, ppw+len-1
                          temp = work( jj + nblst )
                          work( jj + nblst ) = c*temp - s*work( jj )
                          work( jj ) = s*temp + c*work( jj )
                       end do
                       len = len + 1
                       ppw = ppw - nblst - 1
                    end do
                    ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                    j0 = jrow - nnb
                    do jrow = j0, j+2, -nnb
                       ppw = ppwo
                       len  = 2 + j - jcol
                       do i = jrow+nnb-1, jrow, -1
                          c = a( i, j )
                          s = b( i, j )
                          do jj = ppw, ppw+len-1
                             temp = work( jj + 2*nnb )
                             work( jj + 2*nnb ) = c*temp - s*work( jj )
                             work( jj ) = s*temp + c*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - 2*nnb - 1
                       end do
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    ! top denotes the number of top rows in a and b that will
                    ! not be updated during the next steps.
                    if( jcol<=2 ) then
                       top = 0
                    else
                       top = jcol
                    end if
                    ! propagate transformations through b and replace stored
                    ! left sines/cosines by right sines/cosines.
                    do jj = n, j+1, -1
                       ! update jjth column of b.
                       do i = min( jj+1, ihi ), j+2, -1
                          c = a( i, j )
                          s = b( i, j )
                          temp = b( i, jj )
                          b( i, jj ) = c*temp - s*b( i-1, jj )
                          b( i-1, jj ) = s*temp + c*b( i-1, jj )
                       end do
                       ! annihilate b( jj+1, jj ).
                       if( jj<ihi ) then
                          temp = b( jj+1, jj+1 )
                          call stdlib_slartg( temp, b( jj+1, jj ), c, s,b( jj+1, jj+1 ) )
                          b( jj+1, jj ) = zero
                          call stdlib_srot( jj-top, b( top+1, jj+1 ), 1,b( top+1, jj ), 1, c, s )
                                    
                          a( jj+1, j ) = c
                          b( jj+1, j ) = -s
                       end if
                    end do
                    ! update a by transformations from right.
                    ! explicit loop unrolling provides better performance
                    ! compared to stdlib_slasr.
                     ! call stdlib_slasr( 'right', 'variable', 'backward', ihi-top,
           ! $                     ihi-j, a( j+2, j ), b( j+2, j ),
           ! $                     a( top+1, j+1 ), lda )
                    jj = mod( ihi-j-1, 3 )
                    do i = ihi-j-3, jj+1, -3
                       c = a( j+1+i, j )
                       s = -b( j+1+i, j )
                       c1 = a( j+2+i, j )
                       s1 = -b( j+2+i, j )
                       c2 = a( j+3+i, j )
                       s2 = -b( j+3+i, j )
                       do k = top+1, ihi
                          temp = a( k, j+i  )
                          temp1 = a( k, j+i+1 )
                          temp2 = a( k, j+i+2 )
                          temp3 = a( k, j+i+3 )
                          a( k, j+i+3 ) = c2*temp3 + s2*temp2
                          temp2 = -s2*temp3 + c2*temp2
                          a( k, j+i+2 ) = c1*temp2 + s1*temp1
                          temp1 = -s1*temp2 + c1*temp1
                          a( k, j+i+1 ) = c*temp1 + s*temp
                          a( k, j+i ) = -s*temp1 + c*temp
                       end do
                    end do
                    if( jj>0 ) then
                       do i = jj, 1, -1
                          call stdlib_srot( ihi-top, a( top+1, j+i+1 ), 1,a( top+1, j+i ), 1, a( &
                                    j+1+i, j ),-b( j+1+i, j ) )
                       end do
                    end if
                    ! update (j+1)th column of a by transformations from left.
                    if ( j < jcol + nnb - 1 ) then
                       len  = 1 + j - jcol
                       ! multiply with the trailing accumulated orthogonal
                       ! matrix, which takes the form
                              ! [  u11  u12  ]
                          ! u = [            ],
                              ! [  u21  u22  ]
                       ! where u21 is a len-by-len matrix and u12 is lower
                       ! triangular.
                       jrow = ihi - nblst + 1
                       call stdlib_sgemv( 'TRANSPOSE', nblst, len, one, work,nblst, a( jrow, j+1 )&
                                 , 1, zero,work( pw ), 1 )
                       ppw = pw + len
                       do i = jrow, jrow+nblst-len-1
                          work( ppw ) = a( i, j+1 )
                          ppw = ppw + 1
                       end do
                       call stdlib_strmv( 'LOWER', 'TRANSPOSE', 'NON-UNIT',nblst-len, work( &
                                 len*nblst + 1 ), nblst,work( pw+len ), 1 )
                       call stdlib_sgemv( 'TRANSPOSE', len, nblst-len, one,work( (len+1)*nblst - &
                       len + 1 ), nblst,a( jrow+nblst-len, j+1 ), 1, one,work( pw+len ), 1 )
                                 
                       ppw = pw
                       do i = jrow, jrow+nblst-1
                          a( i, j+1 ) = work( ppw )
                          ppw = ppw + 1
                       end do
                       ! multiply with the other accumulated orthogonal
                       ! matrices, which take the form
                              ! [  u11  u12   0  ]
                              ! [                ]
                          ! u = [  u21  u22   0  ],
                              ! [                ]
                              ! [   0    0    i  ]
                       ! where i denotes the (nnb-len)-by-(nnb-len) identity
                       ! matrix, u21 is a len-by-len upper triangular matrix
                       ! and u12 is an nnb-by-nnb lower triangular matrix.
                       ppwo = 1 + nblst*nblst
                       j0 = jrow - nnb
                       do jrow = j0, jcol+1, -nnb
                          ppw = pw + len
                          do i = jrow, jrow+nnb-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          ppw = pw
                          do i = jrow+nnb, jrow+nnb+len-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          call stdlib_strmv( 'UPPER', 'TRANSPOSE', 'NON-UNIT', len,work( ppwo + &
                                    nnb ), 2*nnb, work( pw ),1 )
                          call stdlib_strmv( 'LOWER', 'TRANSPOSE', 'NON-UNIT', nnb,work( ppwo + &
                                    2*len*nnb ),2*nnb, work( pw + len ), 1 )
                          call stdlib_sgemv( 'TRANSPOSE', nnb, len, one,work( ppwo ), 2*nnb, a( &
                                    jrow, j+1 ), 1,one, work( pw ), 1 )
                          call stdlib_sgemv( 'TRANSPOSE', len, nnb, one,work( ppwo + 2*len*nnb + &
                                    nnb ), 2*nnb,a( jrow+nnb, j+1 ), 1, one,work( pw+len ), 1 )
                          ppw = pw
                          do i = jrow, jrow+len+nnb-1
                             a( i, j+1 ) = work( ppw )
                             ppw = ppw + 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end if
                 end do
                 ! apply accumulated orthogonal matrices to a.
                 cola = n - jcol - nnb + 1
                 j = ihi - nblst + 1
                 call stdlib_sgemm( 'TRANSPOSE', 'NO TRANSPOSE', nblst,cola, nblst, one, work, &
                           nblst,a( j, jcol+nnb ), lda, zero, work( pw ),nblst )
                 call stdlib_slacpy( 'ALL', nblst, cola, work( pw ), nblst,a( j, jcol+nnb ), lda )
                           
                 ppwo = nblst*nblst + 1
                 j0 = j - nnb
                 do j = j0, jcol+1, -nnb
                    if ( blk22 ) then
                       ! exploit the structure of
                              ! [  u11  u12  ]
                          ! u = [            ]
                              ! [  u21  u22  ],
                       ! where all blocks are nnb-by-nnb, u21 is upper
                       ! triangular and u12 is lower triangular.
                       call stdlib_sorm22( 'LEFT', 'TRANSPOSE', 2*nnb, cola, nnb,nnb, work( ppwo )&
                                 , 2*nnb,a( j, jcol+nnb ), lda, work( pw ),lwork-pw+1, ierr )
                    else
                       ! ignore the structure of u.
                       call stdlib_sgemm( 'TRANSPOSE', 'NO TRANSPOSE', 2*nnb,cola, 2*nnb, one, &
                                 work( ppwo ), 2*nnb,a( j, jcol+nnb ), lda, zero, work( pw ),2*nnb )
                       call stdlib_slacpy( 'ALL', 2*nnb, cola, work( pw ), 2*nnb,a( j, jcol+nnb ),&
                                  lda )
                    end if
                    ppwo = ppwo + 4*nnb*nnb
                 end do
                 ! apply accumulated orthogonal matrices to q.
                 if( wantq ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_sgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, one, q( &
                              topq, j ), ldq,work, nblst, zero, work( pw ), nh )
                    call stdlib_slacpy( 'ALL', nh, nblst, work( pw ), nh,q( topq, j ), ldq )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_sorm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,q( topq, j ), ldq, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_sgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, one,&
                                     q( topq, j ), ldq,work( ppwo ), 2*nnb, zero, work( pw ),nh )
                          call stdlib_slacpy( 'ALL', nh, 2*nnb, work( pw ), nh,q( topq, j ), ldq )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! accumulate right givens rotations if required.
                 if ( wantz .or. top>0 ) then
                    ! initialize small orthogonal factors that will hold the
                    ! accumulated givens rotations in workspace.
                    call stdlib_slaset( 'ALL', nblst, nblst, zero, one, work,nblst )
                    pw = nblst * nblst + 1
                    do i = 1, n2nb
                       call stdlib_slaset( 'ALL', 2*nnb, 2*nnb, zero, one,work( pw ), 2*nnb )
                                 
                       pw = pw + 4*nnb*nnb
                    end do
                    ! accumulate givens rotations into workspace array.
                    do j = jcol, jcol+nnb-1
                       ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                       len  = 2 + j - jcol
                       jrow = j + n2nb*nnb + 2
                       do i = ihi, jrow, -1
                          c = a( i, j )
                          a( i, j ) = zero
                          s = b( i, j )
                          b( i, j ) = zero
                          do jj = ppw, ppw+len-1
                             temp = work( jj + nblst )
                             work( jj + nblst ) = c*temp - s*work( jj )
                             work( jj ) = s*temp + c*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - nblst - 1
                       end do
                       ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                       j0 = jrow - nnb
                       do jrow = j0, j+2, -nnb
                          ppw = ppwo
                          len  = 2 + j - jcol
                          do i = jrow+nnb-1, jrow, -1
                             c = a( i, j )
                             a( i, j ) = zero
                             s = b( i, j )
                             b( i, j ) = zero
                             do jj = ppw, ppw+len-1
                                temp = work( jj + 2*nnb )
                                work( jj + 2*nnb ) = c*temp - s*work( jj )
                                work( jj ) = s*temp + c*work( jj )
                             end do
                             len = len + 1
                             ppw = ppw - 2*nnb - 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end do
                 else
                    call stdlib_slaset( 'LOWER', ihi - jcol - 1, nnb, zero, zero,a( jcol + 2, &
                              jcol ), lda )
                    call stdlib_slaset( 'LOWER', ihi - jcol - 1, nnb, zero, zero,b( jcol + 2, &
                              jcol ), ldb )
                 end if
                 ! apply accumulated orthogonal matrices to a and b.
                 if ( top>0 ) then
                    j = ihi - nblst + 1
                    call stdlib_sgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, one, a( &
                              1, j ), lda,work, nblst, zero, work( pw ), top )
                    call stdlib_slacpy( 'ALL', top, nblst, work( pw ), top,a( 1, j ), lda )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_sorm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,a( 1, j ), lda, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_sgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                                    one, a( 1, j ), lda,work( ppwo ), 2*nnb, zero,work( pw ), top )
                          call stdlib_slacpy( 'ALL', top, 2*nnb, work( pw ), top,a( 1, j ), lda )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    j = ihi - nblst + 1
                    call stdlib_sgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, one, b( &
                              1, j ), ldb,work, nblst, zero, work( pw ), top )
                    call stdlib_slacpy( 'ALL', top, nblst, work( pw ), top,b( 1, j ), ldb )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_sorm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,b( 1, j ), ldb, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_sgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                                    one, b( 1, j ), ldb,work( ppwo ), 2*nnb, zero,work( pw ), top )
                          call stdlib_slacpy( 'ALL', top, 2*nnb, work( pw ), top,b( 1, j ), ldb )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! apply accumulated orthogonal matrices to z.
                 if( wantz ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_sgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, one, z( &
                              topq, j ), ldz,work, nblst, zero, work( pw ), nh )
                    call stdlib_slacpy( 'ALL', nh, nblst, work( pw ), nh,z( topq, j ), ldz )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                          if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_sorm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,z( topq, j ), ldz, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_sgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, one,&
                                     z( topq, j ), ldz,work( ppwo ), 2*nnb, zero, work( pw ),nh )
                          call stdlib_slacpy( 'ALL', nh, 2*nnb, work( pw ), nh,z( topq, j ), ldz )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           ! avoid re-initialization of modified q and z.
           compq2 = compq
           compz2 = compz
           if ( jcol/=ilo ) then
              if ( wantq )compq2 = 'V'
              if ( wantz )compz2 = 'V'
           end if
           if ( jcol<ihi )call stdlib_sgghrd( compq2, compz2, n, jcol, ihi, a, lda, b, ldb, q,ldq,&
                      z, ldz, ierr )
           work( 1 ) = real( lwkopt,KIND=sp)
           return
     end subroutine stdlib_sgghd3

     module pure subroutine stdlib_dgghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! DGGHD3 reduces a pair of real matrices (A,B) to generalized upper
     !! Hessenberg form using orthogonal transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the orthogonal matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**T*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**T*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**T*x.
     !! The orthogonal matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T
     !! Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T
     !! If Q1 is the orthogonal matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then DGGHD3 reduces the original
     !! problem to generalized Hessenberg form.
     !! This is a blocked variant of DGGHRD, using matrix-matrix
     !! multiplications for parts of the computation to enhance performance.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(dp), intent(out) :: work(*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: blk22, initq, initz, lquery, wantq, wantz
           character :: compq2, compz2
           integer(ilp) :: cola, i, ierr, j, j0, jcol, jj, jrow, k, kacc22, len, lwkopt, n2nb, nb,&
                      nblst, nbmin, nh, nnb, nx, ppw, ppwo, pw, top, topq
           real(dp) :: c, c1, c2, s, s1, s2, temp, temp1, temp2, temp3
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           nb = stdlib_ilaenv( 1, 'DGGHD3', ' ', n, ilo, ihi, -1 )
           lwkopt = max( 6*n*nb, 1 )
           work( 1 ) = real( lwkopt,KIND=dp)
           initq = stdlib_lsame( compq, 'I' )
           wantq = initq .or. stdlib_lsame( compq, 'V' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( wantq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( wantz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           else if( lwork<1 .and. .not.lquery ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGHD3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! initialize q and z if desired.
           if( initq )call stdlib_dlaset( 'ALL', n, n, zero, one, q, ldq )
           if( initz )call stdlib_dlaset( 'ALL', n, n, zero, one, z, ldz )
           ! zero out lower triangle of b.
           if( n>1 )call stdlib_dlaset( 'LOWER', n-1, n-1, zero, zero, b(2, 1), ldb )
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = one
              return
           end if
           ! determine the blocksize.
           nbmin = stdlib_ilaenv( 2, 'DGGHD3', ' ', n, ilo, ihi, -1 )
           if( nb>1 .and. nb<nh ) then
              ! determine when to use unblocked instead of blocked code.
              nx = max( nb, stdlib_ilaenv( 3, 'DGGHD3', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code.
                 if( lwork<lwkopt ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code.
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DGGHD3', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=6*n*nbmin ) then
                       nb = lwork / ( 6*n )
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              jcol = ilo
           else
              ! use blocked code
              kacc22 = stdlib_ilaenv( 16, 'DGGHD3', ' ', n, ilo, ihi, -1 )
              blk22 = kacc22==2
              do jcol = ilo, ihi-2, nb
                 nnb = min( nb, ihi-jcol-1 )
                 ! initialize small orthogonal factors that will hold the
                 ! accumulated givens rotations in workspace.
                 ! n2nb   denotes the number of 2*nnb-by-2*nnb factors
                 ! nblst  denotes the (possibly smaller) order of the last
                        ! factor.
                 n2nb = ( ihi-jcol-1 ) / nnb - 1
                 nblst = ihi - jcol - n2nb*nnb
                 call stdlib_dlaset( 'ALL', nblst, nblst, zero, one, work, nblst )
                 pw = nblst * nblst + 1
                 do i = 1, n2nb
                    call stdlib_dlaset( 'ALL', 2*nnb, 2*nnb, zero, one,work( pw ), 2*nnb )
                    pw = pw + 4*nnb*nnb
                 end do
                 ! reduce columns jcol:jcol+nnb-1 of a to hessenberg form.
                 do j = jcol, jcol+nnb-1
                    ! reduce jth column of a. store cosines and sines in jth
                    ! column of a and b, respectively.
                    do i = ihi, j+2, -1
                       temp = a( i-1, j )
                       call stdlib_dlartg( temp, a( i, j ), c, s, a( i-1, j ) )
                       a( i, j ) = c
                       b( i, j ) = s
                    end do
                    ! accumulate givens rotations into workspace array.
                    ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                    len  = 2 + j - jcol
                    jrow = j + n2nb*nnb + 2
                    do i = ihi, jrow, -1
                       c = a( i, j )
                       s = b( i, j )
                       do jj = ppw, ppw+len-1
                          temp = work( jj + nblst )
                          work( jj + nblst ) = c*temp - s*work( jj )
                          work( jj ) = s*temp + c*work( jj )
                       end do
                       len = len + 1
                       ppw = ppw - nblst - 1
                    end do
                    ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                    j0 = jrow - nnb
                    do jrow = j0, j+2, -nnb
                       ppw = ppwo
                       len  = 2 + j - jcol
                       do i = jrow+nnb-1, jrow, -1
                          c = a( i, j )
                          s = b( i, j )
                          do jj = ppw, ppw+len-1
                             temp = work( jj + 2*nnb )
                             work( jj + 2*nnb ) = c*temp - s*work( jj )
                             work( jj ) = s*temp + c*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - 2*nnb - 1
                       end do
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    ! top denotes the number of top rows in a and b that will
                    ! not be updated during the next steps.
                    if( jcol<=2 ) then
                       top = 0
                    else
                       top = jcol
                    end if
                    ! propagate transformations through b and replace stored
                    ! left sines/cosines by right sines/cosines.
                    do jj = n, j+1, -1
                       ! update jjth column of b.
                       do i = min( jj+1, ihi ), j+2, -1
                          c = a( i, j )
                          s = b( i, j )
                          temp = b( i, jj )
                          b( i, jj ) = c*temp - s*b( i-1, jj )
                          b( i-1, jj ) = s*temp + c*b( i-1, jj )
                       end do
                       ! annihilate b( jj+1, jj ).
                       if( jj<ihi ) then
                          temp = b( jj+1, jj+1 )
                          call stdlib_dlartg( temp, b( jj+1, jj ), c, s,b( jj+1, jj+1 ) )
                          b( jj+1, jj ) = zero
                          call stdlib_drot( jj-top, b( top+1, jj+1 ), 1,b( top+1, jj ), 1, c, s )
                                    
                          a( jj+1, j ) = c
                          b( jj+1, j ) = -s
                       end if
                    end do
                    ! update a by transformations from right.
                    ! explicit loop unrolling provides better performance
                    ! compared to stdlib_dlasr.
                     ! call stdlib_dlasr( 'right', 'variable', 'backward', ihi-top,
           ! $                     ihi-j, a( j+2, j ), b( j+2, j ),
           ! $                     a( top+1, j+1 ), lda )
                    jj = mod( ihi-j-1, 3 )
                    do i = ihi-j-3, jj+1, -3
                       c = a( j+1+i, j )
                       s = -b( j+1+i, j )
                       c1 = a( j+2+i, j )
                       s1 = -b( j+2+i, j )
                       c2 = a( j+3+i, j )
                       s2 = -b( j+3+i, j )
                       do k = top+1, ihi
                          temp = a( k, j+i  )
                          temp1 = a( k, j+i+1 )
                          temp2 = a( k, j+i+2 )
                          temp3 = a( k, j+i+3 )
                          a( k, j+i+3 ) = c2*temp3 + s2*temp2
                          temp2 = -s2*temp3 + c2*temp2
                          a( k, j+i+2 ) = c1*temp2 + s1*temp1
                          temp1 = -s1*temp2 + c1*temp1
                          a( k, j+i+1 ) = c*temp1 + s*temp
                          a( k, j+i ) = -s*temp1 + c*temp
                       end do
                    end do
                    if( jj>0 ) then
                       do i = jj, 1, -1
                          call stdlib_drot( ihi-top, a( top+1, j+i+1 ), 1,a( top+1, j+i ), 1, a( &
                                    j+1+i, j ),-b( j+1+i, j ) )
                       end do
                    end if
                    ! update (j+1)th column of a by transformations from left.
                    if ( j < jcol + nnb - 1 ) then
                       len  = 1 + j - jcol
                       ! multiply with the trailing accumulated orthogonal
                       ! matrix, which takes the form
                              ! [  u11  u12  ]
                          ! u = [            ],
                              ! [  u21  u22  ]
                       ! where u21 is a len-by-len matrix and u12 is lower
                       ! triangular.
                       jrow = ihi - nblst + 1
                       call stdlib_dgemv( 'TRANSPOSE', nblst, len, one, work,nblst, a( jrow, j+1 )&
                                 , 1, zero,work( pw ), 1 )
                       ppw = pw + len
                       do i = jrow, jrow+nblst-len-1
                          work( ppw ) = a( i, j+1 )
                          ppw = ppw + 1
                       end do
                       call stdlib_dtrmv( 'LOWER', 'TRANSPOSE', 'NON-UNIT',nblst-len, work( &
                                 len*nblst + 1 ), nblst,work( pw+len ), 1 )
                       call stdlib_dgemv( 'TRANSPOSE', len, nblst-len, one,work( (len+1)*nblst - &
                       len + 1 ), nblst,a( jrow+nblst-len, j+1 ), 1, one,work( pw+len ), 1 )
                                 
                       ppw = pw
                       do i = jrow, jrow+nblst-1
                          a( i, j+1 ) = work( ppw )
                          ppw = ppw + 1
                       end do
                       ! multiply with the other accumulated orthogonal
                       ! matrices, which take the form
                              ! [  u11  u12   0  ]
                              ! [                ]
                          ! u = [  u21  u22   0  ],
                              ! [                ]
                              ! [   0    0    i  ]
                       ! where i denotes the (nnb-len)-by-(nnb-len) identity
                       ! matrix, u21 is a len-by-len upper triangular matrix
                       ! and u12 is an nnb-by-nnb lower triangular matrix.
                       ppwo = 1 + nblst*nblst
                       j0 = jrow - nnb
                       do jrow = j0, jcol+1, -nnb
                          ppw = pw + len
                          do i = jrow, jrow+nnb-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          ppw = pw
                          do i = jrow+nnb, jrow+nnb+len-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          call stdlib_dtrmv( 'UPPER', 'TRANSPOSE', 'NON-UNIT', len,work( ppwo + &
                                    nnb ), 2*nnb, work( pw ),1 )
                          call stdlib_dtrmv( 'LOWER', 'TRANSPOSE', 'NON-UNIT', nnb,work( ppwo + &
                                    2*len*nnb ),2*nnb, work( pw + len ), 1 )
                          call stdlib_dgemv( 'TRANSPOSE', nnb, len, one,work( ppwo ), 2*nnb, a( &
                                    jrow, j+1 ), 1,one, work( pw ), 1 )
                          call stdlib_dgemv( 'TRANSPOSE', len, nnb, one,work( ppwo + 2*len*nnb + &
                                    nnb ), 2*nnb,a( jrow+nnb, j+1 ), 1, one,work( pw+len ), 1 )
                          ppw = pw
                          do i = jrow, jrow+len+nnb-1
                             a( i, j+1 ) = work( ppw )
                             ppw = ppw + 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end if
                 end do
                 ! apply accumulated orthogonal matrices to a.
                 cola = n - jcol - nnb + 1
                 j = ihi - nblst + 1
                 call stdlib_dgemm( 'TRANSPOSE', 'NO TRANSPOSE', nblst,cola, nblst, one, work, &
                           nblst,a( j, jcol+nnb ), lda, zero, work( pw ),nblst )
                 call stdlib_dlacpy( 'ALL', nblst, cola, work( pw ), nblst,a( j, jcol+nnb ), lda )
                           
                 ppwo = nblst*nblst + 1
                 j0 = j - nnb
                 do j = j0, jcol+1, -nnb
                    if ( blk22 ) then
                       ! exploit the structure of
                              ! [  u11  u12  ]
                          ! u = [            ]
                              ! [  u21  u22  ],
                       ! where all blocks are nnb-by-nnb, u21 is upper
                       ! triangular and u12 is lower triangular.
                       call stdlib_dorm22( 'LEFT', 'TRANSPOSE', 2*nnb, cola, nnb,nnb, work( ppwo )&
                                 , 2*nnb,a( j, jcol+nnb ), lda, work( pw ),lwork-pw+1, ierr )
                    else
                       ! ignore the structure of u.
                       call stdlib_dgemm( 'TRANSPOSE', 'NO TRANSPOSE', 2*nnb,cola, 2*nnb, one, &
                                 work( ppwo ), 2*nnb,a( j, jcol+nnb ), lda, zero, work( pw ),2*nnb )
                       call stdlib_dlacpy( 'ALL', 2*nnb, cola, work( pw ), 2*nnb,a( j, jcol+nnb ),&
                                  lda )
                    end if
                    ppwo = ppwo + 4*nnb*nnb
                 end do
                 ! apply accumulated orthogonal matrices to q.
                 if( wantq ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_dgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, one, q( &
                              topq, j ), ldq,work, nblst, zero, work( pw ), nh )
                    call stdlib_dlacpy( 'ALL', nh, nblst, work( pw ), nh,q( topq, j ), ldq )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_dorm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,q( topq, j ), ldq, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_dgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, one,&
                                     q( topq, j ), ldq,work( ppwo ), 2*nnb, zero, work( pw ),nh )
                          call stdlib_dlacpy( 'ALL', nh, 2*nnb, work( pw ), nh,q( topq, j ), ldq )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! accumulate right givens rotations if required.
                 if ( wantz .or. top>0 ) then
                    ! initialize small orthogonal factors that will hold the
                    ! accumulated givens rotations in workspace.
                    call stdlib_dlaset( 'ALL', nblst, nblst, zero, one, work,nblst )
                    pw = nblst * nblst + 1
                    do i = 1, n2nb
                       call stdlib_dlaset( 'ALL', 2*nnb, 2*nnb, zero, one,work( pw ), 2*nnb )
                                 
                       pw = pw + 4*nnb*nnb
                    end do
                    ! accumulate givens rotations into workspace array.
                    do j = jcol, jcol+nnb-1
                       ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                       len  = 2 + j - jcol
                       jrow = j + n2nb*nnb + 2
                       do i = ihi, jrow, -1
                          c = a( i, j )
                          a( i, j ) = zero
                          s = b( i, j )
                          b( i, j ) = zero
                          do jj = ppw, ppw+len-1
                             temp = work( jj + nblst )
                             work( jj + nblst ) = c*temp - s*work( jj )
                             work( jj ) = s*temp + c*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - nblst - 1
                       end do
                       ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                       j0 = jrow - nnb
                       do jrow = j0, j+2, -nnb
                          ppw = ppwo
                          len  = 2 + j - jcol
                          do i = jrow+nnb-1, jrow, -1
                             c = a( i, j )
                             a( i, j ) = zero
                             s = b( i, j )
                             b( i, j ) = zero
                             do jj = ppw, ppw+len-1
                                temp = work( jj + 2*nnb )
                                work( jj + 2*nnb ) = c*temp - s*work( jj )
                                work( jj ) = s*temp + c*work( jj )
                             end do
                             len = len + 1
                             ppw = ppw - 2*nnb - 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end do
                 else
                    call stdlib_dlaset( 'LOWER', ihi - jcol - 1, nnb, zero, zero,a( jcol + 2, &
                              jcol ), lda )
                    call stdlib_dlaset( 'LOWER', ihi - jcol - 1, nnb, zero, zero,b( jcol + 2, &
                              jcol ), ldb )
                 end if
                 ! apply accumulated orthogonal matrices to a and b.
                 if ( top>0 ) then
                    j = ihi - nblst + 1
                    call stdlib_dgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, one, a( &
                              1, j ), lda,work, nblst, zero, work( pw ), top )
                    call stdlib_dlacpy( 'ALL', top, nblst, work( pw ), top,a( 1, j ), lda )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_dorm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,a( 1, j ), lda, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_dgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                                    one, a( 1, j ), lda,work( ppwo ), 2*nnb, zero,work( pw ), top )
                          call stdlib_dlacpy( 'ALL', top, 2*nnb, work( pw ), top,a( 1, j ), lda )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    j = ihi - nblst + 1
                    call stdlib_dgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, one, b( &
                              1, j ), ldb,work, nblst, zero, work( pw ), top )
                    call stdlib_dlacpy( 'ALL', top, nblst, work( pw ), top,b( 1, j ), ldb )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_dorm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,b( 1, j ), ldb, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_dgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                                    one, b( 1, j ), ldb,work( ppwo ), 2*nnb, zero,work( pw ), top )
                          call stdlib_dlacpy( 'ALL', top, 2*nnb, work( pw ), top,b( 1, j ), ldb )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! apply accumulated orthogonal matrices to z.
                 if( wantz ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_dgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, one, z( &
                              topq, j ), ldz,work, nblst, zero, work( pw ), nh )
                    call stdlib_dlacpy( 'ALL', nh, nblst, work( pw ), nh,z( topq, j ), ldz )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                          if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_dorm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,z( topq, j ), ldz, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_dgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, one,&
                                     z( topq, j ), ldz,work( ppwo ), 2*nnb, zero, work( pw ),nh )
                          call stdlib_dlacpy( 'ALL', nh, 2*nnb, work( pw ), nh,z( topq, j ), ldz )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           ! avoid re-initialization of modified q and z.
           compq2 = compq
           compz2 = compz
           if ( jcol/=ilo ) then
              if ( wantq )compq2 = 'V'
              if ( wantz )compz2 = 'V'
           end if
           if ( jcol<ihi )call stdlib_dgghrd( compq2, compz2, n, jcol, ihi, a, lda, b, ldb, q,ldq,&
                      z, ldz, ierr )
           work( 1 ) = real( lwkopt,KIND=dp)
           return
     end subroutine stdlib_dgghd3

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$gghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! DGGHD3: reduces a pair of real matrices (A,B) to generalized upper
     !! Hessenberg form using orthogonal transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the orthogonal matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**T*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**T*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**T*x.
     !! The orthogonal matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T
     !! Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T
     !! If Q1 is the orthogonal matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then DGGHD3 reduces the original
     !! problem to generalized Hessenberg form.
     !! This is a blocked variant of DGGHRD, using matrix-matrix
     !! multiplications for parts of the computation to enhance performance.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
       ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: blk22, initq, initz, lquery, wantq, wantz
           character :: compq2, compz2
           integer(ilp) :: cola, i, ierr, j, j0, jcol, jj, jrow, k, kacc22, len, lwkopt, n2nb, nb,&
                      nblst, nbmin, nh, nnb, nx, ppw, ppwo, pw, top, topq
           real(${rk}$) :: c, c1, c2, s, s1, s2, temp, temp1, temp2, temp3
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           nb = stdlib_ilaenv( 1, 'DGGHD3', ' ', n, ilo, ihi, -1 )
           lwkopt = max( 6*n*nb, 1 )
           work( 1 ) = real( lwkopt,KIND=${rk}$)
           initq = stdlib_lsame( compq, 'I' )
           wantq = initq .or. stdlib_lsame( compq, 'V' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( wantq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( wantz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           else if( lwork<1 .and. .not.lquery ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGHD3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! initialize q and z if desired.
           if( initq )call stdlib_${ri}$laset( 'ALL', n, n, zero, one, q, ldq )
           if( initz )call stdlib_${ri}$laset( 'ALL', n, n, zero, one, z, ldz )
           ! zero out lower triangle of b.
           if( n>1 )call stdlib_${ri}$laset( 'LOWER', n-1, n-1, zero, zero, b(2, 1), ldb )
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = one
              return
           end if
           ! determine the blocksize.
           nbmin = stdlib_ilaenv( 2, 'DGGHD3', ' ', n, ilo, ihi, -1 )
           if( nb>1 .and. nb<nh ) then
              ! determine when to use unblocked instead of blocked code.
              nx = max( nb, stdlib_ilaenv( 3, 'DGGHD3', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code.
                 if( lwork<lwkopt ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code.
                    nbmin = max( 2, stdlib_ilaenv( 2, 'DGGHD3', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=6*n*nbmin ) then
                       nb = lwork / ( 6*n )
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              jcol = ilo
           else
              ! use blocked code
              kacc22 = stdlib_ilaenv( 16, 'DGGHD3', ' ', n, ilo, ihi, -1 )
              blk22 = kacc22==2
              do jcol = ilo, ihi-2, nb
                 nnb = min( nb, ihi-jcol-1 )
                 ! initialize small orthogonal factors that will hold the
                 ! accumulated givens rotations in workspace.
                 ! n2nb   denotes the number of 2*nnb-by-2*nnb factors
                 ! nblst  denotes the (possibly smaller) order of the last
                        ! factor.
                 n2nb = ( ihi-jcol-1 ) / nnb - 1
                 nblst = ihi - jcol - n2nb*nnb
                 call stdlib_${ri}$laset( 'ALL', nblst, nblst, zero, one, work, nblst )
                 pw = nblst * nblst + 1
                 do i = 1, n2nb
                    call stdlib_${ri}$laset( 'ALL', 2*nnb, 2*nnb, zero, one,work( pw ), 2*nnb )
                    pw = pw + 4*nnb*nnb
                 end do
                 ! reduce columns jcol:jcol+nnb-1 of a to hessenberg form.
                 do j = jcol, jcol+nnb-1
                    ! reduce jth column of a. store cosines and sines in jth
                    ! column of a and b, respectively.
                    do i = ihi, j+2, -1
                       temp = a( i-1, j )
                       call stdlib_${ri}$lartg( temp, a( i, j ), c, s, a( i-1, j ) )
                       a( i, j ) = c
                       b( i, j ) = s
                    end do
                    ! accumulate givens rotations into workspace array.
                    ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                    len  = 2 + j - jcol
                    jrow = j + n2nb*nnb + 2
                    do i = ihi, jrow, -1
                       c = a( i, j )
                       s = b( i, j )
                       do jj = ppw, ppw+len-1
                          temp = work( jj + nblst )
                          work( jj + nblst ) = c*temp - s*work( jj )
                          work( jj ) = s*temp + c*work( jj )
                       end do
                       len = len + 1
                       ppw = ppw - nblst - 1
                    end do
                    ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                    j0 = jrow - nnb
                    do jrow = j0, j+2, -nnb
                       ppw = ppwo
                       len  = 2 + j - jcol
                       do i = jrow+nnb-1, jrow, -1
                          c = a( i, j )
                          s = b( i, j )
                          do jj = ppw, ppw+len-1
                             temp = work( jj + 2*nnb )
                             work( jj + 2*nnb ) = c*temp - s*work( jj )
                             work( jj ) = s*temp + c*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - 2*nnb - 1
                       end do
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    ! top denotes the number of top rows in a and b that will
                    ! not be updated during the next steps.
                    if( jcol<=2 ) then
                       top = 0
                    else
                       top = jcol
                    end if
                    ! propagate transformations through b and replace stored
                    ! left sines/cosines by right sines/cosines.
                    do jj = n, j+1, -1
                       ! update jjth column of b.
                       do i = min( jj+1, ihi ), j+2, -1
                          c = a( i, j )
                          s = b( i, j )
                          temp = b( i, jj )
                          b( i, jj ) = c*temp - s*b( i-1, jj )
                          b( i-1, jj ) = s*temp + c*b( i-1, jj )
                       end do
                       ! annihilate b( jj+1, jj ).
                       if( jj<ihi ) then
                          temp = b( jj+1, jj+1 )
                          call stdlib_${ri}$lartg( temp, b( jj+1, jj ), c, s,b( jj+1, jj+1 ) )
                          b( jj+1, jj ) = zero
                          call stdlib_${ri}$rot( jj-top, b( top+1, jj+1 ), 1,b( top+1, jj ), 1, c, s )
                                    
                          a( jj+1, j ) = c
                          b( jj+1, j ) = -s
                       end if
                    end do
                    ! update a by transformations from right.
                    ! explicit loop unrolling provides better performance
                    ! compared to stdlib_${ri}$lasr.
                     ! call stdlib_${ri}$lasr( 'right', 'variable', 'backward', ihi-top,
           ! $                     ihi-j, a( j+2, j ), b( j+2, j ),
           ! $                     a( top+1, j+1 ), lda )
                    jj = mod( ihi-j-1, 3 )
                    do i = ihi-j-3, jj+1, -3
                       c = a( j+1+i, j )
                       s = -b( j+1+i, j )
                       c1 = a( j+2+i, j )
                       s1 = -b( j+2+i, j )
                       c2 = a( j+3+i, j )
                       s2 = -b( j+3+i, j )
                       do k = top+1, ihi
                          temp = a( k, j+i  )
                          temp1 = a( k, j+i+1 )
                          temp2 = a( k, j+i+2 )
                          temp3 = a( k, j+i+3 )
                          a( k, j+i+3 ) = c2*temp3 + s2*temp2
                          temp2 = -s2*temp3 + c2*temp2
                          a( k, j+i+2 ) = c1*temp2 + s1*temp1
                          temp1 = -s1*temp2 + c1*temp1
                          a( k, j+i+1 ) = c*temp1 + s*temp
                          a( k, j+i ) = -s*temp1 + c*temp
                       end do
                    end do
                    if( jj>0 ) then
                       do i = jj, 1, -1
                          call stdlib_${ri}$rot( ihi-top, a( top+1, j+i+1 ), 1,a( top+1, j+i ), 1, a( &
                                    j+1+i, j ),-b( j+1+i, j ) )
                       end do
                    end if
                    ! update (j+1)th column of a by transformations from left.
                    if ( j < jcol + nnb - 1 ) then
                       len  = 1 + j - jcol
                       ! multiply with the trailing accumulated orthogonal
                       ! matrix, which takes the form
                              ! [  u11  u12  ]
                          ! u = [            ],
                              ! [  u21  u22  ]
                       ! where u21 is a len-by-len matrix and u12 is lower
                       ! triangular.
                       jrow = ihi - nblst + 1
                       call stdlib_${ri}$gemv( 'TRANSPOSE', nblst, len, one, work,nblst, a( jrow, j+1 )&
                                 , 1, zero,work( pw ), 1 )
                       ppw = pw + len
                       do i = jrow, jrow+nblst-len-1
                          work( ppw ) = a( i, j+1 )
                          ppw = ppw + 1
                       end do
                       call stdlib_${ri}$trmv( 'LOWER', 'TRANSPOSE', 'NON-UNIT',nblst-len, work( &
                                 len*nblst + 1 ), nblst,work( pw+len ), 1 )
                       call stdlib_${ri}$gemv( 'TRANSPOSE', len, nblst-len, one,work( (len+1)*nblst - &
                       len + 1 ), nblst,a( jrow+nblst-len, j+1 ), 1, one,work( pw+len ), 1 )
                                 
                       ppw = pw
                       do i = jrow, jrow+nblst-1
                          a( i, j+1 ) = work( ppw )
                          ppw = ppw + 1
                       end do
                       ! multiply with the other accumulated orthogonal
                       ! matrices, which take the form
                              ! [  u11  u12   0  ]
                              ! [                ]
                          ! u = [  u21  u22   0  ],
                              ! [                ]
                              ! [   0    0    i  ]
                       ! where i denotes the (nnb-len)-by-(nnb-len) identity
                       ! matrix, u21 is a len-by-len upper triangular matrix
                       ! and u12 is an nnb-by-nnb lower triangular matrix.
                       ppwo = 1 + nblst*nblst
                       j0 = jrow - nnb
                       do jrow = j0, jcol+1, -nnb
                          ppw = pw + len
                          do i = jrow, jrow+nnb-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          ppw = pw
                          do i = jrow+nnb, jrow+nnb+len-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          call stdlib_${ri}$trmv( 'UPPER', 'TRANSPOSE', 'NON-UNIT', len,work( ppwo + &
                                    nnb ), 2*nnb, work( pw ),1 )
                          call stdlib_${ri}$trmv( 'LOWER', 'TRANSPOSE', 'NON-UNIT', nnb,work( ppwo + &
                                    2*len*nnb ),2*nnb, work( pw + len ), 1 )
                          call stdlib_${ri}$gemv( 'TRANSPOSE', nnb, len, one,work( ppwo ), 2*nnb, a( &
                                    jrow, j+1 ), 1,one, work( pw ), 1 )
                          call stdlib_${ri}$gemv( 'TRANSPOSE', len, nnb, one,work( ppwo + 2*len*nnb + &
                                    nnb ), 2*nnb,a( jrow+nnb, j+1 ), 1, one,work( pw+len ), 1 )
                          ppw = pw
                          do i = jrow, jrow+len+nnb-1
                             a( i, j+1 ) = work( ppw )
                             ppw = ppw + 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end if
                 end do
                 ! apply accumulated orthogonal matrices to a.
                 cola = n - jcol - nnb + 1
                 j = ihi - nblst + 1
                 call stdlib_${ri}$gemm( 'TRANSPOSE', 'NO TRANSPOSE', nblst,cola, nblst, one, work, &
                           nblst,a( j, jcol+nnb ), lda, zero, work( pw ),nblst )
                 call stdlib_${ri}$lacpy( 'ALL', nblst, cola, work( pw ), nblst,a( j, jcol+nnb ), lda )
                           
                 ppwo = nblst*nblst + 1
                 j0 = j - nnb
                 do j = j0, jcol+1, -nnb
                    if ( blk22 ) then
                       ! exploit the structure of
                              ! [  u11  u12  ]
                          ! u = [            ]
                              ! [  u21  u22  ],
                       ! where all blocks are nnb-by-nnb, u21 is upper
                       ! triangular and u12 is lower triangular.
                       call stdlib_${ri}$orm22( 'LEFT', 'TRANSPOSE', 2*nnb, cola, nnb,nnb, work( ppwo )&
                                 , 2*nnb,a( j, jcol+nnb ), lda, work( pw ),lwork-pw+1, ierr )
                    else
                       ! ignore the structure of u.
                       call stdlib_${ri}$gemm( 'TRANSPOSE', 'NO TRANSPOSE', 2*nnb,cola, 2*nnb, one, &
                                 work( ppwo ), 2*nnb,a( j, jcol+nnb ), lda, zero, work( pw ),2*nnb )
                       call stdlib_${ri}$lacpy( 'ALL', 2*nnb, cola, work( pw ), 2*nnb,a( j, jcol+nnb ),&
                                  lda )
                    end if
                    ppwo = ppwo + 4*nnb*nnb
                 end do
                 ! apply accumulated orthogonal matrices to q.
                 if( wantq ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, one, q( &
                              topq, j ), ldq,work, nblst, zero, work( pw ), nh )
                    call stdlib_${ri}$lacpy( 'ALL', nh, nblst, work( pw ), nh,q( topq, j ), ldq )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ri}$orm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,q( topq, j ), ldq, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, one,&
                                     q( topq, j ), ldq,work( ppwo ), 2*nnb, zero, work( pw ),nh )
                          call stdlib_${ri}$lacpy( 'ALL', nh, 2*nnb, work( pw ), nh,q( topq, j ), ldq )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! accumulate right givens rotations if required.
                 if ( wantz .or. top>0 ) then
                    ! initialize small orthogonal factors that will hold the
                    ! accumulated givens rotations in workspace.
                    call stdlib_${ri}$laset( 'ALL', nblst, nblst, zero, one, work,nblst )
                    pw = nblst * nblst + 1
                    do i = 1, n2nb
                       call stdlib_${ri}$laset( 'ALL', 2*nnb, 2*nnb, zero, one,work( pw ), 2*nnb )
                                 
                       pw = pw + 4*nnb*nnb
                    end do
                    ! accumulate givens rotations into workspace array.
                    do j = jcol, jcol+nnb-1
                       ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                       len  = 2 + j - jcol
                       jrow = j + n2nb*nnb + 2
                       do i = ihi, jrow, -1
                          c = a( i, j )
                          a( i, j ) = zero
                          s = b( i, j )
                          b( i, j ) = zero
                          do jj = ppw, ppw+len-1
                             temp = work( jj + nblst )
                             work( jj + nblst ) = c*temp - s*work( jj )
                             work( jj ) = s*temp + c*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - nblst - 1
                       end do
                       ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                       j0 = jrow - nnb
                       do jrow = j0, j+2, -nnb
                          ppw = ppwo
                          len  = 2 + j - jcol
                          do i = jrow+nnb-1, jrow, -1
                             c = a( i, j )
                             a( i, j ) = zero
                             s = b( i, j )
                             b( i, j ) = zero
                             do jj = ppw, ppw+len-1
                                temp = work( jj + 2*nnb )
                                work( jj + 2*nnb ) = c*temp - s*work( jj )
                                work( jj ) = s*temp + c*work( jj )
                             end do
                             len = len + 1
                             ppw = ppw - 2*nnb - 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end do
                 else
                    call stdlib_${ri}$laset( 'LOWER', ihi - jcol - 1, nnb, zero, zero,a( jcol + 2, &
                              jcol ), lda )
                    call stdlib_${ri}$laset( 'LOWER', ihi - jcol - 1, nnb, zero, zero,b( jcol + 2, &
                              jcol ), ldb )
                 end if
                 ! apply accumulated orthogonal matrices to a and b.
                 if ( top>0 ) then
                    j = ihi - nblst + 1
                    call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, one, a( &
                              1, j ), lda,work, nblst, zero, work( pw ), top )
                    call stdlib_${ri}$lacpy( 'ALL', top, nblst, work( pw ), top,a( 1, j ), lda )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ri}$orm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,a( 1, j ), lda, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                                    one, a( 1, j ), lda,work( ppwo ), 2*nnb, zero,work( pw ), top )
                          call stdlib_${ri}$lacpy( 'ALL', top, 2*nnb, work( pw ), top,a( 1, j ), lda )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    j = ihi - nblst + 1
                    call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, one, b( &
                              1, j ), ldb,work, nblst, zero, work( pw ), top )
                    call stdlib_${ri}$lacpy( 'ALL', top, nblst, work( pw ), top,b( 1, j ), ldb )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ri}$orm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,b( 1, j ), ldb, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                                    one, b( 1, j ), ldb,work( ppwo ), 2*nnb, zero,work( pw ), top )
                          call stdlib_${ri}$lacpy( 'ALL', top, 2*nnb, work( pw ), top,b( 1, j ), ldb )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! apply accumulated orthogonal matrices to z.
                 if( wantz ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, one, z( &
                              topq, j ), ldz,work, nblst, zero, work( pw ), nh )
                    call stdlib_${ri}$lacpy( 'ALL', nh, nblst, work( pw ), nh,z( topq, j ), ldz )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                          if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ri}$orm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,z( topq, j ), ldz, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ri}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, one,&
                                     z( topq, j ), ldz,work( ppwo ), 2*nnb, zero, work( pw ),nh )
                          call stdlib_${ri}$lacpy( 'ALL', nh, 2*nnb, work( pw ), nh,z( topq, j ), ldz )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           ! avoid re-initialization of modified q and z.
           compq2 = compq
           compz2 = compz
           if ( jcol/=ilo ) then
              if ( wantq )compq2 = 'V'
              if ( wantz )compz2 = 'V'
           end if
           if ( jcol<ihi )call stdlib_${ri}$gghrd( compq2, compz2, n, jcol, ihi, a, lda, b, ldb, q,ldq,&
                      z, ldz, ierr )
           work( 1 ) = real( lwkopt,KIND=${rk}$)
           return
     end subroutine stdlib_${ri}$gghd3

#:endif
#:endfor

     module pure subroutine stdlib_cgghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! CGGHD3 reduces a pair of complex matrices (A,B) to generalized upper
     !! Hessenberg form using unitary transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the unitary matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**H*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**H*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**H*x.
     !! The unitary matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
     !! Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
     !! If Q1 is the unitary matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then CGGHD3 reduces the original
     !! problem to generalized Hessenberg form.
     !! This is a blocked variant of CGGHRD, using matrix-matrix
     !! multiplications for parts of the computation to enhance performance.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: blk22, initq, initz, lquery, wantq, wantz
           character :: compq2, compz2
           integer(ilp) :: cola, i, ierr, j, j0, jcol, jj, jrow, k, kacc22, len, lwkopt, n2nb, nb,&
                      nblst, nbmin, nh, nnb, nx, ppw, ppwo, pw, top, topq
           real(sp) :: c
           complex(sp) :: c1, c2, ctemp, s, s1, s2, temp, temp1, temp2, temp3
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           nb = stdlib_ilaenv( 1, 'CGGHD3', ' ', n, ilo, ihi, -1 )
           lwkopt = max( 6*n*nb, 1 )
           work( 1 ) = cmplx( lwkopt,KIND=sp)
           initq = stdlib_lsame( compq, 'I' )
           wantq = initq .or. stdlib_lsame( compq, 'V' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( wantq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( wantz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           else if( lwork<1 .and. .not.lquery ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGHD3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! initialize q and z if desired.
           if( initq )call stdlib_claset( 'ALL', n, n, czero, cone, q, ldq )
           if( initz )call stdlib_claset( 'ALL', n, n, czero, cone, z, ldz )
           ! zero out lower triangle of b.
           if( n>1 )call stdlib_claset( 'LOWER', n-1, n-1, czero, czero, b(2, 1), ldb )
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = cone
              return
           end if
           ! determine the blocksize.
           nbmin = stdlib_ilaenv( 2, 'CGGHD3', ' ', n, ilo, ihi, -1 )
           if( nb>1 .and. nb<nh ) then
              ! determine when to use unblocked instead of blocked code.
              nx = max( nb, stdlib_ilaenv( 3, 'CGGHD3', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code.
                 if( lwork<lwkopt ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code.
                    nbmin = max( 2, stdlib_ilaenv( 2, 'CGGHD3', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=6*n*nbmin ) then
                       nb = lwork / ( 6*n )
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              jcol = ilo
           else
              ! use blocked code
              kacc22 = stdlib_ilaenv( 16, 'CGGHD3', ' ', n, ilo, ihi, -1 )
              blk22 = kacc22==2
              do jcol = ilo, ihi-2, nb
                 nnb = min( nb, ihi-jcol-1 )
                 ! initialize small unitary factors that will hold the
                 ! accumulated givens rotations in workspace.
                 ! n2nb   denotes the number of 2*nnb-by-2*nnb factors
                 ! nblst  denotes the (possibly smaller) order of the last
                        ! factor.
                 n2nb = ( ihi-jcol-1 ) / nnb - 1
                 nblst = ihi - jcol - n2nb*nnb
                 call stdlib_claset( 'ALL', nblst, nblst, czero, cone, work, nblst )
                 pw = nblst * nblst + 1
                 do i = 1, n2nb
                    call stdlib_claset( 'ALL', 2*nnb, 2*nnb, czero, cone,work( pw ), 2*nnb )
                              
                    pw = pw + 4*nnb*nnb
                 end do
                 ! reduce columns jcol:jcol+nnb-1 of a to hessenberg form.
                 do j = jcol, jcol+nnb-1
                    ! reduce jth column of a. store cosines and sines in jth
                    ! column of a and b, respectively.
                    do i = ihi, j+2, -1
                       temp = a( i-1, j )
                       call stdlib_clartg( temp, a( i, j ), c, s, a( i-1, j ) )
                       a( i, j ) = cmplx( c,KIND=sp)
                       b( i, j ) = s
                    end do
                    ! accumulate givens rotations into workspace array.
                    ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                    len  = 2 + j - jcol
                    jrow = j + n2nb*nnb + 2
                    do i = ihi, jrow, -1
                       ctemp = a( i, j )
                       s = b( i, j )
                       do jj = ppw, ppw+len-1
                          temp = work( jj + nblst )
                          work( jj + nblst ) = ctemp*temp - s*work( jj )
                          work( jj ) = conjg( s )*temp + ctemp*work( jj )
                       end do
                       len = len + 1
                       ppw = ppw - nblst - 1
                    end do
                    ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                    j0 = jrow - nnb
                    do jrow = j0, j+2, -nnb
                       ppw = ppwo
                       len  = 2 + j - jcol
                       do i = jrow+nnb-1, jrow, -1
                          ctemp = a( i, j )
                          s = b( i, j )
                          do jj = ppw, ppw+len-1
                             temp = work( jj + 2*nnb )
                             work( jj + 2*nnb ) = ctemp*temp - s*work( jj )
                             work( jj ) = conjg( s )*temp + ctemp*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - 2*nnb - 1
                       end do
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    ! top denotes the number of top rows in a and b that will
                    ! not be updated during the next steps.
                    if( jcol<=2 ) then
                       top = 0
                    else
                       top = jcol
                    end if
                    ! propagate transformations through b and replace stored
                    ! left sines/cosines by right sines/cosines.
                    do jj = n, j+1, -1
                       ! update jjth column of b.
                       do i = min( jj+1, ihi ), j+2, -1
                          ctemp = a( i, j )
                          s = b( i, j )
                          temp = b( i, jj )
                          b( i, jj ) = ctemp*temp - conjg( s )*b( i-1, jj )
                          b( i-1, jj ) = s*temp + ctemp*b( i-1, jj )
                       end do
                       ! annihilate b( jj+1, jj ).
                       if( jj<ihi ) then
                          temp = b( jj+1, jj+1 )
                          call stdlib_clartg( temp, b( jj+1, jj ), c, s,b( jj+1, jj+1 ) )
                          b( jj+1, jj ) = czero
                          call stdlib_crot( jj-top, b( top+1, jj+1 ), 1,b( top+1, jj ), 1, c, s )
                                    
                          a( jj+1, j ) = cmplx( c,KIND=sp)
                          b( jj+1, j ) = -conjg( s )
                       end if
                    end do
                    ! update a by transformations from right.
                    jj = mod( ihi-j-1, 3 )
                    do i = ihi-j-3, jj+1, -3
                       ctemp = a( j+1+i, j )
                       s = -b( j+1+i, j )
                       c1 = a( j+2+i, j )
                       s1 = -b( j+2+i, j )
                       c2 = a( j+3+i, j )
                       s2 = -b( j+3+i, j )
                       do k = top+1, ihi
                          temp = a( k, j+i  )
                          temp1 = a( k, j+i+1 )
                          temp2 = a( k, j+i+2 )
                          temp3 = a( k, j+i+3 )
                          a( k, j+i+3 ) = c2*temp3 + conjg( s2 )*temp2
                          temp2 = -s2*temp3 + c2*temp2
                          a( k, j+i+2 ) = c1*temp2 + conjg( s1 )*temp1
                          temp1 = -s1*temp2 + c1*temp1
                          a( k, j+i+1 ) = ctemp*temp1 + conjg( s )*temp
                          a( k, j+i ) = -s*temp1 + ctemp*temp
                       end do
                    end do
                    if( jj>0 ) then
                       do i = jj, 1, -1
                          c = real( a( j+1+i, j ),KIND=sp)
                          call stdlib_crot( ihi-top, a( top+1, j+i+1 ), 1,a( top+1, j+i ), 1, c,-&
                                    conjg( b( j+1+i, j ) ) )
                       end do
                    end if
                    ! update (j+1)th column of a by transformations from left.
                    if ( j < jcol + nnb - 1 ) then
                       len  = 1 + j - jcol
                       ! multiply with the trailing accumulated unitary
                       ! matrix, which takes the form
                              ! [  u11  u12  ]
                          ! u = [            ],
                              ! [  u21  u22  ]
                       ! where u21 is a len-by-len matrix and u12 is lower
                       ! triangular.
                       jrow = ihi - nblst + 1
                       call stdlib_cgemv( 'CONJUGATE', nblst, len, cone, work,nblst, a( jrow, j+1 &
                                 ), 1, czero,work( pw ), 1 )
                       ppw = pw + len
                       do i = jrow, jrow+nblst-len-1
                          work( ppw ) = a( i, j+1 )
                          ppw = ppw + 1
                       end do
                       call stdlib_ctrmv( 'LOWER', 'CONJUGATE', 'NON-UNIT',nblst-len, work( &
                                 len*nblst + 1 ), nblst,work( pw+len ), 1 )
                       call stdlib_cgemv( 'CONJUGATE', len, nblst-len, cone,work( (len+1)*nblst - &
                       len + 1 ), nblst,a( jrow+nblst-len, j+1 ), 1, cone,work( pw+len ), 1 )
                                 
                       ppw = pw
                       do i = jrow, jrow+nblst-1
                          a( i, j+1 ) = work( ppw )
                          ppw = ppw + 1
                       end do
                       ! multiply with the other accumulated unitary
                       ! matrices, which take the form
                              ! [  u11  u12   0  ]
                              ! [                ]
                          ! u = [  u21  u22   0  ],
                              ! [                ]
                              ! [   0    0    i  ]
                       ! where i denotes the (nnb-len)-by-(nnb-len) identity
                       ! matrix, u21 is a len-by-len upper triangular matrix
                       ! and u12 is an nnb-by-nnb lower triangular matrix.
                       ppwo = 1 + nblst*nblst
                       j0 = jrow - nnb
                       do jrow = j0, jcol+1, -nnb
                          ppw = pw + len
                          do i = jrow, jrow+nnb-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          ppw = pw
                          do i = jrow+nnb, jrow+nnb+len-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          call stdlib_ctrmv( 'UPPER', 'CONJUGATE', 'NON-UNIT', len,work( ppwo + &
                                    nnb ), 2*nnb, work( pw ),1 )
                          call stdlib_ctrmv( 'LOWER', 'CONJUGATE', 'NON-UNIT', nnb,work( ppwo + &
                                    2*len*nnb ),2*nnb, work( pw + len ), 1 )
                          call stdlib_cgemv( 'CONJUGATE', nnb, len, cone,work( ppwo ), 2*nnb, a( &
                                    jrow, j+1 ), 1,cone, work( pw ), 1 )
                          call stdlib_cgemv( 'CONJUGATE', len, nnb, cone,work( ppwo + 2*len*nnb + &
                                    nnb ), 2*nnb,a( jrow+nnb, j+1 ), 1, cone,work( pw+len ), 1 )
                          ppw = pw
                          do i = jrow, jrow+len+nnb-1
                             a( i, j+1 ) = work( ppw )
                             ppw = ppw + 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end if
                 end do
                 ! apply accumulated unitary matrices to a.
                 cola = n - jcol - nnb + 1
                 j = ihi - nblst + 1
                 call stdlib_cgemm( 'CONJUGATE', 'NO TRANSPOSE', nblst,cola, nblst, cone, work, &
                           nblst,a( j, jcol+nnb ), lda, czero, work( pw ),nblst )
                 call stdlib_clacpy( 'ALL', nblst, cola, work( pw ), nblst,a( j, jcol+nnb ), lda )
                           
                 ppwo = nblst*nblst + 1
                 j0 = j - nnb
                 do j = j0, jcol+1, -nnb
                    if ( blk22 ) then
                       ! exploit the structure of
                              ! [  u11  u12  ]
                          ! u = [            ]
                              ! [  u21  u22  ],
                       ! where all blocks are nnb-by-nnb, u21 is upper
                       ! triangular and u12 is lower triangular.
                       call stdlib_cunm22( 'LEFT', 'CONJUGATE', 2*nnb, cola, nnb,nnb, work( ppwo )&
                                 , 2*nnb,a( j, jcol+nnb ), lda, work( pw ),lwork-pw+1, ierr )
                    else
                       ! ignore the structure of u.
                       call stdlib_cgemm( 'CONJUGATE', 'NO TRANSPOSE', 2*nnb,cola, 2*nnb, cone, &
                       work( ppwo ), 2*nnb,a( j, jcol+nnb ), lda, czero, work( pw ),2*nnb )
                                 
                       call stdlib_clacpy( 'ALL', 2*nnb, cola, work( pw ), 2*nnb,a( j, jcol+nnb ),&
                                  lda )
                    end if
                    ppwo = ppwo + 4*nnb*nnb
                 end do
                 ! apply accumulated unitary matrices to q.
                 if( wantq ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, cone, q( &
                              topq, j ), ldq,work, nblst, czero, work( pw ), nh )
                    call stdlib_clacpy( 'ALL', nh, nblst, work( pw ), nh,q( topq, j ), ldq )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_cunm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,q( topq, j ), ldq, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, &
                          cone, q( topq, j ), ldq,work( ppwo ), 2*nnb, czero, work( pw ),nh )
                                    
                          call stdlib_clacpy( 'ALL', nh, 2*nnb, work( pw ), nh,q( topq, j ), ldq )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! accumulate right givens rotations if required.
                 if ( wantz .or. top>0 ) then
                    ! initialize small unitary factors that will hold the
                    ! accumulated givens rotations in workspace.
                    call stdlib_claset( 'ALL', nblst, nblst, czero, cone, work,nblst )
                    pw = nblst * nblst + 1
                    do i = 1, n2nb
                       call stdlib_claset( 'ALL', 2*nnb, 2*nnb, czero, cone,work( pw ), 2*nnb )
                                 
                       pw = pw + 4*nnb*nnb
                    end do
                    ! accumulate givens rotations into workspace array.
                    do j = jcol, jcol+nnb-1
                       ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                       len  = 2 + j - jcol
                       jrow = j + n2nb*nnb + 2
                       do i = ihi, jrow, -1
                          ctemp = a( i, j )
                          a( i, j ) = czero
                          s = b( i, j )
                          b( i, j ) = czero
                          do jj = ppw, ppw+len-1
                             temp = work( jj + nblst )
                             work( jj + nblst ) = ctemp*temp -conjg( s )*work( jj )
                             work( jj ) = s*temp + ctemp*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - nblst - 1
                       end do
                       ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                       j0 = jrow - nnb
                       do jrow = j0, j+2, -nnb
                          ppw = ppwo
                          len  = 2 + j - jcol
                          do i = jrow+nnb-1, jrow, -1
                             ctemp = a( i, j )
                             a( i, j ) = czero
                             s = b( i, j )
                             b( i, j ) = czero
                             do jj = ppw, ppw+len-1
                                temp = work( jj + 2*nnb )
                                work( jj + 2*nnb ) = ctemp*temp -conjg( s )*work( jj )
                                work( jj ) = s*temp + ctemp*work( jj )
                             end do
                             len = len + 1
                             ppw = ppw - 2*nnb - 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end do
                 else
                    call stdlib_claset( 'LOWER', ihi - jcol - 1, nnb, czero, czero,a( jcol + 2, &
                              jcol ), lda )
                    call stdlib_claset( 'LOWER', ihi - jcol - 1, nnb, czero, czero,b( jcol + 2, &
                              jcol ), ldb )
                 end if
                 ! apply accumulated unitary matrices to a and b.
                 if ( top>0 ) then
                    j = ihi - nblst + 1
                    call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, cone, a( &
                              1, j ), lda,work, nblst, czero, work( pw ), top )
                    call stdlib_clacpy( 'ALL', top, nblst, work( pw ), top,a( 1, j ), lda )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_cunm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,a( 1, j ), lda, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                          cone, a( 1, j ), lda,work( ppwo ), 2*nnb, czero,work( pw ), top )
                                    
                          call stdlib_clacpy( 'ALL', top, 2*nnb, work( pw ), top,a( 1, j ), lda )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    j = ihi - nblst + 1
                    call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, cone, b( &
                              1, j ), ldb,work, nblst, czero, work( pw ), top )
                    call stdlib_clacpy( 'ALL', top, nblst, work( pw ), top,b( 1, j ), ldb )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_cunm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,b( 1, j ), ldb, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                          cone, b( 1, j ), ldb,work( ppwo ), 2*nnb, czero,work( pw ), top )
                                    
                          call stdlib_clacpy( 'ALL', top, 2*nnb, work( pw ), top,b( 1, j ), ldb )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! apply accumulated unitary matrices to z.
                 if( wantz ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, cone, z( &
                              topq, j ), ldz,work, nblst, czero, work( pw ), nh )
                    call stdlib_clacpy( 'ALL', nh, nblst, work( pw ), nh,z( topq, j ), ldz )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                          if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_cunm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,z( topq, j ), ldz, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_cgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, &
                          cone, z( topq, j ), ldz,work( ppwo ), 2*nnb, czero, work( pw ),nh )
                                    
                          call stdlib_clacpy( 'ALL', nh, 2*nnb, work( pw ), nh,z( topq, j ), ldz )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           ! avoid re-initialization of modified q and z.
           compq2 = compq
           compz2 = compz
           if ( jcol/=ilo ) then
              if ( wantq )compq2 = 'V'
              if ( wantz )compz2 = 'V'
           end if
           if ( jcol<ihi )call stdlib_cgghrd( compq2, compz2, n, jcol, ihi, a, lda, b, ldb, q,ldq,&
                      z, ldz, ierr )
           work( 1 ) = cmplx( lwkopt,KIND=sp)
           return
     end subroutine stdlib_cgghd3

     module pure subroutine stdlib_zgghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! ZGGHD3 reduces a pair of complex matrices (A,B) to generalized upper
     !! Hessenberg form using unitary transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the unitary matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**H*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**H*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**H*x.
     !! The unitary matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
     !! Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
     !! If Q1 is the unitary matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then ZGGHD3 reduces the original
     !! problem to generalized Hessenberg form.
     !! This is a blocked variant of CGGHRD, using matrix-matrix
     !! multiplications for parts of the computation to enhance performance.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: blk22, initq, initz, lquery, wantq, wantz
           character :: compq2, compz2
           integer(ilp) :: cola, i, ierr, j, j0, jcol, jj, jrow, k, kacc22, len, lwkopt, n2nb, nb,&
                      nblst, nbmin, nh, nnb, nx, ppw, ppwo, pw, top, topq
           real(dp) :: c
           complex(dp) :: c1, c2, ctemp, s, s1, s2, temp, temp1, temp2, temp3
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           nb = stdlib_ilaenv( 1, 'ZGGHD3', ' ', n, ilo, ihi, -1 )
           lwkopt = max( 6*n*nb, 1 )
           work( 1 ) = cmplx( lwkopt,KIND=dp)
           initq = stdlib_lsame( compq, 'I' )
           wantq = initq .or. stdlib_lsame( compq, 'V' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( wantq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( wantz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           else if( lwork<1 .and. .not.lquery ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGHD3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! initialize q and z if desired.
           if( initq )call stdlib_zlaset( 'ALL', n, n, czero, cone, q, ldq )
           if( initz )call stdlib_zlaset( 'ALL', n, n, czero, cone, z, ldz )
           ! zero out lower triangle of b.
           if( n>1 )call stdlib_zlaset( 'LOWER', n-1, n-1, czero, czero, b(2, 1), ldb )
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = cone
              return
           end if
           ! determine the blocksize.
           nbmin = stdlib_ilaenv( 2, 'ZGGHD3', ' ', n, ilo, ihi, -1 )
           if( nb>1 .and. nb<nh ) then
              ! determine when to use unblocked instead of blocked code.
              nx = max( nb, stdlib_ilaenv( 3, 'ZGGHD3', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code.
                 if( lwork<lwkopt ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code.
                    nbmin = max( 2, stdlib_ilaenv( 2, 'ZGGHD3', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=6*n*nbmin ) then
                       nb = lwork / ( 6*n )
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              jcol = ilo
           else
              ! use blocked code
              kacc22 = stdlib_ilaenv( 16, 'ZGGHD3', ' ', n, ilo, ihi, -1 )
              blk22 = kacc22==2
              do jcol = ilo, ihi-2, nb
                 nnb = min( nb, ihi-jcol-1 )
                 ! initialize small unitary factors that will hold the
                 ! accumulated givens rotations in workspace.
                 ! n2nb   denotes the number of 2*nnb-by-2*nnb factors
                 ! nblst  denotes the (possibly smaller) order of the last
                        ! factor.
                 n2nb = ( ihi-jcol-1 ) / nnb - 1
                 nblst = ihi - jcol - n2nb*nnb
                 call stdlib_zlaset( 'ALL', nblst, nblst, czero, cone, work, nblst )
                 pw = nblst * nblst + 1
                 do i = 1, n2nb
                    call stdlib_zlaset( 'ALL', 2*nnb, 2*nnb, czero, cone,work( pw ), 2*nnb )
                              
                    pw = pw + 4*nnb*nnb
                 end do
                 ! reduce columns jcol:jcol+nnb-1 of a to hessenberg form.
                 do j = jcol, jcol+nnb-1
                    ! reduce jth column of a. store cosines and sines in jth
                    ! column of a and b, respectively.
                    do i = ihi, j+2, -1
                       temp = a( i-1, j )
                       call stdlib_zlartg( temp, a( i, j ), c, s, a( i-1, j ) )
                       a( i, j ) = cmplx( c,KIND=dp)
                       b( i, j ) = s
                    end do
                    ! accumulate givens rotations into workspace array.
                    ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                    len  = 2 + j - jcol
                    jrow = j + n2nb*nnb + 2
                    do i = ihi, jrow, -1
                       ctemp = a( i, j )
                       s = b( i, j )
                       do jj = ppw, ppw+len-1
                          temp = work( jj + nblst )
                          work( jj + nblst ) = ctemp*temp - s*work( jj )
                          work( jj ) = conjg( s )*temp + ctemp*work( jj )
                       end do
                       len = len + 1
                       ppw = ppw - nblst - 1
                    end do
                    ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                    j0 = jrow - nnb
                    do jrow = j0, j+2, -nnb
                       ppw = ppwo
                       len  = 2 + j - jcol
                       do i = jrow+nnb-1, jrow, -1
                          ctemp = a( i, j )
                          s = b( i, j )
                          do jj = ppw, ppw+len-1
                             temp = work( jj + 2*nnb )
                             work( jj + 2*nnb ) = ctemp*temp - s*work( jj )
                             work( jj ) = conjg( s )*temp + ctemp*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - 2*nnb - 1
                       end do
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    ! top denotes the number of top rows in a and b that will
                    ! not be updated during the next steps.
                    if( jcol<=2 ) then
                       top = 0
                    else
                       top = jcol
                    end if
                    ! propagate transformations through b and replace stored
                    ! left sines/cosines by right sines/cosines.
                    do jj = n, j+1, -1
                       ! update jjth column of b.
                       do i = min( jj+1, ihi ), j+2, -1
                          ctemp = a( i, j )
                          s = b( i, j )
                          temp = b( i, jj )
                          b( i, jj ) = ctemp*temp - conjg( s )*b( i-1, jj )
                          b( i-1, jj ) = s*temp + ctemp*b( i-1, jj )
                       end do
                       ! annihilate b( jj+1, jj ).
                       if( jj<ihi ) then
                          temp = b( jj+1, jj+1 )
                          call stdlib_zlartg( temp, b( jj+1, jj ), c, s,b( jj+1, jj+1 ) )
                          b( jj+1, jj ) = czero
                          call stdlib_zrot( jj-top, b( top+1, jj+1 ), 1,b( top+1, jj ), 1, c, s )
                                    
                          a( jj+1, j ) = cmplx( c,KIND=dp)
                          b( jj+1, j ) = -conjg( s )
                       end if
                    end do
                    ! update a by transformations from right.
                    jj = mod( ihi-j-1, 3 )
                    do i = ihi-j-3, jj+1, -3
                       ctemp = a( j+1+i, j )
                       s = -b( j+1+i, j )
                       c1 = a( j+2+i, j )
                       s1 = -b( j+2+i, j )
                       c2 = a( j+3+i, j )
                       s2 = -b( j+3+i, j )
                       do k = top+1, ihi
                          temp = a( k, j+i  )
                          temp1 = a( k, j+i+1 )
                          temp2 = a( k, j+i+2 )
                          temp3 = a( k, j+i+3 )
                          a( k, j+i+3 ) = c2*temp3 + conjg( s2 )*temp2
                          temp2 = -s2*temp3 + c2*temp2
                          a( k, j+i+2 ) = c1*temp2 + conjg( s1 )*temp1
                          temp1 = -s1*temp2 + c1*temp1
                          a( k, j+i+1 ) = ctemp*temp1 + conjg( s )*temp
                          a( k, j+i ) = -s*temp1 + ctemp*temp
                       end do
                    end do
                    if( jj>0 ) then
                       do i = jj, 1, -1
                          c = real( a( j+1+i, j ),KIND=dp)
                          call stdlib_zrot( ihi-top, a( top+1, j+i+1 ), 1,a( top+1, j+i ), 1, c,-&
                                    conjg( b( j+1+i, j ) ) )
                       end do
                    end if
                    ! update (j+1)th column of a by transformations from left.
                    if ( j < jcol + nnb - 1 ) then
                       len  = 1 + j - jcol
                       ! multiply with the trailing accumulated unitary
                       ! matrix, which takes the form
                              ! [  u11  u12  ]
                          ! u = [            ],
                              ! [  u21  u22  ]
                       ! where u21 is a len-by-len matrix and u12 is lower
                       ! triangular.
                       jrow = ihi - nblst + 1
                       call stdlib_zgemv( 'CONJUGATE', nblst, len, cone, work,nblst, a( jrow, j+1 &
                                 ), 1, czero,work( pw ), 1 )
                       ppw = pw + len
                       do i = jrow, jrow+nblst-len-1
                          work( ppw ) = a( i, j+1 )
                          ppw = ppw + 1
                       end do
                       call stdlib_ztrmv( 'LOWER', 'CONJUGATE', 'NON-UNIT',nblst-len, work( &
                                 len*nblst + 1 ), nblst,work( pw+len ), 1 )
                       call stdlib_zgemv( 'CONJUGATE', len, nblst-len, cone,work( (len+1)*nblst - &
                       len + 1 ), nblst,a( jrow+nblst-len, j+1 ), 1, cone,work( pw+len ), 1 )
                                 
                       ppw = pw
                       do i = jrow, jrow+nblst-1
                          a( i, j+1 ) = work( ppw )
                          ppw = ppw + 1
                       end do
                       ! multiply with the other accumulated unitary
                       ! matrices, which take the form
                              ! [  u11  u12   0  ]
                              ! [                ]
                          ! u = [  u21  u22   0  ],
                              ! [                ]
                              ! [   0    0    i  ]
                       ! where i denotes the (nnb-len)-by-(nnb-len) identity
                       ! matrix, u21 is a len-by-len upper triangular matrix
                       ! and u12 is an nnb-by-nnb lower triangular matrix.
                       ppwo = 1 + nblst*nblst
                       j0 = jrow - nnb
                       do jrow = j0, jcol+1, -nnb
                          ppw = pw + len
                          do i = jrow, jrow+nnb-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          ppw = pw
                          do i = jrow+nnb, jrow+nnb+len-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          call stdlib_ztrmv( 'UPPER', 'CONJUGATE', 'NON-UNIT', len,work( ppwo + &
                                    nnb ), 2*nnb, work( pw ),1 )
                          call stdlib_ztrmv( 'LOWER', 'CONJUGATE', 'NON-UNIT', nnb,work( ppwo + &
                                    2*len*nnb ),2*nnb, work( pw + len ), 1 )
                          call stdlib_zgemv( 'CONJUGATE', nnb, len, cone,work( ppwo ), 2*nnb, a( &
                                    jrow, j+1 ), 1,cone, work( pw ), 1 )
                          call stdlib_zgemv( 'CONJUGATE', len, nnb, cone,work( ppwo + 2*len*nnb + &
                                    nnb ), 2*nnb,a( jrow+nnb, j+1 ), 1, cone,work( pw+len ), 1 )
                          ppw = pw
                          do i = jrow, jrow+len+nnb-1
                             a( i, j+1 ) = work( ppw )
                             ppw = ppw + 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end if
                 end do
                 ! apply accumulated unitary matrices to a.
                 cola = n - jcol - nnb + 1
                 j = ihi - nblst + 1
                 call stdlib_zgemm( 'CONJUGATE', 'NO TRANSPOSE', nblst,cola, nblst, cone, work, &
                           nblst,a( j, jcol+nnb ), lda, czero, work( pw ),nblst )
                 call stdlib_zlacpy( 'ALL', nblst, cola, work( pw ), nblst,a( j, jcol+nnb ), lda )
                           
                 ppwo = nblst*nblst + 1
                 j0 = j - nnb
                 do j = j0, jcol+1, -nnb
                    if ( blk22 ) then
                       ! exploit the structure of
                              ! [  u11  u12  ]
                          ! u = [            ]
                              ! [  u21  u22  ],
                       ! where all blocks are nnb-by-nnb, u21 is upper
                       ! triangular and u12 is lower triangular.
                       call stdlib_zunm22( 'LEFT', 'CONJUGATE', 2*nnb, cola, nnb,nnb, work( ppwo )&
                                 , 2*nnb,a( j, jcol+nnb ), lda, work( pw ),lwork-pw+1, ierr )
                    else
                       ! ignore the structure of u.
                       call stdlib_zgemm( 'CONJUGATE', 'NO TRANSPOSE', 2*nnb,cola, 2*nnb, cone, &
                       work( ppwo ), 2*nnb,a( j, jcol+nnb ), lda, czero, work( pw ),2*nnb )
                                 
                       call stdlib_zlacpy( 'ALL', 2*nnb, cola, work( pw ), 2*nnb,a( j, jcol+nnb ),&
                                  lda )
                    end if
                    ppwo = ppwo + 4*nnb*nnb
                 end do
                 ! apply accumulated unitary matrices to q.
                 if( wantq ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_zgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, cone, q( &
                              topq, j ), ldq,work, nblst, czero, work( pw ), nh )
                    call stdlib_zlacpy( 'ALL', nh, nblst, work( pw ), nh,q( topq, j ), ldq )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_zunm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,q( topq, j ), ldq, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_zgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, &
                          cone, q( topq, j ), ldq,work( ppwo ), 2*nnb, czero, work( pw ),nh )
                                    
                          call stdlib_zlacpy( 'ALL', nh, 2*nnb, work( pw ), nh,q( topq, j ), ldq )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! accumulate right givens rotations if required.
                 if ( wantz .or. top>0 ) then
                    ! initialize small unitary factors that will hold the
                    ! accumulated givens rotations in workspace.
                    call stdlib_zlaset( 'ALL', nblst, nblst, czero, cone, work,nblst )
                    pw = nblst * nblst + 1
                    do i = 1, n2nb
                       call stdlib_zlaset( 'ALL', 2*nnb, 2*nnb, czero, cone,work( pw ), 2*nnb )
                                 
                       pw = pw + 4*nnb*nnb
                    end do
                    ! accumulate givens rotations into workspace array.
                    do j = jcol, jcol+nnb-1
                       ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                       len  = 2 + j - jcol
                       jrow = j + n2nb*nnb + 2
                       do i = ihi, jrow, -1
                          ctemp = a( i, j )
                          a( i, j ) = czero
                          s = b( i, j )
                          b( i, j ) = czero
                          do jj = ppw, ppw+len-1
                             temp = work( jj + nblst )
                             work( jj + nblst ) = ctemp*temp -conjg( s )*work( jj )
                             work( jj ) = s*temp + ctemp*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - nblst - 1
                       end do
                       ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                       j0 = jrow - nnb
                       do jrow = j0, j+2, -nnb
                          ppw = ppwo
                          len  = 2 + j - jcol
                          do i = jrow+nnb-1, jrow, -1
                             ctemp = a( i, j )
                             a( i, j ) = czero
                             s = b( i, j )
                             b( i, j ) = czero
                             do jj = ppw, ppw+len-1
                                temp = work( jj + 2*nnb )
                                work( jj + 2*nnb ) = ctemp*temp -conjg( s )*work( jj )
                                work( jj ) = s*temp + ctemp*work( jj )
                             end do
                             len = len + 1
                             ppw = ppw - 2*nnb - 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end do
                 else
                    call stdlib_zlaset( 'LOWER', ihi - jcol - 1, nnb, czero, czero,a( jcol + 2, &
                              jcol ), lda )
                    call stdlib_zlaset( 'LOWER', ihi - jcol - 1, nnb, czero, czero,b( jcol + 2, &
                              jcol ), ldb )
                 end if
                 ! apply accumulated unitary matrices to a and b.
                 if ( top>0 ) then
                    j = ihi - nblst + 1
                    call stdlib_zgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, cone, a( &
                              1, j ), lda,work, nblst, czero, work( pw ), top )
                    call stdlib_zlacpy( 'ALL', top, nblst, work( pw ), top,a( 1, j ), lda )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_zunm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,a( 1, j ), lda, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_zgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                          cone, a( 1, j ), lda,work( ppwo ), 2*nnb, czero,work( pw ), top )
                                    
                          call stdlib_zlacpy( 'ALL', top, 2*nnb, work( pw ), top,a( 1, j ), lda )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    j = ihi - nblst + 1
                    call stdlib_zgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, cone, b( &
                              1, j ), ldb,work, nblst, czero, work( pw ), top )
                    call stdlib_zlacpy( 'ALL', top, nblst, work( pw ), top,b( 1, j ), ldb )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_zunm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,b( 1, j ), ldb, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_zgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                          cone, b( 1, j ), ldb,work( ppwo ), 2*nnb, czero,work( pw ), top )
                                    
                          call stdlib_zlacpy( 'ALL', top, 2*nnb, work( pw ), top,b( 1, j ), ldb )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! apply accumulated unitary matrices to z.
                 if( wantz ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_zgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, cone, z( &
                              topq, j ), ldz,work, nblst, czero, work( pw ), nh )
                    call stdlib_zlacpy( 'ALL', nh, nblst, work( pw ), nh,z( topq, j ), ldz )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                          if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_zunm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,z( topq, j ), ldz, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_zgemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, &
                          cone, z( topq, j ), ldz,work( ppwo ), 2*nnb, czero, work( pw ),nh )
                                    
                          call stdlib_zlacpy( 'ALL', nh, 2*nnb, work( pw ), nh,z( topq, j ), ldz )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           ! avoid re-initialization of modified q and z.
           compq2 = compq
           compz2 = compz
           if ( jcol/=ilo ) then
              if ( wantq )compq2 = 'V'
              if ( wantz )compz2 = 'V'
           end if
           if ( jcol<ihi )call stdlib_zgghrd( compq2, compz2, n, jcol, ihi, a, lda, b, ldb, q,ldq,&
                      z, ldz, ierr )
           work( 1 ) = cmplx( lwkopt,KIND=dp)
           return
     end subroutine stdlib_zgghd3

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$gghd3( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! ZGGHD3: reduces a pair of complex matrices (A,B) to generalized upper
     !! Hessenberg form using unitary transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the unitary matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**H*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**H*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**H*x.
     !! The unitary matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
     !! Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
     !! If Q1 is the unitary matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then ZGGHD3 reduces the original
     !! problem to generalized Hessenberg form.
     !! This is a blocked variant of CGGHRD, using matrix-matrix
     !! multiplications for parts of the computation to enhance performance.
               work, lwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n, lwork
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: blk22, initq, initz, lquery, wantq, wantz
           character :: compq2, compz2
           integer(ilp) :: cola, i, ierr, j, j0, jcol, jj, jrow, k, kacc22, len, lwkopt, n2nb, nb,&
                      nblst, nbmin, nh, nnb, nx, ppw, ppwo, pw, top, topq
           real(${ck}$) :: c
           complex(${ck}$) :: c1, c2, ctemp, s, s1, s2, temp, temp1, temp2, temp3
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters.
           info = 0
           nb = stdlib_ilaenv( 1, 'ZGGHD3', ' ', n, ilo, ihi, -1 )
           lwkopt = max( 6*n*nb, 1 )
           work( 1 ) = cmplx( lwkopt,KIND=${ck}$)
           initq = stdlib_lsame( compq, 'I' )
           wantq = initq .or. stdlib_lsame( compq, 'V' )
           initz = stdlib_lsame( compz, 'I' )
           wantz = initz .or. stdlib_lsame( compz, 'V' )
           lquery = ( lwork==-1 )
           if( .not.stdlib_lsame( compq, 'N' ) .and. .not.wantq ) then
              info = -1
           else if( .not.stdlib_lsame( compz, 'N' ) .and. .not.wantz ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( wantq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( wantz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           else if( lwork<1 .and. .not.lquery ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGHD3', -info )
              return
           else if( lquery ) then
              return
           end if
           ! initialize q and z if desired.
           if( initq )call stdlib_${ci}$laset( 'ALL', n, n, czero, cone, q, ldq )
           if( initz )call stdlib_${ci}$laset( 'ALL', n, n, czero, cone, z, ldz )
           ! zero out lower triangle of b.
           if( n>1 )call stdlib_${ci}$laset( 'LOWER', n-1, n-1, czero, czero, b(2, 1), ldb )
           ! quick return if possible
           nh = ihi - ilo + 1
           if( nh<=1 ) then
              work( 1 ) = cone
              return
           end if
           ! determine the blocksize.
           nbmin = stdlib_ilaenv( 2, 'ZGGHD3', ' ', n, ilo, ihi, -1 )
           if( nb>1 .and. nb<nh ) then
              ! determine when to use unblocked instead of blocked code.
              nx = max( nb, stdlib_ilaenv( 3, 'ZGGHD3', ' ', n, ilo, ihi, -1 ) )
              if( nx<nh ) then
                 ! determine if workspace is large enough for blocked code.
                 if( lwork<lwkopt ) then
                    ! not enough workspace to use optimal nb:  determine the
                    ! minimum value of nb, and reduce nb or force use of
                    ! unblocked code.
                    nbmin = max( 2, stdlib_ilaenv( 2, 'ZGGHD3', ' ', n, ilo, ihi,-1 ) )
                    if( lwork>=6*n*nbmin ) then
                       nb = lwork / ( 6*n )
                    else
                       nb = 1
                    end if
                 end if
              end if
           end if
           if( nb<nbmin .or. nb>=nh ) then
              ! use unblocked code below
              jcol = ilo
           else
              ! use blocked code
              kacc22 = stdlib_ilaenv( 16, 'ZGGHD3', ' ', n, ilo, ihi, -1 )
              blk22 = kacc22==2
              do jcol = ilo, ihi-2, nb
                 nnb = min( nb, ihi-jcol-1 )
                 ! initialize small unitary factors that will hold the
                 ! accumulated givens rotations in workspace.
                 ! n2nb   denotes the number of 2*nnb-by-2*nnb factors
                 ! nblst  denotes the (possibly smaller) order of the last
                        ! factor.
                 n2nb = ( ihi-jcol-1 ) / nnb - 1
                 nblst = ihi - jcol - n2nb*nnb
                 call stdlib_${ci}$laset( 'ALL', nblst, nblst, czero, cone, work, nblst )
                 pw = nblst * nblst + 1
                 do i = 1, n2nb
                    call stdlib_${ci}$laset( 'ALL', 2*nnb, 2*nnb, czero, cone,work( pw ), 2*nnb )
                              
                    pw = pw + 4*nnb*nnb
                 end do
                 ! reduce columns jcol:jcol+nnb-1 of a to hessenberg form.
                 do j = jcol, jcol+nnb-1
                    ! reduce jth column of a. store cosines and sines in jth
                    ! column of a and b, respectively.
                    do i = ihi, j+2, -1
                       temp = a( i-1, j )
                       call stdlib_${ci}$lartg( temp, a( i, j ), c, s, a( i-1, j ) )
                       a( i, j ) = cmplx( c,KIND=${ck}$)
                       b( i, j ) = s
                    end do
                    ! accumulate givens rotations into workspace array.
                    ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                    len  = 2 + j - jcol
                    jrow = j + n2nb*nnb + 2
                    do i = ihi, jrow, -1
                       ctemp = a( i, j )
                       s = b( i, j )
                       do jj = ppw, ppw+len-1
                          temp = work( jj + nblst )
                          work( jj + nblst ) = ctemp*temp - s*work( jj )
                          work( jj ) = conjg( s )*temp + ctemp*work( jj )
                       end do
                       len = len + 1
                       ppw = ppw - nblst - 1
                    end do
                    ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                    j0 = jrow - nnb
                    do jrow = j0, j+2, -nnb
                       ppw = ppwo
                       len  = 2 + j - jcol
                       do i = jrow+nnb-1, jrow, -1
                          ctemp = a( i, j )
                          s = b( i, j )
                          do jj = ppw, ppw+len-1
                             temp = work( jj + 2*nnb )
                             work( jj + 2*nnb ) = ctemp*temp - s*work( jj )
                             work( jj ) = conjg( s )*temp + ctemp*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - 2*nnb - 1
                       end do
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    ! top denotes the number of top rows in a and b that will
                    ! not be updated during the next steps.
                    if( jcol<=2 ) then
                       top = 0
                    else
                       top = jcol
                    end if
                    ! propagate transformations through b and replace stored
                    ! left sines/cosines by right sines/cosines.
                    do jj = n, j+1, -1
                       ! update jjth column of b.
                       do i = min( jj+1, ihi ), j+2, -1
                          ctemp = a( i, j )
                          s = b( i, j )
                          temp = b( i, jj )
                          b( i, jj ) = ctemp*temp - conjg( s )*b( i-1, jj )
                          b( i-1, jj ) = s*temp + ctemp*b( i-1, jj )
                       end do
                       ! annihilate b( jj+1, jj ).
                       if( jj<ihi ) then
                          temp = b( jj+1, jj+1 )
                          call stdlib_${ci}$lartg( temp, b( jj+1, jj ), c, s,b( jj+1, jj+1 ) )
                          b( jj+1, jj ) = czero
                          call stdlib_${ci}$rot( jj-top, b( top+1, jj+1 ), 1,b( top+1, jj ), 1, c, s )
                                    
                          a( jj+1, j ) = cmplx( c,KIND=${ck}$)
                          b( jj+1, j ) = -conjg( s )
                       end if
                    end do
                    ! update a by transformations from right.
                    jj = mod( ihi-j-1, 3 )
                    do i = ihi-j-3, jj+1, -3
                       ctemp = a( j+1+i, j )
                       s = -b( j+1+i, j )
                       c1 = a( j+2+i, j )
                       s1 = -b( j+2+i, j )
                       c2 = a( j+3+i, j )
                       s2 = -b( j+3+i, j )
                       do k = top+1, ihi
                          temp = a( k, j+i  )
                          temp1 = a( k, j+i+1 )
                          temp2 = a( k, j+i+2 )
                          temp3 = a( k, j+i+3 )
                          a( k, j+i+3 ) = c2*temp3 + conjg( s2 )*temp2
                          temp2 = -s2*temp3 + c2*temp2
                          a( k, j+i+2 ) = c1*temp2 + conjg( s1 )*temp1
                          temp1 = -s1*temp2 + c1*temp1
                          a( k, j+i+1 ) = ctemp*temp1 + conjg( s )*temp
                          a( k, j+i ) = -s*temp1 + ctemp*temp
                       end do
                    end do
                    if( jj>0 ) then
                       do i = jj, 1, -1
                          c = real( a( j+1+i, j ),KIND=${ck}$)
                          call stdlib_${ci}$rot( ihi-top, a( top+1, j+i+1 ), 1,a( top+1, j+i ), 1, c,-&
                                    conjg( b( j+1+i, j ) ) )
                       end do
                    end if
                    ! update (j+1)th column of a by transformations from left.
                    if ( j < jcol + nnb - 1 ) then
                       len  = 1 + j - jcol
                       ! multiply with the trailing accumulated unitary
                       ! matrix, which takes the form
                              ! [  u11  u12  ]
                          ! u = [            ],
                              ! [  u21  u22  ]
                       ! where u21 is a len-by-len matrix and u12 is lower
                       ! triangular.
                       jrow = ihi - nblst + 1
                       call stdlib_${ci}$gemv( 'CONJUGATE', nblst, len, cone, work,nblst, a( jrow, j+1 &
                                 ), 1, czero,work( pw ), 1 )
                       ppw = pw + len
                       do i = jrow, jrow+nblst-len-1
                          work( ppw ) = a( i, j+1 )
                          ppw = ppw + 1
                       end do
                       call stdlib_${ci}$trmv( 'LOWER', 'CONJUGATE', 'NON-UNIT',nblst-len, work( &
                                 len*nblst + 1 ), nblst,work( pw+len ), 1 )
                       call stdlib_${ci}$gemv( 'CONJUGATE', len, nblst-len, cone,work( (len+1)*nblst - &
                       len + 1 ), nblst,a( jrow+nblst-len, j+1 ), 1, cone,work( pw+len ), 1 )
                                 
                       ppw = pw
                       do i = jrow, jrow+nblst-1
                          a( i, j+1 ) = work( ppw )
                          ppw = ppw + 1
                       end do
                       ! multiply with the other accumulated unitary
                       ! matrices, which take the form
                              ! [  u11  u12   0  ]
                              ! [                ]
                          ! u = [  u21  u22   0  ],
                              ! [                ]
                              ! [   0    0    i  ]
                       ! where i denotes the (nnb-len)-by-(nnb-len) identity
                       ! matrix, u21 is a len-by-len upper triangular matrix
                       ! and u12 is an nnb-by-nnb lower triangular matrix.
                       ppwo = 1 + nblst*nblst
                       j0 = jrow - nnb
                       do jrow = j0, jcol+1, -nnb
                          ppw = pw + len
                          do i = jrow, jrow+nnb-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          ppw = pw
                          do i = jrow+nnb, jrow+nnb+len-1
                             work( ppw ) = a( i, j+1 )
                             ppw = ppw + 1
                          end do
                          call stdlib_${ci}$trmv( 'UPPER', 'CONJUGATE', 'NON-UNIT', len,work( ppwo + &
                                    nnb ), 2*nnb, work( pw ),1 )
                          call stdlib_${ci}$trmv( 'LOWER', 'CONJUGATE', 'NON-UNIT', nnb,work( ppwo + &
                                    2*len*nnb ),2*nnb, work( pw + len ), 1 )
                          call stdlib_${ci}$gemv( 'CONJUGATE', nnb, len, cone,work( ppwo ), 2*nnb, a( &
                                    jrow, j+1 ), 1,cone, work( pw ), 1 )
                          call stdlib_${ci}$gemv( 'CONJUGATE', len, nnb, cone,work( ppwo + 2*len*nnb + &
                                    nnb ), 2*nnb,a( jrow+nnb, j+1 ), 1, cone,work( pw+len ), 1 )
                          ppw = pw
                          do i = jrow, jrow+len+nnb-1
                             a( i, j+1 ) = work( ppw )
                             ppw = ppw + 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end if
                 end do
                 ! apply accumulated unitary matrices to a.
                 cola = n - jcol - nnb + 1
                 j = ihi - nblst + 1
                 call stdlib_${ci}$gemm( 'CONJUGATE', 'NO TRANSPOSE', nblst,cola, nblst, cone, work, &
                           nblst,a( j, jcol+nnb ), lda, czero, work( pw ),nblst )
                 call stdlib_${ci}$lacpy( 'ALL', nblst, cola, work( pw ), nblst,a( j, jcol+nnb ), lda )
                           
                 ppwo = nblst*nblst + 1
                 j0 = j - nnb
                 do j = j0, jcol+1, -nnb
                    if ( blk22 ) then
                       ! exploit the structure of
                              ! [  u11  u12  ]
                          ! u = [            ]
                              ! [  u21  u22  ],
                       ! where all blocks are nnb-by-nnb, u21 is upper
                       ! triangular and u12 is lower triangular.
                       call stdlib_${ci}$unm22( 'LEFT', 'CONJUGATE', 2*nnb, cola, nnb,nnb, work( ppwo )&
                                 , 2*nnb,a( j, jcol+nnb ), lda, work( pw ),lwork-pw+1, ierr )
                    else
                       ! ignore the structure of u.
                       call stdlib_${ci}$gemm( 'CONJUGATE', 'NO TRANSPOSE', 2*nnb,cola, 2*nnb, cone, &
                       work( ppwo ), 2*nnb,a( j, jcol+nnb ), lda, czero, work( pw ),2*nnb )
                                 
                       call stdlib_${ci}$lacpy( 'ALL', 2*nnb, cola, work( pw ), 2*nnb,a( j, jcol+nnb ),&
                                  lda )
                    end if
                    ppwo = ppwo + 4*nnb*nnb
                 end do
                 ! apply accumulated unitary matrices to q.
                 if( wantq ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, cone, q( &
                              topq, j ), ldq,work, nblst, czero, work( pw ), nh )
                    call stdlib_${ci}$lacpy( 'ALL', nh, nblst, work( pw ), nh,q( topq, j ), ldq )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ci}$unm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,q( topq, j ), ldq, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, &
                          cone, q( topq, j ), ldq,work( ppwo ), 2*nnb, czero, work( pw ),nh )
                                    
                          call stdlib_${ci}$lacpy( 'ALL', nh, 2*nnb, work( pw ), nh,q( topq, j ), ldq )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! accumulate right givens rotations if required.
                 if ( wantz .or. top>0 ) then
                    ! initialize small unitary factors that will hold the
                    ! accumulated givens rotations in workspace.
                    call stdlib_${ci}$laset( 'ALL', nblst, nblst, czero, cone, work,nblst )
                    pw = nblst * nblst + 1
                    do i = 1, n2nb
                       call stdlib_${ci}$laset( 'ALL', 2*nnb, 2*nnb, czero, cone,work( pw ), 2*nnb )
                                 
                       pw = pw + 4*nnb*nnb
                    end do
                    ! accumulate givens rotations into workspace array.
                    do j = jcol, jcol+nnb-1
                       ppw  = ( nblst + 1 )*( nblst - 2 ) - j + jcol + 1
                       len  = 2 + j - jcol
                       jrow = j + n2nb*nnb + 2
                       do i = ihi, jrow, -1
                          ctemp = a( i, j )
                          a( i, j ) = czero
                          s = b( i, j )
                          b( i, j ) = czero
                          do jj = ppw, ppw+len-1
                             temp = work( jj + nblst )
                             work( jj + nblst ) = ctemp*temp -conjg( s )*work( jj )
                             work( jj ) = s*temp + ctemp*work( jj )
                          end do
                          len = len + 1
                          ppw = ppw - nblst - 1
                       end do
                       ppwo = nblst*nblst + ( nnb+j-jcol-1 )*2*nnb + nnb
                       j0 = jrow - nnb
                       do jrow = j0, j+2, -nnb
                          ppw = ppwo
                          len  = 2 + j - jcol
                          do i = jrow+nnb-1, jrow, -1
                             ctemp = a( i, j )
                             a( i, j ) = czero
                             s = b( i, j )
                             b( i, j ) = czero
                             do jj = ppw, ppw+len-1
                                temp = work( jj + 2*nnb )
                                work( jj + 2*nnb ) = ctemp*temp -conjg( s )*work( jj )
                                work( jj ) = s*temp + ctemp*work( jj )
                             end do
                             len = len + 1
                             ppw = ppw - 2*nnb - 1
                          end do
                          ppwo = ppwo + 4*nnb*nnb
                       end do
                    end do
                 else
                    call stdlib_${ci}$laset( 'LOWER', ihi - jcol - 1, nnb, czero, czero,a( jcol + 2, &
                              jcol ), lda )
                    call stdlib_${ci}$laset( 'LOWER', ihi - jcol - 1, nnb, czero, czero,b( jcol + 2, &
                              jcol ), ldb )
                 end if
                 ! apply accumulated unitary matrices to a and b.
                 if ( top>0 ) then
                    j = ihi - nblst + 1
                    call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, cone, a( &
                              1, j ), lda,work, nblst, czero, work( pw ), top )
                    call stdlib_${ci}$lacpy( 'ALL', top, nblst, work( pw ), top,a( 1, j ), lda )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ci}$unm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,a( 1, j ), lda, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                          cone, a( 1, j ), lda,work( ppwo ), 2*nnb, czero,work( pw ), top )
                                    
                          call stdlib_${ci}$lacpy( 'ALL', top, 2*nnb, work( pw ), top,a( 1, j ), lda )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                    j = ihi - nblst + 1
                    call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,nblst, nblst, cone, b( &
                              1, j ), ldb,work, nblst, czero, work( pw ), top )
                    call stdlib_${ci}$lacpy( 'ALL', top, nblst, work( pw ), top,b( 1, j ), ldb )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ci}$unm22( 'RIGHT', 'NO TRANSPOSE', top, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,b( 1, j ), ldb, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', top,2*nnb, 2*nnb, &
                          cone, b( 1, j ), ldb,work( ppwo ), 2*nnb, czero,work( pw ), top )
                                    
                          call stdlib_${ci}$lacpy( 'ALL', top, 2*nnb, work( pw ), top,b( 1, j ), ldb )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
                 ! apply accumulated unitary matrices to z.
                 if( wantz ) then
                    j = ihi - nblst + 1
                    if ( initq ) then
                       topq = max( 2, j - jcol + 1 )
                       nh  = ihi - topq + 1
                    else
                       topq = 1
                       nh = n
                    end if
                    call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,nblst, nblst, cone, z( &
                              topq, j ), ldz,work, nblst, czero, work( pw ), nh )
                    call stdlib_${ci}$lacpy( 'ALL', nh, nblst, work( pw ), nh,z( topq, j ), ldz )
                              
                    ppwo = nblst*nblst + 1
                    j0 = j - nnb
                    do j = j0, jcol+1, -nnb
                          if ( initq ) then
                          topq = max( 2, j - jcol + 1 )
                          nh  = ihi - topq + 1
                       end if
                       if ( blk22 ) then
                          ! exploit the structure of u.
                          call stdlib_${ci}$unm22( 'RIGHT', 'NO TRANSPOSE', nh, 2*nnb,nnb, nnb, work( &
                                    ppwo ), 2*nnb,z( topq, j ), ldz, work( pw ),lwork-pw+1, ierr )
                       else
                          ! ignore the structure of u.
                          call stdlib_${ci}$gemm( 'NO TRANSPOSE', 'NO TRANSPOSE', nh,2*nnb, 2*nnb, &
                          cone, z( topq, j ), ldz,work( ppwo ), 2*nnb, czero, work( pw ),nh )
                                    
                          call stdlib_${ci}$lacpy( 'ALL', nh, 2*nnb, work( pw ), nh,z( topq, j ), ldz )
                                    
                       end if
                       ppwo = ppwo + 4*nnb*nnb
                    end do
                 end if
              end do
           end if
           ! use unblocked code to reduce the rest of the matrix
           ! avoid re-initialization of modified q and z.
           compq2 = compq
           compz2 = compz
           if ( jcol/=ilo ) then
              if ( wantq )compq2 = 'V'
              if ( wantz )compz2 = 'V'
           end if
           if ( jcol<ihi )call stdlib_${ci}$gghrd( compq2, compz2, n, jcol, ihi, a, lda, b, ldb, q,ldq,&
                      z, ldz, ierr )
           work( 1 ) = cmplx( lwkopt,KIND=${ck}$)
           return
     end subroutine stdlib_${ci}$gghd3

#:endif
#:endfor



     module pure subroutine stdlib_stgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, n1, n2, &
     !! STGEX2 swaps adjacent diagonal blocks (A11, B11) and (A22, B22)
     !! of size 1-by-1 or 2-by-2 in an upper (quasi) triangular matrix pair
     !! (A, B) by an orthogonal equivalence transformation.
     !! (A, B) must be in generalized real Schur canonical form (as returned
     !! by SGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
     !! diagonal blocks. B is upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
     !! Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T
               work, lwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: j1, lda, ldb, ldq, ldz, lwork, n, n1, n2
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_scopy by calls to stdlib_slaset, or by do
        ! loops. sven hammarling, 1/5/02.
           ! Parameters 
           real(sp), parameter :: twenty = 2.0e+01_sp
           integer(ilp), parameter :: ldst = 4
           logical(lk), parameter :: wands = .true.
           
           
           
           
           ! Local Scalars 
           logical(lk) :: strong, weak
           integer(ilp) :: i, idum, linfo, m
           real(sp) :: bqra21, brqa21, ddum, dnorma, dnormb, dscale, dsum, eps, f, g, sa, sb, &
                     scale, smlnum, thresha, threshb
           ! Local Arrays 
           integer(ilp) :: iwork(ldst)
           real(sp) :: ai(2), ar(2), be(2), ir(ldst,ldst), ircop(ldst,ldst), li(ldst,ldst), licop(&
           ldst,ldst), s(ldst,ldst), scpy(ldst,ldst), t(ldst,ldst), taul(ldst), taur(ldst), tcpy(&
                     ldst,ldst)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=1 .or. n1<=0 .or. n2<=0 )return
           if( n1>n .or. ( j1+n1 )>n )return
           m = n1 + n2
           if( lwork<max( n*m, m*m*2 ) ) then
              info = -16
              work( 1 ) = max( n*m, m*m*2 )
              return
           end if
           weak = .false.
           strong = .false.
           ! make a local copy of selected block
           call stdlib_slaset( 'FULL', ldst, ldst, zero, zero, li, ldst )
           call stdlib_slaset( 'FULL', ldst, ldst, zero, zero, ir, ldst )
           call stdlib_slacpy( 'FULL', m, m, a( j1, j1 ), lda, s, ldst )
           call stdlib_slacpy( 'FULL', m, m, b( j1, j1 ), ldb, t, ldst )
           ! compute threshold for testing acceptance of swapping.
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           dscale = zero
           dsum = one
           call stdlib_slacpy( 'FULL', m, m, s, ldst, work, m )
           call stdlib_slassq( m*m, work, 1, dscale, dsum )
           dnorma = dscale*sqrt( dsum )
           dscale = zero
           dsum = one
           call stdlib_slacpy( 'FULL', m, m, t, ldst, work, m )
           call stdlib_slassq( m*m, work, 1, dscale, dsum )
           dnormb = dscale*sqrt( dsum )
           ! thres has been changed from
              ! thresh = max( ten*eps*sa, smlnum )
           ! to
              ! thresh = max( twenty*eps*sa, smlnum )
           ! on 04/01/10.
           ! "bug" reported by ondra kamenik, confirmed by julie langou, fixed by
           ! jim demmel and guillaume revy. see forum post 1783.
           thresha = max( twenty*eps*dnorma, smlnum )
           threshb = max( twenty*eps*dnormb, smlnum )
           if( m==2 ) then
              ! case 1: swap 1-by-1 and 1-by-1 blocks.
              ! compute orthogonal ql and rq that swap 1-by-1 and 1-by-1 blocks
              ! using givens rotations and perform the swap tentatively.
              f = s( 2, 2 )*t( 1, 1 ) - t( 2, 2 )*s( 1, 1 )
              g = s( 2, 2 )*t( 1, 2 ) - t( 2, 2 )*s( 1, 2 )
              sa = abs( s( 2, 2 ) ) * abs( t( 1, 1 ) )
              sb = abs( s( 1, 1 ) ) * abs( t( 2, 2 ) )
              call stdlib_slartg( f, g, ir( 1, 2 ), ir( 1, 1 ), ddum )
              ir( 2, 1 ) = -ir( 1, 2 )
              ir( 2, 2 ) = ir( 1, 1 )
              call stdlib_srot( 2, s( 1, 1 ), 1, s( 1, 2 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
              call stdlib_srot( 2, t( 1, 1 ), 1, t( 1, 2 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
              if( sa>=sb ) then
                 call stdlib_slartg( s( 1, 1 ), s( 2, 1 ), li( 1, 1 ), li( 2, 1 ),ddum )
              else
                 call stdlib_slartg( t( 1, 1 ), t( 2, 1 ), li( 1, 1 ), li( 2, 1 ),ddum )
              end if
              call stdlib_srot( 2, s( 1, 1 ), ldst, s( 2, 1 ), ldst, li( 1, 1 ),li( 2, 1 ) )
                        
              call stdlib_srot( 2, t( 1, 1 ), ldst, t( 2, 1 ), ldst, li( 1, 1 ),li( 2, 1 ) )
                        
              li( 2, 2 ) = li( 1, 1 )
              li( 1, 2 ) = -li( 2, 1 )
              ! weak stability test: |s21| <= o(eps f-norm((a)))
                                 ! and  |t21| <= o(eps f-norm((b)))
              weak = abs( s( 2, 1 ) ) <= thresha .and.abs( t( 2, 1 ) ) <= threshb
              if( .not.weak )go to 70
              if( wands ) then
                 ! strong stability test:
                     ! f-norm((a-ql**h*s*qr)) <= o(eps*f-norm((a)))
                     ! and
                     ! f-norm((b-ql**h*t*qr)) <= o(eps*f-norm((b)))
                 call stdlib_slacpy( 'FULL', m, m, a( j1, j1 ), lda, work( m*m+1 ),m )
                 call stdlib_sgemm( 'N', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
                           
                 call stdlib_sgemm( 'N', 'T', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_slassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sa = dscale*sqrt( dsum )
                 call stdlib_slacpy( 'FULL', m, m, b( j1, j1 ), ldb, work( m*m+1 ),m )
                 call stdlib_sgemm( 'N', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
                           
                 call stdlib_sgemm( 'N', 'T', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_slassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sb = dscale*sqrt( dsum )
                 strong = sa<=thresha .and. sb<=threshb
                 if( .not.strong )go to 70
              end if
              ! update (a(j1:j1+m-1, m+j1:n), b(j1:j1+m-1, m+j1:n)) and
                     ! (a(1:j1-1, j1:j1+m), b(1:j1-1, j1:j1+m)).
              call stdlib_srot( j1+1, a( 1, j1 ), 1, a( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
                        
              call stdlib_srot( j1+1, b( 1, j1 ), 1, b( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
                        
              call stdlib_srot( n-j1+1, a( j1, j1 ), lda, a( j1+1, j1 ), lda,li( 1, 1 ), li( 2, 1 &
                        ) )
              call stdlib_srot( n-j1+1, b( j1, j1 ), ldb, b( j1+1, j1 ), ldb,li( 1, 1 ), li( 2, 1 &
                        ) )
              ! set  n1-by-n2 (2,1) - blocks to zero.
              a( j1+1, j1 ) = zero
              b( j1+1, j1 ) = zero
              ! accumulate transformations into q and z if requested.
              if( wantz )call stdlib_srot( n, z( 1, j1 ), 1, z( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 &
                        ) )
              if( wantq )call stdlib_srot( n, q( 1, j1 ), 1, q( 1, j1+1 ), 1, li( 1, 1 ),li( 2, 1 &
                        ) )
              ! exit with info = 0 if swap was successfully performed.
              return
           else
              ! case 2: swap 1-by-1 and 2-by-2 blocks, or 2-by-2
                      ! and 2-by-2 blocks.
              ! solve the generalized sylvester equation
                       ! s11 * r - l * s22 = scale * s12
                       ! t11 * r - l * t22 = scale * t12
              ! for r and l. solutions in li and ir.
              call stdlib_slacpy( 'FULL', n1, n2, t( 1, n1+1 ), ldst, li, ldst )
              call stdlib_slacpy( 'FULL', n1, n2, s( 1, n1+1 ), ldst,ir( n2+1, n1+1 ), ldst )
                        
              call stdlib_stgsy2( 'N', 0, n1, n2, s, ldst, s( n1+1, n1+1 ), ldst,ir( n2+1, n1+1 ),&
               ldst, t, ldst, t( n1+1, n1+1 ),ldst, li, ldst, scale, dsum, dscale, iwork, idum,&
                         linfo )
              if( linfo/=0 )go to 70
              ! compute orthogonal matrix ql:
                          ! ql**t * li = [ tl ]
                                       ! [ 0  ]
              ! where
                          ! li =  [      -l              ]
                                ! [ scale * identity(n2) ]
              do i = 1, n2
                 call stdlib_sscal( n1, -one, li( 1, i ), 1 )
                 li( n1+i, i ) = scale
              end do
              call stdlib_sgeqr2( m, n2, li, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_sorg2r( m, m, n2, li, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              ! compute orthogonal matrix rq:
                          ! ir * rq**t =   [ 0  tr],
               ! where ir = [ scale * identity(n1), r ]
              do i = 1, n1
                 ir( n2+i, i ) = scale
              end do
              call stdlib_sgerq2( n1, m, ir( n2+1, 1 ), ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_sorgr2( m, m, n1, ir, ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              ! perform the swapping tentatively:
              call stdlib_sgemm( 'T', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
              call stdlib_sgemm( 'N', 'T', m, m, m, one, work, m, ir, ldst, zero, s,ldst )
              call stdlib_sgemm( 'T', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
              call stdlib_sgemm( 'N', 'T', m, m, m, one, work, m, ir, ldst, zero, t,ldst )
              call stdlib_slacpy( 'F', m, m, s, ldst, scpy, ldst )
              call stdlib_slacpy( 'F', m, m, t, ldst, tcpy, ldst )
              call stdlib_slacpy( 'F', m, m, ir, ldst, ircop, ldst )
              call stdlib_slacpy( 'F', m, m, li, ldst, licop, ldst )
              ! triangularize the b-part by an rq factorization.
              ! apply transformation (from left) to a-part, giving s.
              call stdlib_sgerq2( m, m, t, ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_sormr2( 'R', 'T', m, m, m, t, ldst, taur, s, ldst, work,linfo )
              if( linfo/=0 )go to 70
              call stdlib_sormr2( 'L', 'N', m, m, m, t, ldst, taur, ir, ldst, work,linfo )
              if( linfo/=0 )go to 70
              ! compute f-norm(s21) in brqa21. (t21 is 0.)
              dscale = zero
              dsum = one
              do i = 1, n2
                 call stdlib_slassq( n1, s( n2+1, i ), 1, dscale, dsum )
              end do
              brqa21 = dscale*sqrt( dsum )
              ! triangularize the b-part by a qr factorization.
              ! apply transformation (from right) to a-part, giving s.
              call stdlib_sgeqr2( m, m, tcpy, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_sorm2r( 'L', 'T', m, m, m, tcpy, ldst, taul, scpy, ldst,work, info )
                        
              call stdlib_sorm2r( 'R', 'N', m, m, m, tcpy, ldst, taul, licop, ldst,work, info )
                        
              if( linfo/=0 )go to 70
              ! compute f-norm(s21) in bqra21. (t21 is 0.)
              dscale = zero
              dsum = one
              do i = 1, n2
                 call stdlib_slassq( n1, scpy( n2+1, i ), 1, dscale, dsum )
              end do
              bqra21 = dscale*sqrt( dsum )
              ! decide which method to use.
                ! weak stability test:
                   ! f-norm(s21) <= o(eps * f-norm((s)))
              if( bqra21<=brqa21 .and. bqra21<=thresha ) then
                 call stdlib_slacpy( 'F', m, m, scpy, ldst, s, ldst )
                 call stdlib_slacpy( 'F', m, m, tcpy, ldst, t, ldst )
                 call stdlib_slacpy( 'F', m, m, ircop, ldst, ir, ldst )
                 call stdlib_slacpy( 'F', m, m, licop, ldst, li, ldst )
              else if( brqa21>=thresha ) then
                 go to 70
              end if
              ! set lower triangle of b-part to zero
              if (m>1) call stdlib_slaset( 'LOWER', m-1, m-1, zero, zero, t(2,1), ldst )
              if( wands ) then
                 ! strong stability test:
                     ! f-norm((a-ql**h*s*qr)) <= o(eps*f-norm((a)))
                     ! and
                     ! f-norm((b-ql**h*t*qr)) <= o(eps*f-norm((b)))
                 call stdlib_slacpy( 'FULL', m, m, a( j1, j1 ), lda, work( m*m+1 ),m )
                 call stdlib_sgemm( 'N', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
                           
                 call stdlib_sgemm( 'N', 'N', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_slassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sa = dscale*sqrt( dsum )
                 call stdlib_slacpy( 'FULL', m, m, b( j1, j1 ), ldb, work( m*m+1 ),m )
                 call stdlib_sgemm( 'N', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
                           
                 call stdlib_sgemm( 'N', 'N', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_slassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sb = dscale*sqrt( dsum )
                 strong = sa<=thresha .and. sb<=threshb
                 if( .not.strong )go to 70
              end if
              ! if the swap is accepted ("weakly" and "strongly"), apply the
              ! transformations and set n1-by-n2 (2,1)-block to zero.
              call stdlib_slaset( 'FULL', n1, n2, zero, zero, s(n2+1,1), ldst )
              ! copy back m-by-m diagonal block starting at index j1 of (a, b)
              call stdlib_slacpy( 'F', m, m, s, ldst, a( j1, j1 ), lda )
              call stdlib_slacpy( 'F', m, m, t, ldst, b( j1, j1 ), ldb )
              call stdlib_slaset( 'FULL', ldst, ldst, zero, zero, t, ldst )
              ! standardize existing 2-by-2 blocks.
              call stdlib_slaset( 'FULL', m, m, zero, zero, work, m )
              work( 1 ) = one
              t( 1, 1 ) = one
              idum = lwork - m*m - 2
              if( n2>1 ) then
                 call stdlib_slagv2( a( j1, j1 ), lda, b( j1, j1 ), ldb, ar, ai, be,work( 1 ), &
                           work( 2 ), t( 1, 1 ), t( 2, 1 ) )
                 work( m+1 ) = -work( 2 )
                 work( m+2 ) = work( 1 )
                 t( n2, n2 ) = t( 1, 1 )
                 t( 1, 2 ) = -t( 2, 1 )
              end if
              work( m*m ) = one
              t( m, m ) = one
              if( n1>1 ) then
                 call stdlib_slagv2( a( j1+n2, j1+n2 ), lda, b( j1+n2, j1+n2 ), ldb,taur, taul, &
                 work( m*m+1 ), work( n2*m+n2+1 ),work( n2*m+n2+2 ), t( n2+1, n2+1 ),t( m, m-1 ) )
                           
                 work( m*m ) = work( n2*m+n2+1 )
                 work( m*m-1 ) = -work( n2*m+n2+2 )
                 t( m, m ) = t( n2+1, n2+1 )
                 t( m-1, m ) = -t( m, m-1 )
              end if
              call stdlib_sgemm( 'T', 'N', n2, n1, n2, one, work, m, a( j1, j1+n2 ),lda, zero, &
                        work( m*m+1 ), n2 )
              call stdlib_slacpy( 'FULL', n2, n1, work( m*m+1 ), n2, a( j1, j1+n2 ),lda )
              call stdlib_sgemm( 'T', 'N', n2, n1, n2, one, work, m, b( j1, j1+n2 ),ldb, zero, &
                        work( m*m+1 ), n2 )
              call stdlib_slacpy( 'FULL', n2, n1, work( m*m+1 ), n2, b( j1, j1+n2 ),ldb )
              call stdlib_sgemm( 'N', 'N', m, m, m, one, li, ldst, work, m, zero,work( m*m+1 ), m &
                        )
              call stdlib_slacpy( 'FULL', m, m, work( m*m+1 ), m, li, ldst )
              call stdlib_sgemm( 'N', 'N', n2, n1, n1, one, a( j1, j1+n2 ), lda,t( n2+1, n2+1 ), &
                        ldst, zero, work, n2 )
              call stdlib_slacpy( 'FULL', n2, n1, work, n2, a( j1, j1+n2 ), lda )
              call stdlib_sgemm( 'N', 'N', n2, n1, n1, one, b( j1, j1+n2 ), ldb,t( n2+1, n2+1 ), &
                        ldst, zero, work, n2 )
              call stdlib_slacpy( 'FULL', n2, n1, work, n2, b( j1, j1+n2 ), ldb )
              call stdlib_sgemm( 'T', 'N', m, m, m, one, ir, ldst, t, ldst, zero,work, m )
              call stdlib_slacpy( 'FULL', m, m, work, m, ir, ldst )
              ! accumulate transformations into q and z if requested.
              if( wantq ) then
                 call stdlib_sgemm( 'N', 'N', n, m, m, one, q( 1, j1 ), ldq, li,ldst, zero, work, &
                           n )
                 call stdlib_slacpy( 'FULL', n, m, work, n, q( 1, j1 ), ldq )
              end if
              if( wantz ) then
                 call stdlib_sgemm( 'N', 'N', n, m, m, one, z( 1, j1 ), ldz, ir,ldst, zero, work, &
                           n )
                 call stdlib_slacpy( 'FULL', n, m, work, n, z( 1, j1 ), ldz )
              end if
              ! update (a(j1:j1+m-1, m+j1:n), b(j1:j1+m-1, m+j1:n)) and
                      ! (a(1:j1-1, j1:j1+m), b(1:j1-1, j1:j1+m)).
              i = j1 + m
              if( i<=n ) then
                 call stdlib_sgemm( 'T', 'N', m, n-i+1, m, one, li, ldst,a( j1, i ), lda, zero, &
                           work, m )
                 call stdlib_slacpy( 'FULL', m, n-i+1, work, m, a( j1, i ), lda )
                 call stdlib_sgemm( 'T', 'N', m, n-i+1, m, one, li, ldst,b( j1, i ), ldb, zero, &
                           work, m )
                 call stdlib_slacpy( 'FULL', m, n-i+1, work, m, b( j1, i ), ldb )
              end if
              i = j1 - 1
              if( i>0 ) then
                 call stdlib_sgemm( 'N', 'N', i, m, m, one, a( 1, j1 ), lda, ir,ldst, zero, work, &
                           i )
                 call stdlib_slacpy( 'FULL', i, m, work, i, a( 1, j1 ), lda )
                 call stdlib_sgemm( 'N', 'N', i, m, m, one, b( 1, j1 ), ldb, ir,ldst, zero, work, &
                           i )
                 call stdlib_slacpy( 'FULL', i, m, work, i, b( 1, j1 ), ldb )
              end if
              ! exit with info = 0 if swap was successfully performed.
              return
           end if
           ! exit with info = 1 if swap was rejected.
           70 continue
           info = 1
           return
     end subroutine stdlib_stgex2

     module pure subroutine stdlib_dtgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, n1, n2, &
     !! DTGEX2 swaps adjacent diagonal blocks (A11, B11) and (A22, B22)
     !! of size 1-by-1 or 2-by-2 in an upper (quasi) triangular matrix pair
     !! (A, B) by an orthogonal equivalence transformation.
     !! (A, B) must be in generalized real Schur canonical form (as returned
     !! by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
     !! diagonal blocks. B is upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
     !! Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T
               work, lwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: j1, lda, ldb, ldq, ldz, lwork, n, n1, n2
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_dcopy by calls to stdlib_dlaset, or by do
        ! loops. sven hammarling, 1/5/02.
           ! Parameters 
           real(dp), parameter :: twenty = 2.0e+01_dp
           integer(ilp), parameter :: ldst = 4
           logical(lk), parameter :: wands = .true.
           
           
           
           
           ! Local Scalars 
           logical(lk) :: strong, weak
           integer(ilp) :: i, idum, linfo, m
           real(dp) :: bqra21, brqa21, ddum, dnorma, dnormb, dscale, dsum, eps, f, g, sa, sb, &
                     scale, smlnum, thresha, threshb
           ! Local Arrays 
           integer(ilp) :: iwork(ldst)
           real(dp) :: ai(2), ar(2), be(2), ir(ldst,ldst), ircop(ldst,ldst), li(ldst,ldst), licop(&
           ldst,ldst), s(ldst,ldst), scpy(ldst,ldst), t(ldst,ldst), taul(ldst), taur(ldst), tcpy(&
                     ldst,ldst)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=1 .or. n1<=0 .or. n2<=0 )return
           if( n1>n .or. ( j1+n1 )>n )return
           m = n1 + n2
           if( lwork<max( 1, n*m, m*m*2 ) ) then
              info = -16
              work( 1 ) = max( 1, n*m, m*m*2 )
              return
           end if
           weak = .false.
           strong = .false.
           ! make a local copy of selected block
           call stdlib_dlaset( 'FULL', ldst, ldst, zero, zero, li, ldst )
           call stdlib_dlaset( 'FULL', ldst, ldst, zero, zero, ir, ldst )
           call stdlib_dlacpy( 'FULL', m, m, a( j1, j1 ), lda, s, ldst )
           call stdlib_dlacpy( 'FULL', m, m, b( j1, j1 ), ldb, t, ldst )
           ! compute threshold for testing acceptance of swapping.
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' ) / eps
           dscale = zero
           dsum = one
           call stdlib_dlacpy( 'FULL', m, m, s, ldst, work, m )
           call stdlib_dlassq( m*m, work, 1, dscale, dsum )
           dnorma = dscale*sqrt( dsum )
           dscale = zero
           dsum = one
           call stdlib_dlacpy( 'FULL', m, m, t, ldst, work, m )
           call stdlib_dlassq( m*m, work, 1, dscale, dsum )
           dnormb = dscale*sqrt( dsum )
           ! thres has been changed from
              ! thresh = max( ten*eps*sa, smlnum )
           ! to
              ! thresh = max( twenty*eps*sa, smlnum )
           ! on 04/01/10.
           ! "bug" reported by ondra kamenik, confirmed by julie langou, fixed by
           ! jim demmel and guillaume revy. see forum post 1783.
           thresha = max( twenty*eps*dnorma, smlnum )
           threshb = max( twenty*eps*dnormb, smlnum )
           if( m==2 ) then
              ! case 1: swap 1-by-1 and 1-by-1 blocks.
              ! compute orthogonal ql and rq that swap 1-by-1 and 1-by-1 blocks
              ! using givens rotations and perform the swap tentatively.
              f = s( 2, 2 )*t( 1, 1 ) - t( 2, 2 )*s( 1, 1 )
              g = s( 2, 2 )*t( 1, 2 ) - t( 2, 2 )*s( 1, 2 )
              sa = abs( s( 2, 2 ) ) * abs( t( 1, 1 ) )
              sb = abs( s( 1, 1 ) ) * abs( t( 2, 2 ) )
              call stdlib_dlartg( f, g, ir( 1, 2 ), ir( 1, 1 ), ddum )
              ir( 2, 1 ) = -ir( 1, 2 )
              ir( 2, 2 ) = ir( 1, 1 )
              call stdlib_drot( 2, s( 1, 1 ), 1, s( 1, 2 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
              call stdlib_drot( 2, t( 1, 1 ), 1, t( 1, 2 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
              if( sa>=sb ) then
                 call stdlib_dlartg( s( 1, 1 ), s( 2, 1 ), li( 1, 1 ), li( 2, 1 ),ddum )
              else
                 call stdlib_dlartg( t( 1, 1 ), t( 2, 1 ), li( 1, 1 ), li( 2, 1 ),ddum )
              end if
              call stdlib_drot( 2, s( 1, 1 ), ldst, s( 2, 1 ), ldst, li( 1, 1 ),li( 2, 1 ) )
                        
              call stdlib_drot( 2, t( 1, 1 ), ldst, t( 2, 1 ), ldst, li( 1, 1 ),li( 2, 1 ) )
                        
              li( 2, 2 ) = li( 1, 1 )
              li( 1, 2 ) = -li( 2, 1 )
              ! weak stability test: |s21| <= o(eps f-norm((a)))
                                 ! and  |t21| <= o(eps f-norm((b)))
              weak = abs( s( 2, 1 ) ) <= thresha .and.abs( t( 2, 1 ) ) <= threshb
              if( .not.weak )go to 70
              if( wands ) then
                 ! strong stability test:
                     ! f-norm((a-ql**h*s*qr)) <= o(eps*f-norm((a)))
                     ! and
                     ! f-norm((b-ql**h*t*qr)) <= o(eps*f-norm((b)))
                 call stdlib_dlacpy( 'FULL', m, m, a( j1, j1 ), lda, work( m*m+1 ),m )
                 call stdlib_dgemm( 'N', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
                           
                 call stdlib_dgemm( 'N', 'T', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_dlassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sa = dscale*sqrt( dsum )
                 call stdlib_dlacpy( 'FULL', m, m, b( j1, j1 ), ldb, work( m*m+1 ),m )
                 call stdlib_dgemm( 'N', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
                           
                 call stdlib_dgemm( 'N', 'T', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_dlassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sb = dscale*sqrt( dsum )
                 strong = sa<=thresha .and. sb<=threshb
                 if( .not.strong )go to 70
              end if
              ! update (a(j1:j1+m-1, m+j1:n), b(j1:j1+m-1, m+j1:n)) and
                     ! (a(1:j1-1, j1:j1+m), b(1:j1-1, j1:j1+m)).
              call stdlib_drot( j1+1, a( 1, j1 ), 1, a( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
                        
              call stdlib_drot( j1+1, b( 1, j1 ), 1, b( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
                        
              call stdlib_drot( n-j1+1, a( j1, j1 ), lda, a( j1+1, j1 ), lda,li( 1, 1 ), li( 2, 1 &
                        ) )
              call stdlib_drot( n-j1+1, b( j1, j1 ), ldb, b( j1+1, j1 ), ldb,li( 1, 1 ), li( 2, 1 &
                        ) )
              ! set  n1-by-n2 (2,1) - blocks to zero.
              a( j1+1, j1 ) = zero
              b( j1+1, j1 ) = zero
              ! accumulate transformations into q and z if requested.
              if( wantz )call stdlib_drot( n, z( 1, j1 ), 1, z( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 &
                        ) )
              if( wantq )call stdlib_drot( n, q( 1, j1 ), 1, q( 1, j1+1 ), 1, li( 1, 1 ),li( 2, 1 &
                        ) )
              ! exit with info = 0 if swap was successfully performed.
              return
           else
              ! case 2: swap 1-by-1 and 2-by-2 blocks, or 2-by-2
                      ! and 2-by-2 blocks.
              ! solve the generalized sylvester equation
                       ! s11 * r - l * s22 = scale * s12
                       ! t11 * r - l * t22 = scale * t12
              ! for r and l. solutions in li and ir.
              call stdlib_dlacpy( 'FULL', n1, n2, t( 1, n1+1 ), ldst, li, ldst )
              call stdlib_dlacpy( 'FULL', n1, n2, s( 1, n1+1 ), ldst,ir( n2+1, n1+1 ), ldst )
                        
              call stdlib_dtgsy2( 'N', 0, n1, n2, s, ldst, s( n1+1, n1+1 ), ldst,ir( n2+1, n1+1 ),&
               ldst, t, ldst, t( n1+1, n1+1 ),ldst, li, ldst, scale, dsum, dscale, iwork, idum,&
                         linfo )
              if( linfo/=0 )go to 70
              ! compute orthogonal matrix ql:
                          ! ql**t * li = [ tl ]
                                       ! [ 0  ]
              ! where
                          ! li =  [      -l              ]
                                ! [ scale * identity(n2) ]
              do i = 1, n2
                 call stdlib_dscal( n1, -one, li( 1, i ), 1 )
                 li( n1+i, i ) = scale
              end do
              call stdlib_dgeqr2( m, n2, li, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_dorg2r( m, m, n2, li, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              ! compute orthogonal matrix rq:
                          ! ir * rq**t =   [ 0  tr],
               ! where ir = [ scale * identity(n1), r ]
              do i = 1, n1
                 ir( n2+i, i ) = scale
              end do
              call stdlib_dgerq2( n1, m, ir( n2+1, 1 ), ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_dorgr2( m, m, n1, ir, ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              ! perform the swapping tentatively:
              call stdlib_dgemm( 'T', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
              call stdlib_dgemm( 'N', 'T', m, m, m, one, work, m, ir, ldst, zero, s,ldst )
              call stdlib_dgemm( 'T', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
              call stdlib_dgemm( 'N', 'T', m, m, m, one, work, m, ir, ldst, zero, t,ldst )
              call stdlib_dlacpy( 'F', m, m, s, ldst, scpy, ldst )
              call stdlib_dlacpy( 'F', m, m, t, ldst, tcpy, ldst )
              call stdlib_dlacpy( 'F', m, m, ir, ldst, ircop, ldst )
              call stdlib_dlacpy( 'F', m, m, li, ldst, licop, ldst )
              ! triangularize the b-part by an rq factorization.
              ! apply transformation (from left) to a-part, giving s.
              call stdlib_dgerq2( m, m, t, ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_dormr2( 'R', 'T', m, m, m, t, ldst, taur, s, ldst, work,linfo )
              if( linfo/=0 )go to 70
              call stdlib_dormr2( 'L', 'N', m, m, m, t, ldst, taur, ir, ldst, work,linfo )
              if( linfo/=0 )go to 70
              ! compute f-norm(s21) in brqa21. (t21 is 0.)
              dscale = zero
              dsum = one
              do i = 1, n2
                 call stdlib_dlassq( n1, s( n2+1, i ), 1, dscale, dsum )
              end do
              brqa21 = dscale*sqrt( dsum )
              ! triangularize the b-part by a qr factorization.
              ! apply transformation (from right) to a-part, giving s.
              call stdlib_dgeqr2( m, m, tcpy, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_dorm2r( 'L', 'T', m, m, m, tcpy, ldst, taul, scpy, ldst,work, info )
                        
              call stdlib_dorm2r( 'R', 'N', m, m, m, tcpy, ldst, taul, licop, ldst,work, info )
                        
              if( linfo/=0 )go to 70
              ! compute f-norm(s21) in bqra21. (t21 is 0.)
              dscale = zero
              dsum = one
              do i = 1, n2
                 call stdlib_dlassq( n1, scpy( n2+1, i ), 1, dscale, dsum )
              end do
              bqra21 = dscale*sqrt( dsum )
              ! decide which method to use.
                ! weak stability test:
                   ! f-norm(s21) <= o(eps * f-norm((s)))
              if( bqra21<=brqa21 .and. bqra21<=thresha ) then
                 call stdlib_dlacpy( 'F', m, m, scpy, ldst, s, ldst )
                 call stdlib_dlacpy( 'F', m, m, tcpy, ldst, t, ldst )
                 call stdlib_dlacpy( 'F', m, m, ircop, ldst, ir, ldst )
                 call stdlib_dlacpy( 'F', m, m, licop, ldst, li, ldst )
              else if( brqa21>=thresha ) then
                 go to 70
              end if
              ! set lower triangle of b-part to zero
              call stdlib_dlaset( 'LOWER', m-1, m-1, zero, zero, t(2,1), ldst )
              if( wands ) then
                 ! strong stability test:
                     ! f-norm((a-ql**h*s*qr)) <= o(eps*f-norm((a)))
                     ! and
                     ! f-norm((b-ql**h*t*qr)) <= o(eps*f-norm((b)))
                 call stdlib_dlacpy( 'FULL', m, m, a( j1, j1 ), lda, work( m*m+1 ),m )
                 call stdlib_dgemm( 'N', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
                           
                 call stdlib_dgemm( 'N', 'N', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_dlassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sa = dscale*sqrt( dsum )
                 call stdlib_dlacpy( 'FULL', m, m, b( j1, j1 ), ldb, work( m*m+1 ),m )
                 call stdlib_dgemm( 'N', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
                           
                 call stdlib_dgemm( 'N', 'N', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_dlassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sb = dscale*sqrt( dsum )
                 strong = sa<=thresha .and. sb<=threshb
                 if( .not.strong )go to 70
              end if
              ! if the swap is accepted ("weakly" and "strongly"), apply the
              ! transformations and set n1-by-n2 (2,1)-block to zero.
              call stdlib_dlaset( 'FULL', n1, n2, zero, zero, s(n2+1,1), ldst )
              ! copy back m-by-m diagonal block starting at index j1 of (a, b)
              call stdlib_dlacpy( 'F', m, m, s, ldst, a( j1, j1 ), lda )
              call stdlib_dlacpy( 'F', m, m, t, ldst, b( j1, j1 ), ldb )
              call stdlib_dlaset( 'FULL', ldst, ldst, zero, zero, t, ldst )
              ! standardize existing 2-by-2 blocks.
              call stdlib_dlaset( 'FULL', m, m, zero, zero, work, m )
              work( 1 ) = one
              t( 1, 1 ) = one
              idum = lwork - m*m - 2
              if( n2>1 ) then
                 call stdlib_dlagv2( a( j1, j1 ), lda, b( j1, j1 ), ldb, ar, ai, be,work( 1 ), &
                           work( 2 ), t( 1, 1 ), t( 2, 1 ) )
                 work( m+1 ) = -work( 2 )
                 work( m+2 ) = work( 1 )
                 t( n2, n2 ) = t( 1, 1 )
                 t( 1, 2 ) = -t( 2, 1 )
              end if
              work( m*m ) = one
              t( m, m ) = one
              if( n1>1 ) then
                 call stdlib_dlagv2( a( j1+n2, j1+n2 ), lda, b( j1+n2, j1+n2 ), ldb,taur, taul, &
                 work( m*m+1 ), work( n2*m+n2+1 ),work( n2*m+n2+2 ), t( n2+1, n2+1 ),t( m, m-1 ) )
                           
                 work( m*m ) = work( n2*m+n2+1 )
                 work( m*m-1 ) = -work( n2*m+n2+2 )
                 t( m, m ) = t( n2+1, n2+1 )
                 t( m-1, m ) = -t( m, m-1 )
              end if
              call stdlib_dgemm( 'T', 'N', n2, n1, n2, one, work, m, a( j1, j1+n2 ),lda, zero, &
                        work( m*m+1 ), n2 )
              call stdlib_dlacpy( 'FULL', n2, n1, work( m*m+1 ), n2, a( j1, j1+n2 ),lda )
              call stdlib_dgemm( 'T', 'N', n2, n1, n2, one, work, m, b( j1, j1+n2 ),ldb, zero, &
                        work( m*m+1 ), n2 )
              call stdlib_dlacpy( 'FULL', n2, n1, work( m*m+1 ), n2, b( j1, j1+n2 ),ldb )
              call stdlib_dgemm( 'N', 'N', m, m, m, one, li, ldst, work, m, zero,work( m*m+1 ), m &
                        )
              call stdlib_dlacpy( 'FULL', m, m, work( m*m+1 ), m, li, ldst )
              call stdlib_dgemm( 'N', 'N', n2, n1, n1, one, a( j1, j1+n2 ), lda,t( n2+1, n2+1 ), &
                        ldst, zero, work, n2 )
              call stdlib_dlacpy( 'FULL', n2, n1, work, n2, a( j1, j1+n2 ), lda )
              call stdlib_dgemm( 'N', 'N', n2, n1, n1, one, b( j1, j1+n2 ), ldb,t( n2+1, n2+1 ), &
                        ldst, zero, work, n2 )
              call stdlib_dlacpy( 'FULL', n2, n1, work, n2, b( j1, j1+n2 ), ldb )
              call stdlib_dgemm( 'T', 'N', m, m, m, one, ir, ldst, t, ldst, zero,work, m )
              call stdlib_dlacpy( 'FULL', m, m, work, m, ir, ldst )
              ! accumulate transformations into q and z if requested.
              if( wantq ) then
                 call stdlib_dgemm( 'N', 'N', n, m, m, one, q( 1, j1 ), ldq, li,ldst, zero, work, &
                           n )
                 call stdlib_dlacpy( 'FULL', n, m, work, n, q( 1, j1 ), ldq )
              end if
              if( wantz ) then
                 call stdlib_dgemm( 'N', 'N', n, m, m, one, z( 1, j1 ), ldz, ir,ldst, zero, work, &
                           n )
                 call stdlib_dlacpy( 'FULL', n, m, work, n, z( 1, j1 ), ldz )
              end if
              ! update (a(j1:j1+m-1, m+j1:n), b(j1:j1+m-1, m+j1:n)) and
                      ! (a(1:j1-1, j1:j1+m), b(1:j1-1, j1:j1+m)).
              i = j1 + m
              if( i<=n ) then
                 call stdlib_dgemm( 'T', 'N', m, n-i+1, m, one, li, ldst,a( j1, i ), lda, zero, &
                           work, m )
                 call stdlib_dlacpy( 'FULL', m, n-i+1, work, m, a( j1, i ), lda )
                 call stdlib_dgemm( 'T', 'N', m, n-i+1, m, one, li, ldst,b( j1, i ), ldb, zero, &
                           work, m )
                 call stdlib_dlacpy( 'FULL', m, n-i+1, work, m, b( j1, i ), ldb )
              end if
              i = j1 - 1
              if( i>0 ) then
                 call stdlib_dgemm( 'N', 'N', i, m, m, one, a( 1, j1 ), lda, ir,ldst, zero, work, &
                           i )
                 call stdlib_dlacpy( 'FULL', i, m, work, i, a( 1, j1 ), lda )
                 call stdlib_dgemm( 'N', 'N', i, m, m, one, b( 1, j1 ), ldb, ir,ldst, zero, work, &
                           i )
                 call stdlib_dlacpy( 'FULL', i, m, work, i, b( 1, j1 ), ldb )
              end if
              ! exit with info = 0 if swap was successfully performed.
              return
           end if
           ! exit with info = 1 if swap was rejected.
           70 continue
           info = 1
           return
     end subroutine stdlib_dtgex2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, n1, n2, &
     !! DTGEX2: swaps adjacent diagonal blocks (A11, B11) and (A22, B22)
     !! of size 1-by-1 or 2-by-2 in an upper (quasi) triangular matrix pair
     !! (A, B) by an orthogonal equivalence transformation.
     !! (A, B) must be in generalized real Schur canonical form (as returned
     !! by DGGES), i.e. A is block upper triangular with 1-by-1 and 2-by-2
     !! diagonal blocks. B is upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**T = Q(out) * A(out) * Z(out)**T
     !! Q(in) * B(in) * Z(in)**T = Q(out) * B(out) * Z(out)**T
               work, lwork, info )
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: j1, lda, ldb, ldq, ldz, lwork, n, n1, n2
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
        ! replaced various illegal calls to stdlib_${ri}$copy by calls to stdlib_${ri}$laset, or by do
        ! loops. sven hammarling, 1/5/02.
           ! Parameters 
           real(${rk}$), parameter :: twenty = 2.0e+01_${rk}$
           integer(ilp), parameter :: ldst = 4
           logical(lk), parameter :: wands = .true.
           
           
           
           
           ! Local Scalars 
           logical(lk) :: strong, weak
           integer(ilp) :: i, idum, linfo, m
           real(${rk}$) :: bqra21, brqa21, ddum, dnorma, dnormb, dscale, dsum, eps, f, g, sa, sb, &
                     scale, smlnum, thresha, threshb
           ! Local Arrays 
           integer(ilp) :: iwork(ldst)
           real(${rk}$) :: ai(2), ar(2), be(2), ir(ldst,ldst), ircop(ldst,ldst), li(ldst,ldst), licop(&
           ldst,ldst), s(ldst,ldst), scpy(ldst,ldst), t(ldst,ldst), taul(ldst), taur(ldst), tcpy(&
                     ldst,ldst)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=1 .or. n1<=0 .or. n2<=0 )return
           if( n1>n .or. ( j1+n1 )>n )return
           m = n1 + n2
           if( lwork<max( 1, n*m, m*m*2 ) ) then
              info = -16
              work( 1 ) = max( 1, n*m, m*m*2 )
              return
           end if
           weak = .false.
           strong = .false.
           ! make a local copy of selected block
           call stdlib_${ri}$laset( 'FULL', ldst, ldst, zero, zero, li, ldst )
           call stdlib_${ri}$laset( 'FULL', ldst, ldst, zero, zero, ir, ldst )
           call stdlib_${ri}$lacpy( 'FULL', m, m, a( j1, j1 ), lda, s, ldst )
           call stdlib_${ri}$lacpy( 'FULL', m, m, b( j1, j1 ), ldb, t, ldst )
           ! compute threshold for testing acceptance of swapping.
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' ) / eps
           dscale = zero
           dsum = one
           call stdlib_${ri}$lacpy( 'FULL', m, m, s, ldst, work, m )
           call stdlib_${ri}$lassq( m*m, work, 1, dscale, dsum )
           dnorma = dscale*sqrt( dsum )
           dscale = zero
           dsum = one
           call stdlib_${ri}$lacpy( 'FULL', m, m, t, ldst, work, m )
           call stdlib_${ri}$lassq( m*m, work, 1, dscale, dsum )
           dnormb = dscale*sqrt( dsum )
           ! thres has been changed from
              ! thresh = max( ten*eps*sa, smlnum )
           ! to
              ! thresh = max( twenty*eps*sa, smlnum )
           ! on 04/01/10.
           ! "bug" reported by ondra kamenik, confirmed by julie langou, fixed by
           ! jim demmel and guillaume revy. see forum post 1783.
           thresha = max( twenty*eps*dnorma, smlnum )
           threshb = max( twenty*eps*dnormb, smlnum )
           if( m==2 ) then
              ! case 1: swap 1-by-1 and 1-by-1 blocks.
              ! compute orthogonal ql and rq that swap 1-by-1 and 1-by-1 blocks
              ! using givens rotations and perform the swap tentatively.
              f = s( 2, 2 )*t( 1, 1 ) - t( 2, 2 )*s( 1, 1 )
              g = s( 2, 2 )*t( 1, 2 ) - t( 2, 2 )*s( 1, 2 )
              sa = abs( s( 2, 2 ) ) * abs( t( 1, 1 ) )
              sb = abs( s( 1, 1 ) ) * abs( t( 2, 2 ) )
              call stdlib_${ri}$lartg( f, g, ir( 1, 2 ), ir( 1, 1 ), ddum )
              ir( 2, 1 ) = -ir( 1, 2 )
              ir( 2, 2 ) = ir( 1, 1 )
              call stdlib_${ri}$rot( 2, s( 1, 1 ), 1, s( 1, 2 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
              call stdlib_${ri}$rot( 2, t( 1, 1 ), 1, t( 1, 2 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
              if( sa>=sb ) then
                 call stdlib_${ri}$lartg( s( 1, 1 ), s( 2, 1 ), li( 1, 1 ), li( 2, 1 ),ddum )
              else
                 call stdlib_${ri}$lartg( t( 1, 1 ), t( 2, 1 ), li( 1, 1 ), li( 2, 1 ),ddum )
              end if
              call stdlib_${ri}$rot( 2, s( 1, 1 ), ldst, s( 2, 1 ), ldst, li( 1, 1 ),li( 2, 1 ) )
                        
              call stdlib_${ri}$rot( 2, t( 1, 1 ), ldst, t( 2, 1 ), ldst, li( 1, 1 ),li( 2, 1 ) )
                        
              li( 2, 2 ) = li( 1, 1 )
              li( 1, 2 ) = -li( 2, 1 )
              ! weak stability test: |s21| <= o(eps f-norm((a)))
                                 ! and  |t21| <= o(eps f-norm((b)))
              weak = abs( s( 2, 1 ) ) <= thresha .and.abs( t( 2, 1 ) ) <= threshb
              if( .not.weak )go to 70
              if( wands ) then
                 ! strong stability test:
                     ! f-norm((a-ql**h*s*qr)) <= o(eps*f-norm((a)))
                     ! and
                     ! f-norm((b-ql**h*t*qr)) <= o(eps*f-norm((b)))
                 call stdlib_${ri}$lacpy( 'FULL', m, m, a( j1, j1 ), lda, work( m*m+1 ),m )
                 call stdlib_${ri}$gemm( 'N', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
                           
                 call stdlib_${ri}$gemm( 'N', 'T', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_${ri}$lassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sa = dscale*sqrt( dsum )
                 call stdlib_${ri}$lacpy( 'FULL', m, m, b( j1, j1 ), ldb, work( m*m+1 ),m )
                 call stdlib_${ri}$gemm( 'N', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
                           
                 call stdlib_${ri}$gemm( 'N', 'T', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_${ri}$lassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sb = dscale*sqrt( dsum )
                 strong = sa<=thresha .and. sb<=threshb
                 if( .not.strong )go to 70
              end if
              ! update (a(j1:j1+m-1, m+j1:n), b(j1:j1+m-1, m+j1:n)) and
                     ! (a(1:j1-1, j1:j1+m), b(1:j1-1, j1:j1+m)).
              call stdlib_${ri}$rot( j1+1, a( 1, j1 ), 1, a( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
                        
              call stdlib_${ri}$rot( j1+1, b( 1, j1 ), 1, b( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 ) )
                        
              call stdlib_${ri}$rot( n-j1+1, a( j1, j1 ), lda, a( j1+1, j1 ), lda,li( 1, 1 ), li( 2, 1 &
                        ) )
              call stdlib_${ri}$rot( n-j1+1, b( j1, j1 ), ldb, b( j1+1, j1 ), ldb,li( 1, 1 ), li( 2, 1 &
                        ) )
              ! set  n1-by-n2 (2,1) - blocks to zero.
              a( j1+1, j1 ) = zero
              b( j1+1, j1 ) = zero
              ! accumulate transformations into q and z if requested.
              if( wantz )call stdlib_${ri}$rot( n, z( 1, j1 ), 1, z( 1, j1+1 ), 1, ir( 1, 1 ),ir( 2, 1 &
                        ) )
              if( wantq )call stdlib_${ri}$rot( n, q( 1, j1 ), 1, q( 1, j1+1 ), 1, li( 1, 1 ),li( 2, 1 &
                        ) )
              ! exit with info = 0 if swap was successfully performed.
              return
           else
              ! case 2: swap 1-by-1 and 2-by-2 blocks, or 2-by-2
                      ! and 2-by-2 blocks.
              ! solve the generalized sylvester equation
                       ! s11 * r - l * s22 = scale * s12
                       ! t11 * r - l * t22 = scale * t12
              ! for r and l. solutions in li and ir.
              call stdlib_${ri}$lacpy( 'FULL', n1, n2, t( 1, n1+1 ), ldst, li, ldst )
              call stdlib_${ri}$lacpy( 'FULL', n1, n2, s( 1, n1+1 ), ldst,ir( n2+1, n1+1 ), ldst )
                        
              call stdlib_${ri}$tgsy2( 'N', 0, n1, n2, s, ldst, s( n1+1, n1+1 ), ldst,ir( n2+1, n1+1 ),&
               ldst, t, ldst, t( n1+1, n1+1 ),ldst, li, ldst, scale, dsum, dscale, iwork, idum,&
                         linfo )
              if( linfo/=0 )go to 70
              ! compute orthogonal matrix ql:
                          ! ql**t * li = [ tl ]
                                       ! [ 0  ]
              ! where
                          ! li =  [      -l              ]
                                ! [ scale * identity(n2) ]
              do i = 1, n2
                 call stdlib_${ri}$scal( n1, -one, li( 1, i ), 1 )
                 li( n1+i, i ) = scale
              end do
              call stdlib_${ri}$geqr2( m, n2, li, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_${ri}$org2r( m, m, n2, li, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              ! compute orthogonal matrix rq:
                          ! ir * rq**t =   [ 0  tr],
               ! where ir = [ scale * identity(n1), r ]
              do i = 1, n1
                 ir( n2+i, i ) = scale
              end do
              call stdlib_${ri}$gerq2( n1, m, ir( n2+1, 1 ), ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_${ri}$orgr2( m, m, n1, ir, ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              ! perform the swapping tentatively:
              call stdlib_${ri}$gemm( 'T', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
              call stdlib_${ri}$gemm( 'N', 'T', m, m, m, one, work, m, ir, ldst, zero, s,ldst )
              call stdlib_${ri}$gemm( 'T', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
              call stdlib_${ri}$gemm( 'N', 'T', m, m, m, one, work, m, ir, ldst, zero, t,ldst )
              call stdlib_${ri}$lacpy( 'F', m, m, s, ldst, scpy, ldst )
              call stdlib_${ri}$lacpy( 'F', m, m, t, ldst, tcpy, ldst )
              call stdlib_${ri}$lacpy( 'F', m, m, ir, ldst, ircop, ldst )
              call stdlib_${ri}$lacpy( 'F', m, m, li, ldst, licop, ldst )
              ! triangularize the b-part by an rq factorization.
              ! apply transformation (from left) to a-part, giving s.
              call stdlib_${ri}$gerq2( m, m, t, ldst, taur, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_${ri}$ormr2( 'R', 'T', m, m, m, t, ldst, taur, s, ldst, work,linfo )
              if( linfo/=0 )go to 70
              call stdlib_${ri}$ormr2( 'L', 'N', m, m, m, t, ldst, taur, ir, ldst, work,linfo )
              if( linfo/=0 )go to 70
              ! compute f-norm(s21) in brqa21. (t21 is 0.)
              dscale = zero
              dsum = one
              do i = 1, n2
                 call stdlib_${ri}$lassq( n1, s( n2+1, i ), 1, dscale, dsum )
              end do
              brqa21 = dscale*sqrt( dsum )
              ! triangularize the b-part by a qr factorization.
              ! apply transformation (from right) to a-part, giving s.
              call stdlib_${ri}$geqr2( m, m, tcpy, ldst, taul, work, linfo )
              if( linfo/=0 )go to 70
              call stdlib_${ri}$orm2r( 'L', 'T', m, m, m, tcpy, ldst, taul, scpy, ldst,work, info )
                        
              call stdlib_${ri}$orm2r( 'R', 'N', m, m, m, tcpy, ldst, taul, licop, ldst,work, info )
                        
              if( linfo/=0 )go to 70
              ! compute f-norm(s21) in bqra21. (t21 is 0.)
              dscale = zero
              dsum = one
              do i = 1, n2
                 call stdlib_${ri}$lassq( n1, scpy( n2+1, i ), 1, dscale, dsum )
              end do
              bqra21 = dscale*sqrt( dsum )
              ! decide which method to use.
                ! weak stability test:
                   ! f-norm(s21) <= o(eps * f-norm((s)))
              if( bqra21<=brqa21 .and. bqra21<=thresha ) then
                 call stdlib_${ri}$lacpy( 'F', m, m, scpy, ldst, s, ldst )
                 call stdlib_${ri}$lacpy( 'F', m, m, tcpy, ldst, t, ldst )
                 call stdlib_${ri}$lacpy( 'F', m, m, ircop, ldst, ir, ldst )
                 call stdlib_${ri}$lacpy( 'F', m, m, licop, ldst, li, ldst )
              else if( brqa21>=thresha ) then
                 go to 70
              end if
              ! set lower triangle of b-part to zero
              if (m>1) call stdlib_${ri}$laset( 'LOWER', m-1, m-1, zero, zero, t(2,1), ldst )
              if( wands ) then
                 ! strong stability test:
                     ! f-norm((a-ql**h*s*qr)) <= o(eps*f-norm((a)))
                     ! and
                     ! f-norm((b-ql**h*t*qr)) <= o(eps*f-norm((b)))
                 call stdlib_${ri}$lacpy( 'FULL', m, m, a( j1, j1 ), lda, work( m*m+1 ),m )
                 call stdlib_${ri}$gemm( 'N', 'N', m, m, m, one, li, ldst, s, ldst, zero,work, m )
                           
                 call stdlib_${ri}$gemm( 'N', 'N', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_${ri}$lassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sa = dscale*sqrt( dsum )
                 call stdlib_${ri}$lacpy( 'FULL', m, m, b( j1, j1 ), ldb, work( m*m+1 ),m )
                 call stdlib_${ri}$gemm( 'N', 'N', m, m, m, one, li, ldst, t, ldst, zero,work, m )
                           
                 call stdlib_${ri}$gemm( 'N', 'N', m, m, m, -one, work, m, ir, ldst, one,work( m*m+1 ),&
                            m )
                 dscale = zero
                 dsum = one
                 call stdlib_${ri}$lassq( m*m, work( m*m+1 ), 1, dscale, dsum )
                 sb = dscale*sqrt( dsum )
                 strong = sa<=thresha .and. sb<=threshb
                 if( .not.strong )go to 70
              end if
              ! if the swap is accepted ("weakly" and "strongly"), apply the
              ! transformations and set n1-by-n2 (2,1)-block to zero.
              call stdlib_${ri}$laset( 'FULL', n1, n2, zero, zero, s(n2+1,1), ldst )
              ! copy back m-by-m diagonal block starting at index j1 of (a, b)
              call stdlib_${ri}$lacpy( 'F', m, m, s, ldst, a( j1, j1 ), lda )
              call stdlib_${ri}$lacpy( 'F', m, m, t, ldst, b( j1, j1 ), ldb )
              call stdlib_${ri}$laset( 'FULL', ldst, ldst, zero, zero, t, ldst )
              ! standardize existing 2-by-2 blocks.
              call stdlib_${ri}$laset( 'FULL', m, m, zero, zero, work, m )
              work( 1 ) = one
              t( 1, 1 ) = one
              idum = lwork - m*m - 2
              if( n2>1 ) then
                 call stdlib_${ri}$lagv2( a( j1, j1 ), lda, b( j1, j1 ), ldb, ar, ai, be,work( 1 ), &
                           work( 2 ), t( 1, 1 ), t( 2, 1 ) )
                 work( m+1 ) = -work( 2 )
                 work( m+2 ) = work( 1 )
                 t( n2, n2 ) = t( 1, 1 )
                 t( 1, 2 ) = -t( 2, 1 )
              end if
              work( m*m ) = one
              t( m, m ) = one
              if( n1>1 ) then
                 call stdlib_${ri}$lagv2( a( j1+n2, j1+n2 ), lda, b( j1+n2, j1+n2 ), ldb,taur, taul, &
                 work( m*m+1 ), work( n2*m+n2+1 ),work( n2*m+n2+2 ), t( n2+1, n2+1 ),t( m, m-1 ) )
                           
                 work( m*m ) = work( n2*m+n2+1 )
                 work( m*m-1 ) = -work( n2*m+n2+2 )
                 t( m, m ) = t( n2+1, n2+1 )
                 t( m-1, m ) = -t( m, m-1 )
              end if
              call stdlib_${ri}$gemm( 'T', 'N', n2, n1, n2, one, work, m, a( j1, j1+n2 ),lda, zero, &
                        work( m*m+1 ), n2 )
              call stdlib_${ri}$lacpy( 'FULL', n2, n1, work( m*m+1 ), n2, a( j1, j1+n2 ),lda )
              call stdlib_${ri}$gemm( 'T', 'N', n2, n1, n2, one, work, m, b( j1, j1+n2 ),ldb, zero, &
                        work( m*m+1 ), n2 )
              call stdlib_${ri}$lacpy( 'FULL', n2, n1, work( m*m+1 ), n2, b( j1, j1+n2 ),ldb )
              call stdlib_${ri}$gemm( 'N', 'N', m, m, m, one, li, ldst, work, m, zero,work( m*m+1 ), m &
                        )
              call stdlib_${ri}$lacpy( 'FULL', m, m, work( m*m+1 ), m, li, ldst )
              call stdlib_${ri}$gemm( 'N', 'N', n2, n1, n1, one, a( j1, j1+n2 ), lda,t( n2+1, n2+1 ), &
                        ldst, zero, work, n2 )
              call stdlib_${ri}$lacpy( 'FULL', n2, n1, work, n2, a( j1, j1+n2 ), lda )
              call stdlib_${ri}$gemm( 'N', 'N', n2, n1, n1, one, b( j1, j1+n2 ), ldb,t( n2+1, n2+1 ), &
                        ldst, zero, work, n2 )
              call stdlib_${ri}$lacpy( 'FULL', n2, n1, work, n2, b( j1, j1+n2 ), ldb )
              call stdlib_${ri}$gemm( 'T', 'N', m, m, m, one, ir, ldst, t, ldst, zero,work, m )
              call stdlib_${ri}$lacpy( 'FULL', m, m, work, m, ir, ldst )
              ! accumulate transformations into q and z if requested.
              if( wantq ) then
                 call stdlib_${ri}$gemm( 'N', 'N', n, m, m, one, q( 1, j1 ), ldq, li,ldst, zero, work, &
                           n )
                 call stdlib_${ri}$lacpy( 'FULL', n, m, work, n, q( 1, j1 ), ldq )
              end if
              if( wantz ) then
                 call stdlib_${ri}$gemm( 'N', 'N', n, m, m, one, z( 1, j1 ), ldz, ir,ldst, zero, work, &
                           n )
                 call stdlib_${ri}$lacpy( 'FULL', n, m, work, n, z( 1, j1 ), ldz )
              end if
              ! update (a(j1:j1+m-1, m+j1:n), b(j1:j1+m-1, m+j1:n)) and
                      ! (a(1:j1-1, j1:j1+m), b(1:j1-1, j1:j1+m)).
              i = j1 + m
              if( i<=n ) then
                 call stdlib_${ri}$gemm( 'T', 'N', m, n-i+1, m, one, li, ldst,a( j1, i ), lda, zero, &
                           work, m )
                 call stdlib_${ri}$lacpy( 'FULL', m, n-i+1, work, m, a( j1, i ), lda )
                 call stdlib_${ri}$gemm( 'T', 'N', m, n-i+1, m, one, li, ldst,b( j1, i ), ldb, zero, &
                           work, m )
                 call stdlib_${ri}$lacpy( 'FULL', m, n-i+1, work, m, b( j1, i ), ldb )
              end if
              i = j1 - 1
              if( i>0 ) then
                 call stdlib_${ri}$gemm( 'N', 'N', i, m, m, one, a( 1, j1 ), lda, ir,ldst, zero, work, &
                           i )
                 call stdlib_${ri}$lacpy( 'FULL', i, m, work, i, a( 1, j1 ), lda )
                 call stdlib_${ri}$gemm( 'N', 'N', i, m, m, one, b( 1, j1 ), ldb, ir,ldst, zero, work, &
                           i )
                 call stdlib_${ri}$lacpy( 'FULL', i, m, work, i, b( 1, j1 ), ldb )
              end if
              ! exit with info = 0 if swap was successfully performed.
              return
           end if
           ! exit with info = 1 if swap was rejected.
           70 continue
           info = 1
           return
     end subroutine stdlib_${ri}$tgex2

#:endif
#:endfor

     module pure subroutine stdlib_ctgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, info )
     !! CTGEX2 swaps adjacent diagonal 1 by 1 blocks (A11,B11) and (A22,B22)
     !! in an upper triangular matrix pair (A, B) by an unitary equivalence
     !! transformation.
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
     !! Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: j1, lda, ldb, ldq, ldz, n
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: twenty = 2.0e+1_sp
           integer(ilp), parameter :: ldst = 2
           logical(lk), parameter :: wands = .true.
           
           
           
           
           ! Local Scalars 
           logical(lk) :: strong, weak
           integer(ilp) :: i, m
           real(sp) :: cq, cz, eps, sa, sb, scale, smlnum, sum, thresha, threshb
           complex(sp) :: cdum, f, g, sq, sz
           ! Local Arrays 
           complex(sp) :: s(ldst,ldst), t(ldst,ldst), work(8)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=1 )return
           m = ldst
           weak = .false.
           strong = .false.
           ! make a local copy of selected block in (a, b)
           call stdlib_clacpy( 'FULL', m, m, a( j1, j1 ), lda, s, ldst )
           call stdlib_clacpy( 'FULL', m, m, b( j1, j1 ), ldb, t, ldst )
           ! compute the threshold for testing the acceptance of swapping.
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           scale = real( czero,KIND=sp)
           sum = real( cone,KIND=sp)
           call stdlib_clacpy( 'FULL', m, m, s, ldst, work, m )
           call stdlib_clacpy( 'FULL', m, m, t, ldst, work( m*m+1 ), m )
           call stdlib_classq( m*m, work, 1, scale, sum )
           sa = scale*sqrt( sum )
           scale = real( czero,KIND=sp)
           sum = real( cone,KIND=sp)
           call stdlib_classq( m*m, work(m*m+1), 1, scale, sum )
           sb = scale*sqrt( sum )
           ! thres has been changed from
              ! thresh = max( ten*eps*sa, smlnum )
           ! to
              ! thresh = max( twenty*eps*sa, smlnum )
           ! on 04/01/10.
           ! "bug" reported by ondra kamenik, confirmed by julie langou, fixed by
           ! jim demmel and guillaume revy. see forum post 1783.
           thresha = max( twenty*eps*sa, smlnum )
           threshb = max( twenty*eps*sb, smlnum )
           ! compute unitary ql and rq that swap 1-by-1 and 1-by-1 blocks
           ! using givens rotations and perform the swap tentatively.
           f = s( 2, 2 )*t( 1, 1 ) - t( 2, 2 )*s( 1, 1 )
           g = s( 2, 2 )*t( 1, 2 ) - t( 2, 2 )*s( 1, 2 )
           sa = abs( s( 2, 2 ) ) * abs( t( 1, 1 ) )
           sb = abs( s( 1, 1 ) ) * abs( t( 2, 2 ) )
           call stdlib_clartg( g, f, cz, sz, cdum )
           sz = -sz
           call stdlib_crot( 2, s( 1, 1 ), 1, s( 1, 2 ), 1, cz, conjg( sz ) )
           call stdlib_crot( 2, t( 1, 1 ), 1, t( 1, 2 ), 1, cz, conjg( sz ) )
           if( sa>=sb ) then
              call stdlib_clartg( s( 1, 1 ), s( 2, 1 ), cq, sq, cdum )
           else
              call stdlib_clartg( t( 1, 1 ), t( 2, 1 ), cq, sq, cdum )
           end if
           call stdlib_crot( 2, s( 1, 1 ), ldst, s( 2, 1 ), ldst, cq, sq )
           call stdlib_crot( 2, t( 1, 1 ), ldst, t( 2, 1 ), ldst, cq, sq )
           ! weak stability test: |s21| <= o(eps f-norm((a)))
                                ! and  |t21| <= o(eps f-norm((b)))
           weak = abs( s( 2, 1 ) )<=thresha .and.abs( t( 2, 1 ) )<=threshb
           if( .not.weak )go to 20
           if( wands ) then
              ! strong stability test:
                 ! f-norm((a-ql**h*s*qr, b-ql**h*t*qr)) <= o(eps*f-norm((a, b)))
              call stdlib_clacpy( 'FULL', m, m, s, ldst, work, m )
              call stdlib_clacpy( 'FULL', m, m, t, ldst, work( m*m+1 ), m )
              call stdlib_crot( 2, work, 1, work( 3 ), 1, cz, -conjg( sz ) )
              call stdlib_crot( 2, work( 5 ), 1, work( 7 ), 1, cz, -conjg( sz ) )
              call stdlib_crot( 2, work, 2, work( 2 ), 2, cq, -sq )
              call stdlib_crot( 2, work( 5 ), 2, work( 6 ), 2, cq, -sq )
              do i = 1, 2
                 work( i ) = work( i ) - a( j1+i-1, j1 )
                 work( i+2 ) = work( i+2 ) - a( j1+i-1, j1+1 )
                 work( i+4 ) = work( i+4 ) - b( j1+i-1, j1 )
                 work( i+6 ) = work( i+6 ) - b( j1+i-1, j1+1 )
              end do
              scale = real( czero,KIND=sp)
              sum = real( cone,KIND=sp)
              call stdlib_classq( m*m, work, 1, scale, sum )
              sa = scale*sqrt( sum )
              scale = real( czero,KIND=sp)
              sum = real( cone,KIND=sp)
              call stdlib_classq( m*m, work(m*m+1), 1, scale, sum )
              sb = scale*sqrt( sum )
              strong = sa<=thresha .and. sb<=threshb
              if( .not.strong )go to 20
           end if
           ! if the swap is accepted ("weakly" and "strongly"), apply the
           ! equivalence transformations to the original matrix pair (a,b)
           call stdlib_crot( j1+1, a( 1, j1 ), 1, a( 1, j1+1 ), 1, cz, conjg( sz ) )
           call stdlib_crot( j1+1, b( 1, j1 ), 1, b( 1, j1+1 ), 1, cz, conjg( sz ) )
           call stdlib_crot( n-j1+1, a( j1, j1 ), lda, a( j1+1, j1 ), lda, cq, sq )
           call stdlib_crot( n-j1+1, b( j1, j1 ), ldb, b( j1+1, j1 ), ldb, cq, sq )
           ! set  n1 by n2 (2,1) blocks to 0
           a( j1+1, j1 ) = czero
           b( j1+1, j1 ) = czero
           ! accumulate transformations into q and z if requested.
           if( wantz )call stdlib_crot( n, z( 1, j1 ), 1, z( 1, j1+1 ), 1, cz, conjg( sz ) )
                     
           if( wantq )call stdlib_crot( n, q( 1, j1 ), 1, q( 1, j1+1 ), 1, cq, conjg( sq ) )
                     
           ! exit with info = 0 if swap was successfully performed.
           return
           ! exit with info = 1 if swap was rejected.
           20 continue
           info = 1
           return
     end subroutine stdlib_ctgex2

     module pure subroutine stdlib_ztgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, info )
     !! ZTGEX2 swaps adjacent diagonal 1 by 1 blocks (A11,B11) and (A22,B22)
     !! in an upper triangular matrix pair (A, B) by an unitary equivalence
     !! transformation.
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
     !! Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: j1, lda, ldb, ldq, ldz, n
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: twenty = 2.0e+1_dp
           integer(ilp), parameter :: ldst = 2
           logical(lk), parameter :: wands = .true.
           
           
           
           
           ! Local Scalars 
           logical(lk) :: strong, weak
           integer(ilp) :: i, m
           real(dp) :: cq, cz, eps, sa, sb, scale, smlnum, sum, thresha, threshb
           complex(dp) :: cdum, f, g, sq, sz
           ! Local Arrays 
           complex(dp) :: s(ldst,ldst), t(ldst,ldst), work(8)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=1 )return
           m = ldst
           weak = .false.
           strong = .false.
           ! make a local copy of selected block in (a, b)
           call stdlib_zlacpy( 'FULL', m, m, a( j1, j1 ), lda, s, ldst )
           call stdlib_zlacpy( 'FULL', m, m, b( j1, j1 ), ldb, t, ldst )
           ! compute the threshold for testing the acceptance of swapping.
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' ) / eps
           scale = real( czero,KIND=dp)
           sum = real( cone,KIND=dp)
           call stdlib_zlacpy( 'FULL', m, m, s, ldst, work, m )
           call stdlib_zlacpy( 'FULL', m, m, t, ldst, work( m*m+1 ), m )
           call stdlib_zlassq( m*m, work, 1, scale, sum )
           sa = scale*sqrt( sum )
           scale = real( czero,KIND=dp)
           sum = real( cone,KIND=dp)
           call stdlib_zlassq( m*m, work(m*m+1), 1, scale, sum )
           sb = scale*sqrt( sum )
           ! thres has been changed from
              ! thresh = max( ten*eps*sa, smlnum )
           ! to
              ! thresh = max( twenty*eps*sa, smlnum )
           ! on 04/01/10.
           ! "bug" reported by ondra kamenik, confirmed by julie langou, fixed by
           ! jim demmel and guillaume revy. see forum post 1783.
           thresha = max( twenty*eps*sa, smlnum )
           threshb = max( twenty*eps*sb, smlnum )
           ! compute unitary ql and rq that swap 1-by-1 and 1-by-1 blocks
           ! using givens rotations and perform the swap tentatively.
           f = s( 2, 2 )*t( 1, 1 ) - t( 2, 2 )*s( 1, 1 )
           g = s( 2, 2 )*t( 1, 2 ) - t( 2, 2 )*s( 1, 2 )
           sa = abs( s( 2, 2 ) ) * abs( t( 1, 1 ) )
           sb = abs( s( 1, 1 ) ) * abs( t( 2, 2 ) )
           call stdlib_zlartg( g, f, cz, sz, cdum )
           sz = -sz
           call stdlib_zrot( 2, s( 1, 1 ), 1, s( 1, 2 ), 1, cz, conjg( sz ) )
           call stdlib_zrot( 2, t( 1, 1 ), 1, t( 1, 2 ), 1, cz, conjg( sz ) )
           if( sa>=sb ) then
              call stdlib_zlartg( s( 1, 1 ), s( 2, 1 ), cq, sq, cdum )
           else
              call stdlib_zlartg( t( 1, 1 ), t( 2, 1 ), cq, sq, cdum )
           end if
           call stdlib_zrot( 2, s( 1, 1 ), ldst, s( 2, 1 ), ldst, cq, sq )
           call stdlib_zrot( 2, t( 1, 1 ), ldst, t( 2, 1 ), ldst, cq, sq )
           ! weak stability test: |s21| <= o(eps f-norm((a)))
                                ! and  |t21| <= o(eps f-norm((b)))
           weak = abs( s( 2, 1 ) )<=thresha .and.abs( t( 2, 1 ) )<=threshb
           if( .not.weak )go to 20
           if( wands ) then
              ! strong stability test:
                 ! f-norm((a-ql**h*s*qr)) <= o(eps*f-norm((a)))
                 ! and
                 ! f-norm((b-ql**h*t*qr)) <= o(eps*f-norm((b)))
              call stdlib_zlacpy( 'FULL', m, m, s, ldst, work, m )
              call stdlib_zlacpy( 'FULL', m, m, t, ldst, work( m*m+1 ), m )
              call stdlib_zrot( 2, work, 1, work( 3 ), 1, cz, -conjg( sz ) )
              call stdlib_zrot( 2, work( 5 ), 1, work( 7 ), 1, cz, -conjg( sz ) )
              call stdlib_zrot( 2, work, 2, work( 2 ), 2, cq, -sq )
              call stdlib_zrot( 2, work( 5 ), 2, work( 6 ), 2, cq, -sq )
              do i = 1, 2
                 work( i ) = work( i ) - a( j1+i-1, j1 )
                 work( i+2 ) = work( i+2 ) - a( j1+i-1, j1+1 )
                 work( i+4 ) = work( i+4 ) - b( j1+i-1, j1 )
                 work( i+6 ) = work( i+6 ) - b( j1+i-1, j1+1 )
              end do
              scale = real( czero,KIND=dp)
              sum = real( cone,KIND=dp)
              call stdlib_zlassq( m*m, work, 1, scale, sum )
              sa = scale*sqrt( sum )
              scale = real( czero,KIND=dp)
              sum = real( cone,KIND=dp)
              call stdlib_zlassq( m*m, work(m*m+1), 1, scale, sum )
              sb = scale*sqrt( sum )
              strong = sa<=thresha .and. sb<=threshb
              if( .not.strong )go to 20
           end if
           ! if the swap is accepted ("weakly" and "strongly"), apply the
           ! equivalence transformations to the original matrix pair (a,b)
           call stdlib_zrot( j1+1, a( 1, j1 ), 1, a( 1, j1+1 ), 1, cz,conjg( sz ) )
           call stdlib_zrot( j1+1, b( 1, j1 ), 1, b( 1, j1+1 ), 1, cz,conjg( sz ) )
           call stdlib_zrot( n-j1+1, a( j1, j1 ), lda, a( j1+1, j1 ), lda, cq, sq )
           call stdlib_zrot( n-j1+1, b( j1, j1 ), ldb, b( j1+1, j1 ), ldb, cq, sq )
           ! set  n1 by n2 (2,1) blocks to 0
           a( j1+1, j1 ) = czero
           b( j1+1, j1 ) = czero
           ! accumulate transformations into q and z if requested.
           if( wantz )call stdlib_zrot( n, z( 1, j1 ), 1, z( 1, j1+1 ), 1, cz,conjg( sz ) )
                     
           if( wantq )call stdlib_zrot( n, q( 1, j1 ), 1, q( 1, j1+1 ), 1, cq,conjg( sq ) )
                     
           ! exit with info = 0 if swap was successfully performed.
           return
           ! exit with info = 1 if swap was rejected.
           20 continue
           info = 1
           return
     end subroutine stdlib_ztgex2

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$tgex2( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, j1, info )
     !! ZTGEX2: swaps adjacent diagonal 1 by 1 blocks (A11,B11) and (A22,B22)
     !! in an upper triangular matrix pair (A, B) by an unitary equivalence
     !! transformation.
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
     !! Optionally, the matrices Q and Z of generalized Schur vectors are
     !! updated.
     !! Q(in) * A(in) * Z(in)**H = Q(out) * A(out) * Z(out)**H
     !! Q(in) * B(in) * Z(in)**H = Q(out) * B(out) * Z(out)**H
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(out) :: info
           integer(ilp), intent(in) :: j1, lda, ldb, ldq, ldz, n
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           ! Parameters 
           real(${ck}$), parameter :: twenty = 2.0e+1_${ck}$
           integer(ilp), parameter :: ldst = 2
           logical(lk), parameter :: wands = .true.
           
           
           
           
           ! Local Scalars 
           logical(lk) :: strong, weak
           integer(ilp) :: i, m
           real(${ck}$) :: cq, cz, eps, sa, sb, scale, smlnum, sum, thresha, threshb
           complex(${ck}$) :: cdum, f, g, sq, sz
           ! Local Arrays 
           complex(${ck}$) :: s(ldst,ldst), t(ldst,ldst), work(8)
           ! Intrinsic Functions 
           ! Executable Statements 
           info = 0
           ! quick return if possible
           if( n<=1 )return
           m = ldst
           weak = .false.
           strong = .false.
           ! make a local copy of selected block in (a, b)
           call stdlib_${ci}$lacpy( 'FULL', m, m, a( j1, j1 ), lda, s, ldst )
           call stdlib_${ci}$lacpy( 'FULL', m, m, b( j1, j1 ), ldb, t, ldst )
           ! compute the threshold for testing the acceptance of swapping.
           eps = stdlib_${c2ri(ci)}$lamch( 'P' )
           smlnum = stdlib_${c2ri(ci)}$lamch( 'S' ) / eps
           scale = real( czero,KIND=${ck}$)
           sum = real( cone,KIND=${ck}$)
           call stdlib_${ci}$lacpy( 'FULL', m, m, s, ldst, work, m )
           call stdlib_${ci}$lacpy( 'FULL', m, m, t, ldst, work( m*m+1 ), m )
           call stdlib_${ci}$lassq( m*m, work, 1, scale, sum )
           sa = scale*sqrt( sum )
           scale = real( czero,KIND=${ck}$)
           sum = real( cone,KIND=${ck}$)
           call stdlib_${ci}$lassq( m*m, work(m*m+1), 1, scale, sum )
           sb = scale*sqrt( sum )
           ! thres has been changed from
              ! thresh = max( ten*eps*sa, smlnum )
           ! to
              ! thresh = max( twenty*eps*sa, smlnum )
           ! on 04/01/10.
           ! "bug" reported by ondra kamenik, confirmed by julie langou, fixed by
           ! jim demmel and guillaume revy. see forum post 1783.
           thresha = max( twenty*eps*sa, smlnum )
           threshb = max( twenty*eps*sb, smlnum )
           ! compute unitary ql and rq that swap 1-by-1 and 1-by-1 blocks
           ! using givens rotations and perform the swap tentatively.
           f = s( 2, 2 )*t( 1, 1 ) - t( 2, 2 )*s( 1, 1 )
           g = s( 2, 2 )*t( 1, 2 ) - t( 2, 2 )*s( 1, 2 )
           sa = abs( s( 2, 2 ) ) * abs( t( 1, 1 ) )
           sb = abs( s( 1, 1 ) ) * abs( t( 2, 2 ) )
           call stdlib_${ci}$lartg( g, f, cz, sz, cdum )
           sz = -sz
           call stdlib_${ci}$rot( 2, s( 1, 1 ), 1, s( 1, 2 ), 1, cz, conjg( sz ) )
           call stdlib_${ci}$rot( 2, t( 1, 1 ), 1, t( 1, 2 ), 1, cz, conjg( sz ) )
           if( sa>=sb ) then
              call stdlib_${ci}$lartg( s( 1, 1 ), s( 2, 1 ), cq, sq, cdum )
           else
              call stdlib_${ci}$lartg( t( 1, 1 ), t( 2, 1 ), cq, sq, cdum )
           end if
           call stdlib_${ci}$rot( 2, s( 1, 1 ), ldst, s( 2, 1 ), ldst, cq, sq )
           call stdlib_${ci}$rot( 2, t( 1, 1 ), ldst, t( 2, 1 ), ldst, cq, sq )
           ! weak stability test: |s21| <= o(eps f-norm((a)))
                                ! and  |t21| <= o(eps f-norm((b)))
           weak = abs( s( 2, 1 ) )<=thresha .and.abs( t( 2, 1 ) )<=threshb
           if( .not.weak )go to 20
           if( wands ) then
              ! strong stability test:
                 ! f-norm((a-ql**h*s*qr)) <= o(eps*f-norm((a)))
                 ! and
                 ! f-norm((b-ql**h*t*qr)) <= o(eps*f-norm((b)))
              call stdlib_${ci}$lacpy( 'FULL', m, m, s, ldst, work, m )
              call stdlib_${ci}$lacpy( 'FULL', m, m, t, ldst, work( m*m+1 ), m )
              call stdlib_${ci}$rot( 2, work, 1, work( 3 ), 1, cz, -conjg( sz ) )
              call stdlib_${ci}$rot( 2, work( 5 ), 1, work( 7 ), 1, cz, -conjg( sz ) )
              call stdlib_${ci}$rot( 2, work, 2, work( 2 ), 2, cq, -sq )
              call stdlib_${ci}$rot( 2, work( 5 ), 2, work( 6 ), 2, cq, -sq )
              do i = 1, 2
                 work( i ) = work( i ) - a( j1+i-1, j1 )
                 work( i+2 ) = work( i+2 ) - a( j1+i-1, j1+1 )
                 work( i+4 ) = work( i+4 ) - b( j1+i-1, j1 )
                 work( i+6 ) = work( i+6 ) - b( j1+i-1, j1+1 )
              end do
              scale = real( czero,KIND=${ck}$)
              sum = real( cone,KIND=${ck}$)
              call stdlib_${ci}$lassq( m*m, work, 1, scale, sum )
              sa = scale*sqrt( sum )
              scale = real( czero,KIND=${ck}$)
              sum = real( cone,KIND=${ck}$)
              call stdlib_${ci}$lassq( m*m, work(m*m+1), 1, scale, sum )
              sb = scale*sqrt( sum )
              strong = sa<=thresha .and. sb<=threshb
              if( .not.strong )go to 20
           end if
           ! if the swap is accepted ("weakly" and "strongly"), apply the
           ! equivalence transformations to the original matrix pair (a,b)
           call stdlib_${ci}$rot( j1+1, a( 1, j1 ), 1, a( 1, j1+1 ), 1, cz,conjg( sz ) )
           call stdlib_${ci}$rot( j1+1, b( 1, j1 ), 1, b( 1, j1+1 ), 1, cz,conjg( sz ) )
           call stdlib_${ci}$rot( n-j1+1, a( j1, j1 ), lda, a( j1+1, j1 ), lda, cq, sq )
           call stdlib_${ci}$rot( n-j1+1, b( j1, j1 ), ldb, b( j1+1, j1 ), ldb, cq, sq )
           ! set  n1 by n2 (2,1) blocks to 0
           a( j1+1, j1 ) = czero
           b( j1+1, j1 ) = czero
           ! accumulate transformations into q and z if requested.
           if( wantz )call stdlib_${ci}$rot( n, z( 1, j1 ), 1, z( 1, j1+1 ), 1, cz,conjg( sz ) )
                     
           if( wantq )call stdlib_${ci}$rot( n, q( 1, j1 ), 1, q( 1, j1+1 ), 1, cq,conjg( sq ) )
                     
           ! exit with info = 0 if swap was successfully performed.
           return
           ! exit with info = 1 if swap was rejected.
           20 continue
           info = 1
           return
     end subroutine stdlib_${ci}$tgex2

#:endif
#:endfor



     module pure subroutine stdlib_stgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
     !! STGEVC computes some or all of the right and/or left eigenvectors of
     !! a pair of real matrices (S,P), where S is a quasi-triangular matrix
     !! and P is upper triangular.  Matrix pairs of this type are produced by
     !! the generalized Schur factorization of a matrix pair (A,B):
     !! A = Q*S*Z**T,  B = Q*P*Z**T
     !! as computed by SGGHRD + SHGEQZ.
     !! The right eigenvector x and the left eigenvector y of (S,P)
     !! corresponding to an eigenvalue w are defined by:
     !! S*x = w*P*x,  (y**H)*S = w*(y**H)*P,
     !! where y**H denotes the conjugate tranpose of y.
     !! The eigenvalues are not input to this routine, but are computed
     !! directly from the diagonal blocks of S and P.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of (S,P), or the products Z*X and/or Q*Y,
     !! where Z and Q are input matrices.
     !! If Q and Z are the orthogonal factors from the generalized Schur
     !! factorization of a matrix pair (A,B), then Z*X and Q*Y
     !! are the matrices of right and left eigenvectors of (A,B).
               mm, m, work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(sp), intent(in) :: p(ldp,*), s(lds,*)
           real(sp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           real(sp), parameter :: safety = 1.0e+2_sp
           
           ! Local Scalars 
           logical(lk) :: compl, compr, il2by2, ilabad, ilall, ilback, ilbbad, ilcomp, ilcplx, &
                     lsa, lsb
           integer(ilp) :: i, ibeg, ieig, iend, ihwmny, iinfo, im, iside, j, ja, jc, je, jr, jw, &
                     na, nw
           real(sp) :: acoef, acoefa, anorm, ascale, bcoefa, bcoefi, bcoefr, big, bignum, bnorm, &
           bscale, cim2a, cim2b, cimaga, cimagb, cre2a, cre2b, creala, crealb, dmin, safmin, &
                     salfar, sbeta, scale, small, temp, temp2, temp2i, temp2r, ulp, xmax, xscale
           ! Local Arrays 
           real(sp) :: bdiag(2), sum(2,2), sums(2,2), sump(2,2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           if( stdlib_lsame( howmny, 'A' ) ) then
              ihwmny = 1
              ilall = .true.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'S' ) ) then
              ihwmny = 2
              ilall = .false.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'B' ) ) then
              ihwmny = 3
              ilall = .true.
              ilback = .true.
           else
              ihwmny = -1
              ilall = .true.
           end if
           if( stdlib_lsame( side, 'R' ) ) then
              iside = 1
              compl = .false.
              compr = .true.
           else if( stdlib_lsame( side, 'L' ) ) then
              iside = 2
              compl = .true.
              compr = .false.
           else if( stdlib_lsame( side, 'B' ) ) then
              iside = 3
              compl = .true.
              compr = .true.
           else
              iside = -1
           end if
           info = 0
           if( iside<0 ) then
              info = -1
           else if( ihwmny<0 ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lds<max( 1, n ) ) then
              info = -6
           else if( ldp<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STGEVC', -info )
              return
           end if
           ! count the number of eigenvectors to be computed
           if( .not.ilall ) then
              im = 0
              ilcplx = .false.
              loop_10: do j = 1, n
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_10
                 end if
                 if( j<n ) then
                    if( s( j+1, j )/=zero )ilcplx = .true.
                 end if
                 if( ilcplx ) then
                    if( select( j ) .or. select( j+1 ) )im = im + 2
                 else
                    if( select( j ) )im = im + 1
                 end if
              end do loop_10
           else
              im = n
           end if
           ! check 2-by-2 diagonal blocks of a, b
           ilabad = .false.
           ilbbad = .false.
           do j = 1, n - 1
              if( s( j+1, j )/=zero ) then
                 if( p( j, j )==zero .or. p( j+1, j+1 )==zero .or.p( j, j+1 )/=zero )ilbbad = &
                           .true.
                 if( j<n-1 ) then
                    if( s( j+2, j+1 )/=zero )ilabad = .true.
                 end if
              end if
           end do
           if( ilabad ) then
              info = -5
           else if( ilbbad ) then
              info = -7
           else if( compl .and. ldvl<n .or. ldvl<1 ) then
              info = -10
           else if( compr .and. ldvr<n .or. ldvr<1 ) then
              info = -12
           else if( mm<im ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STGEVC', -info )
              return
           end if
           ! quick return if possible
           m = im
           if( n==0 )return
           ! machine constants
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           big = one / safmin
           call stdlib_slabad( safmin, big )
           ulp = stdlib_slamch( 'EPSILON' )*stdlib_slamch( 'BASE' )
           small = safmin*n / ulp
           big = one / small
           bignum = one / ( safmin*n )
           ! compute the 1-norm of each column of the strictly upper triangular
           ! part (i.e., excluding all elements belonging to the diagonal
           ! blocks) of a and b to check for possible overflow in the
           ! triangular solver.
           anorm = abs( s( 1, 1 ) )
           if( n>1 )anorm = anorm + abs( s( 2, 1 ) )
           bnorm = abs( p( 1, 1 ) )
           work( 1 ) = zero
           work( n+1 ) = zero
           do j = 2, n
              temp = zero
              temp2 = zero
              if( s( j, j-1 )==zero ) then
                 iend = j - 1
              else
                 iend = j - 2
              end if
              do i = 1, iend
                 temp = temp + abs( s( i, j ) )
                 temp2 = temp2 + abs( p( i, j ) )
              end do
              work( j ) = temp
              work( n+j ) = temp2
              do i = iend + 1, min( j+1, n )
                 temp = temp + abs( s( i, j ) )
                 temp2 = temp2 + abs( p( i, j ) )
              end do
              anorm = max( anorm, temp )
              bnorm = max( bnorm, temp2 )
           end do
           ascale = one / max( anorm, safmin )
           bscale = one / max( bnorm, safmin )
           ! left eigenvectors
           if( compl ) then
              ieig = 0
              ! main loop over eigenvalues
              ilcplx = .false.
              loop_220: do je = 1, n
                 ! skip this iteration if (a) howmny='s' and select=.false., or
                 ! (b) this would be the second of a complex pair.
                 ! check for complex eigenvalue, so as to be sure of which
                 ! entry(-ies) of select to look at.
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_220
                 end if
                 nw = 1
                 if( je<n ) then
                    if( s( je+1, je )/=zero ) then
                       ilcplx = .true.
                       nw = 2
                    end if
                 end if
                 if( ilall ) then
                    ilcomp = .true.
                 else if( ilcplx ) then
                    ilcomp = select( je ) .or. select( je+1 )
                 else
                    ilcomp = select( je )
                 end if
                 if( .not.ilcomp )cycle loop_220
                 ! decide if (a) singular pencil, (b) real eigenvalue, or
                 ! (c) complex eigenvalue.
                 if( .not.ilcplx ) then
                    if( abs( s( je, je ) )<=safmin .and.abs( p( je, je ) )<=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       ieig = ieig + 1
                       do jr = 1, n
                          vl( jr, ieig ) = zero
                       end do
                       vl( ieig, ieig ) = one
                       cycle loop_220
                    end if
                 end if
                 ! clear vector
                 do jr = 1, nw*n
                    work( 2*n+jr ) = zero
                 end do
                                                       ! t
                 ! compute coefficients in  ( a a - b b )  y = 0
                    ! a  is  acoef
                    ! b  is  bcoefr + i*bcoefi
                 if( .not.ilcplx ) then
                    ! real eigenvalue
                    temp = one / max( abs( s( je, je ) )*ascale,abs( p( je, je ) )*bscale, safmin &
                              )
                    salfar = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*p( je, je ) )*bscale
                    acoef = sbeta*ascale
                    bcoefr = salfar*bscale
                    bcoefi = zero
                    ! scale to avoid underflow
                    scale = one
                    lsa = abs( sbeta )>=safmin .and. abs( acoef )<small
                    lsb = abs( salfar )>=safmin .and. abs( bcoefr )<small
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs( salfar ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoef ),abs( bcoefr ) ) ) &
                                 )
                       if( lsa ) then
                          acoef = ascale*( scale*sbeta )
                       else
                          acoef = scale*acoef
                       end if
                       if( lsb ) then
                          bcoefr = bscale*( scale*salfar )
                       else
                          bcoefr = scale*bcoefr
                       end if
                    end if
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr )
                    ! first component is 1
                    work( 2*n+je ) = one
                    xmax = one
                 else
                    ! complex eigenvalue
                    call stdlib_slag2( s( je, je ), lds, p( je, je ), ldp,safmin*safety, acoef, &
                              temp, bcoefr, temp2,bcoefi )
                    bcoefi = -bcoefi
                    if( bcoefi==zero ) then
                       info = je
                       return
                    end if
                    ! scale to avoid over/underflow
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr ) + abs( bcoefi )
                    scale = one
                    if( acoefa*ulp<safmin .and. acoefa>=safmin )scale = ( safmin / ulp ) / &
                              acoefa
                    if( bcoefa*ulp<safmin .and. bcoefa>=safmin )scale = max( scale, ( safmin / &
                              ulp ) / bcoefa )
                    if( safmin*acoefa>ascale )scale = ascale / ( safmin*acoefa )
                    if( safmin*bcoefa>bscale )scale = min( scale, bscale / ( safmin*bcoefa ) )
                              
                    if( scale/=one ) then
                       acoef = scale*acoef
                       acoefa = abs( acoef )
                       bcoefr = scale*bcoefr
                       bcoefi = scale*bcoefi
                       bcoefa = abs( bcoefr ) + abs( bcoefi )
                    end if
                    ! compute first two components of eigenvector
                    temp = acoef*s( je+1, je )
                    temp2r = acoef*s( je, je ) - bcoefr*p( je, je )
                    temp2i = -bcoefi*p( je, je )
                    if( abs( temp )>abs( temp2r )+abs( temp2i ) ) then
                       work( 2*n+je ) = one
                       work( 3*n+je ) = zero
                       work( 2*n+je+1 ) = -temp2r / temp
                       work( 3*n+je+1 ) = -temp2i / temp
                    else
                       work( 2*n+je+1 ) = one
                       work( 3*n+je+1 ) = zero
                       temp = acoef*s( je, je+1 )
                       work( 2*n+je ) = ( bcoefr*p( je+1, je+1 )-acoef*s( je+1, je+1 ) ) / &
                                 temp
                       work( 3*n+je ) = bcoefi*p( je+1, je+1 ) / temp
                    end if
                    xmax = max( abs( work( 2*n+je ) )+abs( work( 3*n+je ) ),abs( work( 2*n+je+1 ) &
                              )+abs( work( 3*n+je+1 ) ) )
                 end if
                 dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                                                 ! t
                 ! triangular solve of  (a a - b b)  y = 0
                                         ! t
                 ! (rowwise in  (a a - b b) , or columnwise in (a a - b b) )
                 il2by2 = .false.
                 loop_160: do j = je + nw, n
                    if( il2by2 ) then
                       il2by2 = .false.
                       cycle loop_160
                    end if
                    na = 1
                    bdiag( 1 ) = p( j, j )
                    if( j<n ) then
                       if( s( j+1, j )/=zero ) then
                          il2by2 = .true.
                          bdiag( 2 ) = p( j+1, j+1 )
                          na = 2
                       end if
                    end if
                    ! check whether scaling is necessary for dot products
                    xscale = one / max( one, xmax )
                    temp = max( work( j ), work( n+j ),acoefa*work( j )+bcoefa*work( n+j ) )
                              
                    if( il2by2 )temp = max( temp, work( j+1 ), work( n+j+1 ),acoefa*work( j+1 )+&
                              bcoefa*work( n+j+1 ) )
                    if( temp>bignum*xscale ) then
                       do jw = 0, nw - 1
                          do jr = je, j - 1
                             work( ( jw+2 )*n+jr ) = xscale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                       xmax = xmax*xscale
                    end if
                    ! compute dot products
                          ! j-1
                    ! sum = sum  conjg( a*s(k,j) - b*p(k,j) )*x(k)
                          ! k=je
                    ! to reduce the op count, this is done as
                    ! _        j-1                  _        j-1
                    ! a*conjg( sum  s(k,j)*x(k) ) - b*conjg( sum  p(k,j)*x(k) )
                             ! k=je                          k=je
                    ! which may cause underflow problems if a or b are close
                    ! to underflow.  (e.g., less than small.)
                    do jw = 1, nw
                       do ja = 1, na
                          sums( ja, jw ) = zero
                          sump( ja, jw ) = zero
                          do jr = je, j - 1
                             sums( ja, jw ) = sums( ja, jw ) +s( jr, j+ja-1 )*work( ( jw+1 )*n+jr &
                                       )
                             sump( ja, jw ) = sump( ja, jw ) +p( jr, j+ja-1 )*work( ( jw+1 )*n+jr &
                                       )
                          end do
                       end do
                    end do
                    do ja = 1, na
                       if( ilcplx ) then
                          sum( ja, 1 ) = -acoef*sums( ja, 1 ) +bcoefr*sump( ja, 1 ) -bcoefi*sump( &
                                    ja, 2 )
                          sum( ja, 2 ) = -acoef*sums( ja, 2 ) +bcoefr*sump( ja, 2 ) +bcoefi*sump( &
                                    ja, 1 )
                       else
                          sum( ja, 1 ) = -acoef*sums( ja, 1 ) +bcoefr*sump( ja, 1 )
                       end if
                    end do
                                        ! t
                    ! solve  ( a a - b b )  y = sum(,)
                    ! with scaling and perturbation of the denominator
                    call stdlib_slaln2( .true., na, nw, dmin, acoef, s( j, j ), lds,bdiag( 1 ), &
                    bdiag( 2 ), sum, 2, bcoefr,bcoefi, work( 2*n+j ), n, scale, temp,iinfo )
                              
                    if( scale<one ) then
                       do jw = 0, nw - 1
                          do jr = je, j - 1
                             work( ( jw+2 )*n+jr ) = scale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                       xmax = scale*xmax
                    end if
                    xmax = max( xmax, temp )
                 end do loop_160
                 ! copy eigenvector to vl, back transforming if
                 ! howmny='b'.
                 ieig = ieig + 1
                 if( ilback ) then
                    do jw = 0, nw - 1
                       call stdlib_sgemv( 'N', n, n+1-je, one, vl( 1, je ), ldvl,work( ( jw+2 )*n+&
                                 je ), 1, zero,work( ( jw+4 )*n+1 ), 1 )
                    end do
                    call stdlib_slacpy( ' ', n, nw, work( 4*n+1 ), n, vl( 1, je ),ldvl )
                    ibeg = 1
                 else
                    call stdlib_slacpy( ' ', n, nw, work( 2*n+1 ), n, vl( 1, ieig ),ldvl )
                    ibeg = je
                 end if
                 ! scale eigenvector
                 xmax = zero
                 if( ilcplx ) then
                    do j = ibeg, n
                       xmax = max( xmax, abs( vl( j, ieig ) )+abs( vl( j, ieig+1 ) ) )
                    end do
                 else
                    do j = ibeg, n
                       xmax = max( xmax, abs( vl( j, ieig ) ) )
                    end do
                 end if
                 if( xmax>safmin ) then
                    xscale = one / xmax
                    do jw = 0, nw - 1
                       do jr = ibeg, n
                          vl( jr, ieig+jw ) = xscale*vl( jr, ieig+jw )
                       end do
                    end do
                 end if
                 ieig = ieig + nw - 1
              end do loop_220
           end if
           ! right eigenvectors
           if( compr ) then
              ieig = im + 1
              ! main loop over eigenvalues
              ilcplx = .false.
              loop_500: do je = n, 1, -1
                 ! skip this iteration if (a) howmny='s' and select=.false., or
                 ! (b) this would be the second of a complex pair.
                 ! check for complex eigenvalue, so as to be sure of which
                 ! entry(-ies) of select to look at -- if complex, select(je)
                 ! or select(je-1).
                 ! if this is a complex pair, the 2-by-2 diagonal block
                 ! corresponding to the eigenvalue is in rows/columns je-1:je
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_500
                 end if
                 nw = 1
                 if( je>1 ) then
                    if( s( je, je-1 )/=zero ) then
                       ilcplx = .true.
                       nw = 2
                    end if
                 end if
                 if( ilall ) then
                    ilcomp = .true.
                 else if( ilcplx ) then
                    ilcomp = select( je ) .or. select( je-1 )
                 else
                    ilcomp = select( je )
                 end if
                 if( .not.ilcomp )cycle loop_500
                 ! decide if (a) singular pencil, (b) real eigenvalue, or
                 ! (c) complex eigenvalue.
                 if( .not.ilcplx ) then
                    if( abs( s( je, je ) )<=safmin .and.abs( p( je, je ) )<=safmin ) then
                       ! singular matrix pencil -- unit eigenvector
                       ieig = ieig - 1
                       do jr = 1, n
                          vr( jr, ieig ) = zero
                       end do
                       vr( ieig, ieig ) = one
                       cycle loop_500
                    end if
                 end if
                 ! clear vector
                 do jw = 0, nw - 1
                    do jr = 1, n
                       work( ( jw+2 )*n+jr ) = zero
                    end do
                 end do
                 ! compute coefficients in  ( a a - b b ) x = 0
                    ! a  is  acoef
                    ! b  is  bcoefr + i*bcoefi
                 if( .not.ilcplx ) then
                    ! real eigenvalue
                    temp = one / max( abs( s( je, je ) )*ascale,abs( p( je, je ) )*bscale, safmin &
                              )
                    salfar = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*p( je, je ) )*bscale
                    acoef = sbeta*ascale
                    bcoefr = salfar*bscale
                    bcoefi = zero
                    ! scale to avoid underflow
                    scale = one
                    lsa = abs( sbeta )>=safmin .and. abs( acoef )<small
                    lsb = abs( salfar )>=safmin .and. abs( bcoefr )<small
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs( salfar ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoef ),abs( bcoefr ) ) ) &
                                 )
                       if( lsa ) then
                          acoef = ascale*( scale*sbeta )
                       else
                          acoef = scale*acoef
                       end if
                       if( lsb ) then
                          bcoefr = bscale*( scale*salfar )
                       else
                          bcoefr = scale*bcoefr
                       end if
                    end if
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr )
                    ! first component is 1
                    work( 2*n+je ) = one
                    xmax = one
                    ! compute contribution from column je of a and b to sum
                    ! (see "further details", above.)
                    do jr = 1, je - 1
                       work( 2*n+jr ) = bcoefr*p( jr, je ) -acoef*s( jr, je )
                    end do
                 else
                    ! complex eigenvalue
                    call stdlib_slag2( s( je-1, je-1 ), lds, p( je-1, je-1 ), ldp,safmin*safety, &
                              acoef, temp, bcoefr, temp2,bcoefi )
                    if( bcoefi==zero ) then
                       info = je - 1
                       return
                    end if
                    ! scale to avoid over/underflow
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr ) + abs( bcoefi )
                    scale = one
                    if( acoefa*ulp<safmin .and. acoefa>=safmin )scale = ( safmin / ulp ) / &
                              acoefa
                    if( bcoefa*ulp<safmin .and. bcoefa>=safmin )scale = max( scale, ( safmin / &
                              ulp ) / bcoefa )
                    if( safmin*acoefa>ascale )scale = ascale / ( safmin*acoefa )
                    if( safmin*bcoefa>bscale )scale = min( scale, bscale / ( safmin*bcoefa ) )
                              
                    if( scale/=one ) then
                       acoef = scale*acoef
                       acoefa = abs( acoef )
                       bcoefr = scale*bcoefr
                       bcoefi = scale*bcoefi
                       bcoefa = abs( bcoefr ) + abs( bcoefi )
                    end if
                    ! compute first two components of eigenvector
                    ! and contribution to sums
                    temp = acoef*s( je, je-1 )
                    temp2r = acoef*s( je, je ) - bcoefr*p( je, je )
                    temp2i = -bcoefi*p( je, je )
                    if( abs( temp )>=abs( temp2r )+abs( temp2i ) ) then
                       work( 2*n+je ) = one
                       work( 3*n+je ) = zero
                       work( 2*n+je-1 ) = -temp2r / temp
                       work( 3*n+je-1 ) = -temp2i / temp
                    else
                       work( 2*n+je-1 ) = one
                       work( 3*n+je-1 ) = zero
                       temp = acoef*s( je-1, je )
                       work( 2*n+je ) = ( bcoefr*p( je-1, je-1 )-acoef*s( je-1, je-1 ) ) / &
                                 temp
                       work( 3*n+je ) = bcoefi*p( je-1, je-1 ) / temp
                    end if
                    xmax = max( abs( work( 2*n+je ) )+abs( work( 3*n+je ) ),abs( work( 2*n+je-1 ) &
                              )+abs( work( 3*n+je-1 ) ) )
                    ! compute contribution from columns je and je-1
                    ! of a and b to the sums.
                    creala = acoef*work( 2*n+je-1 )
                    cimaga = acoef*work( 3*n+je-1 )
                    crealb = bcoefr*work( 2*n+je-1 ) -bcoefi*work( 3*n+je-1 )
                    cimagb = bcoefi*work( 2*n+je-1 ) +bcoefr*work( 3*n+je-1 )
                    cre2a = acoef*work( 2*n+je )
                    cim2a = acoef*work( 3*n+je )
                    cre2b = bcoefr*work( 2*n+je ) - bcoefi*work( 3*n+je )
                    cim2b = bcoefi*work( 2*n+je ) + bcoefr*work( 3*n+je )
                    do jr = 1, je - 2
                       work( 2*n+jr ) = -creala*s( jr, je-1 ) +crealb*p( jr, je-1 ) -cre2a*s( jr, &
                                 je ) + cre2b*p( jr, je )
                       work( 3*n+jr ) = -cimaga*s( jr, je-1 ) +cimagb*p( jr, je-1 ) -cim2a*s( jr, &
                                 je ) + cim2b*p( jr, je )
                    end do
                 end if
                 dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                 ! columnwise triangular solve of  (a a - b b)  x = 0
                 il2by2 = .false.
                 loop_370: do j = je - nw, 1, -1
                    ! if a 2-by-2 block, is in position j-1:j, wait until
                    ! next iteration to process it (when it will be j:j+1)
                    if( .not.il2by2 .and. j>1 ) then
                       if( s( j, j-1 )/=zero ) then
                          il2by2 = .true.
                          cycle loop_370
                       end if
                    end if
                    bdiag( 1 ) = p( j, j )
                    if( il2by2 ) then
                       na = 2
                       bdiag( 2 ) = p( j+1, j+1 )
                    else
                       na = 1
                    end if
                    ! compute x(j) (and x(j+1), if 2-by-2 block)
                    call stdlib_slaln2( .false., na, nw, dmin, acoef, s( j, j ),lds, bdiag( 1 ), &
                    bdiag( 2 ), work( 2*n+j ),n, bcoefr, bcoefi, sum, 2, scale, temp,iinfo )
                              
                    if( scale<one ) then
                       do jw = 0, nw - 1
                          do jr = 1, je
                             work( ( jw+2 )*n+jr ) = scale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                    end if
                    xmax = max( scale*xmax, temp )
                    do jw = 1, nw
                       do ja = 1, na
                          work( ( jw+1 )*n+j+ja-1 ) = sum( ja, jw )
                       end do
                    end do
                    ! w = w + x(j)*(a s(*,j) - b p(*,j) ) with scaling
                    if( j>1 ) then
                       ! check whether scaling is necessary for sum.
                       xscale = one / max( one, xmax )
                       temp = acoefa*work( j ) + bcoefa*work( n+j )
                       if( il2by2 )temp = max( temp, acoefa*work( j+1 )+bcoefa*work( n+j+1 ) )
                                 
                       temp = max( temp, acoefa, bcoefa )
                       if( temp>bignum*xscale ) then
                          do jw = 0, nw - 1
                             do jr = 1, je
                                work( ( jw+2 )*n+jr ) = xscale*work( ( jw+2 )*n+jr )
                             end do
                          end do
                          xmax = xmax*xscale
                       end if
                       ! compute the contributions of the off-diagonals of
                       ! column j (and j+1, if 2-by-2 block) of a and b to the
                       ! sums.
                       do ja = 1, na
                          if( ilcplx ) then
                             creala = acoef*work( 2*n+j+ja-1 )
                             cimaga = acoef*work( 3*n+j+ja-1 )
                             crealb = bcoefr*work( 2*n+j+ja-1 ) -bcoefi*work( 3*n+j+ja-1 )
                             cimagb = bcoefi*work( 2*n+j+ja-1 ) +bcoefr*work( 3*n+j+ja-1 )
                             do jr = 1, j - 1
                                work( 2*n+jr ) = work( 2*n+jr ) -creala*s( jr, j+ja-1 ) +crealb*p(&
                                           jr, j+ja-1 )
                                work( 3*n+jr ) = work( 3*n+jr ) -cimaga*s( jr, j+ja-1 ) +cimagb*p(&
                                           jr, j+ja-1 )
                             end do
                          else
                             creala = acoef*work( 2*n+j+ja-1 )
                             crealb = bcoefr*work( 2*n+j+ja-1 )
                             do jr = 1, j - 1
                                work( 2*n+jr ) = work( 2*n+jr ) -creala*s( jr, j+ja-1 ) +crealb*p(&
                                           jr, j+ja-1 )
                             end do
                          end if
                       end do
                    end if
                    il2by2 = .false.
                 end do loop_370
                 ! copy eigenvector to vr, back transforming if
                 ! howmny='b'.
                 ieig = ieig - nw
                 if( ilback ) then
                    do jw = 0, nw - 1
                       do jr = 1, n
                          work( ( jw+4 )*n+jr ) = work( ( jw+2 )*n+1 )*vr( jr, 1 )
                       end do
                       ! a series of compiler directives to defeat
                       ! vectorization for the next loop
                       do jc = 2, je
                          do jr = 1, n
                             work( ( jw+4 )*n+jr ) = work( ( jw+4 )*n+jr ) +work( ( jw+2 )*n+jc )&
                                       *vr( jr, jc )
                          end do
                       end do
                    end do
                    do jw = 0, nw - 1
                       do jr = 1, n
                          vr( jr, ieig+jw ) = work( ( jw+4 )*n+jr )
                       end do
                    end do
                    iend = n
                 else
                    do jw = 0, nw - 1
                       do jr = 1, n
                          vr( jr, ieig+jw ) = work( ( jw+2 )*n+jr )
                       end do
                    end do
                    iend = je
                 end if
                 ! scale eigenvector
                 xmax = zero
                 if( ilcplx ) then
                    do j = 1, iend
                       xmax = max( xmax, abs( vr( j, ieig ) )+abs( vr( j, ieig+1 ) ) )
                    end do
                 else
                    do j = 1, iend
                       xmax = max( xmax, abs( vr( j, ieig ) ) )
                    end do
                 end if
                 if( xmax>safmin ) then
                    xscale = one / xmax
                    do jw = 0, nw - 1
                       do jr = 1, iend
                          vr( jr, ieig+jw ) = xscale*vr( jr, ieig+jw )
                       end do
                    end do
                 end if
              end do loop_500
           end if
           return
     end subroutine stdlib_stgevc

     module pure subroutine stdlib_dtgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
     !! DTGEVC computes some or all of the right and/or left eigenvectors of
     !! a pair of real matrices (S,P), where S is a quasi-triangular matrix
     !! and P is upper triangular.  Matrix pairs of this type are produced by
     !! the generalized Schur factorization of a matrix pair (A,B):
     !! A = Q*S*Z**T,  B = Q*P*Z**T
     !! as computed by DGGHRD + DHGEQZ.
     !! The right eigenvector x and the left eigenvector y of (S,P)
     !! corresponding to an eigenvalue w are defined by:
     !! S*x = w*P*x,  (y**H)*S = w*(y**H)*P,
     !! where y**H denotes the conjugate tranpose of y.
     !! The eigenvalues are not input to this routine, but are computed
     !! directly from the diagonal blocks of S and P.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of (S,P), or the products Z*X and/or Q*Y,
     !! where Z and Q are input matrices.
     !! If Q and Z are the orthogonal factors from the generalized Schur
     !! factorization of a matrix pair (A,B), then Z*X and Q*Y
     !! are the matrices of right and left eigenvectors of (A,B).
               mm, m, work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(dp), intent(in) :: p(ldp,*), s(lds,*)
           real(dp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           real(dp), parameter :: safety = 1.0e+2_dp
           
           ! Local Scalars 
           logical(lk) :: compl, compr, il2by2, ilabad, ilall, ilback, ilbbad, ilcomp, ilcplx, &
                     lsa, lsb
           integer(ilp) :: i, ibeg, ieig, iend, ihwmny, iinfo, im, iside, j, ja, jc, je, jr, jw, &
                     na, nw
           real(dp) :: acoef, acoefa, anorm, ascale, bcoefa, bcoefi, bcoefr, big, bignum, bnorm, &
           bscale, cim2a, cim2b, cimaga, cimagb, cre2a, cre2b, creala, crealb, dmin, safmin, &
                     salfar, sbeta, scale, small, temp, temp2, temp2i, temp2r, ulp, xmax, xscale
           ! Local Arrays 
           real(dp) :: bdiag(2), sum(2,2), sums(2,2), sump(2,2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           if( stdlib_lsame( howmny, 'A' ) ) then
              ihwmny = 1
              ilall = .true.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'S' ) ) then
              ihwmny = 2
              ilall = .false.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'B' ) ) then
              ihwmny = 3
              ilall = .true.
              ilback = .true.
           else
              ihwmny = -1
              ilall = .true.
           end if
           if( stdlib_lsame( side, 'R' ) ) then
              iside = 1
              compl = .false.
              compr = .true.
           else if( stdlib_lsame( side, 'L' ) ) then
              iside = 2
              compl = .true.
              compr = .false.
           else if( stdlib_lsame( side, 'B' ) ) then
              iside = 3
              compl = .true.
              compr = .true.
           else
              iside = -1
           end if
           info = 0
           if( iside<0 ) then
              info = -1
           else if( ihwmny<0 ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lds<max( 1, n ) ) then
              info = -6
           else if( ldp<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGEVC', -info )
              return
           end if
           ! count the number of eigenvectors to be computed
           if( .not.ilall ) then
              im = 0
              ilcplx = .false.
              loop_10: do j = 1, n
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_10
                 end if
                 if( j<n ) then
                    if( s( j+1, j )/=zero )ilcplx = .true.
                 end if
                 if( ilcplx ) then
                    if( select( j ) .or. select( j+1 ) )im = im + 2
                 else
                    if( select( j ) )im = im + 1
                 end if
              end do loop_10
           else
              im = n
           end if
           ! check 2-by-2 diagonal blocks of a, b
           ilabad = .false.
           ilbbad = .false.
           do j = 1, n - 1
              if( s( j+1, j )/=zero ) then
                 if( p( j, j )==zero .or. p( j+1, j+1 )==zero .or.p( j, j+1 )/=zero )ilbbad = &
                           .true.
                 if( j<n-1 ) then
                    if( s( j+2, j+1 )/=zero )ilabad = .true.
                 end if
              end if
           end do
           if( ilabad ) then
              info = -5
           else if( ilbbad ) then
              info = -7
           else if( compl .and. ldvl<n .or. ldvl<1 ) then
              info = -10
           else if( compr .and. ldvr<n .or. ldvr<1 ) then
              info = -12
           else if( mm<im ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGEVC', -info )
              return
           end if
           ! quick return if possible
           m = im
           if( n==0 )return
           ! machine constants
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           big = one / safmin
           call stdlib_dlabad( safmin, big )
           ulp = stdlib_dlamch( 'EPSILON' )*stdlib_dlamch( 'BASE' )
           small = safmin*n / ulp
           big = one / small
           bignum = one / ( safmin*n )
           ! compute the 1-norm of each column of the strictly upper triangular
           ! part (i.e., excluding all elements belonging to the diagonal
           ! blocks) of a and b to check for possible overflow in the
           ! triangular solver.
           anorm = abs( s( 1, 1 ) )
           if( n>1 )anorm = anorm + abs( s( 2, 1 ) )
           bnorm = abs( p( 1, 1 ) )
           work( 1 ) = zero
           work( n+1 ) = zero
           do j = 2, n
              temp = zero
              temp2 = zero
              if( s( j, j-1 )==zero ) then
                 iend = j - 1
              else
                 iend = j - 2
              end if
              do i = 1, iend
                 temp = temp + abs( s( i, j ) )
                 temp2 = temp2 + abs( p( i, j ) )
              end do
              work( j ) = temp
              work( n+j ) = temp2
              do i = iend + 1, min( j+1, n )
                 temp = temp + abs( s( i, j ) )
                 temp2 = temp2 + abs( p( i, j ) )
              end do
              anorm = max( anorm, temp )
              bnorm = max( bnorm, temp2 )
           end do
           ascale = one / max( anorm, safmin )
           bscale = one / max( bnorm, safmin )
           ! left eigenvectors
           if( compl ) then
              ieig = 0
              ! main loop over eigenvalues
              ilcplx = .false.
              loop_220: do je = 1, n
                 ! skip this iteration if (a) howmny='s' and select=.false., or
                 ! (b) this would be the second of a complex pair.
                 ! check for complex eigenvalue, so as to be sure of which
                 ! entry(-ies) of select to look at.
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_220
                 end if
                 nw = 1
                 if( je<n ) then
                    if( s( je+1, je )/=zero ) then
                       ilcplx = .true.
                       nw = 2
                    end if
                 end if
                 if( ilall ) then
                    ilcomp = .true.
                 else if( ilcplx ) then
                    ilcomp = select( je ) .or. select( je+1 )
                 else
                    ilcomp = select( je )
                 end if
                 if( .not.ilcomp )cycle loop_220
                 ! decide if (a) singular pencil, (b) real eigenvalue, or
                 ! (c) complex eigenvalue.
                 if( .not.ilcplx ) then
                    if( abs( s( je, je ) )<=safmin .and.abs( p( je, je ) )<=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       ieig = ieig + 1
                       do jr = 1, n
                          vl( jr, ieig ) = zero
                       end do
                       vl( ieig, ieig ) = one
                       cycle loop_220
                    end if
                 end if
                 ! clear vector
                 do jr = 1, nw*n
                    work( 2*n+jr ) = zero
                 end do
                                                       ! t
                 ! compute coefficients in  ( a a - b b )  y = 0
                    ! a  is  acoef
                    ! b  is  bcoefr + i*bcoefi
                 if( .not.ilcplx ) then
                    ! real eigenvalue
                    temp = one / max( abs( s( je, je ) )*ascale,abs( p( je, je ) )*bscale, safmin &
                              )
                    salfar = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*p( je, je ) )*bscale
                    acoef = sbeta*ascale
                    bcoefr = salfar*bscale
                    bcoefi = zero
                    ! scale to avoid underflow
                    scale = one
                    lsa = abs( sbeta )>=safmin .and. abs( acoef )<small
                    lsb = abs( salfar )>=safmin .and. abs( bcoefr )<small
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs( salfar ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoef ),abs( bcoefr ) ) ) &
                                 )
                       if( lsa ) then
                          acoef = ascale*( scale*sbeta )
                       else
                          acoef = scale*acoef
                       end if
                       if( lsb ) then
                          bcoefr = bscale*( scale*salfar )
                       else
                          bcoefr = scale*bcoefr
                       end if
                    end if
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr )
                    ! first component is 1
                    work( 2*n+je ) = one
                    xmax = one
                 else
                    ! complex eigenvalue
                    call stdlib_dlag2( s( je, je ), lds, p( je, je ), ldp,safmin*safety, acoef, &
                              temp, bcoefr, temp2,bcoefi )
                    bcoefi = -bcoefi
                    if( bcoefi==zero ) then
                       info = je
                       return
                    end if
                    ! scale to avoid over/underflow
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr ) + abs( bcoefi )
                    scale = one
                    if( acoefa*ulp<safmin .and. acoefa>=safmin )scale = ( safmin / ulp ) / &
                              acoefa
                    if( bcoefa*ulp<safmin .and. bcoefa>=safmin )scale = max( scale, ( safmin / &
                              ulp ) / bcoefa )
                    if( safmin*acoefa>ascale )scale = ascale / ( safmin*acoefa )
                    if( safmin*bcoefa>bscale )scale = min( scale, bscale / ( safmin*bcoefa ) )
                              
                    if( scale/=one ) then
                       acoef = scale*acoef
                       acoefa = abs( acoef )
                       bcoefr = scale*bcoefr
                       bcoefi = scale*bcoefi
                       bcoefa = abs( bcoefr ) + abs( bcoefi )
                    end if
                    ! compute first two components of eigenvector
                    temp = acoef*s( je+1, je )
                    temp2r = acoef*s( je, je ) - bcoefr*p( je, je )
                    temp2i = -bcoefi*p( je, je )
                    if( abs( temp )>abs( temp2r )+abs( temp2i ) ) then
                       work( 2*n+je ) = one
                       work( 3*n+je ) = zero
                       work( 2*n+je+1 ) = -temp2r / temp
                       work( 3*n+je+1 ) = -temp2i / temp
                    else
                       work( 2*n+je+1 ) = one
                       work( 3*n+je+1 ) = zero
                       temp = acoef*s( je, je+1 )
                       work( 2*n+je ) = ( bcoefr*p( je+1, je+1 )-acoef*s( je+1, je+1 ) ) / &
                                 temp
                       work( 3*n+je ) = bcoefi*p( je+1, je+1 ) / temp
                    end if
                    xmax = max( abs( work( 2*n+je ) )+abs( work( 3*n+je ) ),abs( work( 2*n+je+1 ) &
                              )+abs( work( 3*n+je+1 ) ) )
                 end if
                 dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                                                 ! t
                 ! triangular solve of  (a a - b b)  y = 0
                                         ! t
                 ! (rowwise in  (a a - b b) , or columnwise in (a a - b b) )
                 il2by2 = .false.
                 loop_160: do j = je + nw, n
                    if( il2by2 ) then
                       il2by2 = .false.
                       cycle loop_160
                    end if
                    na = 1
                    bdiag( 1 ) = p( j, j )
                    if( j<n ) then
                       if( s( j+1, j )/=zero ) then
                          il2by2 = .true.
                          bdiag( 2 ) = p( j+1, j+1 )
                          na = 2
                       end if
                    end if
                    ! check whether scaling is necessary for dot products
                    xscale = one / max( one, xmax )
                    temp = max( work( j ), work( n+j ),acoefa*work( j )+bcoefa*work( n+j ) )
                              
                    if( il2by2 )temp = max( temp, work( j+1 ), work( n+j+1 ),acoefa*work( j+1 )+&
                              bcoefa*work( n+j+1 ) )
                    if( temp>bignum*xscale ) then
                       do jw = 0, nw - 1
                          do jr = je, j - 1
                             work( ( jw+2 )*n+jr ) = xscale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                       xmax = xmax*xscale
                    end if
                    ! compute dot products
                          ! j-1
                    ! sum = sum  conjg( a*s(k,j) - b*p(k,j) )*x(k)
                          ! k=je
                    ! to reduce the op count, this is done as
                    ! _        j-1                  _        j-1
                    ! a*conjg( sum  s(k,j)*x(k) ) - b*conjg( sum  p(k,j)*x(k) )
                             ! k=je                          k=je
                    ! which may cause underflow problems if a or b are close
                    ! to underflow.  (e.g., less than small.)
                    do jw = 1, nw
                       do ja = 1, na
                          sums( ja, jw ) = zero
                          sump( ja, jw ) = zero
                          do jr = je, j - 1
                             sums( ja, jw ) = sums( ja, jw ) +s( jr, j+ja-1 )*work( ( jw+1 )*n+jr &
                                       )
                             sump( ja, jw ) = sump( ja, jw ) +p( jr, j+ja-1 )*work( ( jw+1 )*n+jr &
                                       )
                          end do
                       end do
                    end do
                    do ja = 1, na
                       if( ilcplx ) then
                          sum( ja, 1 ) = -acoef*sums( ja, 1 ) +bcoefr*sump( ja, 1 ) -bcoefi*sump( &
                                    ja, 2 )
                          sum( ja, 2 ) = -acoef*sums( ja, 2 ) +bcoefr*sump( ja, 2 ) +bcoefi*sump( &
                                    ja, 1 )
                       else
                          sum( ja, 1 ) = -acoef*sums( ja, 1 ) +bcoefr*sump( ja, 1 )
                       end if
                    end do
                                        ! t
                    ! solve  ( a a - b b )  y = sum(,)
                    ! with scaling and perturbation of the denominator
                    call stdlib_dlaln2( .true., na, nw, dmin, acoef, s( j, j ), lds,bdiag( 1 ), &
                    bdiag( 2 ), sum, 2, bcoefr,bcoefi, work( 2*n+j ), n, scale, temp,iinfo )
                              
                    if( scale<one ) then
                       do jw = 0, nw - 1
                          do jr = je, j - 1
                             work( ( jw+2 )*n+jr ) = scale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                       xmax = scale*xmax
                    end if
                    xmax = max( xmax, temp )
                 end do loop_160
                 ! copy eigenvector to vl, back transforming if
                 ! howmny='b'.
                 ieig = ieig + 1
                 if( ilback ) then
                    do jw = 0, nw - 1
                       call stdlib_dgemv( 'N', n, n+1-je, one, vl( 1, je ), ldvl,work( ( jw+2 )*n+&
                                 je ), 1, zero,work( ( jw+4 )*n+1 ), 1 )
                    end do
                    call stdlib_dlacpy( ' ', n, nw, work( 4*n+1 ), n, vl( 1, je ),ldvl )
                    ibeg = 1
                 else
                    call stdlib_dlacpy( ' ', n, nw, work( 2*n+1 ), n, vl( 1, ieig ),ldvl )
                    ibeg = je
                 end if
                 ! scale eigenvector
                 xmax = zero
                 if( ilcplx ) then
                    do j = ibeg, n
                       xmax = max( xmax, abs( vl( j, ieig ) )+abs( vl( j, ieig+1 ) ) )
                    end do
                 else
                    do j = ibeg, n
                       xmax = max( xmax, abs( vl( j, ieig ) ) )
                    end do
                 end if
                 if( xmax>safmin ) then
                    xscale = one / xmax
                    do jw = 0, nw - 1
                       do jr = ibeg, n
                          vl( jr, ieig+jw ) = xscale*vl( jr, ieig+jw )
                       end do
                    end do
                 end if
                 ieig = ieig + nw - 1
              end do loop_220
           end if
           ! right eigenvectors
           if( compr ) then
              ieig = im + 1
              ! main loop over eigenvalues
              ilcplx = .false.
              loop_500: do je = n, 1, -1
                 ! skip this iteration if (a) howmny='s' and select=.false., or
                 ! (b) this would be the second of a complex pair.
                 ! check for complex eigenvalue, so as to be sure of which
                 ! entry(-ies) of select to look at -- if complex, select(je)
                 ! or select(je-1).
                 ! if this is a complex pair, the 2-by-2 diagonal block
                 ! corresponding to the eigenvalue is in rows/columns je-1:je
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_500
                 end if
                 nw = 1
                 if( je>1 ) then
                    if( s( je, je-1 )/=zero ) then
                       ilcplx = .true.
                       nw = 2
                    end if
                 end if
                 if( ilall ) then
                    ilcomp = .true.
                 else if( ilcplx ) then
                    ilcomp = select( je ) .or. select( je-1 )
                 else
                    ilcomp = select( je )
                 end if
                 if( .not.ilcomp )cycle loop_500
                 ! decide if (a) singular pencil, (b) real eigenvalue, or
                 ! (c) complex eigenvalue.
                 if( .not.ilcplx ) then
                    if( abs( s( je, je ) )<=safmin .and.abs( p( je, je ) )<=safmin ) then
                       ! singular matrix pencil -- unit eigenvector
                       ieig = ieig - 1
                       do jr = 1, n
                          vr( jr, ieig ) = zero
                       end do
                       vr( ieig, ieig ) = one
                       cycle loop_500
                    end if
                 end if
                 ! clear vector
                 do jw = 0, nw - 1
                    do jr = 1, n
                       work( ( jw+2 )*n+jr ) = zero
                    end do
                 end do
                 ! compute coefficients in  ( a a - b b ) x = 0
                    ! a  is  acoef
                    ! b  is  bcoefr + i*bcoefi
                 if( .not.ilcplx ) then
                    ! real eigenvalue
                    temp = one / max( abs( s( je, je ) )*ascale,abs( p( je, je ) )*bscale, safmin &
                              )
                    salfar = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*p( je, je ) )*bscale
                    acoef = sbeta*ascale
                    bcoefr = salfar*bscale
                    bcoefi = zero
                    ! scale to avoid underflow
                    scale = one
                    lsa = abs( sbeta )>=safmin .and. abs( acoef )<small
                    lsb = abs( salfar )>=safmin .and. abs( bcoefr )<small
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs( salfar ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoef ),abs( bcoefr ) ) ) &
                                 )
                       if( lsa ) then
                          acoef = ascale*( scale*sbeta )
                       else
                          acoef = scale*acoef
                       end if
                       if( lsb ) then
                          bcoefr = bscale*( scale*salfar )
                       else
                          bcoefr = scale*bcoefr
                       end if
                    end if
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr )
                    ! first component is 1
                    work( 2*n+je ) = one
                    xmax = one
                    ! compute contribution from column je of a and b to sum
                    ! (see "further details", above.)
                    do jr = 1, je - 1
                       work( 2*n+jr ) = bcoefr*p( jr, je ) -acoef*s( jr, je )
                    end do
                 else
                    ! complex eigenvalue
                    call stdlib_dlag2( s( je-1, je-1 ), lds, p( je-1, je-1 ), ldp,safmin*safety, &
                              acoef, temp, bcoefr, temp2,bcoefi )
                    if( bcoefi==zero ) then
                       info = je - 1
                       return
                    end if
                    ! scale to avoid over/underflow
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr ) + abs( bcoefi )
                    scale = one
                    if( acoefa*ulp<safmin .and. acoefa>=safmin )scale = ( safmin / ulp ) / &
                              acoefa
                    if( bcoefa*ulp<safmin .and. bcoefa>=safmin )scale = max( scale, ( safmin / &
                              ulp ) / bcoefa )
                    if( safmin*acoefa>ascale )scale = ascale / ( safmin*acoefa )
                    if( safmin*bcoefa>bscale )scale = min( scale, bscale / ( safmin*bcoefa ) )
                              
                    if( scale/=one ) then
                       acoef = scale*acoef
                       acoefa = abs( acoef )
                       bcoefr = scale*bcoefr
                       bcoefi = scale*bcoefi
                       bcoefa = abs( bcoefr ) + abs( bcoefi )
                    end if
                    ! compute first two components of eigenvector
                    ! and contribution to sums
                    temp = acoef*s( je, je-1 )
                    temp2r = acoef*s( je, je ) - bcoefr*p( je, je )
                    temp2i = -bcoefi*p( je, je )
                    if( abs( temp )>=abs( temp2r )+abs( temp2i ) ) then
                       work( 2*n+je ) = one
                       work( 3*n+je ) = zero
                       work( 2*n+je-1 ) = -temp2r / temp
                       work( 3*n+je-1 ) = -temp2i / temp
                    else
                       work( 2*n+je-1 ) = one
                       work( 3*n+je-1 ) = zero
                       temp = acoef*s( je-1, je )
                       work( 2*n+je ) = ( bcoefr*p( je-1, je-1 )-acoef*s( je-1, je-1 ) ) / &
                                 temp
                       work( 3*n+je ) = bcoefi*p( je-1, je-1 ) / temp
                    end if
                    xmax = max( abs( work( 2*n+je ) )+abs( work( 3*n+je ) ),abs( work( 2*n+je-1 ) &
                              )+abs( work( 3*n+je-1 ) ) )
                    ! compute contribution from columns je and je-1
                    ! of a and b to the sums.
                    creala = acoef*work( 2*n+je-1 )
                    cimaga = acoef*work( 3*n+je-1 )
                    crealb = bcoefr*work( 2*n+je-1 ) -bcoefi*work( 3*n+je-1 )
                    cimagb = bcoefi*work( 2*n+je-1 ) +bcoefr*work( 3*n+je-1 )
                    cre2a = acoef*work( 2*n+je )
                    cim2a = acoef*work( 3*n+je )
                    cre2b = bcoefr*work( 2*n+je ) - bcoefi*work( 3*n+je )
                    cim2b = bcoefi*work( 2*n+je ) + bcoefr*work( 3*n+je )
                    do jr = 1, je - 2
                       work( 2*n+jr ) = -creala*s( jr, je-1 ) +crealb*p( jr, je-1 ) -cre2a*s( jr, &
                                 je ) + cre2b*p( jr, je )
                       work( 3*n+jr ) = -cimaga*s( jr, je-1 ) +cimagb*p( jr, je-1 ) -cim2a*s( jr, &
                                 je ) + cim2b*p( jr, je )
                    end do
                 end if
                 dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                 ! columnwise triangular solve of  (a a - b b)  x = 0
                 il2by2 = .false.
                 loop_370: do j = je - nw, 1, -1
                    ! if a 2-by-2 block, is in position j-1:j, wait until
                    ! next iteration to process it (when it will be j:j+1)
                    if( .not.il2by2 .and. j>1 ) then
                       if( s( j, j-1 )/=zero ) then
                          il2by2 = .true.
                          cycle loop_370
                       end if
                    end if
                    bdiag( 1 ) = p( j, j )
                    if( il2by2 ) then
                       na = 2
                       bdiag( 2 ) = p( j+1, j+1 )
                    else
                       na = 1
                    end if
                    ! compute x(j) (and x(j+1), if 2-by-2 block)
                    call stdlib_dlaln2( .false., na, nw, dmin, acoef, s( j, j ),lds, bdiag( 1 ), &
                    bdiag( 2 ), work( 2*n+j ),n, bcoefr, bcoefi, sum, 2, scale, temp,iinfo )
                              
                    if( scale<one ) then
                       do jw = 0, nw - 1
                          do jr = 1, je
                             work( ( jw+2 )*n+jr ) = scale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                    end if
                    xmax = max( scale*xmax, temp )
                    do jw = 1, nw
                       do ja = 1, na
                          work( ( jw+1 )*n+j+ja-1 ) = sum( ja, jw )
                       end do
                    end do
                    ! w = w + x(j)*(a s(*,j) - b p(*,j) ) with scaling
                    if( j>1 ) then
                       ! check whether scaling is necessary for sum.
                       xscale = one / max( one, xmax )
                       temp = acoefa*work( j ) + bcoefa*work( n+j )
                       if( il2by2 )temp = max( temp, acoefa*work( j+1 )+bcoefa*work( n+j+1 ) )
                                 
                       temp = max( temp, acoefa, bcoefa )
                       if( temp>bignum*xscale ) then
                          do jw = 0, nw - 1
                             do jr = 1, je
                                work( ( jw+2 )*n+jr ) = xscale*work( ( jw+2 )*n+jr )
                             end do
                          end do
                          xmax = xmax*xscale
                       end if
                       ! compute the contributions of the off-diagonals of
                       ! column j (and j+1, if 2-by-2 block) of a and b to the
                       ! sums.
                       do ja = 1, na
                          if( ilcplx ) then
                             creala = acoef*work( 2*n+j+ja-1 )
                             cimaga = acoef*work( 3*n+j+ja-1 )
                             crealb = bcoefr*work( 2*n+j+ja-1 ) -bcoefi*work( 3*n+j+ja-1 )
                             cimagb = bcoefi*work( 2*n+j+ja-1 ) +bcoefr*work( 3*n+j+ja-1 )
                             do jr = 1, j - 1
                                work( 2*n+jr ) = work( 2*n+jr ) -creala*s( jr, j+ja-1 ) +crealb*p(&
                                           jr, j+ja-1 )
                                work( 3*n+jr ) = work( 3*n+jr ) -cimaga*s( jr, j+ja-1 ) +cimagb*p(&
                                           jr, j+ja-1 )
                             end do
                          else
                             creala = acoef*work( 2*n+j+ja-1 )
                             crealb = bcoefr*work( 2*n+j+ja-1 )
                             do jr = 1, j - 1
                                work( 2*n+jr ) = work( 2*n+jr ) -creala*s( jr, j+ja-1 ) +crealb*p(&
                                           jr, j+ja-1 )
                             end do
                          end if
                       end do
                    end if
                    il2by2 = .false.
                 end do loop_370
                 ! copy eigenvector to vr, back transforming if
                 ! howmny='b'.
                 ieig = ieig - nw
                 if( ilback ) then
                    do jw = 0, nw - 1
                       do jr = 1, n
                          work( ( jw+4 )*n+jr ) = work( ( jw+2 )*n+1 )*vr( jr, 1 )
                       end do
                       ! a series of compiler directives to defeat
                       ! vectorization for the next loop
                       do jc = 2, je
                          do jr = 1, n
                             work( ( jw+4 )*n+jr ) = work( ( jw+4 )*n+jr ) +work( ( jw+2 )*n+jc )&
                                       *vr( jr, jc )
                          end do
                       end do
                    end do
                    do jw = 0, nw - 1
                       do jr = 1, n
                          vr( jr, ieig+jw ) = work( ( jw+4 )*n+jr )
                       end do
                    end do
                    iend = n
                 else
                    do jw = 0, nw - 1
                       do jr = 1, n
                          vr( jr, ieig+jw ) = work( ( jw+2 )*n+jr )
                       end do
                    end do
                    iend = je
                 end if
                 ! scale eigenvector
                 xmax = zero
                 if( ilcplx ) then
                    do j = 1, iend
                       xmax = max( xmax, abs( vr( j, ieig ) )+abs( vr( j, ieig+1 ) ) )
                    end do
                 else
                    do j = 1, iend
                       xmax = max( xmax, abs( vr( j, ieig ) ) )
                    end do
                 end if
                 if( xmax>safmin ) then
                    xscale = one / xmax
                    do jw = 0, nw - 1
                       do jr = 1, iend
                          vr( jr, ieig+jw ) = xscale*vr( jr, ieig+jw )
                       end do
                    end do
                 end if
              end do loop_500
           end if
           return
     end subroutine stdlib_dtgevc

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$tgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
     !! DTGEVC: computes some or all of the right and/or left eigenvectors of
     !! a pair of real matrices (S,P), where S is a quasi-triangular matrix
     !! and P is upper triangular.  Matrix pairs of this type are produced by
     !! the generalized Schur factorization of a matrix pair (A,B):
     !! A = Q*S*Z**T,  B = Q*P*Z**T
     !! as computed by DGGHRD + DHGEQZ.
     !! The right eigenvector x and the left eigenvector y of (S,P)
     !! corresponding to an eigenvalue w are defined by:
     !! S*x = w*P*x,  (y**H)*S = w*(y**H)*P,
     !! where y**H denotes the conjugate tranpose of y.
     !! The eigenvalues are not input to this routine, but are computed
     !! directly from the diagonal blocks of S and P.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of (S,P), or the products Z*X and/or Q*Y,
     !! where Z and Q are input matrices.
     !! If Q and Z are the orthogonal factors from the generalized Schur
     !! factorization of a matrix pair (A,B), then Z*X and Q*Y
     !! are the matrices of right and left eigenvectors of (A,B).
               mm, m, work, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(${rk}$), intent(in) :: p(ldp,*), s(lds,*)
           real(${rk}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           real(${rk}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           real(${rk}$), parameter :: safety = 1.0e+2_${rk}$
           
           ! Local Scalars 
           logical(lk) :: compl, compr, il2by2, ilabad, ilall, ilback, ilbbad, ilcomp, ilcplx, &
                     lsa, lsb
           integer(ilp) :: i, ibeg, ieig, iend, ihwmny, iinfo, im, iside, j, ja, jc, je, jr, jw, &
                     na, nw
           real(${rk}$) :: acoef, acoefa, anorm, ascale, bcoefa, bcoefi, bcoefr, big, bignum, bnorm, &
           bscale, cim2a, cim2b, cimaga, cimagb, cre2a, cre2b, creala, crealb, dmin, safmin, &
                     salfar, sbeta, scale, small, temp, temp2, temp2i, temp2r, ulp, xmax, xscale
           ! Local Arrays 
           real(${rk}$) :: bdiag(2), sum(2,2), sums(2,2), sump(2,2)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           if( stdlib_lsame( howmny, 'A' ) ) then
              ihwmny = 1
              ilall = .true.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'S' ) ) then
              ihwmny = 2
              ilall = .false.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'B' ) ) then
              ihwmny = 3
              ilall = .true.
              ilback = .true.
           else
              ihwmny = -1
              ilall = .true.
           end if
           if( stdlib_lsame( side, 'R' ) ) then
              iside = 1
              compl = .false.
              compr = .true.
           else if( stdlib_lsame( side, 'L' ) ) then
              iside = 2
              compl = .true.
              compr = .false.
           else if( stdlib_lsame( side, 'B' ) ) then
              iside = 3
              compl = .true.
              compr = .true.
           else
              iside = -1
           end if
           info = 0
           if( iside<0 ) then
              info = -1
           else if( ihwmny<0 ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lds<max( 1, n ) ) then
              info = -6
           else if( ldp<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGEVC', -info )
              return
           end if
           ! count the number of eigenvectors to be computed
           if( .not.ilall ) then
              im = 0
              ilcplx = .false.
              loop_10: do j = 1, n
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_10
                 end if
                 if( j<n ) then
                    if( s( j+1, j )/=zero )ilcplx = .true.
                 end if
                 if( ilcplx ) then
                    if( select( j ) .or. select( j+1 ) )im = im + 2
                 else
                    if( select( j ) )im = im + 1
                 end if
              end do loop_10
           else
              im = n
           end if
           ! check 2-by-2 diagonal blocks of a, b
           ilabad = .false.
           ilbbad = .false.
           do j = 1, n - 1
              if( s( j+1, j )/=zero ) then
                 if( p( j, j )==zero .or. p( j+1, j+1 )==zero .or.p( j, j+1 )/=zero )ilbbad = &
                           .true.
                 if( j<n-1 ) then
                    if( s( j+2, j+1 )/=zero )ilabad = .true.
                 end if
              end if
           end do
           if( ilabad ) then
              info = -5
           else if( ilbbad ) then
              info = -7
           else if( compl .and. ldvl<n .or. ldvl<1 ) then
              info = -10
           else if( compr .and. ldvr<n .or. ldvr<1 ) then
              info = -12
           else if( mm<im ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGEVC', -info )
              return
           end if
           ! quick return if possible
           m = im
           if( n==0 )return
           ! machine constants
           safmin = stdlib_${ri}$lamch( 'SAFE MINIMUM' )
           big = one / safmin
           call stdlib_${ri}$labad( safmin, big )
           ulp = stdlib_${ri}$lamch( 'EPSILON' )*stdlib_${ri}$lamch( 'BASE' )
           small = safmin*n / ulp
           big = one / small
           bignum = one / ( safmin*n )
           ! compute the 1-norm of each column of the strictly upper triangular
           ! part (i.e., excluding all elements belonging to the diagonal
           ! blocks) of a and b to check for possible overflow in the
           ! triangular solver.
           anorm = abs( s( 1, 1 ) )
           if( n>1 )anorm = anorm + abs( s( 2, 1 ) )
           bnorm = abs( p( 1, 1 ) )
           work( 1 ) = zero
           work( n+1 ) = zero
           do j = 2, n
              temp = zero
              temp2 = zero
              if( s( j, j-1 )==zero ) then
                 iend = j - 1
              else
                 iend = j - 2
              end if
              do i = 1, iend
                 temp = temp + abs( s( i, j ) )
                 temp2 = temp2 + abs( p( i, j ) )
              end do
              work( j ) = temp
              work( n+j ) = temp2
              do i = iend + 1, min( j+1, n )
                 temp = temp + abs( s( i, j ) )
                 temp2 = temp2 + abs( p( i, j ) )
              end do
              anorm = max( anorm, temp )
              bnorm = max( bnorm, temp2 )
           end do
           ascale = one / max( anorm, safmin )
           bscale = one / max( bnorm, safmin )
           ! left eigenvectors
           if( compl ) then
              ieig = 0
              ! main loop over eigenvalues
              ilcplx = .false.
              loop_220: do je = 1, n
                 ! skip this iteration if (a) howmny='s' and select=.false., or
                 ! (b) this would be the second of a complex pair.
                 ! check for complex eigenvalue, so as to be sure of which
                 ! entry(-ies) of select to look at.
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_220
                 end if
                 nw = 1
                 if( je<n ) then
                    if( s( je+1, je )/=zero ) then
                       ilcplx = .true.
                       nw = 2
                    end if
                 end if
                 if( ilall ) then
                    ilcomp = .true.
                 else if( ilcplx ) then
                    ilcomp = select( je ) .or. select( je+1 )
                 else
                    ilcomp = select( je )
                 end if
                 if( .not.ilcomp )cycle loop_220
                 ! decide if (a) singular pencil, (b) real eigenvalue, or
                 ! (c) complex eigenvalue.
                 if( .not.ilcplx ) then
                    if( abs( s( je, je ) )<=safmin .and.abs( p( je, je ) )<=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       ieig = ieig + 1
                       do jr = 1, n
                          vl( jr, ieig ) = zero
                       end do
                       vl( ieig, ieig ) = one
                       cycle loop_220
                    end if
                 end if
                 ! clear vector
                 do jr = 1, nw*n
                    work( 2*n+jr ) = zero
                 end do
                                                       ! t
                 ! compute coefficients in  ( a a - b b )  y = 0
                    ! a  is  acoef
                    ! b  is  bcoefr + i*bcoefi
                 if( .not.ilcplx ) then
                    ! real eigenvalue
                    temp = one / max( abs( s( je, je ) )*ascale,abs( p( je, je ) )*bscale, safmin &
                              )
                    salfar = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*p( je, je ) )*bscale
                    acoef = sbeta*ascale
                    bcoefr = salfar*bscale
                    bcoefi = zero
                    ! scale to avoid underflow
                    scale = one
                    lsa = abs( sbeta )>=safmin .and. abs( acoef )<small
                    lsb = abs( salfar )>=safmin .and. abs( bcoefr )<small
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs( salfar ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoef ),abs( bcoefr ) ) ) &
                                 )
                       if( lsa ) then
                          acoef = ascale*( scale*sbeta )
                       else
                          acoef = scale*acoef
                       end if
                       if( lsb ) then
                          bcoefr = bscale*( scale*salfar )
                       else
                          bcoefr = scale*bcoefr
                       end if
                    end if
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr )
                    ! first component is 1
                    work( 2*n+je ) = one
                    xmax = one
                 else
                    ! complex eigenvalue
                    call stdlib_${ri}$lag2( s( je, je ), lds, p( je, je ), ldp,safmin*safety, acoef, &
                              temp, bcoefr, temp2,bcoefi )
                    bcoefi = -bcoefi
                    if( bcoefi==zero ) then
                       info = je
                       return
                    end if
                    ! scale to avoid over/underflow
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr ) + abs( bcoefi )
                    scale = one
                    if( acoefa*ulp<safmin .and. acoefa>=safmin )scale = ( safmin / ulp ) / &
                              acoefa
                    if( bcoefa*ulp<safmin .and. bcoefa>=safmin )scale = max( scale, ( safmin / &
                              ulp ) / bcoefa )
                    if( safmin*acoefa>ascale )scale = ascale / ( safmin*acoefa )
                    if( safmin*bcoefa>bscale )scale = min( scale, bscale / ( safmin*bcoefa ) )
                              
                    if( scale/=one ) then
                       acoef = scale*acoef
                       acoefa = abs( acoef )
                       bcoefr = scale*bcoefr
                       bcoefi = scale*bcoefi
                       bcoefa = abs( bcoefr ) + abs( bcoefi )
                    end if
                    ! compute first two components of eigenvector
                    temp = acoef*s( je+1, je )
                    temp2r = acoef*s( je, je ) - bcoefr*p( je, je )
                    temp2i = -bcoefi*p( je, je )
                    if( abs( temp )>abs( temp2r )+abs( temp2i ) ) then
                       work( 2*n+je ) = one
                       work( 3*n+je ) = zero
                       work( 2*n+je+1 ) = -temp2r / temp
                       work( 3*n+je+1 ) = -temp2i / temp
                    else
                       work( 2*n+je+1 ) = one
                       work( 3*n+je+1 ) = zero
                       temp = acoef*s( je, je+1 )
                       work( 2*n+je ) = ( bcoefr*p( je+1, je+1 )-acoef*s( je+1, je+1 ) ) / &
                                 temp
                       work( 3*n+je ) = bcoefi*p( je+1, je+1 ) / temp
                    end if
                    xmax = max( abs( work( 2*n+je ) )+abs( work( 3*n+je ) ),abs( work( 2*n+je+1 ) &
                              )+abs( work( 3*n+je+1 ) ) )
                 end if
                 dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                                                 ! t
                 ! triangular solve of  (a a - b b)  y = 0
                                         ! t
                 ! (rowwise in  (a a - b b) , or columnwise in (a a - b b) )
                 il2by2 = .false.
                 loop_160: do j = je + nw, n
                    if( il2by2 ) then
                       il2by2 = .false.
                       cycle loop_160
                    end if
                    na = 1
                    bdiag( 1 ) = p( j, j )
                    if( j<n ) then
                       if( s( j+1, j )/=zero ) then
                          il2by2 = .true.
                          bdiag( 2 ) = p( j+1, j+1 )
                          na = 2
                       end if
                    end if
                    ! check whether scaling is necessary for dot products
                    xscale = one / max( one, xmax )
                    temp = max( work( j ), work( n+j ),acoefa*work( j )+bcoefa*work( n+j ) )
                              
                    if( il2by2 )temp = max( temp, work( j+1 ), work( n+j+1 ),acoefa*work( j+1 )+&
                              bcoefa*work( n+j+1 ) )
                    if( temp>bignum*xscale ) then
                       do jw = 0, nw - 1
                          do jr = je, j - 1
                             work( ( jw+2 )*n+jr ) = xscale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                       xmax = xmax*xscale
                    end if
                    ! compute dot products
                          ! j-1
                    ! sum = sum  conjg( a*s(k,j) - b*p(k,j) )*x(k)
                          ! k=je
                    ! to reduce the op count, this is done as
                    ! _        j-1                  _        j-1
                    ! a*conjg( sum  s(k,j)*x(k) ) - b*conjg( sum  p(k,j)*x(k) )
                             ! k=je                          k=je
                    ! which may cause underflow problems if a or b are close
                    ! to underflow.  (e.g., less than small.)
                    do jw = 1, nw
                       do ja = 1, na
                          sums( ja, jw ) = zero
                          sump( ja, jw ) = zero
                          do jr = je, j - 1
                             sums( ja, jw ) = sums( ja, jw ) +s( jr, j+ja-1 )*work( ( jw+1 )*n+jr &
                                       )
                             sump( ja, jw ) = sump( ja, jw ) +p( jr, j+ja-1 )*work( ( jw+1 )*n+jr &
                                       )
                          end do
                       end do
                    end do
                    do ja = 1, na
                       if( ilcplx ) then
                          sum( ja, 1 ) = -acoef*sums( ja, 1 ) +bcoefr*sump( ja, 1 ) -bcoefi*sump( &
                                    ja, 2 )
                          sum( ja, 2 ) = -acoef*sums( ja, 2 ) +bcoefr*sump( ja, 2 ) +bcoefi*sump( &
                                    ja, 1 )
                       else
                          sum( ja, 1 ) = -acoef*sums( ja, 1 ) +bcoefr*sump( ja, 1 )
                       end if
                    end do
                                        ! t
                    ! solve  ( a a - b b )  y = sum(,)
                    ! with scaling and perturbation of the denominator
                    call stdlib_${ri}$laln2( .true., na, nw, dmin, acoef, s( j, j ), lds,bdiag( 1 ), &
                    bdiag( 2 ), sum, 2, bcoefr,bcoefi, work( 2*n+j ), n, scale, temp,iinfo )
                              
                    if( scale<one ) then
                       do jw = 0, nw - 1
                          do jr = je, j - 1
                             work( ( jw+2 )*n+jr ) = scale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                       xmax = scale*xmax
                    end if
                    xmax = max( xmax, temp )
                 end do loop_160
                 ! copy eigenvector to vl, back transforming if
                 ! howmny='b'.
                 ieig = ieig + 1
                 if( ilback ) then
                    do jw = 0, nw - 1
                       call stdlib_${ri}$gemv( 'N', n, n+1-je, one, vl( 1, je ), ldvl,work( ( jw+2 )*n+&
                                 je ), 1, zero,work( ( jw+4 )*n+1 ), 1 )
                    end do
                    call stdlib_${ri}$lacpy( ' ', n, nw, work( 4*n+1 ), n, vl( 1, je ),ldvl )
                    ibeg = 1
                 else
                    call stdlib_${ri}$lacpy( ' ', n, nw, work( 2*n+1 ), n, vl( 1, ieig ),ldvl )
                    ibeg = je
                 end if
                 ! scale eigenvector
                 xmax = zero
                 if( ilcplx ) then
                    do j = ibeg, n
                       xmax = max( xmax, abs( vl( j, ieig ) )+abs( vl( j, ieig+1 ) ) )
                    end do
                 else
                    do j = ibeg, n
                       xmax = max( xmax, abs( vl( j, ieig ) ) )
                    end do
                 end if
                 if( xmax>safmin ) then
                    xscale = one / xmax
                    do jw = 0, nw - 1
                       do jr = ibeg, n
                          vl( jr, ieig+jw ) = xscale*vl( jr, ieig+jw )
                       end do
                    end do
                 end if
                 ieig = ieig + nw - 1
              end do loop_220
           end if
           ! right eigenvectors
           if( compr ) then
              ieig = im + 1
              ! main loop over eigenvalues
              ilcplx = .false.
              loop_500: do je = n, 1, -1
                 ! skip this iteration if (a) howmny='s' and select=.false., or
                 ! (b) this would be the second of a complex pair.
                 ! check for complex eigenvalue, so as to be sure of which
                 ! entry(-ies) of select to look at -- if complex, select(je)
                 ! or select(je-1).
                 ! if this is a complex pair, the 2-by-2 diagonal block
                 ! corresponding to the eigenvalue is in rows/columns je-1:je
                 if( ilcplx ) then
                    ilcplx = .false.
                    cycle loop_500
                 end if
                 nw = 1
                 if( je>1 ) then
                    if( s( je, je-1 )/=zero ) then
                       ilcplx = .true.
                       nw = 2
                    end if
                 end if
                 if( ilall ) then
                    ilcomp = .true.
                 else if( ilcplx ) then
                    ilcomp = select( je ) .or. select( je-1 )
                 else
                    ilcomp = select( je )
                 end if
                 if( .not.ilcomp )cycle loop_500
                 ! decide if (a) singular pencil, (b) real eigenvalue, or
                 ! (c) complex eigenvalue.
                 if( .not.ilcplx ) then
                    if( abs( s( je, je ) )<=safmin .and.abs( p( je, je ) )<=safmin ) then
                       ! singular matrix pencil -- unit eigenvector
                       ieig = ieig - 1
                       do jr = 1, n
                          vr( jr, ieig ) = zero
                       end do
                       vr( ieig, ieig ) = one
                       cycle loop_500
                    end if
                 end if
                 ! clear vector
                 do jw = 0, nw - 1
                    do jr = 1, n
                       work( ( jw+2 )*n+jr ) = zero
                    end do
                 end do
                 ! compute coefficients in  ( a a - b b ) x = 0
                    ! a  is  acoef
                    ! b  is  bcoefr + i*bcoefi
                 if( .not.ilcplx ) then
                    ! real eigenvalue
                    temp = one / max( abs( s( je, je ) )*ascale,abs( p( je, je ) )*bscale, safmin &
                              )
                    salfar = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*p( je, je ) )*bscale
                    acoef = sbeta*ascale
                    bcoefr = salfar*bscale
                    bcoefi = zero
                    ! scale to avoid underflow
                    scale = one
                    lsa = abs( sbeta )>=safmin .and. abs( acoef )<small
                    lsb = abs( salfar )>=safmin .and. abs( bcoefr )<small
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs( salfar ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoef ),abs( bcoefr ) ) ) &
                                 )
                       if( lsa ) then
                          acoef = ascale*( scale*sbeta )
                       else
                          acoef = scale*acoef
                       end if
                       if( lsb ) then
                          bcoefr = bscale*( scale*salfar )
                       else
                          bcoefr = scale*bcoefr
                       end if
                    end if
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr )
                    ! first component is 1
                    work( 2*n+je ) = one
                    xmax = one
                    ! compute contribution from column je of a and b to sum
                    ! (see "further details", above.)
                    do jr = 1, je - 1
                       work( 2*n+jr ) = bcoefr*p( jr, je ) -acoef*s( jr, je )
                    end do
                 else
                    ! complex eigenvalue
                    call stdlib_${ri}$lag2( s( je-1, je-1 ), lds, p( je-1, je-1 ), ldp,safmin*safety, &
                              acoef, temp, bcoefr, temp2,bcoefi )
                    if( bcoefi==zero ) then
                       info = je - 1
                       return
                    end if
                    ! scale to avoid over/underflow
                    acoefa = abs( acoef )
                    bcoefa = abs( bcoefr ) + abs( bcoefi )
                    scale = one
                    if( acoefa*ulp<safmin .and. acoefa>=safmin )scale = ( safmin / ulp ) / &
                              acoefa
                    if( bcoefa*ulp<safmin .and. bcoefa>=safmin )scale = max( scale, ( safmin / &
                              ulp ) / bcoefa )
                    if( safmin*acoefa>ascale )scale = ascale / ( safmin*acoefa )
                    if( safmin*bcoefa>bscale )scale = min( scale, bscale / ( safmin*bcoefa ) )
                              
                    if( scale/=one ) then
                       acoef = scale*acoef
                       acoefa = abs( acoef )
                       bcoefr = scale*bcoefr
                       bcoefi = scale*bcoefi
                       bcoefa = abs( bcoefr ) + abs( bcoefi )
                    end if
                    ! compute first two components of eigenvector
                    ! and contribution to sums
                    temp = acoef*s( je, je-1 )
                    temp2r = acoef*s( je, je ) - bcoefr*p( je, je )
                    temp2i = -bcoefi*p( je, je )
                    if( abs( temp )>=abs( temp2r )+abs( temp2i ) ) then
                       work( 2*n+je ) = one
                       work( 3*n+je ) = zero
                       work( 2*n+je-1 ) = -temp2r / temp
                       work( 3*n+je-1 ) = -temp2i / temp
                    else
                       work( 2*n+je-1 ) = one
                       work( 3*n+je-1 ) = zero
                       temp = acoef*s( je-1, je )
                       work( 2*n+je ) = ( bcoefr*p( je-1, je-1 )-acoef*s( je-1, je-1 ) ) / &
                                 temp
                       work( 3*n+je ) = bcoefi*p( je-1, je-1 ) / temp
                    end if
                    xmax = max( abs( work( 2*n+je ) )+abs( work( 3*n+je ) ),abs( work( 2*n+je-1 ) &
                              )+abs( work( 3*n+je-1 ) ) )
                    ! compute contribution from columns je and je-1
                    ! of a and b to the sums.
                    creala = acoef*work( 2*n+je-1 )
                    cimaga = acoef*work( 3*n+je-1 )
                    crealb = bcoefr*work( 2*n+je-1 ) -bcoefi*work( 3*n+je-1 )
                    cimagb = bcoefi*work( 2*n+je-1 ) +bcoefr*work( 3*n+je-1 )
                    cre2a = acoef*work( 2*n+je )
                    cim2a = acoef*work( 3*n+je )
                    cre2b = bcoefr*work( 2*n+je ) - bcoefi*work( 3*n+je )
                    cim2b = bcoefi*work( 2*n+je ) + bcoefr*work( 3*n+je )
                    do jr = 1, je - 2
                       work( 2*n+jr ) = -creala*s( jr, je-1 ) +crealb*p( jr, je-1 ) -cre2a*s( jr, &
                                 je ) + cre2b*p( jr, je )
                       work( 3*n+jr ) = -cimaga*s( jr, je-1 ) +cimagb*p( jr, je-1 ) -cim2a*s( jr, &
                                 je ) + cim2b*p( jr, je )
                    end do
                 end if
                 dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                 ! columnwise triangular solve of  (a a - b b)  x = 0
                 il2by2 = .false.
                 loop_370: do j = je - nw, 1, -1
                    ! if a 2-by-2 block, is in position j-1:j, wait until
                    ! next iteration to process it (when it will be j:j+1)
                    if( .not.il2by2 .and. j>1 ) then
                       if( s( j, j-1 )/=zero ) then
                          il2by2 = .true.
                          cycle loop_370
                       end if
                    end if
                    bdiag( 1 ) = p( j, j )
                    if( il2by2 ) then
                       na = 2
                       bdiag( 2 ) = p( j+1, j+1 )
                    else
                       na = 1
                    end if
                    ! compute x(j) (and x(j+1), if 2-by-2 block)
                    call stdlib_${ri}$laln2( .false., na, nw, dmin, acoef, s( j, j ),lds, bdiag( 1 ), &
                    bdiag( 2 ), work( 2*n+j ),n, bcoefr, bcoefi, sum, 2, scale, temp,iinfo )
                              
                    if( scale<one ) then
                       do jw = 0, nw - 1
                          do jr = 1, je
                             work( ( jw+2 )*n+jr ) = scale*work( ( jw+2 )*n+jr )
                          end do
                       end do
                    end if
                    xmax = max( scale*xmax, temp )
                    do jw = 1, nw
                       do ja = 1, na
                          work( ( jw+1 )*n+j+ja-1 ) = sum( ja, jw )
                       end do
                    end do
                    ! w = w + x(j)*(a s(*,j) - b p(*,j) ) with scaling
                    if( j>1 ) then
                       ! check whether scaling is necessary for sum.
                       xscale = one / max( one, xmax )
                       temp = acoefa*work( j ) + bcoefa*work( n+j )
                       if( il2by2 )temp = max( temp, acoefa*work( j+1 )+bcoefa*work( n+j+1 ) )
                                 
                       temp = max( temp, acoefa, bcoefa )
                       if( temp>bignum*xscale ) then
                          do jw = 0, nw - 1
                             do jr = 1, je
                                work( ( jw+2 )*n+jr ) = xscale*work( ( jw+2 )*n+jr )
                             end do
                          end do
                          xmax = xmax*xscale
                       end if
                       ! compute the contributions of the off-diagonals of
                       ! column j (and j+1, if 2-by-2 block) of a and b to the
                       ! sums.
                       do ja = 1, na
                          if( ilcplx ) then
                             creala = acoef*work( 2*n+j+ja-1 )
                             cimaga = acoef*work( 3*n+j+ja-1 )
                             crealb = bcoefr*work( 2*n+j+ja-1 ) -bcoefi*work( 3*n+j+ja-1 )
                             cimagb = bcoefi*work( 2*n+j+ja-1 ) +bcoefr*work( 3*n+j+ja-1 )
                             do jr = 1, j - 1
                                work( 2*n+jr ) = work( 2*n+jr ) -creala*s( jr, j+ja-1 ) +crealb*p(&
                                           jr, j+ja-1 )
                                work( 3*n+jr ) = work( 3*n+jr ) -cimaga*s( jr, j+ja-1 ) +cimagb*p(&
                                           jr, j+ja-1 )
                             end do
                          else
                             creala = acoef*work( 2*n+j+ja-1 )
                             crealb = bcoefr*work( 2*n+j+ja-1 )
                             do jr = 1, j - 1
                                work( 2*n+jr ) = work( 2*n+jr ) -creala*s( jr, j+ja-1 ) +crealb*p(&
                                           jr, j+ja-1 )
                             end do
                          end if
                       end do
                    end if
                    il2by2 = .false.
                 end do loop_370
                 ! copy eigenvector to vr, back transforming if
                 ! howmny='b'.
                 ieig = ieig - nw
                 if( ilback ) then
                    do jw = 0, nw - 1
                       do jr = 1, n
                          work( ( jw+4 )*n+jr ) = work( ( jw+2 )*n+1 )*vr( jr, 1 )
                       end do
                       ! a series of compiler directives to defeat
                       ! vectorization for the next loop
                       do jc = 2, je
                          do jr = 1, n
                             work( ( jw+4 )*n+jr ) = work( ( jw+4 )*n+jr ) +work( ( jw+2 )*n+jc )&
                                       *vr( jr, jc )
                          end do
                       end do
                    end do
                    do jw = 0, nw - 1
                       do jr = 1, n
                          vr( jr, ieig+jw ) = work( ( jw+4 )*n+jr )
                       end do
                    end do
                    iend = n
                 else
                    do jw = 0, nw - 1
                       do jr = 1, n
                          vr( jr, ieig+jw ) = work( ( jw+2 )*n+jr )
                       end do
                    end do
                    iend = je
                 end if
                 ! scale eigenvector
                 xmax = zero
                 if( ilcplx ) then
                    do j = 1, iend
                       xmax = max( xmax, abs( vr( j, ieig ) )+abs( vr( j, ieig+1 ) ) )
                    end do
                 else
                    do j = 1, iend
                       xmax = max( xmax, abs( vr( j, ieig ) ) )
                    end do
                 end if
                 if( xmax>safmin ) then
                    xscale = one / xmax
                    do jw = 0, nw - 1
                       do jr = 1, iend
                          vr( jr, ieig+jw ) = xscale*vr( jr, ieig+jw )
                       end do
                    end do
                 end if
              end do loop_500
           end if
           return
     end subroutine stdlib_${ri}$tgevc

#:endif
#:endfor

     module pure subroutine stdlib_ctgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
     !! CTGEVC computes some or all of the right and/or left eigenvectors of
     !! a pair of complex matrices (S,P), where S and P are upper triangular.
     !! Matrix pairs of this type are produced by the generalized Schur
     !! factorization of a complex matrix pair (A,B):
     !! A = Q*S*Z**H,  B = Q*P*Z**H
     !! as computed by CGGHRD + CHGEQZ.
     !! The right eigenvector x and the left eigenvector y of (S,P)
     !! corresponding to an eigenvalue w are defined by:
     !! S*x = w*P*x,  (y**H)*S = w*(y**H)*P,
     !! where y**H denotes the conjugate tranpose of y.
     !! The eigenvalues are not input to this routine, but are computed
     !! directly from the diagonal elements of S and P.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of (S,P), or the products Z*X and/or Q*Y,
     !! where Z and Q are input matrices.
     !! If Q and Z are the unitary factors from the generalized Schur
     !! factorization of a matrix pair (A,B), then Z*X and Q*Y
     !! are the matrices of right and left eigenvectors of (A,B).
               mm, m, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(sp), intent(out) :: rwork(*)
           complex(sp), intent(in) :: p(ldp,*), s(lds,*)
           complex(sp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: compl, compr, ilall, ilback, ilbbad, ilcomp, lsa, lsb
           integer(ilp) :: i, ibeg, ieig, iend, ihwmny, im, iside, isrc, j, je, jr
           real(sp) :: acoefa, acoeff, anorm, ascale, bcoefa, big, bignum, bnorm, bscale, dmin, &
                     safmin, sbeta, scale, small, temp, ulp, xmax
           complex(sp) :: bcoeff, ca, cb, d, salpha, sum, suma, sumb, x
           ! Intrinsic Functions 
           ! Statement Functions 
           real(sp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=sp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode and test the input parameters
           if( stdlib_lsame( howmny, 'A' ) ) then
              ihwmny = 1
              ilall = .true.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'S' ) ) then
              ihwmny = 2
              ilall = .false.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'B' ) ) then
              ihwmny = 3
              ilall = .true.
              ilback = .true.
           else
              ihwmny = -1
           end if
           if( stdlib_lsame( side, 'R' ) ) then
              iside = 1
              compl = .false.
              compr = .true.
           else if( stdlib_lsame( side, 'L' ) ) then
              iside = 2
              compl = .true.
              compr = .false.
           else if( stdlib_lsame( side, 'B' ) ) then
              iside = 3
              compl = .true.
              compr = .true.
           else
              iside = -1
           end if
           info = 0
           if( iside<0 ) then
              info = -1
           else if( ihwmny<0 ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lds<max( 1, n ) ) then
              info = -6
           else if( ldp<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGEVC', -info )
              return
           end if
           ! count the number of eigenvectors
           if( .not.ilall ) then
              im = 0
              do j = 1, n
                 if( select( j ) )im = im + 1
              end do
           else
              im = n
           end if
           ! check diagonal of b
           ilbbad = .false.
           do j = 1, n
              if( aimag( p( j, j ) )/=zero )ilbbad = .true.
           end do
           if( ilbbad ) then
              info = -7
           else if( compl .and. ldvl<n .or. ldvl<1 ) then
              info = -10
           else if( compr .and. ldvr<n .or. ldvr<1 ) then
              info = -12
           else if( mm<im ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGEVC', -info )
              return
           end if
           ! quick return if possible
           m = im
           if( n==0 )return
           ! machine constants
           safmin = stdlib_slamch( 'SAFE MINIMUM' )
           big = one / safmin
           call stdlib_slabad( safmin, big )
           ulp = stdlib_slamch( 'EPSILON' )*stdlib_slamch( 'BASE' )
           small = safmin*n / ulp
           big = one / small
           bignum = one / ( safmin*n )
           ! compute the 1-norm of each column of the strictly upper triangular
           ! part of a and b to check for possible overflow in the triangular
           ! solver.
           anorm = abs1( s( 1, 1 ) )
           bnorm = abs1( p( 1, 1 ) )
           rwork( 1 ) = zero
           rwork( n+1 ) = zero
           do j = 2, n
              rwork( j ) = zero
              rwork( n+j ) = zero
              do i = 1, j - 1
                 rwork( j ) = rwork( j ) + abs1( s( i, j ) )
                 rwork( n+j ) = rwork( n+j ) + abs1( p( i, j ) )
              end do
              anorm = max( anorm, rwork( j )+abs1( s( j, j ) ) )
              bnorm = max( bnorm, rwork( n+j )+abs1( p( j, j ) ) )
           end do
           ascale = one / max( anorm, safmin )
           bscale = one / max( bnorm, safmin )
           ! left eigenvectors
           if( compl ) then
              ieig = 0
              ! main loop over eigenvalues
              loop_140: do je = 1, n
                 if( ilall ) then
                    ilcomp = .true.
                 else
                    ilcomp = select( je )
                 end if
                 if( ilcomp ) then
                    ieig = ieig + 1
                    if( abs1( s( je, je ) )<=safmin .and.abs( real( p( je, je ),KIND=sp) )&
                              <=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       do jr = 1, n
                          vl( jr, ieig ) = czero
                       end do
                       vl( ieig, ieig ) = cone
                       cycle loop_140
                    end if
                    ! non-singular eigenvalue:
                    ! compute coefficients  a  and  b  in
                         ! h
                       ! y  ( a a - b b ) = 0
                    temp = one / max( abs1( s( je, je ) )*ascale,abs( real( p( je, je ),KIND=sp) )&
                              *bscale, safmin )
                    salpha = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*real( p( je, je ),KIND=sp) )*bscale
                    acoeff = sbeta*ascale
                    bcoeff = salpha*bscale
                    ! scale to avoid underflow
                    lsa = abs( sbeta )>=safmin .and. abs( acoeff )<small
                    lsb = abs1( salpha )>=safmin .and. abs1( bcoeff )<small
                    scale = one
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs1( salpha ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoeff ),abs1( bcoeff ) ) &
                                 ) )
                       if( lsa ) then
                          acoeff = ascale*( scale*sbeta )
                       else
                          acoeff = scale*acoeff
                       end if
                       if( lsb ) then
                          bcoeff = bscale*( scale*salpha )
                       else
                          bcoeff = scale*bcoeff
                       end if
                    end if
                    acoefa = abs( acoeff )
                    bcoefa = abs1( bcoeff )
                    xmax = one
                    do jr = 1, n
                       work( jr ) = czero
                    end do
                    work( je ) = cone
                    dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                                                    ! h
                    ! triangular solve of  (a a - b b)  y = 0
                                            ! h
                    ! (rowwise in  (a a - b b) , or columnwise in a a - b b)
                    loop_100: do j = je + 1, n
                       ! compute
                             ! j-1
                       ! sum = sum  conjg( a*s(k,j) - b*p(k,j) )*x(k)
                             ! k=je
                       ! (scale if necessary)
                       temp = one / xmax
                       if( acoefa*rwork( j )+bcoefa*rwork( n+j )>bignum*temp ) then
                          do jr = je, j - 1
                             work( jr ) = temp*work( jr )
                          end do
                          xmax = one
                       end if
                       suma = czero
                       sumb = czero
                       do jr = je, j - 1
                          suma = suma + conjg( s( jr, j ) )*work( jr )
                          sumb = sumb + conjg( p( jr, j ) )*work( jr )
                       end do
                       sum = acoeff*suma - conjg( bcoeff )*sumb
                       ! form x(j) = - sum / conjg( a*s(j,j) - b*p(j,j) )
                       ! with scaling and perturbation of the denominator
                       d = conjg( acoeff*s( j, j )-bcoeff*p( j, j ) )
                       if( abs1( d )<=dmin )d = cmplx( dmin,KIND=sp)
                       if( abs1( d )<one ) then
                          if( abs1( sum )>=bignum*abs1( d ) ) then
                             temp = one / abs1( sum )
                             do jr = je, j - 1
                                work( jr ) = temp*work( jr )
                             end do
                             xmax = temp*xmax
                             sum = temp*sum
                          end if
                       end if
                       work( j ) = stdlib_cladiv( -sum, d )
                       xmax = max( xmax, abs1( work( j ) ) )
                    end do loop_100
                    ! back transform eigenvector if howmny='b'.
                    if( ilback ) then
                       call stdlib_cgemv( 'N', n, n+1-je, cone, vl( 1, je ), ldvl,work( je ), 1, &
                                 czero, work( n+1 ), 1 )
                       isrc = 2
                       ibeg = 1
                    else
                       isrc = 1
                       ibeg = je
                    end if
                    ! copy and scale eigenvector into column of vl
                    xmax = zero
                    do jr = ibeg, n
                       xmax = max( xmax, abs1( work( ( isrc-1 )*n+jr ) ) )
                    end do
                    if( xmax>safmin ) then
                       temp = one / xmax
                       do jr = ibeg, n
                          vl( jr, ieig ) = temp*work( ( isrc-1 )*n+jr )
                       end do
                    else
                       ibeg = n + 1
                    end if
                    do jr = 1, ibeg - 1
                       vl( jr, ieig ) = czero
                    end do
                 end if
              end do loop_140
           end if
           ! right eigenvectors
           if( compr ) then
              ieig = im + 1
              ! main loop over eigenvalues
              loop_250: do je = n, 1, -1
                 if( ilall ) then
                    ilcomp = .true.
                 else
                    ilcomp = select( je )
                 end if
                 if( ilcomp ) then
                    ieig = ieig - 1
                    if( abs1( s( je, je ) )<=safmin .and.abs( real( p( je, je ),KIND=sp) )&
                              <=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       do jr = 1, n
                          vr( jr, ieig ) = czero
                       end do
                       vr( ieig, ieig ) = cone
                       cycle loop_250
                    end if
                    ! non-singular eigenvalue:
                    ! compute coefficients  a  and  b  in
                    ! ( a a - b b ) x  = 0
                    temp = one / max( abs1( s( je, je ) )*ascale,abs( real( p( je, je ),KIND=sp) )&
                              *bscale, safmin )
                    salpha = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*real( p( je, je ),KIND=sp) )*bscale
                    acoeff = sbeta*ascale
                    bcoeff = salpha*bscale
                    ! scale to avoid underflow
                    lsa = abs( sbeta )>=safmin .and. abs( acoeff )<small
                    lsb = abs1( salpha )>=safmin .and. abs1( bcoeff )<small
                    scale = one
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs1( salpha ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoeff ),abs1( bcoeff ) ) &
                                 ) )
                       if( lsa ) then
                          acoeff = ascale*( scale*sbeta )
                       else
                          acoeff = scale*acoeff
                       end if
                       if( lsb ) then
                          bcoeff = bscale*( scale*salpha )
                       else
                          bcoeff = scale*bcoeff
                       end if
                    end if
                    acoefa = abs( acoeff )
                    bcoefa = abs1( bcoeff )
                    xmax = one
                    do jr = 1, n
                       work( jr ) = czero
                    end do
                    work( je ) = cone
                    dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                    ! triangular solve of  (a a - b b) x = 0  (columnwise)
                    ! work(1:j-1) contains sums w,
                    ! work(j+1:je) contains x
                    do jr = 1, je - 1
                       work( jr ) = acoeff*s( jr, je ) - bcoeff*p( jr, je )
                    end do
                    work( je ) = cone
                    loop_210: do j = je - 1, 1, -1
                       ! form x(j) := - w(j) / d
                       ! with scaling and perturbation of the denominator
                       d = acoeff*s( j, j ) - bcoeff*p( j, j )
                       if( abs1( d )<=dmin )d = cmplx( dmin,KIND=sp)
                       if( abs1( d )<one ) then
                          if( abs1( work( j ) )>=bignum*abs1( d ) ) then
                             temp = one / abs1( work( j ) )
                             do jr = 1, je
                                work( jr ) = temp*work( jr )
                             end do
                          end if
                       end if
                       work( j ) = stdlib_cladiv( -work( j ), d )
                       if( j>1 ) then
                          ! w = w + x(j)*(a s(*,j) - b p(*,j) ) with scaling
                          if( abs1( work( j ) )>one ) then
                             temp = one / abs1( work( j ) )
                             if( acoefa*rwork( j )+bcoefa*rwork( n+j )>=bignum*temp ) then
                                do jr = 1, je
                                   work( jr ) = temp*work( jr )
                                end do
                             end if
                          end if
                          ca = acoeff*work( j )
                          cb = bcoeff*work( j )
                          do jr = 1, j - 1
                             work( jr ) = work( jr ) + ca*s( jr, j ) -cb*p( jr, j )
                          end do
                       end if
                    end do loop_210
                    ! back transform eigenvector if howmny='b'.
                    if( ilback ) then
                       call stdlib_cgemv( 'N', n, je, cone, vr, ldvr, work, 1,czero, work( n+1 ), &
                                 1 )
                       isrc = 2
                       iend = n
                    else
                       isrc = 1
                       iend = je
                    end if
                    ! copy and scale eigenvector into column of vr
                    xmax = zero
                    do jr = 1, iend
                       xmax = max( xmax, abs1( work( ( isrc-1 )*n+jr ) ) )
                    end do
                    if( xmax>safmin ) then
                       temp = one / xmax
                       do jr = 1, iend
                          vr( jr, ieig ) = temp*work( ( isrc-1 )*n+jr )
                       end do
                    else
                       iend = 0
                    end if
                    do jr = iend + 1, n
                       vr( jr, ieig ) = czero
                    end do
                 end if
              end do loop_250
           end if
           return
     end subroutine stdlib_ctgevc

     module pure subroutine stdlib_ztgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
     !! ZTGEVC computes some or all of the right and/or left eigenvectors of
     !! a pair of complex matrices (S,P), where S and P are upper triangular.
     !! Matrix pairs of this type are produced by the generalized Schur
     !! factorization of a complex matrix pair (A,B):
     !! A = Q*S*Z**H,  B = Q*P*Z**H
     !! as computed by ZGGHRD + ZHGEQZ.
     !! The right eigenvector x and the left eigenvector y of (S,P)
     !! corresponding to an eigenvalue w are defined by:
     !! S*x = w*P*x,  (y**H)*S = w*(y**H)*P,
     !! where y**H denotes the conjugate tranpose of y.
     !! The eigenvalues are not input to this routine, but are computed
     !! directly from the diagonal elements of S and P.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of (S,P), or the products Z*X and/or Q*Y,
     !! where Z and Q are input matrices.
     !! If Q and Z are the unitary factors from the generalized Schur
     !! factorization of a matrix pair (A,B), then Z*X and Q*Y
     !! are the matrices of right and left eigenvectors of (A,B).
               mm, m, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(dp), intent(out) :: rwork(*)
           complex(dp), intent(in) :: p(ldp,*), s(lds,*)
           complex(dp), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: compl, compr, ilall, ilback, ilbbad, ilcomp, lsa, lsb
           integer(ilp) :: i, ibeg, ieig, iend, ihwmny, im, iside, isrc, j, je, jr
           real(dp) :: acoefa, acoeff, anorm, ascale, bcoefa, big, bignum, bnorm, bscale, dmin, &
                     safmin, sbeta, scale, small, temp, ulp, xmax
           complex(dp) :: bcoeff, ca, cb, d, salpha, sum, suma, sumb, x
           ! Intrinsic Functions 
           ! Statement Functions 
           real(dp) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=dp) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode and test the input parameters
           if( stdlib_lsame( howmny, 'A' ) ) then
              ihwmny = 1
              ilall = .true.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'S' ) ) then
              ihwmny = 2
              ilall = .false.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'B' ) ) then
              ihwmny = 3
              ilall = .true.
              ilback = .true.
           else
              ihwmny = -1
           end if
           if( stdlib_lsame( side, 'R' ) ) then
              iside = 1
              compl = .false.
              compr = .true.
           else if( stdlib_lsame( side, 'L' ) ) then
              iside = 2
              compl = .true.
              compr = .false.
           else if( stdlib_lsame( side, 'B' ) ) then
              iside = 3
              compl = .true.
              compr = .true.
           else
              iside = -1
           end if
           info = 0
           if( iside<0 ) then
              info = -1
           else if( ihwmny<0 ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lds<max( 1, n ) ) then
              info = -6
           else if( ldp<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGEVC', -info )
              return
           end if
           ! count the number of eigenvectors
           if( .not.ilall ) then
              im = 0
              do j = 1, n
                 if( select( j ) )im = im + 1
              end do
           else
              im = n
           end if
           ! check diagonal of b
           ilbbad = .false.
           do j = 1, n
              if( aimag( p( j, j ) )/=zero )ilbbad = .true.
           end do
           if( ilbbad ) then
              info = -7
           else if( compl .and. ldvl<n .or. ldvl<1 ) then
              info = -10
           else if( compr .and. ldvr<n .or. ldvr<1 ) then
              info = -12
           else if( mm<im ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGEVC', -info )
              return
           end if
           ! quick return if possible
           m = im
           if( n==0 )return
           ! machine constants
           safmin = stdlib_dlamch( 'SAFE MINIMUM' )
           big = one / safmin
           call stdlib_dlabad( safmin, big )
           ulp = stdlib_dlamch( 'EPSILON' )*stdlib_dlamch( 'BASE' )
           small = safmin*n / ulp
           big = one / small
           bignum = one / ( safmin*n )
           ! compute the 1-norm of each column of the strictly upper triangular
           ! part of a and b to check for possible overflow in the triangular
           ! solver.
           anorm = abs1( s( 1, 1 ) )
           bnorm = abs1( p( 1, 1 ) )
           rwork( 1 ) = zero
           rwork( n+1 ) = zero
           do j = 2, n
              rwork( j ) = zero
              rwork( n+j ) = zero
              do i = 1, j - 1
                 rwork( j ) = rwork( j ) + abs1( s( i, j ) )
                 rwork( n+j ) = rwork( n+j ) + abs1( p( i, j ) )
              end do
              anorm = max( anorm, rwork( j )+abs1( s( j, j ) ) )
              bnorm = max( bnorm, rwork( n+j )+abs1( p( j, j ) ) )
           end do
           ascale = one / max( anorm, safmin )
           bscale = one / max( bnorm, safmin )
           ! left eigenvectors
           if( compl ) then
              ieig = 0
              ! main loop over eigenvalues
              loop_140: do je = 1, n
                 if( ilall ) then
                    ilcomp = .true.
                 else
                    ilcomp = select( je )
                 end if
                 if( ilcomp ) then
                    ieig = ieig + 1
                    if( abs1( s( je, je ) )<=safmin .and.abs( real( p( je, je ),KIND=dp) )&
                              <=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       do jr = 1, n
                          vl( jr, ieig ) = czero
                       end do
                       vl( ieig, ieig ) = cone
                       cycle loop_140
                    end if
                    ! non-singular eigenvalue:
                    ! compute coefficients  a  and  b  in
                         ! h
                       ! y  ( a a - b b ) = 0
                    temp = one / max( abs1( s( je, je ) )*ascale,abs( real( p( je, je ),KIND=dp) )&
                              *bscale, safmin )
                    salpha = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*real( p( je, je ),KIND=dp) )*bscale
                    acoeff = sbeta*ascale
                    bcoeff = salpha*bscale
                    ! scale to avoid underflow
                    lsa = abs( sbeta )>=safmin .and. abs( acoeff )<small
                    lsb = abs1( salpha )>=safmin .and. abs1( bcoeff )<small
                    scale = one
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs1( salpha ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoeff ),abs1( bcoeff ) ) &
                                 ) )
                       if( lsa ) then
                          acoeff = ascale*( scale*sbeta )
                       else
                          acoeff = scale*acoeff
                       end if
                       if( lsb ) then
                          bcoeff = bscale*( scale*salpha )
                       else
                          bcoeff = scale*bcoeff
                       end if
                    end if
                    acoefa = abs( acoeff )
                    bcoefa = abs1( bcoeff )
                    xmax = one
                    do jr = 1, n
                       work( jr ) = czero
                    end do
                    work( je ) = cone
                    dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                                                    ! h
                    ! triangular solve of  (a a - b b)  y = 0
                                            ! h
                    ! (rowwise in  (a a - b b) , or columnwise in a a - b b)
                    loop_100: do j = je + 1, n
                       ! compute
                             ! j-1
                       ! sum = sum  conjg( a*s(k,j) - b*p(k,j) )*x(k)
                             ! k=je
                       ! (scale if necessary)
                       temp = one / xmax
                       if( acoefa*rwork( j )+bcoefa*rwork( n+j )>bignum*temp ) then
                          do jr = je, j - 1
                             work( jr ) = temp*work( jr )
                          end do
                          xmax = one
                       end if
                       suma = czero
                       sumb = czero
                       do jr = je, j - 1
                          suma = suma + conjg( s( jr, j ) )*work( jr )
                          sumb = sumb + conjg( p( jr, j ) )*work( jr )
                       end do
                       sum = acoeff*suma - conjg( bcoeff )*sumb
                       ! form x(j) = - sum / conjg( a*s(j,j) - b*p(j,j) )
                       ! with scaling and perturbation of the denominator
                       d = conjg( acoeff*s( j, j )-bcoeff*p( j, j ) )
                       if( abs1( d )<=dmin )d = cmplx( dmin,KIND=dp)
                       if( abs1( d )<one ) then
                          if( abs1( sum )>=bignum*abs1( d ) ) then
                             temp = one / abs1( sum )
                             do jr = je, j - 1
                                work( jr ) = temp*work( jr )
                             end do
                             xmax = temp*xmax
                             sum = temp*sum
                          end if
                       end if
                       work( j ) = stdlib_zladiv( -sum, d )
                       xmax = max( xmax, abs1( work( j ) ) )
                    end do loop_100
                    ! back transform eigenvector if howmny='b'.
                    if( ilback ) then
                       call stdlib_zgemv( 'N', n, n+1-je, cone, vl( 1, je ), ldvl,work( je ), 1, &
                                 czero, work( n+1 ), 1 )
                       isrc = 2
                       ibeg = 1
                    else
                       isrc = 1
                       ibeg = je
                    end if
                    ! copy and scale eigenvector into column of vl
                    xmax = zero
                    do jr = ibeg, n
                       xmax = max( xmax, abs1( work( ( isrc-1 )*n+jr ) ) )
                    end do
                    if( xmax>safmin ) then
                       temp = one / xmax
                       do jr = ibeg, n
                          vl( jr, ieig ) = temp*work( ( isrc-1 )*n+jr )
                       end do
                    else
                       ibeg = n + 1
                    end if
                    do jr = 1, ibeg - 1
                       vl( jr, ieig ) = czero
                    end do
                 end if
              end do loop_140
           end if
           ! right eigenvectors
           if( compr ) then
              ieig = im + 1
              ! main loop over eigenvalues
              loop_250: do je = n, 1, -1
                 if( ilall ) then
                    ilcomp = .true.
                 else
                    ilcomp = select( je )
                 end if
                 if( ilcomp ) then
                    ieig = ieig - 1
                    if( abs1( s( je, je ) )<=safmin .and.abs( real( p( je, je ),KIND=dp) )&
                              <=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       do jr = 1, n
                          vr( jr, ieig ) = czero
                       end do
                       vr( ieig, ieig ) = cone
                       cycle loop_250
                    end if
                    ! non-singular eigenvalue:
                    ! compute coefficients  a  and  b  in
                    ! ( a a - b b ) x  = 0
                    temp = one / max( abs1( s( je, je ) )*ascale,abs( real( p( je, je ),KIND=dp) )&
                              *bscale, safmin )
                    salpha = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*real( p( je, je ),KIND=dp) )*bscale
                    acoeff = sbeta*ascale
                    bcoeff = salpha*bscale
                    ! scale to avoid underflow
                    lsa = abs( sbeta )>=safmin .and. abs( acoeff )<small
                    lsb = abs1( salpha )>=safmin .and. abs1( bcoeff )<small
                    scale = one
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs1( salpha ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoeff ),abs1( bcoeff ) ) &
                                 ) )
                       if( lsa ) then
                          acoeff = ascale*( scale*sbeta )
                       else
                          acoeff = scale*acoeff
                       end if
                       if( lsb ) then
                          bcoeff = bscale*( scale*salpha )
                       else
                          bcoeff = scale*bcoeff
                       end if
                    end if
                    acoefa = abs( acoeff )
                    bcoefa = abs1( bcoeff )
                    xmax = one
                    do jr = 1, n
                       work( jr ) = czero
                    end do
                    work( je ) = cone
                    dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                    ! triangular solve of  (a a - b b) x = 0  (columnwise)
                    ! work(1:j-1) contains sums w,
                    ! work(j+1:je) contains x
                    do jr = 1, je - 1
                       work( jr ) = acoeff*s( jr, je ) - bcoeff*p( jr, je )
                    end do
                    work( je ) = cone
                    loop_210: do j = je - 1, 1, -1
                       ! form x(j) := - w(j) / d
                       ! with scaling and perturbation of the denominator
                       d = acoeff*s( j, j ) - bcoeff*p( j, j )
                       if( abs1( d )<=dmin )d = cmplx( dmin,KIND=dp)
                       if( abs1( d )<one ) then
                          if( abs1( work( j ) )>=bignum*abs1( d ) ) then
                             temp = one / abs1( work( j ) )
                             do jr = 1, je
                                work( jr ) = temp*work( jr )
                             end do
                          end if
                       end if
                       work( j ) = stdlib_zladiv( -work( j ), d )
                       if( j>1 ) then
                          ! w = w + x(j)*(a s(*,j) - b p(*,j) ) with scaling
                          if( abs1( work( j ) )>one ) then
                             temp = one / abs1( work( j ) )
                             if( acoefa*rwork( j )+bcoefa*rwork( n+j )>=bignum*temp ) then
                                do jr = 1, je
                                   work( jr ) = temp*work( jr )
                                end do
                             end if
                          end if
                          ca = acoeff*work( j )
                          cb = bcoeff*work( j )
                          do jr = 1, j - 1
                             work( jr ) = work( jr ) + ca*s( jr, j ) -cb*p( jr, j )
                          end do
                       end if
                    end do loop_210
                    ! back transform eigenvector if howmny='b'.
                    if( ilback ) then
                       call stdlib_zgemv( 'N', n, je, cone, vr, ldvr, work, 1,czero, work( n+1 ), &
                                 1 )
                       isrc = 2
                       iend = n
                    else
                       isrc = 1
                       iend = je
                    end if
                    ! copy and scale eigenvector into column of vr
                    xmax = zero
                    do jr = 1, iend
                       xmax = max( xmax, abs1( work( ( isrc-1 )*n+jr ) ) )
                    end do
                    if( xmax>safmin ) then
                       temp = one / xmax
                       do jr = 1, iend
                          vr( jr, ieig ) = temp*work( ( isrc-1 )*n+jr )
                       end do
                    else
                       iend = 0
                    end if
                    do jr = iend + 1, n
                       vr( jr, ieig ) = czero
                    end do
                 end if
              end do loop_250
           end if
           return
     end subroutine stdlib_ztgevc

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$tgevc( side, howmny, select, n, s, lds, p, ldp, vl,ldvl, vr, ldvr, &
     !! ZTGEVC: computes some or all of the right and/or left eigenvectors of
     !! a pair of complex matrices (S,P), where S and P are upper triangular.
     !! Matrix pairs of this type are produced by the generalized Schur
     !! factorization of a complex matrix pair (A,B):
     !! A = Q*S*Z**H,  B = Q*P*Z**H
     !! as computed by ZGGHRD + ZHGEQZ.
     !! The right eigenvector x and the left eigenvector y of (S,P)
     !! corresponding to an eigenvalue w are defined by:
     !! S*x = w*P*x,  (y**H)*S = w*(y**H)*P,
     !! where y**H denotes the conjugate tranpose of y.
     !! The eigenvalues are not input to this routine, but are computed
     !! directly from the diagonal elements of S and P.
     !! This routine returns the matrices X and/or Y of right and left
     !! eigenvectors of (S,P), or the products Z*X and/or Q*Y,
     !! where Z and Q are input matrices.
     !! If Q and Z are the unitary factors from the generalized Schur
     !! factorization of a matrix pair (A,B), then Z*X and Q*Y
     !! are the matrices of right and left eigenvectors of (A,B).
               mm, m, work, rwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, side
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: ldp, lds, ldvl, ldvr, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           real(${ck}$), intent(out) :: rwork(*)
           complex(${ck}$), intent(in) :: p(ldp,*), s(lds,*)
           complex(${ck}$), intent(inout) :: vl(ldvl,*), vr(ldvr,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           
           
           ! Local Scalars 
           logical(lk) :: compl, compr, ilall, ilback, ilbbad, ilcomp, lsa, lsb
           integer(ilp) :: i, ibeg, ieig, iend, ihwmny, im, iside, isrc, j, je, jr
           real(${ck}$) :: acoefa, acoeff, anorm, ascale, bcoefa, big, bignum, bnorm, bscale, dmin, &
                     safmin, sbeta, scale, small, temp, ulp, xmax
           complex(${ck}$) :: bcoeff, ca, cb, d, salpha, sum, suma, sumb, x
           ! Intrinsic Functions 
           ! Statement Functions 
           real(${ck}$) :: abs1
           ! Statement Function Definitions 
           abs1( x ) = abs( real( x,KIND=${ck}$) ) + abs( aimag( x ) )
           ! Executable Statements 
           ! decode and test the input parameters
           if( stdlib_lsame( howmny, 'A' ) ) then
              ihwmny = 1
              ilall = .true.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'S' ) ) then
              ihwmny = 2
              ilall = .false.
              ilback = .false.
           else if( stdlib_lsame( howmny, 'B' ) ) then
              ihwmny = 3
              ilall = .true.
              ilback = .true.
           else
              ihwmny = -1
           end if
           if( stdlib_lsame( side, 'R' ) ) then
              iside = 1
              compl = .false.
              compr = .true.
           else if( stdlib_lsame( side, 'L' ) ) then
              iside = 2
              compl = .true.
              compr = .false.
           else if( stdlib_lsame( side, 'B' ) ) then
              iside = 3
              compl = .true.
              compr = .true.
           else
              iside = -1
           end if
           info = 0
           if( iside<0 ) then
              info = -1
           else if( ihwmny<0 ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lds<max( 1, n ) ) then
              info = -6
           else if( ldp<max( 1, n ) ) then
              info = -8
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGEVC', -info )
              return
           end if
           ! count the number of eigenvectors
           if( .not.ilall ) then
              im = 0
              do j = 1, n
                 if( select( j ) )im = im + 1
              end do
           else
              im = n
           end if
           ! check diagonal of b
           ilbbad = .false.
           do j = 1, n
              if( aimag( p( j, j ) )/=zero )ilbbad = .true.
           end do
           if( ilbbad ) then
              info = -7
           else if( compl .and. ldvl<n .or. ldvl<1 ) then
              info = -10
           else if( compr .and. ldvr<n .or. ldvr<1 ) then
              info = -12
           else if( mm<im ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGEVC', -info )
              return
           end if
           ! quick return if possible
           m = im
           if( n==0 )return
           ! machine constants
           safmin = stdlib_${c2ri(ci)}$lamch( 'SAFE MINIMUM' )
           big = one / safmin
           call stdlib_${c2ri(ci)}$labad( safmin, big )
           ulp = stdlib_${c2ri(ci)}$lamch( 'EPSILON' )*stdlib_${c2ri(ci)}$lamch( 'BASE' )
           small = safmin*n / ulp
           big = one / small
           bignum = one / ( safmin*n )
           ! compute the 1-norm of each column of the strictly upper triangular
           ! part of a and b to check for possible overflow in the triangular
           ! solver.
           anorm = abs1( s( 1, 1 ) )
           bnorm = abs1( p( 1, 1 ) )
           rwork( 1 ) = zero
           rwork( n+1 ) = zero
           do j = 2, n
              rwork( j ) = zero
              rwork( n+j ) = zero
              do i = 1, j - 1
                 rwork( j ) = rwork( j ) + abs1( s( i, j ) )
                 rwork( n+j ) = rwork( n+j ) + abs1( p( i, j ) )
              end do
              anorm = max( anorm, rwork( j )+abs1( s( j, j ) ) )
              bnorm = max( bnorm, rwork( n+j )+abs1( p( j, j ) ) )
           end do
           ascale = one / max( anorm, safmin )
           bscale = one / max( bnorm, safmin )
           ! left eigenvectors
           if( compl ) then
              ieig = 0
              ! main loop over eigenvalues
              loop_140: do je = 1, n
                 if( ilall ) then
                    ilcomp = .true.
                 else
                    ilcomp = select( je )
                 end if
                 if( ilcomp ) then
                    ieig = ieig + 1
                    if( abs1( s( je, je ) )<=safmin .and.abs( real( p( je, je ),KIND=${ck}$) )&
                              <=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       do jr = 1, n
                          vl( jr, ieig ) = czero
                       end do
                       vl( ieig, ieig ) = cone
                       cycle loop_140
                    end if
                    ! non-singular eigenvalue:
                    ! compute coefficients  a  and  b  in
                         ! h
                       ! y  ( a a - b b ) = 0
                    temp = one / max( abs1( s( je, je ) )*ascale,abs( real( p( je, je ),KIND=${ck}$) )&
                              *bscale, safmin )
                    salpha = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*real( p( je, je ),KIND=${ck}$) )*bscale
                    acoeff = sbeta*ascale
                    bcoeff = salpha*bscale
                    ! scale to avoid underflow
                    lsa = abs( sbeta )>=safmin .and. abs( acoeff )<small
                    lsb = abs1( salpha )>=safmin .and. abs1( bcoeff )<small
                    scale = one
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs1( salpha ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoeff ),abs1( bcoeff ) ) &
                                 ) )
                       if( lsa ) then
                          acoeff = ascale*( scale*sbeta )
                       else
                          acoeff = scale*acoeff
                       end if
                       if( lsb ) then
                          bcoeff = bscale*( scale*salpha )
                       else
                          bcoeff = scale*bcoeff
                       end if
                    end if
                    acoefa = abs( acoeff )
                    bcoefa = abs1( bcoeff )
                    xmax = one
                    do jr = 1, n
                       work( jr ) = czero
                    end do
                    work( je ) = cone
                    dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                                                    ! h
                    ! triangular solve of  (a a - b b)  y = 0
                                            ! h
                    ! (rowwise in  (a a - b b) , or columnwise in a a - b b)
                    loop_100: do j = je + 1, n
                       ! compute
                             ! j-1
                       ! sum = sum  conjg( a*s(k,j) - b*p(k,j) )*x(k)
                             ! k=je
                       ! (scale if necessary)
                       temp = one / xmax
                       if( acoefa*rwork( j )+bcoefa*rwork( n+j )>bignum*temp ) then
                          do jr = je, j - 1
                             work( jr ) = temp*work( jr )
                          end do
                          xmax = one
                       end if
                       suma = czero
                       sumb = czero
                       do jr = je, j - 1
                          suma = suma + conjg( s( jr, j ) )*work( jr )
                          sumb = sumb + conjg( p( jr, j ) )*work( jr )
                       end do
                       sum = acoeff*suma - conjg( bcoeff )*sumb
                       ! form x(j) = - sum / conjg( a*s(j,j) - b*p(j,j) )
                       ! with scaling and perturbation of the denominator
                       d = conjg( acoeff*s( j, j )-bcoeff*p( j, j ) )
                       if( abs1( d )<=dmin )d = cmplx( dmin,KIND=${ck}$)
                       if( abs1( d )<one ) then
                          if( abs1( sum )>=bignum*abs1( d ) ) then
                             temp = one / abs1( sum )
                             do jr = je, j - 1
                                work( jr ) = temp*work( jr )
                             end do
                             xmax = temp*xmax
                             sum = temp*sum
                          end if
                       end if
                       work( j ) = stdlib_${ci}$ladiv( -sum, d )
                       xmax = max( xmax, abs1( work( j ) ) )
                    end do loop_100
                    ! back transform eigenvector if howmny='b'.
                    if( ilback ) then
                       call stdlib_${ci}$gemv( 'N', n, n+1-je, cone, vl( 1, je ), ldvl,work( je ), 1, &
                                 czero, work( n+1 ), 1 )
                       isrc = 2
                       ibeg = 1
                    else
                       isrc = 1
                       ibeg = je
                    end if
                    ! copy and scale eigenvector into column of vl
                    xmax = zero
                    do jr = ibeg, n
                       xmax = max( xmax, abs1( work( ( isrc-1 )*n+jr ) ) )
                    end do
                    if( xmax>safmin ) then
                       temp = one / xmax
                       do jr = ibeg, n
                          vl( jr, ieig ) = temp*work( ( isrc-1 )*n+jr )
                       end do
                    else
                       ibeg = n + 1
                    end if
                    do jr = 1, ibeg - 1
                       vl( jr, ieig ) = czero
                    end do
                 end if
              end do loop_140
           end if
           ! right eigenvectors
           if( compr ) then
              ieig = im + 1
              ! main loop over eigenvalues
              loop_250: do je = n, 1, -1
                 if( ilall ) then
                    ilcomp = .true.
                 else
                    ilcomp = select( je )
                 end if
                 if( ilcomp ) then
                    ieig = ieig - 1
                    if( abs1( s( je, je ) )<=safmin .and.abs( real( p( je, je ),KIND=${ck}$) )&
                              <=safmin ) then
                       ! singular matrix pencil -- return unit eigenvector
                       do jr = 1, n
                          vr( jr, ieig ) = czero
                       end do
                       vr( ieig, ieig ) = cone
                       cycle loop_250
                    end if
                    ! non-singular eigenvalue:
                    ! compute coefficients  a  and  b  in
                    ! ( a a - b b ) x  = 0
                    temp = one / max( abs1( s( je, je ) )*ascale,abs( real( p( je, je ),KIND=${ck}$) )&
                              *bscale, safmin )
                    salpha = ( temp*s( je, je ) )*ascale
                    sbeta = ( temp*real( p( je, je ),KIND=${ck}$) )*bscale
                    acoeff = sbeta*ascale
                    bcoeff = salpha*bscale
                    ! scale to avoid underflow
                    lsa = abs( sbeta )>=safmin .and. abs( acoeff )<small
                    lsb = abs1( salpha )>=safmin .and. abs1( bcoeff )<small
                    scale = one
                    if( lsa )scale = ( small / abs( sbeta ) )*min( anorm, big )
                    if( lsb )scale = max( scale, ( small / abs1( salpha ) )*min( bnorm, big ) )
                              
                    if( lsa .or. lsb ) then
                       scale = min( scale, one /( safmin*max( one, abs( acoeff ),abs1( bcoeff ) ) &
                                 ) )
                       if( lsa ) then
                          acoeff = ascale*( scale*sbeta )
                       else
                          acoeff = scale*acoeff
                       end if
                       if( lsb ) then
                          bcoeff = bscale*( scale*salpha )
                       else
                          bcoeff = scale*bcoeff
                       end if
                    end if
                    acoefa = abs( acoeff )
                    bcoefa = abs1( bcoeff )
                    xmax = one
                    do jr = 1, n
                       work( jr ) = czero
                    end do
                    work( je ) = cone
                    dmin = max( ulp*acoefa*anorm, ulp*bcoefa*bnorm, safmin )
                    ! triangular solve of  (a a - b b) x = 0  (columnwise)
                    ! work(1:j-1) contains sums w,
                    ! work(j+1:je) contains x
                    do jr = 1, je - 1
                       work( jr ) = acoeff*s( jr, je ) - bcoeff*p( jr, je )
                    end do
                    work( je ) = cone
                    loop_210: do j = je - 1, 1, -1
                       ! form x(j) := - w(j) / d
                       ! with scaling and perturbation of the denominator
                       d = acoeff*s( j, j ) - bcoeff*p( j, j )
                       if( abs1( d )<=dmin )d = cmplx( dmin,KIND=${ck}$)
                       if( abs1( d )<one ) then
                          if( abs1( work( j ) )>=bignum*abs1( d ) ) then
                             temp = one / abs1( work( j ) )
                             do jr = 1, je
                                work( jr ) = temp*work( jr )
                             end do
                          end if
                       end if
                       work( j ) = stdlib_${ci}$ladiv( -work( j ), d )
                       if( j>1 ) then
                          ! w = w + x(j)*(a s(*,j) - b p(*,j) ) with scaling
                          if( abs1( work( j ) )>one ) then
                             temp = one / abs1( work( j ) )
                             if( acoefa*rwork( j )+bcoefa*rwork( n+j )>=bignum*temp ) then
                                do jr = 1, je
                                   work( jr ) = temp*work( jr )
                                end do
                             end if
                          end if
                          ca = acoeff*work( j )
                          cb = bcoeff*work( j )
                          do jr = 1, j - 1
                             work( jr ) = work( jr ) + ca*s( jr, j ) -cb*p( jr, j )
                          end do
                       end if
                    end do loop_210
                    ! back transform eigenvector if howmny='b'.
                    if( ilback ) then
                       call stdlib_${ci}$gemv( 'N', n, je, cone, vr, ldvr, work, 1,czero, work( n+1 ), &
                                 1 )
                       isrc = 2
                       iend = n
                    else
                       isrc = 1
                       iend = je
                    end if
                    ! copy and scale eigenvector into column of vr
                    xmax = zero
                    do jr = 1, iend
                       xmax = max( xmax, abs1( work( ( isrc-1 )*n+jr ) ) )
                    end do
                    if( xmax>safmin ) then
                       temp = one / xmax
                       do jr = 1, iend
                          vr( jr, ieig ) = temp*work( ( isrc-1 )*n+jr )
                       end do
                    else
                       iend = 0
                    end if
                    do jr = iend + 1, n
                       vr( jr, ieig ) = czero
                    end do
                 end if
              end do loop_250
           end if
           return
     end subroutine stdlib_${ci}$tgevc

#:endif
#:endfor



     module pure subroutine stdlib_stgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alphar, alphai, &
     !! STGSEN reorders the generalized real Schur decomposition of a real
     !! matrix pair (A, B) (in terms of an orthonormal equivalence trans-
     !! formation Q**T * (A, B) * Z), so that a selected cluster of eigenvalues
     !! appears in the leading diagonal blocks of the upper quasi-triangular
     !! matrix A and the upper triangular B. The leading columns of Q and
     !! Z form orthonormal bases of the corresponding left and right eigen-
     !! spaces (deflating subspaces). (A, B) must be in generalized real
     !! Schur canonical form (as returned by SGGES), i.e. A is block upper
     !! triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper
     !! triangular.
     !! STGSEN also computes the generalized eigenvalues
     !! w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
     !! of the reordered matrix pair (A, B).
     !! Optionally, STGSEN computes the estimates of reciprocal condition
     !! numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
     !! (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
     !! between the matrix pairs (A11, B11) and (A22,B22) that correspond to
     !! the selected cluster and the eigenvalues outside the cluster, resp.,
     !! and norms of "projections" onto left and right eigenspaces w.r.t.
     !! the selected cluster in the (1,1)-block.
               beta, q, ldq, z, ldz, m, pl,pr, dif, work, lwork, iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(out) :: pl, pr
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(sp), intent(out) :: alphai(*), alphar(*), beta(*), dif(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, pair, swap, wantd, wantd1, wantd2, wantp
           integer(ilp) :: i, ierr, ijb, k, kase, kk, ks, liwmin, lwmin, mn2, n1, n2
           real(sp) :: dscale, dsum, eps, rdscal, smlnum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           info = 0
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( ijob<0 .or. ijob>5 ) then
              info = -1
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -14
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STGSEN', -info )
              return
           end if
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           ierr = 0
           wantp = ijob==1 .or. ijob>=4
           wantd1 = ijob==2 .or. ijob==4
           wantd2 = ijob==3 .or. ijob==5
           wantd = wantd1 .or. wantd2
           ! set m to the dimension of the specified pair of deflating
           ! subspaces.
           m = 0
           pair = .false.
           if( .not.lquery .or. ijob/=0 ) then
           do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 if( k<n ) then
                    if( a( k+1, k )==zero ) then
                       if( select( k ) )m = m + 1
                    else
                       pair = .true.
                       if( select( k ) .or. select( k+1 ) )m = m + 2
                    end if
                 else
                    if( select( n ) )m = m + 1
                 end if
              end if
           end do
           end if
           if( ijob==1 .or. ijob==2 .or. ijob==4 ) then
              lwmin = max( 1, 4*n+16, 2*m*(n-m) )
              liwmin = max( 1, n+6 )
           else if( ijob==3 .or. ijob==5 ) then
              lwmin = max( 1, 4*n+16, 4*m*(n-m) )
              liwmin = max( 1, 2*m*(n-m), n+6 )
           else
              lwmin = max( 1, 4*n+16 )
              liwmin = 1
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           if( lwork<lwmin .and. .not.lquery ) then
              info = -22
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -24
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STGSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==n .or. m==0 ) then
              if( wantp ) then
                 pl = one
                 pr = one
              end if
              if( wantd ) then
                 dscale = zero
                 dsum = one
                 do i = 1, n
                    call stdlib_slassq( n, a( 1, i ), 1, dscale, dsum )
                    call stdlib_slassq( n, b( 1, i ), 1, dscale, dsum )
                 end do
                 dif( 1 ) = dscale*sqrt( dsum )
                 dif( 2 ) = dif( 1 )
              end if
              go to 60
           end if
           ! collect the selected blocks at the top-left corner of (a, b).
           ks = 0
           pair = .false.
           loop_30: do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 swap = select( k )
                 if( k<n ) then
                    if( a( k+1, k )/=zero ) then
                       pair = .true.
                       swap = swap .or. select( k+1 )
                    end if
                 end if
                 if( swap ) then
                    ks = ks + 1
                    ! swap the k-th block to position ks.
                    ! perform the reordering of diagonal blocks in (a, b)
                    ! by orthogonal transformation matrices and update
                    ! q and z accordingly (if requested):
                    kk = k
                    if( k/=ks )call stdlib_stgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz,&
                               kk, ks, work, lwork, ierr )
                    if( ierr>0 ) then
                       ! swap is rejected: exit.
                       info = 1
                       if( wantp ) then
                          pl = zero
                          pr = zero
                       end if
                       if( wantd ) then
                          dif( 1 ) = zero
                          dif( 2 ) = zero
                       end if
                       go to 60
                    end if
                    if( pair )ks = ks + 1
                 end if
              end if
           end do loop_30
           if( wantp ) then
              ! solve generalized sylvester equation for r and l
              ! and compute pl and pr.
              n1 = m
              n2 = n - m
              i = n1 + 1
              ijb = 0
              call stdlib_slacpy( 'FULL', n1, n2, a( 1, i ), lda, work, n1 )
              call stdlib_slacpy( 'FULL', n1, n2, b( 1, i ), ldb, work( n1*n2+1 ),n1 )
              call stdlib_stgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b( i,&
               i ), ldb, work( n1*n2+1 ), n1,dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-2*n1*n2, &
                         iwork, ierr )
              ! estimate the reciprocal of norms of "projections" onto left
              ! and right eigenspaces.
              rdscal = zero
              dsum = one
              call stdlib_slassq( n1*n2, work, 1, rdscal, dsum )
              pl = rdscal*sqrt( dsum )
              if( pl==zero ) then
                 pl = one
              else
                 pl = dscale / ( sqrt( dscale*dscale / pl+pl )*sqrt( pl ) )
              end if
              rdscal = zero
              dsum = one
              call stdlib_slassq( n1*n2, work( n1*n2+1 ), 1, rdscal, dsum )
              pr = rdscal*sqrt( dsum )
              if( pr==zero ) then
                 pr = one
              else
                 pr = dscale / ( sqrt( dscale*dscale / pr+pr )*sqrt( pr ) )
              end if
           end if
           if( wantd ) then
              ! compute estimates of difu and difl.
              if( wantd1 ) then
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = idifjb
                 ! frobenius norm-based difu-estimate.
                 call stdlib_stgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b(&
                  i, i ), ldb, work( n1*n2+1 ),n1, dscale, dif( 1 ), work( 2*n1*n2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
                 ! frobenius norm-based difl-estimate.
                 call stdlib_stgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda, work,n2, b( i, i ),&
                  ldb, b, ldb, work( n1*n2+1 ),n2, dscale, dif( 2 ), work( 2*n1*n2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
              else
                 ! compute 1-norm-based estimates of difu and difl using
                 ! reversed communication with stdlib_slacn2. in each step a
                 ! generalized sylvester equation or a transposed variant
                 ! is solved.
                 kase = 0
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = 0
                 mn2 = 2*n1*n2
                 ! 1-norm-based estimate of difu.
                 40 continue
                 call stdlib_slacn2( mn2, work( mn2+1 ), work, iwork, dif( 1 ),kase, isave )
                           
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation.
                       call stdlib_stgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_stgsyl( 'T', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 40
                 end if
                 dif( 1 ) = dscale / dif( 1 )
                 ! 1-norm-based estimate of difl.
                 50 continue
                 call stdlib_slacn2( mn2, work( mn2+1 ), work, iwork, dif( 2 ),kase, isave )
                           
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation.
                       call stdlib_stgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_stgsyl( 'T', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 50
                 end if
                 dif( 2 ) = dscale / dif( 2 )
              end if
           end if
           60 continue
           ! compute generalized eigenvalues of reordered pair (a, b) and
           ! normalize the generalized schur form.
           pair = .false.
           loop_70: do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 if( k<n ) then
                    if( a( k+1, k )/=zero ) then
                       pair = .true.
                    end if
                 end if
                 if( pair ) then
                   ! compute the eigenvalue(s) at position k.
                    work( 1 ) = a( k, k )
                    work( 2 ) = a( k+1, k )
                    work( 3 ) = a( k, k+1 )
                    work( 4 ) = a( k+1, k+1 )
                    work( 5 ) = b( k, k )
                    work( 6 ) = b( k+1, k )
                    work( 7 ) = b( k, k+1 )
                    work( 8 ) = b( k+1, k+1 )
                    call stdlib_slag2( work, 2, work( 5 ), 2, smlnum*eps, beta( k ),beta( k+1 ), &
                              alphar( k ), alphar( k+1 ),alphai( k ) )
                    alphai( k+1 ) = -alphai( k )
                 else
                    if( sign( one, b( k, k ) )<zero ) then
                       ! if b(k,k) is negative, make it positive
                       do i = 1, n
                          a( k, i ) = -a( k, i )
                          b( k, i ) = -b( k, i )
                          if( wantq ) q( i, k ) = -q( i, k )
                       end do
                    end if
                    alphar( k ) = a( k, k )
                    alphai( k ) = zero
                    beta( k ) = b( k, k )
                 end if
              end if
           end do loop_70
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_stgsen

     module pure subroutine stdlib_dtgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alphar, alphai, &
     !! DTGSEN reorders the generalized real Schur decomposition of a real
     !! matrix pair (A, B) (in terms of an orthonormal equivalence trans-
     !! formation Q**T * (A, B) * Z), so that a selected cluster of eigenvalues
     !! appears in the leading diagonal blocks of the upper quasi-triangular
     !! matrix A and the upper triangular B. The leading columns of Q and
     !! Z form orthonormal bases of the corresponding left and right eigen-
     !! spaces (deflating subspaces). (A, B) must be in generalized real
     !! Schur canonical form (as returned by DGGES), i.e. A is block upper
     !! triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper
     !! triangular.
     !! DTGSEN also computes the generalized eigenvalues
     !! w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
     !! of the reordered matrix pair (A, B).
     !! Optionally, DTGSEN computes the estimates of reciprocal condition
     !! numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
     !! (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
     !! between the matrix pairs (A11, B11) and (A22,B22) that correspond to
     !! the selected cluster and the eigenvalues outside the cluster, resp.,
     !! and norms of "projections" onto left and right eigenspaces w.r.t.
     !! the selected cluster in the (1,1)-block.
               beta, q, ldq, z, ldz, m, pl,pr, dif, work, lwork, iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(dp), intent(out) :: pl, pr
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(dp), intent(out) :: alphai(*), alphar(*), beta(*), dif(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, pair, swap, wantd, wantd1, wantd2, wantp
           integer(ilp) :: i, ierr, ijb, k, kase, kk, ks, liwmin, lwmin, mn2, n1, n2
           real(dp) :: dscale, dsum, eps, rdscal, smlnum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           info = 0
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( ijob<0 .or. ijob>5 ) then
              info = -1
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -14
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSEN', -info )
              return
           end if
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' ) / eps
           ierr = 0
           wantp = ijob==1 .or. ijob>=4
           wantd1 = ijob==2 .or. ijob==4
           wantd2 = ijob==3 .or. ijob==5
           wantd = wantd1 .or. wantd2
           ! set m to the dimension of the specified pair of deflating
           ! subspaces.
           m = 0
           pair = .false.
           if( .not.lquery .or. ijob/=0 ) then
           do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 if( k<n ) then
                    if( a( k+1, k )==zero ) then
                       if( select( k ) )m = m + 1
                    else
                       pair = .true.
                       if( select( k ) .or. select( k+1 ) )m = m + 2
                    end if
                 else
                    if( select( n ) )m = m + 1
                 end if
              end if
           end do
           end if
           if( ijob==1 .or. ijob==2 .or. ijob==4 ) then
              lwmin = max( 1, 4*n+16, 2*m*( n-m ) )
              liwmin = max( 1, n+6 )
           else if( ijob==3 .or. ijob==5 ) then
              lwmin = max( 1, 4*n+16, 4*m*( n-m ) )
              liwmin = max( 1, 2*m*( n-m ), n+6 )
           else
              lwmin = max( 1, 4*n+16 )
              liwmin = 1
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           if( lwork<lwmin .and. .not.lquery ) then
              info = -22
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -24
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==n .or. m==0 ) then
              if( wantp ) then
                 pl = one
                 pr = one
              end if
              if( wantd ) then
                 dscale = zero
                 dsum = one
                 do i = 1, n
                    call stdlib_dlassq( n, a( 1, i ), 1, dscale, dsum )
                    call stdlib_dlassq( n, b( 1, i ), 1, dscale, dsum )
                 end do
                 dif( 1 ) = dscale*sqrt( dsum )
                 dif( 2 ) = dif( 1 )
              end if
              go to 60
           end if
           ! collect the selected blocks at the top-left corner of (a, b).
           ks = 0
           pair = .false.
           loop_30: do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 swap = select( k )
                 if( k<n ) then
                    if( a( k+1, k )/=zero ) then
                       pair = .true.
                       swap = swap .or. select( k+1 )
                    end if
                 end if
                 if( swap ) then
                    ks = ks + 1
                    ! swap the k-th block to position ks.
                    ! perform the reordering of diagonal blocks in (a, b)
                    ! by orthogonal transformation matrices and update
                    ! q and z accordingly (if requested):
                    kk = k
                    if( k/=ks )call stdlib_dtgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz,&
                               kk, ks, work, lwork, ierr )
                    if( ierr>0 ) then
                       ! swap is rejected: exit.
                       info = 1
                       if( wantp ) then
                          pl = zero
                          pr = zero
                       end if
                       if( wantd ) then
                          dif( 1 ) = zero
                          dif( 2 ) = zero
                       end if
                       go to 60
                    end if
                    if( pair )ks = ks + 1
                 end if
              end if
           end do loop_30
           if( wantp ) then
              ! solve generalized sylvester equation for r and l
              ! and compute pl and pr.
              n1 = m
              n2 = n - m
              i = n1 + 1
              ijb = 0
              call stdlib_dlacpy( 'FULL', n1, n2, a( 1, i ), lda, work, n1 )
              call stdlib_dlacpy( 'FULL', n1, n2, b( 1, i ), ldb, work( n1*n2+1 ),n1 )
              call stdlib_dtgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b( i,&
               i ), ldb, work( n1*n2+1 ), n1,dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-2*n1*n2, &
                         iwork, ierr )
              ! estimate the reciprocal of norms of "projections" onto left
              ! and right eigenspaces.
              rdscal = zero
              dsum = one
              call stdlib_dlassq( n1*n2, work, 1, rdscal, dsum )
              pl = rdscal*sqrt( dsum )
              if( pl==zero ) then
                 pl = one
              else
                 pl = dscale / ( sqrt( dscale*dscale / pl+pl )*sqrt( pl ) )
              end if
              rdscal = zero
              dsum = one
              call stdlib_dlassq( n1*n2, work( n1*n2+1 ), 1, rdscal, dsum )
              pr = rdscal*sqrt( dsum )
              if( pr==zero ) then
                 pr = one
              else
                 pr = dscale / ( sqrt( dscale*dscale / pr+pr )*sqrt( pr ) )
              end if
           end if
           if( wantd ) then
              ! compute estimates of difu and difl.
              if( wantd1 ) then
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = idifjb
                 ! frobenius norm-based difu-estimate.
                 call stdlib_dtgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b(&
                  i, i ), ldb, work( n1*n2+1 ),n1, dscale, dif( 1 ), work( 2*n1*n2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
                 ! frobenius norm-based difl-estimate.
                 call stdlib_dtgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda, work,n2, b( i, i ),&
                  ldb, b, ldb, work( n1*n2+1 ),n2, dscale, dif( 2 ), work( 2*n1*n2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
              else
                 ! compute 1-norm-based estimates of difu and difl using
                 ! reversed communication with stdlib_dlacn2. in each step a
                 ! generalized sylvester equation or a transposed variant
                 ! is solved.
                 kase = 0
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = 0
                 mn2 = 2*n1*n2
                 ! 1-norm-based estimate of difu.
                 40 continue
                 call stdlib_dlacn2( mn2, work( mn2+1 ), work, iwork, dif( 1 ),kase, isave )
                           
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation.
                       call stdlib_dtgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_dtgsyl( 'T', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 40
                 end if
                 dif( 1 ) = dscale / dif( 1 )
                 ! 1-norm-based estimate of difl.
                 50 continue
                 call stdlib_dlacn2( mn2, work( mn2+1 ), work, iwork, dif( 2 ),kase, isave )
                           
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation.
                       call stdlib_dtgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_dtgsyl( 'T', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 50
                 end if
                 dif( 2 ) = dscale / dif( 2 )
              end if
           end if
           60 continue
           ! compute generalized eigenvalues of reordered pair (a, b) and
           ! normalize the generalized schur form.
           pair = .false.
           loop_80: do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 if( k<n ) then
                    if( a( k+1, k )/=zero ) then
                       pair = .true.
                    end if
                 end if
                 if( pair ) then
                   ! compute the eigenvalue(s) at position k.
                    work( 1 ) = a( k, k )
                    work( 2 ) = a( k+1, k )
                    work( 3 ) = a( k, k+1 )
                    work( 4 ) = a( k+1, k+1 )
                    work( 5 ) = b( k, k )
                    work( 6 ) = b( k+1, k )
                    work( 7 ) = b( k, k+1 )
                    work( 8 ) = b( k+1, k+1 )
                    call stdlib_dlag2( work, 2, work( 5 ), 2, smlnum*eps, beta( k ),beta( k+1 ), &
                              alphar( k ), alphar( k+1 ),alphai( k ) )
                    alphai( k+1 ) = -alphai( k )
                 else
                    if( sign( one, b( k, k ) )<zero ) then
                       ! if b(k,k) is negative, make it positive
                       do i = 1, n
                          a( k, i ) = -a( k, i )
                          b( k, i ) = -b( k, i )
                          if( wantq ) q( i, k ) = -q( i, k )
                       end do
                    end if
                    alphar( k ) = a( k, k )
                    alphai( k ) = zero
                    beta( k ) = b( k, k )
                 end if
              end if
           end do loop_80
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_dtgsen

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$tgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alphar, alphai, &
     !! DTGSEN: reorders the generalized real Schur decomposition of a real
     !! matrix pair (A, B) (in terms of an orthonormal equivalence trans-
     !! formation Q**T * (A, B) * Z), so that a selected cluster of eigenvalues
     !! appears in the leading diagonal blocks of the upper quasi-triangular
     !! matrix A and the upper triangular B. The leading columns of Q and
     !! Z form orthonormal bases of the corresponding left and right eigen-
     !! spaces (deflating subspaces). (A, B) must be in generalized real
     !! Schur canonical form (as returned by DGGES), i.e. A is block upper
     !! triangular with 1-by-1 and 2-by-2 diagonal blocks. B is upper
     !! triangular.
     !! DTGSEN also computes the generalized eigenvalues
     !! w(j) = (ALPHAR(j) + i*ALPHAI(j))/BETA(j)
     !! of the reordered matrix pair (A, B).
     !! Optionally, DTGSEN computes the estimates of reciprocal condition
     !! numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
     !! (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
     !! between the matrix pairs (A11, B11) and (A22,B22) that correspond to
     !! the selected cluster and the eigenvalues outside the cluster, resp.,
     !! and norms of "projections" onto left and right eigenspaces w.r.t.
     !! the selected cluster in the (1,1)-block.
               beta, q, ldq, z, ldz, m, pl,pr, dif, work, lwork, iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(${rk}$), intent(out) :: pl, pr
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           real(${rk}$), intent(out) :: alphai(*), alphar(*), beta(*), dif(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, pair, swap, wantd, wantd1, wantd2, wantp
           integer(ilp) :: i, ierr, ijb, k, kase, kk, ks, liwmin, lwmin, mn2, n1, n2
           real(${rk}$) :: dscale, dsum, eps, rdscal, smlnum
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           info = 0
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( ijob<0 .or. ijob>5 ) then
              info = -1
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -14
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -16
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSEN', -info )
              return
           end if
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' ) / eps
           ierr = 0
           wantp = ijob==1 .or. ijob>=4
           wantd1 = ijob==2 .or. ijob==4
           wantd2 = ijob==3 .or. ijob==5
           wantd = wantd1 .or. wantd2
           ! set m to the dimension of the specified pair of deflating
           ! subspaces.
           m = 0
           pair = .false.
           if( .not.lquery .or. ijob/=0 ) then
           do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 if( k<n ) then
                    if( a( k+1, k )==zero ) then
                       if( select( k ) )m = m + 1
                    else
                       pair = .true.
                       if( select( k ) .or. select( k+1 ) )m = m + 2
                    end if
                 else
                    if( select( n ) )m = m + 1
                 end if
              end if
           end do
           end if
           if( ijob==1 .or. ijob==2 .or. ijob==4 ) then
              lwmin = max( 1, 4*n+16, 2*m*( n-m ) )
              liwmin = max( 1, n+6 )
           else if( ijob==3 .or. ijob==5 ) then
              lwmin = max( 1, 4*n+16, 4*m*( n-m ) )
              liwmin = max( 1, 2*m*( n-m ), n+6 )
           else
              lwmin = max( 1, 4*n+16 )
              liwmin = 1
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           if( lwork<lwmin .and. .not.lquery ) then
              info = -22
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -24
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==n .or. m==0 ) then
              if( wantp ) then
                 pl = one
                 pr = one
              end if
              if( wantd ) then
                 dscale = zero
                 dsum = one
                 do i = 1, n
                    call stdlib_${ri}$lassq( n, a( 1, i ), 1, dscale, dsum )
                    call stdlib_${ri}$lassq( n, b( 1, i ), 1, dscale, dsum )
                 end do
                 dif( 1 ) = dscale*sqrt( dsum )
                 dif( 2 ) = dif( 1 )
              end if
              go to 60
           end if
           ! collect the selected blocks at the top-left corner of (a, b).
           ks = 0
           pair = .false.
           loop_30: do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 swap = select( k )
                 if( k<n ) then
                    if( a( k+1, k )/=zero ) then
                       pair = .true.
                       swap = swap .or. select( k+1 )
                    end if
                 end if
                 if( swap ) then
                    ks = ks + 1
                    ! swap the k-th block to position ks.
                    ! perform the reordering of diagonal blocks in (a, b)
                    ! by orthogonal transformation matrices and update
                    ! q and z accordingly (if requested):
                    kk = k
                    if( k/=ks )call stdlib_${ri}$tgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq,z, ldz,&
                               kk, ks, work, lwork, ierr )
                    if( ierr>0 ) then
                       ! swap is rejected: exit.
                       info = 1
                       if( wantp ) then
                          pl = zero
                          pr = zero
                       end if
                       if( wantd ) then
                          dif( 1 ) = zero
                          dif( 2 ) = zero
                       end if
                       go to 60
                    end if
                    if( pair )ks = ks + 1
                 end if
              end if
           end do loop_30
           if( wantp ) then
              ! solve generalized sylvester equation for r and l
              ! and compute pl and pr.
              n1 = m
              n2 = n - m
              i = n1 + 1
              ijb = 0
              call stdlib_${ri}$lacpy( 'FULL', n1, n2, a( 1, i ), lda, work, n1 )
              call stdlib_${ri}$lacpy( 'FULL', n1, n2, b( 1, i ), ldb, work( n1*n2+1 ),n1 )
              call stdlib_${ri}$tgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b( i,&
               i ), ldb, work( n1*n2+1 ), n1,dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-2*n1*n2, &
                         iwork, ierr )
              ! estimate the reciprocal of norms of "projections" onto left
              ! and right eigenspaces.
              rdscal = zero
              dsum = one
              call stdlib_${ri}$lassq( n1*n2, work, 1, rdscal, dsum )
              pl = rdscal*sqrt( dsum )
              if( pl==zero ) then
                 pl = one
              else
                 pl = dscale / ( sqrt( dscale*dscale / pl+pl )*sqrt( pl ) )
              end if
              rdscal = zero
              dsum = one
              call stdlib_${ri}$lassq( n1*n2, work( n1*n2+1 ), 1, rdscal, dsum )
              pr = rdscal*sqrt( dsum )
              if( pr==zero ) then
                 pr = one
              else
                 pr = dscale / ( sqrt( dscale*dscale / pr+pr )*sqrt( pr ) )
              end if
           end if
           if( wantd ) then
              ! compute estimates of difu and difl.
              if( wantd1 ) then
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = idifjb
                 ! frobenius norm-based difu-estimate.
                 call stdlib_${ri}$tgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b(&
                  i, i ), ldb, work( n1*n2+1 ),n1, dscale, dif( 1 ), work( 2*n1*n2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
                 ! frobenius norm-based difl-estimate.
                 call stdlib_${ri}$tgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda, work,n2, b( i, i ),&
                  ldb, b, ldb, work( n1*n2+1 ),n2, dscale, dif( 2 ), work( 2*n1*n2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
              else
                 ! compute 1-norm-based estimates of difu and difl using
                 ! reversed communication with stdlib_${ri}$lacn2. in each step a
                 ! generalized sylvester equation or a transposed variant
                 ! is solved.
                 kase = 0
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = 0
                 mn2 = 2*n1*n2
                 ! 1-norm-based estimate of difu.
                 40 continue
                 call stdlib_${ri}$lacn2( mn2, work( mn2+1 ), work, iwork, dif( 1 ),kase, isave )
                           
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation.
                       call stdlib_${ri}$tgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_${ri}$tgsyl( 'T', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 40
                 end if
                 dif( 1 ) = dscale / dif( 1 )
                 ! 1-norm-based estimate of difl.
                 50 continue
                 call stdlib_${ri}$lacn2( mn2, work( mn2+1 ), work, iwork, dif( 2 ),kase, isave )
                           
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation.
                       call stdlib_${ri}$tgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_${ri}$tgsyl( 'T', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( 2*n1*n2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 50
                 end if
                 dif( 2 ) = dscale / dif( 2 )
              end if
           end if
           60 continue
           ! compute generalized eigenvalues of reordered pair (a, b) and
           ! normalize the generalized schur form.
           pair = .false.
           loop_80: do k = 1, n
              if( pair ) then
                 pair = .false.
              else
                 if( k<n ) then
                    if( a( k+1, k )/=zero ) then
                       pair = .true.
                    end if
                 end if
                 if( pair ) then
                   ! compute the eigenvalue(s) at position k.
                    work( 1 ) = a( k, k )
                    work( 2 ) = a( k+1, k )
                    work( 3 ) = a( k, k+1 )
                    work( 4 ) = a( k+1, k+1 )
                    work( 5 ) = b( k, k )
                    work( 6 ) = b( k+1, k )
                    work( 7 ) = b( k, k+1 )
                    work( 8 ) = b( k+1, k+1 )
                    call stdlib_${ri}$lag2( work, 2, work( 5 ), 2, smlnum*eps, beta( k ),beta( k+1 ), &
                              alphar( k ), alphar( k+1 ),alphai( k ) )
                    alphai( k+1 ) = -alphai( k )
                 else
                    if( sign( one, b( k, k ) )<zero ) then
                       ! if b(k,k) is negative, make it positive
                       do i = 1, n
                          a( k, i ) = -a( k, i )
                          b( k, i ) = -b( k, i )
                          if( wantq ) q( i, k ) = -q( i, k )
                       end do
                    end if
                    alphar( k ) = a( k, k )
                    alphai( k ) = zero
                    beta( k ) = b( k, k )
                 end if
              end if
           end do loop_80
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ri}$tgsen

#:endif
#:endfor

     module pure subroutine stdlib_ctgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alpha, beta, q, &
     !! CTGSEN reorders the generalized Schur decomposition of a complex
     !! matrix pair (A, B) (in terms of an unitary equivalence trans-
     !! formation Q**H * (A, B) * Z), so that a selected cluster of eigenvalues
     !! appears in the leading diagonal blocks of the pair (A,B). The leading
     !! columns of Q and Z form unitary bases of the corresponding left and
     !! right eigenspaces (deflating subspaces). (A, B) must be in
     !! generalized Schur canonical form, that is, A and B are both upper
     !! triangular.
     !! CTGSEN also computes the generalized eigenvalues
     !! w(j)= ALPHA(j) / BETA(j)
     !! of the reordered matrix pair (A, B).
     !! Optionally, the routine computes estimates of reciprocal condition
     !! numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
     !! (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
     !! between the matrix pairs (A11, B11) and (A22,B22) that correspond to
     !! the selected cluster and the eigenvalues outside the cluster, resp.,
     !! and norms of "projections" onto left and right eigenspaces w.r.t.
     !! the selected cluster in the (1,1)-block.
               ldq, z, ldz, m, pl, pr, dif,work, lwork, iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(sp), intent(out) :: pl, pr
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: dif(*)
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(sp), intent(out) :: alpha(*), beta(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, swap, wantd, wantd1, wantd2, wantp
           integer(ilp) :: i, ierr, ijb, k, kase, ks, liwmin, lwmin, mn2, n1, n2
           real(sp) :: dscale, dsum, rdscal, safmin
           complex(sp) :: temp1, temp2
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           info = 0
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( ijob<0 .or. ijob>5 ) then
              info = -1
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -13
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGSEN', -info )
              return
           end if
           ierr = 0
           wantp = ijob==1 .or. ijob>=4
           wantd1 = ijob==2 .or. ijob==4
           wantd2 = ijob==3 .or. ijob==5
           wantd = wantd1 .or. wantd2
           ! set m to the dimension of the specified pair of deflating
           ! subspaces.
           m = 0
           if( .not.lquery .or. ijob/=0 ) then
           do k = 1, n
              alpha( k ) = a( k, k )
              beta( k ) = b( k, k )
              if( k<n ) then
                 if( select( k ) )m = m + 1
              else
                 if( select( n ) )m = m + 1
              end if
           end do
           end if
           if( ijob==1 .or. ijob==2 .or. ijob==4 ) then
              lwmin = max( 1, 2*m*(n-m) )
              liwmin = max( 1, n+2 )
           else if( ijob==3 .or. ijob==5 ) then
              lwmin = max( 1, 4*m*(n-m) )
              liwmin = max( 1, 2*m*(n-m), n+2 )
           else
              lwmin = 1
              liwmin = 1
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           if( lwork<lwmin .and. .not.lquery ) then
              info = -21
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -23
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==n .or. m==0 ) then
              if( wantp ) then
                 pl = one
                 pr = one
              end if
              if( wantd ) then
                 dscale = zero
                 dsum = one
                 do i = 1, n
                    call stdlib_classq( n, a( 1, i ), 1, dscale, dsum )
                    call stdlib_classq( n, b( 1, i ), 1, dscale, dsum )
                 end do
                 dif( 1 ) = dscale*sqrt( dsum )
                 dif( 2 ) = dif( 1 )
              end if
              go to 70
           end if
           ! get machine constant
           safmin = stdlib_slamch( 'S' )
           ! collect the selected blocks at the top-left corner of (a, b).
           ks = 0
           do k = 1, n
              swap = select( k )
              if( swap ) then
                 ks = ks + 1
                 ! swap the k-th block to position ks. compute unitary q
                 ! and z that will swap adjacent diagonal blocks in (a, b).
                 if( k/=ks )call stdlib_ctgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, k,&
                            ks, ierr )
                 if( ierr>0 ) then
                    ! swap is rejected: exit.
                    info = 1
                    if( wantp ) then
                       pl = zero
                       pr = zero
                    end if
                    if( wantd ) then
                       dif( 1 ) = zero
                       dif( 2 ) = zero
                    end if
                    go to 70
                 end if
              end if
           end do
           if( wantp ) then
              ! solve generalized sylvester equation for r and l:
                         ! a11 * r - l * a22 = a12
                         ! b11 * r - l * b22 = b12
              n1 = m
              n2 = n - m
              i = n1 + 1
              call stdlib_clacpy( 'FULL', n1, n2, a( 1, i ), lda, work, n1 )
              call stdlib_clacpy( 'FULL', n1, n2, b( 1, i ), ldb, work( n1*n2+1 ),n1 )
              ijb = 0
              call stdlib_ctgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b( i,&
               i ), ldb, work( n1*n2+1 ), n1,dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-2*n1*n2, &
                         iwork, ierr )
              ! estimate the reciprocal of norms of "projections" onto
              ! left and right eigenspaces
              rdscal = zero
              dsum = one
              call stdlib_classq( n1*n2, work, 1, rdscal, dsum )
              pl = rdscal*sqrt( dsum )
              if( pl==zero ) then
                 pl = one
              else
                 pl = dscale / ( sqrt( dscale*dscale / pl+pl )*sqrt( pl ) )
              end if
              rdscal = zero
              dsum = one
              call stdlib_classq( n1*n2, work( n1*n2+1 ), 1, rdscal, dsum )
              pr = rdscal*sqrt( dsum )
              if( pr==zero ) then
                 pr = one
              else
                 pr = dscale / ( sqrt( dscale*dscale / pr+pr )*sqrt( pr ) )
              end if
           end if
           if( wantd ) then
              ! compute estimates difu and difl.
              if( wantd1 ) then
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = idifjb
                 ! frobenius norm-based difu estimate.
                 call stdlib_ctgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b(&
                  i, i ), ldb, work( n1*n2+1 ),n1, dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
                 ! frobenius norm-based difl estimate.
                 call stdlib_ctgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda, work,n2, b( i, i ),&
                  ldb, b, ldb, work( n1*n2+1 ),n2, dscale, dif( 2 ), work( n1*n2*2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
              else
                 ! compute 1-norm-based estimates of difu and difl using
                 ! reversed communication with stdlib_clacn2. in each step a
                 ! generalized sylvester equation or a transposed variant
                 ! is solved.
                 kase = 0
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = 0
                 mn2 = 2*n1*n2
                 ! 1-norm-based estimate of difu.
                 40 continue
                 call stdlib_clacn2( mn2, work( mn2+1 ), work, dif( 1 ), kase,isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation
                       call stdlib_ctgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_ctgsyl( 'C', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 40
                 end if
                 dif( 1 ) = dscale / dif( 1 )
                 ! 1-norm-based estimate of difl.
                 50 continue
                 call stdlib_clacn2( mn2, work( mn2+1 ), work, dif( 2 ), kase,isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation
                       call stdlib_ctgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_ctgsyl( 'C', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 50
                 end if
                 dif( 2 ) = dscale / dif( 2 )
              end if
           end if
           ! if b(k,k) is complex, make it real and positive (normalization
           ! of the generalized schur form) and store the generalized
           ! eigenvalues of reordered pair (a, b)
           do k = 1, n
              dscale = abs( b( k, k ) )
              if( dscale>safmin ) then
                 temp1 = conjg( b( k, k ) / dscale )
                 temp2 = b( k, k ) / dscale
                 b( k, k ) = dscale
                 call stdlib_cscal( n-k, temp1, b( k, k+1 ), ldb )
                 call stdlib_cscal( n-k+1, temp1, a( k, k ), lda )
                 if( wantq )call stdlib_cscal( n, temp2, q( 1, k ), 1 )
              else
                 b( k, k ) = cmplx( zero, zero,KIND=sp)
              end if
              alpha( k ) = a( k, k )
              beta( k ) = b( k, k )
           end do
           70 continue
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_ctgsen

     module pure subroutine stdlib_ztgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alpha, beta, q, &
     !! ZTGSEN reorders the generalized Schur decomposition of a complex
     !! matrix pair (A, B) (in terms of an unitary equivalence trans-
     !! formation Q**H * (A, B) * Z), so that a selected cluster of eigenvalues
     !! appears in the leading diagonal blocks of the pair (A,B). The leading
     !! columns of Q and Z form unitary bases of the corresponding left and
     !! right eigenspaces (deflating subspaces). (A, B) must be in
     !! generalized Schur canonical form, that is, A and B are both upper
     !! triangular.
     !! ZTGSEN also computes the generalized eigenvalues
     !! w(j)= ALPHA(j) / BETA(j)
     !! of the reordered matrix pair (A, B).
     !! Optionally, the routine computes estimates of reciprocal condition
     !! numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
     !! (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
     !! between the matrix pairs (A11, B11) and (A22,B22) that correspond to
     !! the selected cluster and the eigenvalues outside the cluster, resp.,
     !! and norms of "projections" onto left and right eigenspaces w.r.t.
     !! the selected cluster in the (1,1)-block.
               ldq, z, ldz, m, pl, pr, dif,work, lwork, iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(dp), intent(out) :: pl, pr
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(out) :: dif(*)
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(dp), intent(out) :: alpha(*), beta(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, swap, wantd, wantd1, wantd2, wantp
           integer(ilp) :: i, ierr, ijb, k, kase, ks, liwmin, lwmin, mn2, n1, n2
           real(dp) :: dscale, dsum, rdscal, safmin
           complex(dp) :: temp1, temp2
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           info = 0
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( ijob<0 .or. ijob>5 ) then
              info = -1
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -13
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSEN', -info )
              return
           end if
           ierr = 0
           wantp = ijob==1 .or. ijob>=4
           wantd1 = ijob==2 .or. ijob==4
           wantd2 = ijob==3 .or. ijob==5
           wantd = wantd1 .or. wantd2
           ! set m to the dimension of the specified pair of deflating
           ! subspaces.
           m = 0
           if( .not.lquery .or. ijob/=0 ) then
           do k = 1, n
              alpha( k ) = a( k, k )
              beta( k ) = b( k, k )
              if( k<n ) then
                 if( select( k ) )m = m + 1
              else
                 if( select( n ) )m = m + 1
              end if
           end do
           end if
           if( ijob==1 .or. ijob==2 .or. ijob==4 ) then
              lwmin = max( 1, 2*m*( n-m ) )
              liwmin = max( 1, n+2 )
           else if( ijob==3 .or. ijob==5 ) then
              lwmin = max( 1, 4*m*( n-m ) )
              liwmin = max( 1, 2*m*( n-m ), n+2 )
           else
              lwmin = 1
              liwmin = 1
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           if( lwork<lwmin .and. .not.lquery ) then
              info = -21
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -23
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==n .or. m==0 ) then
              if( wantp ) then
                 pl = one
                 pr = one
              end if
              if( wantd ) then
                 dscale = zero
                 dsum = one
                 do i = 1, n
                    call stdlib_zlassq( n, a( 1, i ), 1, dscale, dsum )
                    call stdlib_zlassq( n, b( 1, i ), 1, dscale, dsum )
                 end do
                 dif( 1 ) = dscale*sqrt( dsum )
                 dif( 2 ) = dif( 1 )
              end if
              go to 70
           end if
           ! get machine constant
           safmin = stdlib_dlamch( 'S' )
           ! collect the selected blocks at the top-left corner of (a, b).
           ks = 0
           do k = 1, n
              swap = select( k )
              if( swap ) then
                 ks = ks + 1
                 ! swap the k-th block to position ks. compute unitary q
                 ! and z that will swap adjacent diagonal blocks in (a, b).
                 if( k/=ks )call stdlib_ztgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, k,&
                            ks, ierr )
                 if( ierr>0 ) then
                    ! swap is rejected: exit.
                    info = 1
                    if( wantp ) then
                       pl = zero
                       pr = zero
                    end if
                    if( wantd ) then
                       dif( 1 ) = zero
                       dif( 2 ) = zero
                    end if
                    go to 70
                 end if
              end if
           end do
           if( wantp ) then
              ! solve generalized sylvester equation for r and l:
                         ! a11 * r - l * a22 = a12
                         ! b11 * r - l * b22 = b12
              n1 = m
              n2 = n - m
              i = n1 + 1
              call stdlib_zlacpy( 'FULL', n1, n2, a( 1, i ), lda, work, n1 )
              call stdlib_zlacpy( 'FULL', n1, n2, b( 1, i ), ldb, work( n1*n2+1 ),n1 )
              ijb = 0
              call stdlib_ztgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b( i,&
               i ), ldb, work( n1*n2+1 ), n1,dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-2*n1*n2, &
                         iwork, ierr )
              ! estimate the reciprocal of norms of "projections" onto
              ! left and right eigenspaces
              rdscal = zero
              dsum = one
              call stdlib_zlassq( n1*n2, work, 1, rdscal, dsum )
              pl = rdscal*sqrt( dsum )
              if( pl==zero ) then
                 pl = one
              else
                 pl = dscale / ( sqrt( dscale*dscale / pl+pl )*sqrt( pl ) )
              end if
              rdscal = zero
              dsum = one
              call stdlib_zlassq( n1*n2, work( n1*n2+1 ), 1, rdscal, dsum )
              pr = rdscal*sqrt( dsum )
              if( pr==zero ) then
                 pr = one
              else
                 pr = dscale / ( sqrt( dscale*dscale / pr+pr )*sqrt( pr ) )
              end if
           end if
           if( wantd ) then
              ! compute estimates difu and difl.
              if( wantd1 ) then
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = idifjb
                 ! frobenius norm-based difu estimate.
                 call stdlib_ztgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b(&
                  i, i ), ldb, work( n1*n2+1 ),n1, dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
                 ! frobenius norm-based difl estimate.
                 call stdlib_ztgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda, work,n2, b( i, i ),&
                  ldb, b, ldb, work( n1*n2+1 ),n2, dscale, dif( 2 ), work( n1*n2*2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
              else
                 ! compute 1-norm-based estimates of difu and difl using
                 ! reversed communication with stdlib_zlacn2. in each step a
                 ! generalized sylvester equation or a transposed variant
                 ! is solved.
                 kase = 0
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = 0
                 mn2 = 2*n1*n2
                 ! 1-norm-based estimate of difu.
                 40 continue
                 call stdlib_zlacn2( mn2, work( mn2+1 ), work, dif( 1 ), kase,isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation
                       call stdlib_ztgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_ztgsyl( 'C', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 40
                 end if
                 dif( 1 ) = dscale / dif( 1 )
                 ! 1-norm-based estimate of difl.
                 50 continue
                 call stdlib_zlacn2( mn2, work( mn2+1 ), work, dif( 2 ), kase,isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation
                       call stdlib_ztgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_ztgsyl( 'C', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 50
                 end if
                 dif( 2 ) = dscale / dif( 2 )
              end if
           end if
           ! if b(k,k) is complex, make it real and positive (normalization
           ! of the generalized schur form) and store the generalized
           ! eigenvalues of reordered pair (a, b)
           do k = 1, n
              dscale = abs( b( k, k ) )
              if( dscale>safmin ) then
                 temp1 = conjg( b( k, k ) / dscale )
                 temp2 = b( k, k ) / dscale
                 b( k, k ) = dscale
                 call stdlib_zscal( n-k, temp1, b( k, k+1 ), ldb )
                 call stdlib_zscal( n-k+1, temp1, a( k, k ), lda )
                 if( wantq )call stdlib_zscal( n, temp2, q( 1, k ), 1 )
              else
                 b( k, k ) = cmplx( zero, zero,KIND=dp)
              end if
              alpha( k ) = a( k, k )
              beta( k ) = b( k, k )
           end do
           70 continue
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_ztgsen

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$tgsen( ijob, wantq, wantz, select, n, a, lda, b, ldb,alpha, beta, q, &
     !! ZTGSEN: reorders the generalized Schur decomposition of a complex
     !! matrix pair (A, B) (in terms of an unitary equivalence trans-
     !! formation Q**H * (A, B) * Z), so that a selected cluster of eigenvalues
     !! appears in the leading diagonal blocks of the pair (A,B). The leading
     !! columns of Q and Z form unitary bases of the corresponding left and
     !! right eigenspaces (deflating subspaces). (A, B) must be in
     !! generalized Schur canonical form, that is, A and B are both upper
     !! triangular.
     !! ZTGSEN also computes the generalized eigenvalues
     !! w(j)= ALPHA(j) / BETA(j)
     !! of the reordered matrix pair (A, B).
     !! Optionally, the routine computes estimates of reciprocal condition
     !! numbers for eigenvalues and eigenspaces. These are Difu[(A11,B11),
     !! (A22,B22)] and Difl[(A11,B11), (A22,B22)], i.e. the separation(s)
     !! between the matrix pairs (A11, B11) and (A22,B22) that correspond to
     !! the selected cluster and the eigenvalues outside the cluster, resp.,
     !! and norms of "projections" onto left and right eigenspaces w.r.t.
     !! the selected cluster in the (1,1)-block.
               ldq, z, ldz, m, pl, pr, dif,work, lwork, iwork, liwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           logical(lk), intent(in) :: wantq, wantz
           integer(ilp), intent(in) :: ijob, lda, ldb, ldq, ldz, liwork, lwork, n
           integer(ilp), intent(out) :: info, m
           real(${ck}$), intent(out) :: pl, pr
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: dif(*)
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
           complex(${ck}$), intent(out) :: alpha(*), beta(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, swap, wantd, wantd1, wantd2, wantp
           integer(ilp) :: i, ierr, ijb, k, kase, ks, liwmin, lwmin, mn2, n1, n2
           real(${ck}$) :: dscale, dsum, rdscal, safmin
           complex(${ck}$) :: temp1, temp2
           ! Local Arrays 
           integer(ilp) :: isave(3)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           info = 0
           lquery = ( lwork==-1 .or. liwork==-1 )
           if( ijob<0 .or. ijob>5 ) then
              info = -1
           else if( n<0 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ldq<1 .or. ( wantq .and. ldq<n ) ) then
              info = -13
           else if( ldz<1 .or. ( wantz .and. ldz<n ) ) then
              info = -15
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSEN', -info )
              return
           end if
           ierr = 0
           wantp = ijob==1 .or. ijob>=4
           wantd1 = ijob==2 .or. ijob==4
           wantd2 = ijob==3 .or. ijob==5
           wantd = wantd1 .or. wantd2
           ! set m to the dimension of the specified pair of deflating
           ! subspaces.
           m = 0
           if( .not.lquery .or. ijob/=0 ) then
           do k = 1, n
              alpha( k ) = a( k, k )
              beta( k ) = b( k, k )
              if( k<n ) then
                 if( select( k ) )m = m + 1
              else
                 if( select( n ) )m = m + 1
              end if
           end do
           end if
           if( ijob==1 .or. ijob==2 .or. ijob==4 ) then
              lwmin = max( 1, 2*m*( n-m ) )
              liwmin = max( 1, n+2 )
           else if( ijob==3 .or. ijob==5 ) then
              lwmin = max( 1, 4*m*( n-m ) )
              liwmin = max( 1, 2*m*( n-m ), n+2 )
           else
              lwmin = 1
              liwmin = 1
           end if
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           if( lwork<lwmin .and. .not.lquery ) then
              info = -21
           else if( liwork<liwmin .and. .not.lquery ) then
              info = -23
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSEN', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible.
           if( m==n .or. m==0 ) then
              if( wantp ) then
                 pl = one
                 pr = one
              end if
              if( wantd ) then
                 dscale = zero
                 dsum = one
                 do i = 1, n
                    call stdlib_${ci}$lassq( n, a( 1, i ), 1, dscale, dsum )
                    call stdlib_${ci}$lassq( n, b( 1, i ), 1, dscale, dsum )
                 end do
                 dif( 1 ) = dscale*sqrt( dsum )
                 dif( 2 ) = dif( 1 )
              end if
              go to 70
           end if
           ! get machine constant
           safmin = stdlib_${c2ri(ci)}$lamch( 'S' )
           ! collect the selected blocks at the top-left corner of (a, b).
           ks = 0
           do k = 1, n
              swap = select( k )
              if( swap ) then
                 ks = ks + 1
                 ! swap the k-th block to position ks. compute unitary q
                 ! and z that will swap adjacent diagonal blocks in (a, b).
                 if( k/=ks )call stdlib_${ci}$tgexc( wantq, wantz, n, a, lda, b, ldb, q, ldq, z,ldz, k,&
                            ks, ierr )
                 if( ierr>0 ) then
                    ! swap is rejected: exit.
                    info = 1
                    if( wantp ) then
                       pl = zero
                       pr = zero
                    end if
                    if( wantd ) then
                       dif( 1 ) = zero
                       dif( 2 ) = zero
                    end if
                    go to 70
                 end if
              end if
           end do
           if( wantp ) then
              ! solve generalized sylvester equation for r and l:
                         ! a11 * r - l * a22 = a12
                         ! b11 * r - l * b22 = b12
              n1 = m
              n2 = n - m
              i = n1 + 1
              call stdlib_${ci}$lacpy( 'FULL', n1, n2, a( 1, i ), lda, work, n1 )
              call stdlib_${ci}$lacpy( 'FULL', n1, n2, b( 1, i ), ldb, work( n1*n2+1 ),n1 )
              ijb = 0
              call stdlib_${ci}$tgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b( i,&
               i ), ldb, work( n1*n2+1 ), n1,dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-2*n1*n2, &
                         iwork, ierr )
              ! estimate the reciprocal of norms of "projections" onto
              ! left and right eigenspaces
              rdscal = zero
              dsum = one
              call stdlib_${ci}$lassq( n1*n2, work, 1, rdscal, dsum )
              pl = rdscal*sqrt( dsum )
              if( pl==zero ) then
                 pl = one
              else
                 pl = dscale / ( sqrt( dscale*dscale / pl+pl )*sqrt( pl ) )
              end if
              rdscal = zero
              dsum = one
              call stdlib_${ci}$lassq( n1*n2, work( n1*n2+1 ), 1, rdscal, dsum )
              pr = rdscal*sqrt( dsum )
              if( pr==zero ) then
                 pr = one
              else
                 pr = dscale / ( sqrt( dscale*dscale / pr+pr )*sqrt( pr ) )
              end if
           end if
           if( wantd ) then
              ! compute estimates difu and difl.
              if( wantd1 ) then
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = idifjb
                 ! frobenius norm-based difu estimate.
                 call stdlib_${ci}$tgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda, work,n1, b, ldb, b(&
                  i, i ), ldb, work( n1*n2+1 ),n1, dscale, dif( 1 ), work( n1*n2*2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
                 ! frobenius norm-based difl estimate.
                 call stdlib_${ci}$tgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda, work,n2, b( i, i ),&
                  ldb, b, ldb, work( n1*n2+1 ),n2, dscale, dif( 2 ), work( n1*n2*2+1 ),lwork-&
                            2*n1*n2, iwork, ierr )
              else
                 ! compute 1-norm-based estimates of difu and difl using
                 ! reversed communication with stdlib_${ci}$lacn2. in each step a
                 ! generalized sylvester equation or a transposed variant
                 ! is solved.
                 kase = 0
                 n1 = m
                 n2 = n - m
                 i = n1 + 1
                 ijb = 0
                 mn2 = 2*n1*n2
                 ! 1-norm-based estimate of difu.
                 40 continue
                 call stdlib_${ci}$lacn2( mn2, work( mn2+1 ), work, dif( 1 ), kase,isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation
                       call stdlib_${ci}$tgsyl( 'N', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_${ci}$tgsyl( 'C', ijb, n1, n2, a, lda, a( i, i ), lda,work, n1, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n1, dscale, dif( 1 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 40
                 end if
                 dif( 1 ) = dscale / dif( 1 )
                 ! 1-norm-based estimate of difl.
                 50 continue
                 call stdlib_${ci}$lacn2( mn2, work( mn2+1 ), work, dif( 2 ), kase,isave )
                 if( kase/=0 ) then
                    if( kase==1 ) then
                       ! solve generalized sylvester equation
                       call stdlib_${ci}$tgsyl( 'N', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b( &
                       i, i ), ldb, b, ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    else
                       ! solve the transposed variant.
                       call stdlib_${ci}$tgsyl( 'C', ijb, n2, n1, a( i, i ), lda, a, lda,work, n2, b, &
                       ldb, b( i, i ), ldb,work( n1*n2+1 ), n2, dscale, dif( 2 ),work( n1*n2*2+1 )&
                                 , lwork-2*n1*n2, iwork,ierr )
                    end if
                    go to 50
                 end if
                 dif( 2 ) = dscale / dif( 2 )
              end if
           end if
           ! if b(k,k) is complex, make it real and positive (normalization
           ! of the generalized schur form) and store the generalized
           ! eigenvalues of reordered pair (a, b)
           do k = 1, n
              dscale = abs( b( k, k ) )
              if( dscale>safmin ) then
                 temp1 = conjg( b( k, k ) / dscale )
                 temp2 = b( k, k ) / dscale
                 b( k, k ) = dscale
                 call stdlib_${ci}$scal( n-k, temp1, b( k, k+1 ), ldb )
                 call stdlib_${ci}$scal( n-k+1, temp1, a( k, k ), lda )
                 if( wantq )call stdlib_${ci}$scal( n, temp2, q( 1, k ), 1 )
              else
                 b( k, k ) = cmplx( zero, zero,KIND=${ck}$)
              end if
              alpha( k ) = a( k, k )
              beta( k ) = b( k, k )
           end do
           70 continue
           work( 1 ) = lwmin
           iwork( 1 ) = liwmin
           return
     end subroutine stdlib_${ci}$tgsen

#:endif
#:endfor



     module pure subroutine stdlib_stgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
     !! STGSNA estimates reciprocal condition numbers for specified
     !! eigenvalues and/or eigenvectors of a matrix pair (A, B) in
     !! generalized real Schur canonical form (or of any matrix pair
     !! (Q*A*Z**T, Q*B*Z**T) with orthogonal matrices Q and Z, where
     !! Z**T denotes the transpose of Z.
     !! (A, B) must be in generalized real Schur form (as returned by SGGES),
     !! i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal
     !! blocks. B is upper triangular.
               dif, mm, m, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           real(sp), intent(out) :: dif(*), s(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: difdri = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, pair, somcon, wantbh, wantdf, wants
           integer(ilp) :: i, ierr, ifst, ilst, iz, k, ks, lwmin, n1, n2
           real(sp) :: alphai, alphar, alprqt, beta, c1, c2, cond, eps, lnrm, rnrm, root1, root2, &
                     scale, smlnum, tmpii, tmpir, tmpri, tmprr, uhav, uhavi, uhbv, uhbvi
           ! Local Arrays 
           real(sp) :: dummy(1), dummy1(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantdf = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           info = 0
           lquery = ( lwork==-1 )
           if( .not.wants .and. .not.wantdf ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( wants .and. ldvl<n ) then
              info = -10
           else if( wants .and. ldvr<n ) then
              info = -12
           else
              ! set m to the number of eigenpairs for which condition numbers
              ! are required, and test mm.
              if( somcon ) then
                 m = 0
                 pair = .false.
                 do k = 1, n
                    if( pair ) then
                       pair = .false.
                    else
                       if( k<n ) then
                          if( a( k+1, k )==zero ) then
                             if( select( k ) )m = m + 1
                          else
                             pair = .true.
                             if( select( k ) .or. select( k+1 ) )m = m + 2
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( n==0 ) then
                 lwmin = 1
              else if( stdlib_lsame( job, 'V' ) .or. stdlib_lsame( job, 'B' ) ) then
                 lwmin = 2*n*( n + 2 ) + 16
              else
                 lwmin = n
              end if
              work( 1 ) = lwmin
              if( mm<m ) then
                 info = -15
              else if( lwork<lwmin .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'STGSNA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           ks = 0
           pair = .false.
           loop_20: do k = 1, n
              ! determine whether a(k,k) begins a 1-by-1 or 2-by-2 block.
              if( pair ) then
                 pair = .false.
                 cycle loop_20
              else
                 if( k<n )pair = a( k+1, k )/=zero
              end if
              ! determine whether condition numbers are required for the k-th
              ! eigenpair.
              if( somcon ) then
                 if( pair ) then
                    if( .not.select( k ) .and. .not.select( k+1 ) )cycle loop_20
                 else
                    if( .not.select( k ) )cycle loop_20
                 end if
              end if
              ks = ks + 1
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 if( pair ) then
                    ! complex eigenvalue pair.
                    rnrm = stdlib_slapy2( stdlib_snrm2( n, vr( 1, ks ), 1 ),stdlib_snrm2( n, vr( &
                              1, ks+1 ), 1 ) )
                    lnrm = stdlib_slapy2( stdlib_snrm2( n, vl( 1, ks ), 1 ),stdlib_snrm2( n, vl( &
                              1, ks+1 ), 1 ) )
                    call stdlib_sgemv( 'N', n, n, one, a, lda, vr( 1, ks ), 1, zero,work, 1 )
                              
                    tmprr = stdlib_sdot( n, work, 1, vl( 1, ks ), 1 )
                    tmpri = stdlib_sdot( n, work, 1, vl( 1, ks+1 ), 1 )
                    call stdlib_sgemv( 'N', n, n, one, a, lda, vr( 1, ks+1 ), 1,zero, work, 1 )
                              
                    tmpii = stdlib_sdot( n, work, 1, vl( 1, ks+1 ), 1 )
                    tmpir = stdlib_sdot( n, work, 1, vl( 1, ks ), 1 )
                    uhav = tmprr + tmpii
                    uhavi = tmpir - tmpri
                    call stdlib_sgemv( 'N', n, n, one, b, ldb, vr( 1, ks ), 1, zero,work, 1 )
                              
                    tmprr = stdlib_sdot( n, work, 1, vl( 1, ks ), 1 )
                    tmpri = stdlib_sdot( n, work, 1, vl( 1, ks+1 ), 1 )
                    call stdlib_sgemv( 'N', n, n, one, b, ldb, vr( 1, ks+1 ), 1,zero, work, 1 )
                              
                    tmpii = stdlib_sdot( n, work, 1, vl( 1, ks+1 ), 1 )
                    tmpir = stdlib_sdot( n, work, 1, vl( 1, ks ), 1 )
                    uhbv = tmprr + tmpii
                    uhbvi = tmpir - tmpri
                    uhav = stdlib_slapy2( uhav, uhavi )
                    uhbv = stdlib_slapy2( uhbv, uhbvi )
                    cond = stdlib_slapy2( uhav, uhbv )
                    s( ks ) = cond / ( rnrm*lnrm )
                    s( ks+1 ) = s( ks )
                 else
                    ! real eigenvalue.
                    rnrm = stdlib_snrm2( n, vr( 1, ks ), 1 )
                    lnrm = stdlib_snrm2( n, vl( 1, ks ), 1 )
                    call stdlib_sgemv( 'N', n, n, one, a, lda, vr( 1, ks ), 1, zero,work, 1 )
                              
                    uhav = stdlib_sdot( n, work, 1, vl( 1, ks ), 1 )
                    call stdlib_sgemv( 'N', n, n, one, b, ldb, vr( 1, ks ), 1, zero,work, 1 )
                              
                    uhbv = stdlib_sdot( n, work, 1, vl( 1, ks ), 1 )
                    cond = stdlib_slapy2( uhav, uhbv )
                    if( cond==zero ) then
                       s( ks ) = -one
                    else
                       s( ks ) = cond / ( rnrm*lnrm )
                    end if
                 end if
              end if
              if( wantdf ) then
                 if( n==1 ) then
                    dif( ks ) = stdlib_slapy2( a( 1, 1 ), b( 1, 1 ) )
                    cycle loop_20
                 end if
                 ! estimate the reciprocal condition number of the k-th
                 ! eigenvectors.
                 if( pair ) then
                    ! copy the  2-by 2 pencil beginning at (a(k,k), b(k, k)).
                    ! compute the eigenvalue(s) at position k.
                    work( 1 ) = a( k, k )
                    work( 2 ) = a( k+1, k )
                    work( 3 ) = a( k, k+1 )
                    work( 4 ) = a( k+1, k+1 )
                    work( 5 ) = b( k, k )
                    work( 6 ) = b( k+1, k )
                    work( 7 ) = b( k, k+1 )
                    work( 8 ) = b( k+1, k+1 )
                    call stdlib_slag2( work, 2, work( 5 ), 2, smlnum*eps, beta,dummy1( 1 ), &
                              alphar, dummy( 1 ), alphai )
                    alprqt = one
                    c1 = two*( alphar*alphar+alphai*alphai+beta*beta )
                    c2 = four*beta*beta*alphai*alphai
                    root1 = c1 + sqrt( c1*c1-4.0_sp*c2 )
                    root2 = c2 / root1
                    root1 = root1 / two
                    cond = min( sqrt( root1 ), sqrt( root2 ) )
                 end if
                 ! copy the matrix (a, b) to the array work and swap the
                 ! diagonal block beginning at a(k,k) to the (1,1) position.
                 call stdlib_slacpy( 'FULL', n, n, a, lda, work, n )
                 call stdlib_slacpy( 'FULL', n, n, b, ldb, work( n*n+1 ), n )
                 ifst = k
                 ilst = 1
                 call stdlib_stgexc( .false., .false., n, work, n, work( n*n+1 ), n,dummy, 1, &
                           dummy1, 1, ifst, ilst,work( n*n*2+1 ), lwork-2*n*n, ierr )
                 if( ierr>0 ) then
                    ! ill-conditioned problem - swap rejected.
                    dif( ks ) = zero
                 else
                    ! reordering successful, solve generalized sylvester
                    ! equation for r and l,
                               ! a22 * r - l * a11 = a12
                               ! b22 * r - l * b11 = b12,
                    ! and compute estimate of difl((a11,b11), (a22, b22)).
                    n1 = 1
                    if( work( 2 )/=zero )n1 = 2
                    n2 = n - n1
                    if( n2==0 ) then
                       dif( ks ) = cond
                    else
                       i = n*n + 1
                       iz = 2*n*n + 1
                       call stdlib_stgsyl( 'N', difdri, n2, n1, work( n*n1+n1+1 ),n, work, n, &
                       work( n1+1 ), n,work( n*n1+n1+i ), n, work( i ), n,work( n1+i ), n, scale, &
                                 dif( ks ),work( iz+1 ), lwork-2*n*n, iwork, ierr )
                       if( pair )dif( ks ) = min( max( one, alprqt )*dif( ks ),cond )
                    end if
                 end if
                 if( pair )dif( ks+1 ) = dif( ks )
              end if
              if( pair )ks = ks + 1
           end do loop_20
           work( 1 ) = lwmin
           return
     end subroutine stdlib_stgsna

     module pure subroutine stdlib_dtgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
     !! DTGSNA estimates reciprocal condition numbers for specified
     !! eigenvalues and/or eigenvectors of a matrix pair (A, B) in
     !! generalized real Schur canonical form (or of any matrix pair
     !! (Q*A*Z**T, Q*B*Z**T) with orthogonal matrices Q and Z, where
     !! Z**T denotes the transpose of Z.
     !! (A, B) must be in generalized real Schur form (as returned by DGGES),
     !! i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal
     !! blocks. B is upper triangular.
               dif, mm, m, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           real(dp), intent(out) :: dif(*), s(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: difdri = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, pair, somcon, wantbh, wantdf, wants
           integer(ilp) :: i, ierr, ifst, ilst, iz, k, ks, lwmin, n1, n2
           real(dp) :: alphai, alphar, alprqt, beta, c1, c2, cond, eps, lnrm, rnrm, root1, root2, &
                     scale, smlnum, tmpii, tmpir, tmpri, tmprr, uhav, uhavi, uhbv, uhbvi
           ! Local Arrays 
           real(dp) :: dummy(1), dummy1(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantdf = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           info = 0
           lquery = ( lwork==-1 )
           if( .not.wants .and. .not.wantdf ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( wants .and. ldvl<n ) then
              info = -10
           else if( wants .and. ldvr<n ) then
              info = -12
           else
              ! set m to the number of eigenpairs for which condition numbers
              ! are required, and test mm.
              if( somcon ) then
                 m = 0
                 pair = .false.
                 do k = 1, n
                    if( pair ) then
                       pair = .false.
                    else
                       if( k<n ) then
                          if( a( k+1, k )==zero ) then
                             if( select( k ) )m = m + 1
                          else
                             pair = .true.
                             if( select( k ) .or. select( k+1 ) )m = m + 2
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( n==0 ) then
                 lwmin = 1
              else if( stdlib_lsame( job, 'V' ) .or. stdlib_lsame( job, 'B' ) ) then
                 lwmin = 2*n*( n + 2 ) + 16
              else
                 lwmin = n
              end if
              work( 1 ) = lwmin
              if( mm<m ) then
                 info = -15
              else if( lwork<lwmin .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSNA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' ) / eps
           ks = 0
           pair = .false.
           loop_20: do k = 1, n
              ! determine whether a(k,k) begins a 1-by-1 or 2-by-2 block.
              if( pair ) then
                 pair = .false.
                 cycle loop_20
              else
                 if( k<n )pair = a( k+1, k )/=zero
              end if
              ! determine whether condition numbers are required for the k-th
              ! eigenpair.
              if( somcon ) then
                 if( pair ) then
                    if( .not.select( k ) .and. .not.select( k+1 ) )cycle loop_20
                 else
                    if( .not.select( k ) )cycle loop_20
                 end if
              end if
              ks = ks + 1
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 if( pair ) then
                    ! complex eigenvalue pair.
                    rnrm = stdlib_dlapy2( stdlib_dnrm2( n, vr( 1, ks ), 1 ),stdlib_dnrm2( n, vr( &
                              1, ks+1 ), 1 ) )
                    lnrm = stdlib_dlapy2( stdlib_dnrm2( n, vl( 1, ks ), 1 ),stdlib_dnrm2( n, vl( &
                              1, ks+1 ), 1 ) )
                    call stdlib_dgemv( 'N', n, n, one, a, lda, vr( 1, ks ), 1, zero,work, 1 )
                              
                    tmprr = stdlib_ddot( n, work, 1, vl( 1, ks ), 1 )
                    tmpri = stdlib_ddot( n, work, 1, vl( 1, ks+1 ), 1 )
                    call stdlib_dgemv( 'N', n, n, one, a, lda, vr( 1, ks+1 ), 1,zero, work, 1 )
                              
                    tmpii = stdlib_ddot( n, work, 1, vl( 1, ks+1 ), 1 )
                    tmpir = stdlib_ddot( n, work, 1, vl( 1, ks ), 1 )
                    uhav = tmprr + tmpii
                    uhavi = tmpir - tmpri
                    call stdlib_dgemv( 'N', n, n, one, b, ldb, vr( 1, ks ), 1, zero,work, 1 )
                              
                    tmprr = stdlib_ddot( n, work, 1, vl( 1, ks ), 1 )
                    tmpri = stdlib_ddot( n, work, 1, vl( 1, ks+1 ), 1 )
                    call stdlib_dgemv( 'N', n, n, one, b, ldb, vr( 1, ks+1 ), 1,zero, work, 1 )
                              
                    tmpii = stdlib_ddot( n, work, 1, vl( 1, ks+1 ), 1 )
                    tmpir = stdlib_ddot( n, work, 1, vl( 1, ks ), 1 )
                    uhbv = tmprr + tmpii
                    uhbvi = tmpir - tmpri
                    uhav = stdlib_dlapy2( uhav, uhavi )
                    uhbv = stdlib_dlapy2( uhbv, uhbvi )
                    cond = stdlib_dlapy2( uhav, uhbv )
                    s( ks ) = cond / ( rnrm*lnrm )
                    s( ks+1 ) = s( ks )
                 else
                    ! real eigenvalue.
                    rnrm = stdlib_dnrm2( n, vr( 1, ks ), 1 )
                    lnrm = stdlib_dnrm2( n, vl( 1, ks ), 1 )
                    call stdlib_dgemv( 'N', n, n, one, a, lda, vr( 1, ks ), 1, zero,work, 1 )
                              
                    uhav = stdlib_ddot( n, work, 1, vl( 1, ks ), 1 )
                    call stdlib_dgemv( 'N', n, n, one, b, ldb, vr( 1, ks ), 1, zero,work, 1 )
                              
                    uhbv = stdlib_ddot( n, work, 1, vl( 1, ks ), 1 )
                    cond = stdlib_dlapy2( uhav, uhbv )
                    if( cond==zero ) then
                       s( ks ) = -one
                    else
                       s( ks ) = cond / ( rnrm*lnrm )
                    end if
                 end if
              end if
              if( wantdf ) then
                 if( n==1 ) then
                    dif( ks ) = stdlib_dlapy2( a( 1, 1 ), b( 1, 1 ) )
                    cycle loop_20
                 end if
                 ! estimate the reciprocal condition number of the k-th
                 ! eigenvectors.
                 if( pair ) then
                    ! copy the  2-by 2 pencil beginning at (a(k,k), b(k, k)).
                    ! compute the eigenvalue(s) at position k.
                    work( 1 ) = a( k, k )
                    work( 2 ) = a( k+1, k )
                    work( 3 ) = a( k, k+1 )
                    work( 4 ) = a( k+1, k+1 )
                    work( 5 ) = b( k, k )
                    work( 6 ) = b( k+1, k )
                    work( 7 ) = b( k, k+1 )
                    work( 8 ) = b( k+1, k+1 )
                    call stdlib_dlag2( work, 2, work( 5 ), 2, smlnum*eps, beta,dummy1( 1 ), &
                              alphar, dummy( 1 ), alphai )
                    alprqt = one
                    c1 = two*( alphar*alphar+alphai*alphai+beta*beta )
                    c2 = four*beta*beta*alphai*alphai
                    root1 = c1 + sqrt( c1*c1-4.0_dp*c2 )
                    root2 = c2 / root1
                    root1 = root1 / two
                    cond = min( sqrt( root1 ), sqrt( root2 ) )
                 end if
                 ! copy the matrix (a, b) to the array work and swap the
                 ! diagonal block beginning at a(k,k) to the (1,1) position.
                 call stdlib_dlacpy( 'FULL', n, n, a, lda, work, n )
                 call stdlib_dlacpy( 'FULL', n, n, b, ldb, work( n*n+1 ), n )
                 ifst = k
                 ilst = 1
                 call stdlib_dtgexc( .false., .false., n, work, n, work( n*n+1 ), n,dummy, 1, &
                           dummy1, 1, ifst, ilst,work( n*n*2+1 ), lwork-2*n*n, ierr )
                 if( ierr>0 ) then
                    ! ill-conditioned problem - swap rejected.
                    dif( ks ) = zero
                 else
                    ! reordering successful, solve generalized sylvester
                    ! equation for r and l,
                               ! a22 * r - l * a11 = a12
                               ! b22 * r - l * b11 = b12,
                    ! and compute estimate of difl((a11,b11), (a22, b22)).
                    n1 = 1
                    if( work( 2 )/=zero )n1 = 2
                    n2 = n - n1
                    if( n2==0 ) then
                       dif( ks ) = cond
                    else
                       i = n*n + 1
                       iz = 2*n*n + 1
                       call stdlib_dtgsyl( 'N', difdri, n2, n1, work( n*n1+n1+1 ),n, work, n, &
                       work( n1+1 ), n,work( n*n1+n1+i ), n, work( i ), n,work( n1+i ), n, scale, &
                                 dif( ks ),work( iz+1 ), lwork-2*n*n, iwork, ierr )
                       if( pair )dif( ks ) = min( max( one, alprqt )*dif( ks ),cond )
                    end if
                 end if
                 if( pair )dif( ks+1 ) = dif( ks )
              end if
              if( pair )ks = ks + 1
           end do loop_20
           work( 1 ) = lwmin
           return
     end subroutine stdlib_dtgsna

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$tgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
     !! DTGSNA: estimates reciprocal condition numbers for specified
     !! eigenvalues and/or eigenvectors of a matrix pair (A, B) in
     !! generalized real Schur canonical form (or of any matrix pair
     !! (Q*A*Z**T, Q*B*Z**T) with orthogonal matrices Q and Z, where
     !! Z**T denotes the transpose of Z.
     !! (A, B) must be in generalized real Schur form (as returned by DGGES),
     !! i.e. A is block upper triangular with 1-by-1 and 2-by-2 diagonal
     !! blocks. B is upper triangular.
               dif, mm, m, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${rk}$), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           real(${rk}$), intent(out) :: dif(*), s(*), work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: difdri = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, pair, somcon, wantbh, wantdf, wants
           integer(ilp) :: i, ierr, ifst, ilst, iz, k, ks, lwmin, n1, n2
           real(${rk}$) :: alphai, alphar, alprqt, beta, c1, c2, cond, eps, lnrm, rnrm, root1, root2, &
                     scale, smlnum, tmpii, tmpir, tmpri, tmprr, uhav, uhavi, uhbv, uhbvi
           ! Local Arrays 
           real(${rk}$) :: dummy(1), dummy1(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantdf = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           info = 0
           lquery = ( lwork==-1 )
           if( .not.wants .and. .not.wantdf ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( wants .and. ldvl<n ) then
              info = -10
           else if( wants .and. ldvr<n ) then
              info = -12
           else
              ! set m to the number of eigenpairs for which condition numbers
              ! are required, and test mm.
              if( somcon ) then
                 m = 0
                 pair = .false.
                 do k = 1, n
                    if( pair ) then
                       pair = .false.
                    else
                       if( k<n ) then
                          if( a( k+1, k )==zero ) then
                             if( select( k ) )m = m + 1
                          else
                             pair = .true.
                             if( select( k ) .or. select( k+1 ) )m = m + 2
                          end if
                       else
                          if( select( n ) )m = m + 1
                       end if
                    end if
                 end do
              else
                 m = n
              end if
              if( n==0 ) then
                 lwmin = 1
              else if( stdlib_lsame( job, 'V' ) .or. stdlib_lsame( job, 'B' ) ) then
                 lwmin = 2*n*( n + 2 ) + 16
              else
                 lwmin = n
              end if
              work( 1 ) = lwmin
              if( mm<m ) then
                 info = -15
              else if( lwork<lwmin .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DTGSNA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${ri}$lamch( 'P' )
           smlnum = stdlib_${ri}$lamch( 'S' ) / eps
           ks = 0
           pair = .false.
           loop_20: do k = 1, n
              ! determine whether a(k,k) begins a 1-by-1 or 2-by-2 block.
              if( pair ) then
                 pair = .false.
                 cycle loop_20
              else
                 if( k<n )pair = a( k+1, k )/=zero
              end if
              ! determine whether condition numbers are required for the k-th
              ! eigenpair.
              if( somcon ) then
                 if( pair ) then
                    if( .not.select( k ) .and. .not.select( k+1 ) )cycle loop_20
                 else
                    if( .not.select( k ) )cycle loop_20
                 end if
              end if
              ks = ks + 1
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 if( pair ) then
                    ! complex eigenvalue pair.
                    rnrm = stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vr( 1, ks ), 1 ),stdlib_${ri}$nrm2( n, vr( &
                              1, ks+1 ), 1 ) )
                    lnrm = stdlib_${ri}$lapy2( stdlib_${ri}$nrm2( n, vl( 1, ks ), 1 ),stdlib_${ri}$nrm2( n, vl( &
                              1, ks+1 ), 1 ) )
                    call stdlib_${ri}$gemv( 'N', n, n, one, a, lda, vr( 1, ks ), 1, zero,work, 1 )
                              
                    tmprr = stdlib_${ri}$dot( n, work, 1, vl( 1, ks ), 1 )
                    tmpri = stdlib_${ri}$dot( n, work, 1, vl( 1, ks+1 ), 1 )
                    call stdlib_${ri}$gemv( 'N', n, n, one, a, lda, vr( 1, ks+1 ), 1,zero, work, 1 )
                              
                    tmpii = stdlib_${ri}$dot( n, work, 1, vl( 1, ks+1 ), 1 )
                    tmpir = stdlib_${ri}$dot( n, work, 1, vl( 1, ks ), 1 )
                    uhav = tmprr + tmpii
                    uhavi = tmpir - tmpri
                    call stdlib_${ri}$gemv( 'N', n, n, one, b, ldb, vr( 1, ks ), 1, zero,work, 1 )
                              
                    tmprr = stdlib_${ri}$dot( n, work, 1, vl( 1, ks ), 1 )
                    tmpri = stdlib_${ri}$dot( n, work, 1, vl( 1, ks+1 ), 1 )
                    call stdlib_${ri}$gemv( 'N', n, n, one, b, ldb, vr( 1, ks+1 ), 1,zero, work, 1 )
                              
                    tmpii = stdlib_${ri}$dot( n, work, 1, vl( 1, ks+1 ), 1 )
                    tmpir = stdlib_${ri}$dot( n, work, 1, vl( 1, ks ), 1 )
                    uhbv = tmprr + tmpii
                    uhbvi = tmpir - tmpri
                    uhav = stdlib_${ri}$lapy2( uhav, uhavi )
                    uhbv = stdlib_${ri}$lapy2( uhbv, uhbvi )
                    cond = stdlib_${ri}$lapy2( uhav, uhbv )
                    s( ks ) = cond / ( rnrm*lnrm )
                    s( ks+1 ) = s( ks )
                 else
                    ! real eigenvalue.
                    rnrm = stdlib_${ri}$nrm2( n, vr( 1, ks ), 1 )
                    lnrm = stdlib_${ri}$nrm2( n, vl( 1, ks ), 1 )
                    call stdlib_${ri}$gemv( 'N', n, n, one, a, lda, vr( 1, ks ), 1, zero,work, 1 )
                              
                    uhav = stdlib_${ri}$dot( n, work, 1, vl( 1, ks ), 1 )
                    call stdlib_${ri}$gemv( 'N', n, n, one, b, ldb, vr( 1, ks ), 1, zero,work, 1 )
                              
                    uhbv = stdlib_${ri}$dot( n, work, 1, vl( 1, ks ), 1 )
                    cond = stdlib_${ri}$lapy2( uhav, uhbv )
                    if( cond==zero ) then
                       s( ks ) = -one
                    else
                       s( ks ) = cond / ( rnrm*lnrm )
                    end if
                 end if
              end if
              if( wantdf ) then
                 if( n==1 ) then
                    dif( ks ) = stdlib_${ri}$lapy2( a( 1, 1 ), b( 1, 1 ) )
                    cycle loop_20
                 end if
                 ! estimate the reciprocal condition number of the k-th
                 ! eigenvectors.
                 if( pair ) then
                    ! copy the  2-by 2 pencil beginning at (a(k,k), b(k, k)).
                    ! compute the eigenvalue(s) at position k.
                    work( 1 ) = a( k, k )
                    work( 2 ) = a( k+1, k )
                    work( 3 ) = a( k, k+1 )
                    work( 4 ) = a( k+1, k+1 )
                    work( 5 ) = b( k, k )
                    work( 6 ) = b( k+1, k )
                    work( 7 ) = b( k, k+1 )
                    work( 8 ) = b( k+1, k+1 )
                    call stdlib_${ri}$lag2( work, 2, work( 5 ), 2, smlnum*eps, beta,dummy1( 1 ), &
                              alphar, dummy( 1 ), alphai )
                    alprqt = one
                    c1 = two*( alphar*alphar+alphai*alphai+beta*beta )
                    c2 = four*beta*beta*alphai*alphai
                    root1 = c1 + sqrt( c1*c1-4.0_${rk}$*c2 )
                    root2 = c2 / root1
                    root1 = root1 / two
                    cond = min( sqrt( root1 ), sqrt( root2 ) )
                 end if
                 ! copy the matrix (a, b) to the array work and swap the
                 ! diagonal block beginning at a(k,k) to the (1,1) position.
                 call stdlib_${ri}$lacpy( 'FULL', n, n, a, lda, work, n )
                 call stdlib_${ri}$lacpy( 'FULL', n, n, b, ldb, work( n*n+1 ), n )
                 ifst = k
                 ilst = 1
                 call stdlib_${ri}$tgexc( .false., .false., n, work, n, work( n*n+1 ), n,dummy, 1, &
                           dummy1, 1, ifst, ilst,work( n*n*2+1 ), lwork-2*n*n, ierr )
                 if( ierr>0 ) then
                    ! ill-conditioned problem - swap rejected.
                    dif( ks ) = zero
                 else
                    ! reordering successful, solve generalized sylvester
                    ! equation for r and l,
                               ! a22 * r - l * a11 = a12
                               ! b22 * r - l * b11 = b12,
                    ! and compute estimate of difl((a11,b11), (a22, b22)).
                    n1 = 1
                    if( work( 2 )/=zero )n1 = 2
                    n2 = n - n1
                    if( n2==0 ) then
                       dif( ks ) = cond
                    else
                       i = n*n + 1
                       iz = 2*n*n + 1
                       call stdlib_${ri}$tgsyl( 'N', difdri, n2, n1, work( n*n1+n1+1 ),n, work, n, &
                       work( n1+1 ), n,work( n*n1+n1+i ), n, work( i ), n,work( n1+i ), n, scale, &
                                 dif( ks ),work( iz+1 ), lwork-2*n*n, iwork, ierr )
                       if( pair )dif( ks ) = min( max( one, alprqt )*dif( ks ),cond )
                    end if
                 end if
                 if( pair )dif( ks+1 ) = dif( ks )
              end if
              if( pair )ks = ks + 1
           end do loop_20
           work( 1 ) = lwmin
           return
     end subroutine stdlib_${ri}$tgsna

#:endif
#:endfor

     module pure subroutine stdlib_ctgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
     !! CTGSNA estimates reciprocal condition numbers for specified
     !! eigenvalues and/or eigenvectors of a matrix pair (A, B).
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
               dif, mm, m, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(sp), intent(out) :: dif(*), s(*)
           complex(sp), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           complex(sp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, somcon, wantbh, wantdf, wants
           integer(ilp) :: i, ierr, ifst, ilst, k, ks, lwmin, n1, n2
           real(sp) :: bignum, cond, eps, lnrm, rnrm, scale, smlnum
           complex(sp) :: yhax, yhbx
           ! Local Arrays 
           complex(sp) :: dummy(1), dummy1(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantdf = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           info = 0
           lquery = ( lwork==-1 )
           if( .not.wants .and. .not.wantdf ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( wants .and. ldvl<n ) then
              info = -10
           else if( wants .and. ldvr<n ) then
              info = -12
           else
              ! set m to the number of eigenpairs for which condition numbers
              ! are required, and test mm.
              if( somcon ) then
                 m = 0
                 do k = 1, n
                    if( select( k ) )m = m + 1
                 end do
              else
                 m = n
              end if
              if( n==0 ) then
                 lwmin = 1
              else if( stdlib_lsame( job, 'V' ) .or. stdlib_lsame( job, 'B' ) ) then
                 lwmin = 2*n*n
              else
                 lwmin = n
              end if
              work( 1 ) = lwmin
              if( mm<m ) then
                 info = -15
              else if( lwork<lwmin .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CTGSNA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_slamch( 'P' )
           smlnum = stdlib_slamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_slabad( smlnum, bignum )
           ks = 0
           loop_20: do k = 1, n
              ! determine whether condition numbers are required for the k-th
              ! eigenpair.
              if( somcon ) then
                 if( .not.select( k ) )cycle loop_20
              end if
              ks = ks + 1
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 rnrm = stdlib_scnrm2( n, vr( 1, ks ), 1 )
                 lnrm = stdlib_scnrm2( n, vl( 1, ks ), 1 )
                 call stdlib_cgemv( 'N', n, n, cmplx( one, zero,KIND=sp), a, lda,vr( 1, ks ), 1, &
                           cmplx( zero, zero,KIND=sp), work, 1 )
                 yhax = stdlib_cdotc( n, work, 1, vl( 1, ks ), 1 )
                 call stdlib_cgemv( 'N', n, n, cmplx( one, zero,KIND=sp), b, ldb,vr( 1, ks ), 1, &
                           cmplx( zero, zero,KIND=sp), work, 1 )
                 yhbx = stdlib_cdotc( n, work, 1, vl( 1, ks ), 1 )
                 cond = stdlib_slapy2( abs( yhax ), abs( yhbx ) )
                 if( cond==zero ) then
                    s( ks ) = -one
                 else
                    s( ks ) = cond / ( rnrm*lnrm )
                 end if
              end if
              if( wantdf ) then
                 if( n==1 ) then
                    dif( ks ) = stdlib_slapy2( abs( a( 1, 1 ) ), abs( b( 1, 1 ) ) )
                 else
                    ! estimate the reciprocal condition number of the k-th
                    ! eigenvectors.
                    ! copy the matrix (a, b) to the array work and move the
                    ! (k,k)th pair to the (1,1) position.
                    call stdlib_clacpy( 'FULL', n, n, a, lda, work, n )
                    call stdlib_clacpy( 'FULL', n, n, b, ldb, work( n*n+1 ), n )
                    ifst = k
                    ilst = 1
                    call stdlib_ctgexc( .false., .false., n, work, n, work( n*n+1 ),n, dummy, 1, &
                              dummy1, 1, ifst, ilst, ierr )
                    if( ierr>0 ) then
                       ! ill-conditioned problem - swap rejected.
                       dif( ks ) = zero
                    else
                       ! reordering successful, solve generalized sylvester
                       ! equation for r and l,
                                  ! a22 * r - l * a11 = a12
                                  ! b22 * r - l * b11 = b12,
                       ! and compute estimate of difl[(a11,b11), (a22, b22)].
                       n1 = 1
                       n2 = n - n1
                       i = n*n + 1
                       call stdlib_ctgsyl( 'N', idifjb, n2, n1, work( n*n1+n1+1 ),n, work, n, &
                       work( n1+1 ), n,work( n*n1+n1+i ), n, work( i ), n,work( n1+i ), n, scale, &
                                 dif( ks ), dummy,1, iwork, ierr )
                    end if
                 end if
              end if
           end do loop_20
           work( 1 ) = lwmin
           return
     end subroutine stdlib_ctgsna

     module pure subroutine stdlib_ztgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
     !! ZTGSNA estimates reciprocal condition numbers for specified
     !! eigenvalues and/or eigenvectors of a matrix pair (A, B).
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
               dif, mm, m, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(dp), intent(out) :: dif(*), s(*)
           complex(dp), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           complex(dp), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, somcon, wantbh, wantdf, wants
           integer(ilp) :: i, ierr, ifst, ilst, k, ks, lwmin, n1, n2
           real(dp) :: bignum, cond, eps, lnrm, rnrm, scale, smlnum
           complex(dp) :: yhax, yhbx
           ! Local Arrays 
           complex(dp) :: dummy(1), dummy1(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantdf = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           info = 0
           lquery = ( lwork==-1 )
           if( .not.wants .and. .not.wantdf ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( wants .and. ldvl<n ) then
              info = -10
           else if( wants .and. ldvr<n ) then
              info = -12
           else
              ! set m to the number of eigenpairs for which condition numbers
              ! are required, and test mm.
              if( somcon ) then
                 m = 0
                 do k = 1, n
                    if( select( k ) )m = m + 1
                 end do
              else
                 m = n
              end if
              if( n==0 ) then
                 lwmin = 1
              else if( stdlib_lsame( job, 'V' ) .or. stdlib_lsame( job, 'B' ) ) then
                 lwmin = 2*n*n
              else
                 lwmin = n
              end if
              work( 1 ) = lwmin
              if( mm<m ) then
                 info = -15
              else if( lwork<lwmin .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSNA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_dlamch( 'P' )
           smlnum = stdlib_dlamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_dlabad( smlnum, bignum )
           ks = 0
           loop_20: do k = 1, n
              ! determine whether condition numbers are required for the k-th
              ! eigenpair.
              if( somcon ) then
                 if( .not.select( k ) )cycle loop_20
              end if
              ks = ks + 1
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 rnrm = stdlib_dznrm2( n, vr( 1, ks ), 1 )
                 lnrm = stdlib_dznrm2( n, vl( 1, ks ), 1 )
                 call stdlib_zgemv( 'N', n, n, cmplx( one, zero,KIND=dp), a, lda,vr( 1, ks ), 1, &
                           cmplx( zero, zero,KIND=dp), work, 1 )
                 yhax = stdlib_zdotc( n, work, 1, vl( 1, ks ), 1 )
                 call stdlib_zgemv( 'N', n, n, cmplx( one, zero,KIND=dp), b, ldb,vr( 1, ks ), 1, &
                           cmplx( zero, zero,KIND=dp), work, 1 )
                 yhbx = stdlib_zdotc( n, work, 1, vl( 1, ks ), 1 )
                 cond = stdlib_dlapy2( abs( yhax ), abs( yhbx ) )
                 if( cond==zero ) then
                    s( ks ) = -one
                 else
                    s( ks ) = cond / ( rnrm*lnrm )
                 end if
              end if
              if( wantdf ) then
                 if( n==1 ) then
                    dif( ks ) = stdlib_dlapy2( abs( a( 1, 1 ) ), abs( b( 1, 1 ) ) )
                 else
                    ! estimate the reciprocal condition number of the k-th
                    ! eigenvectors.
                    ! copy the matrix (a, b) to the array work and move the
                    ! (k,k)th pair to the (1,1) position.
                    call stdlib_zlacpy( 'FULL', n, n, a, lda, work, n )
                    call stdlib_zlacpy( 'FULL', n, n, b, ldb, work( n*n+1 ), n )
                    ifst = k
                    ilst = 1
                    call stdlib_ztgexc( .false., .false., n, work, n, work( n*n+1 ),n, dummy, 1, &
                              dummy1, 1, ifst, ilst, ierr )
                    if( ierr>0 ) then
                       ! ill-conditioned problem - swap rejected.
                       dif( ks ) = zero
                    else
                       ! reordering successful, solve generalized sylvester
                       ! equation for r and l,
                                  ! a22 * r - l * a11 = a12
                                  ! b22 * r - l * b11 = b12,
                       ! and compute estimate of difl[(a11,b11), (a22, b22)].
                       n1 = 1
                       n2 = n - n1
                       i = n*n + 1
                       call stdlib_ztgsyl( 'N', idifjb, n2, n1, work( n*n1+n1+1 ),n, work, n, &
                       work( n1+1 ), n,work( n*n1+n1+i ), n, work( i ), n,work( n1+i ), n, scale, &
                                 dif( ks ), dummy,1, iwork, ierr )
                    end if
                 end if
              end if
           end do loop_20
           work( 1 ) = lwmin
           return
     end subroutine stdlib_ztgsna

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$tgsna( job, howmny, select, n, a, lda, b, ldb, vl,ldvl, vr, ldvr, s, &
     !! ZTGSNA: estimates reciprocal condition numbers for specified
     !! eigenvalues and/or eigenvectors of a matrix pair (A, B).
     !! (A, B) must be in generalized Schur canonical form, that is, A and
     !! B are both upper triangular.
               dif, mm, m, work, lwork,iwork, info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: howmny, job
           integer(ilp), intent(out) :: info, m
           integer(ilp), intent(in) :: lda, ldb, ldvl, ldvr, lwork, mm, n
           ! Array Arguments 
           logical(lk), intent(in) :: select(*)
           integer(ilp), intent(out) :: iwork(*)
           real(${ck}$), intent(out) :: dif(*), s(*)
           complex(${ck}$), intent(in) :: a(lda,*), b(ldb,*), vl(ldvl,*), vr(ldvr,*)
           complex(${ck}$), intent(out) :: work(*)
        ! =====================================================================
           ! Parameters 
           integer(ilp), parameter :: idifjb = 3
           
           
           ! Local Scalars 
           logical(lk) :: lquery, somcon, wantbh, wantdf, wants
           integer(ilp) :: i, ierr, ifst, ilst, k, ks, lwmin, n1, n2
           real(${ck}$) :: bignum, cond, eps, lnrm, rnrm, scale, smlnum
           complex(${ck}$) :: yhax, yhbx
           ! Local Arrays 
           complex(${ck}$) :: dummy(1), dummy1(1)
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode and test the input parameters
           wantbh = stdlib_lsame( job, 'B' )
           wants = stdlib_lsame( job, 'E' ) .or. wantbh
           wantdf = stdlib_lsame( job, 'V' ) .or. wantbh
           somcon = stdlib_lsame( howmny, 'S' )
           info = 0
           lquery = ( lwork==-1 )
           if( .not.wants .and. .not.wantdf ) then
              info = -1
           else if( .not.stdlib_lsame( howmny, 'A' ) .and. .not.somcon ) then
              info = -2
           else if( n<0 ) then
              info = -4
           else if( lda<max( 1, n ) ) then
              info = -6
           else if( ldb<max( 1, n ) ) then
              info = -8
           else if( wants .and. ldvl<n ) then
              info = -10
           else if( wants .and. ldvr<n ) then
              info = -12
           else
              ! set m to the number of eigenpairs for which condition numbers
              ! are required, and test mm.
              if( somcon ) then
                 m = 0
                 do k = 1, n
                    if( select( k ) )m = m + 1
                 end do
              else
                 m = n
              end if
              if( n==0 ) then
                 lwmin = 1
              else if( stdlib_lsame( job, 'V' ) .or. stdlib_lsame( job, 'B' ) ) then
                 lwmin = 2*n*n
              else
                 lwmin = n
              end if
              work( 1 ) = lwmin
              if( mm<m ) then
                 info = -15
              else if( lwork<lwmin .and. .not.lquery ) then
                 info = -18
              end if
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZTGSNA', -info )
              return
           else if( lquery ) then
              return
           end if
           ! quick return if possible
           if( n==0 )return
           ! get machine constants
           eps = stdlib_${c2ri(ci)}$lamch( 'P' )
           smlnum = stdlib_${c2ri(ci)}$lamch( 'S' ) / eps
           bignum = one / smlnum
           call stdlib_${c2ri(ci)}$labad( smlnum, bignum )
           ks = 0
           loop_20: do k = 1, n
              ! determine whether condition numbers are required for the k-th
              ! eigenpair.
              if( somcon ) then
                 if( .not.select( k ) )cycle loop_20
              end if
              ks = ks + 1
              if( wants ) then
                 ! compute the reciprocal condition number of the k-th
                 ! eigenvalue.
                 rnrm = stdlib_${c2ri(ci)}$znrm2( n, vr( 1, ks ), 1 )
                 lnrm = stdlib_${c2ri(ci)}$znrm2( n, vl( 1, ks ), 1 )
                 call stdlib_${ci}$gemv( 'N', n, n, cmplx( one, zero,KIND=${ck}$), a, lda,vr( 1, ks ), 1, &
                           cmplx( zero, zero,KIND=${ck}$), work, 1 )
                 yhax = stdlib_${ci}$dotc( n, work, 1, vl( 1, ks ), 1 )
                 call stdlib_${ci}$gemv( 'N', n, n, cmplx( one, zero,KIND=${ck}$), b, ldb,vr( 1, ks ), 1, &
                           cmplx( zero, zero,KIND=${ck}$), work, 1 )
                 yhbx = stdlib_${ci}$dotc( n, work, 1, vl( 1, ks ), 1 )
                 cond = stdlib_${c2ri(ci)}$lapy2( abs( yhax ), abs( yhbx ) )
                 if( cond==zero ) then
                    s( ks ) = -one
                 else
                    s( ks ) = cond / ( rnrm*lnrm )
                 end if
              end if
              if( wantdf ) then
                 if( n==1 ) then
                    dif( ks ) = stdlib_${c2ri(ci)}$lapy2( abs( a( 1, 1 ) ), abs( b( 1, 1 ) ) )
                 else
                    ! estimate the reciprocal condition number of the k-th
                    ! eigenvectors.
                    ! copy the matrix (a, b) to the array work and move the
                    ! (k,k)th pair to the (1,1) position.
                    call stdlib_${ci}$lacpy( 'FULL', n, n, a, lda, work, n )
                    call stdlib_${ci}$lacpy( 'FULL', n, n, b, ldb, work( n*n+1 ), n )
                    ifst = k
                    ilst = 1
                    call stdlib_${ci}$tgexc( .false., .false., n, work, n, work( n*n+1 ),n, dummy, 1, &
                              dummy1, 1, ifst, ilst, ierr )
                    if( ierr>0 ) then
                       ! ill-conditioned problem - swap rejected.
                       dif( ks ) = zero
                    else
                       ! reordering successful, solve generalized sylvester
                       ! equation for r and l,
                                  ! a22 * r - l * a11 = a12
                                  ! b22 * r - l * b11 = b12,
                       ! and compute estimate of difl[(a11,b11), (a22, b22)].
                       n1 = 1
                       n2 = n - n1
                       i = n*n + 1
                       call stdlib_${ci}$tgsyl( 'N', idifjb, n2, n1, work( n*n1+n1+1 ),n, work, n, &
                       work( n1+1 ), n,work( n*n1+n1+i ), n, work( i ), n,work( n1+i ), n, scale, &
                                 dif( ks ), dummy,1, iwork, ierr )
                    end if
                 end if
              end if
           end do loop_20
           work( 1 ) = lwmin
           return
     end subroutine stdlib_${ci}$tgsna

#:endif
#:endfor



     module pure subroutine stdlib_slagv2( a, lda, b, ldb, alphar, alphai, beta, csl, snl,csr, snr )
     !! SLAGV2 computes the Generalized Schur factorization of a real 2-by-2
     !! matrix pencil (A,B) where B is upper triangular. This routine
     !! computes orthogonal (rotation) matrices given by CSL, SNL and CSR,
     !! SNR such that
     !! 1) if the pencil (A,B) has two real eigenvalues (include 0/0 or 1/0
     !! types), then
     !! [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
     !! [  0  a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]
     !! [ b11 b12 ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
     !! [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ],
     !! 2) if the pencil (A,B) has a pair of complex conjugate eigenvalues,
     !! then
     !! [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
     !! [ a21 a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]
     !! [ b11  0  ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
     !! [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ]
     !! where b11 >= b22 > 0.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: lda, ldb
           real(sp), intent(out) :: csl, csr, snl, snr
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), b(ldb,*)
           real(sp), intent(out) :: alphai(2), alphar(2), beta(2)
        ! =====================================================================
           
           ! Local Scalars 
           real(sp) :: anorm, ascale, bnorm, bscale, h1, h2, h3, qq, r, rr, safmin, scale1, &
                     scale2, t, ulp, wi, wr1, wr2
           ! Intrinsic Functions 
           ! Executable Statements 
           safmin = stdlib_slamch( 'S' )
           ulp = stdlib_slamch( 'P' )
           ! scale a
           anorm = max( abs( a( 1, 1 ) )+abs( a( 2, 1 ) ),abs( a( 1, 2 ) )+abs( a( 2, 2 ) ), &
                     safmin )
           ascale = one / anorm
           a( 1, 1 ) = ascale*a( 1, 1 )
           a( 1, 2 ) = ascale*a( 1, 2 )
           a( 2, 1 ) = ascale*a( 2, 1 )
           a( 2, 2 ) = ascale*a( 2, 2 )
           ! scale b
           bnorm = max( abs( b( 1, 1 ) ), abs( b( 1, 2 ) )+abs( b( 2, 2 ) ),safmin )
           bscale = one / bnorm
           b( 1, 1 ) = bscale*b( 1, 1 )
           b( 1, 2 ) = bscale*b( 1, 2 )
           b( 2, 2 ) = bscale*b( 2, 2 )
           ! check if a can be deflated
           if( abs( a( 2, 1 ) )<=ulp ) then
              csl = one
              snl = zero
              csr = one
              snr = zero
              a( 2, 1 ) = zero
              b( 2, 1 ) = zero
              wi = zero
           ! check if b is singular
           else if( abs( b( 1, 1 ) )<=ulp ) then
              call stdlib_slartg( a( 1, 1 ), a( 2, 1 ), csl, snl, r )
              csr = one
              snr = zero
              call stdlib_srot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
              call stdlib_srot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
              a( 2, 1 ) = zero
              b( 1, 1 ) = zero
              b( 2, 1 ) = zero
              wi = zero
           else if( abs( b( 2, 2 ) )<=ulp ) then
              call stdlib_slartg( a( 2, 2 ), a( 2, 1 ), csr, snr, t )
              snr = -snr
              call stdlib_srot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
              call stdlib_srot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
              csl = one
              snl = zero
              a( 2, 1 ) = zero
              b( 2, 1 ) = zero
              b( 2, 2 ) = zero
              wi = zero
           else
              ! b is nonsingular, first compute the eigenvalues of (a,b)
              call stdlib_slag2( a, lda, b, ldb, safmin, scale1, scale2, wr1, wr2,wi )
              if( wi==zero ) then
                 ! two real eigenvalues, compute s*a-w*b
                 h1 = scale1*a( 1, 1 ) - wr1*b( 1, 1 )
                 h2 = scale1*a( 1, 2 ) - wr1*b( 1, 2 )
                 h3 = scale1*a( 2, 2 ) - wr1*b( 2, 2 )
                 rr = stdlib_slapy2( h1, h2 )
                 qq = stdlib_slapy2( scale1*a( 2, 1 ), h3 )
                 if( rr>qq ) then
                    ! find right rotation matrix to zero 1,1 element of
                    ! (sa - wb)
                    call stdlib_slartg( h2, h1, csr, snr, t )
                 else
                    ! find right rotation matrix to zero 2,1 element of
                    ! (sa - wb)
                    call stdlib_slartg( h3, scale1*a( 2, 1 ), csr, snr, t )
                 end if
                 snr = -snr
                 call stdlib_srot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
                 call stdlib_srot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
                 ! compute inf norms of a and b
                 h1 = max( abs( a( 1, 1 ) )+abs( a( 1, 2 ) ),abs( a( 2, 1 ) )+abs( a( 2, 2 ) ) )
                           
                 h2 = max( abs( b( 1, 1 ) )+abs( b( 1, 2 ) ),abs( b( 2, 1 ) )+abs( b( 2, 2 ) ) )
                           
                 if( ( scale1*h1 )>=abs( wr1 )*h2 ) then
                    ! find left rotation matrix q to zero out b(2,1)
                    call stdlib_slartg( b( 1, 1 ), b( 2, 1 ), csl, snl, r )
                 else
                    ! find left rotation matrix q to zero out a(2,1)
                    call stdlib_slartg( a( 1, 1 ), a( 2, 1 ), csl, snl, r )
                 end if
                 call stdlib_srot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
                 call stdlib_srot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
                 a( 2, 1 ) = zero
                 b( 2, 1 ) = zero
              else
                 ! a pair of complex conjugate eigenvalues
                 ! first compute the svd of the matrix b
                 call stdlib_slasv2( b( 1, 1 ), b( 1, 2 ), b( 2, 2 ), r, t, snr,csr, snl, csl )
                           
                 ! form (a,b) := q(a,b)z**t where q is left rotation matrix and
                 ! z is right rotation matrix computed from stdlib_slasv2
                 call stdlib_srot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
                 call stdlib_srot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
                 call stdlib_srot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
                 call stdlib_srot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
                 b( 2, 1 ) = zero
                 b( 1, 2 ) = zero
              end if
           end if
           ! unscaling
           a( 1, 1 ) = anorm*a( 1, 1 )
           a( 2, 1 ) = anorm*a( 2, 1 )
           a( 1, 2 ) = anorm*a( 1, 2 )
           a( 2, 2 ) = anorm*a( 2, 2 )
           b( 1, 1 ) = bnorm*b( 1, 1 )
           b( 2, 1 ) = bnorm*b( 2, 1 )
           b( 1, 2 ) = bnorm*b( 1, 2 )
           b( 2, 2 ) = bnorm*b( 2, 2 )
           if( wi==zero ) then
              alphar( 1 ) = a( 1, 1 )
              alphar( 2 ) = a( 2, 2 )
              alphai( 1 ) = zero
              alphai( 2 ) = zero
              beta( 1 ) = b( 1, 1 )
              beta( 2 ) = b( 2, 2 )
           else
              alphar( 1 ) = anorm*wr1 / scale1 / bnorm
              alphai( 1 ) = anorm*wi / scale1 / bnorm
              alphar( 2 ) = alphar( 1 )
              alphai( 2 ) = -alphai( 1 )
              beta( 1 ) = one
              beta( 2 ) = one
           end if
           return
     end subroutine stdlib_slagv2

     module pure subroutine stdlib_dlagv2( a, lda, b, ldb, alphar, alphai, beta, csl, snl,csr, snr )
     !! DLAGV2 computes the Generalized Schur factorization of a real 2-by-2
     !! matrix pencil (A,B) where B is upper triangular. This routine
     !! computes orthogonal (rotation) matrices given by CSL, SNL and CSR,
     !! SNR such that
     !! 1) if the pencil (A,B) has two real eigenvalues (include 0/0 or 1/0
     !! types), then
     !! [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
     !! [  0  a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]
     !! [ b11 b12 ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
     !! [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ],
     !! 2) if the pencil (A,B) has a pair of complex conjugate eigenvalues,
     !! then
     !! [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
     !! [ a21 a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]
     !! [ b11  0  ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
     !! [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ]
     !! where b11 >= b22 > 0.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: lda, ldb
           real(dp), intent(out) :: csl, csr, snl, snr
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), b(ldb,*)
           real(dp), intent(out) :: alphai(2), alphar(2), beta(2)
        ! =====================================================================
           
           ! Local Scalars 
           real(dp) :: anorm, ascale, bnorm, bscale, h1, h2, h3, qq, r, rr, safmin, scale1, &
                     scale2, t, ulp, wi, wr1, wr2
           ! Intrinsic Functions 
           ! Executable Statements 
           safmin = stdlib_dlamch( 'S' )
           ulp = stdlib_dlamch( 'P' )
           ! scale a
           anorm = max( abs( a( 1, 1 ) )+abs( a( 2, 1 ) ),abs( a( 1, 2 ) )+abs( a( 2, 2 ) ), &
                     safmin )
           ascale = one / anorm
           a( 1, 1 ) = ascale*a( 1, 1 )
           a( 1, 2 ) = ascale*a( 1, 2 )
           a( 2, 1 ) = ascale*a( 2, 1 )
           a( 2, 2 ) = ascale*a( 2, 2 )
           ! scale b
           bnorm = max( abs( b( 1, 1 ) ), abs( b( 1, 2 ) )+abs( b( 2, 2 ) ),safmin )
           bscale = one / bnorm
           b( 1, 1 ) = bscale*b( 1, 1 )
           b( 1, 2 ) = bscale*b( 1, 2 )
           b( 2, 2 ) = bscale*b( 2, 2 )
           ! check if a can be deflated
           if( abs( a( 2, 1 ) )<=ulp ) then
              csl = one
              snl = zero
              csr = one
              snr = zero
              a( 2, 1 ) = zero
              b( 2, 1 ) = zero
              wi = zero
           ! check if b is singular
           else if( abs( b( 1, 1 ) )<=ulp ) then
              call stdlib_dlartg( a( 1, 1 ), a( 2, 1 ), csl, snl, r )
              csr = one
              snr = zero
              call stdlib_drot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
              call stdlib_drot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
              a( 2, 1 ) = zero
              b( 1, 1 ) = zero
              b( 2, 1 ) = zero
              wi = zero
           else if( abs( b( 2, 2 ) )<=ulp ) then
              call stdlib_dlartg( a( 2, 2 ), a( 2, 1 ), csr, snr, t )
              snr = -snr
              call stdlib_drot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
              call stdlib_drot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
              csl = one
              snl = zero
              a( 2, 1 ) = zero
              b( 2, 1 ) = zero
              b( 2, 2 ) = zero
              wi = zero
           else
              ! b is nonsingular, first compute the eigenvalues of (a,b)
              call stdlib_dlag2( a, lda, b, ldb, safmin, scale1, scale2, wr1, wr2,wi )
              if( wi==zero ) then
                 ! two real eigenvalues, compute s*a-w*b
                 h1 = scale1*a( 1, 1 ) - wr1*b( 1, 1 )
                 h2 = scale1*a( 1, 2 ) - wr1*b( 1, 2 )
                 h3 = scale1*a( 2, 2 ) - wr1*b( 2, 2 )
                 rr = stdlib_dlapy2( h1, h2 )
                 qq = stdlib_dlapy2( scale1*a( 2, 1 ), h3 )
                 if( rr>qq ) then
                    ! find right rotation matrix to zero 1,1 element of
                    ! (sa - wb)
                    call stdlib_dlartg( h2, h1, csr, snr, t )
                 else
                    ! find right rotation matrix to zero 2,1 element of
                    ! (sa - wb)
                    call stdlib_dlartg( h3, scale1*a( 2, 1 ), csr, snr, t )
                 end if
                 snr = -snr
                 call stdlib_drot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
                 call stdlib_drot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
                 ! compute inf norms of a and b
                 h1 = max( abs( a( 1, 1 ) )+abs( a( 1, 2 ) ),abs( a( 2, 1 ) )+abs( a( 2, 2 ) ) )
                           
                 h2 = max( abs( b( 1, 1 ) )+abs( b( 1, 2 ) ),abs( b( 2, 1 ) )+abs( b( 2, 2 ) ) )
                           
                 if( ( scale1*h1 )>=abs( wr1 )*h2 ) then
                    ! find left rotation matrix q to zero out b(2,1)
                    call stdlib_dlartg( b( 1, 1 ), b( 2, 1 ), csl, snl, r )
                 else
                    ! find left rotation matrix q to zero out a(2,1)
                    call stdlib_dlartg( a( 1, 1 ), a( 2, 1 ), csl, snl, r )
                 end if
                 call stdlib_drot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
                 call stdlib_drot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
                 a( 2, 1 ) = zero
                 b( 2, 1 ) = zero
              else
                 ! a pair of complex conjugate eigenvalues
                 ! first compute the svd of the matrix b
                 call stdlib_dlasv2( b( 1, 1 ), b( 1, 2 ), b( 2, 2 ), r, t, snr,csr, snl, csl )
                           
                 ! form (a,b) := q(a,b)z**t where q is left rotation matrix and
                 ! z is right rotation matrix computed from stdlib_dlasv2
                 call stdlib_drot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
                 call stdlib_drot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
                 call stdlib_drot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
                 call stdlib_drot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
                 b( 2, 1 ) = zero
                 b( 1, 2 ) = zero
              end if
           end if
           ! unscaling
           a( 1, 1 ) = anorm*a( 1, 1 )
           a( 2, 1 ) = anorm*a( 2, 1 )
           a( 1, 2 ) = anorm*a( 1, 2 )
           a( 2, 2 ) = anorm*a( 2, 2 )
           b( 1, 1 ) = bnorm*b( 1, 1 )
           b( 2, 1 ) = bnorm*b( 2, 1 )
           b( 1, 2 ) = bnorm*b( 1, 2 )
           b( 2, 2 ) = bnorm*b( 2, 2 )
           if( wi==zero ) then
              alphar( 1 ) = a( 1, 1 )
              alphar( 2 ) = a( 2, 2 )
              alphai( 1 ) = zero
              alphai( 2 ) = zero
              beta( 1 ) = b( 1, 1 )
              beta( 2 ) = b( 2, 2 )
           else
              alphar( 1 ) = anorm*wr1 / scale1 / bnorm
              alphai( 1 ) = anorm*wi / scale1 / bnorm
              alphar( 2 ) = alphar( 1 )
              alphai( 2 ) = -alphai( 1 )
              beta( 1 ) = one
              beta( 2 ) = one
           end if
           return
     end subroutine stdlib_dlagv2

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$lagv2( a, lda, b, ldb, alphar, alphai, beta, csl, snl,csr, snr )
     !! DLAGV2: computes the Generalized Schur factorization of a real 2-by-2
     !! matrix pencil (A,B) where B is upper triangular. This routine
     !! computes orthogonal (rotation) matrices given by CSL, SNL and CSR,
     !! SNR such that
     !! 1) if the pencil (A,B) has two real eigenvalues (include 0/0 or 1/0
     !! types), then
     !! [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
     !! [  0  a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]
     !! [ b11 b12 ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
     !! [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ],
     !! 2) if the pencil (A,B) has a pair of complex conjugate eigenvalues,
     !! then
     !! [ a11 a12 ] := [  CSL  SNL ] [ a11 a12 ] [  CSR -SNR ]
     !! [ a21 a22 ]    [ -SNL  CSL ] [ a21 a22 ] [  SNR  CSR ]
     !! [ b11  0  ] := [  CSL  SNL ] [ b11 b12 ] [  CSR -SNR ]
     !! [  0  b22 ]    [ -SNL  CSL ] [  0  b22 ] [  SNR  CSR ]
     !! where b11 >= b22 > 0.
               
        ! -- lapack auxiliary routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           integer(ilp), intent(in) :: lda, ldb
           real(${rk}$), intent(out) :: csl, csr, snl, snr
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*)
           real(${rk}$), intent(out) :: alphai(2), alphar(2), beta(2)
        ! =====================================================================
           
           ! Local Scalars 
           real(${rk}$) :: anorm, ascale, bnorm, bscale, h1, h2, h3, qq, r, rr, safmin, scale1, &
                     scale2, t, ulp, wi, wr1, wr2
           ! Intrinsic Functions 
           ! Executable Statements 
           safmin = stdlib_${ri}$lamch( 'S' )
           ulp = stdlib_${ri}$lamch( 'P' )
           ! scale a
           anorm = max( abs( a( 1, 1 ) )+abs( a( 2, 1 ) ),abs( a( 1, 2 ) )+abs( a( 2, 2 ) ), &
                     safmin )
           ascale = one / anorm
           a( 1, 1 ) = ascale*a( 1, 1 )
           a( 1, 2 ) = ascale*a( 1, 2 )
           a( 2, 1 ) = ascale*a( 2, 1 )
           a( 2, 2 ) = ascale*a( 2, 2 )
           ! scale b
           bnorm = max( abs( b( 1, 1 ) ), abs( b( 1, 2 ) )+abs( b( 2, 2 ) ),safmin )
           bscale = one / bnorm
           b( 1, 1 ) = bscale*b( 1, 1 )
           b( 1, 2 ) = bscale*b( 1, 2 )
           b( 2, 2 ) = bscale*b( 2, 2 )
           ! check if a can be deflated
           if( abs( a( 2, 1 ) )<=ulp ) then
              csl = one
              snl = zero
              csr = one
              snr = zero
              a( 2, 1 ) = zero
              b( 2, 1 ) = zero
              wi = zero
           ! check if b is singular
           else if( abs( b( 1, 1 ) )<=ulp ) then
              call stdlib_${ri}$lartg( a( 1, 1 ), a( 2, 1 ), csl, snl, r )
              csr = one
              snr = zero
              call stdlib_${ri}$rot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
              call stdlib_${ri}$rot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
              a( 2, 1 ) = zero
              b( 1, 1 ) = zero
              b( 2, 1 ) = zero
              wi = zero
           else if( abs( b( 2, 2 ) )<=ulp ) then
              call stdlib_${ri}$lartg( a( 2, 2 ), a( 2, 1 ), csr, snr, t )
              snr = -snr
              call stdlib_${ri}$rot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
              call stdlib_${ri}$rot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
              csl = one
              snl = zero
              a( 2, 1 ) = zero
              b( 2, 1 ) = zero
              b( 2, 2 ) = zero
              wi = zero
           else
              ! b is nonsingular, first compute the eigenvalues of (a,b)
              call stdlib_${ri}$lag2( a, lda, b, ldb, safmin, scale1, scale2, wr1, wr2,wi )
              if( wi==zero ) then
                 ! two real eigenvalues, compute s*a-w*b
                 h1 = scale1*a( 1, 1 ) - wr1*b( 1, 1 )
                 h2 = scale1*a( 1, 2 ) - wr1*b( 1, 2 )
                 h3 = scale1*a( 2, 2 ) - wr1*b( 2, 2 )
                 rr = stdlib_${ri}$lapy2( h1, h2 )
                 qq = stdlib_${ri}$lapy2( scale1*a( 2, 1 ), h3 )
                 if( rr>qq ) then
                    ! find right rotation matrix to zero 1,1 element of
                    ! (sa - wb)
                    call stdlib_${ri}$lartg( h2, h1, csr, snr, t )
                 else
                    ! find right rotation matrix to zero 2,1 element of
                    ! (sa - wb)
                    call stdlib_${ri}$lartg( h3, scale1*a( 2, 1 ), csr, snr, t )
                 end if
                 snr = -snr
                 call stdlib_${ri}$rot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
                 call stdlib_${ri}$rot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
                 ! compute inf norms of a and b
                 h1 = max( abs( a( 1, 1 ) )+abs( a( 1, 2 ) ),abs( a( 2, 1 ) )+abs( a( 2, 2 ) ) )
                           
                 h2 = max( abs( b( 1, 1 ) )+abs( b( 1, 2 ) ),abs( b( 2, 1 ) )+abs( b( 2, 2 ) ) )
                           
                 if( ( scale1*h1 )>=abs( wr1 )*h2 ) then
                    ! find left rotation matrix q to zero out b(2,1)
                    call stdlib_${ri}$lartg( b( 1, 1 ), b( 2, 1 ), csl, snl, r )
                 else
                    ! find left rotation matrix q to zero out a(2,1)
                    call stdlib_${ri}$lartg( a( 1, 1 ), a( 2, 1 ), csl, snl, r )
                 end if
                 call stdlib_${ri}$rot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
                 call stdlib_${ri}$rot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
                 a( 2, 1 ) = zero
                 b( 2, 1 ) = zero
              else
                 ! a pair of complex conjugate eigenvalues
                 ! first compute the svd of the matrix b
                 call stdlib_${ri}$lasv2( b( 1, 1 ), b( 1, 2 ), b( 2, 2 ), r, t, snr,csr, snl, csl )
                           
                 ! form (a,b) := q(a,b)z**t where q is left rotation matrix and
                 ! z is right rotation matrix computed from stdlib_${ri}$lasv2
                 call stdlib_${ri}$rot( 2, a( 1, 1 ), lda, a( 2, 1 ), lda, csl, snl )
                 call stdlib_${ri}$rot( 2, b( 1, 1 ), ldb, b( 2, 1 ), ldb, csl, snl )
                 call stdlib_${ri}$rot( 2, a( 1, 1 ), 1, a( 1, 2 ), 1, csr, snr )
                 call stdlib_${ri}$rot( 2, b( 1, 1 ), 1, b( 1, 2 ), 1, csr, snr )
                 b( 2, 1 ) = zero
                 b( 1, 2 ) = zero
              end if
           end if
           ! unscaling
           a( 1, 1 ) = anorm*a( 1, 1 )
           a( 2, 1 ) = anorm*a( 2, 1 )
           a( 1, 2 ) = anorm*a( 1, 2 )
           a( 2, 2 ) = anorm*a( 2, 2 )
           b( 1, 1 ) = bnorm*b( 1, 1 )
           b( 2, 1 ) = bnorm*b( 2, 1 )
           b( 1, 2 ) = bnorm*b( 1, 2 )
           b( 2, 2 ) = bnorm*b( 2, 2 )
           if( wi==zero ) then
              alphar( 1 ) = a( 1, 1 )
              alphar( 2 ) = a( 2, 2 )
              alphai( 1 ) = zero
              alphai( 2 ) = zero
              beta( 1 ) = b( 1, 1 )
              beta( 2 ) = b( 2, 2 )
           else
              alphar( 1 ) = anorm*wr1 / scale1 / bnorm
              alphai( 1 ) = anorm*wi / scale1 / bnorm
              alphar( 2 ) = alphar( 1 )
              alphai( 2 ) = -alphai( 1 )
              beta( 1 ) = one
              beta( 2 ) = one
           end if
           return
     end subroutine stdlib_${ri}$lagv2

#:endif
#:endfor



     module pure subroutine stdlib_sgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! SGGHRD reduces a pair of real matrices (A,B) to generalized upper
     !! Hessenberg form using orthogonal transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the orthogonal matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**T*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**T*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**T*x.
     !! The orthogonal matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T
     !! Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T
     !! If Q1 is the orthogonal matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then SGGHRD reduces the original
     !! problem to generalized Hessenberg form.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilq, ilz
           integer(ilp) :: icompq, icompz, jcol, jrow
           real(sp) :: c, s, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode compq
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           ! decode compz
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! test the input parameters.
           info = 0
           if( icompq<=0 ) then
              info = -1
           else if( icompz<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( ilq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( ilz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGGHRD', -info )
              return
           end if
           ! initialize q and z if desired.
           if( icompq==3 )call stdlib_slaset( 'FULL', n, n, zero, one, q, ldq )
           if( icompz==3 )call stdlib_slaset( 'FULL', n, n, zero, one, z, ldz )
           ! quick return if possible
           if( n<=1 )return
           ! zero out lower triangle of b
           do jcol = 1, n - 1
              do jrow = jcol + 1, n
                 b( jrow, jcol ) = zero
              end do
           end do
           ! reduce a and b
           do jcol = ilo, ihi - 2
              do jrow = ihi, jcol + 2, -1
                 ! step 1: rotate rows jrow-1, jrow to kill a(jrow,jcol)
                 temp = a( jrow-1, jcol )
                 call stdlib_slartg( temp, a( jrow, jcol ), c, s,a( jrow-1, jcol ) )
                 a( jrow, jcol ) = zero
                 call stdlib_srot( n-jcol, a( jrow-1, jcol+1 ), lda,a( jrow, jcol+1 ), lda, c, s )
                           
                 call stdlib_srot( n+2-jrow, b( jrow-1, jrow-1 ), ldb,b( jrow, jrow-1 ), ldb, c, &
                           s )
                 if( ilq )call stdlib_srot( n, q( 1, jrow-1 ), 1, q( 1, jrow ), 1, c, s )
                 ! step 2: rotate columns jrow, jrow-1 to kill b(jrow,jrow-1)
                 temp = b( jrow, jrow )
                 call stdlib_slartg( temp, b( jrow, jrow-1 ), c, s,b( jrow, jrow ) )
                 b( jrow, jrow-1 ) = zero
                 call stdlib_srot( ihi, a( 1, jrow ), 1, a( 1, jrow-1 ), 1, c, s )
                 call stdlib_srot( jrow-1, b( 1, jrow ), 1, b( 1, jrow-1 ), 1, c,s )
                 if( ilz )call stdlib_srot( n, z( 1, jrow ), 1, z( 1, jrow-1 ), 1, c, s )
              end do
           end do
           return
     end subroutine stdlib_sgghrd

     module pure subroutine stdlib_dgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! DGGHRD reduces a pair of real matrices (A,B) to generalized upper
     !! Hessenberg form using orthogonal transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the orthogonal matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**T*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**T*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**T*x.
     !! The orthogonal matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T
     !! Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T
     !! If Q1 is the orthogonal matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then DGGHRD reduces the original
     !! problem to generalized Hessenberg form.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilq, ilz
           integer(ilp) :: icompq, icompz, jcol, jrow
           real(dp) :: c, s, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode compq
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           ! decode compz
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! test the input parameters.
           info = 0
           if( icompq<=0 ) then
              info = -1
           else if( icompz<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( ilq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( ilz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGHRD', -info )
              return
           end if
           ! initialize q and z if desired.
           if( icompq==3 )call stdlib_dlaset( 'FULL', n, n, zero, one, q, ldq )
           if( icompz==3 )call stdlib_dlaset( 'FULL', n, n, zero, one, z, ldz )
           ! quick return if possible
           if( n<=1 )return
           ! zero out lower triangle of b
           do jcol = 1, n - 1
              do jrow = jcol + 1, n
                 b( jrow, jcol ) = zero
              end do
           end do
           ! reduce a and b
           do jcol = ilo, ihi - 2
              do jrow = ihi, jcol + 2, -1
                 ! step 1: rotate rows jrow-1, jrow to kill a(jrow,jcol)
                 temp = a( jrow-1, jcol )
                 call stdlib_dlartg( temp, a( jrow, jcol ), c, s,a( jrow-1, jcol ) )
                 a( jrow, jcol ) = zero
                 call stdlib_drot( n-jcol, a( jrow-1, jcol+1 ), lda,a( jrow, jcol+1 ), lda, c, s )
                           
                 call stdlib_drot( n+2-jrow, b( jrow-1, jrow-1 ), ldb,b( jrow, jrow-1 ), ldb, c, &
                           s )
                 if( ilq )call stdlib_drot( n, q( 1, jrow-1 ), 1, q( 1, jrow ), 1, c, s )
                 ! step 2: rotate columns jrow, jrow-1 to kill b(jrow,jrow-1)
                 temp = b( jrow, jrow )
                 call stdlib_dlartg( temp, b( jrow, jrow-1 ), c, s,b( jrow, jrow ) )
                 b( jrow, jrow-1 ) = zero
                 call stdlib_drot( ihi, a( 1, jrow ), 1, a( 1, jrow-1 ), 1, c, s )
                 call stdlib_drot( jrow-1, b( 1, jrow ), 1, b( 1, jrow-1 ), 1, c,s )
                 if( ilz )call stdlib_drot( n, z( 1, jrow ), 1, z( 1, jrow-1 ), 1, c, s )
              end do
           end do
           return
     end subroutine stdlib_dgghrd

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$gghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! DGGHRD: reduces a pair of real matrices (A,B) to generalized upper
     !! Hessenberg form using orthogonal transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the orthogonal matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**T*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**T*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**T*x.
     !! The orthogonal matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**T = (Q1*Q) * H * (Z1*Z)**T
     !! Q1 * B * Z1**T = (Q1*Q) * T * (Z1*Z)**T
     !! If Q1 is the orthogonal matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then DGGHRD reduces the original
     !! problem to generalized Hessenberg form.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilq, ilz
           integer(ilp) :: icompq, icompz, jcol, jrow
           real(${rk}$) :: c, s, temp
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode compq
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           ! decode compz
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! test the input parameters.
           info = 0
           if( icompq<=0 ) then
              info = -1
           else if( icompz<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( ilq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( ilz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGHRD', -info )
              return
           end if
           ! initialize q and z if desired.
           if( icompq==3 )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, q, ldq )
           if( icompz==3 )call stdlib_${ri}$laset( 'FULL', n, n, zero, one, z, ldz )
           ! quick return if possible
           if( n<=1 )return
           ! zero out lower triangle of b
           do jcol = 1, n - 1
              do jrow = jcol + 1, n
                 b( jrow, jcol ) = zero
              end do
           end do
           ! reduce a and b
           do jcol = ilo, ihi - 2
              do jrow = ihi, jcol + 2, -1
                 ! step 1: rotate rows jrow-1, jrow to kill a(jrow,jcol)
                 temp = a( jrow-1, jcol )
                 call stdlib_${ri}$lartg( temp, a( jrow, jcol ), c, s,a( jrow-1, jcol ) )
                 a( jrow, jcol ) = zero
                 call stdlib_${ri}$rot( n-jcol, a( jrow-1, jcol+1 ), lda,a( jrow, jcol+1 ), lda, c, s )
                           
                 call stdlib_${ri}$rot( n+2-jrow, b( jrow-1, jrow-1 ), ldb,b( jrow, jrow-1 ), ldb, c, &
                           s )
                 if( ilq )call stdlib_${ri}$rot( n, q( 1, jrow-1 ), 1, q( 1, jrow ), 1, c, s )
                 ! step 2: rotate columns jrow, jrow-1 to kill b(jrow,jrow-1)
                 temp = b( jrow, jrow )
                 call stdlib_${ri}$lartg( temp, b( jrow, jrow-1 ), c, s,b( jrow, jrow ) )
                 b( jrow, jrow-1 ) = zero
                 call stdlib_${ri}$rot( ihi, a( 1, jrow ), 1, a( 1, jrow-1 ), 1, c, s )
                 call stdlib_${ri}$rot( jrow-1, b( 1, jrow ), 1, b( 1, jrow-1 ), 1, c,s )
                 if( ilz )call stdlib_${ri}$rot( n, z( 1, jrow ), 1, z( 1, jrow-1 ), 1, c, s )
              end do
           end do
           return
     end subroutine stdlib_${ri}$gghrd

#:endif
#:endfor

     module pure subroutine stdlib_cgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! CGGHRD reduces a pair of complex matrices (A,B) to generalized upper
     !! Hessenberg form using unitary transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the generalized
     !! eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the unitary matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**H*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**H*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**H*x.
     !! The unitary matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
     !! Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
     !! If Q1 is the unitary matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then CGGHRD reduces the original
     !! problem to generalized Hessenberg form.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(sp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilq, ilz
           integer(ilp) :: icompq, icompz, jcol, jrow
           real(sp) :: c
           complex(sp) :: ctemp, s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode compq
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           ! decode compz
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! test the input parameters.
           info = 0
           if( icompq<=0 ) then
              info = -1
           else if( icompz<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( ilq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( ilz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGHRD', -info )
              return
           end if
           ! initialize q and z if desired.
           if( icompq==3 )call stdlib_claset( 'FULL', n, n, czero, cone, q, ldq )
           if( icompz==3 )call stdlib_claset( 'FULL', n, n, czero, cone, z, ldz )
           ! quick return if possible
           if( n<=1 )return
           ! zero out lower triangle of b
           do jcol = 1, n - 1
              do jrow = jcol + 1, n
                 b( jrow, jcol ) = czero
              end do
           end do
           ! reduce a and b
           do jcol = ilo, ihi - 2
              do jrow = ihi, jcol + 2, -1
                 ! step 1: rotate rows jrow-1, jrow to kill a(jrow,jcol)
                 ctemp = a( jrow-1, jcol )
                 call stdlib_clartg( ctemp, a( jrow, jcol ), c, s,a( jrow-1, jcol ) )
                 a( jrow, jcol ) = czero
                 call stdlib_crot( n-jcol, a( jrow-1, jcol+1 ), lda,a( jrow, jcol+1 ), lda, c, s )
                           
                 call stdlib_crot( n+2-jrow, b( jrow-1, jrow-1 ), ldb,b( jrow, jrow-1 ), ldb, c, &
                           s )
                 if( ilq )call stdlib_crot( n, q( 1, jrow-1 ), 1, q( 1, jrow ), 1, c,conjg( s ) )
                           
                 ! step 2: rotate columns jrow, jrow-1 to kill b(jrow,jrow-1)
                 ctemp = b( jrow, jrow )
                 call stdlib_clartg( ctemp, b( jrow, jrow-1 ), c, s,b( jrow, jrow ) )
                 b( jrow, jrow-1 ) = czero
                 call stdlib_crot( ihi, a( 1, jrow ), 1, a( 1, jrow-1 ), 1, c, s )
                 call stdlib_crot( jrow-1, b( 1, jrow ), 1, b( 1, jrow-1 ), 1, c,s )
                 if( ilz )call stdlib_crot( n, z( 1, jrow ), 1, z( 1, jrow-1 ), 1, c, s )
              end do
           end do
           return
     end subroutine stdlib_cgghrd

     module pure subroutine stdlib_zgghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! ZGGHRD reduces a pair of complex matrices (A,B) to generalized upper
     !! Hessenberg form using unitary transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the unitary matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**H*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**H*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**H*x.
     !! The unitary matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
     !! Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
     !! If Q1 is the unitary matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then ZGGHRD reduces the original
     !! problem to generalized Hessenberg form.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(dp), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilq, ilz
           integer(ilp) :: icompq, icompz, jcol, jrow
           real(dp) :: c
           complex(dp) :: ctemp, s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode compq
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           ! decode compz
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! test the input parameters.
           info = 0
           if( icompq<=0 ) then
              info = -1
           else if( icompz<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( ilq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( ilz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGHRD', -info )
              return
           end if
           ! initialize q and z if desired.
           if( icompq==3 )call stdlib_zlaset( 'FULL', n, n, czero, cone, q, ldq )
           if( icompz==3 )call stdlib_zlaset( 'FULL', n, n, czero, cone, z, ldz )
           ! quick return if possible
           if( n<=1 )return
           ! zero out lower triangle of b
           do jcol = 1, n - 1
              do jrow = jcol + 1, n
                 b( jrow, jcol ) = czero
              end do
           end do
           ! reduce a and b
           do jcol = ilo, ihi - 2
              do jrow = ihi, jcol + 2, -1
                 ! step 1: rotate rows jrow-1, jrow to kill a(jrow,jcol)
                 ctemp = a( jrow-1, jcol )
                 call stdlib_zlartg( ctemp, a( jrow, jcol ), c, s,a( jrow-1, jcol ) )
                 a( jrow, jcol ) = czero
                 call stdlib_zrot( n-jcol, a( jrow-1, jcol+1 ), lda,a( jrow, jcol+1 ), lda, c, s )
                           
                 call stdlib_zrot( n+2-jrow, b( jrow-1, jrow-1 ), ldb,b( jrow, jrow-1 ), ldb, c, &
                           s )
                 if( ilq )call stdlib_zrot( n, q( 1, jrow-1 ), 1, q( 1, jrow ), 1, c,conjg( s ) )
                           
                 ! step 2: rotate columns jrow, jrow-1 to kill b(jrow,jrow-1)
                 ctemp = b( jrow, jrow )
                 call stdlib_zlartg( ctemp, b( jrow, jrow-1 ), c, s,b( jrow, jrow ) )
                 b( jrow, jrow-1 ) = czero
                 call stdlib_zrot( ihi, a( 1, jrow ), 1, a( 1, jrow-1 ), 1, c, s )
                 call stdlib_zrot( jrow-1, b( 1, jrow ), 1, b( 1, jrow-1 ), 1, c,s )
                 if( ilz )call stdlib_zrot( n, z( 1, jrow ), 1, z( 1, jrow-1 ), 1, c, s )
              end do
           end do
           return
     end subroutine stdlib_zgghrd

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$gghrd( compq, compz, n, ilo, ihi, a, lda, b, ldb, q,ldq, z, ldz, &
     !! ZGGHRD: reduces a pair of complex matrices (A,B) to generalized upper
     !! Hessenberg form using unitary transformations, where A is a
     !! general matrix and B is upper triangular.  The form of the
     !! generalized eigenvalue problem is
     !! A*x = lambda*B*x,
     !! and B is typically made upper triangular by computing its QR
     !! factorization and moving the unitary matrix Q to the left side
     !! of the equation.
     !! This subroutine simultaneously reduces A to a Hessenberg matrix H:
     !! Q**H*A*Z = H
     !! and transforms B to another upper triangular matrix T:
     !! Q**H*B*Z = T
     !! in order to reduce the problem to its standard form
     !! H*y = lambda*T*y
     !! where y = Z**H*x.
     !! The unitary matrices Q and Z are determined as products of Givens
     !! rotations.  They may either be formed explicitly, or they may be
     !! postmultiplied into input matrices Q1 and Z1, so that
     !! Q1 * A * Z1**H = (Q1*Q) * H * (Z1*Z)**H
     !! Q1 * B * Z1**H = (Q1*Q) * T * (Z1*Z)**H
     !! If Q1 is the unitary matrix from the QR factorization of B in the
     !! original equation A*x = lambda*B*x, then ZGGHRD reduces the original
     !! problem to generalized Hessenberg form.
               info )
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: compq, compz
           integer(ilp), intent(in) :: ihi, ilo, lda, ldb, ldq, ldz, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           complex(${ck}$), intent(inout) :: a(lda,*), b(ldb,*), q(ldq,*), z(ldz,*)
        ! =====================================================================
           
           ! Local Scalars 
           logical(lk) :: ilq, ilz
           integer(ilp) :: icompq, icompz, jcol, jrow
           real(${ck}$) :: c
           complex(${ck}$) :: ctemp, s
           ! Intrinsic Functions 
           ! Executable Statements 
           ! decode compq
           if( stdlib_lsame( compq, 'N' ) ) then
              ilq = .false.
              icompq = 1
           else if( stdlib_lsame( compq, 'V' ) ) then
              ilq = .true.
              icompq = 2
           else if( stdlib_lsame( compq, 'I' ) ) then
              ilq = .true.
              icompq = 3
           else
              icompq = 0
           end if
           ! decode compz
           if( stdlib_lsame( compz, 'N' ) ) then
              ilz = .false.
              icompz = 1
           else if( stdlib_lsame( compz, 'V' ) ) then
              ilz = .true.
              icompz = 2
           else if( stdlib_lsame( compz, 'I' ) ) then
              ilz = .true.
              icompz = 3
           else
              icompz = 0
           end if
           ! test the input parameters.
           info = 0
           if( icompq<=0 ) then
              info = -1
           else if( icompz<=0 ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( ihi>n .or. ihi<ilo-1 ) then
              info = -5
           else if( lda<max( 1, n ) ) then
              info = -7
           else if( ldb<max( 1, n ) ) then
              info = -9
           else if( ( ilq .and. ldq<n ) .or. ldq<1 ) then
              info = -11
           else if( ( ilz .and. ldz<n ) .or. ldz<1 ) then
              info = -13
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGHRD', -info )
              return
           end if
           ! initialize q and z if desired.
           if( icompq==3 )call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, q, ldq )
           if( icompz==3 )call stdlib_${ci}$laset( 'FULL', n, n, czero, cone, z, ldz )
           ! quick return if possible
           if( n<=1 )return
           ! zero out lower triangle of b
           do jcol = 1, n - 1
              do jrow = jcol + 1, n
                 b( jrow, jcol ) = czero
              end do
           end do
           ! reduce a and b
           do jcol = ilo, ihi - 2
              do jrow = ihi, jcol + 2, -1
                 ! step 1: rotate rows jrow-1, jrow to kill a(jrow,jcol)
                 ctemp = a( jrow-1, jcol )
                 call stdlib_${ci}$lartg( ctemp, a( jrow, jcol ), c, s,a( jrow-1, jcol ) )
                 a( jrow, jcol ) = czero
                 call stdlib_${ci}$rot( n-jcol, a( jrow-1, jcol+1 ), lda,a( jrow, jcol+1 ), lda, c, s )
                           
                 call stdlib_${ci}$rot( n+2-jrow, b( jrow-1, jrow-1 ), ldb,b( jrow, jrow-1 ), ldb, c, &
                           s )
                 if( ilq )call stdlib_${ci}$rot( n, q( 1, jrow-1 ), 1, q( 1, jrow ), 1, c,conjg( s ) )
                           
                 ! step 2: rotate columns jrow, jrow-1 to kill b(jrow,jrow-1)
                 ctemp = b( jrow, jrow )
                 call stdlib_${ci}$lartg( ctemp, b( jrow, jrow-1 ), c, s,b( jrow, jrow ) )
                 b( jrow, jrow-1 ) = czero
                 call stdlib_${ci}$rot( ihi, a( 1, jrow ), 1, a( 1, jrow-1 ), 1, c, s )
                 call stdlib_${ci}$rot( jrow-1, b( 1, jrow ), 1, b( 1, jrow-1 ), 1, c,s )
                 if( ilz )call stdlib_${ci}$rot( n, z( 1, jrow ), 1, z( 1, jrow-1 ), 1, c, s )
              end do
           end do
           return
     end subroutine stdlib_${ci}$gghrd

#:endif
#:endfor



     module pure subroutine stdlib_sggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
     !! SGGBAK forms the right or left eigenvectors of a real generalized
     !! eigenvalue problem A*x = lambda*B*x, by backward transformation on
     !! the computed eigenvectors of the balanced pair of matrices output by
     !! SGGBAL.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(in) :: lscale(*), rscale(*)
           real(sp), intent(inout) :: v(ldv,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, k
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( n==0 .and. ihi==0 .and. ilo/=1 ) then
              info = -4
           else if( n>0 .and. ( ihi<ilo .or. ihi>max( 1, n ) ) )then
              info = -5
           else if( n==0 .and. ilo==1 .and. ihi/=0 ) then
              info = -5
           else if( m<0 ) then
              info = -8
           else if( ldv<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'SGGBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward transformation on right eigenvectors
              if( rightv ) then
                 do i = ilo, ihi
                    call stdlib_sscal( m, rscale( i ), v( i, 1 ), ldv )
                 end do
              end if
              ! backward transformation on left eigenvectors
              if( leftv ) then
                 do i = ilo, ihi
                    call stdlib_sscal( m, lscale( i ), v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward permutation on right eigenvectors
              if( rightv ) then
                 if( ilo==1 )go to 50
                 loop_40: do i = ilo - 1, 1, -1
                    k = rscale( i )
                    if( k==i )cycle loop_40
                    call stdlib_sswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
                 50 continue
                 if( ihi==n )go to 70
                 loop_60: do i = ihi + 1, n
                    k = rscale( i )
                    if( k==i )cycle loop_60
                    call stdlib_sswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_60
              end if
              ! backward permutation on left eigenvectors
              70 continue
              if( leftv ) then
                 if( ilo==1 )go to 90
                 loop_80: do i = ilo - 1, 1, -1
                    k = lscale( i )
                    if( k==i )cycle loop_80
                    call stdlib_sswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_80
                 90 continue
                 if( ihi==n )go to 110
                 loop_100: do i = ihi + 1, n
                    k = lscale( i )
                    if( k==i )cycle loop_100
                    call stdlib_sswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_100
              end if
           end if
           110 continue
           return
     end subroutine stdlib_sggbak

     module pure subroutine stdlib_dggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
     !! DGGBAK forms the right or left eigenvectors of a real generalized
     !! eigenvalue problem A*x = lambda*B*x, by backward transformation on
     !! the computed eigenvectors of the balanced pair of matrices output by
     !! DGGBAL.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(in) :: lscale(*), rscale(*)
           real(dp), intent(inout) :: v(ldv,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, k
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( n==0 .and. ihi==0 .and. ilo/=1 ) then
              info = -4
           else if( n>0 .and. ( ihi<ilo .or. ihi>max( 1, n ) ) )then
              info = -5
           else if( n==0 .and. ilo==1 .and. ihi/=0 ) then
              info = -5
           else if( m<0 ) then
              info = -8
           else if( ldv<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward transformation on right eigenvectors
              if( rightv ) then
                 do i = ilo, ihi
                    call stdlib_dscal( m, rscale( i ), v( i, 1 ), ldv )
                 end do
              end if
              ! backward transformation on left eigenvectors
              if( leftv ) then
                 do i = ilo, ihi
                    call stdlib_dscal( m, lscale( i ), v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward permutation on right eigenvectors
              if( rightv ) then
                 if( ilo==1 )go to 50
                 loop_40: do i = ilo - 1, 1, -1
                    k = int(rscale( i ),KIND=ilp)
                    if( k==i )cycle loop_40
                    call stdlib_dswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
                 50 continue
                 if( ihi==n )go to 70
                 loop_60: do i = ihi + 1, n
                    k = int(rscale( i ),KIND=ilp)
                    if( k==i )cycle loop_60
                    call stdlib_dswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_60
              end if
              ! backward permutation on left eigenvectors
              70 continue
              if( leftv ) then
                 if( ilo==1 )go to 90
                 loop_80: do i = ilo - 1, 1, -1
                    k = int(lscale( i ),KIND=ilp)
                    if( k==i )cycle loop_80
                    call stdlib_dswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_80
                 90 continue
                 if( ihi==n )go to 110
                 loop_100: do i = ihi + 1, n
                    k = int(lscale( i ),KIND=ilp)
                    if( k==i )cycle loop_100
                    call stdlib_dswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_100
              end if
           end if
           110 continue
           return
     end subroutine stdlib_dggbak

#:for rk,rt,ri in REAL_KINDS_TYPES
#:if not rk in ["sp","dp"]
     module pure subroutine stdlib_${ri}$ggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
     !! DGGBAK: forms the right or left eigenvectors of a real generalized
     !! eigenvalue problem A*x = lambda*B*x, by backward transformation on
     !! the computed eigenvectors of the balanced pair of matrices output by
     !! DGGBAL.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${rk}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${rk}$), intent(in) :: lscale(*), rscale(*)
           real(${rk}$), intent(inout) :: v(ldv,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, k
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( n==0 .and. ihi==0 .and. ilo/=1 ) then
              info = -4
           else if( n>0 .and. ( ihi<ilo .or. ihi>max( 1, n ) ) )then
              info = -5
           else if( n==0 .and. ilo==1 .and. ihi/=0 ) then
              info = -5
           else if( m<0 ) then
              info = -8
           else if( ldv<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'DGGBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward transformation on right eigenvectors
              if( rightv ) then
                 do i = ilo, ihi
                    call stdlib_${ri}$scal( m, rscale( i ), v( i, 1 ), ldv )
                 end do
              end if
              ! backward transformation on left eigenvectors
              if( leftv ) then
                 do i = ilo, ihi
                    call stdlib_${ri}$scal( m, lscale( i ), v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward permutation on right eigenvectors
              if( rightv ) then
                 if( ilo==1 )go to 50
                 loop_40: do i = ilo - 1, 1, -1
                    k = int(rscale( i ),KIND=ilp)
                    if( k==i )cycle loop_40
                    call stdlib_${ri}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
                 50 continue
                 if( ihi==n )go to 70
                 loop_60: do i = ihi + 1, n
                    k = int(rscale( i ),KIND=ilp)
                    if( k==i )cycle loop_60
                    call stdlib_${ri}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_60
              end if
              ! backward permutation on left eigenvectors
              70 continue
              if( leftv ) then
                 if( ilo==1 )go to 90
                 loop_80: do i = ilo - 1, 1, -1
                    k = int(lscale( i ),KIND=ilp)
                    if( k==i )cycle loop_80
                    call stdlib_${ri}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_80
                 90 continue
                 if( ihi==n )go to 110
                 loop_100: do i = ihi + 1, n
                    k = int(lscale( i ),KIND=ilp)
                    if( k==i )cycle loop_100
                    call stdlib_${ri}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_100
              end if
           end if
           110 continue
           return
     end subroutine stdlib_${ri}$ggbak

#:endif
#:endfor

     module pure subroutine stdlib_cggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
     !! CGGBAK forms the right or left eigenvectors of a complex generalized
     !! eigenvalue problem A*x = lambda*B*x, by backward transformation on
     !! the computed eigenvectors of the balanced pair of matrices output by
     !! CGGBAL.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_sp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(sp), intent(in) :: lscale(*), rscale(*)
           complex(sp), intent(inout) :: v(ldv,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, k
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( n==0 .and. ihi==0 .and. ilo/=1 ) then
              info = -4
           else if( n>0 .and. ( ihi<ilo .or. ihi>max( 1, n ) ) )then
              info = -5
           else if( n==0 .and. ilo==1 .and. ihi/=0 ) then
              info = -5
           else if( m<0 ) then
              info = -8
           else if( ldv<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'CGGBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward transformation on right eigenvectors
              if( rightv ) then
                 do i = ilo, ihi
                    call stdlib_csscal( m, rscale( i ), v( i, 1 ), ldv )
                 end do
              end if
              ! backward transformation on left eigenvectors
              if( leftv ) then
                 do i = ilo, ihi
                    call stdlib_csscal( m, lscale( i ), v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward permutation on right eigenvectors
              if( rightv ) then
                 if( ilo==1 )go to 50
                 loop_40: do i = ilo - 1, 1, -1
                    k = rscale( i )
                    if( k==i )cycle loop_40
                    call stdlib_cswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
                 50 continue
                 if( ihi==n )go to 70
                 loop_60: do i = ihi + 1, n
                    k = rscale( i )
                    if( k==i )cycle loop_60
                    call stdlib_cswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_60
              end if
              ! backward permutation on left eigenvectors
              70 continue
              if( leftv ) then
                 if( ilo==1 )go to 90
                 loop_80: do i = ilo - 1, 1, -1
                    k = lscale( i )
                    if( k==i )cycle loop_80
                    call stdlib_cswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_80
                 90 continue
                 if( ihi==n )go to 110
                 loop_100: do i = ihi + 1, n
                    k = lscale( i )
                    if( k==i )cycle loop_100
                    call stdlib_cswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_100
              end if
           end if
           110 continue
           return
     end subroutine stdlib_cggbak

     module pure subroutine stdlib_zggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
     !! ZGGBAK forms the right or left eigenvectors of a complex generalized
     !! eigenvalue problem A*x = lambda*B*x, by backward transformation on
     !! the computed eigenvectors of the balanced pair of matrices output by
     !! ZGGBAL.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_dp, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(dp), intent(in) :: lscale(*), rscale(*)
           complex(dp), intent(inout) :: v(ldv,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, k
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( n==0 .and. ihi==0 .and. ilo/=1 ) then
              info = -4
           else if( n>0 .and. ( ihi<ilo .or. ihi>max( 1, n ) ) )then
              info = -5
           else if( n==0 .and. ilo==1 .and. ihi/=0 ) then
              info = -5
           else if( m<0 ) then
              info = -8
           else if( ldv<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward transformation on right eigenvectors
              if( rightv ) then
                 do i = ilo, ihi
                    call stdlib_zdscal( m, rscale( i ), v( i, 1 ), ldv )
                 end do
              end if
              ! backward transformation on left eigenvectors
              if( leftv ) then
                 do i = ilo, ihi
                    call stdlib_zdscal( m, lscale( i ), v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward permutation on right eigenvectors
              if( rightv ) then
                 if( ilo==1 )go to 50
                 loop_40: do i = ilo - 1, 1, -1
                    k = int(rscale( i ),KIND=ilp)
                    if( k==i )cycle loop_40
                    call stdlib_zswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
                 50 continue
                 if( ihi==n )go to 70
                 loop_60: do i = ihi + 1, n
                    k = int(rscale( i ),KIND=ilp)
                    if( k==i )cycle loop_60
                    call stdlib_zswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_60
              end if
              ! backward permutation on left eigenvectors
              70 continue
              if( leftv ) then
                 if( ilo==1 )go to 90
                 loop_80: do i = ilo - 1, 1, -1
                    k = int(lscale( i ),KIND=ilp)
                    if( k==i )cycle loop_80
                    call stdlib_zswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_80
                 90 continue
                 if( ihi==n )go to 110
                 loop_100: do i = ihi + 1, n
                    k = int(lscale( i ),KIND=ilp)
                    if( k==i )cycle loop_100
                    call stdlib_zswap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_100
              end if
           end if
           110 continue
           return
     end subroutine stdlib_zggbak

#:for ck,ct,ci in CMPLX_KINDS_TYPES
#:if not ck in ["sp","dp"]
     module pure subroutine stdlib_${ci}$ggbak( job, side, n, ilo, ihi, lscale, rscale, m, v,ldv, info )
     !! ZGGBAK: forms the right or left eigenvectors of a complex generalized
     !! eigenvalue problem A*x = lambda*B*x, by backward transformation on
     !! the computed eigenvectors of the balanced pair of matrices output by
     !! ZGGBAL.
               
        ! -- lapack computational routine --
        ! -- lapack is a software package provided by univ. of tennessee,    --
        ! -- univ. of california berkeley, univ. of colorado denver and nag ltd..--
           use stdlib_blas_constants_${ck}$, only: negone, zero, half, one, two, three, four, eight, ten, czero, chalf, cone, cnegone
           ! Scalar Arguments 
           character, intent(in) :: job, side
           integer(ilp), intent(in) :: ihi, ilo, ldv, m, n
           integer(ilp), intent(out) :: info
           ! Array Arguments 
           real(${ck}$), intent(in) :: lscale(*), rscale(*)
           complex(${ck}$), intent(inout) :: v(ldv,*)
        ! =====================================================================
           ! Local Scalars 
           logical(lk) :: leftv, rightv
           integer(ilp) :: i, k
           ! Intrinsic Functions 
           ! Executable Statements 
           ! test the input parameters
           rightv = stdlib_lsame( side, 'R' )
           leftv = stdlib_lsame( side, 'L' )
           info = 0
           if( .not.stdlib_lsame( job, 'N' ) .and. .not.stdlib_lsame( job, 'P' ) &
                     .and..not.stdlib_lsame( job, 'S' ) .and. .not.stdlib_lsame( job, 'B' ) ) then
              info = -1
           else if( .not.rightv .and. .not.leftv ) then
              info = -2
           else if( n<0 ) then
              info = -3
           else if( ilo<1 ) then
              info = -4
           else if( n==0 .and. ihi==0 .and. ilo/=1 ) then
              info = -4
           else if( n>0 .and. ( ihi<ilo .or. ihi>max( 1, n ) ) )then
              info = -5
           else if( n==0 .and. ilo==1 .and. ihi/=0 ) then
              info = -5
           else if( m<0 ) then
              info = -8
           else if( ldv<max( 1, n ) ) then
              info = -10
           end if
           if( info/=0 ) then
              call stdlib_xerbla( 'ZGGBAK', -info )
              return
           end if
           ! quick return if possible
           if( n==0 )return
           if( m==0 )return
           if( stdlib_lsame( job, 'N' ) )return
           if( ilo==ihi )go to 30
           ! backward balance
           if( stdlib_lsame( job, 'S' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward transformation on right eigenvectors
              if( rightv ) then
                 do i = ilo, ihi
                    call stdlib_${ci}$dscal( m, rscale( i ), v( i, 1 ), ldv )
                 end do
              end if
              ! backward transformation on left eigenvectors
              if( leftv ) then
                 do i = ilo, ihi
                    call stdlib_${ci}$dscal( m, lscale( i ), v( i, 1 ), ldv )
                 end do
              end if
           end if
           ! backward permutation
           30 continue
           if( stdlib_lsame( job, 'P' ) .or. stdlib_lsame( job, 'B' ) ) then
              ! backward permutation on right eigenvectors
              if( rightv ) then
                 if( ilo==1 )go to 50
                 loop_40: do i = ilo - 1, 1, -1
                    k = int(rscale( i ),KIND=ilp)
                    if( k==i )cycle loop_40
                    call stdlib_${ci}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_40
                 50 continue
                 if( ihi==n )go to 70
                 loop_60: do i = ihi + 1, n
                    k = int(rscale( i ),KIND=ilp)
                    if( k==i )cycle loop_60
                    call stdlib_${ci}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_60
              end if
              ! backward permutation on left eigenvectors
              70 continue
              if( leftv ) then
                 if( ilo==1 )go to 90
                 loop_80: do i = ilo - 1, 1, -1
                    k = int(lscale( i ),KIND=ilp)
                    if( k==i )cycle loop_80
                    call stdlib_${ci}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_80
                 90 continue
                 if( ihi==n )go to 110
                 loop_100: do i = ihi + 1, n
                    k = int(lscale( i ),KIND=ilp)
                    if( k==i )cycle loop_100
                    call stdlib_${ci}$swap( m, v( i, 1 ), ldv, v( k, 1 ), ldv )
                 end do loop_100
              end if
           end if
           110 continue
           return
     end subroutine stdlib_${ci}$ggbak

#:endif
#:endfor


end submodule stdlib_lapack_eigv_comp
